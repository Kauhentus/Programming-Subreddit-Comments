Feel free to write something down that provides some solutions for those issues. I'd like to reference then to your article or even develop a builtin solution into the process manager.
Your 'Content-Type' question for example.
&gt;PHP fakes a lot of stuffs,so it appeals to the java folks. Oh boy... *backs away slowly*
Make an html form, make sure the method is GET. When the form is submitted, the values of the form fields will be appended to the URL. In PHP, you would access those values via the $_GET[] array..
I think he's talking about GET..
Where I work we know about Laravel because we inherited a project written in L3, but otherwise I don't think anyone really knows about it. That said, I'm in Eastern EU, and only now am I starting to see Symfony mentioned in job offers. In my experience, people here stop reading tech blogs as soon as they find a solution to their current problem. Therefore, everything good that has happened with PHP in the last 2-3 years is mostly unnoticed. 
The architecture is an http server. That's what I'm asking about. If an http server is only useful behind another http server then it's wasting my time. If you don't know how to answer the questions don't pound the table and pretend like the person raising the questions is in the dark.
I guess I could find the lowest and highest date range and then loop through it by year and month.
Yes, it is a http server, but not to replace apache/nginx &amp; co but only to omit the expensive bootstrap. So, please stop pretend I've no answers to your questions. Your questions are mainly just the wrong ones as you haven't understood the point behind this approach.
If the problem is the expensive bootstrap then you should consider a solution that doesn't have an excessively expensive bootstrap. Recursively nesting servers is the last way you should approach removing an inefficiency in your software stack.
The answers are trivial. &gt; How do I deploy named virtual hosts on the same IP? Can I do this? Same as apache. The design is to put React BEHIND an nginx or apache. The number of questions asked show a complete ignorance to understanding the proprosed architecture (not that I've ever used it), which is straightforward. &gt; How about error logging? Request logging? Is this information written to the filesystem? How is any filesystem access performed without blocking the event loop? *facepalm* let's talk about the request. Your proxy can handle recording, but let's say you want the react nodes to do it. Ok, so write to a log? Throw an event to a ZeroMQ that writes to redis + whatever log processor. It's like you are asking "what about if I want to add 2 numbers!" &gt; Can I modify the SO_LINGER option on client sockets if I'm under a DoS attack to avoid having many thousands of leftover sockets in the TIME_WAIT state? A lot of your questions seem to drift toward DDoS mitigation strategies but you completely ignore the capabilities of having access to the connection at the socket level. http://www.php.net/manual/en/function.socket-set-option.php &gt; I could go on and on. It just looks like trolling from here. Edit: &gt; Can I accept chunked entity bodies in my requests? chunked requests and request body parsing are not implemented.
Ohwe. You can not just kill the bootstrap. Classes needs to be registered, connection needs to be built, service containers needs to be loaded, objects have to be instantiated etc pp. But this is not related to this topic. If you have a solution without such a bootstrap, write Symfony&amp;Co that do have expensive bootstraps. I highly doubt it.
Exactly. If you use ab to performance check your stack you are going to have a bad time on your productive servers. 
Interesting. I just started using Laravel. I think it's pretty nice. Before that I would just roll my own for the specific task at hand. I think Laravel has a lot in common with the things I made in the past. 
This is not really a problem in newer versions of PHP. A much *bigger* issue is PHP's inability to recycle resource IDs once used. If you run out of resource IDs you fatal. If you have a busy server in a 32-bit environment this is a real problem because every client connection is a resource ID. Factor in that you use a resource ID every time you open file handles, (some) db handles, etc and you're on a freight train headed for fatal land. This is an unavoidable problem that is currently unaddressed.
If you only have 1 stack, why use reactPHP at all? You have to drop all connections on a mass restart after any modifications, so it's not appropriate for single server setups! I get that. If you have multiple stacks (let's say 3), you can gracefully degrade and restart each stack for eventual consistency. Optimally, you want an independent messaging system for scheduling these events.
I get it. I'm asking questions about the server though. Is this a great solution if you have to compensate for a horrifically slow framework? Sure. But it would be a hell of a lot easier to not use the horrifically slow framework in the first place. I'm far more interested in the merits of the server that's in use.
I generally put my traits in either their parent namespace (in your case it would be Acme\Blog\Trait.php) or all of them in their own folder (since technically they are for cross-domain composition, e.g. Acme\Traits\Trait.php)
You can do this in pure SQL. select count(*) from my table where month(timestamp) = '1' and year(timestamp) = '2014' This is pseudo of course but you get the idea
(*facepalm*) Every more or less feature-rich framework needs a bootstrap. In all languages. But it looks like you just want to troll. It's your stage. Have fun ;)
&gt; The design is to put React BEHIND an nginx or apache. I'm asking about the react server. Can you answer any of those questions? Because if the solution is "put it behind a real server" then what's the point? &gt; Throw an event to a ZeroMQ that writes to redis Great! This is what I'm asking about! &gt; you completely ignore the capabilities of having access to the connection at the socket level Another real answer. We're getting somewhere. Now tell me, how does that work on an encrypted socket stream when you call [socket_import_stream](http://www.php.net/manual/en/function.socket-import-stream.php)? &gt; It just looks like trolling from here. If you call the expectation that HTTP servers be usable in the real world, sure. &gt; The answers are trivial. So you answered **one** of my questions? Got any more or are all the rest of my questions just fake troll concerns? This constant insistence that anyone pointing out deficiencies in an implementation is a troll is just not correct.
You could try and do the entire thing in SQL: SELECT CONCAT(RIGHT(varchar_date, 4),"-",LEFT(enterDate, LOCATE('/', enterDate)-1)) AS year_month, COUNT(*) AS entries FROM some_table GROUP BY CONCAT(RIGHT(enterDate, 4),"-",LEFT(enterDate, LOCATE('/', enterDate)-1)) ORDER BY CONCAT(RIGHT(enterDate, 4),"-",LEFT(enterDate, LOCATE('/', enterDate)-1)) Not sure how large your database is or how wise doing it this way would be.
Well, if you were storing your dates as dates, this would be a lot easier... but since they are varchar here is what I would do: //You will want a start/end date, I'm guessing first entry in the DB -&gt; Now. $start = earliest record in your db; $results = array(); //convert the date to date object with strtotime(), while($start &lt; now()) { // select count(*) from yourTable where data like '01/%/2014'; $results[date('Y-m',$start)] = "select count(*) from yourTable where date like '" . date('m',$start) . "/%/" . date('Y',$start) . "';" $start = $start + 1 month; } //Print it all out foreach($results as $date =&gt; $count) { print $date . " - " $count . "\n"; } The code is pretty rough, but I hope that gives you an idea.
+1 You should immediately discount any benchmark executed using `ab` ... for the uninitiated may I suggest [wrk](https://github.com/wg/wrk)
This seems incomplete, looks like the site is looking for certain keywords on social network profiles. I think using Google Trends as a data set would be more accurate. For example: http://www.google.ca/trends/explore#q=%2Fm%2F02qgdkj%2C%20laravel%2C%20cakephp%2C%20symfony%2C%20%2Fm%2F0cdvjh&amp;cmpt=q
(facepalm) You're missing the point. I'm not saying remove the bootstrap phase. I'm saying your bootstrap phase was programmed idiotically if it's so slow that you have to use a proxy server to work around the inefficiency.
Can you answer any of the other questions or not? Don't mistake ad hominem for being witty. No one is arguing against the efficacy of proxy servers.
&gt; then what's the point? Well, as I've assumed, you haven't understood the approach. Hint: NodeJS is behind a NGiNX too although they have a http server as well. But wait, that must be horrible wrong. All NodeJS developer are stupid as hell... You should tell them ;)
In Doctrine, its not a cache, nor is it something that you can really turn off. Doctrine keeps track of entities (known as "Managed Entities" so that it may track changes to them. (there's no save() or update() methods, nor anything that says "save this entity." It makes for simple, decoupled code-- at the expense of memory. Clearing all manages entities works well enough-- but that means you can't really reuse any Entities. You can detach specific entities, but you run into problems with relations lingering. Detaching all entities matching a class works much better-- but still has its issues. The big issues is reattaching specific entities isn't very pleasant-- particularly with relationships. So if there's any lingering detached entities, Doctrine's will likely complain, later.
Exactly, the whole Symfony framework is idiotically because it needs a complex bootstrap. ;)
I was actually thinking more of this: http://www.acme.com/software/http_load/ You can specify a list of URLs. But even that is not really benchmarking. I mean a real life application is just not that stupid. Think of conditions like: mobile, googlebot, i18n, l10n, etc. Some sub pages making more SQL queries, some less. If you only use ab you might have great results always retrieving the same URL as it gets cached (even on low level by your system). Use xhprof, check if the bottleneck really lies in your phpcode or because you have huge ass SQL queries.
So clearing all entities at the manager at the end of the request would work?
I store mine in my DNA (sorry I had to say that) Parent namespace seems to be a good place to put them. But not all projects are structured the same. Try to go for the path of least resistance. 
I wouldn't let that hold you back at all mate. I would be calling their bluff on this one.
If he wants to use php to solve it then I would do: $my_entries = array(); $query = "SELECT eventDate, count(eventDate) AS entries FROM table GROUP BY eventDate ORDER BY eventDate"; $result = mysql_query($query) while ($row = mysql_fetch_assoc($result)) { $key = substr($row['eventDate'],-4)."-".substr($row['eventDate'], 0, strpos($row['eventDate'], '/')); if (isset($my_entries[$key])) { $my_entries[$key] += $row['entries']; } else { $my_entries[$key] = $row['entries']; } } print_r ($my_entries); 
Mh, don't know the internals of Doctrine so I can't talk with you here. I'm using mainly Propel which works fine when you clear the 'instance pool' at the end of the request.
From the looks of the article, the author doesn't understand traits, nor when to use them properly. Those examples should really have been a class extending an abstract, not inheriting a trait.
lol
Selecting randomly from a database is done with "ORDER BY RAND()" at the end of a SELECT statement. I don't know if that's your play, though. With PHP you can store a lot of information in a session cookie, so keeping the entries in an array could work. Let's say you have $_SESSION['entries'][0] through $_SESSION['entries'][99] holding the entry names. When I enter "feather" and assign it 10%, then the script runs a foreach() on $_SESSION['entries'] and gives "feather" ten empty spots. When I enter "ball" and assign it 50%, then the foreach() will give "ball" 50 empty spots. You'll probably have to require the user to add entries until the percentages add up to 100, or provide a wildcard-type entry that affects the game somehow.
It is just me, I just prefix my traits with T, ie Acme\TBlog
&gt; Selecting randomly from a database is done with "ORDER BY RAND()" at the end of a SELECT statement. ... and is a great way to shit on your database performance. A better way to go about selecting a random database entry (assuming you have a sequential ID number you can select on) is to get the high ID, the low ID, generate a random number between those two values and select the entry that is &gt;= that value. This of course is not without its caveat, which is that if the range you're keying on has inconsistent gaps in its sequence you will get varying degrees of bias towards certain values.
&gt; Don't mistake ad hominem for being witty. It wasn't witty. It was mean spirited. It was a reflection your antagonistic attitude and backwards approach to dealing with people. It is not anyone's job to regurgitate the nginx or php docs because you feel entitled.
Youre welcome, I had fun writing it :D
niche corner. It's not a very well known framework -- I've never heard of it until just a few months ago.
I was going to take this article seriously until I saw the code examples were obviously written by coercing two feral cats to fuck on a keyboard. 
Doctrine is an awesome ORM, but it really needs bit better handling in these cases. If there were just a *good* way to refresh an entity, that'd at least help, but `-&gt;refresh($entity)` is only the beginning of the solution-- you have to specify a `cascade={refresh}` on nearly every relation-- which defeats the point a little as it'll probably run one query per relation (when it doesn't really need to except to satisfy Doctrine's weird behavior when it comes to refreshing entities). ^^Disclaimer: ^^Its ^^been ^^a ^^few ^^months ^^since ^^I've ^^messed ^^with ^^Doctrine ^^^I've ^^^just ^^^been ^^^busy ^^^with ^^^other ^^^things.
Along the same lines, they could count the # of items in the set (X), generate a random # between 1 and X (Y), then use select * from table limit 1 offset Y
Return type checking? You can do that...
Guys, its much easier than you think! I'm amazed by the number of loong and cooomplex ways to do such a simple thing! SELECT COUNT(*), RIGHT(`enterDate`, 7) AS d FROM table GROUP BY d;
Maybe you need to explain what you mean by this, because you absolutely can.
Makes sense to me, I use **NameSpace\iInterfaceName** for interfaces, so **NameSpace\tTraitName** seems fitting. Everyone's mileage will vary here - each to your own, but works for me.
I'd avoid doing that because you wind up scanning every row up to the offset. It's better to use a limiting factor that can be indexed.
Ahh, yeah. Would this still be more efficient than ORDER BY RAND()?
I asked you to clarify what you're talking about and you act like a toddler?
Just depends on the sample set. For example, here is a Google trends chart: http://d.pr/i/uONW/1XsUjUsI
It's not. It's for a game I'm making for a friend, but thanks for the accusation though.
No problem. It's always easy to accuse random people of stuff on the internet!
No, only traits is plural :/ I feel your pain. I couldn't figure out another way to do it, nor another name for the traits folder. https://github.com/titon/common/tree/master/src/Titon/Common Let me know if you think of something better, hah.
&gt; if the range you're keying on has inconsistent gaps Come to think of it, that might be a good answer too: id | Name 5 | Gold bar 55 | Banana If the ids are spaced out by weight then it should be a fast index lookup for the first item &gt; random number from [0,max(id)) eg select * from table where id &gt; floor(rand()*max(id)) order by id limit 1 maintenance of the list would be a nightmare though.
There is no reason why you should have traits with the name "Traits". This indicates that you haven't thought clearly enough about the name or that your traits are poorly designed. Traits are not meant to be a unnamed container of random methods. You wouldn't name a `class` "class" and you wouldn't name an `interface` just "interface" so why are you naming your traits this way? What do they do? 
folder plural and namespace singular
lol
&gt; since hhvm uses stream_select for the event loop Can you expand on this? What part of hhvm you're talking about here? The article's benchmarks say that it tested with no more than 100 concurrent connections. However, at that extremely low level of concurrency the system `select()` call and the epoll/kqueue abstractions underlying libevent are virtually indistinguishable. `select()` only slows down when asked to handle a high number of file descriptors.
Though I sometimes think it is over engineered Magento's architecture is amazing learning point for architecture. Its not a generic use case, its built with ecommerce web service in mind but you have to look into https://github.com/magento/magento2
Just a note, mysql's rand() is not cryptographically random. If the game involves money or anything of value consider using a different method. 
The question isn't about naming a trait `Trait`; it is about where should you store your trait. Say you have a trait, named `Hydrate`, which can populate properties using an array. You first write this Trait to use with your Models, which would allow you: $user = new User(); $user-&gt;hydrate(['username' =&gt; 'baileylo']); You originally store this trait in `App/Model/Hydrate.php`. This kind of makes sense until you decide you want to use this trait elsewhere, maybe in `App/Config/Config.php`. Now all of a sudden you have this class defition: &lt;?php namespace App\Config; class Config { use \App\Model\Hydrate; } Ss you should be able to see, the file location and namespace of `Hydrate` no longer makes sense. And this is where my question came from: "Where should I store the trait?". I suggested storing it in `App\Trait` as a namespace. So the full class name would have been `App\Trait\Hydrate`. But this cannot be done since `Trait` is a reserved word and can't be by itself in a namespace.
If it's just the name that bothers you, I believe "mixin" is a decent synonym.
Laravel.io and laravel-tricks.com are both open source on github. 
&gt; I suggested storing it in App\Trait as a namespace. I can use the same argument: You don't put interfaces in `App\Interface` or classes in `App\Class` so would traits be different? You could be really uncreative and call the namespace `Utils` so the trait is `App\Utils\Hydrate`. Or just put in the `App` namespace directly and be `App\Hydrate` as there's no chance of naming conflicts. `Hydrate` is pretty simple example of a trait, but a more complex trait might also be related to other classes or interfaces -- all of which should be contained in the same namespace. 
I was going to come in here and say that you need [Bolt](http://bolt.cm), but it's already on your list. It literally satisfies all the requirements you listed. Are there any specific concerns you might have that make you feel that Bolt might not suit your needs? ^disclaimer: ^I'm ^one ^of ^the ^devs ^of ^Bolt.
I would suggest using a MD5 or SHA-256 digest as a key for either 128 and 256 bit keys, so no padding is needed.
This is exactly what I was going to say. Business logic shouldn't be in traits. If the PHP language was perfect then we probably wouldn't need to use traits. Traits are a way to work around not being able to do something in the PHP language. Whenever you're about to use a trait, have a think about whether it might be possible to use composition instead.
I don't really care if you're part of PHP team or not. There're unfortunately some guys that aren't able to communicate and discuss stuff pleasant. Instead, writing provoking questions, answering like a ignorant and being arrogant is their way to go, so yours. It's a shame that especially you, with your arrogant and antagonistic attitude, are a part of the PHP team.
Credits doesn't matter. If you write nonsense, then you write nonsense. Doesn't really matter if you think you're elite.
Thanks for your response. Bolt looks good on paper and definitely caught my attention. It's on my list to install and evaluate. I just wanted to reach out to the community for additional suggestion so that I can carve out an appropriate amount of time to evaluate all potential options. I'll reach out again in a few days if I have any questions, concerns about Bolt.
Could it be the case that questions you see as irrelevant are actually relevant if you take the suggestion that using an event loop/nbio in your PHP applications is viable way to serve production websites seriously !? That wasn't a question, that _is actually_ the case. If you could answer the questions Daniel proposed satisfactorily then you would have something robust on which people could actually rely. The basic problem here is that Daniel does takes the idea seriously, he tried to point out the things you need to think about, having spent a long time thinking about them for himself, and you, for some reason, seem to have taken offense to that. This isn't very productive. Someone who is both arrogant and ignorant, isn't actually engaging anyone on reddit, just an observation ...
I've wrote several times in the article that there's a 'real' web server in front of react. Why rdiowrey want now use the setup without it and ask questions about a total different setup shows me he doesn't care about the actual idea but only want to bash.
That's how you chose to read it, to me, it seems his head went straight to the optimal solution and asked relevant questions ... I don't see what's arrogant, or ignorant about that, he took it seriously, he really did ... It is the optimal solution, why have that layer there at all, PHP is extremely good at sockets and parsing strings, which is as near as makes no difference all you need, why stick a process infront of your process when the solution could be robust enough to not even require it ...
Real programmers use butterflies!
The kind of network infrastructure I have in my head, is pretty much the one that a lot of us use now, we use dedicated php servers, content isn't even served by the same machine. If you're going to replace the most performant setups that exist now, then you need to be able to standalone, and to standalone, you need to have answers to all those questions ... Setting up virtualhosts is among the questions he asked, what we're trying to say is that _if_ you can find good answers to those questions and implement solutions, what you have then would be optimal, whether or not you choose to deploy from behind a proxy or not is not all important, the ability of the software is ...
Thanks for the suggestions! PageKit and October look impressive. It's too bad they're both still in development mode. Do you know if either has a Beta (or development) release available? October has an empty Git(Hub) repository and PageKit doesn't seem to have one at all. How do they expect to get early adopter feedback? Not sure either is far enough along to be of immediate help; perhaps I'll consider them for future project.
However you opinion is here: php with libevent is 300req/s faster than without it in this test. Since hhvm does not support libevent and it's exactly 300 req/s slower it is obvious which slowed it down.
Pfft, a serious benchmark would include test results using frameworks from other worlds too ...
https://github.com/brightmarch/major-api is the best open-source example I know of.
+1 on bolt ^disclaimer: ^I'm ^not ^one ^of ^the ^devs ^of ^Bolt.
This map uses a very poor data set. Is there an explanation of how it works anywhere? It gives Symfony a 0 for London, even though London is the home to a number of large Symfony outfits. Oh I get it now, it only searches through it's own members profiles? 
I learnt a lot from going through Zend Framework code and more simplistically, Opencart.
Update: I *tried* to post it on the site as well, but got this message: &gt; Notice: It seems you have Javascript disabled in your Browser. In order to submit a comment to this post, please copy the code below the form and paste it along with your comment. Yes, javascript is enabled. You might want to look into that. 
Most websites out there don't use CDNs. And even then would NGiNX be better as load balancer for all ReactPHP workers. The answer to almost all question is: Use NGiNX or whatever in front of it. The idea behind the php-process manager is only to spawn workers, the load balancer is optional and how the benchmark has shown: php is too slow to act as a load-balancer.
You should not do that. Either you generate a cryptographically strong key right away, or you use a password and derive the key using a KDF. Plain MD5 is *not* a good KDF. However you *can* use MD5 as the primitive in PBKDF2 or similar.
I feel obliged to point out that /u/rdlowrey is one of about 1.5 people with significant experience in writing high-performance asynchronous HTTP servers in PHP. It's very sad that you discount valuable feedback like this. If the top expert in an area takes the time to comment on your work, you should appreciate the feedback, rather than trying to find some kind of offense in it.
I give a +1 on this strategy. Entities bridge the gap between database and code by providing objects, repositories contain common query logic associated with a given entity, and managers introduce business functionality using the repositories.
[KnpMenu](https://github.com/KnpLabs/KnpMenu) along with [KnpMenuBundle](https://github.com/KnpLabs/KnpMenuBundle) are fairly good reads. No validation, but lots of "domain" logic. I think studying what they chose to put in the "core" library vs. symfony specific integration is very interesting. &gt; It kind of has the opposite problem of #3 mentioned above. Some of its service-y stuff is happening in the controllers, ie. when registering a user: validation, firing events(for sending a confirmation email), saving the user. I suspect you'll find this everywhere. Controllers are at the edge of your system. They're where your domain logic touches the real world (and your framework of choice), so it make sense that all the "glue" exists there. You can make your controllers much more natural looking, however, by [treating them as services](http://symfony.com/doc/current/cookbook/controller/service.html) where you pass in dependencies instead of relying on the container. Once that's done, you start looking at what sorts of objects you pass into controllers and how those could be refactored into objects that represent common patterns and things that make more sense for your specific domain. For example, you can see certain parts of of FOSUserBundle where it would be helpful to write small adapter classes. Every controller [does this](https://github.com/FriendsOfSymfony/FOSUserBundle/blob/master/Controller/ChangePasswordController.php#L81-L84), for instance. It would make sense to write small template adapter that had the templating engine along with the type of templating injected as dependencies. Then hide that implementation behind an interface. Want to use the FOSUserBundle controllers elsewhere -- not symfony? Just write your own template adapter. That sort of refactoring can be continually applied until only a small portion of your application touches external code and the real world. Whether or not that makes a lot of sense depends on the application. For most symfony apps, it doesn't. Controllers are meant to be used with Symfony and most bundles treat them as the edges of the system with no need for further abstraction. It's a balance of developer taste and application needs.
I like the idea of managers. I think i'm struggling with where the validation should go. Say I have a Project model, so i would have a ProjectManager. I have two separate validation objects for creating and updating a Project. Should those validation objects be inside the ProjectManager or should that occur outside of the manager and the manager ONLY deals with models and not raw input(an array) to hydrate a Project? Should a client class be responsible for validating the raw input, getting a fresh Project from the ProjectManager, hydrating the project, then handing it back to the ProjectManager so it can assign the Creator, queue an email, create Roles and Permissions, etc.?
Yeah i tried to think of how i could reuse the FOSUserBundle controller with adapter code but there certain points where a Response potentially could be returned: [for example](https://github.com/FriendsOfSymfony/FOSUserBundle/blob/master/Controller/RegistrationController.php#L50) on lines 50, 67, 72, and 76 of the user registration controller. I could probably do it by creating listeners for each of those events and create new json or xml responses but it was easier to just mimic that flow in my own service class. 
It's ok to me that you think he's an expert in your eyes. Whatever he is, I don't care actually and it doesn't really matter. It only matters what he's writing/asking and that what he wrote makes no sense to me as it's based on the wrong assumption. So it's **not** a valuable feedback for me.
You're right, although you can still make it work, it deserves a mention: https://github.com/leedavis81/vent#but-you-stole-my-magic
I wouldn't have thought you were targetting most websites ... if you want to push the boundaries of what is possible you must first approach those boundaries, infrastructures under extreme pressure do use cdns and spread out across multiple machines and even networks, so it's not enough to say that most websites out there don't have _____, since we're not talking about most websites ...
Thank you for this good comment on how to apply this properly.
Maybe i misunderstood the title, but are you specifically looking into DDD? Or just 'good architecture' per se?
Thank you! This may be a very valuable suggestion for people that need to encrypt binary files.
Man, what am I reading? Good work on ReactPHP! Some of these guys are comparing it to some other software that does other things albeit in a similar vein. I don't think that's fair. There has been some discussion about the validity of those benchmarks. If this holds up in real-world scenarios, you are on to something, buddy. I hope you keep up the good work.
Bolt is built using [Silex](http://silex.sensiolabs.org/) I believe, which is one of the items that I have been looking into recently for small projects. So not only is there documentation for Bolt, you can read about the Silex documentation as well.
That is correct: Bolt is built on Silex, and uses a bunch of Symfony components as well. If you're writing an extension, you can basically do whatever Silex provides for you, on top of the Bolt-specific stuff. 
This logic is ... well ... quite flawed. Most importantly HHVM and your react server are not doing the same things. For example, HHVM is doing all the (decidedly non-trivial) work required to act as a real HTTP server (see my list of questions) without having the safety of another web server in front to protect it. Meanwhile your react server is conveniently skipping all of this logic. Blaming `select()` for this difference is a basic misunderstanding of what's happening under the hood. A scientific experiment has exactly one variable and this benchmark has many. I'm simply trying to demonstrate that there is more at play here than `select()` vs. libevent.
Just to let you know the L4withSentry project is being served as a package for composer as [Sentinel](https://github.com/rydurham/Sentinel). I've also been implementing it recently and expanding it to support oauth.
&gt; http://phrocco.info/ A++ Great product, would write documentation with again.
Take a look at [Sylius](https://github.com/Sylius/Sylius). It is an ecommerce solution built on Symfony2.
well damnit...haha. I'm glad you posted these. It makes sense. I'm starting to think i want to do something like below which gives me the option to eventually create a facade/manager: interface ProjectCreatorInterface { public function createProject(ProjectInterface $project); public function newProject(); } class ProjectCreator implements ProjectCreatorInterface { protected $projects; protected $users; protected $roles; protected $transactor; public function __construct ( ProjectRepositoryInterface $projects, UserRepositoryInterface $users, RoleRepositoryInterface $roles, TransactorInterface $transactor ) { $this-&gt;projects = $projects; $this-&gt;users = $user; $this-&gt;roles = $roles; $this-&gt;transactor = $transactor; } public function newProject() { return $this-&gt;projects-&gt;newProject(); } public function createProject(ProjectInterface $project) { //business logic that uses $users, $roles, $transactor } } interface ArrayCreatorServiceInterface { public function with(array $input); public function isValid(); public function getErrors(); public function create(); } class ArrayProjectCreatorService implements ProjectCreatorInterface, ArrayCreatorServiceInterface { protected $validator; protected $creator; protected $input = []; public function __construct(Validator $validator, ProjectCreatorInterface $creator) { $this-&gt;validator = $validator; $this-&gt;creator = $creator; } public function with(array $input) { $this-&gt;input = $input; } public function isValid() { return $this-&gt;validator-&gt;validate($this-&gt;input); } public function getErrors() { return $this-&gt;validator-&gt;getErrors(); } public function create() { $project = $this-&gt;newProject(); //map array data to $project $this-&gt;createProject($project); return $project; } public function createProject(ProjectInterface $project) { $this-&gt;creator-&gt;createProject($project); } public function newProject() { return $this-&gt;creator-&gt;newProject(); } }
This is very interesting. Thanks a lot. I see all of the domain logic is accomplished with events. Hmm..
Annotations for everything in our shop. 
I use annotations exclusively. The hassle of opening multiple files just to see your mapping information is totally unwarranted.
Do you use annotations for routing and templating as well? Or just for entities?
What about routing? 
Check out teamtreehouse.com. you won't get a cert from them but you will have a public profile that tracks your progress and shows what you've completed. 
I prefer writing pure PHP configurations - which is why I dislike both YAML and Annotations. With that said, I tend to choose which one to use based on the scenario. With Entities, I use annotations because the domain logic (relationships, field types, etc) couples closely with the entity code. For routing, I'll use configuration files, since I'd rather have my routing code available in a single place rather than per controller. It tends to be a serious pain in the ass to track down a route definition using annotations, whereas I could just look in "routing.yaml". All in all, I would say it depends on the context, and it's fine to use a combination of both, as long as it's documented and the people working on your project know.
I guess it makes sense, especially since you can run the router:debug if you want to find anything, but doesn't that complicate things in a larger application? 
As long as you're disciplined about organizing the project, it won't. I favor fairly thin controllers with most logic living in services, repositories or a base controller class. I find that routing is actually a good way to organize your controllers, so I will usually create a distinct controller or even a distinct bundle for each top level route. e.g. administration functionality lives under /admin and has its own controller. Then just declare a base route above your controller class and off you go.
&gt; http://www.slideshare.net/andreizm/the-good-the-bad-and-the-ugly-what-happened-to-unicode-and-php-6 It would be interesting to theorize what would have happened if they had chosen utf-8 rather than utf-16. Although there are some specialist application that would be better off using utf-32, the vast majority of websites accept utf-8, display utf-8 and store everything in utf-8. Although it must suck for those people who had been working on it for so long, using utf-16 internally is (in retrospect) clearly the wrong choice, but it's hard to see if using utf-8 would have made the other problems solvable. 
Sorry rdlowrey, you're again following the wrong assumption. I haven't used the hhvm http server. I've started the react process manager in one test with `php ./bin/ppm start ...` and in other test `hhvm ./bin/ppm start ...`. So they do basically the same thing and my theory is in my eyes still logical.
It's paid because you're getting high quality videos from professionals in the field. You get more than what you pay for with treehouse. 
A few, not open-source though. http://pipestack.com/ http://buildwithcraft.com/
There is practically zero useful information in this blogspam. All you've done is copy-pasted a few charts of how often various frameworks (that you've heard of) have been searched for.. no analysis, no comparisons, no opinions. You'd not even heard of Zend Framework? I'm betting you've never written more than a couple lines of code in most of these frameworks, if you've even so much as installed them, or maybe you've just &gt;made my list from the general sentiment I got from sites like NetTuts+ and SitePoint. Jeez.
https://github.com/fabpot/sami
Slide 84 stung a bit: &gt; Clearly, the Unicode/i18n implementation wasn't exciting enough to be viable. Of all the PHP developments that we've come to enjoy over the years, the movement towards Unicode/i18n was the most exciting thing ... to wish for. Did I publicly express that? No. Slide 79 sums it up: &gt; Probably &lt;10 people understood the intricacies of the Unicode and ICU. Yeah, Unicode is one of those things that I would LOVE to learn the intricacies about... but don't seem to end up having the time at the end of the day.
Yaml here, I very rarely use the entity generator.
In order of importance. 1. Has it got the features I need? 2. How good are the docs? 3. How big is the community/ how old is it? i.e. How easy will it be to google for a solution to a problem someone else has probably already had. 
[Link about EllisLab looking for a new owner for CI to rejuvenate it.](http://ellislab.com/blog/entry/ellislab-seeking-new-owner-for-codeigniter)
too bad the [demo](http://demo.sylius.org/) doesn't work. Boo
Annotations, in my opinion, creates more coupling with Doctrine. I like to avoid coupling, so I generally go with YAML.
Working fine on my end. I did look closer at both php.net and nettuts and found that both use Source Code Pro. If you have a local copy of that font, try reinstalling it, or uninstall it completely. 
Oh I totally installed that font a few weeks ago. That must be it
Must be.
I find lack of unit tests disturbing. I was happy to find codeception.yml but... then no tests. 
TL;DR somebody benchmarks how long it takes PHP-FPM &amp; APC to include the bazillion files in the bloated Symphony project on every request. Benchmark flawed.
You've done two things wrong. The first is not storing dates as dates. That should be fundamentally obvious. I don't want to be the "you're doing it wrong" guy, but the fact is you **are** doing it wrong. If you had the right field type this would be a trivial exercise. The second mistake is that even doing it in the wrong field type this could still have been done rationally. m/d/y is an asinine format for numbers, imo ever but certainly from a technical point of view. The standard way to write a date is YYYY-MM-DD. This has the advantage of being self sorting. How do you order by your dates? Fact is you can't. It's basically a random string. But most particularly has the advantage that you can break it down easily. Want the entries from a particular year? `LEFT(enterDate, 4) = 2012` Want the entries for a particular month? `LEFT(enterDate, 7) = 2013-07` What you've done here is the worst of all worlds. It's not a date column. It should be. It's not a YYYY-MM-DD string. It should be. It's not even zero padded. Any of the above would make this easy. The problem is hard because the data is stupid. So the answer has to be stupid as well. The stupid answer while($row = mysqli_fetch_array($thisData)) { // logic for finding year/month and adding to the array. list($month, $day, $year) = explode('/', $row['enterDate']); $month = str_pad($month, 2, '0', STR_PAD_LEFT); // there's probably a better way to do this // this is just a dirty solution $dateArray[$year.'-'.$month][] = ''; } ksort($dateArray); $date = '2013-06'; echo $date . ' - ' . count($dateArray[$date]) . ' entries'; This is a shit solution. If you use it, you're a bad programmer.
I'll go out on a limb and suggest it is because it is a giant steaming pile of unmaintainable shit? And every customization ever thrown at a wordpress installation is infected by it's terrible design. also Object-oriented? where? the whole core of the thing is a procedural blob. There might be objects in there somewhere but it is hardly a modern object oriented application. Oh and while we're at it, not a CMS. Its a blog platform that people have coerced into other roles. Sure it can do content management, but it does a pretty terrible job at it. Seriously, Wordpress needs to die in a fire.... Sure you can make it do whatever you want but the effort involved next to something which is, you know, **well designed** is enormous.
use github wikis. I think you're looking for a place to put examples and some words about your code, not just automatically generated docs, so the documentation generators will only get you so far. they're not a bad idea to use as a supplement though.
I would like to add some more 1.a ) can I resuse the components in another project without making use of the whole framework. ( Helps in refactoring / modifications / new feature implementations ) 3.a ) I could not resist on the community. It will start growing one day or the other. The thing is whether the open-source project is maintained. If you are good in coding you should not resist in checking the 3rd point. Dive into the code and build it, google is not always the answer for the solution. Checking the api's help more. That said, have a look into http://auraphp.com/ if you are interested.
Good one man!
Yes. Unless the class already extended something, or you want to "extend" from multiple classes by using multiple traits.
Seconded, we use annotations for everything. Compared to Symfony 1.x it feels so much cleaner.
Try `var_dump($_POST):` at the top of your submit script. I have a feeling that will reveal to you what you're missing. ;) Now, please rewrite anything that is using the mysql_* functions. These have been deprecated for years and break things. You are only harming your progression as a PHP developer by using them. Check out the PDO API. It is very similar to the MySQL API, and not at all hard to use. Secondly, learn how to use parameterized queries with PDO. It is the only correct way to protect yourself from SQL injection. Good luck!
INSERT INTO days (id,start,end,note) VALUES (1,blah,blah,blah), (2,blah,blah,blah), (3,blah,blah,blah), (4,blah,blah,blah) ON DUPLICATE KEY UPDATE start = VALUES(start), end = VALUES(end), note = VALUES(note); Essentially, it's an insert statement with a catch to just update if the record already exists. running one query as opposed to multiple saves time, processing power, etc.
In my defense, I did not say anything negative about Wordpress in my OP. All I said was that I don't have the bandwidth to sit down and learn all the intricacies involved in a system like WP. The general sentiment that I've received about WP is that it's very powerful. But, more often than not, "powerful" is code word for either very complex and/or requiring a substantial learning curve. As I said in my OP, I simply don't have time to learn a complicated system. I need to get the site up-and-running in a matter of days and my best chance to accomplish that is by leveraging skills, tools, libraries I'm already familiar with. (seems like you understand my situation based on your edit). Thanks for your input.
@bopp, Bolt is looking really good so far. Seems like something I can wrap my head around and be productive within a day or two. The only immediate concern I have is that the out-of-the-box installation directory structure doesn't seem to follow best practices (or at least not the ones I'm used to following). Will Bolt continue working if I move the the app/ and vendor/ directory outside of the public docroot? I suppose I can set up .htaccess files to prevent access from those directories worst case scenario, but this approach doesn't feel warm and fuzzy to me.
I spent about 2 hours with a very knowledgable programmer friend on screenshare who helped me arrive at this conclusion: if ($_SERVER["REQUEST_METHOD"] == "POST") { $datas = array(); $datas[0] = array( //Sunday "start" =&gt; $_POST["sundaystart"], "end" =&gt; $_POST["sundayend"], "note" =&gt; $_POST["sundaynote"] ); foreach($datas as $data_day =&gt; $data) { $sql1 = "UPDATE days SET start='".$data['start']."', end='".$data['end']."', note='".$data['note']."' WHERE id=0"; mysqli_query($con, $sql1); mysqli_close($con); } header("Location: editor.php?status=sent"); } ?&gt; And it actually works! Woo!!! Now I just need to clean up the query when it is submitted to avoid exploits. Oh and obviously add the rest of the array for the rest of the week.
When we were first building Bolt, we made a design-decision that we wanted Bolt to be usable for a wide range of people. One of the scenarios we had in mind was that it should be easy to set up for people with less knowledge of PHP (read: _Front-end developers_) and less-than-optimal hosting (read: _shared hosting_). In many of those cases it's not really possible to move `app/` and `vendor/` outside of the root. I understand your point of view, and I agree with it, but at least there is some reasoning behind it. :-) That said, if you have installed bolt using the distro from the site, you should already have a `.htaccess` in `vendor/` that prevents access. See also [#882](https://github.com/bolt/bolt/issues/882). There are some files in `app/` that need to be accessible (like .js and .css files). Other files in there you do _not_ want accessible, like the config files in `app/config/`. We've taken care to make sure they really are not. And, if you want, you _can_ move the `app/config/` folder outside of your webroot, and Bolt will still pick it up. I do expect this is something that will change in the near future, though. There's been a ticket for a while ([#475](https://github.com/bolt/bolt/issues/457)) and people are actively working on getting Bolt to work smoothly when installed via Composer as part of 'vendors' ([#894](https://github.com/bolt/bolt/issues/894)). Hope this helps! 
I wrote a simple cms a few years ago when I wasn't quite as competent as I am now (never marketed it, and this site is broken): http://vesselcms.com/ I'd be happy to send your a free zip, but there are definitely better options as others have mentioned (bolt is nice). I'm finishing up a huge project in laravel at the moment and in a few weeks I'm going to begin the new project of completely redoing Vessel from the ground up in laravel. There are definitely lots of nice CMSs popping up these days...I'm very excited to see where October CMS leads especially. The philosophy with my original CMS was for it to take minutes to integrate into an existing html template --- perfect for front end developers who very well might not have a clue about &lt;?php ?&gt;. I want to keep this concept, as well as integrate many of the features you listed above, especially composer integration. I'm aiming for a beta by summer.
I read that same article(2nd link) as well. I found it on Hacker News.
Thanks for the quick response and for linking to the related GitHub issues. Seems like plenty of others folks have the same mindset as mine and that work is underway to fix this issue. Pretty much everything else about Bolt matches what I'm looking for. Normally I wouldn't look past potential security issues, but I'm willing to make an exception here since it seems like measures can be put in place to lessen the security vulnerabilities in the default installation directory structure. Not to mention this may be my only hope of getting this site up-and-running in a few days. I'll keep any eye on those GitHub issues and perhaps even involve myself in the conversation/fixes. Thanks! 
Your very knowledgeable programmer doesn't know shit. That code is awful and very open to exploits.
I didn't know they'd included unicode identifiers. From a purely selfish standpoint I'm kinda glad the project didn't succeed. Having fixed more than a few lines of outsourced code, I can't imagine the fun of having to deal with half of it in Cyrillic or hanzi on top of all the other badness.
Assuming you do clear up any security flaws, you could speed your coding and save your self a bit of time by creating an array of data on your input form. Take this entry for your Sunday services, the key property here is the name field. &lt;tr&gt; &lt;td&gt;Sunday:&lt;/td&gt; &lt;td&gt;&lt;input name="sundaystart" type="text" id="sundaystart" value="&lt;?php echo $days[0]['start']; ?&gt;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="sundayend" type="text" id="sundayend" value="&lt;?php echo $days[0]['end']; ?&gt;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="sundaynote" type="text" id="sundaynote" value="&lt;?php echo $days[0]['note']; ?&gt;"&gt;&lt;/td&gt; &lt;/tr&gt; If you change your name field to the following &lt;tr&gt; &lt;td&gt;Sunday:&lt;/td&gt; &lt;td&gt;&lt;input name="days[0][start]" type="text" id="sundaystart" value="&lt;?php echo $days[0]['start']; ?&gt;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="days[0][end]" type="text" id="sundayend" value="&lt;?php echo $days[0]['end']; ?&gt;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="days[0][note]" type="text" id="sundaynote" value="&lt;?php echo $days[0]['note']; ?&gt;"&gt;&lt;/td&gt; &lt;/tr&gt; You can iterate the out put of the form and iterate through the database entry. On your form: foreach ($result as $key =&gt; $day) { ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$day['day']:&lt;/td&gt; &lt;td&gt;&lt;input name="days[&lt;?=$key?&gt;][start]" type="text" id="sundaystart" value="&lt;?php echo $day['start']; ?&gt;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="days[&lt;?=$key?&gt;][end]" type="text" id="sundayend" value="&lt;?php echo $day['end']; ?&gt;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=""days[&lt;?=$key?&gt;][note]" type="text" id="sundaynote" value="&lt;?php echo $day['note']; ?&gt;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php } and on your input //CLEAN UP DATA AND PUT THE RESULTS IN AN ARRAY CALLED $days foreach ($days as $key =&gt; $day) { $sql = "INSERT INTO `days` SET `start`= {$day['start']}, `end` = {$day['end']}, `note`={$day['note']} WHERE id = {$key}"; // EXECUTE COMMAND HERE } I hope this isn't confusing, your way works so stick with it if you prefer, but it's always better to try to reduce lines of code and optimise as much as possible. Also as has been noted, CLEAN YOUR INPUTS. Never, ever, ever, ever trust inputs :) EDIT: Also I noticed in this new code, your friend has stopped using PDO. DON'T! PDO is excellent and has better features and support in the future.
To be fair, the OP did say this at the bottom of his comment &gt; Now I just need to clean up the query when it is submitted to avoid exploits. Oh and obviously add the rest of the array for the rest of the week 
I didn't really look at the code, but I did look at the scroll bar. It's way too large ;) Parsing HTML correctly is very non-trivial. Thankfully, as of HTML5, there is a formalized parsing algorithm for HTML that you "just" need to implement. Here's the beginning of the relevant part of the WHATWG spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html. It continues in the next sections on "Tokenization" and "Tree construction". But let me warn you right away that properly implementing this will take you more than just two days ;) As far as performance is concerned, you should definitely split up the tokenization and parsing stages. Doing both together is not very performant ;) If you're interested in fast lexing, you can take a look at the implementations provided here: https://github.com/nikic/Phlexy
Hold on though, OP is clearly a non-programmer. They are using PHP in a non-programmer way for a tiny tiny tiny app, all I would want from him is that it works and it's not horribly insecure. As long as OP cleans up the inputs, there is nothing wrong as such with that code. In my response, I suggested changes that could lead OP into further optimisation and study. All you did was criticise his friend and his code. For all you know his friend just threw a bit of code at him so he could learn, rather than overwhelming OP with trouble. What do you want? A full laravel distro with a Nginx stack?? Also as in the original text OP was using PDO, now he's not. Would not your post be better commenting about that rather just being negative. If you want to encourage new programmers and encourage learning, you have to actually be encouraging.
Others have already helped plenty. I was just pointing out that the final code isn't good and that their friend probably shouldn't be trusted.
I guess you can [clone it](http://stackoverflow.com/questions/15080848/how-do-i-clone-a-github-wiki) so you can keep full backups of all the info, and its just markdown I think so you can convert it to HTML as well.
Don't take this too hard, but… First impressions: You should probably look into MVC frameworks, or at least separation of concerns or some proper templates. Your index.php is a mix of definitions and side effects, and throwing HTML straight out, too? Pretty hard to work with.
Okay, so insert into a temp table, then do an update on a join between the two tables. Acceptable?
Okay, so remove the HTTP server from the equation -- the basic problem of select not being the only variable in play here applies all the same. Let's just assume that there is not enough difference between `select()` and libevent at this low level of concurrency to justify that explanation (this isn't really up for debate). Do you have any thought on what else might be responsible for the difference? I'm simply trying to make sense of what's causing the difference because it's not the perceived slowness of `select()`.
Separation of concerns is a general programming concept which basically means building an application using a set of separate, reusable, interchangeable components. A simple example relevant to your case would be separating the program logic from it's presentation. Anther would be your splitting your Site class into multiple classes, because it is like a miniature 'god' class due to having a whole bunch of responsibilities from getting categories to creating and authenticating users. Check out some OOP theory for more info. I would also recommend looking into a modern PHP framework in order to bring some order to your code. Frameworks can help encourage OOP practices and separation of concerns, and you'll also be able to build complex functionality much quicker than starting from scratch once you get to grips with the basics.
Go with ajax, pass the data via json. If the data doesn't change frequently, make sure your PHP endpoint is telling the browser that the response is cacheable.
Thanks for your opinion. I know when I was starting out I would have liked a high level look at what's "hot" in the PHP world when I was looking for a framework. Maybe your past that point so this bothers you and in that case I'm sorry to inconvenience you. 
Makes sense. That's about 50% of my daily reading.
Are these charts constantly updating, or are they rendered once, upon page load? If the latter, you could simply output it as tabular data and do what jQuery Visualize does (i.e turn the data tables into charts). This also frees the data from a javascript dependency. If the former, go with AJAX. *Or* go with a combined approach, depending on what your goals are. 
This an an awesome start for a school project. Drarok is right you need to move onto a frame work, it will make all the things you found painful in this project suddenly easier and leave you more time for development. These tools have done all the authentication, separation of model, view and controller, routing and ton of other tools and saves you time designing and securing your own. Don't see this as a downside, more like standing on the shoulder of giants Checkout [laravel 4](http://laravel.com/) which is very "cool" at the moment and very easy to get started with. 
Closing your eyes to real problems is a good way get fired when they inevitably blow up in your face.
To pass something relatively static like a csrf token or language/phrase mappings into javascript, something like json_encode into an inline script is pretty much the correct approach. There's absolutely no need for a redundant AJAX request even if that's currently the trend with facebook etc doing it.
I didn't mean to criticize, it's just important to realize the ups and downs of any approach with SQL.
I see, thanks for explaining. I guess I should had this submitted on Reddit before I sent it to the teacher as I could have worked out some of feedback I got here. The deadline was one month and is long gone now so it's too late. Also we were not allowed to use any major frameworks on this project. I have used Smarty a bit before, some classmates saying Laravel is very good so maybe I should check it out. Can you also please recommend some good framework? Thanks again.
I agree with the first two commentors. Go with AJAX it is most clean. There are optimizations out there to increase the visual display.
I wouldn't worry that much, it looks like you are making great progress so far with learning PHP. Laravel is indeed a popular modern framework, and it's not too hard to get into, so you could give it a try.
Firstly, Well done on getting it *finished* and if this is one of your first projects doubly well done :), I've seen far worse code in production from "experienced programmers". From a quick glance you appear to be using a returned value of false to indicate an an error. This seems intuitive I know but what happens when you have a function like validateUserCredentials(array $credentials) which returns a boolean to indicate if said credentials are valid since in the case where you return error (false) is the same as the credentials been invalid (also false) you can not disambiguate between them (this is one of the reasons why the convention in the C world (and some other languages) was to return -1 for an error, 0 for false and anything &gt; 0 for true). This really isn't helped because lots of the core library functions return false (because sometimes that kinda makes sense as false *can* be used for errors in those particular cases). The "correct" way to handle errors is to throw and deal with exceptions (which is indeed what the newer frameworks all do Symfony, Laravel etc) as you can throw exceptions of different types, so you not only know something went wrong but what went wrong. The tragedy is that many PHP functions just throw false and a warning where an exception would be really useful (file_get_contents etc) but this is a legacy issue and not something to stop you using exceptions in your code. http://www.phptherightway.com/#exceptions and http://www.phptherightway.com/ is an excellent resource for someone moving up from beginner. ------- Based on your project you seem to have a reasonable grasp of the basics so I'd consider looking at a framework (as an aside, I'd suggest Laravel, it's clean, modern, well documented, has the amazing laracasts which I would have killed for when I was starting out in web dev) and a friendly community over on #irc (freenode #laravel). EDIT: Comments, write comments, don't write $x = 1 // set x to 1 style comments, write about what the function/code does, what it modifies and what it returns (if you use a good idea like phpstorm/netbeans they can auto document much of the signature for the function), a good comment example would be (grabbed at random from laravels Eloquent class) /** * Retrieve a user by the given credentials. * * @param array $credentials * @return \Illuminate\Auth\UserInterface|null */ public function retrieveByCredentials(array $credentials) { // First we will add each credential element to the query as a where clause. // Then we can execute the query and, if we found a user, return it in a // Eloquent User "model" that will be utilized by the Guard instances. $query = $this-&gt;createModel()-&gt;newQuery(); foreach ($credentials as $key =&gt; $value) { if ( ! str_contains($key, 'password')) $query-&gt;where($key, $value); } return $query-&gt;first(); } This won't seem important at the time but future you will not want to kill present you when you open code you wrote a year ago with no comments and can't remember how it bloody works, trust me. 
Prepare to be unpleasantly surprised: http://3v4l.org/mn4Sa PHP has a blacklist of characters not allowed in function names. All the other characters are allowed, but are just interpreted byte by byte. So it works - but yeah, isn't good.
Seconded. Only make it available via an AJAX call if there's some need, e.g. The data set is really large, or takes a long time to prepare, or may need to be refreshed on the page without a page reload. 
Well I have done some small PHP projects outside school but it has only been small hobby "things". But it was my first school project working alone. About the false thing I thought there is that triple equal operator so I did not think so much about it but I think I understand what you mean because it can be very confusing for others who may read my code I guess. To tell you the truth I have never worked with exception before which I think is sad. Well few times but it so few I hardly remember if I did correct. But don't exception exit the script? I just want to say it's a very nice community here on Reddit and I am thankful for every comments. Edit: Ah, cool I never been good writing comments so that is helpful.
Hmm ... looks like some (preliminary) [work has begun](https://github.com/google/gumbo-parser/issues/23) to create a php extension for google's gumbo HTML parser as well. Doesn't seem like there's been much dev on it recently, though. This may interest you if performance is your main concern. If this is a learning project for you, kudos! There's no better way to improve your skills than by manually implementing things like this yourself. That said I would certainly defer to /u/nikic's recommendations with regard to parsing concerns in userland as he's the local expert on these matters.
&gt; Also we were not allowed to use any major frameworks on this project. &gt; There's something very wrong about that. Frameworks don't do the work for you, and you'll almost never be writing code from scratch in your career, it's far more beneficial to finish a project using a framework than build something from scratch. not sure what your teacher is thinking, but that's the stupidest requirement i've ever heard.
I think it is to see what we have learnt from all lessons we had in PHP/MySQL.
For a school project, I think it's fine. Why shouldn't you start out with plain PHP? As long as you know it's just the first step, I'd say it's the best place to get started unless you already know another language. Jumping from never used PHP straight into a framework isn't ideal IMO, because you start learning the framework rather than PHP.
It's still awful.
It's true that Wordpress is very popular. But this post is specifically looking for something aimed at modern web developers, which as you pointed out Wordpress is not.
Thanks! This is definitely what I was leaning toward and already have implemented, but just wanted a little verification that there wasn't some better way. 
That was the problem, thank you!
Great.
Until you decide to implement a content security policy that prevents inline javascript from executing.
Is there some reason this is better than REPLACE INTO?
Popularity is not an indicator of quality. You also make assertions about how great it is by stating that it is things that it is not. That it can be coerced into leveraging some modern practices and tools (a process which is awkward and painful at best) does not mean it can hold a candle to well designed software. User friendly? Perhaps - when used as a blog like it was intended. When pushed in any other direction this breaks down because you fall at the mercy of the much praised plugin ecosystem - with addons developed by unqualified "developers" with questionable abilities. Wordpress does not even begin to tick OPs boxes, and your assertions that it does shows your lack of experience and calls into question whether you are qualified to have an opinion on the matter.
cockpit seems to go in the same direction - http://getcockpit.com ... maybe useful for you
I'm guessing it's related to this point in the RFC, but who knows. &gt; If people want to change the syntax of this feature more in line with Hack generics syntax then simply vote no, and we can revisit the issue.
Not /u/nikic, but I can definitely say it's too little code. HTML has an *enormously complicated* grammar (though it's not actually *specified* as a grammar), there's no way you can do it right in this amount of code. When I wrote a streaming parser a year or so ago, the lexer alone was almost 1.2 kLOC of tedious state machine. I could probably cut it down if I revisited it, but considering I almost wanted to die when I was done I've got no desire to ever look at it again. The most aggravating thing about doing it was the complete lack of anything resembling abstraction. When you want to parse, say, S-expressions, you can find [a grammar](http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-7.html#node_sec_4.2.1) that you can process any way you want. You can make parser combinators out of it. You can tweak it a little and feed it to an LR parser generator. You can write a recursive-decent parser by hand if you're feeling bored. But with HTML, what you get instead is a specification that reads like pseudocode in some imperative language; your *only real option* is to implement this mess by hand. And some of these steps are insane. Separating tokenization of the input stream into lexemes from stringing those lexemes into an AST is a completely bog-standard thing to do with these problems, but parts of the HTML spec require the tree-construction stage to *reach into the lexer* and twiddle its state. Let's not even get into the "Adoption Agency algorithm". I understand it's necessary for the language we've ended up with, but I think it's *incredibly* unfortunate.
&gt;To pass something relatively static like a csrf token or language/phrase mappings into javascript, something like json_encode into an inline script is pretty much the correct approach. For the cases mentioned, why would you even need to involve javascript at all?
Dude. This is reddit. Being qualified and having an opinion on the matter are mutually exclusive!
And if an end user, instead of a developer, had posted this request your post might have merit. But as lordofworms has said, the requirements the OP has (which are reasonable) are not met in **any** sense by Wordpress. The fact that you think it does speaks volumes about your knowledge and experience.
Phrases where the javascript must fill in tokens itself, e.g. as used in XenForo http://imgkk.com/i/d7rh.png csrf wasnt a great example though, could just pull from a hidden element
"replace into" deletes the record if it already exists, then inserts it. 1) If you have any triggers on any of the fields, timestamps, cascading stuffs, this blows it up. 2) it changes the physical location of the record on the disk. The more you do that, the further away the records will be from each other and the longer it will take to grab them, basically. The second one is an issue in large databases with lots of transactions. Having said that though, OP seems to have a database with only 7 records and none of the rows are special, so.....
My reasoning for voting -1 (in approximately descending order of importance): * I feel like this is a syntactic dead end: either PHP is going to support generics or not in the longer term — if PHP does, then the syntax will probably be significantly different (which means this will have to be maintained and documented even though it won't be the best way to do it), and if it doesn't, then having a half-buttocked feature that only solves one part of the problem only muddies the waters. * It's O(n), which has the potential for users to have unexpected performance issues when scaling code — this can be solved with support for a proper collection type and/or generics, neither of which this patch helps with. * It's being proposed for PHP 5.6, which is now **extremely** close to feature freeze. Even if it was accepted, I'd prefer it had more time to bake as a feature rather than trying to rush it in at the last minute. On the bright side, the patch itself looks fine at a cursory glance. I think this may end up being a situation like namespaces, personally, where the initial design doesn't make it in but something will evolve out of it in the longer term that will address the underlying need (like generics).
Very nice summary, I agree on all points.
These kinds of benchmark get my attention ... and make me a bit sad ... I'm sad because, it would seem that, people would rather deploy code compiled into a language they cannot understand, taking a huge risk in the real world, just in order to get a bit more work done. They are even willing to change their whole stack, before utilizing skills they already have. For some time now, there's been a much simpler way to squeeze every last bit out of PHP, without learning a new language, without swapping out your whole stack, without having to learn the intricities of an entire implementation of our favourite language. https://gist.github.com/krakjoe/9274747 Maybe it's just too complicated, and I can live with that most of the time, but then I see the rather extreme measures those that are thinking about high performance PHP are actually considering and I despair .... Nice article btw ... don't mean to hi-jack the thread ;)
Thanks for getting involved in the conversation whatever ... Worth mentioning I think, a type-hinted variadic is also O(n) ...
I agree with Daniel's post on Internals about the variadic issue: it's true, but it doesn't need to scale the same way passing an array does.
The location of the data on disk doesn't matter. If it does, you are better off writing a filesystem that will order all data sequentially by whatever rules you define as sequential. Common-purpose file systems effectively store data in random locations. I know this isn't entirely true, but my point is you can't necessarily guarantee the continuity of file data in most file systems. Now, if you're running into performance problems with data being spread out on the harddrive, before you go off on writing a new filesystem to handle this, you would be better served by indexing, so that at least searches will be unaffected by the data discontinuity (and even your indexes can be spread out on the harddrive). These considerations are moot on SSDs. The major problem with a delete-then-insert is that it will cause more writes to both the table and the indexes defined for that table. Do it in a transaction, well, you're bound to have locking issues.
I think it feels natural as well but to me that typehint just logically infers that the language has generics, which it wouldn't with this RFC. In other words, if I can typehint a generic, I would also expect that I could do something like... &lt;?php $foos = Foo[]; $someFoo = new Foo; // Works $foos[] = $someFoo; // Throws invalid argument exception $foos[] = 'bar'; Disclaimer: I didn't actually know what generics were when this RFC was first published, as a user of PHP that just felt natural to me as well. After learning about generics and how they are implemented in other languages I kind of feel like implementing a generics typehint without actually having generics is kind of iffy. But that's just IMO. There seem to be arguments either way on the ML and various other discussions.
You should totally try to recreate this in Laravel. Try using PuPHPet and composer too.
How funny would it be if this developed in to the project that ultimately replaces Reddit.
Another Bitbucketer! There are literally dozens of us! 
What a terrible piece of advice. Frameworks is the last thing he should be looking at!
Care to elaborate, or would you prefer to remain an inflammatory dick?
This is the biggest reason I rarely post on anything tech. I am a PHP and mySQL hobbyist. What I've learned I've had to do on my own with zero schooling. Okay. It's obvious you know a great deal and (maybe) have done work as a DBA, but this is ridiculous. Fragmentation can be a big deal, which is why clustered indexes were created to solve the problem. Each new non-clustered index in a large database increases the time it takes to write records, blah, blah, blah... It's actually a thing because I ran into the problem myself. Thanks for the casual dismissal, bro. ...which brings me back to the point I made in my last post.... church website guy, one user with a total of seven rows and four columns. He can likely put everything in a comma-delimited file and not see any performance hit. He could put each record in a separate file and not see a performance hit. ...with his teeny, tiny database, he can hit refresh 100 times and not see any locking whatsoever. it will zip through his entire query 100 times and his table would be locked by the system for a total of 0.00000000000001 second. So why do experts on Reddit come to tiny threads to show everyone how awesome they are by criticizing everyone who doesn't have the exact, best answer. good lord. why does everyone gotta make it so hard to help anyone else?
?&gt; and then a line break. Your class just broke an entire app.
Smalltalk's MVC is very different to the Rails MVC we see in web frameworks now.
Wikis don't support versioning though.
I like to create a docs folder within the repository. This allows for documentation through markdown files, which renders easily in GitHub, and is even easier to write. https://github.com/titon/toolkit/tree/master/docs It also allows localization by organizing into folders, and for versioning of documentation alongside commits and tags.
&gt; Speed difference was negligible. &gt; It makes sense to say no to this because of the other generics proposal. You missed the point that generics only need to be checked once for each element on insertion. Consider: function foo1(Foo[] $fooArray) { //add an element to $fooArray and foo2($fooArray); } function foo2(Foo[] $fooArray) { //add an element to $fooArray and foo3($fooArray); } function foo3(Foo[] $fooArray) { ... } Each call to a function that has been type-hinted to `Foo[]` will need to check the complete array. That's really nasty performance impact, that is both not obvious, and means that writing code correctly (i.e. with the type-hinting) will perform much worse than code without the type-hinting. btw if you really need this feature, you can already do it with a combination of documentation and checking the array yourself. function foo1(Foo[] $fooArray) { $fooArray = array_map(function (Foo $foo){ return $foo; }, $fooArray ); //fooArray guaranteed to only contain Foo objects. } Adding a feature to the language adds more than a little burden for the future. The feature has to be good enough to deserve that burden, and imho, this one isn't good enough, even though I'm a strong believer in type-hinting all the things. 
The Java syntax is better for types of collections other than arrays. Doing it with the `Foo[]` declaration obviously means that it's an array that contains `Foo` objects but what would be the syntax for supporting user defined collections e.g. If I have a `Tree` object that holds objects of type `Foo` then Foo[Tree] is not at all obviously the correct syntax, and having to explain that the array brackets aren't actually an array would be quite confusing. Having Tree&lt;Foo&gt; vs array&lt;Foo&gt; is much easier to interpret and explain to new programmers - even if you think it's too much like Java's syntax. 
Yeah, totally forgot about nested collection type hinting. Good enough reason at this point.
True, but I don't think PHP would need both forms if generics support is added.
maybe, I don't see the harm in adding both, though... like Java.
**C#** (an incredibly designed language) also has the same syntax: http://msdn.microsoft.com/en-us/library/hyfeyz71.aspx
Make it `HAPPEN` guys, ... 
I really really don't like this. Mainly because I don't like the implementation. Why can't we just add scalar type hints and typed arrays. I think we should try to make the language more consistent, instead of adding hackish features like this. And I don't think many people don't understand the difference between generics and what this proposes. Generics will probably be an alien concept to most php programmers. So I think there is real danger that people may have opinions about it without actually understanding it. So I will just leave this here &gt; In the simplest definition, generic programming is a style of computer programming in which algorithms are written in terms of to-be-specified-later types that are then instantiated when needed for specific types provided as parameters. This approach, pioneered by ML in 1973,[citation needed] permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplication. From http://en.wikipedia.org/wiki/Generic_programming EDIT: The msdn library also has a good article. http://msdn.microsoft.com/en-us/library/ms379564%28v=vs.80%29.aspx 
Nice!
When I think of performance, there's a lot of things I think about. Its not usually just about time. Its usually about its either about making an experience better *or* reducing costs. So, I thought about how this information from the showdown can be applied, but the list was very short. Perhaps this sort of number crunching would be useful if one is writing a game. Perhaps it'd be useful if one is trying to perform some scientific calculations. Are those really practical uses case right now? Is that something that developers are trying to use PHP for? As someone who really enjoys seeing how PHP is getting more efficent per-server and per-request, I find it interesting to see HHVM's number crunching isn't as quick as PHP's. On the other hand, that wasn't a question that really came up when thinking about PHP performance. tl;dr Number Crunching in PHP?
Multi-thread programming is rather hard-- even for languages that have been doing it for years. After seeing some [intergration with ReactPHP and Symfony2](http://marcjschmidt.de/blog/2014/02/08/php-high-performance.html) I do wonder how practical thread-use will be with something like ReactPHP. (their [FAQ](https://github.com/reactphp/react/wiki/FAQ) suggests it isn't a good idea)
Thanks for all feedback/comments I have read them all. Amazing how much you can learn from it.
&gt; could just pull from a hidden element Indeed.
These numbers kinda ... don't look impressive at all. For seed 100 PHP is twice as fast as the HHVM JIT, for everything else the HHVM JIT is twice as fast as PHP. And we're talking about a very computationally intensive task here, something totally unrealistic for most PHP applications and something HHVM should really shine at. I would have expected that HHVM would have a very wide margin here, with performance close to C.
Easier in most cases to do one of the following: 1. Block grab the lines in your IDE and mass comment the lines out. It'll work for PHP, JS, Java, or whatever language you're editing that your IDE supports. 2. Put an if(0) { at the top and } at the bottom of the PHP code you want to comment out. Why do I say 'easier'? Because almost every time I've tried to comment out PHP code with multiline comment syntax, it fails, because there are already multiline comments in the code I'm dealing with. In trivial cases like above it works, but it doesn't work on larger/complex code if it's already got multiline comments in it (and many times it does). I find it easier to use an approach that works *all the time* (either I mentioned above) vs using one then having to switch to a different approach at another time.
If you are using Sublime Text, you can select the entire block and do `ctrl`/`cmd` + `/` and you'll comment out the entire block.
That section has been updated ... that's no longer the case, I'm [super] happy to report :) There's a handful of people who really know what they are talking about, and when we speak, we are usually shouted down. Something being hard is no justification for avoiding it, it couldn't really be easier, I've never heard anyone saying (outside of a blog post, written by someone who just learned java that morning) you should avoid using threads in Java, because they exist, are part of the language, it's normal. Well, everything that pthreads does is part of Zend, I didn't make PHP multi-threaded, it _was already multi-threaded_. It has been a part of Zend for more than a decade, it's been poorly reported on and blogged about that entire time ... While it's not justification for avoiding it, it's completely fair to say that it is hard, but so is writing nonblocking applications in PHP, so is learning a new language, so is learning how to debug your extension that used to be some kind of interbreed of PHP and C, and is now C, swapping your whole stack is also a risk even if you are standing on the shoulders on giants like facebook, you don't get to whip the carpet from underneath anything without causing some instability. Before you knew what any of this stuff even was, connecting to a database was hard, loading an XML document was hard ... it's all relative, if you take in the correct information _everything_ get's easier... On the scale of the web, we have at one end, pretty much entirely on their own, Facebook. The entirety of the rest of the scale, the other *79.99% of the entire internet*, is taken up by normal size websites, crunching large (for them) but normal (in reality) sets of data, servicing normally busy websites. I'm not comparing the ability to multi-thread with the abilities that a JIT compiler has or writing in C (which is what zephir does, really) will expose, I'm just saying that for the vast majority it's not actually necessary to do either, since performance can be squeezed from PHP using not only threading, but things like nbio, and just writing better code.
Or in Phpstorm/Intellij, just select all the code you want to comment out and do cmd + /, then use the same shortcut to uncomment.
Upvoted for the Ah-ha! factor. Anyway, you're better off leaving multiline comments for documentation purposes *only*.
Absolutely, the WAY in which they work is much different. PHP is loosely typed, while Java and C# are strongly typed. In a strongly typed language the type gets checked on every addition into the array, but in PHP it'll only check the types at passing to a function, which could be a huge array, so the efficiency is very different. The syntax, however, is the same. That's what I was saying.
Yes they do. GitHub wikis are git repos in themselves
&gt; Something being hard is no justification for avoiding it The problem isn't that its hard to write. Threading comes with its own set of issues: synchronization, locks, dead lock situations, and more. The real problem is that threading tends to make code more fragile if not done just right. Whether it be a crashing thread, a dead-lock situation, or make some assumption on memory that wasn't true. I have yet to see a threading design, in PHP, that was worth the effort. Creating the same circumstances to reproduce a bug also tends to grow difficult. Several platforms are *very* careful about what's shared between threads and what isn't. Several languages have built-in constructs to help solve threading problems, PHP... doesn't. I agree with you on the interbreed of C and whatever non-PHP language. In fact, I still think using database and loading an XML is "hard" (or at least, more complicated than it should be), but I know how much it'd cost me to not use them vs using them. I actually tried threading in PHP a while back, it worked fine, but it wasn't yet worth the added complexity (it didn't save much per-request, if anything). With most websites, its not that different from Multi-proceseses (particularly since PHP-FPM, mod_php, and such all shut down the process when the request is done, so PHP doesn't get as much of the shared memory space advantages). There's all sorts of technology out there. OPCache has *finally* become something standard-- but before that people used APC (which has its own issues), eAccelerator, XCache, Zend Optimizer, or a number of other solutions. You got a boost without having to lock yourself in-- though you could use extra functionality if you want. HHVM is a similar solution. Despite not performing as well in benchmarks, it manages make applications run faster with very little developer costs (modifications which seem to be decreasing more and more). I'd love to see more stuff like threading embraced in frameworks and PHP, but I don't think I can agree that the vast majority should use threads to get a bit more of a performance boost. With the current architecture of PHP, in web requests, it doesn't make much sense. Say you create 8 threads to get a page loading 8x faster. Giving 8x requests, it'll still perform about the same (or worse) as multiple processes. When the server starts to get bogged down, say at 64 requests/sec, its managing about 512 threads instead of just 64-- creating and destroying them for each request. PHP may actually be performing worse at this point. I'm not sure if things have changed since I looked, but last I checked, the PHP-FPM/mod_php per-process model didn't allow for threads to be fully taken advantage of. I see potential for things like ReactPHP to change that (especially after seeing it integrated with a Framework that wasn't really designed to do that). I'm a bit curious though, have you found practical applications for threads in web pages or has your usage of threads been more of offline data processing? 
I'd rather say: don't commit commented code. If you comment it and want to commit that, it means you don't need it so just delete it.
&gt; I have yet to see a threading design, in PHP, that was worth the effort. I'm not aware of any complete ones, I don't think there ever has been another complete implemenetation actually. &gt; PHP... doesn't. _Yes, it does_, PHP does have a defined and maintained architecture for multithreading and it is that architecture that is used by pthreads. The architecture as we all know is a shared nothing one, the job of pthreads is to breach the barrier, safely, obviously. In addition it's the job of pthreads to provide things like synchronization, automatic safety, and the things you expect from a high level threading API ... we're not discussing Posix Threads, hope that's clear ... Of course the vast majority shouldn't use threads, I didn't say they should. I'm saying before the minotiry interested in high performance consider such extreme things as swapping stacks or running code they do not understand they should explore all the possibilities, starting with write better code, including nbio, and working up to threading if required. You should _never_ create threads in direct response to a web request, I would never suggest such a thing. I don't know what you mean by the PHP-FPM/mod_php per process model doesn't allow threads to be taken advantage of, they do, if PHP is built with the same configuration required for any threading at all. http://appserver.io That is pretty cool stuff, it's still being developed, but I met with the chaps writing it at the phpuk the other day and they report good progress, surprising progress. This is the logical place to take it but I don't have the time or will power to write an application server, though I'll support their project every step of the way, I'll leave the hard work to them ;)
With SublimeText, I just do Ctrl+/ and it adds // to every line, whether there's already a comment there or not, then I just do ctrl+/ again on the same block to uncomment. It seems very weird to me to put an if(0) statement in your code, it just opens doors to mistakes imho. If you forget to uncomment and another coder finds it, it'll look really weird to have that kind of logic in there. But if a dev finds a bunch of commented out code, they might understand the context more.
I've experienced that it's also extremely easy to port existing vanilla PHP applications onto Slim. The ability to keep the original framework-less pages as-is with new routes and gradually shift everything over to some sort of design pattern is brilliant. Especially when you're expecting to gradually re-write the codebase while keeping the current feature set intact.
Co-author of React here. pthreads is cool and it's on my todo list to try it out and optionally support it (if the extension is installed) in React in a proper architectural manner. Our FAQ doesn't suggest pthreads is bad or won't help performance. The "no" is there because we constantly get people in IRC or GH issues who ask about opening a thread for every connection or some other miss-guided question thinking that just throwing threads at the lib will magically solve all our problems - all issues with lack of education. I don't believe our FAQ is FUD. It states React is about async I/O and that threading is a complex topic and beyond the scope of React. If you feel that is FUD I'm open to a discussion (please not here) about correcting our wiki. 
Nicoooon! Thankyou for your effort, its much appreciated :D thankyou!
This has nothing to do with scalar type hints. It doesn't block them, hasn't been done instead of them (theres more than one person working on anything at any time), but arrayof would definitely benefit from them. :) Generics are still completely on the table in a later version. Java has both, and several internals folks said they would like both too. I definitely see no need for one of the other. Sadly it does look like this is going to bounce, generics-like syntax will be used in 5.7 and full-on generics _may_ come in PHP 6/7 (whichever it gets called). That's not hugely surprising, but getting this vote out the way obviously helps us focus on the next route. If people wanted this this way, it would have answered a lot of questions. DEMOCRACY! :D
Thanks for getting involved in the conversation ;) You done a wicked job of updating that section, no complaints :D
That's what I implied. I delete every commented code i can find, and I never commit commented code.
Thanks Joe. Happy to have that conversation with you on IRC and see that we're on the same page. For those following along: The FAQ had *mostly* reflected my comment above except for a sentence that could be taken the wrong way and another sentence that was totally a bad generalization that looked like we were snubbing pthreads. Sorry, my bad. React's FAQ is now updated, more clear, and should better inform readers. 
I mentioned scalar type hints as a predecessor to typed arrays. With typed arrays I don't think this will be necessary, right? Or do you think this feature makes sense even with the availability of typed arrays?
&gt; Generics pretty much are typed arrays. :) Except that it seems to me that generics have nothing to do with arrays. I mean, it can be used to design collections of arbitrary types. But from what I understand about generics, saying both are pretty much same is a bit naive. &gt;Generics allow for checking the type of the contents of an array at pass time. Again, as I understand it, it does not have any thing to do with an array. But it allows for checking the type of the arguments passed to a method and this type can be specified at the time the object is created, instead of hard coding it in the class definition. It has nothing to do with arrays. &gt;Generics also allow for checking of the type of the contents of an array while you're adding things to it. Same, generics allows type checking. Does not have anything to do with arrays. 
Is this generics ?
If, for, while, arrays, objects, classes. It takes all of 10 seconds to quickly check the syntax for anything else. The key is knowing what sorts of things are available, and that's something that's impossible to list. It's just something that you just pick up from experience. (Things like string manipulations, I have no idea what the functions are specifically called or what the syntax is, but I know that they exist and the basic things they can do, so I can find out the specifics in a 15 second lookup.)
Know when something is deprecated. example: mysql_* Know when something is insecure. example: md5 hashing a password, or using the correct rng function, or SQL injections. OOP patterns. If you're talking about functions.. well.. I can't really code without documentation TBH. Needle or haystack first? =|
Documentation is built into any decent IDE and you'd have to try **hard** not to look at it - at the least you get the function name and arguments as you type. 
in oop: * How and when to use static methods and properties. * How to access static class properties and methods (::function() / ::$var) * How to access object properties and methods (-&gt;function() / -&gt;var ) * How to use namespaces, and in what situations you need to consider using namespaces (large projects where class names might start colliding) * visibility (public / protected / private) generally: * How and when returning by reference might be useful * The difference between double quotes and single quotes * Which connector is best suited for your purposes (mysqli vs pdo) Not strictly PHP-related, and not exactly minimal, but still useful: * Advantages of server-side object caching: Memcache, file-cache * Advantages of proxy caching (Varnish is a popular choice), and how to properly use the proxy cache you've chosen or are stuck with (looking at you, Squid) * How to control, mitigate and/or disable browser caching, depending on your needs * The advantages of using a dependency manager like composer (only relevant if you want to incorporate frameworks or other external projects) * What unit testing is, and at what point it becomes worthwhile (lets you set up frequent automatic jobs that check every feature and functionality on your website to see if anything got broken - much better than having your users discover the bugs for you) That's off the top of my head, I'm sure there's lots i've forgotten to mention.
To be fair, they don't make it easy to remember: stristr($haystack, $needle); vs in_array($needle,$haystack);
Depending on the quantity of encryption operations you do, switching to OpenSSL will probably lead to significant performance increase. OpenSSL is compiled to take advantage of your CPU's native support for AES encryption. Mcrypt isn't. 
Unit testing isn't enough. To get the full advantage of unit tests, you have to be doing test driven development, which requires you to write your tests before you write any code. The advantages of TDD include more than having a high degree of confidence that your code is working - it also helps guide the design of your system while aiding refactoring and creates a foundation from which your code can grow and adapt almost organically. None of this is possible if you try to create unit tests here and there, or after the code is written. Edit: seriously, I'm being down voted for this comment? No offence, but the people down voting this comment are idiots.
The measure of a programmer is not necessarily what he or she needs to look up, although I'd be a little alarmed if they were looking up correct syntax for an if statement. But instead, you should focus on practicality, and specialise in something such as OOP. If you do something like that, you'll get familiarized with common functions enough to where you won't have to consult documentation. But I'd say no one is going to look down on you for consulting the documentation every now and again, even for simple functions.
Know what features were introduced, deprecated, and removed in what versions of PHP. 
I've only been writing for 2-3 years, and "professionally" for 3 months, so I'm glad someone with much more experience agrees with my view on it.
Quite a lot is covered in the replies already but I just wanted to add knowing what the various keywords mean and when they should be used : * Trait * Extends * Interface * Use * Namespace * Dependency Injection * Caching * Autoloader * Unit Tests and other types of tests 
For somebody who works in multiple web languages... I need to look up loops all the time to remember which ones this language supports :P
I've heard that in general array_* tends to use one order and str* use the other. I can never remember which way around that is though.
I do too. All the damn time. I work regularly in 6 languages so yeah the correct syntactic often eludes me.
Maybe a contribution to an opensource project written in PHP ? One that is popular now is Owncloud (http://owncloud.org). You could fix bugs, add features or develop your own owncloud "app" (plugin). 
wat?
array_map and array_filter are ones that infuriate me. Callback, Array or Array, Callback. Why are they different?
Hell yes. The 3 languages I work in the most are C#, PHP, and JavaScript. Every time I go from one to the other, my brain farts a little inside when trying to remember the various syntactical differences.
yes, I like the idea, thank you very much
good idea, but i don't know if i'm skilled enough for that
Nothing I guess. The documentation is right there, and auto-complete does the rest.
Check this out https://github.com/gleitz/howdoi
Same here. It's all about knowing what's available. I recently had to reverse a string for something, and I thought, hmm what's the best way to do this? turns out strrev() is a thing since php4 and I've never even heard of it! 
I'm on the fence on tdd, tbh. Not sure at what point of project complexity that philosophy pays off more than it costs, in terms of development time.
[One day.](https://wiki.php.net/rfc/named_params)
I don't think anyone like this actually exists. Don't worry about it.
i hope i can help
Honestly I find my self checking syntax on freaking everything in every language I write in, I just have a piss poor memory. Anyone who would require or ask you to work without documentation and expect it to be right is goofy. 
and without any working experience?
How to code?
This to me is a relief; thank-you. I've always been self-conscious on my PHP abilities thinking that I've been really sloppy-like in my learning. Knowing that constant doc referrals are a norm is comforting.
If we were to make all the array functions consistent, it would be the *array* that would always come first in the argument list, as it's the "common thread". Just look at basically any extension with functions that all operate on some common resource for an example - they all always have that common resource as the first argument.
How will you do TDD when you have to create a user row in database from details entered in a form. Just curious. I am asking because you said, 'write your tests before you write ANY code'. 
Just know where to look and how to search. 
my exact response
Any use of manual escaping or sanitizing for SQL queries is indicative of doing something very wrong.
Definitely *not* the parameter order of PHP library functions like [strstr](http://ca1.php.net/manual/en/function.strstr.php) and [str_replace](http://ca1.php.net/manual/en/function.str-replace.php). I have been doing PHP development for several years and still need to looks those up.
^^this. phpunit and maybe the ability to use selenium for functional testing - if they can't they should at least be familiar with the concept, and I'd ask them why they haven't/can't. Also I haven't seen anyone mention [Iterators](http://www.php.net/manual/en/spl.iterators.php) yet. [IteratorAggregate](http://us2.php.net/manual/en/class.iteratoraggregate.php) and [Iterator](http://us2.php.net/manual/en/class.iterator.php) are so useful.
PageKit has a beta scheduled for March, but that was already pushed back from January. Hopefully they release something soon. October is going to be at Laracon, I think, so I'm sure they'll have something soon to show there.
I don't think avoiding documentation is the best thing anyways. If anything you should know what exists in PHP and what PHP can do, and where to find it in the documentation. The PHP "date" page is probably my most used page. I could memorize the time variables, but why should I have to if I know where exactly to find them?
Just use strtotime for all the logic. In had to do something similar for one of my projects. It will make working with dated so much easier.
To combine others' suggestions, find an open soirée project on GitHub that looks interesting, look through their issues, and try to add a small bit of functionality or fix a bug. Even if you just make some grammatical or spelling corrections or clarify the meaning of the documentation, it could be a help to the project. And it would signal to me, as a hiring manager that you took the time to read through the docs or the code to better understand the project, even if the contribution was fairly trivial. Edit: I'm not sure what an "open soirée project" is, but autocorrect thinks it sounds better than "open source project," and I think I agree!
HNI is awesome.
thanks! open soirée sounds cool
Because MI gets weird (diamond inheritance for example) but it's not really terrible. Traits and Interfaces combined give you MI but can be used separately so they're ultimately more powerful. 
I don't think you understand what "more powerful" means... 
How so? MI lets you inherit from multiple base classes. But you inherit both the interface and implementation. You do not have the option to inherit only the interface or only the implementation. This is what traits and interfaces allow. More capability so more powerful. 
If I read that right, you are looking for some beginner type ideas for scripts for your friend to write? A few ideas I have. A choose your own adventure type text based game, a lotto number picker, a calculator. People always say not to reinvent the wheel but I feel like I learned the most when doing this. A reinvent the wheel type idea would be creating a login membership system then adding to it until it is a full featured cms. best way to learn is by doing. When I was still learning and wasn't sure where to go next I would just try to replicate a site, not with the intention of other people ever using it but just for the learning.
You inherit only the interface of base classes with only pure virtual members in MI. Your argument is that interfaces and traits can do a subset of what MI can do, therefore they're more powerful, which is the opposite of what "more powerful" means. 
My argument is that interfaces and traits are more flexible than MI and therefore they are more powerful. While you make MI work like interfaces (with pure virtual members) you can't make MI work like traits. There is always an is_a relationship. 
Pseudocode... and that's it. (Beyond That: Possibly general PHP functions, general syntax) I've been a professional programmer (Lead Software Architect for those who like fancy titles) as well as a UNIX System Administrator for 20+ years. I still look at documentation. Do I remember every nuance in PHP's date function? No. Plus in the process of looking things up I see updates, new features, and have come across better ways to do things I've done a certain way for years. You'll never stop learning... and with dynamic documentation that now exists on the internet, its even more true. What would I expect a PHP programmer to know? How to use php.net's search function. How to use man pages (if they have shell access) and how to search Google and sites like Stack Overflow. That's the measure of a GOOD programmer. When I first got into programming all we had was O'Reilly books. So someone with 10+ experience I might make sure they can search the index of an O'Reilly book too ;)
Switching back and forth between MySQL, javascript, and PHP, I wouldn't be able to keep string manipulation functions straight if my life depended on it.
Why does the "is a" relationship matter? 
I'm not even a PHP developer but it's what I do for a living. I think "able to find solutions and understand them lightning quick" is the skill set of the average web dev.
Oh, they do, I've worked with them. One guy would read big ass books on cryptography and quote that shit.
make sure register_globals is off, sanitize ALL user input
Javascript.. Every time I need an else if{} I seem to invariably use the php elseif{}. Invariably. 
I bop between, javascript, PHP, Python, and C++. I can't remember all kinds of things that are common between them. Things like join statements seem to reverse their params. Sometimes it is len, length, size, or count. So if it has been a few weeks since I did that language I find myself brainfarting about some pretty damn basic stuff. 
Contribute to a couple projects (even just small bug fixes, etc) on Github. Also work on something (even small, like a proxy RSS script or something) that you can build 100% yourself and pop on a web page to show your coding ability and ability to complete a project. It doesn't have to be more than 100 lines of code. But you need to prove you can do a project from start-to-finish. Don't worry about it being 100% great/bug-free/or secure (although try your best)... you're still learning and that's fine. But on the flip side... be open to critiques of your work. - These two steps will help get into an internship somewhere. You don't need to build something grand and great... you just need to show: a) you're competitent b) can work with others (thats why contributing on GitHub is a good idea) c) can work/edit other peoples code (see b) d) have a passion outside of just a "job" (shown by making your own script as I said above) e) you're eager
thanks, good advices
They do when they start commenting unnecessarily on a single issue, mindlessly rephrasing what Taylor already clearly asked. +1s do not help on issues.
When I was starting out I worked on small random projects that could be useful, then polished and added features. For example I wanted to search some news sites for something, so I made a little tool to search specified media outlets for a keyword, then to show I could expand the project, I added live update and notification features. You're one person, so some large impressive project likely won't be in the cards, but a simple, clean, well coded project demonstrating various abilities will be just as powerful. Side note: I agree with what a lot of folks are saying about not *needing* a portfolio to get hired on, however, if you have the time, it does show you took initiative, and takes some guess work out of the employers day. Good luck! 
thanks!
Others have mentioned contributing to OSS lots of times, but here's a pretty sweet list of places you can contribute: http://www.lookingforpullrequests.com/
This is very good. I would also integrate some 3rd party APIs here, such as a Twitter API. I don't mean pulling the latest tweets down from Twitter, but add a micro-app to your blog that lets you post to your Twitter account from a form within your blog. This will demonstrate you have the ability to read 3rd party API documentation, and implement it at a code level on your site.
wait....was this a legitimate question? i thought i was in /r/programmerhumor
Well, i think Taylor Otwell is not getting it all right here either. With this pull request he also wants to claim copyright of all the shitty changes. Probably the right way is to prepend the original copyright: Copyright (c) 2014 &lt;Taylor Otwell&gt; Copyright (c) 2014 FlyPHP FlyPHP is great troll renaming string values 'taylor' to 'allan' in tests. https://github.com/flyphp/flyframework/commit/0c8b551ac881d74f549d5d65f82b8bbda9d147f9 Renaming components robs him ability to easily merge updates and fixes to laravel code. 
Or implode which can take both implode(string $glue, array $pieces) and implode(array $pieces , string $glue)
Some people use words in programming languages like function, public, throw etc. as tokens like () or {}. I don't wanna assume whether the author does speak English or not but you don't have to understand these keywords literally as long as you know what they do. If you studied the methods he wrote for more than a second then you could've seen what the problem is he is trying to solve -&gt; having two methods with the same name but different arguments. Just try to be a bit more open minded and if you don't understand the code don't complain but ask.
Probably had an eidetic memory.
And here is a good walkthrough: http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1
I interviewed a guy for a mid-level dev position and - in the course of talking about OOP in PHP - he revealed that he'd have to research how to define a class. He did not get the job. 
Ah yeah. I see what you mean. Actually a really nice idea
So... followup - what happened? Something I use sometimes when negotiating is "I'm not the best, but I'm the best you'll find (around here, in the next few months, etc)". Said with some self-deprecation and a bit of humor, it serves to remind them that you're already there and willing to do the work, but ... this is a two-way street. In your case, you're already working there, and the results are pretty measurable. What title you may have is more down to self-promotion and corporate politics than anything else. As to what separates as developer from a sr dev? I've read many opinions on this, but a lot of agreement I've seen on this centers around multiple abilities, including ability to work in a team or solo as required lead/direct others on a project write code maintainable by others test code (automated tests) refactor when necessary architect a project from the ground up understand and deal with multiple areas of concern (performance, security, modularity, etc) I'm sure there's more, and not everyone agrees on these certainly. The title in some companies goes to people simply based on years of experience, but that's not the best way to measure ability (other than ability to stick at the same job/company for X years). Push for more $. Let's say they're trying to get you down... $20k (wild guess). At this point, you're already in there, right? You know the systems. The cost of them spending another X weeks trying to find someone else, then another Y weeks after that for the other person to get up to speed will be *far* greater than that $20k they're trying to save. Granted, if you're there 5 years, that's an *extra* $100k they're out, and the comparison benefit might not be quite the same, but... the principle still stands. The value you've provided by doing the work of 2 people is proof that you're valuable to them, but the longer you let it go on, the more it's proof that you don't know how to value yourself accordingly. However, I've seen companies do stupid things like letting people go, then getting hurt *really* bad for months afterwards because no one had any clue how central that lowly peon developer actually *was* to keeping all systems running. It happens. If it happens, move on, but take all this as a lesson to be able to understand the true value you can bring to an org/project in the future. 
Perl and Ruby, that SQL from Oracle. probably a bunch of others 
If you're not doing TDD, it is simply true that your unit tests are not being used for maximum effect, and you are losing some of the most valuable aspects of them - stuff like the power to refactor easily, and the assurance that pretty much all of your code is covered by tests. There's also the fact that TDD actually guides you in terms of the design of your code and forces you early to write decoupled, and of course through necessity, easily testable code. I still assert that if you are not writing your tests first, you are doing it wrong. *Edit: I also never said unit testing is useless or "even impossible" without tdd. I had some success using unit tests without tdd in the past. What I am saying (am I'm right) is that unit tests are LESS useful and HARDER to implement without tdd.
Thank you very much, it's exactly what I was looking for. For now I have him learning PDO as he didn't learn that in his first set of courses so from there I can then get him to do something more.
I always end up having to look up time and date functions. I just can never remember the syntax. 
Very close to it at least. 
I think we should wait to see what the docs look like.
Yes. Put some thought into building it yourself; think about how to approach all the different problems you'll encounter and try to apply your own insights for solving these problems rather than copying existing solutions. This shows you're able to solve your own problems without having to find a solution elsewhere on the internet. Finally write a blog post about this and your argumentation for choosing the solutions you chose and you'll be way ahead of the curve. 
Projects like this make it hard to make it clear what your exact contribution has been. An employer couldn't care less about the work of others if they're looking into hiring you, and if you've only contributed a few lines here, a few lines there and a small block on the other side of the project you're not making it easy for yourself and your potential employer to see what you did and what others did.
Someone once told me: all good developers look at docs. Those that claim they don't, are egotistical fucks that you shouldn't be working with.
I get a huge number of code smells off this, just from a quick look. I'll run through them quickly. 1. Use of define. Global constants are bad juju. 2. Big Static wrapped blog creeps me out 3. Terrible namespacing. Seriously z? As a final point... this should be a framework. Use of a framework would vastly reduce the amount of code under management. Laravel has a lot of support, and is the one I'd recommend, but Yii or one or two others are equally good. Even a microframework would help a lot. Actually, come to think of it a micro framework would probably scratch most if not all the needs here. I know a decision was already made on frameworks. It was the wrong decision. &gt; file structure didn't make sense to me, why have such a complicated file structure and so many files/folders for such a simple thing? What, do you pay for your server by the file now? Having highly separated code is a mark of **good** development practises. Using a framework would mean not having to manage and update all of the routing systems, etc. They become a dependency, instead of a liability.
The most therapeutic thread of the day! I to look up syntax way more than i think i should. What's the switch syntax in php, the foreach loop in js, or why won't this variable work in sh?? When interviewing you'd think the ones on the other side of the table know everything, but in reality, they probably just googled "interview questions for php developer." And, even if you do know the right command, it's nearly impossible to know all the arguments or flags for every command or function in your chosen language. Knowing the fundamental programming concepts is the key then knowing where to find the answer to refresh your stagnant, overfilled head cavity breeds the success. Because I do not have a photographic memory, the only thing that works for me is repetition, repetition, repetition. Cheers for the post!
OCP
Yeah, to me this seems pretty simple. The framework author is breaking the licence what Taylor is asking is not unreasonable at all.
&gt; when to use static methods and properties. What's the answer to this one? 
I think my *while (1)* might have killed your server. Sorry.
Need help with hosting? I can donate some... just message me (I host a couple other open source projects)
Markdown allows HTML though, so really a non-issue.
My thoughts exactly.
&gt; Statics are by their nature untestable. That's not true, it totally depends on __what__ the static does. A factory class with a static method `::create`? Perfectly testable! 
I used to code that way, but at the end I found that instead of making one method getUserInfo that accepted two types of parameters, it's better to have two methods. getUserInfoById(integer $uid) &amp; getUserInfoByLogin(string $login) Because you know which one you need to call &amp; it's easier to read
PS: If I try to add a coment in your blog with "Google", it doesn't work :(
First thank you again, for a non CS guy like me, talking with someone is a lot easier to understand than reading guides/tutorials written by CS engineers. &gt; As someone building a career on the basis that this is clearly NOT the end of the story, that's an incredibly dumb thing to say. For your career I think Javascript or any client side development tools are best suited. PHP has very little to do with what you want. At least that's what I think, and all the work I see done in PHP to address this is to me a complete waste of efforts. Sorry if this seems rude but you're being kinda rude yourself ;). &gt; You should be using composer. You should have an autoloader that handles that sort of thing. You should have your namespaces and directory structure set up so it all works without needing to fudge and force your include path. Why do you think forcing include path is bad? This 'autoloader' takes care of including files depending on filestructure and namespace, and it's really really simple, I love it. // autoload class madness set_include_path(implode(PATH_SEPARATOR, array( get_include_path(), PATH_BASE .'lib', PATH_APP ))); spl_autoload_extensions('.php'); spl_autoload_register(); As to why I need those constants, it's just to make it easy to reference to a path from anywhere and improve code readability. That being said, having an other look at it now it seems you are right, I can live without them, I guess they were "residues" from when I started development. (I don't use those constants anywhere in my code base except for the 'autoloader' in bootstrap.php... *shrug*) Now what about my user object? Doesn't it make sense to have it in the global scope? As you can see in my code the user object exist even for 'guest' users. &gt; The last major application I worked on contained more than 300 constants, defined across more than 40 files. I bet it, too, started with three. I'm sorry to hear that, but trust me, there won't be any more "path constant" or object in the global scope. There's no need for more. Reference to users avatars folder? PATH_PUBLIC .'/images/avatars/'; Wich now would be $_SERVER['DOCUMENT_ROOT'] .'/images/avatars/'; (without the constant I don't need) &gt; Sorry, typo. I meant big static-wrapped block. Large slab of code wrapped in a static function call. Statics are by their nature untestable. More bad juju. I'm having a really difficult time understanding tests but from what I did understand, you test your "domain / business logic". The static blocks you speak of are my controllers, how do you test a controller? Don't you just run it's route and see if there are no errors? &gt; You're looking at it wrong. When you use a framework you're not responsible for its code. You don't have to worry about its code. You don't even have to look at its code. That's a bit scary (I'm an IT guy), but I will try to do some more research. Thank you.
Exactly! Maintaining this from here on out is going to be a nightmare. Just a terribly stupid idea on his part. I do think sword is much better though lol.
it shouldnt matter. It uses xdebug extension which does debugging over tcpip
Looks like it will fit in with my dev env perfectly. I have saved the details, and will try this out on monday. If it works well, expect our shop getting some licenses...
Retina issues probably. I'm going to check it out. Thanks
App looks interesting and I'd be keen to give it a try - at the moment the fixed top nav is hiding part of the top 'hero' section - I think the icon is possibly displaying larger than you intended, stretching out that fixed nav. 
Groovy news. I'm excited to check it our
Thanks for pointing that out, I'm going to check it out !
Yes, you're right. At the end, and for understanding purpose it's better to have two method and call the one needed according to the type of the arguments. Anyway, this was just an example on how to simulate ḿethod overloading in PHP.
&gt; I think you need to set a time limit though, since people can start up long running jobs and kill your process. I agree. Any suggestions on how to fix it? I've created an issue if you want to chat about it more: https://github.com/mrjoelkemp/phpepl/issues/4 &gt; I've used the PHPSandbox library before too, it's works surprisingly well but you have to think a bit out of the box on what you enable/disable. Ideally, every function that's not blacklisted would be whitelisted; however, that's not the case with the sandbox lib. I made the project forkable (locally unsandboxed) to avoid the headaches of sandboxing. Would love some help with this. Thanks for the feedback! 
Why is this scary to you? It's an extremely obvious thing to do. Plagiarism has been around since before computers. Now it only takes a few mouse clicks. 
Thanks for this! fieryprophet fixed the issue.
Fixed! :)
Thanks again for your help :)
Don't like it - don't use it
No problem, glad to help :) Feel free to ping me with questions/comments in the future.
$70 AUD for a sublime debugger license vs $99 AUD for a PHPStorm license. Not sure this is priced very competitively.
It works great for us over Vagrant. The only issue I've had is trying to map my "local" filesystem against the remote file system running on my VM. It's quite possible I'm doing it wrong though. By the way, HUGE props for console evaluation! That was the biggest missing feature in my opinion.
Indeed quite expensive. Edit: when you use sublime, macgdpd is a nice free alternative. http://www.bluestatic.org/software/macgdbp/index.php
Looks great, will tests this out. How about a future atom package?
does PHPStorm still require a local copy of the source for its code autocomplete suggestions? because that blows. at least with sublime text and it's free FTP plugin I can edit whatever, and code intelligence can still work.
Haha, for $50 this is a joke. 
I feel like I'm missing something in your comment. Why are you editing over FTP? Either way, with any editor or IDE, you can alter remote files.
&gt; z is a just a namespace for a small set of library (route, view, form), I figured it doesn't matter that much and there's a low chance for conflict with other libraries/packages out there. Or do you mean I should find a "sexy" namespace like "Cartalyst" or "Illimunati"? I don't see your point sorry. It's got nothing to do with a sexy name. The convention usually is to have a top level *vendor* namespace. That's what Cartalyst is. A vendor. When I work inside an organization, I use the organization's name as the top level namespace. Below that, it is a good idea to organize your code into various namespaces. Sure right now you have 3 objects so it might seem like overkill, but when you get bigger and have many many more objects, organization becomes important. In your case I'd suggest: &lt;vendor&gt;\Routing\Route &lt;vendor&gt;\Http\Request (and consider a Response object...) &lt;vendor&gt;\View\Helpers\Form a hierarchy like this, complying with the various PSR recommendations, can be understood by composer, which gives you package management (so you can consume other people's well tested packages) and a handy dandy autoloader. The naming also assists with organizing your code later, and makes it easier for others to understand 
&gt; Now what about my user object? Doesn't it make sense to have it in the global scope? As you can see in my code the user object exist even for 'guest' users. it is probably a bad idea. Changes made to the user object in one place may not be expected in another place. What you are talking about sounds like a singleton. There are tomes written about the evils of singletons. &gt; I'm having a really difficult time understanding tests but from what I did understand, you test your "domain / business logic". The static blocks you speak of are my controllers, how do you test a controller? Don't you just run it's route and see if there are no errors? Your controllers don't actually look like controllers (which are objects that receive a request and return a response generally speaking)... it looks like route definitions. Typically you can and do test controllers (with mock request objects, to verify responses are returned as expected). &gt; That's a bit scary (I'm an IT guy), but I will try to do some more research. Thank you. what is scary about this? Surely your time is better spent not reinventing the wheel? For the record for what you want I don't know that a full stack framework would be in your best interest...but composer would be... go grab a good router package from somewhere, a good set of HTTP objects, etc... then just glue those bits together. 
Are you showing your errors? If not, put this on top of your code: error_reporting(E_ALL); ini_set('display_errors', '1'); 
There are two potential answers to this. I'll start with the simplest. **Helpful and simple response** It's hard to tell at a glance what's wrong here, so let's debug it a step at a time: You aren't checking for failure on your query. Do something like `mysqli_query($link,$query) or die(mysqli_error());` That will show if there's an error occurring in the background. Debug out your actual query. Then you can see what values you have in there. echo $query; die(); Debug out both the $_POST and the $sanitize arrays so you can see what's happening in them. echo '&lt;pre&gt;'; print_r($_POST); print_r($sanitize); die(); Between these you should be able to see what's happening in there. You should be able to fix it. **Less helpful but more accurate answer** There are so many things wrong with this I don't know where to begin. I strongly recommend using PDO. It makes this kind of stuff vastly safer and easier. I wrote an [article about improving how you do databases](http://www.belessbad.com/post/doing-better-at-databases) that might be relevant here. The takeaway is that using PDO would be much better, much safer, and much less code. Using an ORM... better still. Second, you need to understand "separation of concerns". Again, [here's an article](http://www.belessbad.com/post/a-concern-about-separation). Sorry about that. But the basic point is that you really should have each "thing" only doing one task. This file does a hell of a lot. It connects to a database, makes HTML, runs queries, changes output based on state, etc. You could make a much better application by separating all of those jobs out. I know this is a uni project, and you probably just want to get through it with minimal effort, but... I didn't feel I could just let that slide. If you want to improve your code, rather than just your grade, there is a lot of work to be done.
&gt; Changes made to the user object in one place may not be expected in another place. What you are talking about sounds like a singleton. There are tomes written about the evils of singletons. But this is a "web application", the client sends a request for an URI and the server sends back a response, in my case the response is an HTML page "dynamicaly generated" by PHP. Even if my user object does change it would only after a new request have been issued. If you look inside my controllers after a successfull POST or PUT request I always redirect to a GET request. &gt; Your controllers don't actually look like controllers (which are objects that receive a request and return a response generally speaking)... it looks like route definitions. What I refer to as a controller is maybe what you call a route definition. My application makes use of Apache MultiViews, what this does is if I make a request for `/user(.*)` and I have a `/user.php` file Apache will "serve" this file. In this `/user.php` file I will have my controllers for all `/user(.*)` requests. `route::get('/hello', function() { // do stuff });` is what I call a controller. &gt; Surely your time is better spent not reinventing the wheel? Pardon me but many of the components in all the PHP frameworks I checked already exists in Apache, PHP and Unix userland, most have been there for a decade and are easily used in PHP.
Hi /r/php! PHP Function of the Day is a little script I wrote to learn a new internal function every day. It's procedural, inelegant and ugly as fudge but maybe someone will find it interesting.
Ultimately benchmarks are stupid and the only reason I wrote the suite was to understand the various ways in which all these projects are implemented hence the inclusion of straight C, PHP extensions, HHVM extensions, Zephir Optimizers and CBLOCKs. As I stated in the article I needed a task that was simple and could easily (and quickly) be moved from implementation to implementation. If you have a better task in mind then I would welcome a pull request for all paradigms.
Fair point and pthreads is definitely on my list of things to dig into. I recently mentioned it in a talk I gave about functional programming. Hoping to write something about it as well.
Thank you for that summary, it now makes sense why the majority voted against the RFC.
I usually pretend that in_array() is a string function that checks whether that string is found inside target array. Like if it were OOP, I would imaging it as $string-&gt;in_array($array); It also doesn't begin with array_ like most array functions. That's how I remember that "needle" goes first here.
&gt; But this is a "web application", the client sends a request for an URI and the server sends back a response, in my case the response is an HTML page "dynamicaly generated" by PHP. Even if my user object does change it would only after a new request have been issued. If you look inside my controllers after a successfull POST or PUT request I always redirect to a GET request. You are speaking like your application will never change. If your User object in the future is shared with multiple other objects (for example, a persistence object and an authentication object), and during the request one alters the other, you may have a problem. I am well aware of how short the request/response life cycle is. I'm telling you that what happens in between can be impacted by global scope. &gt; What I refer to as a controller is maybe what you call a route definition. My application makes use of Apache MultiViews, what this does is if I make a request for /user(.*) and I have a /user.php file Apache will "serve" this file. In this /user.php file I will have my controllers for all /user(.*) requests. route::get('/hello', function() { // do stuff }); is what I call a controller. Cool. Its a router. And you are right, it is untestable (or at least very difficult to test). But don't go saying stuff like "you can't test controllers", because people do it all the time. &gt; Pardon me but many of the components in all the PHP frameworks I checked already exists in Apache, PHP and Unix userland, most have been there for a decade and are easily used in PHP. That may be so, but you are writing a lot of boilerplate code which has already been written for you, and in many cases is well tested and well maintained. I'm sorry, you asked for a code review. People are pointing out your deficiencies and you're spewing out "hurfblurf web application". Did you come here so people could point out where you went wrong so you can learn, or did you come here for an affirmation?
This should be restricted to core extensions only. Nobody wants to hear about XMLDiff ;)
&gt; If your User object in the future is shared with multiple other objects (for example, a persistence object and an authentication object), and during the request one alters the other, you may have a problem. That's the part I don't get in the context of a "web application" but don't worry about trying to explain it to me as I can clearly see that it pisses you off, sorry. &gt; But don't go saying stuff like "you can't test controllers", because people do it all the time. I never said that.
Learn to read licenses... Taylor cannot claim copyright on the whole framework. He can only see his own license preserved (which is perfectly valid). His PR does not do this so it needs to be amended to acknowledge the forker's own copyright. The sword cuts both ways.
I don't really think there's anything wrong with the tests; the way to find your place in the universe is probe the outer limits. When car manufacturers take their cars round the Nürburgring or around rally stages in switzerland, they are not usually endorsing or promoting that kind of use (though sometimes they are), afterall most cars are taken through such tests in less infamous locations. They are actually ascertaining how well the car will perform in extreme circumstances, testing the durability of it's structure, they don't expect that you will take your toyota yaris down a ski slope or through a forest. That's exactly what we are doing when we put PHP under extreme pressure, probing the outer limits in order to find out how well we can expect it to behave under normal conditions over a sustained period.
Good point! It's unfortunate that "random" doesn't always mean "interesting"! Hopefully tomorrow's will be something more intriguing.
Yes, I've done it and it works perfectly fine!
... or you could buy PHPStorm with everything including the debugger for almost the same price.
I wish there was support for Espresso IDE. 
&gt; There are so many things wrong with this I don't know where to begin. Well yes, there's a lot that can be improved. But he's a beginner and his code looks like the code of a beginner. It's quite standard to teach the 'wrong' but easy to understand way of doing things to get people started. For example working in one file can be easier for a beginner to get their head around rather than splitting everything out from day one. PDO is object oriented, something that students are normally not introduced to in their first two weeks. It can be hard to imagine the point of doing things in any other way than the 'right' way once you know them. But I think they're valid learning experiences as part of the journey to doing things the right way.
There is always so much of doing it yourself. If you wanna draw the line at PHP, fine. But why not draw the line at Symfony and abstract stuff like http and focus on PHP? It was a suggestion based on his background. If you keep pushing the argument of diy we would all be learning assembly language and soldering circuits.
Wow, what a bunch of total cunts in that thread. Why not give them the benefit of the doubt? Maybe they didn't realise they weren't supposed to change the copyright and weren't trying to "steal" anything?
Sure, there will always be a debate on where to draw the DIY line, I know. That's why I emphasized **small** so he wouldn't go build a next Symfony himself. To know the underlying mechanics and know what parts are integrated in a modern framework and know them on a basic level, that is a good idea . Building your own monster is not. The knowledge of building a basic framework and the knowledge to use it (the blog suggestion in my previous comment) is, in my opinion, good foundational pieces for a portfolio. Hence, emphasize on **small**, on both the framework and the blog.
Whether he makes money is irrelevant, he's still breaking the license. The commenters are still being complete dicks though.
No that's exactly how it works. The original copyright must be left intact, which it is. There is nothing prohibiting further copyrights.
The way they are used in Hack language seems to be a little different from your understanding of generics in general. Whilst they may in other languages be a bit different (Java, JavaScript, etc) where you can created new Float32Array or whatever, in Hack that exact same functionality would be array&lt;float&gt;, using generics with some automagic meaning there is no need to define a collection. This to me seems like reason enough to make the arrayof syntax available and generics maybe available later as something you need to actually define, but other people seem to see it differently. 
This type of automatic dependency resolution is great for smaller applications and prototyping. And since Silex is built on top of Pimple, you could use this builder in your Silex apps!
OP is at Uni though, he will probably get downgraded for doing it the correct way :( doesn't that suck?
Thanks for the input, I will be looking in to everything you mentioned. As u/frazzlet mentioned, we haven't done any object oriented programming yet so maybe that's why we're not using PDO. Regardless, it's good to know everything that you mentioned. As you mentioned in your article I will take a look at PHP the right way. Thank you.
Why in god's name are you editing over FTP?
You're right, we haven't learned any object oriented programming yet so that is most likely why we're not using PDO yet. However it's always good to know that there are better ways so I can do some research on it. 
You could start by writing a basic CRUD interface, ones I quite often seen in programming books are a basic shop, blog and task list. As ButIamSuperCereal said, "people" always say not to reinvent the wheel, but "people" are wrong, especially when it comes to learning, reverse engineering and figuring out how someone else did something and more importantly *why* they did it that way is incredibly important and involves a lot of reinventing wheels while you learn the pitfalls of certain methods. 
I keep them to 2-4, after that create a single $args/$params array to house them.
Wouldn't you just point it to the folder Vagrant is mapping between them already? For example, I use NFS to map the www folder in each project to the Nginx document root like this: config.vm.synced_folder "www", "/usr/share/nginx/html", :nfs =&gt; true So ~/projects/projectname/www should do it, no? (installed Codebug last night, haven't had a chance to actually fire it up yet)
I know the [Laravel IoC Container](http://laravel.com/docs/ioc) does [automatic resolution](http://laravel.com/docs/ioc#automatic-resolution) like this as well, and it's very handy. I even use this library outside of Laravel, as it has no other dependencies. It will even resolve dependencies based on interfaces, which is awesome. You can change your implementation so easily. Having said that, it will not automatically inject regular variables like this does (ie. the $name), and I'm not entirely sure how I feel about that feature anyway. Generally I like class dependencies to be objects.
My first real php code was a simple live chat. (because i wanted to make a IRC-like xD)
often times when a function requires a lot of arguments they are not all required or you might not know how many parameters to pass or why they will be called, function that do db queries for example. Passing an array allows you to simple use the isset() on an index instead of having to pass a false value.
I'll add this one to my list, I like having these as a PHP-fiddle... * [codepad.viper-7.com](http://codepad.viper-7.com/) - the first I found, has option for many different versions * [3v4l.org](http://3v4l.org/) - autoruns against many different versions, includes VLD opcodes, and has a performance graph * [ideone.com](http://ideone.com/) - supports like 60 languages 
After writing my own recursive IoC Container w/auto-injection to see how this concept works under the hood, and using Laravel's, I'm now 100% convinced that an auto resolving DI Framework / Container should be at the heart of any PHP framework or application these days. I would argue that it's the only way to make complex PHP applications, maintainable. Yes, containers like Pimple also help make PHP applications maintainable, but if you have a REALLY big application, maintaining your Pimple wiring is too much of a maintenance nightmare. The only "restriction" this places on your code is architecting it in such a way that everything resolves through this container, and that it's easy to use the container to resolve out other dependencies.
Instead of limiting yourself to an arbitrary number of arguments, ask yourself if the variable you're about to add will cause your function to violate the Single Responsibility Principle. For examples sake (don't really do this. There are smarter ways to add 10 numbers): Need to add 10 numbers together? Use 10 arguments. Need to multiply that result by a number? Don't add an 11th argument as the multiplier. Create a new function that takes two numbers.
Don't use arrays for your arguments unless you actually need an array of data. Create more methods instead.
I would argue that if your method/function depends on only some of its parameters, it's a bit of a code smell and an indication that your method is trying to do too much.
Injecting while building an object, and injecting while calling a callable is not the same thing.
It would also be possible to build a shareable link into phpepl – making it more like a fiddle. We could add the code to run as part of the url's hash, bitly encode the full url, and allow a copy-to-clipboard of the generated share url. For decoding the url, upon visiting the page, the JS would detect the hash, then load the code into the editor. Newlines should be preserved in the encoded url, so that the code looks formatted when pasting it back into the editor. Thoughts?
It's a mac app - staunch OS X supporters are used to being gouged.
If someone came out with a ST debugger plugin for Linux (the fact that this is mac-only is ridiculous all on its own) I would try it. However, I'm not going to buy an interface for xdebug that costs more than the editor does. That's just silly.
That's sort of my point.
Although this may be more down and dirty than you might be asking for: [PHP Internals](http://www.phpinternalsbook.com/index.html)
I've experimented with a number of different mappings on both my host and the VM and haven't found a combination that works. I'll try it again with 1.0 myself and see if I can get it right.
pretty much the same thing to me
[I use Vim](https://github.com/enrichit/dotfiles/blob/master/.vimrc) and I love Vim (I even use Vim mode in ST3) but I still make a lot of mistakes and it requires more brain power. I guess you could say Vim is always reminding me that I'm using it, whereas Sublime sits in full screen mode on my second monitor and I just forget that it's there. Also, the speed increase I get from Vim over ST3 is minor. You can get away without using the mouse quite a lot.
the fact that is mac only is as stupid as it would be windows only. Yet most linux people seem to enjoy ranting on mac more then on win only. 
Yeah as a developer, I'm less worried about "memory hogging" and more worried about functionality and tools. 16GB of RAM should be a half-day's work or less for most professional developers, cost-wise, so it's not like adding memory is prohibitive these days.. If you're not using an IDE *solely* because of memory concerns, you're probably looking at your priorities wrong. That said, it's never a bad thing to have multiple choices in the market, so it's nice to see this program out there.
Just about everyone has or can get access to a Windows box, and anyone can have access to a Linux box regardless of what they're running. OS X on the other hand only runs on Apple sanctioned hardware (unless you're building a hackintosh which in my experience does not work very well) so you're severely limiting your audience.
And, round() in PHP returns a float which seems stupid because you typically would expect to round to an integer. The rounding to an arbitrary precision that returns a float should have been placed in a separate function. PHP has had support for arbitrary precision numbers since PHP3. There's no reason not to use them. 
Who doesn't love commented out code in production?
Line 24: Boolshit if (($info['generate']) &amp;&amp; ($bean-&gt;Generate == 'N')) { $client-&gt;setGenerate(false); } elseif ((!$info['generate']) &amp;&amp; ($bean-&gt;Generate != 'N')) { $client-&gt;setGenerate(true); } 
I just can't get past the superfluous parenthesis. Why do people do that? Are they trying to make their code look more complicated to try to make themselves look smarter? Of course, what the heck do I know. I'm just a waitress and not a multi-millionaire exchange owner. 
Hardcoded queries &gt;_&lt; Schema within the file. Am I mistaken or is this all one file? Yikes.
Parenthesis are not the same thing as curly braces. Parent is complaining about this: ((!$info['generate']) &amp;&amp; ($bean-&gt;Generate != 'N')) ... because it would be slightly more readable like this: (!$info['generate'] &amp;&amp; $bean-&gt;Generate != 'N')
Yeah, this is what you get when most of the community is made up of very young people. 
To be honest I prefer the former, the parenthesis break it up into readable chunks. Maybe not so apparent here, but throw a third conditional in the mix..
I think jen1980 is referring to the extra brackets in the condition, not the curly braces. 
Syslogs are for pussies. Every time there's an error let's just email a bunch of random people with addresses hardcoded in the source mail('mark@ookoo.org', 'BLOCK IMPORT ERROR', $e-&gt;getMessage()."\n\n".$e); mail('mark@tibanne.com,luke+eligius@dashjr.org', 'SSH connection to freetxn@'.$ip.' failed', 'Used ssh key 14a70b11-5f36-4890-82ca-5de820882c7f, but couldn\'t login to push those txs:'."\n".implode("\n", $el_todo)); mail('mark@tibanne.com', 'FAILED TO GENERATE REDIRECT TX', 'Error '.$e-&gt;getMessage().' on: '.$wallet_info-&gt;Money_Bitcoin_Permanent_Address__."\n".print_r($bean-&gt;getProperties(), true)); 
I'm agree with you. Pimple with medium/big application is a nightmare. I've use Pimple in this example only because it's easy to explain. But in fact I prefer to use Symfony's DIC component (because I know it best, only).
I've tended to use static when I know won't be needing more than one instance of the class in any circumstance, since it makes things a lot simpler and cleaner. You don't need to worry about scope, for instance. MyClass::getValue() works the same no matter where you call it from. Some would object to that though, as having an object instance to pass as a parameter can be handy in larger, more convoluted projects. For instance, say you have a function that recieves a database object as a parameter. This function can then operate on several different database types without even knowing, as long as the database objects implement the same interface.
It frightens me that this code was running behind a stock exchange site.
To [quote HN](https://news.ycombinator.com/item?id=7332992), where someone put it better than I could: &gt; Some random red flags: &gt; &gt; - There's a class with the name of the application. (Issues: Scope, SRP) &gt; - There's a class with 1708 lines of code. (Scope) &gt; - There's a switch-case statement that runs over 150 LOC (readability, maintainability) &gt; - There's a string parsing function in the same class as transaction processing (Separation of concerns) &gt; - There are segments of code commented out (are they not using source control?) &gt; - There's inlined SQL (maintainability, security) &gt; - There's JSON being generated manually &amp; inline (SoC, DRY) &gt; - There's XML being generated manually &amp; inline (SoC, DRY) &gt; - To sum up function `_Route_getStats($path)`: XML production, JSON production, file writing, business logic, SQL commands, HTTP header fiddling, hard coded paging limits, multiple exit points... &gt; &gt; The amount of refactoring needed here to bring this code up to acceptable quality is simply staggering. This is on top of the actual *errors* in the code... e: [Of course, no, there is no source control used at all](http://www.wired.com/wiredenterprise/2014/03/bitcoin-exchange/). Emphasis added: &gt; Mt. Gox, he says, **didn’t use any type of version control software** — a standard tool in any professional software development environment. This meant that any coder could accidentally overwrite a colleague’s code if they happened to be working on the same file. According to this developer, the world’s largest bitcoin exchange had **only recently introduced a test environment**, meaning that, previously, untested software changes were pushed out to the exchanges customers — not the kind of thing you’d see on a professionally run financial services website. And, he says, there was **only one person who could approve changes** to the site’s source code: Mark Karpeles. That meant that some bug fixes — even security fixes — could languish for weeks, waiting for Karpeles to get to the code. “The source code was a complete mess,” says one insider.
*shudder* I've seen that in code where I work
*bitcoin exchange, not stocks Which is probably even worse since bitcoin transactions can never be reversed.
Commenting - poor men's versioning system :)
Putting parenthesis that are not needed creates superfluous complexity. Makes it also harder to balance them when counting opening/closing parens.
One thing is Dependency Injection and another one are Dependency Injection Containers. Dependency Injection is a way to decouple components. Instead of creating new objects inside our objects ("new" keyword inside our function), We create our objects outside and pass the reference. Looks complicated but it very simple. Read about SOLID principles (especially the D - Dependency Inversion Principle). When we use Dependency Injection intensively we will need to face to one problem. As we create the instances "outside" this "outside" can become a mess. Dependency Injection Containers (aka DIC) are tools to handle this mess and turn it into something maintainable. A good tutorial about DIC is http://symfony.com/doc/current/components/dependency_injection/introduction.html.
Ooh! One of my favorites. It's a great way to accidentally end up with 100,000 emails in your inbox.
Wait till you graduate and become a professional programmer.
Wow.
Namespace "Money" - looks sound to me. :)
unless I'm reading wrong here and it's very possible, the smallest portion of a bitcoin is .00000001. You hardly ever deal with whole numbers in bitcoin trading. If I want to buy 1 bitcoin there's also a transaction fee where I might end with .99876512 bitcoin.
You count?! I'd suggest getting an editor that tracks that and supports 'goto opposing bracket'. No matter your opinions on this nested bracket discussion, counting brackets in a text editor is pretty 1976.
I'm amazed nobody else has seen this yet, I posted this elsewhere, but this seemed like a better place. In the spirit of reddit, I will leave a slight bit of detective work up to you to see if you can figure out what exactly is that wrong: The problem I see involves lines 581-584, which seem like pretty important lines of code in the sendAmount method. Do you see what I see? (hint for late comers: the real problem is on line 578)
[PHP-DI](http://php-di.org/) then!
Another app with a built in Mac-tax...
First off, you really should be sanitizing all user generated input, better to get into good security habits right when you're learning. As far as why it's not mailing, I don't see anything in particular that stands out as blatantly incorrect. Try checking your server logs for the error message it's giving and post that. If there's nothing in the server logs, there is a chance the server doesn't have sendmail installed or it may be misconfigured.
This strikes me as somewhat similar to [Aura.Marshal](http://github.com/auraphp/Aura.Marshal), which you seemed to disapprove of in [this Reddit thread](http://www.reddit.com/r/PHP/comments/1y5occ/a_databaseless_nonorm/). What would you say are the major differences between the two?
there is a return before that statement, so does lines of code are in theory commented out of the function
Yay! I found _a_ method with a doc block! He's well on his way to becoming a professional programmer.
Thanks mate. I do understand the concept with D.I. but with OPs link, why are we masking another objects method call (a-&gt; hi, b-&gt; bye) instead of just calling them directly? 
Exactly. Maybe that was actually one of MK's little "lazy programmer tricks" that was a half-assed way of commenting out code, but still, as a programmer, that would terrify me until I was able to hunt down what that code was supposed to be doing and if it was in fact being done elsewhere or if it was actually needed. Of course, as a programmer I would be doing this in some sort of version control system, comparing diff's and such to hunt down the line of reasoning, so I can only imagine one day suddenly the code was returning 5 lines earlier than before, with no comment as to why, and old code left in place. It's like, old school version control kind of?!
You are correct. Fixed my post.
I've seen much, much.. much worse. Shield your eyes everybody. :D
the use of a return as a 'comment' made me cringe
It's a good question. Do you have a Laracasts membership, because you may find the [Controller Cleanup](https://laracasts.com/lessons/controller-cleanup) screencast quite helpful.
Copious instances of calling die or exit
&gt; Mt. Gox, he says, didn’t use any type of version control software :o wat this website controlled half a billion dollars worth of assets.... and it wasn't even version controlled.... 
I'm a new developer, so could you explain to me why this is bad? I have a site that dynamically creates an XML for excel export using a string, and while I know it's clunky, what would the best practice be?
So you're saying that ***namespace is money***?
I get a 500 error when I try to sign in with demo/demo
Apple's fail was with curly brackets. Do you have trouble differentiating between parenthesis and brackets? 
I actually don't. But I have looked at many ways of doing this. However, there seems to be no clear "best practice" way of doing it. Besides, every validation error needs to return some sort of a message to the API client telling them what went wrong, which makes the whole thing even worse. How do you do it?
we all have to learn one way or another
If they were going for minimal readability they could have gone with. $client-&gt;setGenerate(!(!$info['generate']) &amp;&amp; ($bean-&gt;Generate != 'N'));
Wanna guess how much testing they ~~do~~ did?
Use a template system, or some type of XML Builder. If you're using PHP, even something like building your XML out of Twig templates is better/easier to maintain/less error-prone than having it all jumbled up with the rest of your code.
You know, I actually interviewed here a couple of weeks ago. I didn't get the job because (IMO) I raised concerns about the development standards and the fact that I was told outright to suck up to the CEO to get the position. Bullet fucking dodged.
That sendAmount() method is a mess but how is the return on line 582 being used as a 'comment'? Not that line 582 is a good example but 'return home early' is a pretty common technique to avoid a boat load of conditional statements.
It's a pity to see this code. It's shit like this that gives PHP a bad name. LOL, LOOK AT THIS SHIT! PHP SUCKS, AMIRITE? Everything about this speaks of a talentless self-taught cowboy "programmer" who fancied himself a CEO and *entrepreneur* hacking away at a fucking Magic the Gathering online trading system and then deciding it was enterprise ready. But no... people are going to blame PHP.
Some wiseguy changed the password for the demo account. I've changed it back but there is nothing in place at the moment from preventing it from happening again.
The static methods and lack of dependency injection suggests there was no testing at all. The CEO talked about himself like he was a engineering genius. :/
We use form libraries for the same reason we use other libraries. To improve productivity. A good library (note, this is a GOOD library, not necessarily all) will abstract out some of the handling of errors, reposting data, security features, etc. Some, such as the one built into Laravel, will do things like auto-populate values for edits, keep changes on errors, etc. In general, though, they allow you to do more functionality with less code. There are downsides. You bind the form to the framework or library. So if you find yourself changing PHP frameworks, your form needs to be rebuilt. Probably not too much, but still. However, if you find yourself changing to something like an Ember or Angular JS "Single Page App" model you have a lot of rebuilding to do. IMO the compromises are worth it for the features provided.
My b. I meant like phone home early. A break that saves that code. 
Cool, I don't have a huge problem with it. It's not like a continue or something. A method can only return once. That code below can never be executed if the is condition is met. In the case of recursive functions they have to operate like that. That said, like anything there are rules / exceptions. In an ideal world there would only be a single return statement per method. In the request/response world this is often an unrealistic requirement.
As a related note, what are some good form libraries that are decoupled from a framework? I've been trying to get Symfony forms working outside of Symfony, but it seems you're stuck using a templating engine with that instead of being able to just echo form outputs.
Can you guys do it with BTC-e and coinbase?
I don't know whether to laugh, or to cry at the fact that this clown was able to fool us into handing over any amount of money or bitcoin to him.
Ha! I didn't look above that block. Thanks for the info. I guess indentation and brackets come in handy after all.
This may be a stupid question, but i really want to know the answer. They seem to have a lot of random \'s in the file, i know why they use it for say SQL strings, but they use it on other things to... eg \DB::DAO('Money_Bitcoin_Available_Output')-&gt;insert($insert, true); $db = \DB::i(); throw new \Exception('Method is deprecated') $list = \DB::DAO('Money_Bitcoin_Process_Tx_Out') What on earth does \ do in this situation? 
So - what happens when $bean-&gt;Generate DOES equal 'N' and $info['generate'] is false? I guess that's when Jack comes in with the magic beans?
thanks bopp to sharing a valuable comment. Really appreciate your efforts
You really should be using a templating engine anyway. There's sort of an assumption with a lot of web development tools that you're doing things "correctly".
and what informs you that you've got an error in your syslog?
Instead of including DB in the use statement, each use of the DB class comes from the root namespace. It's the same reason you see "catch \Exception" and the same behavior in other instances.
&gt; And, round() in PHP returns a float which seems stupid because you typically would expect to round to an integer. I think `round` returns a float or the same as the input type in most languages.
Not sure why the downvotes, these ARE superfluous. People, stop being dicks. People do it for a couple of reasons. One that I've been told is because you have to, otherwise it breaks. This is, of course, not true, but people often believe shit that isn't true. Another reason is because sometimes it doesn't work. If you have more complex conditionals, like the following, you definitely do need it. if( $user-&gt;id==$item-&gt;owner &amp;&amp; ($user-&gt;is_admin || $user-&gt;is_editor )) The final reason you need it is that.. well, it kind of just helps keep it clear in your head. It's a bit like how we group phone numbers by 3/4 digit blocks. Thinking a block at a time can help make it more clear. It's unnecessary, and in some cases can reduce readability, but it's pretty subjective. 
`array_map()` also can accept 1+n arrays to map over, soooo yeah.
At this point I'm just hoping they had a development server lol
It was probably Mark's laptop lol
Definitely. It's mostly CYA.
Due diligence and a number of server monitoring systems that will alert you without flooding your inbox. Imagine an error that effected even 500 visitors causing 500 emails to be sent your way, that would be horrible. 
ah ok ty
FWIW, the site was purchased from the original owner, who *wanted* create a MtG trading site. It's not clear if the card trading site ever went live. The existing code and ownership are different thing entirely. That doesn't make Magic the Gathering Online Exchange any less *hilarious*, but it'd be dishonest to blame that. &gt; Everything about this speaks of a talentless self-taught cowboy "programmer" who fancied himself a CEO This is still true. Worse, he thinks himself a genius. He's insane enough to have written [an ssh daemon](http://blog.magicaltux.net/2010/06/27/php-can-do-anything-what-about-some-ssh/) and [a DNS daemon](http://blog.magicaltux.net/2010/03/19/simplednsd-new-features-bugfix/) in PHP. The code is of similar questionable quality.
yes, but if you throttle the emails... report the first one immediately, and then aggregate for the next 6 hours or so.
My understanding is that it was actively developed as a MtG trading system and was fully functional, but I could be wrong there. From Wired: &gt; McCaleb had registered the Mtgox.com web domain in 2007 with the idea of turning it into a trading site for the wildly popular Magic: The Gathering game cards. He never followed through on that idea, but in late 2010, McCaleb decided to repurpose the domain as a bitcoin exchange. The idea was simple: he’d provide a single place to connect bitcoin buyers and sellers. But soon, McCaleb was getting wires for tens of thousands of dollars and, realizing he was in over his head, he sold the site to Karpeles Hmmm... it seems you're right. It may have changed tracks mid development. It's hard to tell how far along the "Magic" path it got. But I think we can agree regardless: this was not built with the rigor and professionalism one would expect of financial software.
There was no testing at all. There was version control, though. source: interviewed there a few weeks ago.
Don't be snarky. Everyone knows that this is NOT a version control solution. Proper version control is done like this: `file_old.php`.
Any red flags stick out during the interview process?
Could you be more specific about your filter comment? If you're taking about the clients module, the filter on that has not been fully realized. I created that module for a CRM for my job but it hasn't been fully flushed out. Regarding the background image, that particular image is probably a bad choice to begin with since it's a pretty large file, I just really liked it and haven't changed it, plus it hasn't been an issue on my local running build :). The demo that is running is a little behind the master branch but there should be proper http cache headers being sent along with all assets. I'll have to take a look at it.
Yeah. A number. Mark accounted for most of them, tbh. Even before I went, the recruiter kind of made it clear just how "big a deal" he was, real IT genius. I wondered right from the start if that was coming exclusively from Mark. Also possible he was a big deal, but only in the Bitcoin world. I don't give a fuck about Bitcoin, frankly, but a job is a job. More particularly, in my case, a job is a visa. Anyway, in the interview I was pretty much told that I was "the man", but that for the second interview I'd be meeting Mark, and that I really needed to make an impression on him. I was given Mark's Github details and online persona to stalk and told to really be impressed, look at his code and tell him how great it was. Suck up, basically. I don't just mean it was implied. I mean I was told outright. To me, this is a giant fucking scarlet flag. If you're hiring based on who tells you how awesome you are, you're not hiring the best people, and as a result your team is going to suck. If you care about this you're probably an egotist, and you probably are a giant cock to work for. This is magnified when an egotist is the owner of the codebase. How is a guy like this going to handle being told "your code is shit, and you need to refactor it to conform to a rational standard"? Nothing else I was told contradicted this. The guy who interviewed me made it clear that he was trying to make changes. He was in the process of implementing proper bug reporting, for example. They were setting up Jira. Previously things had been... not... managed. He'd gotten version control implemented. He wanted to get unit testing happening. I have to be honest, I don't mind these things. A company doing them is great. A company that's trying to get there... you know what, that's fine too. I'll come for that ride, I'll help out there. The one thing I won't put up with is not doing it, not seeing the need, and aggressively resisting improvements to process and quality assurance. I got the feeling the guy interviewing me was meeting resistance, and that part of the reason he was keen on me was that he wanted someone who had experience using/administering the things he was so enthusiastic about putting in place. An advocate as well as a coder. The job, by the way, was a front-end job, not a back-end one. Anyway, I have to be honest, despite all the red flags I'd have taken the job if it was offered. I expressed great concerns about the standards of code and the attitude, and I believe I wasn't hired on the basis of those concerns.
So...you're making a website. You make one page, get it all nice, just how you want it. Then you add a second page. You realize you need that super cool string formatting function you made for the first page, so you copy it over. Then you add a third page. Man, that string formatting function is really handy. Better copy it over. A couple weeks go by, and then you notice there's a bug in your fancy string formatting function on page 3. You fix it. Another week goes by and you notice that it's broken on pages 1 and 2. Oops! Forgot you needed to update those ones too. You know, this is kind of annoying, wouldn't it be nice if we could put that function somewhere else so we didn't have to update it in 3 or more places every time we want to update the function? OK, let's create functions.php and then include it on all 3 pages. Awesome! Now we only have one copy of the function and it's much easier to maintain. Time goes on and you add hundreds of these helper functions. Woahhh..functions.php is really getting way out of control. I can hardly find anything in this darn file anymore! I wish there was a better way to organize these functions... I know, why don't we split the file into several smaller files. We can put all the string functions in one file, the date functions in another file, the math functions in another, and any function that has to do with "users" in another file. These "user" things are kinda funky though. I'm storing all my user data in an array, and then when I want to check if a user is authenticated, I call `is_user_authenticated($user_array)`. And if I want to get the age of a user I call `get_age($user)` but I have to make sure `$user['date_of_birth']` is filled in. And I keep forgetting what 'properties' a user has. Did I split name into first and last name? Do they have a username? A password...? This is getting kind of messy. Wouldn't it be nice if there was a way I could group all this user information into one neat little package? Enter classes! &lt;?php class User { public $firstName; public $lastName; public $dateOfBirth; public $isBanned; public function getAge() { // calculate age here return $years; } public function isAuthenticated() { return $this-&gt;isLoggedIn() &amp;&amp; !$this-&gt;isBanned(); } // ... } For a simple website you might be able to get away without classes, but as you become more experienced and the site gets bigger you will see how important keeping your code organized becomes.
There are two ways to look at classes. The most basic way is the way /u/ellisgl described them... groups of common functions and variables. The `User` class might have lots of functions that make sense to belong to a "user" system. Like saveUser, updateUserDetails, etc. These sorts of functions... it makes sense to group them, and classes are one way of doing that. It also means you don't have to reuse terms like "user". You can call a function `save()` because `User::save()` is a completely different thing to `Product::save()`. Kind of iffy namespacing. A more advanced way of doing things is using **Objects**. This means that the class doesn't just represent a concept, but an actual thing. So, for example, the user class becomes a representation of a user. class User { public $data = array(); public function __construct($id){ $this-&gt;data = $this-&gt;getUser($id); } private function getUser($id){ //this is not a real thing, I just couldn't be bothered // properly implementing a PDO call return $db-&gt;query('SELECT * FROM users WHERE id = '.$id); } } The above is not great practise or great code, it's just a really uber-simplified object form. It's hard to show the usefulness of this without writing a ton more boilerplate that saves the user, updates the user's details, etc. But suffice it to say, when you have a user object you can then do lots of things with it that make sense. $user = new User($user_id); $user-&gt;addOrder($orderArray); $user-&gt;update($_POST); $user-&gt;save(); Because `$user` is an object that represents one actual user, the way of thinking about that user becomes simplified and clarified. 
At the very least, in most cases you'd call some kind of standard library to format them, you'd think. Hell, even global constants would be clearer.
Can't happen. We've checked and.. Yeah, but what if CAN'T FUCKING HAPPEN LA LA LA
I like this a lot. You have a clean and consistent coding style and you do a lot of unit tests and documentation. A few notes though, and forgive me if I seem presumptuous. The following things I would like to see and I think would greatly improve the impact of your project. * composer support * continuous integration * project-wide PSR-0/4 compliance Finally, and this may seem nitpicky, but I also personally find it favorable when a project doesn't rely as much on global scope and static methods(ostensibly more testable that way) Anyway, this is very cool and keep up the great work! 
Sounds like you dodged a bullet. The interviewer seemed to make it clear that sucking up to Mark was how anything got done. Whether it's getting a job, or getting version control. God knows you don't want to work for someone who constantly needs their ego stroked in order to get things done. Mark sounds like a 3rd class Steve Jobs. He has all of the ego, and none of the natural talent.
Nah, just push the changes live. Panic and revert quickly via FTP when you fuck up. Sorted! &gt; *Shit, just pushed breaking updates and my wifi is down. Ah well, time to take the money and run...*
SVN? Pft, you have to use Git or you suck. Joking. I'm really fucking sick of people telling me what I'm still doing wrong every time I improve. What, in the last 18 months you've learned LESS, Ember, Git, Unit testing, TDD, Bootstrap, Laravel... But you don't use Vagrant? DIAF, NOOB. And yeah, I worked in places that did similar things. More often we just make changes and upload them. One place I tried to convince to use SVN (Git wasn't popular at the time) and they didn't want to because it "took too long". It's faster, easier, and safer. Unless you're fucking retarded.
Yep. One thing I've noticed about these kind of people is their talent rarely matches their ego.
Ha, while it is a good idea to always keep learning and teaching yourself it shouldn't be a "race" to keep up with the cutting edge. Different tools for different jobs and all that. The right time will come to learn the right tools. The lead programmer's excuse when I insisted we all start using svn was that "the designers just won't get it." There was a very blurred line between designer and developer there, so everyone's hands were in the code (even the CEO's which always turned out to be a giant mess I'd have to clean up later...) In the words of Robert C. Martin... &gt;The way to go fast, and to keep the deadlines at bay, is to stay clean. Professionals do not succumb to the temptation to create a mess in order to move quickly. Professionals realize that "quick and dirty" is an oxymoron. Dirty always means slow!
Yeah. Lead programmers can be good positive drivers of best practise, or a damn nightmare if they're dragging their feet. Last place I worked the lead programmer was pretty much incompetent, and anything that wasn't done the way he would do it was just wrong and silly. That it was easier, faster, more reliable, more maintainable, less error prone, less code, more standard, more idiomatic.... none of that mattered.
Yeah, it was definitely his way or the highway. Then they hired another dev who thought he was hot shit because he could program in a few lower level languages. When I suggested we replace the md5 hashing of passwords in the database with mycrypt he told me something to the affect of "If someone has already broken into your house, they're already going to rummage through your stuff. What's the point?" This was about a week before one of the servers we hosted was compromised and I made the amazing discovery that an application that was currently being updated to be PCI compliant was still storing credit card numbers in plaintext. Told you so? I facepalmed so hard that day. I couldn't believe people like this were getting better work and more recognition. Because if the CEO and the one PM we had liked you they would play favorites and assign the new projects to the favorites and leave the legacy code to those of us who were not as well liked. 2.5 years of that was enough.
Yeah, I replaced someone in the last place I worked who was actually even MORE incompetent than the lead. So she looked up to the useless lead as a mentor, learned his "skills". Etc. When I left, I knew that telling him the project was bad wouldn't work, there would just be the usual bullshit about "academic" code. So I sent a five page document to him and (in theory) his boss. It detailed exactly what was wrong, why it was wrong, where an example of that issue was, how it could be fixed, and what would be a better way to do it. Here are some fun highlights: Ancillary data is routinely “stored” in global constants. For example, where a status of some kind exists there are multiple constants STATUS_OK, STATUS_DECLINED, etc. [major project] contains nearly 300 constants defined in 40 different files. BTW, this is how jquery ajax calls were done all through the site: var call = {}; call.cmd = 'display_plan'; call.project_number = project_number ; call.sections = sections ; var url = 'section_query.php'; callBack = function(txt) { update_section_content(txt); $('#plan_record_'+project_number).html(''); }; $.post(url, call, callBack); I have no idea why. 
That's true, but when it does matter (like it did for me for a car rental site that charged by the hour...) then it's not fun.
Then it doesn't call the $client-&gt;setGenerate() function. That isn't necessarily a bug, that's likely how the code is supposed to work.
All the superfluous parenthesis make the code more confusing (as someone else mentioned... and got down voted) and I think that lead to you writing code that doesn't do what you intended. I don't think you meant "!(!$info['generate'])". That's the same thing as just $info['generate']. But in any case, I think I know what you were trying to do, but it still wouldn't do the same thing as the original code. The original code doesn't call $client-&gt;setGenerate() at all in certain cases (such as if $info['generate'] is false and $bean-&gt;Generate == 'N'. 
Yeah, I was only there a year. 
I know this isn't popular opinion, but I really like brackets and parentheses. They help me keep track of scope - on top of nice indenting. I dunno, it's just easier to have a marked start and end.
He's not arguing whether or not they're necessary, just that he likes them because they make it easier for him to see the separate chunks of logic.
This isn't something you can just do to any old website, the source was leaked by someone who hacked their website.
Who needs to comment their code? That's for pussys, and no fun for the next bug tracer. 
I highly doubt critical systems in most banks are version controlled. Most of them are running ancient COBOL crap that predates version control...
&gt;It's shit like this that gives PHP a bad name. No, this stuff just adds to it. PHP has no shortage of its own problems, and dismissing the many legitimate criticisms is ridiculous.
1. I think the library would be less error-prone if the rules would be defined as arrays instead of english phrases. 2. What happens if the columns are not prefixed? (the country name the column `country` in the result set but it is in the column `name` from table `countries`) 3. Why does re-loading the resultset does not discart the changes that were made. It seems to me that if one calls `$entities = $eb-&gt;getAll();` the desired result is to have access to the original data.
This is exactly how orm eager loading works ib phpixie framework )))
You'd have a valid point if that's what I did. It's not like there was tiny text underneath what I wrote that dismissed all of the idiotic legacy bullshit in PHP as legitimate complaints. PHP has **tons** of problems, then and now. But they're exacerbated and publicised by shithouse codebases like this. No one mocks PHP because we don't have scalar type hinting. They mock PHP because yes, the API is a cluster fuck. But mostly they mock PHP because they see retard code written by retards, and assume that's what PHP is for. IMO.
This is so wrong... How is this: class MyClass { public function __construct(Dependency $dep) { $this-&gt;dep = $dep; } } coupled to any container? You totally mix things up, sure annotations (as they exist now) couple your code to a container, however autowiring definitely doesn't. Because it doesn't affect your code. If the user of your class decides to use autowiring for building the dependency graph, it has absolutely no impact (and it shouldn't) on your class… And furthermore, in Java annotations for injection are standardized. Which makes using annotations not coupling to any container. So just take a step back before jumping in the wagon of "this is service location, not DI" because that's trendy. Here you are completely wrong.
there's a startup for that http://www.bugsnag.com/
&gt; I still don't see the issue with hardcoded queries. Separation of concerns, this class does wwaaaaaaay too much, and holding all the queries is just another thing for it to do. Queries, specifically, become a maintenance issue quickly. I've worked on legacy systems where there are three or four or ten versions of the same basic functionality, just doing a different `order by`, or grouping slightly differently for reporting. Add a field, rename a field, best pray you updated all of them. &gt; How often to you change your DB schema All the time, especially early on, or in a site in active development &gt; and how would that not break even if you used an ORM? Migrations
Or had access and decided to shame.
[The leaker claims to be a Russian Hacker](http://techcrunch.com/2014/03/03/mt-gox-source-code-leaked-by-hackers-along-with-team-information-customer-data/), although they could be lying. Plus, honestly even with code this bad, that'd be pretty unprofessional and isn't a great idea when your (former, I suppose) employer is deeply in the red from being sued and loosing customer assets. (As in, they're desperate for money and will sue you for everything you're worth in return.) Although if Mt. Gox was run as poorly as its code was written, it would not surprise me too much if they failed to add the proper clauses to their employment contracts to allow them to properly retain copyright to employees' works.
&gt; I think the library would be less error-prone if the rules would be defined as arrays instead of english phrases. This is done to improve readability. Rules specified in arrays are hard to write and hard to read. &gt;What happens if the columns are not prefixed? (the country name the column country in the result set but it is in the column name from table countries) It wont be able to identify the which columns belong to which entity if the columns are not prefixed. Why do you think it matters. aliasing columns wont limit your query in any was as far as I know. &gt; Why does re-loading the resultset does not discart the changes that were made. It seems to me that if one calls $entities = $eb-&gt;getAll(); the desired result is to have access to the original data. Usually you want to preserve all the changes that has been done to an entity. Suppose if you load a User object with id 10 into the memory and does some modification, like change its name attribute. And suppose you run another query who's result also contain the user with id 10. Your logic will break if the old values fetched from the db overwrite the change done to this entity. Because a user entity with id 10 will have old name, when you know that you have set its name to a new value 2 lines before. So you want the library to return the original entity, instead of making a copy of User entity using values just read from the result set. So basically there should not be more than one User entities loaded into memory with same id. Anyway, I don't think I can explain better than [this article by Martin Fowler](http://martinfowler.com/eaaCatalog/identityMap.html) 
You can try Wardrobe CMS. Is built on Laravel4 which very popular these days. http://woazala.com/post/wardrobe-cms-blogging-made-simple
Can you tell me how they are similar. I checked this page http://phpixie.com/tutorials/orm/ and I was not able to find an similarity. 
Oh totally. If it was someone "in the know" they'd be dumb to share.
Yeah, I've used Wardrobe, it's a good option.
Honestly, I hate Wordpress, but... this sounds to me a hell of a lot like a job for Wordpress. Wordpress gets misused badly as a CMS and a "framework" by people who are (frankly) stupid. But as a blog it's moderately capable, and certainly easy. If not, I'd recommend Wardrobe. It's built on Laravel, and is decently easy to setup.
I'd argue that having code that is close to unmaintainable is a bug in and off itself.
When you mentioned small. [This](http://ghost.org/) came to me. Not PHP though, written in Backbone &amp; Node.
A class defines all the attributes of a thing. An object is an instance of a class. When I first started I was encouraged to think of real world things and map those things back to objects. For example a computer mouse: Its a peripheral - whats common to all peripherals It has 2 buttons and a sensor for movement A wireless mouse has batteries When you have a set of class maps you start to define your classes class Peripheral { private $input_flag; private $output_flag .. some methods all Peripherals might have } class Mouse extends Peripheral { private $left_button_state; private $right_button_state; private $sensor_type; ....methods all types of mouse have such as left click, right click } class WirelessMouse extends Mouse { private $battery_type; private $battery_power_level; private $connection_frequency; ...methods that are specific to wireless mice } When your main code creates an object it is an instance of whatever class it is defined with, but it has access to the descendant classes too. So a WirelessMouse object will be able to access methods in the WirelessMouse class and the Mouse class and the Peripherals class. Exactly what methods it can access is determined by how the variables and methods were defined (using the private, public or protected scope keywords). In other languages you often initiate an object and then just leave it to sit there waiting for events. When an event comes the object processes it and performs some action defined by its methods. The object may also have internal events (such as timers which generate some functionality). So for our WirelessMouse it may look like this: - if mouse move detected, send new co-ordinates to computer - if left click down detected, send left click info to computer - if left click up detected, send left click up info to computer every 10ms, update battery power by -1 unit. Check if power dead. - etc. So this is the core idea of objects - they are self contained. They are built from smaller components. They are maintainable (for example if you add a variable or method to the Mouse class, all descendant classes now have access to that new item). Now in PHP it works a little different just because the paradigm is different. In a classic PHP program you run at the server and create html/javascript taht is sent out to a web browser. All events occur in the web browser and do not get sent to the PHP. When the web browser submits some data to requests a new PHP page the PHP receives data and processes it. Effectively you can use objects to process that data and generate any response. In an ajax type system you also reveive data from the client and process it. You can also use objects to process that data and generate the response (normally the response is a json message sometimes containing data that is sent back to the javascript callback handler). So with PHP you are not handling too many events - most of the time you are simply getting data from a service or database and sending it to the browser, or taking data from a view and saving it to a database or sending it out through a service. So where to use classes: - lets assume you receive data from the browser that is to accept a payment for a product. You might have an object that represents the payment transaction. You might have different payment Adaptor classes for PayPal, CreditCard,Cash and other types (vouchers, club points, groupons etc.). They might descend from a base Payment class. The Product may also have a class tree. Different types of products may have special attributes. - sometimes you will create a Model type class which descends from a DB abstraction class. If all your database access goes through Model objects which in turn use the DB class which writes to the database, and then at some point in the future you switch out the database to something different, all you need to do is rewrite one class (the DB class). - If you get data from APIs you might have a set of classes for different type of APIs. If you send data out you may have a class for you EmailApi or MailHouseAPI. They may derive from a single base API class. So with PHP you are using your classes to implement business logic at the back-end. 
You're building XML... from a string? Not an array? Weird. Check out SimpleXML, or write a class whose sole purpose is to convert data back and forth between XML and PHP arrays/objects. As for their code, it's ugly but meh. Business is business. More an indicator of dysfunction than a serious problem on its own. I'm sure everyone here would get off on it if it looked more like: $trades = $user-&gt;getTrades($filters); $tradesXml = Xml::buildFromArray($trades-&gt;toArray()); $httpResponse-&gt;sendFile($tradesXml-&gt;__toString(), 'application/vnd.gox.trade+xml');
Well it dows much more than that, so the mechanism of eager loading isn't something that made into the tutorial page. Basically if you look at https://github.com/dracony/PHPixie-ORM/blob/master/classes/PHPixie/ORM/Model.php#L243 This methods looks at which relationship pathsyou'd like preloaded and constructs join queries. E.g. preloading authors for posts would reult in felds like: post_id, post_title, post_text, author_id, author_name (actually there would be two underscores, but reddit parses them as formatting) You can also preload nested relationships like 'post.author.company'. And then the Result class https://github.com/dracony/PHPixie-ORM/blob/master/classes/PHPixie/ORM/Result.php transforms that data into objects 
He's making a point. Don't judge the details that hard. 
Whereas manually doing DI is: - Code specifies which dependencies it needs - User obeys and fulfills the dependency requests of that code ... where is the difference?
then it shouldnt. there should be array_multi_map (or whatever you like) which takes an array of arrays. Way overpowerful functions and varaidic arguments are on of the dumb things causing inconsistencies.
yup )
If you mean [this package](https://bitbucket.org/mailchimp/mailchimp-api-php) - I'd say yes. The docs there are all generated from ApiGen - which you don't need in production. You could make a pull request to remove docs and add `apigen/apigen` to require-dev in Composer. That way to build the docs locally you just do something like: git clone ... composer install --dev vendor/bin/apigen Edit: meh, [I went away and did it](https://bitbucket.org/mailchimp/mailchimp-api-php/pull-request/3/remove-generated-docs).
Not me! I've been putting all of my extra cash into more sound financial long term investments. Hookers and blow. Pretty much all just hookers and cocaine.
To be fair, neither was the Linux kernel for a large number of years.
Um... no. You're right. There probably aren't a lot of "bugs", this codebase would have *worked*. But there are a shitload of issues. What you call *nit-picking* is the sort of thing that makes the difference between a skill professional building reliable software, and a ham-fisted amateur fucking up for everyone. That you dismiss these things as "nit picking" and say it "certainly could be a lot worse" puts you pretty firmly in one of those two camps. Building software that "runs" is easy, even for the most unskilled programmer. Building software that conforms to best practises, is maintainable, manageable, idiomatic and performant... that's what actually matters. Let's not forget that this system was hacked, and lost something like half a BILLION dollars due to one man's arrogance and incompetence. So yes. There clearly is at least one bug, huh? And yes. Some people might be a bit mean. Deservedly so.
Indeed. Title of this is about BUGS in the code. Sometimes in a startup environment you just don't have the time to make your code style look like you know it should. It may seem incomprehensible to a recent grad or someone working on a huge established company but your priorities are a little different.
Oh I know, I love twig. But we have a lot of legacy projects that were custom coded, and wordpress projects. I would prefer not to bring twig into those for ease of use for the outsourced developers. My theory is there's less that could go wrong. What I'll probably end up doing is just saying forms must be made using the Symfony/Form component and rendered using separate twig templates. 
[Former](https://github.com/anahkiasen/former) might be worth a try. It's supposed to be platform-agnostic (I've only used it with Laravel).
I'll add one little thing. If you get to that point where you have tons of functions, and you find yourself using global or passing in the same variables to your functions, odds are it would be better designed as a class.
Honest question: how do you replace that with version control? I mean, if I change one single line, then make a bunch of other changes, how do I revert that one line? I can't go back 10 commits because I lose all my other changes.
What you are missing is that this autowiring can be used only with constructor injection. So specification of dependencies can only be done via arguments in constructor. This is unlike a service locator that can be called from anywhere in code. &gt; There's no inversion of control here. There is, because the code is not in control of what it is being given via the constructor arguments. The section below from http://martinfowler.com/bliki/InversionOfControl.html describes the confusion you might be having. &gt;There is some confusion these days over the meaning of inversion of control due to the rise of IoC containers; some people confuse the general principle here with the specific styles of inversion of control (such as dependency injection) that these containers use. The name is somewhat confusing (and ironic) since IoC containers are generally regarded as a competitor to EJB, yet EJB uses inversion of control just as much (if not more).
&gt; He's insane enough to have written an ssh daemon There are two kinds of people who write their own implementation of encryption tools for production use: PhDs and idiots. These two sets are *not* mutually exclusive.
Nice! I wish I was that hands on :) TBH, I've only made one pull request, ever. I should be more like you :) Thanks! Hope they accept it!
Even Facebook's leaked source code from 2007 is better than this.
Pick something he'll have interest in and wants to automate. My first successful personal project was a comic strip downloader that daily downloads and presents all my favorite comics, and now i'm working on a media organizer that can go through my collection of music, movies, shows etc. Basically make him pick something that he's interested in, that way the project will be more fun and he'll be more likely to stick to it until it's complete. For first projects, I would probably avoid existing frameworks, they often have their own coding styles and classes to learn, it's better to get a broader understanding of PHP coding by making your own classes and functions in the beginning. At least that's how I started out.
&gt; takes a Symfony DI config file Isn't this the definition of un-maintenance? The fact that your dependencies need an explicit config seems like it needs to be manually maintained. Add a new controller with dependencies? Gotta wire them up. That said, I suppose if you were an interface/abstraction stickler, then you'll need to explicitly configure all of your implementations *anyway*
 public static function _Route_getStats($path) { Not necessarily a bug per se, but declaring a function as public then using an underscore to lower it's visibility outside the class is ridiculous, it reminds me of the old PHP4 coding styles when there was no control on public/protected/private. Not sure what the case would be where this needs to be underscored but remain public.
One thing that no one else has really covered is about the hardest thing to get when understanding a class and that's the design. You want to think of each class as a noun. Things have adjectives (and sometimes other nouns) that describe them or that they "own", things also do stuff. So the first thing you should ask yourself is what is my thing that I am trying to describe? I'm going to go straight to practical here, and skip silly examples. Let's say your "thing" is an article on your website. class article { } Now that you know what your thing is, you need to know how to describe your thing. What is important to a website article? Websites articles have: * An ID in a database * A headline * The actual article text * An author * A "short name" that probably gets used in the URL * Maybe a main photo that gets put directly under the headline Now add that to your class: class article { private $articleID; private $headline; private $articleText; private $author; private $shortName; private $photo; } Now, that your article has a description, we need to know what an article can do: * Load it from a database * Save it to a database * Format the article text for safely displaying on a website Now we can add those functions to our class: class article { private $articleID; private $headline; private $articleText; private $author; private $shortName; private $photo; function Load($ID) { //write good PDO based database code to load the article based on ID } function LoadByShortName($ShortName) { //write good PDO based database code to load the article based on it's short name } function Save($ID) { //write good PDO based database code to save the article! } function GetArticleText_HTML() { return htmlentities($articleText); } } Now that you have your "thing" created, you can use it in your website! &lt;? include_once('incTop.php'); $currentArticle = new article(); $currentArticle-&gt;LoadByShortName($_GET['article_name']); echo $currentArticle-&gt;GetArticleText_HTML(); include_once('incBottom.php'); ?&gt; Obviously this is a really simplistic example, and you shouldn't use my code as an actual back end for a website, but the method of figuring out how to design your class works well.
Until quite recently, no, they just pushed all the changes live &gt;.&lt;
The same amount that the YouTube people do?
You're so money and you don't even know it
I'd assume a singleton, where DB::i() returns the instance. 
It's more of a nitpick than a "bug" but I don't static functions that don't return a value e.g from line 73 public static function getRate() { $ticker = \Money\Trade::ticker('BTC','EUR'); $btc = \DB::DAO('Currency')-&gt;searchOne(array('Currency__' =&gt; 'BTC')); $btc-&gt;Ex_Bid = 1/$ticker['vwap']['value']; $btc-&gt;Ex_Ask = 1/$ticker['vwap']['value']; $btc-&gt;commit(); \DB::DAO('Currency_History')-&gt;insert(array('Currency__' =&gt; $btc-&gt;Currency__, 'Date' =&gt; gmdate('Y-m-d'), 'Ex_Bid' =&gt; $btc-&gt;Ex_Bid, 'Ex_Ask' =&gt; $btc-&gt;Ex_Ask)); } at least return true, or return the DB call value, you are doing an insert ffs. I mean I understand an exception is likely to be thrown but....
You might find this interesting: http://stackoverflow.com/a/16356866/727208
It's an obvious guard clause with poorly implemented logic. If you have a function that's setting a class parameter to true or false, I would bet good money that the class parameter default value is false anyways, and they just never had to deal with the result of the faulty logic because the default was being set even though the implementation of the logic was horrible.
It's really not something worth worrying about. The file size of your app has no bearing on anything.
Oh god, this is horrible. 
I promise you YouTube tests (though they may not be using something like unit tests). And even if they didn't, they are masquerading as a bank.
I wish my client wasn't locked into a contract with FirstData, this would be awesome to use. Apart from that though, I'm actually seeing this as a great example of how / when / why to use traits.
&gt; if the getAll() method is supposed to map the result set to an entity and I'm calling that twice doesn't that mean I really want to get access to the data from the result set? Yes. There is a row from the user table with id 20, it reads this row and returns the entity with id 20. But if such an entity is already loaded into memory, there is a good chance that it has been involved in some processing, and its properties are modified in some way. So the attributes of the entity in memory, is the one that matters. So it returns the entity that is already loaded in memory. Note that it still correctly mapped a row in the user table with id 20, to the correct entity. So in a way, the answer to your question is in the question itself. The getAll() method maps the result set to entities, as you say in the first part of your question, not to the data in the result set.
The problem is on line 578, where the function returns the $txid value, meaning that 581-584 will never run.
 namespace MPScholten\GithubApi; why not just namespace GithubApi; I noticed a lot of PHP developers do this.
That is a recommendation of PSR-0/4 and Composer. That helps avoiding namespace clashes by setting as a root namespace your vendor name. For example, what if someone else makes a Github api?
The API and code looks very clean, I like it! Only remark I have: more phpdoc, especially return types for autocompletion and IDE support (example: https://github.com/mpscholten/github-api/blob/master/src/Github.php)
It's to avoid naming conflicts with other libraries. It's also defined in psr-1 : "This means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name." (http://www.php-fig.org/psr/psr-1/)
&gt; That is a recommendation of PSR-0/4 and Composer Didn't know that, thanks for explaining. I always thought that PHP devs are just so narcistic they need their name everywhere, but this makes more sense. I really need to check the PSR soon, even though I don't really use PHP that much anymore. &gt; what if someone else makes a Github api? I doubt that someone would use 2 different github api clients in one project, but I get your point. I like the code btw. Very easy to read, but could use more docblocks.
blame shows when was the last line changed. And you can do a diff between various revisions. If you can't pull back a single line change from 10 commits back you are using a bad versioning system (or don't know how to use it properly).
I'm rather enjoying this whole "not totally hating php" thing that's happening
Thanks for feedback, you're right, there's some phpdoc missing there. I fixed this in my latest commit.
Here's how I handle it: Note that this is a wrapper for a Laravel-specific implementation, but the same concept applies: My Base Validator: abstract class BaseValidator { protected $id; public function validate($input, $id=null) { $this-&gt;setID($id); $validator = \Validator::make($input, $this-&gt;rules(), $this-&gt;messages()); if ($validator-&gt;fails()){ throw new ValidationException($validator); } } public function setID($id) { $this-&gt;id = intval($id); } public function getID() { return $this-&gt;id; } abstract public function rules(); abstract public function messages(); } An implementation validator. This simply contains the rules and response messages that Laravel uses when validating class SectionValidator extends BaseValidator { public function rules() { return array ( 'name' =&gt; 'required', 'slug' =&gt; 'required|unique:sections,slug,'.$this-&gt;getID() ); } public function messages() { return array ( 'name.required' =&gt; 'Please give the section a name', 'slug.required' =&gt; 'Please give the section a URL slug/identifier', 'slug.unique' =&gt; 'That slug is already being used by another section' ); } } Method in my controller: public function store() { try { $this-&gt;SectionValidator-&gt;validate(Input::all()); // save the item, redirect etc } catch(ValidationException $e) { return Redirect::to('/admin/section/create') -&gt;withErrors($e-&gt;getValidator()) -&gt;withInput(); } } Of course Laravel handles a lot of the form error displaying for me elegantly, but that's not really important. You can see here I have a validator class that runs through a series of rules, and if it encounters an error, it throws a validation exception which is then caught in the controller. So your controller relies only on a simple try-catch block. The key is encapsulating the compiled results of the validation into an object (which you see in the code is the $validator that gets passed into the ValidationException) which is then given to your view. 
Could have been bugs. Could also have been an inside job brought on by lax security and bad management. And ultimately, building software that produces profit is what matters to a business. Beauty don't mean a thing on its own.
Just use an isolated scope and write the information to a member on window using json_encode. If you're using Angular, just create a module you can include in your app, and let that module hold the data. If the data is global state stuff for the page in question, which it sounds like it is, then this is a good way to keep your data separate from everything else, but still keep it accessible. Making an AJAX request for data known at the time of serving the page doesn't make a great deal of sense in this case.
Haha, then you better stay away from the discussion this article generated over at HN. 
Best answer so far, considering that it is the only one :P haha! Thank you for taking the time to type all this down. Never seen this kind of implementation before which is certainly interesting. I myself handle it by extending all my controllers from a BaseController that has a validate input method. If all the input fields exist and have a NOT NULL value, I proceed to execute the action. public function validateParamsAndExecute($action) { $r = new ReflectionMethod(get_class($this), $action); $params = $r-&gt;getParameters(); $errors = array(); foreach ($params as $param) { if (!$param-&gt;isOptional()) { $paramName = $param-&gt;getName(); if (!isset($_REQUEST[$paramName])) $errors[] = $paramName . " is missing!"; else { $supplied = trim($_REQUEST[$paramName]); if (empty($supplied) &amp;&amp; $supplied !== "0") //0 as string is allowed, a field can be zero as string $errors[] = $paramName . " is missing!"; } } } if (count($errors) != 0) { $this-&gt;setResponseCode(1005); $this-&gt;setResponseData($errors); } else $this-&gt;executeAction($action); } private function executeAction($action) { $r = new ReflectionMethod(get_class($this), $action); $params = $r-&gt;getParameters(); $parametersIn = array(); foreach ($params as $param) { if($param-&gt;isOptional() &amp;&amp; !isset($_REQUEST[$param-&gt;getName()])) $parametersIn[] = null; else $parametersIn[] = $_REQUEST[$param-&gt;getName()]; } call_user_func_array(array($this, $action), $parametersIn); } In my router file which handles the instanciation of the controller: if (class_exists($controller) &amp;&amp; method_exists($controller, $action)) { $controller = new $controller(); $controller-&gt;validateParamsAndExecute($action); //Validate the existence of the required parameters and executing the action! $response-&gt;setCode($controller-&gt;getResponseCode()); $response-&gt;setContent($controller-&gt;getResponseData()); } else $response-&gt;setCode(404);
The code was removed, anyone got a mirror? Edit: Found one https://letscrate.com/f/johnbiggs/mt-gox/W8B3CGiN.txt
&gt; I always thought that PHP devs are just so narcistic they need their name everywhere Heh speaking for me I have so much trouble putting my name in the code. That feels just weird.
I must of gotten here to this thread before all the hipster bandwagoners piled on about how php is the worst thing ever.
The distinction between good code and bad code is generally extensibility and readability. Anything you can do to make the next programmer's job easier. Less time taken = money saved. Businesses care about money. That's why this code is bad. It implies lack of foresight, and that either the programmer doesn't care, or doesn't have the experience to know better.
One downside to stripe is the 7 day waiting period to get funds. As a small business owner, I can say that would be a huge pain waiting so long for funds to arrive. Our Bank of America Merchant Services funds are processed by NDC (Global Payments) and arrive the NEXT DAY, even if we batch/settle at midnight. Per transaction is $0.05, too, not $0.30. The API is cool, but the service from a pure merchant processing side isn't that great, and that's what really matters to a business owner. (This isn't an ad, NDC is very old, just saying this would be a big step backwards in terms of funds availability and transaction costs). I'd love to see a slick Laravel API written for a better processor. :) 
posting this link to /r/php is preaching to the choir
For some, it's by losing millions of dollars!
Cool, that page will read itself to you.
Ouch - any idea why that is? Some human verification queue or something?
They probably hold it to earn interest on the float. Just a guess. Either way, programmers are quick to see the virtue in the progmatic interfaces, but the business needs are more important. A 7 day wait to get captured funds is ridiculous.
I don't really care about the new changes since 4.x. PHP has decided that I am no longer part of their market - windows users/developers who prefer PHP for its simplicity. They're trying to make PHP a regular, crappy, complicated programming language because it's "better" - but what made PHP popular was the simplicity. If I had the cash, I would definitely hire some guys to rewrite PHP from scratch with a focus on simplicity and ease of programming. -edit- Not deleting this comment just because you don't like my opinion. Every downvote I get is a downvote against common courtesy.
I disagree that PHP had become more complicated. Yes, you can do more with it, and it has "modern" language constructs. But - if anything - it has become easier because it's so much more consistent than it was in the 4.x days. 
I don't know where it originated.
Did I miss the subscribe button or a RSS feed (on phone)? That would be kinda cool :)
If you don't like the new features, don't use the new features.
"but they're depreciating all my code's mysql_ functions!"
We use this at work (function is called _print_r) when something isn't worth using XDebug for
laravel has a more robust version of this as `dd()`, and I've added this as just `d()` to keep it really short and sweet. Be aware that depending on the context and when headers are being sent, you might not be able to use this everywhere. You should add `ob_start()` at the top and `ob_get_clean()` at the end. Also allow an optional parameter to use var_dump() instead of print_r(), as sometimes you need to know whether some data is a string or an integer. function d($input, $vardump = false) { ob_start(); echo '&lt;pre&gt;'; if ($vardump) { var_dump($input); } else { print_r($input); } echo '&lt;/pre&gt;'; echo ob_get_clean(); } And as a bonus, include this in your auto_prepend_file setting in php.ini so that it's always available on all of your projects. You may have to namespace it to make sure it doesn't conflict with anything though.
Add a (non-unique) index column with the letters in the word/phrase in alphabetical order. Then sort the characters in the input that you want to compare. A simple `WHERE` should then suffice. 
This is a quick way to do it. http://stackoverflow.com/a/10654108/945775 1. Assign a unique prime number to each letter in the alphabet 2. Multiply all the letters together for every word in your database and store the result. 3. Multiply the letters of your input string the same way, and then `SELECT * FROM words WHERE prime_value = $prime_value`
They can't earn interest on the float. That'd be illegal. They do it so they don't have to have massive reserves. https://stripe.com/us/help/faq#transfer-time
You need to assign a value to $re_html22 first, then your code will work. Page 1: &lt;?php session_start(); $re_html22 = 42; $_SESSION["number"] = $re_html22; ?&gt; Page 2: &lt;?php session_start(); echo $_SESSION["number"]; // 42 ?&gt; 
3 or 4 months ago I had to test something with data which was only available on production DB. Nothing being in place to do a simple export-anonymize-import in dev database my chief told me to just use the production database login and password in my dev config. Yup, untested dev code base plugged directly to the production data. It's not like it was a big e-commerce website with millions of clients. Now you can weep.
I've been using git for ages, but mostly for the standard commit/push/pull. I've heard of "blame" before but I thought it was literally like the name and only told you *who* made changes to a file. How would you revert changes? Do you just note the commit number, open the file at that commit then copy-paste the lines back to your current file? Or is there a command to actually revert individual changes?
$re_html22 has a value in it, if i put session_start(); echo $re_html22; // this will echo the correct number. but your example did work. so i was wondering if you would know why i can echo the value however, not pass it. $_SESSION['number'] = $re_html22; 
PhpStorm has Annotate feature and diff viewers. Doing stuff like this with cli would indeed be pretty difficult IMO.
i see that now, good call dude. as for the `!(!$info['generate'])`, i just took the statement out of the `elseif` construct and threw it in `setGenerate()` which i understand still doesn't work as intended.
I'm not sure I understand. What do you mean by "pass" the value? In other words, if you assign $_SESSION['number'] to something, $_SESSION['number'] will persist across your session as whatever you assign to it. It won't remember that the variable you used to assign it was $re_html22, just whatever $re_html22's value was.
If that's all what your file contains, then no, the variable does not contain a value. 
[Here's why](https://stripe.com/us/help/faq#transfer-time)
"For comparison purposes, it may be helpful to note that other payment providers can often take 2-5 days to transfer funds (especially from payments via American Express)." That's a crappy comparison basis. AE is 4 days, true, but it's also only about 10-15% of transactions in the various ecommerce companies I've been associated with over the last 13 yrs. The overwhelming majority use Visa/Mastercard, which settles the next day (so does discover), at least on NDC/Visanet platforms through BofA. For a small venture like Laracasts, I'm sure stripe is a great solution. For a typical small business with "just in time" cash flow needs, 7 days would be a pretty serious turn off. Good for them, though, if customers are signing up! :)
Try: phpVirtualBox - http://sourceforge.net/projects/phpvirtualbox/ Implements the Virtualbox client in a browser using PHP. You have to have the Virtualbox web services daemon running and you have to be able to connect to it from your client computer. Once setup it works really well. 
Are you running meta.php off the same box as virtualbox? If so then you could use exec() to call [vboxmanage startvm](https://www.virtualbox.org/manual/ch08.html#vboxmanage-startvm). Seems a bit odd but that should work. The following two projects might also be of use: [vboxweb](https://code.google.com/p/vboxweb/) [phpVirtualBox](http://sourceforge.net/projects/phpvirtualbox/) I've not actually use either of those so your mileage may vary.
I had seen that in my searches, but was hesitant to try the package out for I'm not sure if it will accomplish what I'm hoping to do with it. which is just to turn the VMs on and off, not to actually access them.
They are on the same box, and That i've tried. Doesn't seem to want to do much of anything. Below is a snippet of "meta.php" &lt;standard html set up and discription nonsense.&gt; &lt;form action="&lt;?=$_SERVER['PHP_SELF'];?&gt;" method="post"&gt; &lt;input type="submit" name="submit" value="Start OS"&gt; &lt;/form&gt; &lt;?php if(isset($_POST['submit'])) { exec ('vboxmanage startvm Metasploitable'); echo "The OS is booting, Please allow a few minutes to boot."; } ?&gt;
Do you have sufficient privileges to launch it? Have you added the web server user to vboxusers, for instance? 
__Idiot Developer:__ _"PHP is dead!"_ __Actual Developers__ _"Let's improve PHP!"_
This and the others are all really great responses, so thanks. It is an internal website, not even applied company wide, just for our department. I hopefully won't need to worry about any malicious attacks just accidental mistypes, and I think our validation protects against it. I will look into these templates though for future enhancements!
This is probably where I've gone wrong.. I'll report back.
yes.
I've been working on a [small-ish CMS](https://github.com/hassankhan/Zepto/), it'd be great if you gave it a go - I could use some real-world feedback.
I also do not understand what you mean but you could try $_SESSION['number'] = '$re_html22';
www-data ( the webuser) has permisisions, and is in the vboxusers group. no dice. -_-
http://www.charles-reace.com/PHP_and_MySQL/Anagram_Finder/index.php
That's happening? I honestly don't think that the "*renaissance*" in the PHP world is sufficient to make people who hate, not hate PHP. It's more that what's happening to PHP is what's also happening to JavaScript. They're both atrocious, poorly-designed languages, but unfortunately they have their niche, they're not going away, and so we do the best we can with what we're given.
Right! You *can* use OOP and interfaces and traits and all that other good stuff. There's nothing however to prevent you from continuing to develop as though these improvements had never been made. 
PHP has some oddities, but if there is one thing that hamstrings new developers, it has to be out of date educational material that still float the web. 
I got asked about translating time codes at an interview once. I failed that; memorizing date codes does not come naturally to me. 
Speaking as a business owner, who has tested a number of creditcard processing APIs and services, I can tell you that even though Stripe is a bit more expensive, and there is a 7 day waiting period for funds, I've yet to have an issue in over 2 years of using it. Whereas, with other processors, I'd have about a running average of an issue per month. I'd much rather pay higher prices and get better service than deal with issues all the time.
whaaa...? how often is your app *crashing* that you need an app for this?
It depends on the platform you will be developing and deploying to. I personally think using / is fine. Windows supports it, as do all Unix OS' and Mac OS X. It's unlikely that you will ever use your code anywhere else. See [Wikipedia](https://en.wikipedia.org/wiki/Path_%28computing%29) for a rundown of the different separators for different OS'. If you want to run on some of these older and more obscure platforms, use DIRECTORY_SEPARATOR.
&gt; "just in time" cash flow needs Can you give an example? I'm starting a small business and was considering stripe....7 days doesn't sound that bad to me. I'm not exactly running on E.
That's so funny that you release this today. I just built laravel stripe subscription into my startup Snippet Repo and it was a pain in the ass. One week later and I could've used this! Kudos!!
I don't need a CMS. I really only want something that I can embed INTO my static webpages, that enables me to do some small articles. So far I couldn't find anything satisfactory. Even Wardrobe requires root access to my server, which I don't have. I have a normal Webserver with FTP, PHP and MySQL, that's it. I guess if I have to use something bigger, I am just gonna use Wordpress then, even though I really tried to avoid it. And I don't mean to be an ass, but I am really looking for something sophisticated and tested in the same time. I got hacked once when using NukePHP 10 years ago and I really don't want that happening again.
As I understand, DIRECTORY_SEPARATOR is not needed. PHP converts `/` to the appropriate character for the current OS.
What's that got to do with anything? And what's all this hype about performance? Performance doesn't mean anything without features. OMG. I'm just skimming through the docs here. [This](http://docs.phalconphp.com/en/latest/reference/filter.html) and [this](http://docs.phalconphp.com/en/latest/reference/escaper.html) alone is fucking bullshit. I have to instantiate an escaper and then sprinkle that shit over my raw PHP templates? FUCK THAT. This needs to be the default, and it needs to be dead simple. No wonder they can boast "performance". It does fuck all for you. .. Volt looks nice, but it looks identical to Twig, which also offers a [compiled version](http://twig.sensiolabs.org/doc/installation.html#installing-the-c-extension).
Why not use a static site generator? I'm partial to [Piecrust](http://bolt80.com/piecrust/)
I was half expecting this article to be about HHVM and the new language features it adds (like lambdas, generics, async functions, list/hashtable types that aren't just "array"). Hoping that at least some of those make it into Zend PHP one day too. 
its just the result of a simple join query like, select u.id as u_id, u.name as u_name, p.id as p_id, p.title as p_title , c.id as c_id, c.name as c_name from user as u join post as p on p.user_id = u.id join country as c on c.id = u.country_id
I repeat: profit, not beauty. Depending on the lifecycle and complexity of your app, making it SOLID, tested, and testable might simply be a waste of time, particularly if the market is going to give outsize rewards to the first competitor. In many cases, there is no added value to building an extensible product. You build it, you make money, the product dies, and you build the next thing. 90% of the value is just getting it in front of customers. tldr; Build the MVP, then iterate. (Obviously Mt. Gox is a different story. They had the money, risks, time, and warning signs but still didn't address their problems. They pretty much got what was coming to them.)
You can't really share one browser's web storage with another - can you? I thought this was a pretty clever idea.
+1 for [phantom.js + pdf.js pdf generation](http://www.garysieling.com/blog/integrating-phantomjs-and-pdf-js-inter-process-communication) and [symfony/process](http://symfony.com/doc/current/components/process.html)
Except that PHP isn't an atrocious language, and you can write very good code with it. It's also been used for backend web development and many other "backend" things for many years. JavaScript is going through a new phase as well as a "renaissance." It has been tremendously improved in the browser environment, and now it's available on the backend. I completely agree with your last statement as it pertains to JavaScript. PHP is actually changing for the better, rather than simply introducing new syntax sugar and a million build systems and a million frameworks.
Do you know of a good IDE that can edit the local php files on the Android device?
&gt; Code specifies which dependencies it needs No it does not. It specifies it needs a type of object (and usually, an interface) so that whatever service class gets passed into it has an API that conforms to how the client class is using it. * It does not know where the dependency is coming from * It does not know exactly what implementation of the API it is getting if you're using an abstraction. * It is not requesting the dependency, it is RESTRICTING what it will accept &gt; External system obeys and fulfills the dependency requests of that code If it's a concrete implementation? Yes it does, because there is NOTHING ELSE IT CAN DO (nor could a human, if you wanted to wire the thing up the hard way....). If I have a class that wants a User object, guess what? It's going to get a User object one way or the other. If I have a class that wants a UserInterface interface, then now I will define the concrete implementation of that interface somewhere in the configuration (100% control), and the auto-resolver will inject it for me. Unless of course you think it's fun wiring an object graph of 10-12 different objects together every time you want to use the root object, I don't see why you would have a problem with an auto-resolver or even a "service locator" DIC like Pimple (which is NOT a service locator, unless you deliberately want to use it like a service locator). All object assembly ultimately has to bubble up to the very top of your application, unless you want to make heavy use of factories, and abstract factories which smell a lot like service locators anyway. 
If I didn't know better, I'd say you were [Lester Caine](http://news.php.net/php.internals/50950). He's still active on the internals mailing list, however.
And have you piped back the command output to see what it says?
Maybe this is it? You have set up the virtualbox VM you want to start under user "Fred". You are running the "startvm" command as user "www-data" so it says "no VM set up for this user!"
prepared statements :-)
Why? 
I didn't tried it. I was just asking. I didn't said it was perfect neither. And I completely agree that we really need features. I actually use Symfony2 for a lot of projects. I read some articles about it the last few days and yes, if it works like they say, I have several projects I did (with Silex for example) where I could have used this micro-framework. And I edited my first comment to make it more neutral. It really looks like I was trying to sell it.
"SELECT * FROM users WHERE `username` = '".$_GET['username']."'";
&gt; I doubt that someone would use 2 different github api clients in one project in this example yes, but what about a class called API? or User?
I use git for my work flow 1) Develope on local machine and commit it to some branch. i have couple virtual machines and stuff so i can do some basic tests myself. 2) On test machine pull branche with changes from my local machine 3) People that is not me test it repeat 1-3 till there are no more problems 4) make local commits pretty 5) On local machine merge final branch in master and push master to global repo where we store all production code 5) from production pull changes from global repo 
Please fix the lowercase H in the namespace.
I haven't done PHP in long time either, but what I've gathered over the last couple of years is that you should use the mysqli_ functions instead of mysql_ if you just need to make quick connections adn queries, as they're newer and improved. However every here and there I see people talking about using mysql_pdo as well. * http://www.php.net/manual/en/intro.mysqli.php * http://www.php.net/pdo_mysql The complain though, that the thread top comment mentions, is that a lot of beginner aimed documentation doesn't take this in to account, and thus teaches new programmers bad habbits.
&gt; you're too dumb to learn new skills I see, so you resort to insults when you see an opinion you don't like.
7 days is very little in the Netherlands. The default waiting period over here is about 30 days. The minimum is 7 days.
Thanks, will be fixed!
I'm not a proponent of PayPal by any means but one huge advantage they have over Stripe is being able to withdraw funds to a bank account the same day, often within the hour. For a small business this is a huge lifeline. I'm in the middle of creating a site which will require subscription based payments. This is almost perfect for my needs but the 7 day waiting period definitely puts me off, especially since PayPal offers subscription payment services too. It's a massive shame because this looks like such a well-written module. Being able to swap out payment processors but keep the same API would be the ultimate in DI :p
that is just stupid.
For the love of all that's digital, ignore that last tip. Not validating input is one of the best ways to make sure your site constantly breaks and that your site has piss poor security. On top of that, never trust that client side validation is being done... since PHP doesn't carry domain restrictions with it, people can pass variables to your page without them originating from your code.
try SQLYog. It's somewhat better than Heidi in my opinion. Especially since it has HTTP tunneling, which I used a lot at some time
SequelPro
That's for Windows though, isn't it.
If you are looking for an interface to work with queries, this is something I created, which is web based, [SQLCraft](https://bitbucket.org/sras/sqlcraft/overview) for this purpose. Like you, my frustration of using phpmyadmin while I had to work with big queries was the driving force behind creating this. Features are, * Single page app. * Tabbed interface for working with multiple queries at the same time. * Every executed query will be saved to local machine using local storage. You can bookmark queries that are thus stored in history. You can clear un-bookmarked queries from time to time. You also have an option to store the query history in a separate database table. * Bundled in SQL Query formatter * Bundled with ACE Editor for SQL Editing. * Minimal interface for viewing table structure. This does not contain any administration features for creation and administration of databases or tables. This is only meant for working with queries. To use just clone the mercurial repo or download the [ZIP](https://bitbucket.org/sras/sqlcraft/get/5bb876036f87.zip) to your doc root and take after extracting, take index.php in browser. You can enter the db server details in the first page. After pressing the connect button, you will be able to select the database. After that you can switch to query tab and start working with queries. 
that's messed up yo !!
Holy fuck. This is why people hate on PHP.
how about using an old phpmyadmin if you are just annoyed by the ajax? i didnt even know phpmyadmin has ajax probably because i either use an old one or its turned off somehow. 
is this sarcasm? it must be sarcasm .... PLEASE let it be sarcasm
I must say, that i did not know about the memory function: echo 'Memory Used' .round (memory_get_usage () / 1024 ,1) . ' KB ' . round (memory_get_usage(1) / 1024 , 1) . ' KB ' ; I like the idear of that one i can use it later to do some proper optimization and see the effects live, but the rest i think is garbage. specially the validation of form input. Just never trust the clients input even if "Validated" by javascript..
Having used Sequel Pro, it's hard to use anything else. I'm a little shocked at how poor the alternatives are in comparison; I wouldn't imagine going back to something like PHPMyAdmin or Adminer now. 
There's also [navicat](http://www.navicat.com/) for power users :) it is cross platform and it has a free version too.
I've not used PMA in about 10 years, Navicat desktop client all the way for me. Available for windows/mac/linux. 
Also vouch for navicat, I use it all the time. So much faster / more secure than phpmyadmin.
Chive is pretty good: http://www.chive-project.com/Features
Not a replacement, but the AJAX option can be disabled, so if this is the main problem it can be fixed easily. (Not realy sure about the latest version)
sqlpro ya right
I'm mentioned it in the past and was shot down before, but I really would like a "remove" option for the composer.json that says what directories to remove in which environments. This would let you, say, remove "unittests/" or "docs/" based on where you are. None of that stuff needs to to go production, especially when it's that large.
One thing you could do it use the set_exception_handler or set_error_handler and create custom error handling output. This way any exceptions or errors thrown and not caught will bubble up and be handled by this method.
How do you transfer large databases with Sequel Pro?
Not php. 
I still don't understand the complaints over the namespace syntax. What's wrong with \?
If you get to the point where your code is full of genius decisions like this, God help you.
On the Ember / Angular JS comment, I don't think that is quite true. I have a Symfony2 / Backbone.Marionnette application and still use Symfony Form component. 
From my testing, chive is even buggier.
It would be awesome. And then have a deploy-script that automatically removed all the env=dev and env=test folders when uploading to server. Or something like that
Take the time to learn the CLI for MySQL, especially if you don't often stray from GUIs. It's a much more powerful, flexible and versatile way to work. Then use SequelPro. edit: missed a don't
...with ease (compared to PMA). - File &gt; Export - File &gt; Import
Mac only? :(
No developer with half a brain would say php is dead.
I've also used PhpMyAdmin a lot less in the last few months. Granted I moved to a job where we use PostgreSql ;) Seeing as we are in /r/PHP, I must say that I use now the integrated PhpStorm client a lot. Really practical to stay in the IDE, and sufficient for most of the tasks. The console with history is handy and you get completion in the IDE for all your SQL (wow moment for me). HeidiSQL is not bad but it was crashing on me a lot.
http://sqlbuddy.com/ It was developed exactly for that.
Use http://www.adminer.org/, go pro! :P
Why does it have to be an app? What's a matter with getting friendly with the terminal? You'll end up learning far more than a little piping of output too I would bet!
I use [Toad for mySQL](http://www.toadworld.com/products/toad-mac-edition/default.aspx), personal preference realy, but I'd recommend it. 
I have used [Adminer](http://adminer.org) for a few years, and it gets things done.
"PDO or go home" is pretty much my mantra. Exceptions being: 1. Use what the project/company is using, until you can get that changed. 1. If you're using a framework, stick to it's method of database interaction.
If you want payware try [Navicat](http://www.navicat.com/). If you want something free I'm very fond of [HeidiSQL](http://www.heidisql.com/)
Learn command line tools, you won't be disappointed. 
Chive has bugs, sure, but they never really impact my workflow.
It provides no benefit over the second example by op and is not as clear and not as succinct. thats why it is stupid. 
ohh noes my internet points!! however it is interesting that I got more downvotes then you got upvotes. So I will leave you to ponder what about my comment was downvoted, was it that I was wrong, or how I said it?
pretty much the same process in PMA (click export/import tabs)
How is that different than PMA?
I don't especially like the way you said it, but I have to agree with you…
You can't turn it off after version 4.0
&gt; SequelPro Running PMA itself is a security issue, let alone running old PMA which can get you hacked. Check your access logs and you will likely see a constant barrage.
No, I resort to insults when I see an opinion I think is completely asinine. A programmer who isn't willing to learn and grow is a waste of everyone's time, and a detriment to the field. Honestly? I think you're a bad programmer keeping their lack of skill well hidden even from yourself by proclaiming any knowledge you don't possess as "unnecessary complexity". I believe you sincerely believe it. Because you lack the knowledge to know what you're doing wrong. It's called the Dunning-Kruger effect. I'm not trying to be insulting. In truth, I think it's genuinely sad. You can make snarky come-backs now. I don't care.
OP requested a Mac app... so... Yeah.
I always just defined DS = DIRECTORY_SEPARATOR in my projects. 
Great work, this is just what I needed, but please, close the dropdowns after the second click.
Not true....you are limited to PHP memory limitations, execution time limitation, and max file/post sizes. Whereas, not so with native apps (well I guess besides computer RAM and hard drive space).
This....I can't stress how important this statement is. Same goes for pretty much anything computer related: git, programming/compiling, terminal, etc. 
Except this : ***The uploaded file exceeds the upload_max_filesize directive in php.ini*** 
HeidiSQL interface is amazing. And it's for Windows. I love it.
I would also add that using Sequel Pro means you don't have a web app on your server that provides direct access to your MySQL database. PMA is relatively well reviewed, but using SSH to tunnel into your server and connecting that way is way more safe and proper than using PMA (especially for production environments). 
you would have to run php as admin which would not be a good idea.
Adminer is great!! 
I'm actually not sure. In 2008 a lot of banking rules changed so it might actually be something they can do now.
Secondededed.
I use MyWebSQL a lot.
Like many others in this thread, I recommend SequelPro for your MySQL desktop client. If you also want to monitor your MySQL environment, I highly recommend [Monyog](https://www.webyog.com/product/monyog). If you take the time to configure it correctly, and setup alerts for the things you care about, it helps you keep your database running smoothly. 
The RFC goes into advantages/disadvantages of different methods. https://wiki.php.net/rfc/backslashnamespaces I think the main deal was a vocal group that wanted to use :: and maybe that \ is a directory separator in windows?
compared to SqlYog (unfortunately on windows only), SequelPro is kinda lackluster....
Yep, this is definitely something we can make more flexible! Of course you can continue to handle any of the webhooks you want. We could try to automate more maybe.
I didn't get you. If it is about having to click on close button to close the drop downs for logs and clips, it is done so for making it easy for copying something from them. But I think I can make it close on the second click on the menu itself. You can open to drop down to check something and close it by clicking again, without moving the mouse. That would be nice. I will do it. EDIT: done!
That's a good point. Autocompletion on those items would be a huge plus.
A lot of people will promote GUI solutions to beginners and I think it's a great way to put someone on the fast track to thinking computers are powered by magic. GUIs should only enhance, never replace. https://twitter.com/climagic/status/421714781973016576 
Reeeally miss my Navicat since I've had to switch to MySQLWorkBench at my new company.
Would it have been so difficult to offer the ajax interface as an option? I've hated this about phpmyadmin since upgrading last year. 
I use a combination of Adminer and SequelPro.
I love that feature. I have 4 different mysql servers that I can just click and log into.
It's never loaded so the file sizes don't matter. Unless 10 mb is critical space on your server or local machine, which I highly doubt. And if your network connection is fast it shouldn't take much extra time to download.
&gt;Except that PHP isn't an atrocious language I don't see how people can say this with a straight face. I'm not going to be one of those people who goes out and insults people for expressing opinions like that, but I just don't understand how anyone who's used another mainstream programming (other than JavaScript) can have an opinion like that. PHP is a total mess. It's inconsistent in pretty much every way that it can be. It's actively hostile to be reasoned about with its fluid types and weird/inconsistent/dangerous automatic/implicit conversion rules. A lot of constructs are excessively verbose (I can't be the only one sick of writing `$this-&gt;` and `self::`). It has two to three (depends if you count return codes) different error handling mechanisms, and uses them in a wildly inconsistent fashion. In a lot of instances it's impossible to verify if your code is **syntactically correct** until you take the particular branch that causes that code to be executed. Do I have to go on? PHP isn't a good language, quite the opposite. This "*renaissance*" isn't because PHP is this amazing, developer-friendly tool that everyone just wants and loves to develop with. It's because PHP has a niche -- it's pretty much present out of the box on every web server, and has MySQL integration out of the box -- nothing more. PHP is a chore to write. People who laud PHP's simplicity/ease of use can't care about correctness, or be aware of the correctness concerns with "*simple*" PHP code. Correct C/C++ code is substantially easier to write, and with how permissive C/C++ are in some areas, that's quite a low bar.
The "todo" list is always a good basic one to start with. You could even grab a demo from [ToDoMVC](http://todomvc.com/) and connect it to your own PHP backend that persists todo lists in a database.
Highly recommend Toad Mac Edition (http://www.toadworld.com/products/toad-mac-edition/default.aspx). Sequel Pro as mentioned already is pretty good too.
Sqlyog for Windows. It is usually on sales during the end of the year.
I am using Sequel Pro which is pretty good, I still love command line though :)
In the little while, its improved a lot. Most invocations don't crash anymore. Just a couple a years ago, it'd be pretty much every 5-15 minutes. Now, its so infrequent that I don't really need to care about.
I use this for local development all the times. Works great. Too bad the guy who admins our production server thinks allowing external DB connections is a security risk and PHPmyAdmin isn't...
DbNinja is really nice. It's very convenient and I'm looking forward to it growing. It's a web client so there's no compatibility problem.
Seconded.
MySQLWorkbench is more confusing to use than SequelPro and, while better than in the past, is buggier. Both are free. I started using Workbench but once I discovered SequelPro I immediately switched as the latter is orders of magnitude better and easier to use.
Serious question.. what is the benefit of this versus say running up VMs with vagrant for instance which include the PHP environment and the entire isolated linux environment?
Okay. I use terminal fairly often (probably, on average, every minute while on a computer, so not too much). I work with git and files quite a bit-- am much more comfortable typing out git commands than trying to select things in a GUI. But I look at database cli, and it just seems... basic? I open up workbench or some GUI, select a table, edit data, apply. Sometimes I'm just looking for data, but if the column has too much data, it formats pretty badly (often unreadable). Select too much data? Exit. When I'm at a shell, the system is doing what I want. I progress from one thing to another, and it helps me. The databases always feel like they're showing me a bit of information, then pulling me back to the beginning as though I wasn't trying to do anything. There's also other things: * Long "commands" (`ls` vs `SELECT id FROM tablename`) * Backwards commands (`find | xargs perl` vs "UPDATE SET ... WHERE ..."). You forget a WHERE? Too bad. * No real progression or piping (`find|grep` to `find |xargs` to `find | xargs perl`) * No table context. (`show create [table]`, `select * from information_schema.columns where table_schema = ... and table_name = [table]`, select ... from [table]; update [table]`, etc) * Editing multiple values is hard. On command line, I'd go into an editor, in mysql, its pretty much UPDATE [table] [new values] WHERE [new conditions] each time. Using history here is near useless. `ALTER TABLE` is better, but It'd probably be much nicer if I could edit rows/tables in vim. Am I missing something here? Is there a way to go where it doesn't feel like the database keeps sending me back to square one?
The only time I've had issues with Workbench was on my old work computer. And that was, AFAIK, because the companies antivirus would try scan database dumps on the fly and cause a blue screen. 
How do you suggest I edit something in the middle of a 30 line query in mysql cli? 
Nice project initialization! I really like how you checked the box to generate a README.
There's nothing in that repository. Mind giving us some context here?
Navicat is ace!! 
&gt;Sorry, english is not my native language, Not mine either. :) &gt;The clips feature is a lovely touch, but you should use some type of clipboard extension or management utility like Ditto on windows. Yes. I have used them. But after sometime you loose track of the context. I mean, if I am working with a query, and I copy user_id, post_id, country_id, and after a while, all of these will be in the clipboard extensions cache, but I will have no idea what is what. With clips, you can paste it and add some kind of label like, "user_id: 344" etc. Not sure if that sounds stupid, but that is an issue I have faced with these things.
While I agree it is good to start out with a solid understanding of the MySQL client first, having a good GUI can still save you boatloads of time. You need to use the right tool for the job - in my experience the CLI is not (usually) the right tool if you want to get stuff done quickly.
Then you update the upload_max_filesize and you're all "Ok, good, lets try this again"... But the upload limit is still the same. So you create a quick phpinfo(); test to see which ini file needs to be updated even though you're sure you've updated the proper one, and of course the output of phpinfo() agrees with you. A full 20 seconds to think it through further and you're back in the ini file updating the post_max_size.
Blogs are always good for this. They can start very simple with just posting new stories and then increase with complexity as lessons and semesters go on by adding things like commenting, taging, user management, etc. 
Whoa.
I've looked through every commit in that project, and let me tell you, there's some rich history there.
Man, hopefully one day I'll be as good as creating github repos as him!
You can have a single VM running multiple versions. Saves resources and everything else is shared within the VM.
sed
Whatever, I don't feed trolls.
If you're on a Mac I'd highly recommend [Sequel Pro](http://www.sequelpro.com). It's free, easy, and fast.
At least it's not static.
navicat is awesome, and thanks to http or ssh tunnels you can use it on every database you work on if they don't allow for direct access
&gt; At least it's not static. Or public!
I've been using SQLyog for a long time. I recently switched to postgresql so now I use PGAdmin III and Navicat
Well that code is correct, not exposing your privates is essential for encapsulation. `public $sex;` would have been a bad choice.
Navicat here... do it
I care when it crashes even once, not only because it wastes my time having to relaunch, but because it is also infuriating and generally causes profanity towards the application.
self::$sex = 'masturbation';
"did.. did my debugger just tell me to go fuck myself?"
If you use vim as your $EDITOR, you can even get syntactic coloration if you put [the following](https://github.com/greg0ire/dotvim/commit/3eb096c7c6cae1b48191e19d93e8860695308596) in your vimrc : autocmd BufRead,BufNewFile /var/tmp/sql* setf sql
My first real big thing was a forum. Also they can make a messaging system with profiles.
3/10 no docblock, would not bang
seconded were using this in our company
If people want the code I can post it?
You could just do this: http://img.youtube.com/vi/INSERT_YOUTUBE_KEY/0.jpg
That's what I used! I used PHP to parse the URL string and extract the YouTube ID then upload the image on the page. This just makes the whole process a little quicker!
 function ds($path) { return str_replace('/', DIRECTORY_SEPARATOR, $path); } require_once ds(__DIR__ . '/lib/vendor/init.php'); You have the readability of having actual paths written out and you have support for platforms that use a different separator. 
Or you can use 1.jpg, 2.jpg and so on.
That's hilarious - if you're 9 years old.
In my experience, GUI apps will eventually crash (or otherwise stop working) if they run long enough. I'm pretty happy if I can get through 5-7 days without crashing. Workbench exceeded that. (There are a few edge cases like connecting to old servers).
Protected sex is never hilarious to a 9 year old.
I understand, totally. The first implementations of something won't ever be perfect. I think it's a reasonable concept to have implemented. Instead of just returning the json, we'll probably modify it to wrap the response in a value object.
/r/im14andthisisfunny
It probably should be gender. Just to be a nitpicker.
&gt; McCaleb had registered the Mtgox.com web domain in 2007 with **the idea** of turning it into a trading site for the wildly popular Magic: The Gathering game cards. **He never followed through on that idea**, but in late 2010, There was never a Magic: The Gathering card trading site, it was just the domain name that McCaleb registered, left to collect dust, and finally used for bitcoin a few years later.
/r/im14andthisisPHP
what? no ... the phpmyadmin is local! what are you even talking about, who would put phpmyadmin on a server with live data, no way
//giggity
Don't forget updating. I've used both cli and pma, and for updating pma is far superior, and I imagine any GUI will be. I'm having mini panic attacks everytime I have to update a row in the cli.... 
Sometimes I see them as nothing more than objects.
NaviCat
Oh.
I use IntelliJ IDEA Ultimate for web development, and it has a database connector. It is actually great. It doesn't export to JSON properly (adds a comma after the first opening of the array), but so far that's the only problem I've found. I also find it really convenient that I can stay within my IDE to do everything. Every now and then I have to use PHPMyAdmin but it's generally because I have to connect to the production database (which IntelliJ can do, but I think our devops has disabled external connections).
I'm definitely in agreement with you here. If you need to do extremely specific or visual work on a database, it's probably time to bust out Sequel Pro. There is definitely a point where the CLI falls short. If you know exactly what you will need to do in the CLI but know it's going to be a pain in the ass, fire up the GUI. But if you shun the command line to search for a button that probably does what you want, you need to step away from the database. I'm not a big database guy, but I will always favor understanding something over hoping there is a button. The other important advantage of the MySQL CLI (at least over web clients) is the innate security boost you get from not opening your database to the outside world. Say whatever you want, but having something like PHPMyAdmin is never going to increase your security. For desktop GUIs, SSH tunnel to MySQL bring basically the same security benefits of the CLI.
[I'm not certain it's a trend specific to PHP](http://www.google.com/trends/explore#q=php%2C%20python%2C%20ruby%2C%20%2Fm%2F0jgqg%2C%20javascript&amp;cmpt=q). I'd guess that perhaps it's due in part to the rise in popularity of frameworks, or looking at the aggregate graph maybe just a decline in the proportion of developers in Google's demographic.
I tried doing development, on the Nexus 7 with a bluetooth mouse and keyboard. The problem I had, was its hard working on a 7 in screen, and you can get a usb to hdmi out, but then you lose your ability to stay powered, thus having less than 3 hours to do programming. I bought the Chrome cast in hopes it would reflect the display, but that has not been added to Chrome Cast. The next best option is Miracast, but I didn't have a computer monitor to support it. I tried using other mirror apps like MirrorOp, but to support a resolution high enough cause too much latency. Thus I gave it up, 7-in programming sucks...
Anyone else notice when executing a custom query it loads but then hides the result straight away? 
It seems like you want too much for what you have. You want something that's sophisticated, tested and lightweight which can be embedded in your static webpages. Lot of bases to cover here. Anyway, what I think you want is a really basic PHP script which loads your blog file, and in your static site you include some Javascript which calls the script and gets the blog data.
The problem with `private` is that it wouldn't be able to be shared at all. It'd be strictly `self`.
Or knowing of a specific website to go directly to search like php.net
Add this to the top of nike2.php ini_set('display_errors',1); ini_set('display_startup_errors',1); error_reporting(-1); 
Or VirtualBox, isolate the environment so that you can build on it instead of trying to make your main non-deployment enviornment conform to it. Sorry this isn't help for your problem.
This times the biggest number I know
I don't think you made that up.
the ratio (internet users who knows how to program) / (total internet users) is lower than ever.
No, after the &lt;?php. These directives instruct PHP to show any errors that might occur. EDIT: Actually, error_reporting(-1) is no longer [the recommended way](http://us2.php.net/function.error_reporting) to report all errors. skrawg's last line should be error_reporting(E_ALL ~ E_DEPRECATED);
Yeah.. that graph makes me really question the validity of their information. [This graph](http://www.indeed.com/jobtrends?q=php%2C+ruby%2C+%28node.js+OR+nodejs+OR+node%29%2C+python&amp;l=) better represents PHP among other interpreted languages. Anyway, if you spend any time over at Hacker News, you'll notice they all hate PHP with a passion. That hate sticks with them and grows overtime and perpetuates among startups. So, all these popular startups with a ton of available jobs? They absolutely aren't for PHP. It's unfortunate because their base of the hatred is extremely ill-informed and outright ignorant. Oh well.
I would guess SaaS contributes too. Back in the day, you went to hotscripts.com, found a php script, edited some php files to configure it, and if you were lucky there was an installer script to run. Nowadays, with SaaS/Cloud products like Basecamp, there's much less need to set up PHP scripts unless you want to. As an offshoot of that, PHP was the first choice if you were writing a web script because of its wide adoption. For those companies building cloud products today, they can now choose any language because they're controlling the infrastructure themselves. It might be PHP, but it could just as well be something else.
My coworker runs it easily in wine too. 
\G instead of ; gives you better select output for the command line by the way. 
Yeah.. It's annoying. Shitty developers write shitty code. Language is irrelevant.
You mean other than the fact that there are more languages available now, better languages that allow for faster code development, languages like python, ruby, etc? Or maybe its the fact that people tend to use frameworks, and don't worry about pure PHP. Maybe they prefer to find their solutions to code problems on stack overflow rather than google?
&gt; all these pedantic SF folks praise Javascript I was just ranting about this over in /r/webdev. I'm all for finding a better language to develop web apps... but fucking _javascript?!?_
It's obviously due to the increase in pirates! [http://www.google.com/trends/explore#q=piratebay](http://www.google.com/trends/explore#q=piratebay).
Honestly, I find it best to just use command line. Pop into terminal and sql your heart away. 
Yeah.. and a lot of the "new arrivals" to the internet over the past ten years have been non-developer types. Plus .. these stats are for searches like "php". Or "php mysql". Like .. how many people are searching like that. I don't think anyone computer savvy would just search for "php" and expect anything worthwhile. Anyways .. it looks like all of the languages have similar declines. But it is all just relative to the total Google searches. Pretty much all techy terms look the same. I guess there were just proportionately more nerds on the Interwebs 12 years ago. Go figure.
Everyone complains about phpmyadmin, just use the native client apps if you don't like that or the command line.
While I don't miss using Toad for MySQL/Oracle, I do miss the toad start-up sound (ribbit!).
This was me a few days ago setting up a client's site on a Digital Ocean vps.
Nah it's good advice, I'm getting vagrant set up right now. 
Only with the `DOM` extension due to a bug with the underlying library (`libxml`).
Cli is great for switching users and permissions to do stuff on the fly. But not optimal for viewing data or reusing SQLs.
Good, I used to use WAMP, I regret every minute I spent in that =)
This is when you just do it via command line.
Allowing external DB connections IS a security risk. 
Instead of arguing with you about terminology, read the documentation. &gt; When an object is sent by argument, returned or assigned to another variable, the different variables are not aliases: they hold a copy of the identifier, which points to the same object. http://www.php.net/manual/en/language.oop5.references.php &gt; You can pass a variable by reference &gt; References can be likened to hardlinking in Unix filesystem. &gt; PHP references allow you to make two variables refer to the same content. &gt; The second thing references do is to pass variables by reference &gt; The third thing references can do is return by reference http://www.php.net/manual/en/language.references.whatare.php http://www.php.net/manual/en/language.references.arent.php http://www.php.net/manual/en/language.references.whatdo.php http://www.php.net/manual/en/language.references.pass.php http://www.php.net/manual/en/language.references.return.php
You may be timing out while parsing the document. Add `set_time_limit(0)` at the top.
Blog. Forum. Calendar/Event. Image Gallery.
Stripe gives you cleanliness and simplicity in exchange for a waiting period and a bigger cut. Setting up a proper merchant account is almost always going to be a better long-term strategy, but Stripe is an excellent service for devs who want to quickly start receiving CC payments on their site without relying on Paypal (who might decide to freeze their funds on a whim). 
Could be the advent of mobile. If you want to earn a lot of money as a developer, PHP is not where it's at. iOS dev? Java dev for mobile? That's where the 6 figure salaries are these days.
OSX-wise, I like to use Querious (not free). Otherwise I use the command line, but I've heard good things about Adminer. 
This could be done with regex far easier
The confusion seems to be that they're both called references, the difference is in what they refer to. function foo($b) { } $a = new stdClass(); foo($a); `$b` refers to the same `stdClass` that `$a` does, but `$b` is not "bound to" `$a` (to use the same terminology [they use](http://www.php.net/manual/en/language.references.arent.php)). function foo(&amp;$b) { } $a = new stdClass(); foo($a); Again, both `$b` and `$a` refer to the same `stdClass`, but now `$b` is "bound to" `$a`. Is that how you would describe it? Then what *are* `$a` and `$b`? In the first case they're essentially pointers. Simple memory addresses that point to some data in memory (although their usage varies a bit from C). In the second case.... what? They have some correlation with both each other and the data they point to?
Slightly off topic, but I highly recommend using Twitter's REST api instead of parsing HTML. [Here's](https://github.com/themattharris/tmhOAuth) useful class for that.
Agreed. These days I'm far more likely to google "yii &lt;term&gt;" or "jquery &lt;term&gt;".
Good coding practices aren't rules so much as suggestions. I'm not referencing some age-old law that states "thou shalt not use regex," I'm just saying that it's widely held that code should be understandable for the sake of future changes, and string manipulations are more eloquent in this case than a RegEx pattern. 
That implementation was heavily based on regex operations; what do you mean?
Gone straight to my vimrc
I have comments next to both variables reminding me to edit the other one.
This is very true. In no other language would statements like "I don't use a framework because I prefer to have control" or "There's just no point in a framework, good developers write more efficient code themselves" not be laughed at. They SHOULD be for us, too. We should stop engaging positively with the derps who say derpy things, and just laugh at them and steal their jobs. Sadly, lots of them are our managers and "leads". :(
&gt; What did you all use to learn Laravel? The two things that helped me most were [Code Bright](https://leanpub.com/codebright) and [Culttt](http://culttt.com/2013/04/29/getting-started-with-laravel-4/). Code Bright is a basic eBook on how to Laravel. It has a casual, chatty tone, and is not especially complex. This is helpful for people like me. (Like, really stupid people.) Culttt helped with a lot of the implementation stuff. Phillip Brown has done a lot of writing, covering everything involved in actually creating an actual thing, and documented both the how and (often missed) the why of what he's doing. It's a really good resource for actual implementation in a real-world scenario. This is, in my opinion, the Achilles Heel of Laravel, just as it is with a lot of frameworks and systems. Almost invariably, Laravel's docs give examples that are highly simplistic. They don't in any way explain what to do if something more complex is required. For example, Laravel guides routinely show a form with a "title" field and some sort of textarea. They show how to save it, how to populate it, etc. But what if you're using a dropdown/select, not a text field? What if your select has to be populated from a database, such as a list of staff which populates the "staff_id" select? No one mentions, no one tells you. Here's the [section on dropdown lists](http://laravel.com/docs/html#drop-down-lists), not a thing about pulling the content from a DB. The answer, btw, is `lists()`. $staff = Staff::all()-&gt;lists('name', 'id'); This will generate an array, with their id as the key and their name as the value, perfect to feed to `Form::select()` Here's the part of the documentation that tells you how to do that: 
You're beating around the bush. What's the difference between a "unique resource" and a "variable" (on a low-level)? How is the data address looked up? How does PHP know if two variables are bound to each other?
Using the PHP tokenizer to find the function names would have been safer. Either way though, this could cause all kinds of mayhem. Converting arrays to short-hand, however, is a bit safer: https://github.com/thomasbachem/php-short-array-syntax-converter
&gt;That function would obviously fetch return posts from the database. My question is that is it better to return an array of post IDs or actual Post objects? Well, seeing as you're just returning the IDs, and not the contents of the posts themselves, I'd say that it isn't obvious at all. In fact, it's pretty darn misleading. I'd say return the results *as* objects *with* a full set of data, not just IDs.
arrays
I'm downvoting this bigoted unintellectual garbage. 2/10 troll attempt
what's with Cuba's obsession with PHP?
https://barebonescms.com/
I wish they'd still support XP
And the broader answer, is collections (which has all sorts of stuff you can use for any kind of data and is the base container for the results you get back from a query). API link... http://laravel.com/api/class-Illuminate.Support.Collection.html
The real question: Why would I want things converted to camelCase? It's much harder to read, and it has all sorts of ambiguities when you are dealing with embedded acronyms.
For those that may be unaware, PHP community has been at work on developing code style guides that provide the implementation of innumerable libraries without sacrificing quality and clarity. Among these, are non other than the [Framework Interop Group] (http://www.php-fig.org/) . Although not all are related to code-style, those that do are absolutely essential in clarifying standardization. Be sure to take a moment to read [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md), [PSR-1](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md), [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md), and [PSR-4](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md). 
It might have something to do with how easy it is to get started in PHP without a framework. In Python, for example, I wouldn't have a clue how to get something to even show in the browser without a framework.
Thank you for your patience. That explains it better.
It does understand coding patters it loojs for stuff like: -&gt;name function name $name Take a cliser look )
[Laracasts](https://laracasts.com/) as well as [Culttt](http://culttt.com/) have already been mentioned --two of which are my favorite sources online. However, don't disregard published e-material. Particularly, [leanpub.com](https://leanpub.com/). They focus on publishing early and often. In a way, it's like agile publishing. A work in progress but with already rock solid advise! What's really cool, is that you can adjust your custom price for what you believe the author should be paid. In addition, when an author updates their work, you get that brand new copy automatically updated! Pretty cool, right? So there is a few quality books I bought that I think will improve your Laravel development: [Laravel: Code Bright](https://leanpub.com/codebright) by Dayle Rees. [Laravel: From Apprentice To Artisan](https://leanpub.com/laravel) by Taylor Otwell. [Build APIs You Won't Hate](https://leanpub.com/build-apis-you-wont-hate) by Phil Sturgeon. [Laravel Testing Decoded](https://leanpub.com/laravel-testing-decoded) by Jeffrey Way. [Implementing Laravel](https://leanpub.com/implementinglaravel) by Chris Fidao. [Laravel 4 Cookbook](https://leanpub.com/laravel4cookbook) by Christopher Pitt and Taylor Otwell. Moreover, never disregard Medium! That is, Medium has offered a platform for hundreds of developers from around the world to offer their knowledge at amazing strides of quality. Have you searched Medium lately for [Laravel material](https://medium.com/search?q=Laravel) --exciting! Podcast are amazing on your off time --I like to listen to them while working out. Two that relate to Laravel and PHP development as a whole are: [Laravel.io Podcast](https://itunes.apple.com/us/podcast/laravel.io-podcast/id653204183?mt=2) featuring the best of the best in Laravel, news, and developer's questions! [PHP Town Hall](http://phptownhall.com/) for a fucking good time in the current events of the PHP world. As you can see, there is a lot to digest. Pick a route and stay active daily on Laravel. Only with persistence and hard work can you master the eloquence of Laravel. Happy Coding!
Well, for consistency. I mean having mixed styles is a pain to read. So I thought if you convert methods you might as well go all in and change everything. 
The overly long constant name is why our code always looks like this: join_path(__DIR__, 'some', 'where', $variable, 'bin'); Totally worth the 20 seconds to write that function. 
No problem. Apologies if I came across tersely.
Not in the last version for Mac. The only issues that I have with MySQLWorkbench 6.0 for Mac is that sometimes a combo box is not hidden when lost the focus.
&gt;maintaining the likeness of its C API Which is a ridiculous notion. The fact that I make pretty much the same calls consuming libcurl in PHP and consuming it in C/C++ should be a red flag. The point of high-level languages is to abstract away implementation details at the cost of some performance/flexibility, not to leave you faced with implementation details and foist an awful type system on you. &gt;PHP isn't actively hostile. It doesn't go out of its way to make your job difficult. What do you call things like `'hello'==0`? You can make all the defenses you want of a loose type system -- and I'll disagree with you on every single one -- but this is inexcusable, in my opinion, even in a loose type system. A case can be made for converting between types silently when they can be **losslessly** converted back-and-forth, but doing so when the conversion is traumatically lossy? Or how about the fact that `intval` returns 0 -- **an actual integer** -- when it fails. Or the fact that `json_decode` returns `null` when it fails, but also returns `null` for the input `'NULL'`, which is not an error. Then there's the elephant in the room: PHP uses a mix of return codes and its internal error handling to indicate errors throughout pretty much its entire standard library. This means that safely, consistently consuming its standard library means wrapping the whole thing or writing code that looks like C with a lot of dollar signs and `===` added in for good measure. Even C++ doesn't do this. C++'s standard library (where the standard library is C++'s and not C's) uses exceptions, and does so consistently. I don't see how this **isn't** actively hostile. It seems that everywhere PHP **can** make a developer's life difficult/hell, it does so. &gt;You write C and C++ code and you're sick of writing `$this-&gt;`? All the code you write in C/C++ has some meaning. `$this-&gt;` and `self::` are just meaningless fluff. You're in a member method of an object, all that object's properties should be in scope. &gt;You can verify whether your code is syntactically correct at any time. Use tests, use the PHP linter, or use an editor or IDE that can tell you it's not right. Tests aren't really an argument. Sure you should write/use tests -- in any language -- but tests to detect syntax errors? That's kind of bizarre, and -- in my opinion -- leads to a bad/unnecessarily bloated workflow. You try and compile a C/C++ program that's syntactically invalid, the compiler won't do it. You could run a syntactically invalid PHP program for **years** until a particular branch is taken. That's dangerous. And syntactic correctness is only really half the battle. What about other kinds of correctness? Use of possibly-unassigned variable? A function that should return a value not returning? Et cetera. PHP has no concept of these, whereas these kinds of warnings/errors are par for the course in other languages. PHP seems designed to just keep running at all costs, and in a world where correctness and security matter, that's immensely at odds to the needs of the developer. &gt;clean code can be written in it Which means nothing. Sure clean code **can** be written in it, so what? The language actively discourages you from writing clean code, and if you want/need to consume its standard library directly, you probably have to resist the temptation to just use that call, and have to rather wrap it to make it safe and handle all the bizarre ways that it can fail. For example: Say you want to use `preg_replace`, what do you do? Well `preg_replace` can fail, and do so in **two different ways**. In certain instances (syntactic error in the input regular expression, for example) it raises a PHP warning, so better make sure you transform that into an exception with some kind of wrapper. In other instances (exceeding the backtrack limit internally, for example) it returns `null` (as opposed to all the other PHP standard library functions that return `false` on error, just for good measure). In that case you have to call another function to determine the exact cause of that error, which you probably should do to throw a descriptive/helpful exception. So suddenly what should've been one line -- and would've been in any other modern language -- has turned into a massive quagmire of error checking/handling **that C could only dream of**.
&gt; Navicat is great. some great features: * Data transfer * Data sync * Structure sync Shame that on Linux is run through Wine. But it works well! 
Post objects of course, otherwise why even have a post class to begin with? Thats the whole point of a class, so you can send its variables and methods along.
I know what coding practices are. It's not a widely held belief that regex is a bad choice for string replacement. Pattern matching in strings is *exactly* what regex is for, and it's entirely possible to write regex in ways that are perfectly readable.
Here, I'll prove it. [It does not understand context](http://codepad.viper-7.com/XksV0S). If it did, it wouldn't be touching the inside of that string. The only way you're going to get proper context is if you use PHP's [tokenizer](http://php.net/tokenizer) (or write one yourself) which would be a better approach to doing this.
If youre returning the ids, call the method getPostIds().
Because I have two distinct different entities implementing RolesInterface. (Users and Groups). (I may be wrong here, this is just my current reasoning) 
Well, earlier it was just php alone. when you had a doubt yo'd ask google "How to do *this* in php?".. now-a-days its more like "How to do *this* in (insert your favourite php framework here)?"
Have been using Navicat for about a year now - Cannot recommend highly enough
That's a design choice (property name patterns), and not a PSR requirement. I think the article just needs to make this clear. 
* Checkout code * Install dependencies * Dump an optimised autoloader * Generate Doctrine proxies * Compile assets * Inject version number in to code 
You are not measuring popularity. You're measuring search term frequency. PHP will have reduced, as a search term, as the conversation moved from the basic language into our brave new world of frameworks and libraries. If you want popularity, use a proper service for the task. http://w3techs.com/
Again? I thought we were over it: they're not facades, the end :-)
Yes, I've been hearing that, but with this article, I now finally know what a real facade is :D
I'm happy to see that Python is included. I'm upgrading now.
Separate interface-specific initialization into methods. Initialize first and separately. Bind the product class as a single entity. If this doesn't work for you then the class shouldn't have multiple interfaces; use composition or other form of indirection.
Nope. Costs £19 GBP. [Source](https://secure.shareit.com/shareit/checkout.html?productid=300618806&amp;js=-1).
Damn
This would surely fail for something like $foo_bar = 0; $foo_Bar = 1; echo $foo_bar, $foo_Bar; 
Seems odd that Mamp would be coming out for Windows. Of did I read that wrong? Isn't the first M for Mac?
I'm of the opinion that using MAMP is *wrong*. There are better solutions, specifically in running things like Vagrant to create a VM that perfectly mirrors the development environment. I say that in advance. But seriously, fuck it. I've been using MAMP for a while, and I really like it. I'm pretty thoroughly over being told by snarky PHPsters that my dev environment is, like, so 2012. I like using MAMP. It solves a problem for me, and I like the solution. On MAMP 3.0... the hell did that come from?! My version is 2.1.4 and I don't think it's out of date. I'm not seeing a lot here that warrants a re-purchase, but I **do** like shiny things. The addition of Python is a particularly nice feature, but I'll save any decisions on that front until I actually know any Python.
Gonna grab me a Pro license the second a Windows version is released. Here's hoping the license is cross platform.
It looks like they've changed it to stand for "*My* Apache MySQL PHP"
My point of view exactly!
I much prefer Vagrant (+ [PuPHPet](https://puphpet.com/)), but it's nice to see MAMP improving. Sometimes I just need to test a quick script without booting up a Vagrant box. 
Great little write up. It was short and sweet but serves as a decent introduction to the software architecture needed to use a worker in a PHP application.
On a side note, I use [CodeRunner](http://krillapps.com/coderunner/) to run quick code tests. It uses the Mac's built in PHP though.
I guess never ever in the history of mankind has there been a web developer who failed to consider the most obvious of security concerns.
That's a really long article that as far as I can tell barely reflects on the OP's question.
What does MAMP for Windows have over WAMP/XAMPP?
I must be so 2008 or earlier then, as I 'sudo apt-get' and configure all the services manually on my Linux VM. 
Laravel isn't actually a framework. It's a whatchamacallit whizzbang pizza flipper deluxe. edit: Why so serious? Feel the need to shutdown jokes about your framework. You must be compensating.
$foo_Bar is not a valid snake_case style I just wanted to share something that worked for me, and might work for someone else, this isn't a tried an tested way or anything. But if you have tests written for your code than using this + some manual fixing will get the job done much quicker than doing everything by hand =)
Though, to be fair, whoever initially wrote that code should be drawn and quartered.
It'll be "the end" when the Laravel folk stop calling it the wrong thing. Using the phrase "a facade in the context of Laravel" to have it both ways is just not good enough.
Have you seen the section where it is explained why using an object instead of an id value may be better? It also contains why storing attributes of an entity in an array and passing it around may be not as good as passing the object itself. Both of which I think is relevant to OPs question. And the rest of the article is something that I believe is relevant to OP, since he is using oop, but it seems to me that he is not sure where or how to apply it. 
Can anyone review this analogy to check my understanding? - You want to generate the Packagist badges, - Say you have an Image interface, with two implementations that provide Imagick and libgd functionality - that would be an Adapter. - Then an interface for retrieving data (say, HTTPClient) with implementations for cURL and Guzzle - again, an Adapter pattern. - Then a BadgeBuilder class that takes an Image and a HTTPClient, and generates the packagist badge - not a Facade, but a service class. - A class that exposes static methods to a single instance of a BadgeBuilder, which is a Proxy. - Then a class that provides an easier interface to a BadgeBuilder instance, which would be a Facade. As I understand it, Laravel's facades are just proxies to instances in the service locator - just a lazy method of injecting dependencies (rather than injecting in a constructor or method).
Honestly, this is one of the better examples of a simple class and its uses I've come across. Many thanks
One could argue programmers changed the definition of the word "in the context of programming"... I'm simply returning the word to its true meaning... :)
You do understand that's how IoC containers work in almost every other real language? I simply modeled the Laravel IoC container after the most popular containers in the .NET ecosystem, which is where I came from.
I prefer camel case as well, but if the framework uses something else that's at least bearable) I'll use it. Currently I'm using snake_case in my CI project because the framework uses it and I'd like it to be consistent. 
Lorna Jane always has great write ups. Laravel does this brilliantly as well.
I think the only difference is the UI is a hell of lot cleaner and easier to use than XAMPP. However, they both do the same thing. 
Ah yes, do it once and once everything starts exploding, then we'll write a well thought out version. A proper version would use the built in tokenizer.
&gt; I simply modeled the Laravel IoC container after the most popular containers in the .NET ecosystem So you are telling that you just took something that is popular in .NET, with out having any opinion of your own regarding its worthiness, and implemented it in your php framework. And what is the deal about "every other real language". Are you implying that php is not a real language?
I'm saying I brought it to PHP after having used it for years while maintaining extremely large enterprise .NET applications with many hundreds of thousands of LOC for a Fortune 500 company.
What I think really happened is that you used the wrong term and now you're trying to backtrack. That's okay, and it's fine to make mistakes, just start referring to them as Proxies. People are getting aggravated because we're programmers, we work in a world where (unlike natural language) you can't make syntax mistakes. GoF's Facade has been around a while, it's what everybody means when people discuss facades. It'd be a shame if a new generation of developers starting out with Laravel had the wrong idea of what a Facade really is.
Stop calling them facades and call them something else widely used in the server world to mean something totally different. Sounds legit! Thanks for your wisdom. We're not changing the name.
At my uni, I saw someone who had written out over 3k lines if code for an image gallery, where he could have just iterated over the folder contents. 
One hopes you are just exaggerating. Laravel is hardly the first time a IOC container has been implemented in PHP. Don't mistake the relatively recent trend of adopting IOC (albeit in a half-assed way with service locators) as technical innovation.
Laravel had the first (as far as I know) container that used reflection to auto-resolve constructor dependencies in PHP. Not that I care really. I'm just saying I brought that practice into PHP from its wide adoption in the rest of the programming world.
They are proxies not facades. I do have a solution. Laravel calls them Facades. Everyone else refuses to even utter the word in relation to Laravel and instead uses Proxy consistently. One we are in agreement, we can find something else actually worth arguing about ;).