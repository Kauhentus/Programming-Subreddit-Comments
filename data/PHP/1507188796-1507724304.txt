fyi you can do asynchronous programming in php just as in nodejs.
Latest Symfony offers Argon2i support - http://symfony.com/blog/new-in-symfony-3-4-argon2i-password-hasher . So that's what I'll vote for. Use bcrypt or argon2. You can find more details here: http://php.net/manual/ro/function.password-hash.php
When you use `stat:clear`, your action will only affect whichever FPM worker responds to your request, not the whole pool. See cachetool docs. &gt; Note that, unlike APC and Opcache, the file status cache is per-process rather than stored in shared memory. This means that running stat:clear against PHP-FPM will only affect whichever FPM worker responds to the request, not the whole pool. Julien Pauli has written a post with more details on how the file status cache operates.
Enterprise distributions are usually reproached to provide outdated versions, things have changed. Red Hat Enterprise Linux have official support for * PHP 5.4 in base repository * PHP 5.6 as Software Collection * PHP 7.0 as Software Collection * PHP 7.1 as Software Collection (testing) These packages are also available for CentOS users, see https://wiki.centos.org/AdditionalResources/Repositories/SCL 
Please note that question is about encryption not hashing.
Thanks!
&lt;?php return $_GET['a life']; ?&gt; (don't forget to filter+sanitize the GET variables and remove html special chars )
If you have to be snobby about the language you use you're not worth much as a developer anyway.
That doesn't mean there aren't well-paid PHP jobs. PHP job listings cover a wide gamut from needing people who just know how to slice a PSD and turn it in to some HTML with a PHP contact form, to WordPress, to people who design and build high performance scalable apps. The glut of positions is at the lower end of the pay scale, so yes the average salary is lower. 
Eh. Experienced developers know that PHP is flawed, but they can work with it regardless. If you know a safe path, a mine field isn't that dangerous.
It seems more a problem with the manager/management to me. You should express your concern about the maintainability of the code remembering them this piece of code is key to their business. If he pursue with something that can be summarize as 'shut up and do as i said' it is obvious about what to do.
Thanks, I'd missed that. Is there a good solution to this that doesn't involve changing webserver configuration?
How so ?
GIYF
Code wise, this is not dissimilar to what I've gone into. But they only recently cut the cord with the overseas outsourcing company. And, in all three programming jobs I've had, it was a similar situation - coming into an environment with little to no best-practice in code, systems or processes. So far as I can tell, unless a developer with a clue has gotten to them first, you'll quite often end up in similar situation - you just need to be the dev-with-a-clue. Management wise, the latest company specifically recruited me to put together a team to deal with their problem code, so the working environment is completely different to what you're describing. If it's just code that's the problem, you can deal with it - refactor and unit test as you go, implement the processes you need to make it work. If you can't get the company/bosses on side, then it's going to be an up hill struggle, and you may want to continue looking while sticking it out.
Eh, we've had tons of articles about what's new in PHP. The latest one is just more blogspam. The pornhub thing is a funny joke that I (and apparently many others) hadn't heard before, and is not posted every day. 
Once you get to a serious list of blocked accounts, /r/php is usable again. Cue "php company in India" -&gt; report, block.
That's what I thought, you can't do async "just as in nodejs". You can but it's cumbersome and limited. FWIW I don't even like nodejs. 
What's it like being a Reddit genius?
I don't agree. I was rather happy earning 550 Euro's a day in my PHP contract.
Quirky and sometimes weird? Sure... Crime against humanity? Please...
How many people are involved in this project? Looks promising!
This is really the root of my problem with using PHP/JavaScript every day. They're both wonky and shit but one isn't optional. I wish I could use a different back end language just for a bit of a change more than anything
My dad once told me a lot of “new” at older ages takes more work to learn and apply, just like staying fit when you are older becomes harder. With that being said- I know a few fit people In their mid 50’s. Might be $bs; 
Ratchet creates a daemonized PHP server built over `libev` or `libevent` for asynchronous event handling. This removes the advantage PHP has with ease of deployment: you need shell access with permission to install a native extension into the PHP interpreter, and to launch the server daemon. PHP also doesn't have any asynchronous libraries for file system or network calls, so Ratchet is only using the eventing library (`libev`) to handle I/O between the websocket client and the PHP daemon. Network and file system access within the PHP websocket daemon is still synchronous and blocking.
That's if you know the timezone. What if I want to store that something will happen at a certain date and time, in whatever timezone the user will be in then? That's a so called Local Date Time. PHP doesn't have it. What if I want to store a date and time with an offset to UTF,but disregarding DST transitions and timezone changes? That's an Offset Date Time, PHP doesn't have it. Java has classes for these, and much more. It can handle Arabic dates, if you want to, or time on Mars (a few minutes longer days) or Venus (days longer than years). It can handle DateTime without a timezone, and convert it later to a timezone properly, it can handle specific moments in time, even those during timezone changes. Everything you'd ever need out of a DateTime library, Java has it built in. In PHP, storing a date and time relative to no timezone already requires you to roll your own dulian datetime.
Experienced developers know every language has flaws
Well timed question, just had a CV yesterday, the guy has more experience in years with PHP than our youngest dev in life experience. :-) Knows all databases (sql, nosql also), caching, testing, OS-s, worked with all frameworks, architected multiple complex systems, knows and used AWS, docker, vagrant etc. Personally I would hire him without an interview. :-D Of course I have seen the other side too, where the man has changed profession around 40 and now at 50 has experience with Wordpress and site building, same as what younger devs have. In summary age doesn't really count, if I would have the same high experience devs at age 30 and 50, I would hire both, it's hard to find good devs anyway. :-)
God, get a sense of humor. It was funny.
Experienced programmers know PHP is not as bad as some people claim, but great is simply the wrong term.
The type system is ridiculous. There is no excuse for it and it bites people in the real world. It induces actual bugs. That's not nitpicking.
I'm about to hit 50 and I've been a software dev most of my life (starting in VB and moved onto PHP when the web got popular). Learning new things is harder, not impossible though. Things I've learned: A lot of people have got very rich of my work. In the early days I'd do overtime and crazy hours to make the boss happy. I made the boss rich and got a 9-5 wage for my overtime. These days: Overtime means someone fucked up - either failing to plan properly or simply underestimating how long things take to get right. I don't do overtime any more- my spare time is precious. Tried and tested beats new and sparkly. That doesn't mean new and sparkly isn't good it means don't bet the farm on a new/unproven tech no matter how much fun it looks. TDD is great on paper but has never been a good fit for any of the organisations I've worked for. TAD (Test After Development) make much more sense in an environment where they client doesn't know what they want till you give it to them. Testing IS important but why bother writing tests for code that will probably be dropped when the client changes their mind. The simpler the solution, the better. I've never had a problem that was solved by complicating it. The older I get the easier it's been to get work, and incrementally better paid work too. Experience is everything. Even at the start of my career I got work by showing them what I'd already built. Not one single employer asked me about my CompSci degree. I've burned out a few times working for shitty companies. Don't work for shitty companies!
C#, because it's well-designed. Swift, because it's well-designed. Rust, because it's well-designed. I can go on.
how can you know it's cumbersome and limited if you've just been told it's possible? I'd suggest to get your hand dirty with it, before jumping to conclusions.
&gt; A lot of people have got very rich of my work. In the early days I'd do overtime and crazy hours to make the boss happy. I made the boss rich and got a 9-5 wage for my overtime. Roger that ! Learned that a few years back ... Starting at 8am and leaving the office at 4:30pm. It sounds like I'm a bad employee but that gives me time to reflect on myself and recharge to stay productive the next day!
I'm getting older and starting to get stuck in my ways. I refuse to upgrade past 5.5.37, sick and tired of deprecations No I'm not getting 5.5.38 "at the very least"
[removed]
B2
Great reply! A couple thing stuck out to me: &gt; Learning new things is harder, not impossible though. Would you be able to elaborate on this? I would think the older developers willing to learn, would be better able to determine *when* to learn. What affects learning, more, here: Experience? Ability? Something else? &gt; The simpler the solution, the better. I've never had a problem that was solved by complicating it. 1 core is simpler than multiple. 1 computer is simpler than multiple. Aren't there problems that need more than 1 core and/or 1 computer? Aren't there similar problems where more things needed to be added, rather than a single-thing made bigger or more powerful? 
My favorite stack for web applications is postgresql, node.js and C++ together, and React in the client. 1. Native extensions in PHP are painful if you have performance-critical code. You have to extend the parser with new tokens to expose your native functions to your PHP code. Distribution is difficult since many users don't have shell access or permissions to extend the PHP interpreter. Node native extensions are very easy to deploy (works the same as any other package) and interact with the V8 javascript interpreter via its API rather than extending it. I also prefer writing extensions in C++ (node) rather than C (PHP). 2. Node's execution model (asynchronous eventing based on `libuv`) seems the most natural fit to web apps to me. Websockets are natural to handle. 10k+ simultaneous connections are manageable with well-optimized code. Javascript has good support for asynchronous calls with `async/await` and promises. 3. Node gives Javascript code raw access to memory buffers, so you can do things like write efficient big integer libraries just in Javascript. 4. The V8 JIT compiler is really fast and capable. A lot of things run faster in Javascript than as native C++ extensions because of all of the optimizations the JIT makes. 5. I like the emerging programming style in the Node ecosystem. It seems to me it is taking the best functional ideas and blending them with what's good in OO and procedural design, and naturally discouraging bad practices in those patterns (like long and brittle inheritance chains). 6. React and Node together make server-side rendering of single-page application client code very easy. On the downside, Javascript has almost no standard library so you're left fishing for libraries to include for everything. Distribution is also more difficult, on par with Rails or Django apps.
Building more simply doesn't mean every problem will be worked down to only needing a single core or a single machine. It just simply means avoiding to over engineer as much as possible. Don't throw 50 machines at an issue that may only require 5. Don't over abstract your code if it'll never be reused again. Complexity also comes in various levels. Keeping it to a minimal is what keeps you sane.
You are using a language led by a guy who is turning 49 soon. In my opinion, if you're good in your 30-es, you'll be good in 50-es. If you're an average PHP copy-paste guy, your age doesn't really matter. 
...not a dick. Don't take it so hard
The learning thing (for me) is down to a couple of things. I've wasted time learning stuff that never got used/was a flash in pan. it's hard to get your learning head on if your thinking 'are we *really* going to use this?' It's hard to learn something new when you have an existing toolkit of techniques you know intimately and know works. Why learn something new that might not work/be a good fit? (There's the 'fun' of learning new things, but that stops being fun for the above reasons). Your brain slows down with age and isn't as malleable as it was. By simple, I go by the age old adage: 'The simplest solution that works and no simpler' :-) If the simplest thing that works needs 2 machines then that's fine. But there's no point writing extra code for it to run on 3 machines until it's time for it to run on 3 machines. (And by that time, you'll have learned a bunch more so your original 3 machine code is already out of date when you come to need it) Of course, you might have to write your 2 machine code in such a way as to be expandable to 3, but leave the stubs in and flesh it out fully when the time comes. Note: I might come across as a grumpy old dev but really, I love my job (and I'm still learning - but focusing on relevant, useful stuff). Edit: Another thing - I don't DO office politics. And that has made my career much more happy :-)
All I'm going to say, is that you need to learn a lot of things about php, one thing is throwing up code without knowing what you are doing. I've been programming php for more than 10 years and I only tried to kill myself 24 times. Joke aside, y'all motherfuckers need some php
RIP
I see it as a balance of complexities. Sometimes the solution is better/more hardware (network, memory, cpu), sometimes the solution is better/more software (removing contention/locks, better/simpler algorithms or software that implements them). Some algorithms are more complicated-- taking more brainpower to parse, or more time to develop, but keeps the hardware/rest of the platform more simple. "Never had a problem that was solved by complicating it" doesn't fully fit with that, to me. Sometimes there's not much choice, complexity sometimes has to be added somewhere. Adding more lines of code is, inheritance, more complicated than not having the code at all. I'm definitely interested in getting a better understanding of *what* sorts of complexities-- like you point out. Is it just abstracting code and/or only using a few machines, or is it more than that: Organizing things to seem small and predictable, even when they're not?
Thanks, let me know if you try it out :) At the moment it's a team of 3 full time developers. We do have outside help when it comes to UX and visuals. We went live only 5 days ago, and hope over time others will like the project and hopefully join as a contributor.
SSR is supported, as with any Javascript app...we are already using SSR with Webiny on one of the projects we did. Let me know if you have any questions regarding that?
Most of the older developers I meet are so burnt out that they barely function. Hopefully this isn’t our future. 
How can you tell if something is useful and relevant vs something that is a waste to learn?
Thanks, will take a look!
Yeah, I could do that. I don't know, it just doesn't feel right.
Covfefe
48 here, you move on to Datawarehousing or management. (Most of us do)
I'd say that sums it up pretty accurately. I interpreted "complicating things" to mean making a bigger problem out of something than it needs to be. Nothing in life is simple, equally so in software engineering. I see it more-so as trying to avoid over complicating solutions to problems, which can sometimes even take longer than you would think. Humans love to complicate things. Making things simple takes time. Sometimes this can even mean not having the most elegant solution or the best algorithm in place. Sometimes a duct tape fix is good enough and won't present a major headache to overall maintainability. It really is a delicate balance somewhere in between super simple and crazy complicated. As long as one isn't used to excess, you can usually find happiness.
Experience can be a double edged sword. I am *very* resistant to change for example (because experience has taught me change is always painful). 
You get a feel for what will work. I've seen a 1000 cms' and probably the same number of frameworks appear over the years. Often they are just re-inventing the wheel and offer no tangible advantage over an existing, established product - those are the ones I tend to avoid.
Work/Life balance is crucial here. If you don't make time for yourself, don't be surprised if you boss tries to fill it for you ;-) I have a couple of hobbies: Wild camping &amp; packrafting (heading off to Scotland for a week soon!) and making scale models ( http://www.richbuilds.com ). Wild camping gets me out in the fresh air away from computers and offices and stress, the model building gives me an opportunity to flex my creative muscles in a way I don't get from programming. It's a physical creative not a mental creative.
I know all of that, I'm not a new PHP developer. My point is the language is full of shit. That nonsense actually does exist. And the fact it does exist is appalling. The language is a straight up hack, and not a very good one.
&gt; Experience is everything. This is true nearly everywhere *except* for Silicon Valley. Companies there shun older workers, preferring recent grads over workers with demonstrated histories of productivity.
I went through a rough patch with jobs a couple of years ago. Got kicked from a lead dev job as they couldn't find the sort of work a lead dev gets paid for. Then a company with THE worst code I've ever seen, and a 'patch it, not fix it' mentality - I quit after a year. I haven't 'job searched' for years. I just update my linkedin profile and field the (literally) thousands of jobs sent from employment agencies. My criteria was simple: Is the job a good fit for my skills, is it local, is the salary ok. 60 is a difficult age - by then you've only got about 5 more years of work in you before you retire and most people wanting senior devs (in my experience) need longer term commitment than that.
Truth. Although I've consciously steered away from management positions as, at heart, I'm a coder. The rest is stuff that just gets in the way of coding :-)
Silicon Valley sounds a dreadful place to work :-(
Think of it more as: with experience you get better at spotting anti-patterns.
&gt; shorthand anonymous function syntax Sadly the [short closures RFC](https://wiki.php.net/rfc/short_closures) failed the vote.
&gt; The type system is ridiculous. Set strict types and not have to worry about variable coercion?
F
Companies that prefer cheap labor over experience are probably ones you don't want to work for anyway. (To be fair, some companies need a mix of experience levels, so maybe they're not hiring experienced developers at the moment. I'm not talking about those, but rather companies that exclusively hire young developers for cheap and burn them out.)
Shitty affiliate spam as always from the shitty php classes website 
Would there be a reason to switch from [Xdebug Helper](https://addons.mozilla.org/en-US/firefox/addon/xdebug-helper-for-firefox/) to this addon?
Elaborate on shitty companies plz. What makes a company shitty?
I see people working themselves raw trying to make companies and bosses happy. It's usually some combination of wanting a raise and wanting to build some measure of security against job loss. The companies are almost always happy to take the extra work and not once have I seen somebody actually get a raise or be less likely to be let go for it. These days, I take a measured approach and wait for a company to demonstrate itself before sacrificing any of what time I have with my family to the company. &gt; Overtime means someone fucked up - either failing to plan properly or simply underestimating how long things take to get right. I've found this to be true every single time. The painful irony is that killing yourself to meet the unrealistic deadline or at least make it less overdue only ends up communicating to the person who made the mistake that it _is_ possible to have that kind of time-line. It ends up as a vicious cycle.
As you might expect, performing fewer operations usually means it will go faster. In this case, printf is only receiving a single argument, and is not having to handle any formatting fields. 
I just turned 48 and have been learning for a couple years with every spare moment and project opportunity. I am so afraid that nobody will hire me because I'm old so I'll be stuck in this fucking cubicle for the rest of my life.
PHP has enforced type hinting now.
experience. long, and sometimes bitter, experience. no real shortcut here.
You're drunk /u/colshrapnel, go home.
Okay. But you can still do websockets with PHP.
How are arrays not useable?
cause they can churn&amp;burn younger people willing and able to put in 80+ hours a week for a 40hr/wk salary. look, we have a foozball table! look, free lunch! look, don't bother going home, you'll be back here in 6 hours.
The ones I use most often I have memorized. For the rest, I don't really care, because my IDE has them memorized. If, for some reason, I'm using a primitive form of code editing, I just pop into the manual real quick. And really, there is no programming languages or frameworks that don't require a visit to the manual here and there. 
My definition of shitty will likely be different to yours, but here's what made me leave: Awful, awful codebase. I've faced bad codebases many times in the past but this is a pretty major ISP in the UK. This system runs *everything* from procurement of services to billing and payment. It's horrid mashup of (very old) PHP, (new) PHP &amp; Java. The build process often took days. Only *one* person (out of maybe 50 devs) could get parts of the code to run locally and he didn't know what he'd done to get it working. Many people had tried, many more will try.... There was no incentive to fix the broken code - everyone knew it was broken, everyone wanted to fix it, there had been several half assed attempts to get it fixed (I joined after the 2nd rewrite and they were STILL using code from the original code alongside the 1st and 2nd rewrite). Hardly anything was under test and they insisted all new code had to have tests, but it was plugging into a system that was essentially untestable. Then there were the meetings, and the straw that broke this camel's back - being forced to attend meetings about meetings that I wouldn't be attending. Another place told me in the interview their business was to identify failing businesses, contact them and help them out of their predicament. Their 'help' involved asset stripping the company and killing it. The owners were totally money driven and treated staff very badly. I stuck that for a couple of years until they let slip what their business model actually was. You get a feel for shitty companies pretty quickly. I wish I'd learned to quit sooner at these places :-/
I agree completely. PHP is just one of the many languages I regularly use. I'm just saying I don't have any more difficulty writing PHP than I do with anything else.
That's exactly the point, though. With better languages you almost never have to consult the manual, because everything is consistent and clear. You know how one function works, you know how all of them work. In PHP, this consistency is missing. That's why so many projects made their own stdlib for all this. Same in JS.
&gt; The simpler the solution, the better. I've never had a problem that was solved by complicating it. This. This is the most essential thing developers must learn during their career. It ist the most common thing I observe in every programmer growing up and gaining experience. The most difficult phase is the one where people think that clever is good. And it is nearly impossible to convince them otherwise until they learn it themselves. Clever is bad. Always. I think it comes from the mindset that a simple solution looks like the developer isn't capable of finding a better solution, which is completely wrong. The opposite is the case: it is very difficult and requires a lot of experience to come up with a simple solution. This reminds me of another thing a developer must learn: deleting code is good! You are not throwing away your work. In most cases this work was necessary to reach the simple solution you end up with after deleting all the mess you produced before. 
Also interesting to note that printing nothing is much more faster than printing something.
I'm 33 and about 4 years into the field. I can't answer a whole lot since I'm not even close to a senior level developer but at larger corporations you'll see lots of older developers. I would trust someone who has been coding for longer especially if it's a language that's been around for awhile. I wouldn't recommend startups or small companies for people going into web development unless it's simply to build up your resume for a couple years. I work for Marriott and we have an ample budget and reasonable time frames that you typically only get with bigger companies with plenty of capital. Also, it's worth noting that most developers have their own styles and ways of solving problems so it costs alot to replace a developer since it will require someone else not familiar with the entire cascade of calls in your code to figure it out and then train someone else to come in and take over, trying to work around the foundation you laid. Again, I'm still a greenhorn to some degree but these were all things I researched before going into the field (or have learned from other developers over time) as I don't want to be naive and ignore my future and my job security. 
I'm 41 and one of the oldest Developers in the company, i'm also a self taught Developer who has programmed since he was 9 years old. I've lost count of how many young graduate Developers i've met who did a degree in CS, yet cannot write a single line of code. Some of them admitted that they paid someone else in their class to do all of their work, some of them admit they hated programming and only did the degree because they wanted lots of money, some of them admit they didn't remember any of the programming that they learned. These kids have to be trained up and hand holded for at least 6 months until they are at a level where they can be given their own small projects. Most of the self-taught Developers that I know seem to be older guys like me, most of the qualified but useless Developers seem to be kids.
Wow, I hadn't noticed this because I have been using PHP 7.0 from Brew to overcome the fact that Sierra came with 5.6. Thanks for the info!
I'm 36 years old, and my PHP developer co-worker who is in his 60s said to me last week, "object oriented programming is a crutch for people that can't think logically." He was defending procedural code. I don't know wtf we're going to do with this guy. If you stay on top of your craft and learn the newer stuff as you age, you should be fine.
Holy shit, your name is fucking awesome. I love it. You must get that all the time? :D
&gt; With better languages you almost never have to consult the manual I do not find that to be the case at all. It's not possible to memorize everything.
So it has static typing, yes. It's still weak though, unless you enable strict typing which has its own problems. See Python for actually strong typing. The coercion rules are still nuts.
That's an option, yes.
I think JavaScript will be easier to get started with primarily because it’s a bit easier to tinker with In sites like [jsFiddle](https://jsfiddle.net) or locally in your browser. It needs no setup to get started. Be prepared to learn HTML and CSS (which you’d also want to do if you start with PHP). Learning JavaScript will not prevent you from taking up PHP later. For learning JavaScript check out /r/learnjavascript and for learning in general check out /r/learnprogramming and its FAQ.
If you turn strict mode on, type hinted parameters are strongly typed. An exception will be thrown if you pass an invalid type. Everything else is still weak type though. I would prefer if it was strongly typed like Python, but I can't say that it really impacts my day-to-day. If you write clean code, use best practices, and utilize proper frameworks then it's rarely an issue.
The language you start with isn't all that important, it's learning the concepts behind programming. You're not going to be making "fast money" making websites anytime soon just because you start with PHP instead of something else. You could do worse, but I personally don't think PHP is a great first language. You're going to be jumping into multiple concepts at once (both programming _and_ how it interacts with the Web as a platform, given that PHP is inherently a Web-oriented language), at a stage where it's incredibly easy to get confused about how all of this works. I would say start with something like Python, which is both just generally an okay language, general-purpose so you can stick to just grasping programming for the time being, and has historically been perceived as a "learning" language, so there's a ridiculous amount of beginner-level resources for it.
I find most of them to be extremely stubborn and stuck on methodologies that are 10 years out of date. Since they're older, they think they are smarter and as such, everything must be done their way. They seem apprehensive about leaving their comfort zone and trying new things. A generalization for sure, but that sums up the majority of my experiences.
At the time I was looking for a web-ext version I did not find it, or it wasn't ready yet. From what I can see it seems to be a port from the one you can find in Chrome's store. Actually, if you're fine with Xdebug Helper, there's no good reason to switch. Just choose the one you like. EDIT: Moreover, Xdebug Helper addon seem to have registered nice keyboard shortcuts, it's far more advanced than XDebug WebExt, and for that I probably would tell you to choose the other one ! :) But when I'll have some spare time, I'll add a few keyboard shortcuts, it's a nice feature.
&gt; Programming seems like one those jobs you can do until you die(no that you'd want to, but it's an option) Why not? It sure beats getting promoted into a manager function and then doing the same thing literally every other manager does. I didn't spend 8 years getting a programming education just to throw it away after 4 years.
dunno, though, what are the hours?
You can have 20 years of experience, or one year of experience 20 times over. From what I can tell when programmers are longer in the field they tend to fall into these categories: * Routine developers: these know a certain set of technologies and practices and are going to try to keep coding in those until they reach retirement age. Fine if that's what you need to do, hard to work with if you need more. * Permanent noobs: people who will never grow to become competent, but somehow manage to stay employed while they keep having that one year of experience over and over again. Steer clear. * One man armies: people who just keep growing, and growing, and growing. Eventually they become swiss army knives who can be deployed in any project in any circumstance. Great to have on your team and very employable, but challenging to work with if you don't bring your A game because they don't tolerate B.S. * Management track: ex-coders who manage other coders thinking their coding background gives them a leg up (it rarely does). Whether they're employable or not is down to the individual. 
Maybe you should distinguish between the core logic (data and business logic) and the infrastructure (like database, mailing, logging etc). Composer is optimal for the management of "external" dependencies (libraries). You could bundle the main application together with all the Controllers, Services, Repositories, Entities and Views etc. Then organize your application modules with namespaces under the App\Service namespace, for example. App\Service\Customer or App\Service\Article. If you see a chance for a total independent "component" or "library" then just create a new Repo for it and include it with composer. 
I see what they did there; they lead you to believe the shame comes from the nature of the company, but really it appears they are talking about the programming language. It subverts your expectations, and from this humour arises. 7/10
Relevant, https://twitter.com/betaorbust/status/908890982136942592 Be aware of the wording some companies may use. One of the main tasks for a company is to reduce costs. 
I've been doing enterprise-y things, at-scale, for more than a decade and very rarely have found PHP lacking. I've written tons of Ada, Java, C/C++, ASM, Python, Javascript and dabbled in/with dozens of other languages. There are times and places where the features of one make it a better choice than another. If I'm doing "web applications" PHP is my choice. When I look at what it takes to accomplish the same thing with Java I'm *amazed* that anyone chooses Java.
yeah I feel about it the same way if someone insults my car. "I know, it's a 10-year-old Ford Focus. It's fine. Cost me less than a grand. It is OK."
Most people who "write with PHP" never asked a question like this. They just wrote. Given you are asking other people if it's going a good hobby for *you*, better look for the another one, about which you'll be more certain.
Not printing anything at all is even faster. Which basically means that commenting out stuff is good for performance.
BTW, this one architecture is literally the "how to make your apps worse and impossible to debug" architecture. Don't confuse this with event-sourcing and other good uses of events, in a structured, clean way. This one will seem fun at start and somewhere 6 months to a year after your project started you'd be pulling your hair out. Where functional programming is about how to avoid spurious side-effects and hard to control shared mutable state, this one encourages you to go wild and ignore all this, wiring up all your components so receivers don't know the senders, the senders don't know the receivers, and call this "decoupling", as if *depending on unknown components to emit very specific set of events in very specific circumstances* is making you decoupled from them (spoiler: it doesn't). As for controlling handling order of events? Just kidding, you can't do that. You can try with priorities, this is just a short detour before you either embrace the chaos (and the newly increased security of your paycheck managing this monster!) or you quit.
/* less is more */
&gt; If I'm doing "web applications" PHP is my choice. PHP is typically my choice as well. &gt; When I look at what it takes to accomplish the same thing with Java I'm amazed that anyone chooses Java. Hmm, why? Spring is very feature-rich and not hard to work with. I would say it's no harder than Symfony or Laravel.
They are, it's just weird for someone coming from something like JavaScript. They expect array functions to be methods on the array itself and not just global functions. PHPs global array functions are super powerful though even if they are an eyesore. 
I'm approaching 40 and have more work than ever before. At my day job I've moved more into a management role, mostly because I'm really good with clients. I'm constantly told that I do a really good job at explaining things and put clients at ease that we can solve their problems, my bosses love it. I'm basically the exact opposite of the bobble-head guy on the HP commercials who walks around the office telling everyone it can't be done. I also make sure that I'm constantly learning something new outside the the standard LAMP stack. If I have downtime, I jump in and start learning anything new that seems useful and will be a potential benefit to my skillset. I even started learning about robotics and got pretty good at circuitry and soldering components together. There are numerous opportunities to expand what you think you know, take them. The worst thing you can do is put yourself in a silo and think that you've figured it all out. The biggest difference that I see between myself and most of the younger devs that I work with is that they don't really seem to see the bigger picture on projects and often struggle with architecture. I spend a lot of time explaining how part A can work with B, B to C, etc. But I think that's just purely an experience thing, like a chess player that learns to see several moves ahead. Some figure it out, some don't.
That's the point, you don't have to. You learn the rule (haystack first, needle second), and can apply it everywhere. That consistency is very much nicer than with PHP.
The older guys just know the pattern more often than not and get to it. Great thing to pick up on from them. Not always great at keeping with the shift forward in best practices and updates. Waiting for that to describe me...
You're talking about user-facing modules that users will be able to add/remove/customize. If I were you I wouldn't use Composer for this. Composer is a developer-side tooling. Just like you wouldn't build your modules around something in your IDE, I think you shouldn't build modules around Composer. For example, if you want to be user-friendly, you shouldn't let people install modules and then wait for Composer to decide the version doesn't fit. You should *never show incompatible modules* in the app for installation in the first place. Maybe your needs are more modest than what I imagine when people say "application modules for my clients", but then we wouldn't be talking about modules at all. Just configure the app for your clients through Composer packages, deploy it, and you're done. Nothing specific required. But if you want truly seamless user experience, and even more - if you want tight security, then Composer can't help you. You need to roll a solution that has those considerations as Composer doesn't. 
Indeed I use Composer for infrastructure dependencies only and just like you I'm not sure about moving some domain logic into the vendor folder. So - correct me if I'm wrong - you suggest to keep it all together as long as I cannot make it 100% independent. Thanks for the reply!
&gt; Hmm, why? Spring is very feature-rich and not hard to work with. I would say it's no harder than Symfony or Laravel. Honestly, it's been years since I took a hard look and that's probably my fault for not revisiting. I'll say that up front. Your quote somewhat gets at the heart of my "distaste" for Java in this context. Many web applications don't require a framework, and wouldn't be improved by the use of one, and in those cases PHP provides me most/all of what I need. Want to do a web app in Java? Can't just use the language. You can, but oh-my-god-look-at-how-much-verbose-code-it-takes-to-accomplish-anything. Most of what I need I get from PHP, most of what Java provides I just don't have a real use for. Cheers!
I've had an ex-programmer boss that I loved because he was a little more adept at stopping the people that really had no clue from pushing forward "bad ideas" or "bad designs" to implement. I'm a mix of the one man army and permanent noob. My resume reflects such. Been really, really lucky with tech leads... 
Here in France, if you're an old developer, it means that you didn't succeed. Here, you're supposed to become a CTO or else, be considered some kind of loser. When we hire junior developers and we ask them, "where do you see yourself in 5 years? "90% of the time, they say they want to become a Technical product manager and then CTO, rarely a coding guru. Just like if coding was a step to a "higher" position, whatever it means. I had this CTO and associate of a company I worked for, he was 55, whom would mentor his team. Every week, he would spend a day with one of the guys and review his code. They would gain from his experience, and I think it's something he really liked to do. Overall, it helped us be consistent and make better product
Thanks for your feedback! I probably should have clarified in the post that these modules are not managed by app users, we ship the app with pre-defined set of modules. &gt;Maybe your needs are more modest than what I imagine when people say "application modules for my clients", but then we wouldn't be talking about modules at all. Just configure the app for your clients through Composer packages, deploy it, and you're done. Nothing specific required. Indeed, that's my case. Could you elaborate on "application modules for my clients"? If these are not modules, what would be an appropriate term for these components? So I can Google more into this.
What I imagined is an experience closer to - you log into the admin, as a client, and you can shop for modules, similar to phone apps. Something to consider. If all you need is for *you* to preconfigure the app and ship it, sure, Composer is fine.
That's interesting, thanks
&gt; Many web applications don't require a framework, and wouldn't be improved by the use of one, I disagree. Unless you like rewriting the same shit all the time, frameworks are an absolute must. &gt; and in those cases PHP provides me most/all of what I need. That's because PHP is basically a web framework in and of itself. It's pretty much only useful for web applications. Its entire standard library is tailored for web applications. It is the only language where this is the case. In every other language, you use a framework. Python, Ruby, Javascript, Java, C#, Go, C++... you need a framework.
The reason is because everything is an object in those other languages. So there is no haystack, only a needle. For any method that has more than one parameter, you're either forced to memorize it, look it up in the manual, or let your IDE do the work for you. And then there's the actual stdlib that you'd need to either memorize, or look up. What's the name of that one interface you want to implement again? What was that method called for sorting? There's plenty of reasons to need to visit the manual in every language. Dinging PHP because you're too lazy to use an IDE is not valid.
Ah, good, thanks! How about using main application as dev dependency while working on module? The more I think about it, the more acceptable it seems to me. Do I miss anything in this regard?
Nah, seems common sense. The module needs the app. It's a good way to do it. Good luck!
Well then let's look at haskell. No objects, still consistency. Parameters are always ordered the same. Or the lisps. And their stdlibs have consistent naming, consistent interfaces, etc. Both are decades older than PHP.
&gt; http://www.richbuilds.com Holy crap man, great job on those models. My almost 9 year old son is amazing at building everything out of Lego without instruction. Thinking I need to get him into this direction too. He's insanely artistic. Going to show him your site later.
I think you need to ask yourself what you want to do, and how you can accomplish it. Making fast money will likely not happen, but if you really only cared for it because of the money I recommend, * Taking classes (school, online, college seminars) * Going to college * Getting a job Why? Because personally I find all self-taught people who are successful had a passion for it, while taking structured courses will allow you to learn the concepts you need. For example, I'm pretty young. I started out looking at VB6 source code for Starcraft: Brood War bots, and taught myself independently via that. I continued to print documentation, and teach myself .NET (couldn't run the new IDE on my computer). Eventually I got a great enough computer and taught myself C# and Visual Basic .NET using the new IDE. From there, I taught myself basic Java, F# and Python. By the time I was 18, I was really fluent in C# and VB.NET, while at this point focusing fairly heavily in IT concepts instead. Now, I'm working fulltime as a developer without any college degree. They hired me for Fullstack work (barely knowing any web languages). I honestly took a 2 week crash course with CodeAcademy and YouTube tutorials, but my C# background helped me grasp PHP extremely quickly. Moral of the story? The language doesn't matter, it just matters on what is most effective for you.
AWOOGA! AWOOGA! "We expect you to work for free AND LIKE IT!"
[removed]
Thanks :) If I could earn as much from making models as I do as a dev, I'd ditch my coding career in a heartbeat :) 
I'm not claiming that PHP is consistent. It clearly is not. It would bea better language if it was more consistent. I'm claiming that its inconsistency is not actually a problem in the real world.
I personally taught myself PHP when I was 19-20. I'm now 26, and working as a Senior PHP Developer. My advise to you is, if you learn PHP, learn best practise from the start. Have a look at the Laracasts videocasts (they've got non Laravel specific ones), they teach a LOT of information, and will get you on your way. From those series', you can easily move your skillset into Laravel, Symfony, or another framework. As you already have touched the JS, HTML5, etc. you'll be slightly ahead of other newbies, keep it that way. When starting out, don't be a specialist; learn your trade, then once you know more, allow yourself to become an expert. One person has already mentioned this before, but keep other developers close to you as friends. They're a great asset to have, both at work, and in personal projects / learning. I myself am very close to a guy I hired a couple of years back, and even today, we still ask each other for help when stuck in a rut. Overall, PHP is a great language, with very good salary offerings; for the right people. Be passionate about your code, admire it. Find time to learn new packages, techniques, patterns etc, and you can't go far wrong. Best of luck to you.
The best thing about deleting code is you don't have to debug it later :-)
I'd actually argue the opposite for this. I find it's easy for newer programmers to become bored if they're not actually creating something. PHP and Javascript are great for this as the barrier between writing code and making something functional is actually very small. I agree that Python is great for learning language fundamentals, but if you're looking for a hobby then PHP is a better bet and you're much more likely to be able to get to a place where you can earn a small amount of money building small systems for clients.
Well, then why did every PHP framework that exists build their own clone of every stdlib function, if it's not relevant? Why does JS have projects such as lodash and rambda and moment? Consistency matters a lot.
That's how I feel about making things out of wood and raising chickens. It's funny what being a dev allows you to do outside of work. 
&gt; Well, then why did every PHP framework that exists build their own clone of every stdlib function They don't? That would be pretty silly. Things like lodash and rambda exist because Javascript, as a language, lacks a lot of features. It's the same reason jQuery became so popular and has survived for so long: because the Javascript stdlib sucks, and is extremely lacking. It cannot do super basic things that you need to do all the time - or if it can, it happens in a clunky way.
So for PHPUnit, you should mock the database provider: class ToTest { private $database; public function __construct(\PDO $database) { $this-&gt;database = $database; } public function methodNeedingTesting(array $data) { $sql = 'INSERT INTO random_table (column1, column2, column3) VALUES (:param1, :param2:, :param3)'; $query = $this-&gt;database-&gt;prepare($sql); $query-&gt;execute([ ':param1' =&gt; $data['param1'], ':param2' =&gt; $data['param2'], ':param3' =&gt; $data['param3'], ]); } } class Test extends PHPUnit\Framework\TestCase { private $database; private $testing; protected function setUp() { $this-&gt;database = $this-&gt;createMock(\PDO::class); $this-&gt;testing = new ToTest($this-&gt;database); } public function testCorrectParameters() { $statementMock = $this-&gt;createMock(\PDOStatement::class); $statementMock-&gt;expects($this-&gt;once()) -&gt;method('execute') -&gt;with([ ':param1' =&gt; 'one', ':param2' =&gt; 'two', ':param3' =&gt; 'three', ]); $this-&gt;database-&gt;expects($this-&gt;once()) -&gt;method('prepare') -&gt;willReturn($statementMock); $this-&gt;testing-&gt;methodNeedingTesting([ 'param1' =&gt; 'one', 'param2' =&gt; 'two', 'param3' =&gt; 'three', ]); } } Remember that your Unit Tests shouldn't touch the database, as this makes them integration tests and adds a lot of complexity to your testing environment. See the PHPUnit documentation for more information: https://phpunit.de/manual/current/en/test-doubles.html
&gt;The simpler the solution, the better. I've never had a problem that was solved by complicating it. This just means that you should always split your solution to the simplest task you can. If something can be split into multiple tasks, you can identify which are unnecessary. If you see it only as the broad solution, you are immediately overthinking it and making it far more complicated than it should be.
And that exact same criticism you just voiced about JS also applies to PHP. I don't hate PHP — I use many languages frequently, and it is one of them — but it certainly has the same issues.
Management hours can be way worse, believe me. There is this concept that being a manager is just ordering people around. It's tedious hours of reviewing what your developers did and guide them on any improvements they may be able to make, writing documentation on projects, figuring out who's working on what, who's doing what, listening to your team's complaints and concerns, your boss's complaints and concerns, trying to show them all that you may have a solution for all that and come up with one, meet with clients, meet with external development teams, meet with your project managers, try to have all these people satisfied at the end of the day. The hours will end up being murder, if you are actually a proper manager, and not someone just filling space.
I just toggle the xdebug extension whenever I need it. It really kills the performance when enabled on web server :/ Am I doing something wrong?
I'm 38, but I changed careers and have only been developing for 2 years. While I don't professionally code in PHP (although it's my favorite language), I can tell you that I generally despise people that have coded for 20+ years. The majority that I've seen know a way to do something and refuse to try and learn any other way. I know this is not true for everyone - this has only been my experience. At my last job, we were using Node/Express, and for EVERYTHING, the old guy would use 'exec', which is Node's way to interact with the Linux shell. However, they have their own built-in functions. So, for instance, you wanted to delete a file. Instead of using Node's FileServer functionality, he would just use exec('sudo rm file'). STOP DOING THAT! It's a million times slower and not the right way to do it. He was - by far - the worst offender I've ever run into, but it seems to be very common, and while I have only coded for 2 years, I pride myself on always learning new things and being up-to-date on everything. EDIT: Why am I being downvoted? The question asks for my opinion. The downvote button is not a disagree button. If you disagree, wouldn’t it be more beneficial for you to explain why?
&gt; Learning new things is harder, not impossible though. Isn't it more like most new things are rehash of older ones so learning it has to come with real benefits. Example: JSON. We had XML with a ton of tools and libraries. Someone decided it was better for their resume to invent some lightweight thing instead of learning XML. So they used JSON for things where XML was perfect. Now they want to validate it: JSON schema is coming. Soon we'll see the equivalent of XSLT for when you want to tranform a JSON to some other JSON or text document. And lot of tools have to be reinvented: you want to describe an API with auto generation of mocks and things, fuck WSDL and let's half-ass a full ecosystem of shit (Swagger and friends).
I don't know why you crossed off cheaper, because I am sure that is valid. It is a race to the bottom, like everything else is.
Add more contrast, FFS. The articles from that site are always interesting, but I never read them fully because that design hurts my eyes.
45-50.is not "old"
To be fair, OOP isn’t always the right solution. But it sounds like this person was defending spaghetti code, rather than just a different organization style. 
Hey thanks!
Unicodes are multiple byte characters... so XOR is probably going to break those bytes apart and create invalid unicode characters that can't be displayed. what are you expecting?
65 is way too young to retire nowadays 
Maybe it's just me but I would never consider ES as a way to _decouple_ my components. As /u/LtAramaki already explained, have events doesn't decouple anything. ES is about keeping track of the changes instead of mutating directly a state for example for traceability. Another thing is that an event-oriented architecture is hard, it greatly complexify the architecture and don't you dare using that in production without any experienced person to deal with it and proper debugging/logging tooling.
The difference is that PHP's stdlib is feature-rich and functional, unlike JS, albeit a little messy.
&gt; The simpler the solution, the better. I've never had a problem that was solved by complicating it. I guess it depends on what you mean by a simpler solution. Simpler to read/write the first time? Simpler to maintain and extend? My current boss is big on simple solutions. He doesn't like things like interfaces and DI/IoC, though that doesn't mean he thinks they don't add value. A lot of the code in our code base is really straightforward, but it is extremely tightly coupled and difficult to change. For example, all of our business object classes contain Load/Save overrides that are coupled to a database implementation. The specific database server is abstracted away, and that's good, but we'd be hosed if we ever had a customer ask us to read/write from anything besides a database. Also, because each object has its own Load/Save logic baked in, there is no way to implement it differently for a specific use case (eager loading a dependent object in a single query, for instance). Like I said, the code I work with is extremely simple, but I don't know if I'd say that it's better in all cases.
Hey! Tkx for your tip!! It's a default WordPress template, I cant change it. But I can change the template itself... And I just did! :D Let me know if this one is more readable. 
Java is to programming languages what Microsoft Windows is to OSes. There's nothing other languages with separate libraries can't do better than Java. Especially faster and more securely. But hey, I have been programming 40+ years in dozens of different languages. I probably haven't had the chance modern developers had to learn one primary language and use that in every application I encounter, regardless of whether it makes sense. Java as an interpreted platform, sucks huge balls. It's used in many scenarios where it shouldn't and doesn't need to be interpreted. Also, object oriented programming is not always needed everywhere. Forcing OOP down peoples throats whether they need it or not is a curse. At least PHP makes sense as an interpreted language. At least PHP was developed to be really good at specific things. Java is your goofy uncle who seems to know a little bit about everything but is never the best at anything in the room even though he thinks he is the best at everything. 
Hmm so there is no way to save them to retrieve it later?
If you work as a software developer you usually have the great advantage of an above average income. If you live frugally (but still enjoy life) and save a large chunk of your income you should be able to retire way before the usual retirement age. That way you don't need to worry about becoming obsolete in your 50s. If you want to keep working you can, if you don't you don't need to. The rule of thumb is save 25x your projected annual retirement expenses and you are good to go. Some have been able to get there in their 30s. This is a gift that comes with the job that is usually underappreciated but in my opinion the single biggest advantage of the job. Check out /r/financialindependence and /r/leanfire if you are interested. 
&gt; ~~Java~~ C++ is far better for things like networking, concurrency, large complicated applications, enterprisey things, etc. FTFY
Compared to Java, C# or Qt, PHP certainly is lacking a lot, though.
&gt; I've been doing enterprise-y things, at-scale, for more than a decade and very rarely have found PHP lacking. I have as well. Facebook runs on PHP. It doesn't get more "enterprisey" than Facebook. &gt; I'm amazed that anyone chooses Java. My impression is, nobody *chooses* Java. It's the cirriculum that they have to learn to graduate with a degree, or get a job in a company that has lots of IT executives routinely taken out to lunch by Oracle salespeople. Or, they're forced into it in cases where they want to develop for a particular platform (like Android) where it's the standard. 
Much better, thanks.
&gt; I disagree. Unless you like rewriting the same shit all the time, frameworks are an absolute must. You really think you have to rewrite things all the time unless you use a framework? &gt;That's because PHP is basically a web framework in and of itself. It's pretty much only useful for web applications. That's exactly right, and there's nothing wrong with that. Although like Java, PHP can be used for a wide variety of other applications, but it was designed to be very good at certain things, unlike how Java is basically mediocre at everything and isn't superlative anywhere. This is what modern day programmers haven't figured out yet. Languages are *tools*. Not every tool is ideally suited for every job. Java programmers try to use the same tool for every job, and it's why so many of their end results suck. 
&gt; If you can't name a half dozen ways PHP is a crime against humanity, you're not an experienced PHP programmer. If you can't do the same thing with *every* language then you obviously don't know many languages. 
ummm, I think there's a misunderstanding here... Maybe in my article or in your comment, or in both! :D &gt; have events doesn't decouple anything. Actually, it does. The component triggering the event will be coupled to the event dispatcher (interface) but will not be coupled to the component(s) receiving the event and acting on it. However, if you said this referring to Event Sourcing, then yes, I agree with you because as you say very well "ES is about keeping track of the changes instead of mutating directly a state for example for traceability." Event sourcing is only one of the ways to use events. In my article, I tried to refer several ways to use events and what they are good for. I think I failed here: &gt; In my experience, there are two cases in which to use events: &gt; &gt; 1. To decouple components &gt; 2. To perform async tasks Indeed ES doesn't fit in either of these. I will correct this. Tkx for calling me out on this. Furthermore, I agree that is more complex than the usual "inject object and call method" way of doing things, but I've been using it for some time and if we do it right we have big benefits as the application becomes much more organic and decoupled. Also, I do warn about the dangers: &gt; Nevertheless, there are dangers to it. If we use it indiscriminately, we run the risk of ending up with logic flows that are conceptually highly cohesive but wired up together by events which are a decoupling mechanism. In other words, code that should be together will be separated and will be difficult to track its flow (kind of like the goto statement), to understand it and reason about it: It will be spaghetti code! &gt; &gt; To prevent turning our codebase into a big pile of spaghetti code, we should keep the usage of events limited to clearly identified situations. Again, tkx for your comment.
Not everything needs to be OOP. OOP is a tool just like languages. Unless your application has a need to utilize OOP-like capabilities (beyond the illusion that OOP syntax is somehow more intuitive or user friendly), it's a waste of resources. PHP embraces this idea and gives developers the ability to not bloat their code unnecessarily. It's funny how what some people feel is an advantage, others feel is a disadvantage. 
Agree. The problem with these observations is that critics take the language out of context. A language should really only be evaluated in the context of its ability to solve a certain problem, not its general features. 
This sort of old, crotchety, and unwilling to do anything new has been my experience with the 50+ crowd. We built an interface for some processes that used to be all manual and this one old guy refuses to use it. It's literally going to a web page and clicking one button instead of manually entering commands for 10 minutes and he will not do it.
I digress. I think "great" needs context. For web apps (in a general sense), PHP is "great." That's what it was designed for. Calling any language "great" or "crappy" without context is useless. 
I'm curious if it's age descrimination vs the salary range he was looking for. 
&gt; You really think you have to rewrite things all the time unless you use a framework? If you're not rewriting it's because you're reusing, which means you've basically created your own framework. Web application tasks are extremely repetitive. You need session stuff, database stuff, form stuff, template stuff, authentication/authorization stuff, cookie stuff, file stuff, image stuff, etc, in pretty much every single application. Why not use a framework so that you don't have to touch *any* of that stuff? &gt; Although like Java, PHP can be used for a wide variety of other applications It *can be*, but there's *absolutely no reason* to use PHP for anything outside of web development. It's a terrible choice for anything outside of web development. &gt; This is what modern day programmers haven't figured out yet. Languages are tools. Not every tool is ideally suited for every job. I've said that several times in other replies. I'm not in love with any one language, I just use the best one for the job. &gt; Java programmers try to use the same tool for every job, and it's why so many of their end results suck. I don't think the end results would suck just because they chose Java. Java is an extremely capable language.
For non-web related tasks, yes absolutely.
But writing ~~web apps~~ anything in C++ sucks.
Not going to defend him, but I do think Object Oriented programming is an evolutionary alley in the history of programming languages... For me (who has tried to modularize/create libraries with C), it is very clear the roots of OO and of why it took the world by storm, but it launched us in a direction where we aren't able to find the proper abstractions for the problems at hand... I think the future (and present) is functional programming.
LOL... not if you have good libraries. Programming is about writing your own stuff. If you need a language that has everything built into it, you're not a programmer. You're a housekeeper. 
You can try to achieve it as reported here https://github.com/zendtech/ZendOptimizerPlus/issues/126#issuecomment-24026853
Most PHP apps are hooked up to the web, which means input garbage is to be expected. I find variable typing and other constraints to offer a false sense of security. The programmer should always qualify his own data regardless of the language's built-in constraints. I feel the same way about data types in SQL databases. I don't trust any outside system to tell me what data type is in a variable. 
Node is far from being a _server-side_ runtime. It makes a bridge between a Javascript engine and the OS while exposing parts of the OS/Libraries APIs. Node.js is an ecosystem in itself, so no, not ONLY a framework, but it contains a framework in which you can build the scripts (framework which contains the exposed APIs). Saying that Node.js is a SERVER-SIDE runtime is stupid in itself.
That was incredibly well done. You have great talent as a explainer
&gt;I find variable typing and other constraints to offer a false sense of security. It is a very true sense of security though. Refusing to use proven means to reduce bugs and vulnerabilities just to make a point about how one can deal with security on their own is... unprofessional. &gt;I feel the same way about data types in SQL databases. I don't trust any outside system to tell me what data type is in a variable. So you don't use prepared statements or what are you getting at?
I'm not sure how you jumped to that conclusion from what I said. I find C++ as a language to be a pain in the ass. I'd rather be writing Java or C# any day.
&gt;It is a very true sense of security though. It can be true or false. I think PHP definitely has had an evolution, and there are things that could be improved. But I also think that not overly depending upon built in abstraction layers to sanitize your data is quintessential bad programming. &gt;So you don't use prepared statements or what are you getting at? No, I do. I just never assume everything is as it claims to be. For example, if you are diving by a variable, and by all accounts that variable should never be zero, I'd still check to see if it was zero before dividing. I think in many modern apps, too many people (figuratively speaking) make assumptions that "it won't be a zero" because of language features that may or may not be 100% reliable. This becomes even more critical when you take into context malicious hacking, buffer overflows, etc. The programming environment can still behave as it promised in one context, but have compromised data anyway. 
I am a permanent one many army noob 
How are you going to store a date with timezone in Java without knowing the timezone? Dates are very easy in PHP. Store as UTC and let the user's browser deal with it.
&gt; What if I want to store that something will happen at a certain date and time, in whatever timezone the user will be in then? That's a so called Local Date Time. PHP doesn't have it. Since PHP runs on the server, you have to ask the user. The current covention is storing the date as UTF in the server, then using the user configs to convert to date from UTF to his timezone. Most websites uses client-side tricks which fetch the guessed timezone of the user and uses that by default, but also allows the user to change his timezone. PHP supports the convertion of timezones seemlessly. &gt; What if I want to store a date and time with an offset to UTF,but disregarding DST transitions and timezone changes? That's an Offset Date Time, PHP doesn't have it. You can use the Etc/GMT+x and Etc/GMT-x timezones to mimic that. &gt; Java has classes for these, and much more. It can handle Arabic dates, if you want to, or time on Mars (a few minutes longer days) or Venus (days longer than years). It can handle DateTime without a timezone, and convert it later to a timezone properly, it can handle specific moments in time, even those during timezone changes. I think that the IntlDateFormatter class can handle that, although I never tried it. I don't think that it can handle dates on other planets. Although yes, you can support dates during timezone changes very easily, and even calculate the difference between multiple DateTime objects that has to support DST. &gt; In PHP, storing a date and time relative to no timezone already requires you to roll your own dulian datetime. You can do that by just storing the date string as-is and then using it when you have a timezone. If you wouldn't have a timezone in a DateTime object, it would break most of it's features (and wouldn't really make sense since you're missing an important data).
exactly! :)
Loser... That's an error you make when you are not 100% fluent in English and you rely on your smartphone auto completion system 
I think it all depends upon the application. I think about what tool will do the best job. Not which one makes me feel better. I feel good when the job gets done. I don't really have any loyalty to any particular language, but I can't help but defend the tools that have defended me and my jobs for decades. 
I still have no idea what you're expecting to have happen... once you XOR, don't think of anything as unicode, it's just bits.
At the bottom end of that age range, but still learning. With every new version of your IDE, language, toolbox and so on, there are always new things to be discovered. I too have realised that work stops when you leave the building, that a lunch break is best away from my desk, and that I still get a little depressed when our latest recruit is young enough to be my child. 
Well, you don't have to ask the user. All this behaviour is standardized. But PHP has no functionality for it. Specifically, you can convert any julian or gregorian timestamp into julian day and millisofday, and use them to operate on timestamps without timezone. Even "2h later" or "next week" are well defined. PHP doesn't support that without dealing with timezones (which then leads to problems).
Simple, as LocalDateTime, which stores the day since a defined start date, plus the time of day in local time. You can operate on it, and convert to a ZonedDateTime with a timezone, which then nets you an Instant in UTC.
Yes, exactly!
I am expecting it to be saved and later retrieve to get original string.. nothing fancy. But I am unable to save that returned xored value. Because when I select in browser it just mess up those invisible characters and I am also unable to get them from viewing webpage source code in browser. I don't mind if in some way I can directly write that xored value to a file.
[removed]
Sounds a lot like our guy. I wonder if he’s moon lighting. :) He’s almost always a huge pain in the ass to deal with. 
You can host the *code* on Github, but to actually run the project so that other people can access it, you will need something along the lines of Dreamhost or GoDaddy to get a domain. You might be able to get by with a cheap shared hosting plan from the same place. If your project is complex, you’d want to provision a private VM with someone like AWS, DigitalOcean, Azure, or Heroku. You’d then point the domain DNS to the VM. 
Agreed, OOP isn’t always the way to go. Take functional programming, he doesn’t even know what that is. He writes tons of spaghetti code and then defends it with a very old view of things. Trying to get him to change something like that becomes a 2 hour debate on best practices dating back to like 1987. It really sucks. 
&gt;Isn't it more like most new things are rehash of older ones so learning it has to come with real benefits. I believe they're talking about old-age. As we get older our grey matter brains get harder, making it more difficult to acquire new knowledge.
Other decent hosts I've worked with, Vultr (decent priced, unmanaged), Psychz (managed, dedicated boxes only), and Bluehost (terrible service, downtime was pretty bad, but cheap. Managed VPS with panel is the same price as Vultr unmanaged, but with less space).
War is peace
as long as your run composer during build-time, you should be fine, however if you try to do runtime-plugin stuff, don't do it. 
Why does RHEL and CentOS release things so late?
Nah, as long as your mind is healthy it's a mindset above all. Real issue is your priorities change as you get older. Once you start thinking about the fact you only have a few decades (or less) left to live you don't give a shit about "new" unless it's something you are already passionate for.
TAD &gt; TDD; you heard it here first, folks.
What kind of problems are you experiencing with timezones? Timezones supports every date and time-related rules. So if you add 2 hours right before DST, it will come out at the right hour, as long as you have the timezone set. $date = new \DateTime('now', new \DateTimeZone('America/Toronto')); $date-&gt;modify('+2 hours'); This will work while taking everything into account for you.
mh.. I'd probably structure it differently, going with: app-customer - everything that's customized (e.g. the composer.json with the modules for that customer) * depends on: app * depends on: modules app - the non-module code * depends on: external dependencies modules: * depend on: probable external dependencies? * depend on: the app's version to which interface they fit * dev-depend on: an app-customer implementation focused on developing modules I'd build myself a skeleton for the app (https://devedge.wordpress.com/2014/11/05/building-better-project-skeletons-with-composer-2/), and I might actually build the post-create hook there in a way that allows me to pick modules at the end of creating the app-customer instance on a side note, I'd probably develop modules against tests rather than against a dev-app, but I assume that's not what you are after from your question hope I could help. edit: because apparently, the markdown here needs a blank line before a list edit 2: added note about developing against tests, fixed some spelling 
on the same level, if you're 45, don't expect to find a new job... Both facts tend to change but it's rather infuriating On the other side of the spectrum, junior are like diva. In a country where you tend to stick to your job cause you might end up unemployed quite easily, they switch from one company to an other in a snap. While, here, if you stay less than 3 years in a company, you're usually called unstable and unfit for a long term contract
What about using something like cloud ways google cloud servers? We really need the website for a 1 day event lol.
What about using something like cloud ways google cloud servers? We really need the website for a 1 day event lol
I need to store stuff like "Every day, at 2am". Or "Second working day of the week, at noon". And later on I get a timezone from a user, and combined with that data I need to convert them into actual times. This is what Java has LocalDateTime for. PHP doesn’t. Please read the documentation of LocalDateTime, OffsetDateTime, ZonedDateTime, and Instant, and try to understand what they do different, to understand why PHP’s solution is suboptimal.
&gt;one year of experience 20 times over. I see this phenomenon being mentioned a lot with similar wording, but hardly anyone discusses fixes to this problem... why? I've read stuff on how to *prevent* the "permanent noob" experience, but not how to cure it once you are waist deep in it, which is kind of annoying.
once again, after the XOR, you have to stop thinking about them as characters. you have bits, and you'll need to treat them as a binary blob. i still have no idea why you are doing it this way, but you made it very clear you don't want anyone to suggest you do it any other way, so i won't. 
doing it for pretty much learning different things. Is there anyway to save binary blob to a file?
That's actually out of the scope of PHP's DateTime. It's goal is mainly to support a single point in time and have the ability to convert it to various timezones or manipulate it. But you're right, I don't think that there's something that supports repetitive dates in PHP's Core. But the classes you linked don't handle that automatically either... unless I'm missing something?
&gt; But the classes you linked don't handle that automatically either... unless I'm missing something? You use LocalTime/LocalDateTime together with Period or Interval, and then they do. LocalDateTime to mark a starting point, Interval to mark the distance between two points. &gt; That's actually out of the scope of PHP's DateTime. It's goal is mainly to support a single point in time and have the ability to convert it to various timezones or manipulate it. Yes, that’s what Java’s old Date does, and it’s deprecated because that’s just not good enough, and very confusing.
Not really familiar with Cloudways, but they appear to be a manger/provisioner for other VM services. All these things would work. More important — what works with you budget. Are you going to be up for one day with 500 hits or 500,000? 
why would they ship PHP 5.4 though
&gt; start preferring younger, perhaps better or cheaper, programmers. But they will happily pay **engineers** what they're worth. Don't stagnate and your demand/paycheck won't either.
open the file in binary mode and write to it as normal.
Ah, well, we have DateTimeInterval and DatePeriod in PHP. I never got to use them though. I guess that would cover that feature. Edit: The old PHP date() was a mess as well. I cringe when I see that being used in any code...
43 year old here. First thing to note is that not all developers stay 'in the trenches' for the entirety of their careers. Management isn't just a place you go when you are useless.. Some developers find that they are useful in mentoring the younger generation in their careers as well as helping to foster good development technique along the way.. It can be a 'natural progression' for some. 
You can put your code on GH and use GH pages to host the site (and it’s free): https://pages.github.com
like &lt;100
&gt; I guess that would cover that feature. If your starting point is an absolute point in time – as mentioned before, if you just deal with relative time, PHP is useless.
to my knowledge GH pages doesn't run php code?
This has been discussed before, as recently as a week ago. Did you have something to add or discuss?
I am 55, currently earning the highest amount I ever have doing the most intensely complicated project I've ever seen with the latest React JS toolchain. You have to do two things to remain a valuable asset: 1. Never stop learning and reading around the current technologies - this makes you able to be a useful high functioning team member of current projects like the young guys. This does get harder as you age, but discipline is required, it wont happen automatically. 2. Develop a deep and pragmatic understanding through experience and also reading of how dev decisions can affect business outcomes and why this matters - this makes you able to prioritise the right aspects of a project to get the result that the customers need in a timely and cost effective way. Number 2 is the most important and why I am paid more than the young React guns. A business centric focus enables you to question assumptions about "how" to do things and more importantly "why" to do things, and to find better solutions to problems. This is something the younger devs usually utterly fail to do, they are often wedded to the one technology they have learned and the few examples they have seen, but their experience is shallow, they have received wisdom rather than real experience. They often don't question this received wisdom or try to optimise for business value based on the similar or alternative solutions they have seen because they have none, and in many cases they have an naive idealist fixation on the purity of the code somehow being more important that the actual business outcomes that pay their wages. EDIT: I'll add one last thing. You have to have good communication and listening skills. Many young devs despise meetings or any other human contact with the rest of the business who might actually have to use the product they have made. Devs also often have an adversarial or conceited, superior undertone in their communication. This is a mistake, and bad manners as well. Meetings are often wasteful and distracting, but they are often inevitable. You need to see them as an opportunity. If you are seen as a clear communicating problem solver who listens and understands instead of techno-babbling and acting dismissive, you are automatically seen as an asset and a key player. Some of these things are wrongly seen as management skills of no significance to a coder. Thats wrong, they are human interaction skills, essential to any team member worth having around. 
Yep, the best code is no code
I'm not sure about cloudways. But honestly, if you need it short-term, most places charge monthly. Vultr *doesn't*. They bill hourly. So first try something like 000webhost, because it's free. Personally after that I recommend Vultr because you can pay to run it for however long. Just *make sure you* ***destroy*** the server when you're done or you'll pay for it, even if it's sitting disabled. If you have some extra money, just get a cPanel installation (they'll charge you for a full month because that's how the licensing works) and you can have a basic unmanaged server up within a few hours of googling.
I hadn't been using the PHP that comes with it either. For whatever reason, I thought, "Eh, let me check out using the local PHP instead of docker first."
Unfortunately you are mistaken. Node is not a framework in any way. Frameworks may be built on node however. Node is a server side runtime environment for executing JavaScript.
You could either base64 encode the string, which would allow you to save it like any string or save it in a blob field in the DB or in a file you opened in binary mode.
Uncle Bob claims that the number of new programmers has been roughly doubling every five years, and that this means that, for as long as this trend continues, half the developers out there always have 5 years of experience or less. This has the effect that there are a lot more young programmers than older ones. This makes it seem like programming is for young people, and older programmers must have stopped programming. He claims that most of them are still programming, there just weren't very many of them to begin with compared to how many programmers there are now. Personally, I think the most important thing is, how many years of experience do you have learning, experimenting, keeping an open mind, and therefore improving. I think until you become really very old or develop some kind of serious physical, mental health problem, I think that type of experience will make you better faster than your body aging will make you worse. Don't ever think you know it all, or you are the ultimate master, or your so good it is no longer worth improving. I feel like the way we all program now is really stupid and unproductive compared to what we will eventually discover. Along the lines of discovering what is next, I'm working on a really interesting library (could eventually become a framework or something, but for now is just a library) called [PurposefulPhp](https://github.com/still-dreaming-1/PurposefulPhp). It is still in the very early stages, and is highly experimental and incomplete.
wow I think it will work because later it can be decided as well to xor back. Thanks.
Then, please explain to me why am I using Node.js to compile Javascript files on my CLIENT ?
They are LTS support distros.
"{design pattern} architecture" It's like saying, "I've got this great hammer, let's see all the things I can build with it." Instead of, "I need to build a {solution}, let's see what tools I'll need." But then again I don't write blog posts, so titles like "this pattern is good for {situation} sometimes," is not exactly click bait. 
As far as I am aware (on the reviews) the develop said he wasn't upgrading his extension to webext. So it won't work on Firefox 57, released on November 14th.
I work about 50 hours a week, but not because I want my boss to be happy but because I'm allowed a ton of overtime (hourly worker) and can easily make an extra 30k a year. I'm only 34 at the moment, but I don't want to end up as an older developer getting pushed out without any money.
Everything gets 'old' to everyone at some point and most/some need to do something new/different at different point in life. Sharepoint is just like git with less comments ;) 
The only one I can think of now was my boss from a few years ago. He was really good. It was obvious he spent his whole career getting and staying on top of his game. He was difficult to work for though. Hard to please and always made me feel that I'm inadequate.
I think we're great.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Especially for a life long developer. I don't think i'll ever stop coding, i'll just switch to more personally relative things.
I didn't even know this existed until today. Found it via the .NET Foundation list of projects, and I happen to have both PHP + C# books sitting on my desk right now.
I got caught out by a nasty one the other day. I usually run PHP in strict mode (all notices, strict messages are exceptions). I'm not sure if it was a factor or not. I was testing something on a codebase that doesn't have this and forgot to put static for some methods. Rather than getting an error about accessing non-static methods in a static context, it works except that when you call non-static methods as static it fails to populate the static meta data. So within that non-static but statically called method if you have static or self for example, it fails as they resolve to the namespace of the caller rather than the context they are defined in. It's really confusing and looks like a PHP bug at first (kind of maybe is isn't bug or feature). Because of this bizarre inexplicable error message I started to wonder if PHP was bugged instead of looking for the obvious. Your code should also always be easily rapidly testable and runnable as much as possible.
&gt; killing yourself to meet the unrealistic deadline Single biggest contributor to stupid, tired head bugs imo. No-one writes good code in a rush. Well, that's not true. I think I've met maybe 6 coders who could, but they were the old guys when I was young. I can't write good code in a rush. I might be able to write code that works, but I'd never show it to a living soul and curse every day I had to fix/enhance it. 
Getting paid for you time is all that matters at the end of the day. Doesnt matter if you enjoy the code if you cant put food in your belly or have some sort of personal life. And you really need some sort of personal life. You have to interact with people to be able to write software that interacts with people.
Such a strange question to ask. As always when singling out a single "group" of devs, there's good and there's bad. I've worked with a 50+ dev who was completely on top of things, a great innovator who came in every day with lots of motivation. And I've worked with some terrible older devs who were there just to "ride it out". As long as the dev is up to date with technologies, I see no issues. 
yup. You can do a bit of prior research (general takeup, is it actively developed, dodgy licence) which cuts out a lot of chaff.
"free lunch" used to save me around £5 for the lunch hour. More because I stayed on site and didn't go boredom shopping in my lunch hour.
The inversion of control means that your module can be completely naive about what's utilising it. With one exception which is that it maintains a list of listeners. This gets a bit nasty, you're inverting other things too like relations. You start to want to use things like weak refs in places as it gets convoluted and complex. You then need to start looking ad IO driven and UI driven, who is the master... it's a mess.
A lot of systems code (cron job processes etc.) are written procedurally - because it's a step by step process: open file, read line, process line, repeat till end of file. OOPs great for representing hierarchies of things, not so much for step by step. You can find a happy ground between the two though. No need to get anal about what cool. What works simplest is what pays.
Build stuff and show it to people. It's how I got started (writing games and libraries for the ZX Spectrum back in the 80s). 
Code fast! Retire Young!
I've been doing async in PHP since before it was a big thing (I've been doing async for nearly 20 years in general thanks to things like mIRC script) because I had to and my advice is don't do it unless you have to. If you need full async, skip PHP and do another language.
Can you help me understand why they would need to wait so long to release versions instead of declaring them LTS right when they are released.
I just want to note that one doesn't need to deal with events directly to do async at all. The underlying mechanism will rely on events of some sort for I/O and timers. But on top of this it can be (and should be) regular callbacks, promises, and if the language supports it - async/await. Dealing with events directly just to do async is the equivalent of dropping to asm when you want to code imperatively/proceduraly.
You really have no idea what you are talking about do you? You said it yourself, you use tools that run on node to compile JavaScript that gets sent to the client. The browser has no concept of node, it already supports JavaScript. This is especially obvious when you consider that node was created specifically for executing code server side. Google node, that’s all you have to do. Node is still not a framework. Accept that you were misinformed and use it as motivation to improve.
It does not. Pages only serves static content.
PHP is a long way from that though and I wouldn't realistically hold it to become that effectively anytime soon. Most people are using promises and futures just as syntactic sugar as well because function chaining is hip these days. They're not really aware of how those things really work or what problems they address. It's not that hard really as it's just dependency concerns and understanding deferred (or on demand) execution/blocking. Even in functional async languages though, you need to think around a bit to properly manage GC.
If it needs to be on the internet and you don't care about speed, there are tons of free hosters available. If you have control over the internet-connection at the event. f.e. if everyone is using the wireless you provide, you can redirect every request from that wireless hub to a specific machine, running a local webserver. Considering that you seem to know close to nothing about websites, I can only recommend to hire professionals to do it for you. Costs, but learning how to do it properly takes years and you can invest that time or you can pay someone for their sacrifice... 
Companies usually prefer younger employees since they are cheaper. You only need that many experienced senior-developers. But you need a bunch of code-monkeys... And even though it's true that some of the older coders got stuck in their ways, stopped learning and are now behind, that's not true for all of them. I think another reason why some senior developers choose to leave their job is because they realise that they are the ones creating value and that they can make a lot more money if they just start their own thing, or at least go into an advising IT role in a huge corporation. Pharma and Banking usually pays well... I always found that software-development is paid extremely bad, considering how much value some projects create and how much effort is required to stay on top of the game. There's not much appreciation out there... 
for 10 year olds, 30 is old. for 30 year olds, 50 is old. for 50 year olds, 80 is old. How we experience the world changes over time. 
Yeah, and those 30 year olds don't realize how quickly it will seem that they find themselves 50 too and how they might just feel like they are just getting started 
My parents say the same.. But the truth is that when we were in school, people "beat us", in a metaphorical sense, to do what was expected of us. When we became adults, we were motivated to do our own thing in life and after a few years, like studying or throwing ourselves into a job. But that initial excitement disappears after a while. What used to be "a new era of our life" becomes everyday life. we get lazy. It's not more difficult to learn stuff. It's actually proven that adult brains can learn as good as child-brains, since the methods of learning that have been acquired through life (if they have been acquired) help a lot. The problem isn't the learning. The problem is the motivating yourself. And having a common-knowledge-explanation on why you shouldn't even bother to try is a great way of keeping yourself from trying. And it isn't as if 'Pumping Lemma for regular languages' didn't kill my brain when I was in my early 20s... I was just a lot more motivated to dig through material that was tough... 
A few years ago I developed that theory, that we compare each year to the time we have already been alive, so each year feels shorter. With every year I grow older, I believe more in that theory. If it's true, I'm really afraid of my 60s though.. they'll fly by in a minute. 
I would be really interested in this if I was able to write PHP code for Unity. Right now I'm like a monkey fucking a football building a game in C#
We are living in exciting times and change is at hyperspeed, in 20 years times will be even more exciting, I think more of us will be taking classes than thinking of retiring 
&gt;For example, if you are diving by a variable, and by all accounts that variable should never be zero, I'd still check to see if it was zero before dividing. I think in many modern apps, too many people (figuratively speaking) make assumptions that "it won't be a zero" because of language features that may or may not be 100% reliable. Not trying to be rude, but that's nonsense. Nobody does that, except for programmers using languages with very expressive type systems like Ada or functional languages and then those features *are* 100% reliable. On the other hand, not checking the input and running into runtime errors is a typical thing found in dynamically typed code bases (although there are exceptions, obviously).
I'm pretty sure about the "not thinking about retirement" part. At this point I'm just unsure if the cause will be exciting or terrible... ;-)
Oh, didn’t realize that they only did static sites. My bad!
I definitely don't feel I pick things up as fast, but everything is still very learnable at 32. When I learned PHP back in high school it felt like it just took a week. Node took me longer than a week. Could be the environment. 
I'm about to turn 60 in a few weeks and I'm happily employed as a Drupal developer, working remotely from home. I don't really feel my age. I guess I'd be kidding myself to think I learn as quickly as my younger co-workers but I don't think I'm far behind. Maybe I'm just lucky. While I'm definitely "old" in many ways I don't think I am in terms of the technology. I'm really enjoying working with Drupal 8. I feel much more at home with OOP than procedural. For what it's worth, I can recommend the Drupal world. It's pretty much a meritocracy and very diverse. I don't have any hard evidence but I suspect it has less ageism and other prejudices than many other communities / industries. That said, when I was looking for this job last year, I had one employer call me from my StackOverflow profile about a Drupal job. We had a quick impromptu phone interview. He seemed really interested, invited me to do a coding test and promised to get back to me before the end of the week. That time came and went and nothing so I emailed him saying I was ready to do the test and still nothing. I suspect he looked at my LinkedIn profile and figured out my age. I do wonder how long I can keep doing this for. I have good physical health. No doubt eventually my mind is going to slow down and struggle. In general I feel very fortunate that for whatever reason I seem to have some saleable skills at my age. I'm very aware that a lot of people my age are struggling, usually after layoffs.
Maybe they benchmarked against `rm -r ` for folders or something. Did you talk to the developer about it? 
I was his replacement, so he left a week after I started. I didn’t know Node, so I didn’t realize he was doing this until a while later.
In that case maybe node had to be run under a user without privileges to delete the files or some other really weird reason. 
It didn’t, because I tested the speed and then refactored the code when I saw FileSystem was 10 times faster.
TDD &gt; TAD ...but you never get to use pure TDD, unless you end up in a magical place where you get your specs delivered to you wrapped in a neat package.
&gt;preferring recent grads They don't specifically prefer recent grads, just people who don't know any better. If you're wooed by a foozball table, a Keurig and a fridge with coke with some beanbags laying around, you're their prime material.
And he uses PHP and *not* Cobol? Neat! Also, procedural code will be the next big hipster thing. We'll probably have an .io website with a nice bootstrap theme, perhaps even a JS library with hundreds of stars to convert all OO code into procedural code. Bearded, flanneled hipster luberjack-o-grammers will take a sip from their cup o' green tea infusion and shed a tear of joy.
Hey now, do you not want to try the latest framework which may or may not be here in a few months? Eh? Eh?
You missed my point completely. There are tons of environmental and managerial reasons things can happen. Heck, just off the top of my head * If the code he used was inherited * If the company's style guidelines had different rules when the application was written * If the fs module initially being used had worse performance * If the original deployment differed from current deployment (user permissions) all could have been a potential reason to not do things the right way. I am just saying it might not be best to judge a developer just by the code that was left. I have had projects where I was pressured to just get it out the door, or do it a way that another person could understand easier. It happens. 
Mistakes you are going to make that will make it weak: * Poor key derivation * Malleable cipher text * Broken padding * Poor key representation, ie, a hex string Things that won't be relevant to the strength: * AES256 vs AES128 Either the security is a concern or it isn't. If it isn't, the cipher doesn't matter. If it is, the cipher chosen sits down the bottom of the list 
The ability to chain array methods prevents bloat. My 2 examples were both places where PHP causes you to write a lot of bloat to attempt to do simple things. They wouldn't have to remove the old weird global methods, but saying using a modern approach at working with arrays is a disadvantage sounds really odd.
Yeah, I'll never understand why that one failed. It really puts a salty taste in my mouth when the people directing the language are so out of touch. This is a feature all or almost all competitors to PHP have. The addition of type hinting has made this an even worse problem for me recently as anonymous functions can become really bloated now.
Can you tell me your thoughts on this open source php webapp? It’s called civicrm and the code is on github. Like is it a shitty codebase I’m working with 😂 
I use Node.js to make scripts that has nothing to do with the web. Node.js is not limited to the server-side, that is my point. Also, Node.js can be intepreted as many things, and I have the opinion that it also includes a framework since it adds lots of functionalities over the language in a way most other frameworks do. Node.js is not only about making Javascript usable outside the browser, it's much more than that. Now it's your choice to argue about the semantics, but I don't really care. NODE.JS IS NOT A __SERVER-SIDE__ RUNTIME ENVIRONMENT. And saying it is only that, is uterly stupid.
Mmm, you're right. Doing a feature like that in PHP would be harder. I wonder if it would be doable through the DateTimeInterface, although I have no use for that right now. I think that the nearest approach would be to use UTC as a timezone, then you create a new DateTime object using the same date/time information, but with a different TimeZone, although it does feel hackish.
Again you are mistaking JavaScript with Node. JavaScript is supported natively in many environments such as mobile/desktop OS’s, browsers, and many other devices. Those devices do not run Node. Node.js is an open-source, cross-platform JavaScript run-time environment for executing JavaScript code server-side. Seriously, how have you not googled it yet? Node is not a framework. It has nothing to do with semantics. Do me a favor and reply with the definition of Node after you’ve done some research please.
Why?
I don't understand what you mean by "so late". - RHEL-7 was release in 2014 with PHP 5.4 (which was current at that time), with a life cycle of at least 10 years. - PHP 5.6 was available in Apr 2015 a few months after its release - PHP 7.0 was available in Nov 2016 a few months after its release - PHP 7.1 will be available soon, a few months after its release 
Write him a bash script. He will grok bash scripts.
Reminds me of bootstrap v4 :)
One thing I always miss in these articles is how to handle updates to multiple databases. For instance I created an app which saves the events as json to Amazon Kinesis Firehose and it saves the updates to Redis. If one of those would fail the data is inconsistent with the events. I could make it eventual consistent but this app doesn't allow me to as everything needs to be realtime/without lag. Anyone has a good solution for this? One solution I had myself was to store the events in Redis too first (and then move them to Kinesis in a separate process) and then I could use a single pipelined command for it.
You're obviously inexperienced yourself. Event driven architecture definitely helps to decouple your objects, especially when used in conjunction with a DI container.
Thanks for your feedback!
Migrating to Magento 2 is not the easiest process. Magento 2 comes with a completely different architecture and database design. While this Magento estimates a Magento 2 migration is only 20% larger than a Magento 1 upgrade. The amount of time and effort it will take to move to Magento 2 depends on the number of customizations, complexity, and the number of extensions running on the store. I used LitExtension tool to migrate Magento 1 to Magento 2 ,here is the guide : http://blog.litextension.com/migrating-magento-1-x-to-magento-2-0/ Hope this may help !
I am using Firefox 57 and the store allows me to install it, yet I didn't so I can't tell if it really works, but it supposedly does.
ORM is nice?! It has a __call method in a Trait! Think about it. Also, everything that has __callStatic scares me.
You're confusing character encoding with byte streams. XOR is a bitwise operation, not a substitution cipher with a finite list of possibilities that are all mapped to other legitimate UTF8 sequences. 
I would use a queue for that. For example, setup rabbitMq and send the events there. RabbitMq sends an ACK response when it receives successfully, so u can be sure it got the event or you can try again. RabbitMq puts those events in 2 different queues, one for Firehose and another for Redis. Then we need 2 workers, 1 for Firehose and another for Redis, which will read an event from its queue and deliver it to Firehose or Redis. RabbitMq only removes the message from the queue if the worker marks the message as received, so we can either be sure the message was delivered successfully or the worker will try again. Of course, although this is not rocket science it is not trivial to do either. At the company I work we have something similar to this working, also with more fallback cases. I have even been working on open sourcing some of that code, so you can even take a look: https://github.com/Werkspot/message-queue https://github.com/Werkspot/message-bus https://github.com/Werkspot/message-bus-werkspot-message-queue-adapter
Thanks for your reply. This does mean though that the writes to Redis are eventual consistent while they need to be consistent for this app.
Ok let's put an application before each database and have one authoritative event storage. Think of the even storage as a stream of events which can always answer the question: Give me all events since event x. Each application has its local databases and knows the its locally last sucessfully handled event. Then each application would request from the event storage all events since that last local event. If an update fails, request again from the event storage since the last successful handled event. Afaik this idea is described in one of Vernon's books.
I know how it works but this is eventual consistency which won't work for this app as delays would mess up the users experience.
Nope, the coffee-loving dude with a Unix beard is depicted as a hipster who uses Mac with GUI and mouse. #TRIGGERED Hahahaha... 
Haha true :-D
That actually wouldn't work, due to leap seconds and more problems. It's indeed a very interesting question, and needs special attention.
"Why does it matter what the code looks like if it does what we want?!"
Hahaha but he's kind of right, though! Also I'm 36 years old. Here is the now-famous and also really long and really philosophical take on OOP that everyone should try to read once: http://www.smashcompany.com/technology/object-oriented-programming-is-an-expensive-disaster-which-must-end Edit: At my work we have over 50k PHP files in our monolith, which make up several websites, Jenkins jobs, administrative tools, so on and so forth. About 95% of the web code is OOP/MVC, probably 70% of the rest is as well. The problems that we are facing with design at our scale are probably roughly the same as we would have with well-organized procedural code. If you had 10k line procedural scripts before, you'll probably have 10k line domain models, too. We do. Good design takes effort and experience.
Yes it sums it up really well, done a lot of contract work over the past few years so been in lots of different offices and you can see the groups of people listed above. The hipsters make me laugh because they do it in the name of being "unique" yet they all have the same clothes, hairstyles and facial hair and of course will only use Apple products regardless of what the best tool for the job is.
True, I overlooked that criteria. But then the only solution I see is to make direct calls to Firehose and Redis, and check that the requests were handled successfully or try again. If you send the request to both at the same time, it would "remove" eventual consistency (although we always have it, even if for just a few seconds), but if one fails, then we have them out of sync again... So we can send it first to Firehose and then to Redis: After successfully adding the event to Firehose you make the call to Redis, but then if putting the event in Redis fails, you need to either retry or remove the event from Firehose (and hope the removal doesn't fail)... and try everything again... Building an application to be able to handle eventual consistency is much better. Are you really sure you need this kind of aproximately 0 time of eventual consistency system? Have you considered changing your application UI and UX so it can handle eventual consistency?
That is basically what I'm doing in an app that is current live (and has nearly 3 million users) :) I write to Firehose and when that's successful I do the (pipelined) writes to Redis. If that fails I will write another event to Firehose that the previous events for this request failed (identified by a UUID). However in rare cases it could happen that there is a network failure and both Redis and Firehose requests failed which leaves the event store unknown that the events weren't written. Because client liked the events so much (they can query it in Redshift) they want to have a bigger platform which is more extendable. I'm just looking on better ways to do this. Eventual consistency has my personal preference but I'm scared that app users will do an action and it takes too long to update the db to handle subsequent requests. Thanks for your input!
Distributed transactions are not trivial. Maybe think if immediate consistency is truly required. It's often a "nice to have" and not a "need to have" if you take a step back and reassess.
Looks like we're not getting an answer.
Badoo is using their in-house developed service [Pinba](http://pinba.org), to monitor and profile their thousands of servers without an overhead. That's quite smart a solution in many ways, created by tony2001, one of PHP core developers. It is Open Source, all you need is enough infrastructure to deploy and some your own ideas on what you want to monitor. If you want a more out-of-the-box solution, it could be blackfire.io or newRelic 
Maybe u read this already, but Udi Dahan has a really good post about CQRS where he also talks a lot about how to shift the application design so that it is adjusted to eventual consistency: http://udidahan.com/2009/12/09/clarified-cqrs/ It's mostly about managing users expectations, things like instead of saying "Your data has been updated" say something like "We received your request and we will update your data as soon as possible". Nevertheless, I think there will always be some stuff that will need immediately updated, ie without using eventual consistency mechanisms. Anyway, great to know your thoughts and good luck.
I did not care for this video. Didn't like it. Fine people, nice voice-over, couldn't get into it. It *insists* upon itself, guys. [It *insists* upon itself](https://www.youtube.com/watch?v=4wMQz3iJDzE).
Its just funny reflection and maybe somebody can recognize oneself in it
Please don't ever link to that shitty site. It's a disgrace to this community
Well, if you can't accept eventual consistency, enter the world of [distributed transactions](https://en.wikipedia.org/wiki/Distributed_transaction). Enjoy!
&gt;I can't change it but I can change it This is how I know not to bother reading your article.
As one that's easy to setup and because I'm not paying the bill... NewRelic is my choice. I also make use off cloudwatch but for really digging into transactions and finding out where performance issues are NewRelic has really helped. If you've not tried it you can get it free for a few weeks with all features, after that you can get a reduced set for free. Things I like: - easy to setup - plugins to added monitoring of many other things not "in the box" - event based alerts - integration into slack/email/whatever - drilling down into transactions to find out where time is spent - slow query monitoring - knowing what time is spent on external service calls (e.g APIs) 
No. Why not do this?: $score.= " &lt;tr class='text'&gt; &lt;p&gt;&lt;th&gt; " . $plads . " &lt;/th&gt;&lt;th&gt;" . $k_row['skoler'] . " &lt;/th&gt; &lt;th&gt;" . $k_row['klasser'] . "&lt;/th&gt; &lt;th&gt;" . $row['sum_score'] . "&lt;/th&gt;&lt;th&gt;&lt;div class='tooltip'&gt;" . $row['Count(klasse_id)'] . "/4" . "&lt;span class='tooltiptext'&gt;"; while($rowPoster = mysqli_fetch_assoc($resultPoster) { $score.= $rowPoster['stationnavn'] } $score.= "&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;&lt;/p&gt;&lt;/tr&gt;";
Will read, thanks. In a gaming environment a "we received your request" doesn't really work, especially when it needs to be (near) realtime but I understand what you're saying.
I just leave it enabled at all times and only listen to the incoming connection in PHPStorm whenever I need to debug something. The performance hit is not really noticeable for me on my virtual machine. &gt; Am I doing something wrong? From what you said it sounds like you might use xdebug on a production server ? if that's the case then yes you're doing something wrong (you probably shouldn't even have the extension installed on your production servers). If it's on your local environment or staging server you're fine, just do what's more practical for you.
If you are looking to track data about what happoning on your server (cpu usage, memory usage, netwerk usage, etc) monit is a fine options https://github.com/arnaudsj/monit. This is free. If you want more in depth information when applications throw exceptions something like Sentry(https://sentry.io) might be for you. They have a free self hosted option or a payed cloud based option.
when u call $score. = are u not overwriting the previous statements ? or are u manking a longer string ? 
1. https://pasteboard.co/GMK7VJ2.png 2. No, you cannot add a while loop to a *string concatenation operator* (which you had a fancy to call "a variable"). 
&gt; Personally I would hire him without an interview. That's how I know not to work for your company: because *team fit* isn't a consideration for their hiring manager.
rip im out then ^^ 
http://php.net/manual/en/language.operators.string.php Reading the manual helps :)
hmmmm. so the "." just adds to the string. ty fam :) 
We already have server-level monitoring (through a combination of several solutions - and I have a sysadmin who looks after this side of things) and error logging (via Sentry - which I recommend - we used to do this by emailing individual errors which works OK for smaller projects but it would basically take out our devmail server during "error stampedes" on larger ones). (As well as DB monitoring with Percona Monitoring &amp; Management which I also recommend) What I'm looking for is "code level" monitoring to help me find bottlenecks in the application without having to add instrumentation / logging to individual requests / processes / code paths in the code. I have a number of requests / code paths I already know need investigation, but it would also be nice to have potential / suspect code paths / requests hilighted for me in a similar way to PMM showing me the queries that are taking up the most DB server time.
take a look at how pyrocms maintains modularity around composer packages. It has a base platform (streams-platform) and modules, themes, field_types on top of it
We also use PMM. We found a few interesting thing with that, definitely a recommendation for PMM. For code level bottlenecks its probably a good idea to have a look at blackfire (https://blackfire.io/). You tell it when te monitor a request (using a browser plugin) and will give you useful information about what happons and where possible bottlenecks are located. 
Haha!! Yes, in that context it wouldn't really work... 😂
Let's reinvent the wheel and post about it on Reddit.
&gt;I don't want to learn how to use a debugger This is how retarded you're being.
I mean, I worked there, and I know the environment. I can assure you none of that is true. While there was some bad legacy code, I know what he wrote. It was a small shop of 6 developers and only 1 javascript developer. Since the inception of the company, there had only been 4 js developers, and he was the third. The first was the js dev for 9 years. His code was amazing. The second barely did any work at all, and the third was that guy. The fourth was me. He wrote bad code. There's no way around it. He once passed a callback through 14 functions. His average was around 4 functions per callback, because he didn't know how to do async code the right way, so he just did what he knew how to do instead of learning to do it the right way.
Testing out NewRelic for one of our servers here, it's awesome! We've found enough bottlenecks and performance issues that sped up our application from 800~1000ms/request to 100~200ms/request
Strange, because when I thing of old programmers, they are at leats 70 ... Must be my old age (53). I always believe that age has nothing to do with your capabilities, when it comes to using your braincells. I've seen smart "youngsters", and smart "oldies". I would preferably hire a wise person, not for the age, but for the wisdom. If you only look at age to define a person, it tells more about you than it does about the persons you want to hire. Sidenote: I've heard that vintage is quite hot these days ;-)
Is the pricing any better? The last time I tried EB with PHP 5 and a database, the bill was $40-50 a month... the same setup on Google App Engine was $10.
"It doesn't do these very specific tasks, therefore it's lousy". Really?
RHEL is big on **long** term support.
Actually when I started the project, there was just none working as a webext, and I have been forced to develop it because I needed it. I just posted it here so people can test if they wish too.
how else will you learn how to say double colon in hebrew?
"There are only two kinds of languages: the ones people complain about and the ones nobody uses." - Bjarne Stroustrup
That's an example — PHP is lacking everywhere. From Unicode to timezones, native IO to SQL.
Ahh, so this post was recommended to me by the Reddit app, so full disclosure—I’m a Java developer. I think it’s a little over-the-top to suggest that no one likes or chooses Java. Sure, we are all taught it in University, and it feels like a second language to me. But I generally like coding in it. When I want go get something done fast and correct, believe it or not, Java’s my first choice because it’s adept at that. C# would likely be as good of a choice if I was fluent there. If I want just fast, I’ll go with Python.
&gt; Nobody does that This is why we have vulnerabilities and patches in software. 
There are many ways to solve problems. I would submit not only are there more efficient ways to accomplish things without OOP, including avoiding the need of certain array functions in the first place. 
Yeah I've had similar experiences. Managed to really improve performance from it
&gt; Yes it sums it up really well Yup, can confirm also. I have a desk, I use computer, and I drink things throughout the day. Very accurate portrayal.
I'm really not sure, I don't see the bill. You'd have to check out their pricing and compare. I'd make sure to look into on-demand pricing and per-second billing if you were using a reserved host before. That might help. 
It's okay I remember my first pube as well, I understand it's a difficult time.
It depends on What youre doing. So like, that setup is actually 3 different servers. EB sets up an instance for the web server, it also sets up an instance for the load balancer. And RDS sets up the database. Each of those is like 10-15 bucks per using the smallest options. Now of course you could just set up a, EC2 nano instance for 5 or 6 bucks a month and install all your stuff on it if you wanted to.
You are lucky, we have a multi stage hiring process and I'm just filtering the CV-s and evaluating the test tasks from a professional standpoint, so no one gets hired based on my sole opinion. :-) Back to the personal part: most of the genius developers are not team players, if you want a great product, you need such people who are the best in their area. It is already hard to find a senior developer, but if you only look for senior + team fit + best person ever, you won't hire anyone, it has a better chance to have diamonds float out of your shower.
Yeah, but the whole point is auto-scaling.
You can have load balancer + server + database for $10 on Google App Engine?
Yes, and ~$5 if you use the lowest tiers. If you have a traffic spike and start getting millions of hits, it scales automatically, but you'll have to pay extra for all the new front-ends that get spun up. The front-end instances are pretty cheap. The DB is the most expensive piece. 
So you're the kind who starts talking about his pubes in the middle of an unrelated conversation.
Worst spam in Spamton 
Awegges law: Any post title enumerating things are a waste of time. 
Now they just need PHP 7+ for AWS Lambda
Maybe that person is afraid that they will not be busy... 
Too close to lunch time for all this spam. 
Thanks for mentioning!
I'd like to disclaimer what I'm about to say with, this is not a thing I support it's a description of the climate I perceive around me. The major reason that it's harder to get a job as an older developer is that the traditional career path is to move away from development and into management as you age. If you haven't done that it raises questions as to why. The secondary reason is that as you get older you generally become more cynical. My ex-boss, who I regularly had arguments with about this subject was very suspicious of database migrations and automated deployment. This does not mean I believe that he would be incapable of understanding the benefits but there was a noticeable inertia that I did not experience with my peers. Even if your are the most open and trendy developer in the world, your age will carry the weight of the experience of other developers, it's a human thing to do, to generalise. The best you can hope to do is to prove yourself the exception, or move away from the front lines.
I don't have gold sir, but I will be saving this comment. It has helped me better understand the politics at my shop.
U wot People relying on their type systems are definitely not the reason for that. Type systems don't eliminate every error though and I've never claimed that. He have vulnerabilities *despite* type systems, not because of them and programmers relying on them. Trying to be rude now: Stop talking nonsense.
I do it for one of my apps. I have a bunch of legacy SQL DBs with my user base among other things I can't change or migrate off of. I have an SPA which is a huge Gantt based project management tool where the data is deeply nested. I created the nested data schema in MongoDB that my Gantt requires, which is great because it's single query to load the view...works a treat.
We have been working on a PHP Application Performance Monitoring solution called Tideways (www.tideways.io) for 2 1/2 years now. It has Profiling, Monitoring and Exception Tracking functionality, but it focuses solely on application monitoring and does not provide server monitoring. I am obviously biased, so I wouldn't want to comment on pros/cons with competition. Pricing is based on per project (not servers) and plans vary in retention days, number of traces and features. Customers monitor between 1 and 40 servers per project with it.
Interesting. For me it's a lot slower. Every page view is several seconds slower :| No, it's not on in production. I just toggle it inside the docker container
Yes, PHP seems like a natural fit for a function as a service 
How does the DB scale automatically?
That gets a little trickier, and depends on how your app uses the DB. If you aren't using a healthy dose of caching throughout the site, the DB isn't going to scale no matter how much RAM and pipe you feed to it. Generally, you'll get an alert, and can bump the DB tier if you need to.
that sounds reasonable. Mongo is a document store, after all. JSON format your logs and store them in Mongo so they can be searched/queried more easily. Good use case. If you have budget to pay for this as a service though, you might be interested in [paper trail](https://papertrailapp.com/) which gives you similar functionality.
Why? Just use MySQL for everything.
I hear in a lot of cases that MongoDB is way faster then MySQL. The tables will be bigger then 10GB. 
Of course I am confused. But is there anyway to do what I am trying to do?
oh my god, thank you so much for informing me of `&lt;input type="text"&gt;` I would have never known otherwise! Previously I'd been forcing my users to enter input entirely through javascript prompts and AJAX. This is *revolutionary*
&gt;I'm only 30 Me too, however here Companies are hiring people under 26 so I don't consider my self young, as I don't anyways... I Can program only 4 hours by day, maybe more on weekends... when I had 24 I code like 8 hours by day... my cock was harder too 
Quantity of data is meaningless. Any RDBMS is good for 100+ Terabytes. MongoDB isn't magically faster.
Now just give us the option of nginx...
Web development really is a fast paced industry, you learn something new everyday!
It is right. You need both tests like /u/tie_salter suggested with mocks and other things and integration tests to make sure your SQL is actually correct. Use SQLite as your database backend for tests unless you're using vendor-specific features.
I love NewRelic. My only problem is their price... 
Do you just want nginx in the dropdown or what? I used nginx on EB a few years ago... pretty sure it was just adding an .ebextensions directory in the app's .zip file, then putting in commands for "yum -y install nginx", "service httpd stop", "service nginx restart", copy the SSL certs into the nginx directory... and that's basically it.
It's because xdebug have its execution hooks active even if no debug or profiling session is triggered. The overhead can be significant especially if: - your run a recent PHP version (7+) - your script is mostly CPU bound
Or you could run docker with whatever PHP version you like. As in, this is still nice. But if someone wants to be on the cutting edge, use docker.
And password.between that and the subtle background music and colors, I think I just mentally graduated to senior dev
In all seriousness though, I can't wait for date and time fields to be a thing. Bootstrap date/timepicker begone.and although they weren't featured in the video, I'd like to imagine pastel pink and blue chosen for those 2 as they're sweet like cotton candy, and that shits always pink and blue
Thanks, I thought this was useful :)
No
Also the refuse to do any relational stuff, since you know, data has no relations to other data... 
I think it will largely depend on how you are using the data and what it looks like. Is your data highly structured or unstructured? Do you care more about availability or accuracy? Do you need ACID support? If you're dealing with any sort of financial or inventory management type application, I'd definitely stick with a SQL database. If you're dealing with less critical info such as customer/user info, logs, analytics, etc, then a NoSQL database would probably be better. Here's a video on the topic by Martin Fowler: https://www.youtube.com/watch?v=qI_g07C_Q5I&amp;feature=youtu.be&amp;t=44m42s I think this article provides some good examples: https://www.sitepoint.com/sql-vs-nosql-choose/ There's also the issue to consider of "not over-optimizing" your app before it's needed. Most software related endeavors fail for reasons other than not being able to scale. Successful software products will usually end up re-evaluting their tech stack later down the road - trying to get everything 100% optimal to start can be getting the cart before the horse. Depending on your situation, it may be advisable to just stick with the technology you are most comfortable with. 
Use git submodules or separate repos that are ignored from the parent application for development. That gives you separate repos for all modules and the main app as well as a rudimentary deployment mechanism. You could, if needed, custom build a simple deployment script into the parent app that just grabs the latest dist from your repo for a given module. Good luck!
You are also not constrained in available versions when you use docker
Did you look at other technical solutions other than MySQL or Mongo? &gt; bulk data Not sure what this means, but possibly stream it with Amazon Kinesis/Firehose to process later. &gt; logs What about a hosted ELK stack solution? logit.io or logz.io &gt; stats What type of stats? Possibly put it into Amazon Redshift. aws.amazon.com/redshift/ The types of data you have matter more than size. We have TB's of data in RDS (Amazon hosted MySQL) and the queries are quick. But you should pick the best solution for the job.
Might want to take a look at the soon to be released Symfony Flex platform. http://fabien.potencier.org/symfony4-compose-applications.html Turns out that composer was initially designed for installing application modules.
So do I just need to change the box name in my config.yml and do an eb deploy to upgrade? Or is there other things to do to get the upgrade flowing?
Bummer with being Mongo only is that's now a requirement that's not often installed in many client environments, so it keeps me from even considering this.
If you have unstructured data with little to no relations to other data, use Mongo. If you have structured data and relationships to other data use SQL. However, be aware, running Mongo in production is a pain in the ass. It's super easy to start to develop against but once you move it into production and you need to look after your cluster, be prepared to spend a considerable amount of time to learn the inside outs of Mongo. Edit: Oh, don't use Mongo as your primary database. Ever. 
Don’t use Mongo only to use Mongo. Been there, done that. If you data is relational use a relational database. Remember that Mongo is a document store, primarily meant to fetxh a document bij it’s identifier. Extra indices are a tat more difficult than with relational databases. Most relational databases, like MySQL and PostgreSQL, also offer json functionality. Long story short; Mongo next to MySQL may sound cool, but you will need to maintain and monitor two databases. For logging enough dedicated solutions like Sentry or Splunk are available. If you wish to create a search index consider something like ElasticSearch. All these arguments lead the company I worked to move away from Mongo next to MySQL.
You don't have to necessarily be doing OOP to want to chain array methods. You mostly just have to be working with and manipulating data sets.
I have no trouble with older developers. I would love to hire them. BUT! My experience with older applicants is that their knowledge level is on average lower than that of younger applicants. I can only guess why, but in my experience the older applicants at this moment lack the appropiate education. The older developers that *are* properly educated as developers usually don’t seek employ in web development but stick with Java, .Net or the more archaïc languages like Delphi, Pascal, C and Cobol. I see exactly that at my current employer; the older (35+) developers are usually not in the php teams, but rather in the Delphi and .Net teams.
I'm not a security expert. I'd be interested to see some of these questions answered in the readme: * Why would I use your lib over the one written by /u/ircmaxell ? * Why are these changes necessary? * If these changes are necessary, why not feed them back into Anthony's project - why the decision to fork? 
At 51, I would have to say that it's just that guy (OK and probably SOME others), as one of the other posters says that sometimes keeping things simple is better. Would you write a Laravel app to say 'Hello world'? Also would you write a monolithic script for any business app. It's a case of being open minded to the best solution - OO isn's always the best solution.
@RichardFuchs I could pull the image, but I'd rather have the Dockerfile, which is nowhere to be found
So how does DBUnit fit into PHPUnit? I thought that did a bit more than touch the database?
For anyone running into this, I am using: RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - \ &amp;&amp; sh -c 'echo "deb http://dl.google.com/linux/chrome/deb/ stable main" &gt;&gt; /etc/apt/sources.list.d/google.list' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y google-chrome-unstable And: google-chrome-unstable --disable-gpu --headless --remote-debugging-address=0.0.0.0 --remote-debugging-port=9222 --no-sandbox Works so far :)
&gt; If these changes are necessary, why not feed them back into Anthony's project - why the decision to fork? [lack of activity](https://github.com/ircmaxell/RandomLib/issues/5)
Yeah, I did it using php-fpm reload instead of restart as explained on this link https://stackoverflow.com/questions/16890855/can-we-reload-one-of-the-php-fpm-pool-without-disturbing-others
&gt; All the bulk data, logs, stats will be stored in MongoDB. How many data? What you will do with it? &gt; What do you think of this? Only in case if you could verify that databases are in sync with each other (in case of any related data) and you have a single source of truth in order to fix data (or this will be just two separate storages which doesn't intersect in any way) - then everything will be fine.
You can build your own base image for EB ;)
Hehe &gt; [Seriously, HHVM, I have no idea why you're being weird. Stop it.](https://github.com/paragonie/RandomLib/commit/8d1856b7ecf3974211d120a64d166c90d389f0cb)
10+ GB in some tables. 1 or 2 way more
10GB tables are nothing for MySQL or any other decent RDBS to handle. They can happily handle orders of magnitude more, easily into the terabytes. MongoDB will not magically give you a performance benefit, certainly not at that scale and depending on the data itself may be substantially worse. If your data has any kind of relationships you should probably be using an RDBS unless you have a good reason not to and you understand the drawbacks of using a non-relational system.
It's like a buzzfeed quiz, but with more ads. 
also since mysql supports jsonb, I don't really see any reasons to use mongodb.
&gt; Why are these changes necessary? * Anthony's version emits warnings on PHP 7.1 because of the mcrypt deprecation. * Anthony's included `/dev/random` as a "high strength" source when, really, no userland application code should use it. Instead: `getrandom(2)` or [`/dev/urandom` should be used](https://www.2uo.de/myths-about-urandom/). * Anthony's version considered OpenSSL a high security mixer, but as a userspace PRNG, it's at most medium-strength. This was likely a legacy decision he didn't want to break BC for. If you want a high strength secret and you want it reasonably fast, use version 2, which uses `random_bytes()` (or the random_compat polyfill). &gt; If these changes are necessary, why not feed them back into Anthony's project - why the decision to fork? I've been trying to contact Anthony Ferrara for months, to no avail. This is observable on Twitter. 1. [My messages to Anthony](https://twitter.com/search?q=from%3Aciphpercoder%20to%3Aircmaxell&amp;src=typd). 2. [Anthon's messages to me](https://twitter.com/search?q=from%3Aircmaxell%20to%3Aciphpercoder&amp;src=typd). I've also tried email, IRC, and Reddit. Apparently, despite total radio silence for months and near-silence for over a year, he wanted folks to just send a pull request. I explained previously why [that's a bad expectation given the context](https://twitter.com/CiPHPerCoder/status/916450721062670336). As I mentioned [here](https://github.com/ircmaxell/RandomLib/issues/55#issuecomment-334856487), upon learning that Ramsey had write/merge access (a fact that isn't exactly documented anywhere as far as I can tell), I'm willing to create a branch that undoes the BC breaks and send a PR to his library to solve the annoyances. Anyway, these communication failures aren't really worth noting in the readme, since they could end up getting ironed out in the future. Ball's not in my court though.
I'm not sure where you'd get the idea that I have more talent than anyone else with programming or security work, but I assure you, that's not true. I do not like dicking around though.
You're not giving us nearly enough information to think anything. You need to figure out your APIs first, then when you have them, you can start making decisions where you'd put boundaries between services (i.e. one service can handle one API, or several related APIs etc.), and how each service would store its state. I've been forced to use MongoDB on an inherited project, so I have some experience with it, but I've seen absolutely no situation where my explicit choice would be "oh I know, let's use MongoDB". Unless you need to work at large scale it likely also doesn't matter to you performance-wise whether you use MySQL or MongoDB, but again... you haven't told us nearly enough for us to start making recommendations and conclusions.
I thought a PRNG was either a CSPRNG or not. If it's the latter, then getting X bits from the PRNG really nets X bits of entropy at a rate of one bit of entropy per one bit out output. So, this notion of having different "strengths" doesn't make sense to me. Why use this (or what it's forked from) instead of `random_bytes`?
Agreed, and the same applies to PostgreSQL.
Some sources provide a maximum of 32 bits of entropy, but if you combine enough disparate sources together with a secure mixing function, you can achieve higher. Low entropy + Low entropy &gt;= Low entropy, but only if the sources are actually disparate. When one or more of the sources is a CSPRNG, you can safely say you're at medium. When one of the sources is the *kernel* CSPRNG (read: Not OpenSSL), you have a high strength output. (You'd have a high strength output even without mixing other sources in, with the kernel CSPRNG.) More practically: Developers really don't need to worry about this. Just use the high-strength generator in v2. It's fast enough and always produces secure output.
If you have a good caching layer in front, such as memcache, speed is less important, since for high traffic situations you should not be hitting your DB directly every time. Even if it is mongo
It turns out the stack trace was a lie, and it wasn't doing something weird with sodium_compat's internals. https://travis-ci.org/paragonie/RandomLib/jobs/284452047#L718
&gt; How many data? Three. 😁
That's exactly what I'm doing. I'm expecting the interview to be like a blind date. They've heard great things about me and what I can do but then they see me in person. And I'm old.
yeh, and answers out of order... &gt; * All of the above &gt; * A Correct answer &gt; * A Correct answer &gt; * A Correct answer or &gt; * A Correct answer &gt; * Both of above &gt; * A Correct answer &gt; * None of the above wtf!?
Try $_SERVER['HTTP_X_FORWARDED_FOR']
Which proxy does it bring up? If you are using Cloudflare, then that variable will be the Cloudflare proxy IP, however they send additional headers to provide the original client IP. Apache's mod_cloudflare can make these accessible to the PHP process.
 - have you still got anything that looks like HHVM issue here, especially with the sodium extension? If so, could you file issues? I've not got a huge amount of time for another week or two, but I worked on the sodium extension and should be able to fix things fairly quickly - are you testing on something other than Travis? If not, please let me know/file an issue if you're still seeing something that indicates that those is_callable checks you're doing are passing: - Travis is running HHVM 3.18 - HHVM didn't have a sodium extension until 3.20, so 3.18 should have none of those functions defined - possibly relevant: HHVM 3.20 matches an early-this-year PECL version of the extension. 3.21 and 3.22 are meant to be compatible with what's actually in PHP 7.2
Also, you can store multiple IPs in `HTTP_X_FORWARDED_FOR` with multiple proxies. If you're using HttpFoundation the request object will abstract all this away for you in `getClientIp`
For the uninitiated, a lot of proxy services set a header telling you what the actual user IP was. A common one is X-Forwarded-For. This retrieves that header.
I usually use this with fallbacks to **REMOTE_ADDR**, then **HTTP_CLIENT_IP** as the last resort. Though perhaps using PHP session might be a better way of preventing duplicate votes. Can anyone chime in on that?
Couple years older than you, and yes the "self taught" web was the only way to do it. I was in college when HTML was launching. College didn't teach it yet. You had to want to learn it.
Having been a professional PHP developer for five-ish years, I disagree - we regularly had bugs that wouldn't've happened in other languages, and had to build lots of strong conventions and tooling to prevent them, especially for new developers (we hired a lot of students). Just combining error and exception handling and making it so you can *reliably* set a custom error handler would've done wonders.
I would be surprised if half the people on my team got a 100% on this quiz. I don't remember the last time someone accessed the $REQUEST global or defined constants with the define() function. Plus knowing the return arguments of array functions, I'll leave that to my IDE to remind me. What a terrible quiz that promotes antiquated PHP.
[Link for the lazy](https://github.com/symfony/symfony/blob/d3f372171597eb8a56b085e23e300ac559d5904c/src/Symfony/Component/HttpFoundation/Request.php#L751-L773)
http://media.giphy.com/media/bg4pMH02w4Tx6/giphy.gif
I don't know if it counts as an HHVM issue, but it seems to be an inconsistency with closures. This fixed the error: https://github.com/paragonie/RandomLib/blob/b73a1cb8eae7a346824ccee42298046dedbf2415/lib/RandomLib/AbstractMixer.php#L157-L159 EDIT: I'd wager that Travis is definitely implicated here. The stack trace confused me greatly.
Also worth to mention HTTP_X_FORWARDED_FOR can be spoofed
Not sure what that module is for. Cloudflare forwards you the real client IP which you can get in $_SERVER['HTTP_CF_CONNECTING_IP']
Composer would be cool.. It is also easy to right a simple autoloader to traverse a directoy of plugins if you copy x amount of them in there. Benefit of Composer is if you write to standards you could potentially release modules externally for all. 
Ajax isn't what you want. You want websockets. If you were to do it with ajax, you'd need to poll the server on an interval, which would create massive unneeded load to your server. This is what you want: http://socketo.me/
* IP addresses are not stable (for phones) * IP addresses may be shared (think: multiple computers in a house or in a corporate network) * Cookies (sessions) might be be deleted. If you're making some kind of public voting mechanism, then the best thing you can do is not worry too much about people voting multiple times. It really depends on the use-case what a good solution might be.
Thank you. Does it work with php 5.6?
 , "require": { "php": "&gt;=5.4.2" https://github.com/ratchetphp/Ratchet/blob/master/composer.json
Yep. If you're not using a proxy, you'll want to make your server strip this out.
Thank you
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ratchetphp/Ratchet/.../**composer.json** (master → c03b1b0)](https://github.com/ratchetphp/Ratchet/blob/c03b1b0f56d1732a4bffcdbef5eae444f8c9e73b/composer.json) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply do1jbsf.)^.
[Sockets.io](https://socket.io/) is probably your best and easiest solution for a chat in a PHP game. Don't solely use PHP or Ajax for a chat, it will cause more issues than it's worth. https://socket.io/
It really depends on the context of what you are doing and what the application is. From what I can take from your vague thread, I think MariaDB would probably be a better option for you. https://mariadb.org/
The specs aren’t decided yet. But i wantend some opinions and insights before hand. Thank you i will look into t
PM me information and I'll see if I can help.
Here is some additional help: https://socket.io/get-started/chat/ https://socket.io/demos/chat/
Here are a list of PHP Projects that are looking for help: https://github.com/search?l=PHP&amp;q=label%3Ahacktoberfest+state%3Aopen+type%3Aissue&amp;type=Issues
Ok i dont have have node.js installed. I can install it but I have a principiant question: currently the game is running on apache that listen on port 80. I would need to run also a node server on another port and when players go to the specific page the node server will make the chat work?
*when players go to the specific page* What do you mean?
A free tea would be better!
I want the same thing but open source
A player is in a game page like this: https://imgur.com/gallery/od40M and then clicks the link 'chat'.
[The Community Engineering team are doing something similar at Magento.](https://magento.com/blog/technical/are-you-ready-magento-squashtoberfest)
Why is that?
I don't understand, why is this different than PHP? Are you saying for Node its keeping a process running ready to respond? Why couldn't this be done for PHP?
Yes, it's pretty self-explanatory. Just have the chat page connected to the node server.
Interesting. Would you be willing to elaborate further in a blog post? I'm sure I'm not alone in being curious about the ins and outs of this.
Sure, except I have a backlog of posts I've been meaning to write already. Writer's block kind of sucks. Luckily my business partners are cool with me taking months off writing at a time if I need to.
Ah, I couldn't remember if it was needed for PHP, the module changes the Apache logs to use the correct client IP instead of the CF proxy IP.
i didn't get my t last year :( i blame USPS
I'm dealing with this as well these days. I decided to use the Doctrine, since I'm kinda used to it, and I've got a load balancer (written with ReactPHP as well) with multiple workers behind. I've done some benchmarks for my scenario and handled about a thousand of requests per second on a single core VPS. I belive that better results can be achieved by running multiple balancers with Nginx in front of them, or running many workers directly without the ReactPHP balancer. Thing is that PHP TCP server, even when doing nothing (or just sending empty 200 responses or proxying requests async), can serve much less RPS than Nginx, on my specific hardware it was ~2k vs ~5k, so the maximum performance is, no suprise, limited by the balancer. This is of course still way faster than any other ISAPI around (FastCGI, Apache, you name it) and there is no resource draining caused by bootstrapping - talking about Doctrine, it's pretty damn fast once loaded and I don't even need to generate proxies to some cache (it's in memory). If the performance is your concern, you'd better use something else than PHP. I've fallen in love with .NET core, which is fully asynchronous (not to mention concurrent). But you probably got your reasons to stick with PHP (so did I). Unfortunately, PHP was never meant to be asynchronous, I doubt we will ever see native database drivers async support, not to mention async/await keyword. There is also buggy stream_select() support for Windows.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
"this one old guy" != "the 50+ crowd" That sort of inability to think logically or critically is what bothers me most about the "20-35 crowed" (sarcasm intended)
A couple of generalizations: 1) That 50 year old guy stuck in his own 20 year old procedural code - he was the same way when he was 25, and some of you will be him in 25 years. It's a mindset, not an age. Some people find a comfortable niche and just sit in it for life, regardless of what job they are doing. Not everyone is interested in computer science, per se - they have an engineering-style way of thinking, and so computers earn them a nice living where they can go home at 5pm and do what they care about more. 2) Older programmers are not negative about the new frameworks and techs - they find them just as interesting as anyone else. They are more likely, I think, to build a small side project to see if what is new is actually interesting ideas they might make use of, or just shiny bells and whistles. They don't tend to be as fascinated with magic methods and things that let them type less characters. 3) This is across ages, but I find older programmers will feel the day was much more satisfying if they created some interesting code or solved an interesting problem than if they "hammered out a bunch of new features". This kind of goes hand in hand with our failure to be impressed with long hours. To close, i can't iterate enough the top poster's comments on bosses who abuse younger devs to get rich. This is a job - go do volunteer work for an OSS or a charity for another 20hrs a week if you still have the itch at the end of the week.
The stat cache can die in a fire for how easy it makes someone who doesn't realize there is a stat cache (or someone that just temporarily forgets that `is_file` doesn't check if something's a file, it checks for a cache hit without any consideration of cache invalidation then checks if it's a file) to write code that can fuck up in a really obnoxious, hard to track down way since *technically* it's not an error for `is_file` to return invalid data if the file state of something has changed between the cache entry and the next call and since you have to specifically remember the stat cache is there to notice the issue.
&gt; I use Node.js to make scripts that has nothing to do with the web. Node.js is not limited to the server-side, that is my point. PHP was specifically made for website backends, yet the PHP interpreter/runtime/whatever you want to call it can still be used for other things. So too with node.js - it was made to run web backends specifically even if it can be used in other ways.
Just use SQL. If you have some time to learn something better for a new project, then now's a good time to switch to postgres. I wish I'd done it sooner. 
[@betaorbust's latest tweet](https://i.imgur.com/Egstx1e.jpg) [@betaorbust on Twitter](https://twitter.com/betaorbust) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Node.js was not made to run web backends specifically. It allowed other libraries to be Web-centric libraries. The only goal of Node.js was to bring Javascript to the bare machines. The proof of that is that you need to use HTTP handler libraries/routing libraries in order to have a web server, whilst you don't need such things for PHP. (basically, you need to use the same methods as any other languages to bring your code to the web [such as Python, C++, etc.])
https://nodejs.org/en/about/ &gt; As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications... HTTP is a first class citizen in Node, designed with streaming and low latency in mind. This makes Node well suited for the foundation of a web library or framework. Even the node.js website trying to say it's for 'network applications' still can't help but provide an example with HTTP, and specifically mention HTTP but not any other network protocol. Node has HTTP out of the box, but not most (any?) other major protocols. Not LDAP, for example, or MQTT - those are relegated to packages, but HTTP is built right in. This together with the fact it was intially designed specifically to address issues relating to web backends and web servers means it's pretty clear node.js was mainly made for, still largely targets, and of course de facto is mostly used for web backends. &gt; The proof of that is that you need to use HTTP handler libraries/routing libraries in order to have a web server, whilst you don't need such things for PHP. You get just about as much out of node.js as you do in PHP, hence why both node and PHP have frameworks. Just check that /about link above: their example for creating an HTTP endpoint works without any extensions or third party packages outside of standard node.js - that includes the `http` implementation.
&gt; It's one process handling all the requests, unlike PHP which is a new process for each request. You should take the time to learn how PHP actually works before you try explaining things. The processing model depends entirely on which SAPI is being used. Most web-server setups are either using Apache's mod_php (which embeds a PHP process inside each Apache process via the embed SAPI) or a server like nginx/lighttpd talking to php-fpm (which runs numerous persistent PHP processes that communicate via the fpm-fcgi SAPI). While you will often see Node setups that run it directly from the command line as a single process (since it's event-based IO and passes off most IO to c++ threads managed by libuv, it has great performance) but this simply never happens when using PHP as a backend. In the realm of PHP, you simply use multiple fork()'d processes, which while are indeed synchronous processing independently, they are relatively lightweight due to the nature of process forking (which you'll notice is precisely how node.cluster operates: multiple forked processes)
This is great, been looking for an alternative to PhantomJS. Can you point me in the right direction - how do I get the html of the entire page once fetched? After I do $page= $mink-&gt;getSession('chrome')-&gt;visit($url); I can verify that the session fetches the page, but then I've tried to getOuterHtml(); on the page, etc, but can't find the right syntax...and very limited documentation. Any help would be great!
Isn't it just how PHP FPM works? It keeps x processes alive and reuses them?
nvm, figured it out finally, but here it is for anyone searching: $mink-&gt;getSession('chrome')-&gt;visit($url); $page = $mink-&gt;getSession('chrome')-&gt;getPage(); $html = $page-&gt;getContent();
I'm 26 years old, a software engineer who spends most of his time building things for the web. I noticed most older developers take what they've learned in school or on the job and just rely on that, i.e cold fusion and other outdated languages/methods. How good a developer is really depends on how much work they spend on continuing to learn. When I built my first website I thought I knew everything then I realized I still have a lot to learn and now I'm at the point where I realize I know nothing. While I'm sure there are many talented older engineers/developers who have kept up to date and continued to learn I do feel the bulk of them just stick to what they know mainly because life takes over and unless you're willing to sacrifice your personal life it's very hard to stay up to date. That's just my opinion, most developers build their skillset from 20-30 and then profit off it from 30-65 and live a balanced life.
I've said this to clients countless times - *You don't need everything under admin/CMS control*. They want every header, link, text block, image etc to be manageable. Some of them listen. The others ask half way through the development why the interface is so complex. It's possible to e.g. limit character count on a heading input box but that's even more unnecessary admin/development overhead.
if (is_spaghetti_code) { goto Hell; }
[high five]
Why does PHP has no module system like python or JavaScript ? With the import/export thing. I mean there is class autoloading and namespaces but it does not offers the power of a true module system. Is it something planned for a futur version of PHP, even at long term ? Is it implementable in any way with the existing tools ? I ask this because I have the felling that this kind if feature could be a langage level replacement of all the service containers implementations found in symfony/zend/laravel... Am I even right on this point ? Thanks you all :)
He does have a point. ( from me and literally)
Can just any project add the Hacktoberfest tag to any open issue they have? Or do the projects / issues have to be pre-approved?
If you are worried about race conditions (and you probably should), then you probably shouldn't use `is_file` anyway. Just use the file and gracefully handle any errors.
prolly because no one believes you've run into a significant number of 50+ programmers in only 2 years of coding, and think you're just belly-aching about this one guy whose code was a PIA.
Care to elaborate on the use cases of binary search trees and other less common data structures in web applications? (No /s)
Just the tag. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I've been working on writing a rapid access development framework in Node to function as the API for third-party extensions in a web application that I want to migrate to it from a PHP framework. One difference in the two environments is the efficiency of the V8 JIT compiler compared to the PHP interpreter. Nikic and a few other PHP core developers have done a really good job with the rewrite for 7.x (adding an AST to the interpreter so that there's opportunities for compiler optimizations) but there's a magnitude of order speed difference between PHP client code and what's possible with a native-C extension to the PHP interpreter. This isn't true in Node; often Javascript client code will run faster than a native C++ Node extension since it is progressively compiled and optimized to machine code, where the extension code always has some indirection overhead to interact with the V8 engine. This makes lack of more complex data structures especially frustrating in PHP vs. the same in Node. In my framework project, one feature is a semantic ORM. By this I mean that all data objects are defined by schema.org and local custom vocabularies. So for example, if you wanted to write an event manager, you could annotate [http://schema.org/Event](Event) vocabulary on the data object, and a set of metadata describing the relationships and business rules to enforce. It generates the necessary database tables and methods, and uses the semantic attributes from top to bottom of the stack (applying the semantic tags in the front-end code). I make heavy use of self-balancing BSTs to parse, manipulate and cache those object trees. That's a narrow example but there's a lot of library code that needs less common data structures. For example, I use efficient immutable data structures a lot in web application code. The library code underneath them requires a tree structure to implement. That's slow in PHP without engine support, so the approach isn't popular in the PHP community. PHP added some core data structures in the standard library in 5.3 - fixed arrays, double linked lists, minimum and maximum heaps, stack, queue, priority queue, and map (SplObjectStructure).
I would use only sql unless I had a real problem which could be solved by using mongo.
I’ve run into about 10 of them, which I know isn’t many, and again, I said it was simply my experience with them.
my friend who is **not a programmer** tells me shit like "you should switch to java, bro", Symfony sounds like forgotten old ass framework, change language, there is always a need for java developers, bla bla bla, already assuming I actually need help to get paid more.. or that there are zero job offers.. Or thinking that he knows the market by only regurgitating silly rumours in his IT support type of job. Don't forget PHP jokes from xkcd, 9gag or whatever other nerdy programmer comic that is popular right now.
I like your analogies. I kind of see myself becoming "One man armies" as per your description. And yeah sometime it's hard to put it gently for some too complicated idea my younger teammate have to offers (not to say B.S., they are eager to try out new cool things they just learned, but still.)
In case anyone is wondering, here is what the free tee looks like: ![Alt text](https://www.shutterstock.com/image-photo/wood-golf-tee-95134135?src=YjC8RWWl_WKGNVNkl5KNaw-1-11) Pretty nice.
Best IMHO is switch Could possibly put the options in a lookup array with car name as key (or vice versa) and use array functions to lookup
You could use [in_array](http://php.net/manual/en/function.in-array.php) or a loop.
Was about to comment this. I'd put all the values into an array and use the in_array() function. http://php.net/manual/en/function.in-array.php
Create an array of all the values you want to test against. Then run an if statement using the in_array function. $values = array('string 1','string 2'); If(in_array($textfieldvalue,$values)){ //Do stuff } On my phone so there are probably typos but you get the idea.
You can put all vars you want to check against into an array and then loop over it. This way you only need a single if check. Also /r/phphelp
Great. Thanks, didn't know that in array function yet. The problem is I need to know what var was a match from the array 
Couldn't you just use the value of the text field once you know it is in the array?
Man has a point. 
 &gt;$input = "something else"; $vars = [ '1' =&gt; "something", '2' =&gt; "something else", '3' -&gt; "yet another thing", ]; if ($key = array_search($input, $vars)) { echo "Input found at key {$key}."; } else { echo "Input not found."; } (I din't test it, though… It can be wrong and/or set you computer on fire.)
That's awesome! Thanks a million. Will report in case of succes, or fire 
...or a book about crypto in Web applications with an emphasis on PHP but applicable to any language targeting mid- to senior-level devs with no special background in cryptography but who want to be knowledgeable.
I can see it as either in_array or a key search. Without knowing why the poster made some design choices and going from just what was posted, I still think a switch gate would be best.
Yes - I've used NewRelic a number of times and it's great. However: * it does quickly become expensive - especially if you're running it on a variable number of web server nodes. * it doesn't work all that well with calls out to web services (like ElasticSearch, Facebook etc) and grouped them all as 'curl_exec' or something ... which is unfortunate. * I seem to think there was a problem with it working very well when the "frontend" is just an API (i.e. all calls to the API are Ajax/via JS).
WTF people downvoting a mere mention of /r/phphelp?
**Here's a sneak peek of /r/PHPhelp using the [top posts](https://np.reddit.com/r/PHPhelp/top/?sort=top&amp;t=year) of the year!** \#1: [First time writing OOP can anyone check im on the right track.](https://np.reddit.com/r/PHPhelp/comments/65qzgl/first_time_writing_oop_can_anyone_check_im_on_the/) \#2: [Can someone explain what this php malware does?](https://np.reddit.com/r/PHPhelp/comments/5phn6r/can_someone_explain_what_this_php_malware_does/) \#3: [Tutorial on getting xdebug to work with phpstorm?](https://np.reddit.com/r/PHPhelp/comments/70ho0c/tutorial_on_getting_xdebug_to_work_with_phpstorm/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I just ceeated yesterday a lib in js for the same..the logic will be the same in php https://github.com/JuliusKoronci/truth-table 
I'm really interested in the use-case for this. What are you getting to do? 
You can use array_search instead of in_array if you want to find where the match was. http://php.net/manual/en/function.array-search.php
Yeah no :D
&gt; it doesn't work all that well with calls out to web services (like ElasticSearch, Facebook etc) and grouped them all as 'curl_exec' or something ... which is unfortunate. &gt; About NewRelic being expensive, after many research, I hired 2 sysadmins to configure munin/inciga2 on all my servers (actually 11, which regroup multiple company (i'm working for all thoses)) and now i've a fully working system that cost me only installation. Expensive installation, but nothing after that ;)
git submodules are a pain to maintain. Was using them on a project, and recently we merged everything in main repo, using them was a pain.
Am I missing the obvious here. If it's only 20 variables why don't you put them in a select input and make them choose. Then it's a normal input handling...
 $userInput = $_POST['input']; // here's the user input $validInputs = ["apple", "banana", "cucumber"]; // here's an array of valid possible values $validKey = array_search($userInput, $validInputs, true); if($validInputKey !== false){ echo "Found a match"; echo $userInput; echo " = "; echo $validInputs[$validInputKey]; } else { echo "No match found."; }
^^ This one!!
I bet people were downvoting for not so effective solution but not r phphelp
Let me post it in about an hour when I'm behind my pc
phpstorm
You mean like example.com?variable=value ?
Never use a switch statement in lieu of a mapping.
do you mean something like http://wordpress.com/blog/page/1 ?
Yea like: www.example.com?i=$h $h = 2 echo $h
You would do echo $_GET[‘i’];
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Im a PHP devloper You can barely develop a thought in English, let alone PHP.
Oh. Just use $_GET["variable"]
No i want echo what i write in the paramter example.com?i=text $_GET["i"] =$i echo $i But i have dinamic variables that i want set in paramater example.com?i=text%20$lol $_GET["i"] =$i echo $i 
This should cover the basics about symmetric crypto: http://timoh6.github.io/2014/06/16/PHP-data-encryption-cheatsheet.html
But i want show a variable in my program on paramater like: www.example.com?i=Ola%24$nome &lt;?php $nome =andre; echo $_GET['i']; ?&gt;
Then you'd include the parameter when making the html link. &lt;a href="example.com/index.php?i=Ola%24".$nome.""&gt;&lt;/a&gt;
 $url = 'https://example.com/?q=' . urlencode($var); 
Are you Italian by any chance? If someone loads that url, your script will receive a GET variable i with a value of Ola$$nome That value is not interpolated with your $nome variable, so your first line does nothing. Then you echo "Ola$$nome". You should instead do something like: When a user loads example.com?i=Andre echo "Ola " . $_GET['i']; 
It must be string and var in the same parameter
But i have to represent string and var on the same paramter
Can you explain what the end result should look like?
Since you are setting the $rolled variable outside the while loop once, it will not change anymore. So if it is initially not set to 6 the condition will always evaluate to TRUE. After each iteration you should reset the $rolled to a random number and eventually it will be set to 6 and exit the While loop.
What does your TA suggest?
I know this code is incorrect but u can understand how i want my code work www.example.com?i=Ola%24$nome &lt;?php $nome =andre; echo $_GET['i']; ?&gt; //response: //Ola andre
 &lt;?php $rolled = rand(1,6); while($rolled &lt; 6){ echo "Dice roll $rolled &lt;br /&gt;"; $rolled = rand(1,6); } echo "Dice rolled number 6!";
he didn't tell me anything. I am doing this ahead.
Not sure what =&lt; is supposed to do. If you'd want it to run indefinitely and only stop when a 6 is hit. Try doing 'while (true)' as the condition, then do the random call and if it is 6, exit. So 'while (true) { $num = rand(1, 6); if ($num == 6) { exit; } }. Typed this on my phone and haven't tested but should work.
 &lt;?php do { $rolled = rand(1,6); echo "Dice roll $rolled &lt;br /&gt;"; } while ($rolled !== 6);
This is the simplest I could manage: &lt;?php do { $rolled = rand(1, 6); echo "Dice roll $rolled &lt;br /&gt;"; } while ($rolled != 6); 
The misinformation has been deleted!
 &lt;?php do { $rolled = rand(1,6); echo "Dice roll $rolled &lt;br /&gt;"; } while ($rolled !== 6);
Now in stupid form: &lt;?php for($rolled = NULL; $rolled == 6; $rolled = rand(1,6)) { } echo "Dice roll 6 &lt;br /&gt;"; ?&gt;
 &lt;?php do { $rolled = rand(1,6); echo "Dice roll $rolled &lt;br /&gt;"; } while ($rolled !== 6);
1. You assign $rolled a random value just once, do this inside the loop 2. php end tag ?&gt; is unnecessary 3. Keep things [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) &lt;?php while (true) { $rolled = rand(1,6); echo "Dice roll $rolled"; if ($rolled === 6) break; echo '&lt;br /&gt;'; }
Now in idiot form for($rolled = 1; $rolled &lt; 6; $rolled = rand(1,6)) { echo $rolled; } echo "Dice roll".$rolled." &lt;br /&gt;";
I forgot about the do while thing... :o jeez
I love when I get to use a `do...while`, it's underrated.
No.
/r/phphelp
So from what I gather, Phony can be a replacement for Mockery? 
I think the future is diversity. Functional Programming can become as much of a mess as OOP. Just maybe some problems are best solved with OOP and some with FP. And the future is multi-paradigm languages that allow you to do both. PHP has always tried to pull in features from whatever the latest trend is, and by accident its actually becoming a decent multi-paradigm language IMO. The problem developers often have is when they think a particular way is the 'right' way. They think OOP or FP is a way of thinking. When the truth is you have to think *all* ways when coming up with the best solution to a problem.
Elastic and Facebook work for me. I remember a year or so back they had issue with newer versions of guzzle but they've been fixed for some time.
There are a few horror stories of older programmers not keeping up with the times and falling way behind. However IMO I come across way more problems with junior devs who think 3 years in the industry is a long time. This is why we have framework wars. Like if you learn React you cannot possibly use Angular because you've already invested time into React so now you have to do everything in React. Thats bullshit. If you've been in this industry as long as me you just learn everything and use whatever is best for the job. No time invested in learning is wasted. And learning these new frameworks is easier because I actually have foundational knowledge. And thats just javascript. I've met front end devs who don't know any server side or databases because they thought they had to choose. They think for some reason they had to choose because nobody can possibly learn everything to be a full stack dev these days. "there is just too much to learn" Pfft In my day there were **only** full stack devs. When you've been learning for only 3 years I guess thats a valid perspective. But when you've been doing this 15 years then you realise there is nothing new under the sun. Every new tech is just an adaption of some old tech that I'm already familiar with. Experience means a lot in this industry. Any old fuddy who has kept up with everything is an invaluable resource. 
ahh is a new day in utc, ofcourse in autralia is tuesday now 
/r/phphelp. Do a check in your foreach loop to check the subject and year. foreach ($list as $list) { if(strpos("EECS", $list)) { print "&lt;p class='output highlight'&gt;$list&lt;/p&gt;"; } elseif(strpos("1st")) { print "&lt;p class='output bold'&gt;$list&lt;/p&gt;"; } else { print "&lt;p&gt;$list&lt;/p&gt;"; } } 
Yes, Phony is a test double / mocking tool, like Mockery. Phony's mocks are more like Mockery's stubs/spies than its mocks. Phony mocks don't use "expectations". Instead you set up behaviors before the test (stubbing) and assert based on what happened during the test (verification). It's an approach with many benefits, including test failures that are often easier to understand. Phony also provides features that AFAIK no other mocking tool does. Function-level stubs and spies, stubbing and verification for generator-based systems, ad-hoc mocks for testing ducktyping etc.
&gt; You're not going to be making "fast money" making websites anytime soon just because you start with PHP instead of something else. Well if you're trying to make money building websites as a freelancer then there is a distinct advantage to learning php. No other language has the choice of CMS's, frameworks and is easy to learn.
I will look into this, it sounds cool! Thank you for the explanation 
 &gt;Blade template is totally useless, I did not understand why a template system is required when php is a template system itself. Do you (and all the other developers who work on your codebases now and in the future) reliably escape everything that needs escaping before outputting it? I was against templating engines for a long time, but after seeing the sheer number of potential XSS exploits in large codebases created by developers who were completely unaware of what they were doing, I now stand firmly on the side of using proper templating engines. Escaping by default is more than enough of a reason to use one IMO. 
If you want to echo the parameter value you don't need to set the name in your script, just load the url with the name as part of the value already. I think you need to reevaluate what you want to do, or be clearer. If your goal is to show the name the user requests as part of a sentence you choose, just have only the name in the parameter. If you want the user to build a sentence he chose while you choose the name, you have to interpolate the sentence in the parameter, in this case a safe way to do that would be with a regex.
&gt; Do you (and all the other developers who work on your codebases now and in the future) reliably escape everything that needs escaping before outputting it? I hope so :) You are right that you "cover" that way a lot of possible human errors, but it is not bulletproof. I had made screw ups despite using an template engine. In my opinion, not using a template engine made me more careful to what to output to user. After being forced to work with Smarty, and its (arguable) strict rules and limitations, the first thing I think when I hear about a template sistem is "limitations", and "workaround would be required". The best feature I found working with Smarty was the caching mechanism. Concerning Blade, I found it ok as an template engine, less stressful than Smarty, but kind of useless. Now that you mentioned default escaping, it is indeed a good feature if you want to cover some of the human error. 
 Yea my link is wrong but u can understand the idea what I want to do :) My link is: www.example.com?i=Your%20rank%20$rank%20$elo%20$lp%20LP My code is like that: &lt;?php $elo = *this var will get the LOL elo* /*Gold, Silver,etc*/ $rank =*this var will get the LOL rank* /*I, II, III, IV, V*/ $lp = *this var will get LOL lesguepoints/* 10, 25, 44, etc*/ echo $_GET['i']; ?&gt;
 Yea my link is wrong but u can understand the idea what I want to do :) My link is: www.example.com?i=Your%20rank%20$rank%20$elo%20$lp%20LP My code is like that: &lt;?php $elo = *this var will get the LOL elo* /*Gold, Silver,etc*/ $rank =*this var will get the LOL rank* /*I, II, III, IV, V*/ $lp = *this var will get LOL lesguepoints/* 10, 25, 44, etc*/ echo $_GET['i']; ?&gt;
When I said that the Laravel ORM is nice I was talking about using the ORM and the features it has, and not about it's internals.
Interesting, I didn't know the loop variable can shadow the iterable variable, however I would suggest not to do it ever. :-) foreach ($list as $item) would be better. Otherwise, there are two errors: second strpos doesn't have a haystack and EECS 1st year doesn't get bold. Also I have to note that strpos should be always used with strict false check, even if it wouldn't make a difference in this case, it is a best practice to do so.
Congrats on the release! And a personal "thank you" for keeping the minimum requirements low, for those of us who support a user-base that isn't always running on the latest-and-greatest. 
I have checked the PHPUnit example, but I don't get what is the gain with having with('argument') and calledWith('argument') as well? For me it looks like duplicated code, is there a clear gain with this approach in comparison where I set up the expectation and it just works without an additional call? Also the auto-wire example here is a bad example, PHP will already check for the instance type because of the type hint, therefore it makes no sense to test for it, again. :-) It would be better to show that it is a mock indeed and not the real object.
As other people say, you have to really know what you are doing when choosing Mongo and if you even really have a need for it. Many use Redis to cache data structures so they don't hit MySQL that my (or any database backend) and it's quite easy to keep an up-to-date data structures in Redis in live mode if you develop properly and with that layer in mind.
Laravel is major overkill for simple CRUD. Most frameworks are really. There's 1001 simple CRUD apps on github to look through.
I need a secure login system to get t the CRUD and maybe build web services/APIs on it in the future as well. Hence, I thought of Laravel or using any other popular framework.
Laravel will absolutely run on a shared hosting plan (maybe not _any_ shared hosting plan), I have at least one client website written in Laravel deployed on shared hosting right now. Who knows what the author of that article was doing to get to that conclusion.
You should always rely on metrics you have obtained yourself with your own datasets, rather than relying on metrics that others have published.
I've had 2 hosting services with FTP access only and Laravel worked just fine. Mod rewrite is required. Just configure the app properly and don't copy gitignore files (like .env). For only CRUD operations I think Laravel is too much, altho it's super easy to code it. But if there's an admin panel required for something else, user auth (for advanced I'd suggest [Sentinel](https://cartalyst.com/manual/sentinel/2.0)) and API later, it can be the way to go.
For now, just a secure login to access the CRUD grid, and something that can accommodate development of web services/APIs in the near future . What would you suggest for these requirements? I'll look into Sentinel. Thanks.
Where I work we regularly bring on new developers to work on Magento codebases, and having to explain to them why it's necessary to run all of their code through `$this-&gt;escapeHtml()` over and over is a pain in the arse. I've only really worked with Handlebars and Mustache, and Mako and Jinja2 for python, and they're all so nice to work with. It also forces developers to not be lazy and include lots of random logic in their templates. Say what you will but it ends up happening time and time again. Best to just remove the temptation altogether.
What exactly is the point of having dependencies that are "automatically mocked" if those mocks do nothing.
MySQL also has a json field (https://dev.mysql.com/doc/refman/5.7/en/json.html)
MySQL also has a json field https://dev.mysql.com/doc/refman/5.7/en/json.html
&gt; I have checked the PHPUnit example, but I don't get what is the gain with having with('argument') and calledWith('argument') as well? For me it looks like duplicated code, is there a clear gain with this approach in comparison where I set up the expectation and it just works without an additional call? It's really tough to create examples that show a decent amount of the API, and at the same time show realistic "real-world" usage. I made a compromise to show both stubbing and verification in one short example, but the example is contrived, and you're right that it wouldn't make much sense to write a test exactly like that. In "real-world" usage, I typically find that I use either `with()` or `calledWith()`. But there are cases where you might want to use both in combination, and the separation of stubbing and verification gives you the flexibility to do that. To give you some specific examples, if you had a class that you simply wanted to spy on, you might do something like this: // setup $handle = mock(ClassA::class); $mock = $handle-&gt;get(); // system under test - this function calls $mock-&gt;methodA('argumentA') somethingThatCallsMethodA($mock); // verification $handle-&gt;methodA-&gt;calledWith('argumentA'); Or if you have a test that will only pass when a dependency behaves a certain way, you might do this: // setup $handle = mock(ClassA::class); $mock = $handle-&gt;methodA-&gt;with('argumentA')-&gt;returns(true); // system under test - this function returns true if $mock-&gt;methodA('argumentA') returns true $actual = checkMethodAReturnsTrue($mock); // verification assertTrue($actual); In the above example, it's not necessary to use `calledWith()` because a successful result implies that it was called how we expected it to be called. There's a LOT more that could be said here, but basically, Phony gives you more freedom and less magic than "expectation" based mocking frameworks. There's plenty of discussion out there about why this approach is good. It's what made [Mockito](http://site.mockito.org/) so popular, and you can find a [blog post from the author](https://monkeyisland.pl/2008/02/01/deathwish/) (from almost 10 years ago!) talking about some of the other justifications for it. &gt; Also the auto-wire example here is a bad example, PHP will already check for the instance type because of the type hint, therefore it makes no sense to test for it, again. :-) It would be better to show that it is a mock indeed and not the real object. Yes, you're right of course. But once again, this is more to demonstrate syntax. You can find full and working example of auto-wiring over at [eloquent/phony-examples](https://github.com/eloquent/phony-examples/blob/master/example/kahlan/spec/DomainResolver.spec.php). It goes hand-in-hand with the [Phony and Kahlan by example](http://eloquent-software.com/phony/latest/kahlan-by-example) guide.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [eloquent/phony-examples/.../**DomainResolver.spec.php** (master → d4c9e5d)](https://github.com/eloquent/phony-examples/blob/d4c9e5dd1791c08a79eb126d2b2cf12d9b6b9b41/example/kahlan/spec/DomainResolver.spec.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
&gt; Function-level stubs and spies As i remember, they do that by using monkey patching, no? Or there are limitation that I can't use `\random_int` because in this case library can't replace call to spy?
Spider monkeys get their name because of their long arms, legs and tail.
I don't get it. If you want to show a player to the user, then all you need is an identifier. A name, maybe. You can get the information from your database or whatever it is you use. you don't even need the get parameters. Just have someone load example.com and you'll show them the string. But if you want the url to provide you with a string to fill with the values you have, Then just use a string replace or a regex, fill the string and echo it out. Dude, just rethink what you're doing, study how get parameters work and why they're used, and keep it simple. 
Is just a example the the users must insert a text to show in the body of the page and they must use variables $rank $elo $lp
The example in the original post just demonstrates the syntax, it's not a real use-case. Check out [this example](https://github.com/eloquent/phony-examples/blob/master/example/kahlan/spec/DomainResolver.spec.php) to get a better idea of how it's used. Having said that, there are definitely situations where having a mock that "does nothing" is useful. Think about the case where you're forced to implement an interface that takes some object as an argument, but your implementation doesn't even *use* said argument. You need an instance to call the method, but it doesn't need to "do anything".
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [eloquent/phony-examples/.../**DomainResolver.spec.php** (master → d4c9e5d)](https://github.com/eloquent/phony-examples/blob/d4c9e5dd1791c08a79eb126d2b2cf12d9b6b9b41/example/kahlan/spec/DomainResolver.spec.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply do44j66.)^.
That's not how things work. If more and more people think that PHP sucks and turn away from it, obviously companies will start to use other technologies. If you can't hire a PHP developer, maybe you have to use another language in the end?
Kahlan definitely supports [function stubbing](https://kahlan.github.io/docs/allow#function-stubbing), but I think it's only for "global" functions? Not 100% sure on that, I'll see if I can get a definite answer. Phony's function-level APIs can be used on *anything* that PHP considers "callable" - closures, classes that implement `__invoke`, pre-defined functions etc. It opens the door for using functions in places where it might have been difficult to test before.
I'd suggest CakePHP, you can auto-generate a lot of the CRUD and then expand it when necessary.
A page that says Laravel won't work on a shared hosting is not an "article" in any sense but a fucking blogspam. Better delete it from your post to prevent it from indexing by Google and fooling other people.
Strange that a client is up for having a custom system built, but wants to stick with shared hosting with an old version of PHP. You should probably at least move them to a PHP7 shared hosting plan. Although the fact that they want to stick with shared hosting implies they possibly shouldn't even be having a custom system built to begin with. Maintaining and fixing a custom site is more work than running a cheap VPS. Crazy building a new system now for PHP5, and will restrict your ability to write more reliable code with some of the new PHP7 features. Even Laravel has already dropped full support for it: https://laravel-news.com/php-56-no-longer-supported &gt; till I read some articles like this one saying that Laravel: Does NOT work on Shared hosting plans That article is low quality blogspam crap full of mistakes. They even called Symfony "Symphony". Laravel is purely PHP based, so fine for shared hosts. Again though, building and running a new system on PHP5 is a really bad idea. This is like having a new custom Windows program written specially for Windows XP just because they happen to have an old PC in the office running it still. They can leave the wordpress site on the old hosting if they want to. But in $5 extra per month is an issue, then I can't understanding why they're having a new custom system built to begin with. 
Just to add to my previous answer, Phony can definitely [stub global functions](http://eloquent-software.com/phony/latest/#stubbing-global-functions). It exploits a feature of PHP called [global function fallback](http://php.net/language.namespaces.fallback).
Kahlan subbing is done by using a Just In Time patching technique so you can stub PHP core functions like `\random_int` as well as user land functions.
Accurately named, as that's always going to start by printing `Dice roll 1` and it's never going to print "Dice roll 6" like the original spec does. `do...while` correctly meets the spec with minimal code.
Personally unless you're desperate for work I'd consider refusing the job - they sound like they're either thick as shit or dont care about the long term performance and security of their site/service, I'd assume the former given that they are using GoDaddy for hosting. I'd raise the most obvious issues and ask for genuine reasons for the following before committing to anything: 1. Why are they using shitty GoDaddy hosting (are they unaware of how much of a terrible idea that is?) 2. Why do they want you to use an insecure shared environment 3. Why are they wanting new work done using a version of PHP that as from January will only be getting security updates. Given you also mentioned they might need more work down the line this just sounds like it'll be a minefield of issues - make sure you charge appropriately if you do go ahead with this. 
Yeah whatever it is, there's going to be some huge pain in the ass issue with this client/system. Especially odd they given the hosting requirement that they even know the term "API". 
Except php is actively used, a lot, a very fucking lot and there are lots of programmers for it. It is thriving regardless of what some trolls on reddit have to say. 
try octobercms, for your requirements all you have to do is setting up models and form configuration
Try codeigniter 3 if you need CRUD actions. If you want also an admin panel with CRUD builder, try CI Bonfire: http://cibonfire.com/ . It's easy to use and fast.
A little desperate since I'm new and just getting started with learning Laravel on Laracasts. I've built WP sites earlier and know a bit about frameworks. A login system and CRUD grid are common use cases and I thought getting experience in this would be good. Believe it or not they do have a "developer" who shared their requirements with me. I know I'm new but this was enough to make even my eyes roll. It's strange to see technical people having a very low standard of security in mind when thinking of getting such an app built. I might refuse; depends on my next few meetings. 
Yeah. I insisted for PHP7 but they have some code running on 5.6 as of now. Which is why I had Laravel 5.4 in mind, which supports 5.6 but security fixes for that Laravel version end in Jan 2018 since its not LTS. Could be only the low quality posts saying that Laravel doesn't work or work well with shared hosts. This was just an example I linked to. There are others you'll find in many forums, etc. which have similar concerns. I know right? It's just $5!
If you want a popular framework and you're interested in CRUD only, try searching for a microframework. So I suggest you to take a look at: https://lumen.laravel.com/ , https://www.slimframework.com/ , http://flightphp.com/, https://docs.zendframework.com/zend-expressive/ and https://silex.symfony.com/ . These are all modern frameworks. Those are all good for starting an API based application.
I have no idea why all non-Laravel suggestions are getting downvoted. I'll check out CI3 and CI Bonfire. Thanks.
Thanks. Laravel was inspired by Code Igniter. Now all Laravel developers hate CI. The truth is that CI3 is not using latest PHP futures (almost nothing that was introduced starting with PHP 5.5-5.6). Right now, the CodeIgniter 4 is in development. So any developer can help by testing/contributing to CI4 - https://github.com/bcit-ci/CodeIgniter4/
That was just one example. I've read it in many different places. 
When are we going to see more information about symfony flex btw?
&gt; Could be only the low quality posts saying that Laravel doesn't work or work well with shared hosts. Yeah I wouldn't really recommend anyone building a custom site to use shared hosting at all really. Whether or not your Laravel config works on it is outside of your control, you might find you need a module or something which you won't have the power to install. Also you won't be developing+testing your custom built project using the same config as the production server - which leads to discovering, fixing &amp; testing bugs in production (when they don't occur on your dev server). I always develop in a VM with the exact same server OS/packages/config etc as the production server. &gt; I know right? It's just $5! Reading your other comments you mentioned both that this is for a "client", but also said "I'm new here"... are you a contractor or employee? If you're a contractor, I wouldn't go near a client that has an issue paying for hosting. 
Contractor. "I'm new here" == New to professional php development
Ah right, fair enough. I guess you're also giving them a bit of leeway seeing you don't have much custom dev experience yet. But yeah, having an issue at $5/month is a bit of a red flag. Not sure what you're charging them - but you should expect this client to chew up a lot of your time - so just make sure you know what you're getting yourself in for. It might be worth it though to get some more experience starting out.
Interesting that it recommends CTR mode without mentioning CBC or GCM. I thought CBC was just fine and that GCM dominates CTR as a way of converting a block cipher into a stream cipher.
CBC and CTR are morally equivalent in the sense that they're unauthenticated modes. GCM gives you authenticated encryption. You want authenticated encryption.
Nice, Javascript has always been a bit of a thorn in my side due to not having live debugging in the IDE. I often have to code down for maximum compatibility, and code the majority of it as straight Javascript, no libraries or jQuery. I'll have to look in to those.
One could securely use any of CBC, GCM or CTR modes, but as GCM was not generally available in OpenSSL back when the article was written, I chose to recommend CTR. As /u/sarciszewski points out, they are both unauthenticated modes, but there is another "major" discrepancy between them: CBC requires padding. With CTR you don't have to worry about padding (one thing less to consider). But afterall, it is not a problem per se that CTR is not authenticated. Using a HMAC (as described in the article) is easy and bullet proof solution.
here? https://symfony.com/doc/current/setup/flex.html
http://php.net/manual/en/migration55.deprecated.php
&gt; Lots of vulnerabilities Name one
So you don't really care *why* mysqli API got deprecated, you are mourning your old code that has been written in 1990-х. So the answer is not really important for you but as far as I know, Oracle guys just not willing to support two API versions, which is quite understandable. So only one remained. 
i dont even know where to start
A major chunk of the development community was using the library in a very bad and sometimes completely idiotic way, mysql extension was the era of injection. The library itself had only a very simple API that lacked a lot of security features pretty much leaving the implementation of said security features to the programmer or whatever wrapper library was available. Dropping support for this extension was the right choice since it really announced to the world "PLEASE FOR THE LOVE OF [insert your god/idol/whatever] STOP USING THIS EXTENSION COMPLETELY WRONG". 
Don't hesitete, shoot the first one coming to your mind. Just try not to confuse your own mistake with API's vulnerability. 
Surely it works. Hundreds of monkeys switched to mysqli and happily keep writing in the old style, keeping all the injections in place. 
The monkey is the 9th animal that appears on the Chinese zodiac, appearing as the zodiac sign in 2016.
Who said anything about extension vulnerabilities?
Get lost fucking bot
Damn son, have a snickers.
You just said "lots of vulnerabilities" but failed to name even one. How /r/php
I like that one. Thank you. I stiched a simple default-css together: https://codepen.io/anon/pen/GMxXwL
https://www.youtube.com/watch?v=hpigjnKl7nI
It really doesn't matter what language you start out on as long as it is web development if that is what you are interested in. I would recommend HTML5 and JS to learn the basic of how web development works and if you find that enjoyable to try PHP to get a feel for backend development. Also, I have no idea you weren't native to English, you are doing very well.
 &lt;?php $variable = $_POST("input"); mysql_connect(...); $query = mysql_query("SELECT * FROM table WHERE column = '$variable'"); Tell me you never saw these... This was probably the way most "beginners" did things. Later they learnt about escaping, and used a terrible fucking function called `mysql_real_escape_string` instead of actual parameters and prepared statements. This was what was taught to new people. This was what was used by professionals (yes, i've seen 'professionals' do this). Something had to be made to stop the general community do stupid stuff.
Good catch on the `foreach`. I missed that! I never use strpos but in this case, I chose it because the items were not in an array so I'm not familiar with best practice for strpos.
Yeah, making a typo in a comment or being a non native English speaker speaks volumes about the content that he provides as a developer. /s
 &lt;?php $variable = $_POST("input"); $cn = mysqli_connect(...); $query = mysqli_query($db, "SELECT * FROM table WHERE column = '$variable'"); now tell me how many times you've seen **that**. 
Hey, that's how I started! Except I use `sprintf ` inside `mysql_query`. I moved onto PDO pretty quick afterwards and haven't looked back.
Too many times. It was a scary time.
just install it using PECL if You don't have resources to upgrade to PDO or mysqli
Yeah, that's how I started my first guestbook too when that was popular in the late 90's early 00's and I tried to hack it together not having done any programming previously.
Back then, I feel there was an excuse. These days, however, there isn't. There are a plethora of resources available for learning PHP and I'd hedge a bet saying that near every single one of them recommends using PDO or an ORM.
A method has a vulnerability if it can't do things in a secure way. In this case, "the secure way" is using parametrized queries. The mysql api doesn't support them. That makes it vulnerable. Not all vulnerabilities are coding bugs (or unintended behavior). Some things are vulnerable by design. Let's have some more semantic satiation, shall we? Vulnerable vulnerable vulnerable. 
Yeah, and it's all pretty much thanks to deprecating the mysql extension. It was really the best decision by PHP dev team.
I don't even use sql without a orm 
It can. One can write secure code with mysql ext all right. As well as one could write insecure code with mysqli and PDO. So the only actual vulnerabilities is PHP users, whose indeed number a lot, and whose at large remained the same. 
Strange that a certain troll account has been deleted then this guy takes over 
The premise of this post is wrong. mysql functions were not deprecated in PHP 7. They were REMOVED in PHP 7. They were deprecated with PHP 5.5 which was released in 2013. FOUR YEARS AGO.
Reasons to test your code before upgrading the platform it runs on :) You may just not be able to use PHP7 without refactoring.
```use BotManBotManBotMan; use BotManBotManBotManFactory;``` whoaat? :D
If I guess it right, it's a huge loss for this community that he quit.
It does not have parametrized queries so therefore it is more vulunerable. It's as simple as that. You could write vulunerable and secure code in any api/language, but you could not write as secure code with the old mysql api as you can with mysqli.
That is nice :D
Lol it's missing slashes. https://botman.io/2.0/installation Still weird though. use BotMan\BotMan\BotMan; use BotMan\BotMan\BotManFactory;
Is there an example you could point me to that demonstrates the difference between expect-run-verify and how Phony approaches it? I've looked at the examples on Github and even of Mockito and I'm not picking up on how the approach changes. 
Neat. I considered making a Discord bot ages ago, but I didn't feel like diving into the API. I'll have to save this.
Your foreach is clobbering $list.
Okay, so this error is pretty straight forward unless I'm misunderstanding something. You're looping each index in the $list array, making $list a string. Also, I don't know if I'm correct here (I never do what you did) but the loop *$list as $list* should really have a different variable name (i.e. $list as $l) because if I'm correct the $list value overwrites the array $loop as a string. I could be wrong (PHP may recognize it properly). But moving on.. This is kind of the root of your issue. if(in_array("One", $list)) { That $list value is now a string, and this is pretty redundant. You should either compare string to string, or loop through an array of values. Ex: $lists = file("classList.txt"); foreach ($lists as $list) { if('One' == $list) { print "&lt;p class='output highlight'&gt; $list &lt;/p&gt;"; else { print "&lt;p&gt;$list&lt;/p&gt;"; } } or $lists = file("classList.txt"); $values = array('One','Two'); foreach ($lists as $list) { if(in_array($list,$values) { print "&lt;p class='output highlight'&gt; $list &lt;/p&gt;"; else { print "&lt;p&gt;$list&lt;/p&gt;"; } } But I have a feeling that's not what you want, so the first way is probably it.
take it with a grain of salt. that joke is funny imho
Well. "in_array()" has a syntax of "in_array($needle, $haystack):" assuming $needle is the string you are looking for in $haystack, the array. It appears it does not think that $list is an array. "$lines=file('file.txt');" is the syntax for the file() function. But you can also add "FILE_IGNORE_NEW_LINES" as a second parameter, which would explain the error, in "$lines = file($filename, FILE_IGNORE_NEW_LINES);" to not have a trailing newline in each element of the array. 
&gt; You could write vulunerable and secure code in any api/language So you admit that it's, so to say, "not a wand, it's a wizard". PHP users en masse cannot produce secure code at all, but a blame goes to a honest extension. &gt; you could not write as secure code with the old mysql api as you can with mysqli. This is simply not true. Be careful making statement you cannot prove. 
This is the main reason I'm using Cashier because it automatically handles webhooks. At least the ones for subscriptions and invoicing. 
 foreach ($list as $list) { You can't do that. What do you think is going to happen when you try to do something with $list later? How is your script going to know *which* $list to use, because now there are two? You should do something like this: foreach ($list as $list_item) { Then you can refer to the $list_item as you loop through the array. Next, this part: if(in_array("One", $list)) { First, let's change that variable to the correct one to match what I just taught you a minute ago: if(in_array("One", $list_item)) { Now, are you **SURE** that $list_item is an array? Because if it isn't, you're going to get an error message that says "in_array() expects parameter 2 to be an array..." Obviously the value is not an array. You can't use in_array to search inside a string. So instead, you need to use a function that searches strings instead, like this: if(strpos($list_item, 'One') !== false) { Now you're searching the string. The else condition would be when 'One' does not exist within the string. 
thanks for the clear and enriched guide. It really helps me to understand. I figured out on how to use strpos, but I wanted to know how to use in_array.
/r/phphelp
How about file_get_contents along with strpos 
Thanks for showing me variety of examples. Unfortunately none of these worked, and I am not sure why. First example just prints all the list without highlighting. Second example and third example does not run..
I changed it to what you said but it still gives me the same error.
What is in your classList.txt file?
The way you're doing it above, you can't use in_array. However, if you're **CERTAIN** that each value that you're looking for is on its own line in the file, then you can do this: $list = file("classList.txt"); if(in_array('One', $list)) { // do something if it is there } else { // do something if it isn't there } 
I need to know what you're looking to do in order for me to actually give you a solid working example. I just gave you a few ways you could accomplish what you may be attempting to do. As for your issues, * That means that the values were not exactly the same. If they are supposed to be, is there whitespace? * Probably because this isn't anything close to what you wanted, so I would just ignore this one.It was meant to be a similar example. * I'm not printing out the array anywhere here. To break this down, &gt; $lists = file("classList.txt"); Store entire contents into array $lists. &gt; if(in_array('One',$lists) { If the exact value 'One' is in the array, print with the highlighting. Else should be pretty self explanatory at this point. So to review, if you're printing "Array", you're probably trying to print out a variable with an array.
https://developers.google.com/speed/pagespeed/insights/
Since OP seems to be new at PHP, you can verify everything is properly in an array by doing var_dump($list); or is_array($list); Var_dump will display the value type, while is_array returns a boolean.
That does not work as i told you i have changed DNS which means there are different versions of my website right now. This is why i need the information. Also it has everything to do with php, because if my website is slow it's a api php call problem. 
It has names of students and their year. Asley, Year One Robert, Year Two Rosalia, Year Two Christy, Year Three Alex, Year One I want to make First year students to appear with background color yellow. 
Well, w3school is using mysqli mysqli_select_db($con,"ajax_demo"); $sql="SELECT * FROM user WHERE id = '".$q."'"; $result = mysqli_query($con,$sql); https://www.w3schools.com/php/php_ajax_database.asp
Okay I am more used to using Python and figured out php is bit more specific? So I will let you know what clasList.txt file contains. It has the names of students and their year. Asley, Year One Robert, Year Two Rosalia, Year Two Christy, Year Three Alex, Year One and I want to make First year students to appear with background color 
hire some freelance in upwork 
Hire a freelancer to do a 5 second dns test?.. lul
It seems to be on https ok. Takes ~40 seconds to load though. Specifically: https://www.brominer.com/getSiteStats6.php and https://www.brominer.com/getTopMiners6.php taking between 12-38seconds to ajax in. For me at least. 
Thanks, also the same stats I get. Weird. 
yeah, anyways you can pay them 3 dollars the hour 
It's called supply and demand
I used V1, was a lot of fun. Excited to try v2! Good job Marcel!
Ok this method will not work for you. You need to go back to using strpos. There's no easy way to use in_array with this data, you'd be doing a whole lot more work than you need to in order to try to get it in a format that will work with in_array than to just use strpos.
The core difference between the Phony/Phake/Mockito approach and "expectations", is that with expectations, you are *forced* to assert something whenever you want to change the way a mock behaves: $mock-&gt;shouldReceive('methodA')-&gt;andReturn('returnValue'); The above example is really doing two things at once; making `methodA` return a certain value when called, AND asserting that `methodA` was actually called. In simple tests, this is often fine. But what if you have a really big test suite, with 100 tests, and 50 of those tests will call `methodA`? In a test runner like PHPUnit, where you don't have hierarchical test setups, you now have two options: 1. Repeat the expectation in each of the 50 tests that need it. 2. Put the expectation in the shared test setup, and "override" or "turn off" the expectation in each of the 50 tests that don't call `methodA`. This problem gets worse if your mocking framework makes "overriding" difficult. Then you're pretty much stuck with option 1. In this same situation with Phony, there's no problem. You can "split" what you were doing with the expectation into two parts. The part that makes `methodA` return a certain value goes in your shared test setup: $mock-&gt;methodA-&gt;returns('returnValue'); If a test happens to call this method, it will get the correct value back. If it doesn't, it's no big deal - there's no failure associated with *not* calling this method. And if some of the 100 tests particularly care about *how* `methodA` was called, they can use whatever verifications they like to achieve that: $mock-&gt;methodA-&gt;calledWith('argumentA'); That isn't the only benefit, but it's probably the biggest one. Other cool things that tend to come with this approach include: - Clearer failure messages. - Tests that are easier to read. - Tests that are more robust. It's a pretty tough concept to get across, and I'm sorry that the docs don't do a good enough job of explaining it. A lot of the benefits make more sense in situations like these, where you have multiple tests with complicated hierarchical test setups. It's a subject that probably warrants a whole guide unto itself!
ugh I hate php.. It's good to know that thank you. I don't know why my prof asked his students to use in_array function then.
I’m sorry. I can’t seem to find any errors. Although you may be able to manually do what you want like this. (Not sure if it works) /* $lines = file('classList.txt'); print highlight_string($lines[0], TRUE); // line 1 print $lines[1]; // line 2 print $lines[2]; // line 3 print $lines[3]; // line 4 print highlight_string($lines[4], TRUE); // line 5 */ P.S. Is Asley supposed to be Ashley? 
Dev console in chrome will tell you it in a second
If using in_array is a requirement, it *can* be done, I just think it's much easier to do it with strpos in this case.
/u/mercadoaleman Yep, and they still managed to fuck it up. The one writing that article is a prime example of someone who doesn't know what they are doing. True, they do intval the passed variable but they fail to do prepared statements and thus also fail in passing the variable the right way. Never, ever, use w3school. There is a reason why w3fools.com was originally published.
One thing to look at would be to run your own "cloud" based solution using OpenStack. The mechanisms behind the proprietary vendor locked in way to do the things are really solid, having been battle tested millions or billions of times. They have already solved all the same problems you have. I've been where you have been. For the first 2 billion objects I tried to fight it myself with my small team. When we got to 5 billion objects I realized that there were people in the world who were doing just research and development on just these problems. When I got to 50 billion objects I realized I was insane to have held out as long as I did.
&gt;I don't know why my prof asked his students to use in_array function then. It is hard to guess because we don't have a lot of context, but one way of doing it would be to use fgetscsv $fr = fopen( 'file.txt', 'r'); if( !is_resource($fr)){ exit; } while( !feof( $fr)){ $line = fgetcsv($fr); if( in_array( "Year One", $line)){ // Year one echo "&lt;p class='output highlight'&gt; {$line[0]} &lt;/p&gt;"; }else{ print "&lt;p&gt;{$line[0]}&lt;/p&gt;"; } } That isn't the way I would do it, but it would work using in_array? 
You'd honestly be better off looking at some of the Javascript libraries (eris, or discord.js). 
I feel you. I just use PHP because I like to focus on learning the language more. I came from a .NET software background and have only known PHP for a little under a year. I made a Reddit bot using PHP, despite there not being a current API wrapper in development. I'm considering releasing it. It's essentially a basic wrapper, nothing really extensive. But I have YouTube integrated with it currently, so I figured wrapping Discord support into it would be another cool feature.
Discord.net library is pretty awesome too. Just warning that PHP support in discord isnt the best. I wrote a REST lib that is referenced in the Discord API docs, but it can't do anything like listen for messages. The other Discord PHP library died...
Yeah I've noticed that PHP barely gets any support haha. Even though seemingly a lot of large sites utilize PHP, I find it interesting it's fairly scarcely reported. I'm okay with that though. Gives me more time to learn outside of work haha. I probably won't make a Discord Wrapper, but I figured I'd look at this and see if it makes it plausible. I realistically don't have a reason to make one, while the Reddit bot I use crons to just run the bot for auto-posting and scraping data from subreddits.
Its mostly because PHP doesn't do the greatest in long running environments.
I'm guessing you mean by that is continuous running applications? I've noticed the main ways to 'schedule' events is to, * Cron * Use a sleep timer for however long in an infinite loop. While in C# you can have asynchronous events occurring on timers. 
ReactPHP is the best way to have it continuously running, but a **LOT** of the libraries you might want to use (say doctrine ORM for example), aren't meant to run outside of the Request/Response model. The apps start taking up more memory than they should. PHP by itself uses more memory than most of the other libs.
Ah okay, yeah I noticed that too. I work with large data sets and was astounded when the MySQL PDO results was easily pushing 1.5GB of RAM. Found out PHP5 has up to an 18x overhead on the storage for arrays.... Moved everything to Fetch and calculated everything on the fly, keeping universal data sets to a minimum to store them in smaller arrays and it now uses maximum 400MB of RAM. Some quirks here and there to get used to.
wow amazing.. it actually worked! But only problem now is that I am not sure if I can use this method.. Because the terms that you used are very technical and it's stuff that I haven't learned in class yet.. But anyways I am grateful of your help. Thanks a million.
I created a project using Symfony, well like 5 project actually. But the code is not good, and I think If I had used Laravel from the begin with Mails and Notification and Queues the code now will be cleaner.
Hi there, Just took a glance over this and this is an excellent guidebook! Thanks for posting!
You're very welcome!
Can someone explain what I am looking at here?
It's a horribly bloated convolution around a feature toggle ;-) Martin Fowler has a really good writeup here: https://martinfowler.com/articles/feature-toggles.html And here's a presentation from a tech talk I gave concerning feature toggles and A/B testing. (I'd read the Fowler if you want the most info) https://docs.google.com/presentation/d/e/2PACX-1vQDZonhBUeNtC1NwXZBGHfODyAxj-VQThgRy98oMdvfMlBc_BS36rW3giCAkph6XBGnSPrI7Akk2oF8/pub?start=false&amp;loop=false&amp;delayms=3000 TLDR; parallel development of branching code paths on master. Fewer conflicts, incomplete designs can go out (small pr's), features can be fielded earlier (usually), and your new feature sees the light of day in every other developer's pulls. 
 use NaNaNaNaNaNa\BotMan;
&gt;The other Discord PHP library died... It still works though. I have multiple active bots using it.
That's really not true and hasn't been for ages.
Why would you use doctrine for a chatbot though? Just write to a key value store like redis and if you need persistent/modeled storage have a microservice interface with your kvs.
Why do u need mysqli if there is PDO?
I think PHP for fist language is not good idea. I advice either C++ or Java.
Seems like a whole lot of work for what is essentially an if statement...
My host disabled my account thinking I am some kind of spam, anyhow here is the updated URL http://invatar.ga/ 
I don't have experience with any libraries like this, so maybe this is a stupid question, but, how would one integrate this with a real world application? If using a web framework, would this be placed before building routes then dynamically registering them based on the requestor? Implemented as a system-wide middleware (somehow)? Just implemented for each applicable route?
ha! I think you just summed up the entirety of software development.
In a framework, if you're using DI and a service container of some kind (a few frameworks do these days) you'd wire up a Doorkeeper instance in the container. It'd be up to you to decide whether or not you want to bind a Requestor to that instance or dynamically build them at the call site. If the app has access to web requests and has a single instance per request, it'd make sense to create a Requestor from server globals and go ahead and set it on Doorkeeper. Typically I've still done this in the container as well. Once everything is wired up from there you could *definitely* add something of a middleware if you want to do some sort of branching logic there. I would generally say let the app get built before any feature toggling decisions needs to be made unless it's something of an OPS toggle. You don't want anything weird going on managing states during bootstrapping. I'd push you towards the container though and you can inject it into services, controllers, or business logic or whatever you want! Your app can then tell other apps if features are enabled if you want to build a tiny responder or controller. This can be helpful when coordinating new feature builds across microservices. A few places I've worked before provided answers to our .js client apps so they could have a miniature version of this lib too. It was always in sync the backend. I'm sure a lot of people will see limited use for most applications BUT it's invaluable when you're on a larger team.
For storing anything that doesn't fit into the design of a KV store? There's literally tons of reasons you would want an ORM/ODM with a bot.
For now. When they get rid of the latest gateway, or release a breaking change, the library will be unusable.
So to sum it up. Nobody was able to provide *any* evidence for the old mysql's API vulnerabilities. The only weak link was named is a PHP user, who was unable to grasp the secure coding or invent an emulated prepared statement in their own. The thing that scarcely worked is was to create a religious movement, with its adepts chanting "prepared statement" mantra all day round and hit with stones any heretic that not even disagree but just ask them simple questions. Ironically, this part (PHP users that are en massse driven not by knowledge byt superstitions) remains exactly the same. 
Start with the simplest solution that solves the problem and only add complexity if you realize that the solution doesn’t actually solve the problem. To that end, I’d construct the array manually and have an integration test catch breaks.
I have no idea where you got that part about mysql extension being vulnerable as in having bugs, nobody ever said that in this thread, nor do I know why you're defending it so much lol. About your concerns about prepared statements; It's not a religious movement. It's fact that it's more safe to pass the query in one call and the parameters in the other. There is simply nothing else that makes anything as secure, since the database is "prepared" with a question that **never changes**. You cannot inject into a prepared statement unless there is a bug somewhere. So since you're asking about it even though there is no "security bug", the **key vulnerability** with MySQL extension is simply the fact that it does not offer any security features at all. You cannot make the mysql extension as safe as mysqli or pdo. That's just fact. If you are still using outdated methods and have not yet realized why prepared statements should be used, you should to read up on it. This is no taunt or anything remotely alike, I'm giving you an honest suggestion.
Oh man, I just spawned BotMan to my room because of you!
&gt; That's just fact. A fact is a thing that needs to be proven. Unfortunately, you cannot prove this one. This is all one needs to know about religious fanatics of /r/php. They call their superstitions facts :)
Problem is, when I use it with paragonite/halite it crash on "optimize" task of Laravel Framework (laravel adds "php artisan optimize" to composer post update/install). So i'm using `random_bytes` cause not possible to use it ;)
No, it is a fact. Here is the fact and proof; Prepared statements vs Statements; - Prepared statements are sent ahead of time to the database server, allowing it to compile the question **before** any variables are even considered. The database server compiles and **prepare** a static statement, that **does not** change. Again, this is something that the mysql extension did not support, instead the statement including the variables is sent to the server in one go. One have to rely on proper escaping of certain characters, and always be 100% sure that all characters, including multi-byte and extended charset never cause any problems. Also a bug in any other package or core php extension/feature could lead to escaping these characters might be error prone in different ways. Yet again, with a prepared statement there is no need to escape anything, there is simply nothing in the statement that changes by variables (parameters). - Sending the variables separately to the database. You literally cannot break a prepared statement. You send variables as-is. Most implementations also allows you to pass variables as defined types. - You are literally protected against SQL injection. Unless you, the developer, use user input to structure your statements there is no possible way to inject SQL into a prepared statement. Your argument is about nobody giving you facts about prepared statements being more secure than regular statements. There you have it. If you're going to continue arguing, you need to show how to make a regular statement as secure as above.
I assume that "the code" is the part you made yourself. It would have been like this with every framework if you look back at it. The thing is: what do you learn out of it all? My advice is to program in a framework independent way and have it loosely coupled, so you can always switch to the new flavor of the month without too much damage. But then again, if your code is bad, it will still be bad. ;-)
It isn't. Sure, pdo and prepared statements makes it a bit harder to mess up and forget to sanitize something, but you CAN write perfectly safe code using mysql api.
It's much, much simpler to migrate existing legacy code from mysql to mysqli than pdo.
Legacy it’s other problem) I don’t understand why MySQL users are thinking that it’s ok that php has to support special other package for them. OracleDB, PostgreSQL and other they r good working with PDO, and nobody complains. PDO forces to write right requests then mysqli, in old packages u can write everything what u want, with injections of course. In PDO u can do it too, but it’s more difficulty.
For very simple data structures, an POCO (Simple object with public properties) could be enough. If you need more control about the data use an DTO (object with setter/getter methods). If you need to handle immutable data use a value object (Object with getters, but no setters).
Not sure what the actual point of this post is? It just redirects you to another blog article, that comes down to `php artisan make:auth` ? Anyone who has read any of the Laravel docs will have come across this, and Artisan even tells you of the command in it's listing
There's nothing that "doesn't fit into the design of a KV store". Anything that can be modeled can be put into JSON, which can be transferred by microservice from the KV store. Writing directly to relational storage for this kind of application isn't something you'd do in *any* single threaded language. The worker model exists for a reason.
I know it's anwser for question you didn't ask and offtopic but ... have you seen GraphQL ? There are few good libraries implementing basics written in PHP. 
No, no :) You are confusing *facts* with your abstract musings :) To make a fact you should prove that any code written with mysql ext is not secure. So here is a simple code for you. Find any way to break it, and consider your statement a fact. &lt;?php $db = mysql_connect("localhost","login","password"); mysql_set_charset("utf8", $db); $variable = mysql_real_escape_string($_POST["input"], $db); mysql_query("SELECT '$variable'"); Otherwise it is not a fact but - you guessed it! - a superstition ;) 
Thanks, I'm using the simplest solution, but I feel strong desire to fully understand my options and how my design can evolve in the future, just to feel safe :) .
I have seen it mentioned here and there but never found time to read up on it, I guess it's about time, thanks for the suggestion. :)
In contract to other comments I totally feel you. ;) We used this kind of advanced feature switch at DocPlanner, but we focused more on the UI rather than on the requestor and the rules. [It looked something like this](https://image.slidesharecdn.com/sso-v1-161002195431/95/our-road-to-single-signon-docplanner-52-638.jpg?cb=1475442240). If you’d drop in a Symfony Bundle with an admin panel to manage it, and a simple voter (i.e. `is_granted`…) I would totally use it.
Looks fishy to me...
Yep...nothing actually happens. 
And how is that more safe? What happens if a bug is accidentally introduced into `mysql_real_escape_string`, and you all of the sudden don't escape anything? Imagine the scenario where you accidentally forget to add quotes in your query, or simply don't think of it since you're not comparing a string; `SELECT * FROM table WHERE id = $variable`, or if you use double quotes instead of single quotes? Or someone using your library sets an unsafe character set? You still have not shown a safe way to deal with these scenarios without prepared statements. (Remember, if the database fails to compile a prepared statement, the issue is raised before you even get to pass variables - you cannot execute a faulty statement).
This is a very simple suggestion but I think you hit the nail in the head. I could use objects and then use some sort of renderer service that would render the final array from the main object. That way I would effectively declare structure of every part of my array, could reuse these objects in other responses, and easily make them in sync with capabilities of my React components. This seems simple enough and makes the response more strictly defined. I think this is the way to go, but we will see in practice :) .
You should get an email with a link to download the PDF. If not, just DM me and I'll send it to you :-)
How so? I'm just a software developer who put together a free book. Being transparent here, my goal is to guage interest in the topic. If I get enough people to download the free book, I'm going to make a paid video course series. Just a way to make some money on the side. If you have questions, feel free to DM me!
So you failed. That's a fact. Everything else is your fantasies. I see you are a prolific talker. But in programming, it's only a code, not an empty blab, that matters.
Even the most sophisticated library, framework, application or API is always one character away from total breakage. Don't make things more complicated than they have to be. It's unclear at this point what do you want to eliminate as errors currently. You want to ensure that the arrays you merge in the output are all of a certain format? Then you can assert that, run the output through an assertion that verifies the output is as expected before you send it. Builders are great, but I'm not sure in this case you'd be doing more than adding pointless bloat to your code.
One side note, I must tell you that you got severe problems with your logic.
I turned back as soon as I saw no guidebook and no direct link. You will lose a lot of people because of that. Why not just do a self post and DM the link to people when they comment? Posting a link to a page had me thinking I could look at it directly and see how useful it would be to me. Instead I experienced mild disappointment and left. Just something to think about.
The "company" field made me suspicious so I used wrong email and after a few download buttons nothing happened. After your comment I used an actual email and I got the message and downloaded the book. Sorry for the doubts.
Haha, would you happen to be that "hashtagframework" dude by any chance? :D This is hilarious!
Oh, sorry about that. You can leave the company blank if you want.
Well, it's just an email address exchange. I know I'll lose some people who refuse to give away their emails, but I'll be posting plenty of free blog posts on the site too.
I can't believe this one got so downvoted from /u/scootstah: "I find most of them to be extremely stubborn and stuck on methodologies that are 10 years out of date. Since they're older, they think they are smarter and as such, everything must be done their way. They seem apprehensive about leaving their comfort zone and trying new things." Because, that was exactly my experience. Super-calcified. As a 23-year old, anybody over about 40 fell into the above category. What was worse, they didn't seem to try to learn or change at all, preferring to drag their feet or fight me. Now I'm 48. Shit. 
Failed what? Did I fail to describe the issues with mysql extension to you? If you still don't understand why prepared statements are superior in both safety and optimization, sure - I guess I did.
RemindMe! 1 week "Did this guy push the sources to git yet?"
I will be messaging you on [**2017-10-17 12:07:08 UTC**](http://www.wolframalpha.com/input/?i=2017-10-17 12:07:08 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/73cqwm/demo_random_chance_activity/do5z163) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/73cqwm/demo_random_chance_activity/do5z163]%0A%0ARemindMe! 1 week ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
We got couple little applcations that don't make enough money to be worth updating. So I just added [mysql compat](https://github.com/mattbit/mysql-compat) and they work with PHP7. Bad solution, but cheap.
And check for existence!
&gt; It's simply too many potential human errors with your example that makes it unsafe. I think the difference here is that the old MySQL extension is hands down not as good as mysqli extension (or PDO_MySQL), but I wouldn' blame it is extension's fault people used to use it incorrectly. As /u/colshrapnel showed in the example code, the extension itself can be used securely. Any code can be abused and used incorrectly, that's why I see it that the old extension is not "less secure", but it certainly is less good.
Alertsite is a really great scalable, configurable option. I work directly with the product, so I am a bit biased, but here are two third party pretty in-depth reviews that may help you get a feel for what you will get and what it works best for: https://www.pcmag.com/article2/0,2817,2492703,00.asp?source=autosuggest https://www.discovercloud.com/blog/alertsite-review-a-unified-synthetic-monitoring-platform/ There's a 30 day free trial (and you don't have to put in any payment information) if you want to try it out and see how it works with your performance monitoring requirements. Here's the link: https://smartbear.com/product/alertsite/free-trial/ Hope this helps!
I'm not arguing the extension itself is at fault. It simply doesn't offer the same level of security options, as you too just said. The example he gave is clearly a small and very contained piece of code.
In my PHP Environment I use a lot of proprietary libraries. And when I have a look at their code I would wish that shit like that would not compile. I think the issue is that you can do anything in PHP, where as lots of the shit I saw would not compile in Java. Recent example. A library sends a file hash with every request to the provider server to make shure the API is still compatible. How is the hash generated? There is a comment at the end of the file, which is opened via strpos and file_get_contents(__FILE__). I debugged this because the libary made the old error to close with ?&gt;&lt;SPACE&gt; so it caused output errors. I removed the closing bracket and the version check stopped working because the strpos accounted for the space. 
Assuming the method doesn't do anything means the test is coupled with implementation specifics which may change. Delivering a broken dependency that doesn't implement its own contract properly is a bad way to test if some other component using this dependency follows its own contract. Mocks should be a last resort, this is an absolutely terrible way to do testing.
Bad bot
Thank you jb\_da\_bes for voting on AnimalFactsBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
You failed to prove the "fact" :) And this is the very spot where your logic (if any) is failing you. You are constantly confusing a library with a user. All your examples are about a user, but all the blame is going to the library. You made two false, ungrounded statements, like "Too much vulnerabilities" and "one cannot write a secure code with old ext". Now you started talking about optimization, which I cannot decide whether it's trolling or stupidity. Either way you need to work on your logic. Well, for a PHP user it's quite good but if you aspire to be a programmer some day, buy yourself a book on the formal logic. 
WARNING: Autism follows.
Lol dude, I'm 100% sure you're that hashtagframework dude :D 
/r/beetlejuicing/
&gt; just an email address exchange 
I'll have it a try, thank you very much
I'm more concerned that they want a PHP Dev with C++ and an Android Developer who is also a Product Manager? 
How to learn English and talk good like Wall Street ?
A link to a medium post with a link to another site. I will not go to another site because there is a chance that I will find another link.
If that's your **only** goal then you would just provide a direct download link and not require contact information. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Which site is this.
Okay, I honestly have no idea why that might be happening.
- I knew what the difference between Abstract Class and Interface is. - I knew what HTTP is. - I knew the difference between GET and POST. - I knew HTML &amp; JavaScript. - I knew what AJAX is. - I applied for a job (internship).
Get experience with popular frameworks like laravel or symphony. Get experience with database management as php and database goes together. Make something to show in interviews.
Just because you can, doesn't mean you should. A recent example, is externalizing the cache for large bots (bots on 100,000 servers). If you put all the data in redis, in order to search all users, you would need to pull all the documents out of redis, json decode them, and then search them in PHP. This is incredibly inefficient. Not only would your process likely crash due to memory errors, but the time to parse that many rows would be in the seconds. And to top all that off, PHP would be **far** slower at searching records than say, mysql, or mongo. Even using a micro service wouldn't be that great of an idea, because you are adding extra network latency. &gt;Writing directly to relational storage for this kind of application isn't something you'd do in any single threaded language maybe in a synchronous world. But this is why i suggested ReactPHP. Tons of bots that run on node (which is single threaded, remember), use different types of datastores (relational, document, or key/value). It's all about using what's right for the job, and in many cases, a KV store is not right for the job.
&gt; Symfony So OP isn't confused.
RemindMe! 10 years "Did that moron ever complete the simple task they set out to complete, or are they still technically a failure?" 
Go to local BarCamps or meetups and talk to people! That's the easiest way of getting to know local, small PHP businesses. From there you can acquire knowledge and go on to bigger fish. 
Bittersweet Symfony.
I went to an academy (not uni) in my city and they found me a job for me.
I was hired as a designer then they told me I was a PHP developer. I don't suggest that route. PHP is everywhere. Here are some big name: * WordPress - CMS * Drupal 8 - CMS * Laravel - Framework * Symfony - Framework Do you have a GitHub account? Do you have any work to show? Nothing really different about getting a PHP job over anything else. You need to give the company a reason to hire you.
You are named like french... of course you're supporting symfony framework is good but it doesn't include basic things like orm, timestamps, queues and mails... that's it. Ihave a bunch of commands running as cron job and a spaguethi code between twig and swifmailer messages... 
I'm not a professional PHP dev, but I am professional dev who's only been in the biz for 2 years. My number one piece of advice? Build something. That's honestly the best way. Nobody will know how good or bad you are until you have a large piece of work out there for them to see. When I built my site, I put the code right on the site instead of in a separate GitHub account, so they could just click to see it, instead of having to comb through GitHub code. Also, and this is just as important, know your shit. You can't code everything, but you better be able to answer the easy questions competently.
After you land your first job, create a google reminder for yourself to apply for other jobs after 2 years. The fastest way to get yourself a raise is to find another job. Your current employer will either match it, or let you move on.
jb_da_bes has been unsubscribed from AnimalFactsBot. I won't reply to your comments any more.
Good bot
* Magento (e-commerce stand-alone) * Zend 1 &amp; 2 (older Frameworks, not suggested) * Phalcon (framework)
This looks really good. Currently we have a home brew feature toggle system that gets some settings on user overrides at the database level. Is there an easy way to check the userid against a database?
Came here to say this. Also: Be easy to find. Establish yourself as an expert. Write a blog documenting advanced stuff you learned and used. Be a writer/editor/custodian for a standards organization... I am going to plug OWASP as an example. Make videos of you doing cool stuff-- you will inevitably write example code using volcanoes and gorillas as variable names or something to wrap your head around something new. Screen capture that and pop it on youtube.
There are only about 700 mountain gorillas and they live high in the mountains in two protected parks in Africa. Lowland gorillas live in central Africa.
Didn't know any PHP or database management. Programmed as a hobby since 11 years old. Got hired on as a Tech but they mentioned that they wanted someone with coding experience. I learned PHP and MySQL database management within the first month or so. Created the web app they wanted as I was answering phone calls for tech stuff. At the end of the year they promoted me to their one and only "programmer". Been here almost two years now and I've dived into the MEAN stack, ASP .NET, all sorts of frameworks. I learn everyday even though I don't hold a degree.
Good bot
Thank you Green\_TeaRoll for voting on AnimalFactsBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Top Ten Spam Posts of October 2017 by u/joaopcribeiro Seriously, take your blog spam somewhere else.
Oh like Tarzan's family. neato.
Thanks, I was just about to brush up on my Bethoven's 3rd.
I guess they didn't find anyone else. I couldn't find a job in another language. So, we matched.
Oh cool I always wanted a version of this sub that's 3 months behind
Bad bot
Self taught PHP dev, now working as a Senior Developer. I recruit and help manage a team of developers - so hopefully I can be of some assistance here. As others have said, the big one is __build something__. Anything. Just having a project that is live, puts you ahead of 70% of the applicants. Extra kudos if it's in Symfony, Laravel, or CodeIgniter. Learn your __SOLID__ principles, and best practices. Common technical questions that we use are around this. It shows the good, from the great. We don't expect you to __know__ it off by heart, but a working knowledge of their concepts will 9 times of of 10 get you a second interview at least. But more than anything else, be different. Portfolios are all good, but show some personality. Nobody wants to hire a code monkey, we all want to work with actual people. There's never any harm in contacting the company directly, with some work that you've done. Something along the lines of '_I was on your site, and saw you do XYZ. Here's my portfolio, and some links to my work - maybe we can have a chat and see if I could be of assistance to your development team_'. That shows confidence, and a drive. All the best for the future though, it's a tough industry to get into, but once you're rolling it's brilliant.
good bot
I learned this the hard way. But a great piece of advice. Just make sure not to change too often, else new employers will see you as a risk
&gt;you will inevitably write example code using volcanoes and gorillas as variable names or something to wrap your head around something new ??? Are you serious about this? That is what TheNewBoston does, it makes your code very confusing to follow...
no need to be caustic
&gt; Magento Don't kill the poor boy.
You have to name these variables something, and since you are in the driver's seat-- you get to pick.
It's a fun little joke. But does it not strike you as odd to post a clone of reddit, on reddit?
Ok, but other people will be reading your code if you are working anywhere and won't want to waste time and effort tracking down whatever the fuck 'gorilla' is referring to.
No matter how you sanitize it there will be one more attack vector compared to actually giving the db the different parameters separately from the query.
Thanks! You can ask me for more facts any time. Beep boop.
carlos_vini has been unsubscribed from AnimalFactsBot. I won't reply to your comments any more.
This is your best comment so far. At least you don't pretend saying something sensible here.
Thanks! You can ask me for more facts any time. Beep boop.
Hi /u/Ramakrishnan_S You are providing a tutorial that includes a few SQL injections. You should take a look at http://php.net/manual/en/book.pdo.php, namely prepared statements. The tutorial should be taken down because it promotes dangerous coding practices.
After skipping to an hour in, it's clear that this tutorial is advising people to: 1. Store passwords in plaintext. 2. NOT use prepared statements.
You might be interested in codestop.io for learning PHP. Let me know what you think
Exactly, just because you can, doesn't mean you should. That applies to your original comment of trying to use something like a traditional hydrating ORM with a discord bot. Just because it's done on node doesn't mean it should be. My reply of using KV Store wasn't meant to be a be-all end-all solution, just a point that there are other solutions besides what comes to mind from a traditional request architecture. Resorting to something like direct communication to an SQL Database shouldn't automatically be the default in a rapid response application like a chat bot. &gt;Even using a micro service wouldn't be that great of an idea, because you are adding extra network latency. If your environment creates noticeable latency talking between 3 services, there's a problem with your environment. This is a non issue for a proper deployment.
Doesn't seem like there is a point to continue this discussion. I have real world examples on several bots showing that a KV is not even close to enough. If it is for you, kudos, but its not for a large number of people.
From experience (lots), 2 is the magic number. Less and you draw suspicion. More and you might be considered dated or too "pre-programmed" with habits. In this day, 2 to 3 years at a job is considered the average. Promotions and growth are often few and far between and pensions are nearly extinct. IMHO two years is the least amount of time it takes to figure out your future with a company. 
You didn't even read my reply. Go fuck yourself then.
It isn't that technical, just unfamiliar. I can explain what each line does * 1: Opens file as a readable resource * 2-4: check that the file opened, if not exit * 6: while Not at the end of the file loop * 7: read the current line of the file, separated by commas as an array * 9: Check the line array for the presence of "Year One" * 10-13: Output name Hope that helps you understand it.
1) I did read your reply, and I wholeheartedly disagree with you, on multiple levels. You are blanket statement saying that ORM's are bad, without having any knowledge of real world examples where its useful. You make it seem like everyone who is using them is doing so in a blocking matter, without care of speed or efficiency, but thats just silly. I cache the shit out of my DB calls so i dont have to do them unless i really need to. I also never said that it was a must in a chat bot, but rather something that someone might want in their codebase, but you jumped down my throat to make me look like a simpleton who doesn't know anything about data storage or the issues of running in a single threaded environment. 2) &gt; Go fuck yourself then Awesome reply to an argument. Even if you edited it away, total loss of respect for any opinion you put forth. 3) Just because you disagree with me, doesn't mean I'm giving bad advice. You talk about being full of myself, yet here you are throwing Ad hominem's at me, trying to make yourself look like the better person.
Seriously. If I’m reviewing your code as a job applicant and you have a bunch of goofy variable names I’m going to move right along to the next applicant. 
&gt; Go fuck yourself Just wanted to point out what you posted the first time, before you edited. Go take your ad hominems elsewhere please. The serve no purpose in a discussion. I'd write you a reply countering your points, but you clearly don't want to listen to me. And FWIW, i never said that using a SQL database was a must or a default in a chat bot, just something that someone might want (which, it turns out again, tons of people do)
&gt;I did read your reply &gt;You are blanket statement saying that ORM's are bad Why are you lying, when anyone reading this thread can tell that you're lying? This is very sad.
I was hired as an entry-level PHP/HTML web-dev with basic understanding. Told to install, setup, configure, skin, and debug Magento installs, my life was hell.
Cat facts
Did you ask for cat or dog facts? I'm sorry, if I did cat or dog facts I'd be spamming every thread on reddit. Reply 'more' if you'd like a random animal fact.
Lion facts
If at all possible - suggest WooCommerce. Or really anything else. But Woo is pretty damn solid and easy to work with. If you can't - my condolences.
Nice! The place I'm at now has a similar thing based on an user account. It's limited to that scope. If you want to check a userid against a database I'd say store the feature toggle rules in a table. I opted for something like this https://gist.github.com/remotelyliving/9ab74f5f4976e6dd72e7f00f374f80e4 If you build the Requestor after you've determined if you have a logged in user, it's pretty easy to do a comparison. The rules you store have to spec out the user id. So save a rule on a feature that requires a user id, and when wiring up your Requestor, add the userId of a user if they are logged in and Doorkeeper will do the eval for you. It's really just a matter of config.
The roar of a lion can be heard from 8 kilometers (5.0 miles) away.
Are you a human masquerading around as a robot? Your delayed responses has me picturing someone googling animal facts.
That's awesome...and a gorgeous UI. I'm definitely going to shoot for a Symfony Bundle and Laravel Integration in the future. Thanks for the suggestion!
He's a bot. He posts all day everyday
I think the most important thing is to have example project you've built that you can show off. They create great talking points, demonstrate your technical skill, and show that you have the initiative to start a project and see it through to some level of completion. I'd also agree with the others that you should know either Laravel or Symfony to increase your marketability. To kill two birds with one stone, create a demo using one of those frameworks. As someone that has conducted hiring interviews, here's what I'm primarily looking for in a junior position: * Someone that knows the bare basics of programming (logic flow, functions, code reuse, OO programming) * Strong understanding of Separation of Concerns (which plays into the above). Knowing what spaghetti code is, and why it's bad. * Knowledge of HTTP (what happens, GET, POST), AJAX, and the differences between a single page app and a more traditional website. * Someone that seems like they will be a good fit for our team/company. This means someone that seems passionate about software development and shows some confidence in their skills, but also someone that seems willing to grow and learn. In other words, "confident" but with a dose of humility and without any know-it-all attitude. Beyond that, nice-to-have extras that would make someone stand out are: * Database design experience. Understanding the different ways you can store data and setup relationships, and the trade-offs between different setups. * Strong SQL knowledge. Understanding JOINS, HAVING vs. WHERE, subqueries, aliases, etc. * Knowledge of whiteboarding/user-story mapping/requirements gathering. * Good use of code comments. Especially java-doc style function/method headers that define a contract (see further below). * The ability to think about software in terms of discrete components/classes that interact together to form a system. * Knowledge of the importance of Interfaces (not necessarily PHP specific) in general and design by contract methodology. Once a public interface is released, you can't easily modify it without introducing breaking changes to other code that uses it. This underlies the importance of thinking about the public interfaces in software. * Experience writing Unit and Integration tests. * Understanding of security dangers. Defensive programming. See: https://www.owasp.org/index.php/PHP_Security_Cheat_Sheet For your first job, I wouldn't worry about knowing all the nice-to-have stuff. That's the kind of stuff you learn through experience. The way you dress (nice, but not over-the-top), the demeanor you project during an interview, and work you have to show off will have a much greater impact on your chances of getting a job.
is it ok if I get a link to the site?
Made sites for clients, applied for job with portfolio. 
I proved I could do the work they asked for. I have no degree, nor 'training', I never once took a computing class. I am scientist by degree. My friend convinced me to apply for the job and as I was able to prove the work I could do and had done while also completing the task they set me (Technically set it for myself). Within my first week Id completed my first Magento 1 site ready to launch and worked harder from there. Everyone always gives you loads of tips but the 2 biggest are to have a portfolio of the work you have done and being able to describe and explain the portfolio as well as having a good workable attitude. No one wants a cocky shit, no one wants someone who cannot be told they are wrong or are unwilling to listen, and no one wants to hire a emotionless staff member you cant get on with. 
I started out doing freelance work, then got a job at a company after a couple of years. I was able to demonstrate basic knowledge of current frameworks, database integration, design patterns, the HTTP request/response cycle, etc. I also had live client sites and a GitHub to show off. But I think the thing that cinched the deal was not trying to spin some bullshit. The guy who interviewed before me apparently made a big deal about how he was a database expert, but then couldn't answer harder questions about schema design or whatever. Don't be afraid to say "I don't know". Or even better, "...but here's how I would find out."
What's the difference between Abstract Class and Interface?
As far as the migrations goes, most of the `mysql` functions have an exact `mysqli` equivalent. As such the conversion is pretty straightforwards. Nonetheless, you can *Shift* your way to happiness with the [MySQL to MySQLi converter](https://laravelshift.com/upgrade-mysql-mysqli).
Interface is pure template. No method bodies. Abstract can. Both interface and abstract cannot be instantiated. Both can be singly inherited. 
I'd rather not, simply because it has all of my personal information on it. But it's just a basic 3-page site that has an About Me, my resume, and a page with a link to my github and a way to view the code on each individual page: each page is a link, and clicking it will display that pages pre-compiled code.
Interface can be multi-inherited. But I didn't ask you, I wanted to see what kind of an answer gets one a job ;-).
I only use OAuth2 for obtaining tokens that are stored in the session to provide access to external services... never to be the main session itself. If the session expires, a "remember me" cookie can be used to create a new authenticated session and updated "remember me" cookie... pretty much the same way an expired OAuth2 token needs to be "refreshed".
I wonder if Bob Martin get a penny every time someone mentions SOLID, I wonder? People really feel as if it's some universal law of programming. It has some important ideas, but it's neither universal, nor complete.
Would it involve getting a list of all users toggle settings upfront? Have many millions of users so I'm wondering if this would be appropriate even with caching.
An interface defines a set of public method signatures that an imolenenting class must provide. An abstract class is a class which cannot itself be instantiated, but implements methods that an extending class will expose, additionally abstract methods can be defined that an extending class will need to implement.
Might not help you get a job but still pretty rewarding
&gt; Interface can be multi-inherited That's right, but it can also be singly inherited.
It does, but I think you maybe thinking about it as a toggle for a user...and it is, that's the tricky part. Typically it looks like this: App has features, features have rules, rules can be around a User's id whether or not they should have access to that feature. You don't want them to be too long living. Feature toggles are mostly transient. You put one in, do your work around it, and once you know the other branch of logic / feature is good, you remove it. Ops toggles can be long lived, but probably wouldn't be based on a user, but an `enabled` state. Like, "holy shit, the activity feed is killing the site, let's turn it off right now." I've used feature toggles on sites with upwards of 13 million active users with no issue at all. If you're looking to partition users into a group that can use certain features in a long lived situation, it might make sense to implement a 'settings' type object for each user, or subclass your typical user like class PremiumFeaturesUser extends User {} or something like that. Is that helpful? I apologize if I'm still not getting it. 
I began with HTML in 1999, I found the ability to view source and began figuring out what each tag did by trial and error. Then I began learning CGI/PERL, made my early websites in that. I signed up on Elance via an ad on eBay (I think), and began working on small print/graphic design projects. A few years later in 2004, the owner of the commercial printing plant asked me if I can create a shopping cart system for the American Cancer Society. He knew I was working on my websites after hours at work, so he figured he'd ask. I told him, "let me figure out what would be needed", and did the research, learned about online merchant accounts and payment gateways, reviewed shopping cart systems, and put together a solution the next day. We went forward, and with no PHP experience, I began working on the website and had it all together in a couple weeks. After that, I decided to go self-employed and using my existing company name that I established 5 years prior, I launched my own retail website to sell my own political product, mirroring the work I did for the ACS. It was a success, I ran ads on The Onion's leaderboard for $1000 and their NYC and California papers, had Richard Prior order some products, and managed to make good money packing orders for a few minutes every day and sitting back and relaxing. This windfall lasted a good 2 or 3 months, but then sales slowed, and I was forced to find more work. I went back on Elance and began bidding on web development projects, and since I didn't have confidence in my level of expertise, I sold myself cheap - way too cheap. I worked for several months on a project which was paying minimal, and scraped by. I eventually realized it was toxic, especially with the website sales pretty much dried up, and distanced myself from that client and began other projects. By that time, I had learned a lot more and over the next several years, I tried doing ASP, Java, CGI/PERL, and PHP projects, as well as graphic design/print work from time to time. I learned that I hated ASP, love Java but wasn't experienced enough to make money with it, and CGI/PERL was taking a far backseat and PHP dominated my work. I began getting lucky and having large clients bubble up through the crappy projects on Elance. I eventually began working for the PCI DSS website via intermediary company, adding the first line of scripting - they previously only had straight HTML pages. For three years, I worked on demand for them, as well as other projects, but eventually, they wanted a complete overhaul and went with a different provider. I then had another great client come along that needed a complete overhaul, worked hourly for about 3 years, as well as taking care of other projects until we entered an dedicated work relationship in which they were my only client (big mistake even though I would only do it at 125% my normal rate). The manager of that company wasn't the sharpest. He claimed to be an SEO expert and was telling me to set the robots.txt to "User-agent: * Disallow: /" which would block all search engines. I told the manager guy that it was wrong, but he wouldn't hear it. Having previously worked directly with the company CEO, I let him know that this guy wanted to do this, and the CEO said, "let him fall by his own sword". Sure enough, days later, all the site links began disappearing, and I alerted everyone. He got canned, and the dedicated agreement that he brokered with me also came off the table, and the CEO decided eventually to do a complete rebuild with a different company. Notice the "big mistake"? In being dedicated to that one client, I distanced myself from my existing client list. Telling a client that you are not available is basically saying, go away and never come back, as they more than likely will find another provider to get their work done, and usually if they do well enough, stick with them. So, I've continued to find greater work, but a couple years ago, a severely troubling developed with Elance came about - they were acquired by oDesk and eventually merged in to the horror show that is UpWork. With Elance, originally, you could have clients pay you directly, then report your earning to Elance. They did away with that, which was fine, and all processing was through Elance. They charged a sliding rate of 6.75 to 8.75 depending on your earnings, and things were good for about 13 years for me. Then with the UpWork merge, they bumped up the rate to 10%. I grumbled a lot about it, and voiced my opinion on their message boards. They also had in place a ridiculous payment system. Basically, a client releases funds, and then they are held for 10 days before they are available to withdraw. Once withdrawn, they transfer takes 2 to 5 days in the US (depending on weekends, bank holidays). With Elance, there was no hold on funds. Being a provider for 13 years, I would expect some level of trust and this BS hold not be in place, but no UpWork didn't care. So, things got worse. They gleefully announced that they will be charging 20% fees on all projects for the first $500 per client. So, if you do lots of smaller projects for various clients, the fees would be 20% for pretty much ALL projects. Worse, they also decided to add a transaction processing fee on top which the client pays outside of the bid. Now, if you wanted $100, the client is charged 25.58% in fees, so $125.58. I was disgusted by this price gauging and left UpWork behind. What does this mean for you? Well, my suggestion would be to churn work through a website like Elance, but it doesn't exist anymore. So, you can try your hand at it with Guru or UpWork, build up clients, and when exclusivity periods end (UpWork has a 2-year period for all clients *first contacted through UpWork*), take them on as a direct client. Do good work, build a good client list, and stay busy. If you want a position for an employer rather than going solo, do just enough freelancing to get yourself confident and have a proper portfolio to shop yourself with to prospective employers. Honestly, being self-employed is dangerous. You have all the potentials to succeed and fail rolled in to one large mess. If you do decide to try and go independent, try working in a retainer agreement with your clients to have a regular income base coming in. Retainers can be in two flavors, one is payment as credit towards work, and the other is for retaining your services only. Personally, I would suggest getting real familiar with Wordpress. Code some plugins and themes - you will find a wealth of Wordpress based projects for the 7+ million Wordpress websites that are live out there.
Yes, PHP won't crash if you inherit just one. What an amazing insight.
That's crazy dude. How did you figure all that out?
It doesn't debunk the fact that uber engineers decided to switch. I switched back and forth a few times chasing new features in the last 15 years... but now, they both have pretty much all you need. It's just a style preference.
It all started when I was researching the question I need to get a job...
Thank you for the explanation. My current system is basically a FeatureToggle class that can check if a feature is enabled or is enabled for a user. In our implementation it will check config files or database for the global value (on/off/100%/etc). There is a concept of user overrides in our system, so you would pass the logged in user (or other user in some cases). This checker method will query the database to look for an override for that specific user. Our backoffice people will toggle on off certain accounts to test features for example or we may just do things based on environment for other features. What feels like I am missing is how to implement the overrides for specific users in your lib. 
I think that would place pretty high in the 'SFW subreddits that sound NSFW' rankings.
Weed.
All my code uses the industry standard of $foo, $bar, $baz, $qux, $quux, $quuz, $corge, $grault, $garply, $waldo, $fred, $plugh, $xyzzy, and $thud.
I never follow it as a strict rule, they're not laws by any means. However, it does give a good approach and teaches very good practice. They're principles and I'll always use them as such. I've worked with people who use them as universal laws as you've said, and it was a nightmare. 
I'd have to agree with all your points there in all honesty 
OK, meant the extending class can using a single interface as opposed to traits. An extending class can implement multiple traits but only implement one interface at a time. Is this wrong?
Weed || phpdocs
Yes: - A class can extend only one other class. - A class can use many traits. - A class can implement many interfaces. - An interface can extend many interfaces. That's a really cool property of interfaces, and the primary reason why they're useful over abstract classes. I'm glad you get to put this on your arsenal today. :-)
Gotcha. Extending is different from implementing.
If you can write your tests without needing mocks, that's great! People who aren't there yet (lots of people) still need tools to get their jobs done. After all, in the original comment, I only said that this was useful, not an ideal situation. I also think you missed the key word "forced". When you're not in control of the interface you're testing, e.g. writing a plugin for some third-party framework, lofty design goals often have to take a back seat to pragmatism.
Well... not exactly. An interface can extend many interfaces, as noted above. Extending is implementing, actually the only distinction is syntactical. Some languages don't even make the distinction, for example, in PHP you'd write this: interface Foo extends Bar, Baz {} class Foo extends Bar implements Baz, Qux {} In C# you'd write the same as: interface Foo: Bar, Baz {} class Foo: Bar, Baz, Qux {}
If you want to be pragmatic, you can skip writing tests. I don't see how writing bad tests that aren't very useful as tests counts as pragmatic.
Amazing. So ABSTRACT | Cannot | Method | Single | Instantiate | bodies OK | child INTERFACE | "" | Method | Multiple | | bodies NO | children TRAIT | "" | Method | Multiple | | bodies OK | children
Good software follows those principles. Simple as that.
Believe me lots of bad software also follows those principles.
"Single child" and "Multiple children" is not the right distinction. A class can always have multiple children, but it has only one parent class. There's also another distinction - traits are not types, so they don't participate when you do "$obj instanceof TraitName" on an object using a trait. So this means the "Liskov Substitution Principle" doesn't apply to traits.
??? Reading between the lines or picking up nuance isn't your strong suit, is it. Yes, when I am writing code that has no bearing on the actual prod code-- I enjoy myself, I do whatever I want. I make a library have the outcome I am seeking. I suppose I didn't explicitly express that after doing exploratory work then I pop it into the the code base and do my best to fit it into the existing variable naming pattern... but maybe that is on me for implying that my practice code and suitability work is something I have fun with and enjoy doing.
You forgot $var and $a, $b,...$z. 
Github, My current job the interviewer told me my CV is shit, the only reason I got the interview (and i got the job) was through the code I had righted and my contributions.
What? lol
Very nice though it requires php 7.1, yikes. Any particular reason you are strict on types? w/o it this would work in older versions, correct?
Put PHP on LinkedIn. Close pc for the night. Respond to one of the hundreds of recruiters who messaged you last night. 
sucking dicks
I tried with adding '"' as $enclosure but is the same
Where I am from there are only PHP jobs when it comes to the web. And they take _everyone_ but keep only the ones who prove themselves to be worthy after a few months.
neither with "\"$startDate\"", what it seems to work is " $startDate " because of spaces, 
http://php.net/supported-versions.php PHP isn't a fine wine. 5.2 isn't getting any better.
Depending on the particular flavor of CSV, you double them and force start/end quotes. Easy way to test/demo: $ php -r "fputcsv(STDOUT,['test\"test','\"']);" "test""test","""" $ 
I learned it at a part time IT job (they had a small website) while working towards a "CS-related" degree, then went to a PHP startup after graduating. My biggest caution is that there's a lot of ugly old PHP code out there which can end up teaching you bad practices -- or at least not help you with good ones.
There's no standard -- are these files only being made/consumed by PHP code you control, or are there other systems involved?
If you have a bhndh or procedural code written in MySQL, then rewrite it. Don't want to rewrite, then you have a choice to stay with php 5.
Only the most pedestrian of plebians is still using anything other than 7.1.
Seems like you conflated ACL with feature toggles without either realising it or declaring it.
&gt;There are a few feature toggle frameworks and libraries out there already. None cited.
I could tell you, but I'd have to kill you.
What the fuck are you even saying to me? Are you a bot?
uh, what?! Upgrades take time, especially in enterprise environments (I know, php in an enterprise environment...)
http://lmgtfy.com/?q=feature+toggle+php
Nah. Feature toggles are transient. This has nothing to do with roles or permissions...or the ability to perform an operation on a resource as a 'type' of user, just a specific user. This isn't for controlling access to resources. Now is a feature a resource? It's not an entity, so you can cross that off. You could say there's so overlap here in that an ACL would allow a user to access a feature like an admin panel, and so could a toggle, but again, we're not caring about user type or role here. Just specific users...and again, the toggle, if you read the Fowler article, is mostly transient. ACL usually hangs around a concept...
I want to be comma separated values but I also need the enclousure to be always present like "aasd", "10", "f", "asd asd" 
Exactly how much time are we talking.
That's the cost of the router in that regard, it hits the database at run time to build the Requestor if you choose to use it. Chances are you're hitting the DB anyways to set the app user? I mean, however, and wherever you determine you have a logged in user at app spinup time is the place to create your Requestor too.
Using technology has nothing to do with religion. If you don't want to use a database feature such as prepared statements that's fine. But it's also fine if all the other devs who see your code then literally throw their shit at you.
Righto champ.
The point of _good_ software is not that you _can_ make it work but that it is hard to break it or make it work in the wrong (i.e. insecure) way.
It’s going to be different for everyone, but started learning assembly (AS86) and Visual Basic and T-Basic (so I could cheat in class or make games on my TI-83). Then started learning HTML from just looking at source code and then CSS. Was (and still am) self taught. Picked up CGI/Perl and finally PHP 3 (so 23+ years coding in that alone). Did freelance because I was young and the industry was immature. Went to college for a CIS and business degree, dropped out, started a web hosting company and picked up DBA and Sysadmin skills. Used WordPress a lot initially, building custom frameworks, then CodeIgniter, and finally Zend and Symfony and Laravel (use this exclusively). Along the way picked up JavaScript, jQuery, and Bootstrap; but now use Vue and Bootstrap or Foundation (specifically for emails). Went from jobs as low as $50k to $150k+ all with different titles (essentially doing the same thing though). Now I’m a Senior Software Engineer and focus on all aspects of development (so a full-stack PHP developer basically). Jobs were always found via CyberCoders or AngelList or Ladders, Larajobs, and once via Stack Overflow.
Same reason Doctrine did the same. http://www.doctrine-project.org/2017/07/25/php-7.1-requirement-and-composer.html &gt; One question we frequently hear is, “isn’t dropping support for a PHP version a BC break”? In a nutshell, no. A BC break happens when there is an incompatible change that your package manager can’t handle. For example, changing a method signature in a minor version is a no-go, since the composer version constraints mentioned above assume any minor upgrade can safely be used. &gt; However, when we drop support for an older version of PHP, composer will not consider the new version if the PHP version requirement is no longer fulfilled. Thus, you won’t end up with a fatal error due to a wrong method signature, you just won’t get the new version.
Since CSV is [defined](https://tools.ietf.org/html/rfc4180) in a way that double quotes are __not required__ you are actually asking for something that is __not CSV__. To be more precise, you are asking for a subset of CSV - for which the only use case is that the parser on the other and is just _wrong_ when it was intended to parse actual CSV. Your options at this point is to either implement your own CSV encoder or perhaps use some intermediary Python script (considering Python is available on about every Linux system and its default CSV library has an option `QUOTE_ALL` - [manual](https://docs.python.org/3.6/library/csv.html)).
I need to work with an in-game date - that is a date based on the actual date except converted to game time. ("Year 5, day 12") except for example years progress independently of real life years. I shouldn't have any problem with the logic, but just wondering if there was any "gotchas" or libraries that who have worked with a similar situation could advise on?
Looking at the CMS currently available all are a nightmare when it comes to either/or: * regarding usability for editors * complexity (for everyone) * extendability, interoperability - leading to high costs * maintainability and by extend safety and security - often making it hard to keep a system up to date * performance, duh (often "solved" by caching but some don't even offer caching) And the frameworks basically all try to imitate Ruby on Rails or Sinatra.
hahaha just realised the miscommunication here. Assuming you did not mean to be an asshole when you said *`the self-proclaimed expert`* and it was merely in response to *`(I know, php in an enterprise environment...)`* Please re-read *`(I know, php in an enterprise environment...)`* and realise there is a **comma** in there. In case you don't realise the difference, I am scoffing at php in an enterprise environment, which no doubt will bring a whole lot of hate all on it's own down on me -.-
Interestingly enough, people seem to mirror my experience. Quick bullet rundown, * Taught myself VB6 using StarCraft: Brood War bot source code. (10-12 years old here) * Taught myself .NET using documentation (computer was shit). * Got a better computer, made .NET applications in VB.NET for a few years, taught myself C#. * Dabbled in Java, Python, and F#. * Created a fairly successful web forum and used that on my resume. * Posted my Resume to Indeed, and it was honestly a jumble of shit. I figured that I wasn't really looking for a job atm, so I'll just post *all* of my experience. Was like 3 pages long, most catered towards IT work (wanted to become a sys admin). * Current employer contacted me about becoming a fullstack dev, he liked what I had on my resume (I had a ton of examples). He asked if I knew PHP, I said some. I went through 4 interviews. Currently in this position, zero college experience and been here for about a year at under 25 years old.
Normally about 10 years.
Create your own projects that showcase your skills. It shows what YOU can do. I made a big system in laravel which landed me an awesome dev job. If I didn't have that system they wouldn't have hired me because I look like shit on paper. But since they saw what I could do I got it :)
Adhering to SOLID won't guarantee your software to be good, but not adhering will definitely guarantee it to be bad.
&gt; Told to install, setup, configure, skin, and debug Magento installs, my life was hell. I went through similar, it left me shell-shocked. :(
I never wanted a "job". Web development has basically been my life. Let me preface by saying I live in a smallish city, in the middle of the Canadian Prairies, where there isn't much opportunity for this kind of work. Taught myself HTML when I was young (less than age 10). Through grade school experimented with Java Applets (remember those?), Javascript, Flash/Actionscript as the technology evolved. Taught myself Perl, how to structure data into flat-file databases, then eventually moved into SQL (MySQL), and then eventually found PHP. By grade 9 (high school, aged 14) I was building full Content Management systems and selling my services. This continued throughout high school, making money. Actually moved out of my parents house at age 16. Finished high school while supporting myself buildinv websites and small, basic web based applications. After high school (age 18) I got a day job doing graphic design for a local advertising company, but still doing web design on the side. That job lasted about a year before the company collapsed. After working a few other day jobs (including a short haul delivery driver, locksmith, security system installer, and so on), I decided I hated working for other people and my business was doing quite well as a side income, so I quit my day job to focus on my business full time. Fast forward a couple years, plus a marriage and two children later. In 2013 I bought a small web hosting company. A couple of the clients were development clients of the previous web host's. They had built web applications in the early 2000's in Perl. After a few months of taking over the reigns, these companies approached us looking for modifications to their applications. We did, and billed accordingly. A few months later one of the companies wanted a new application built from the ground up (which we built in PHP). And then another, and another. Now we're in a position where we are paid well to maintain these applications going forward, and are back to also building some new projects to scratch our own itches. I'm currently in the process of starting a VOIP company for my local area (CLEC), but that's for another sub. I guess the point of my ramblings is that while I know many people are comfortable just obtaining a job, you may want to also consider finding your own way. It's /very/ satisfying.
Why you all cannot follow a simple thread and make a relevant comment? Nobody is talking of the technology here. One not very smart zealot made a stupid statement, "old mysql ext had a lot o vulnerabilities". I merely asked him to name one. Nothing else. This topic is not about using prepared statements. It's about vulnerabilities that do not exist. It's about logic and knowledge. But it's hard to expect both from a typical PHP user.
You see, when you spend something like 20-30 years in software development, you'll find out there are more rules to good software design than SOLID, and you'll discover that sometimes all those can get in conflict. You'll also realize that some of these principles are highly subjective, and especially in the mouth of an inexperienced developer they're just a bullet, ready to shoot anything down. If I had a nickle for every time I've seen or heard someone say to someone "that's a violation of the single responsibility principle" I'd be a billionaire. Give me any class at all, *any class* and I can instantly figure out a way you're "violating the single responsibility principle". The same applies to the "Interface Segregation Principle" which is just "SRP for interfaces", and I suspect Bob Martin threw that one in so he can make SOLID a nice acronym. Or how about Dependency Inversion. First, if you're the average developer you can't tell the difference between Dependency Inversion and Dependency Injection. Second, it's literally impossible to write a useful piece of software where every dependency is inverted. Inversion is a recommendation with specific properties, which recommendation you're to take or not take depending on the context. Or let's talk about Open/Closed principle. Again, most developers can't even agree what it is. And when we agree what it is, we realize the original definition (involving inheritance) is absolutely outdated and irrelevant to the modern OOP practices. And it's again highly subjective. You're unlikely to *either* open everything for extension, *or* close everything for modification. It's always a balance brought forward by requirements and experience. So. Bottom line. To say "not adhering will definitely guarantee it to be bad" is to demonstrate how little you understand about how contextual and subjective these rules are. The **only** rule in SOLID that has a relatively objective meaning, is the Liskov Substitution Principle. That's one out of five. It's the only rule you can really "adhere" to without everyone having a different opinion about what "adhering to" means (technically even this one has edge cases, but let's not get into it). But as I said, rules are for the guidance of wise men, and for the obedience of fools.
ehm... it is based on the real date except it progresses on its own? That is a contradiction.
So days and time progress at the same rate as a 24 hour day. But years will progress faster than normal years, except not all years will be the same amount of days. Which just makes the logic slightly more complicated :)
Do you want full error report in PM ? I tried some tricks to check if it was from paragonite/RandomLib itself or dependancies. It's from the lib itself. All dependancies working great. I'll prob continue to try to sort it out when I'll have more time :)
So, when I leave the game active, the date will proceed as normal, but when I close the game and return later, then a year can have passed? It is only the year that goes quicker? Would I return to the same date as last time but in a different year? I think, this still makes no sense (at least to me). 
I like the look of this! It would be good if it could take test coverage into account. For refactoring, I tend to be guided by the CRAP score, which helps to locate complex, untested code. It would be great to have a CRAP score which includes churn as well. Perhaps a CRAPPER score? "Change Risk Anti-Patterns / Probably Endless Revisions"
The amount of comment you get on your examples, it may be worth your time yo just write better examples.. :)
Sadly, it's tutorials like this that cause PHP to be looked down on as a programming language and perpetuate bad practice among new developers. But it does explain an awful lot about outsourced development quality. 
I started off as a junior in a marketing agency. I worked on small handmade websites and WordPress websites before changing jobs to work on one large SaaS codebase. The marketing agency work isn't great, but they're always looking for PHP developers. It's easier to get your foot in the door in those places because management don't really know anything about interviewing.
For a moment I thought this is very useful, until I realized it's just basic comparison of the two dates within. So I'm wondering, if the value of this class is sufficient, if all it does is &gt;, &lt;, &gt;=, &lt;=, ==, on the timestamps of the two contained dates? It becomes particularly tricky if you have business rules like "if two periods are interrupted by at most of 30 minutes, then they're considered to meet each other". Or how about "if the end of A and start of B at *on the same day* they are considered to meet each other". There's no convenient way to encode rules like this and still maintain a neat set of universal methods.
Ah - that's great to know .... thanks :)
It hurts me how true this is. Can I create a reminder in my boss's calendar? 
Library should support the iso8601 formats https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
That's literally two ISO8601 dates with a slash between them, so what does it mean "should"? When was the last time you needed that format for *anything* and did you have a great difficulty rendering two dates with a slash between them?
This is what happens when you take PSR recommendations 100% literally. Rules are for the guidance of wise men, and for the obedience of fools.
Hey, thanks for the feedback. Adding granularity (see the "How it works" section in the readme), as you suggest, should not be very difficult and I agree it would definitely increase usefulness. From the top of my head granularity could be a 3rd argument to creating a DateTimePeriod. Regarding comparison, my main goal was to implement the basic predicates from Allen's interval algebra, as relations on intervals are not as simple as &gt;, &lt;, &gt;=, &lt;=, ==. You can read more about it here: https://www.ics.uci.edu/~alspaugh/cls/shr/allen.html P.S.: username checks out ;)
Thanks for the feedback. Do you mean the ability to create a DateTimePeriod using ISO 8601 intervals? If so that should be fairly easy to add.
"There are four ways to express a time interval". It should because it's a world and enterprise standard. The support of standard is that makes a library is good but not "another one".
&gt; "There are four ways to express a time interval". It should because it's a world and enterprise standard. The specific DateTimePeriod takes two dates, not a Date and an DateInterval, so the only correct way to express that period is with two dates, anything else would be just a cargo cult implementation of the standard, that's subject to incorrect interpretation on the other side. So only one of the four ways applies. &gt; It should because it's a world and enterprise standard. There are countless standards for everything, most of which you've never heard of. I'm asking again, when was the last time you had to pass an ISO8601 interval to anything?
You should indicate at the top of the README that the library implements Allen's theory, because the definition of _starts_, _finishes_, _overlaps_ and others is quite different from what one would usually expect (by example, a [common definition of overlapping events](https://stackoverflow.com/a/325964/4990350)).
Nice tips!
My recommendation is for you to approach a non-tech company who is looking for an in-house PHP developer. For example, my first PHP job was with a food manufacturer who had been outsourcing their Magento work to a small, crap company. They wanted to grow their website and thought it to be more efficient to just hire a developer. Me being the only PHP guy in the company bought me time when it came to learning curves. My performance could be based on site improvements and the improvements we saw in the metrics we measured. It's a bit of a niche to hope to get into, but shop locally and I'm sure you can find something. What was key for me: 1. Non tech company 2. e-commerce website - much easier to measure your value and ROI here 3. Reviewing analytics and being proactive with my suggestions for improvements Just a note, I did my best to be proactive when it came to pushing the website to the next level in terms of e-commerce features as well as teaching myself industry standard tools along the way (Git, docker, AWS, ...). Due to the results of these efforts, one job later, I'm able to negotiate salaries starting at 110k in an area that is paying significantly less, on average, for PHP folk. 
Just thinking a bit about this, one could easily do the following: $hourGranule = 'Y-m-d\TH'; $a = new DateTimePeriod( DateTimeImmutable::createFromFormat($hourGranule, (new DateTimeImmutable($aStart))-&gt;format($hourGranule)), DateTimeImmutable::createFromFormat($hourGranule, (new DateTimeImmutable($aEnd))-&gt;format($hourGranule)) ); $b = new DateTimePeriod( DateTimeImmutable::createFromFormat($hourGranule, (new DateTimeImmutable($bStart))-&gt;format($hourGranule)), DateTimeImmutable::createFromFormat($hourGranule, (new DateTimeImmutable($bEnd))-&gt;format($hourGranule)) ); assert($a-&gt;meets($b) === true); // a meets b by the hour granule $minuteGranule = 'Y-m-d\TH:i'; $a = new DateTimePeriod( DateTimeImmutable::createFromFormat($minuteGranule, (new DateTimeImmutable($aStart))-&gt;format($minuteGranule)), DateTimeImmutable::createFromFormat($minuteGranule, (new DateTimeImmutable($aEnd))-&gt;format($minuteGranule)) ); $b = new DateTimePeriod( DateTimeImmutable::createFromFormat($minuteGranule, (new DateTimeImmutable($bStart))-&gt;format($minuteGranule)), DateTimeImmutable::createFromFormat($minuteGranule, (new DateTimeImmutable($bEnd))-&gt;format($minuteGranule)) ); assert($a-&gt;meets($b) === false); // a does not meet b by the minute granule Meaning the same 2 periods meet on a timeline with hour granularity but does not meet on a more fine-grained timeline with minute granularity. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Good call, will do. Currently the link to Allen's Interval Algebra is in the "How it works" section.
Thanks for your reply. I had another moment of thought (username checks out again!) and I think I realize what bothers me, it's the fact that the period is encapsulated in an object. I think the object is what I find is not justified, not the comparison methods, which are handy on their own. I.e. the aggregation of these dates into objects should probably done at a higher level, for ex. "$meeting-&gt;getStart();" and "$meeting-&gt;getEnd()". With DateTimePeriod being a class, we have several choices. **1) Inheritance.** If we use inheritance, this means class Meeting can't extend anything else, so this is very inflexible. Also it precludes the opportunity for one "$meeting" to contain two or more periods, for whatever reason. **2) Composition.** This is better, but it results in extra verbosity, and inconvenience, as DateTimePeriod seems immutable, and the dates inside are immutable - we know that working with composite immutables is very uncomfortable the deeper they go. I.e. where I'd do this with naked DateTimeImmutable: $meeting = $meeting-&gt;withStart($date); ... I'd need this instead, if I use composited DateTimePeriod: $meeting = $meeting-&gt;withPeriod(new DateTimePeriod($date, $meeting-&gt;getPeriod()-&gt;getEnd())); **3) Use it apart as a manipulation-only object.** The third option is to use DateTimePeriod as a manipulation object, which means it's not part of your entities, or value objects, but you construct it ad-hoc as you need it, and dispose of it after you run the needed comparisons. In this case, again, it just seems to add verbosity over what could be a set of static methods: // Using a manipulation-only object: $period1 = new DateTimePeriod($meeting1-&gt;getStart(), $meeting1-&gt;getEnd()); $period2 = new DateTimePeriod($meeting2-&gt;getStart(), $meeting2-&gt;getEnd()); echo $period1-&gt;overlaps($period2); // Stateless static methods: echo DateTimePeriod::overlaps( $meeting1-&gt;getStart(), $meeting1-&gt;getEnd(), $meeting2-&gt;getStart(), $meeting2-&gt;getEnd() ); I understand the balance in the latter example tips towards "too many arguments, man" but I feel in this particular instance it remains clear, and results in less superfluous code and memory churn.
&gt; Do you mean the ability to create a DateTimePeriod using ISO 8601 intervals? yes
Unlike most things advertised in this sub, this seems worthwhile, although I eschew the default of 10 parallel processes because that shit really churns up my HDD.
No link... 
I know, I have missed it the first time so the methods did appear very strange to me :)
Thank you for your feedback!
Web Design Houston offers cost effective and custom PHP application development and maintenance services. We are Open source Content management system CMS specialist."
Let me guess, this "Houston" company is actually based in Bangalore, right?
How did you guess? 
Given that every day this sub is spamed with ads of Bangalore based dev companies, it's hard to guess anything else. Oh, and a grammar also.
I'm already amazed you need 4 articles just to explain a deploy.