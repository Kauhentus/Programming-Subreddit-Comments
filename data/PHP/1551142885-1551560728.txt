This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Can you share the `composer.json` file?
Use shared folders for vm. It will solve all your problems regarding the IDE and env.
Could you use a model as a read-only? &amp;#x200B; Let's say you're reading aviation weather... you can't write it back to the FAA server, but you can read it and process it.
I like using array_map and array_reduce over foreach when I need to map or reduce an array, just because when I see either of those functions, I immediately know that the input is not simply being iterated, it’s being transformed. I feel like it does a better job of expressing intent. With a foreach, I have to look at the loop to know what it is doing. But that’s just my two cents 
Laravel is actually where I'm coming from, asking this question! My assumption is that Laravel tightly couples models to the database because realistically, the *vast majority* of cases where one uses a model, one is using it to represent a database row - particularly in a web application. I would view it not so much as anti-pattern, but an understanding of the context in which the framework will be frequently used - the edge cases can either fend for themselves or find a framework that better suits their needs (which I may have to for the implementation that prompted this question!). Thanks for the response!
TIL that creating a DB table wrapper is a pattern all onto itself. Every time I hear of a new "pattern" I am more and more convinced people are just making up buzzwords to fill their books and blog posts for the most trivial and specific things. Oh look, wrapping a DB table with a class? ActiveRecord pattern! Writing a class to handle DB related operations like access, handling results, etc? Data Access Object Pattern! (I literally googled this name by the description I just wrote) Writing a class that has only one output function? Single Output Object Pattern! Writing a class with 2 variable members and 2 functions, that extends 2 interfaces? TwoTwo Pattern! The more patterns I hear about, the more of them I find to be spam not worthy of wasting my time reading about, not to mention making up names for.
PHPStorm uber alles. Although VS Code will do, with some addons like PHP Intelephense and PHP Formatter
I wrote a pair of models today that are exactly what you described, I have a request model that takes some input and prepares to pass it to an API and a response model that takes that response and transforms it into something more useful than xml
Most of the aforementioned patterns aren't new, and as far as I remember, they originated in Martin Fowlers excellent book, Patterns of Enterprise Application Architecture which was written 17 years ago. 
If you're on windows that's the problem. For real, on the same machine here, composer on Linux is even faster on an HDD then on Windows with an SSD.
Not sure why you are getting down voted. It's been a while since I used CI, but it wasn't bad back in the day. Laravel is just full of magic and anti-patterns.
&gt; And then this token can be used outside of the client-side front-end. I'm not sure i follow sorry the quoted text is perfectly valid and secure, if someone wants to generate a login token with my api layer to use it as a service they can go and to it. You just throttle peoples use to the rate at which you whish to accept them.
I would say it's a matter of a habit. Personally I prefer an explicit loop over a function, because for me it's more readable, with every part written distinctly - here is the loop, here is the payload. But I see many people are comfortable with functions - so why not? 
Speaking of the preference, I would say it's a matter of habit. Personally I prefer an explicit loop over a function, because for me it's more readable, with every part written distinctly - here is the loop, here is the payload. But I see many people are comfortable with functions - so why not? However, speaking of performance - the moment the difference between a function and an explicit loop will become a bottleneck for your application you would know it's time to move the resource-hungry parts to another language. The test by the link is the same pointless shit like [one I reviewed recently](https://phpdelusions.net/articles/single_vs_double): any performance test taken out of the blue, without any sensible payload and in the conditions unnatural for PHP is a waste of time. The time you wasted on making this test is a multitude bigger than you ever will be able to save applying its results to the code. 
&gt; I'm not sure i follow sorry the quoted text is perfectly valid and secure, if someone wants to generate a login token with my api layer to use it as a service they can go and to it. Yes, but OP specifically wants to prevent this.
PHP isn't ideal for this type of programming. More ideally, `walk`, `map`, `filter`, and `reduce` would be method-like-- that's not really the point, though: 1. array_map, array_filter, array_reduce, and array_walk are more functional ways of dealing a list of values. 2. Abstracting away the loop into a function enables more robust implementations. --- You mention making functions that can just do a foreach loop, but when you already have functions that deal with the arrays-- the functions can focus on values, and those functions tend to be more reusable than the looping ones, e.g: array_walk($words, 'strtolower'); --- Procedural loops, like in PHP, execute from beginning to end. There's no other way to interpret the code. There is an expected order to iterate over the array, only one iteration/transformation is executing at a time (usually on the same machine), and the loop may be broken at any time. Theoretically, by abstracting away from these expectations: an implementation can optimize itself better for the array and function-- possibly not even executing the walk on a single machine. Its a bit better when the array/collection is more interface-like, so that implementations can be swapped, but PHP can still see seems some of the abstraction benefits.
Would it work for him to make a crazy exclusive CORS policy? Access-Control-Allow-Origin: my.domain
So, you wouldn’t make a difference between regular data/value objects and persistable objects? Isn’t dangerous if an entity manager or persistor can get any kind of value objects without table definitions? I’d like to make difference between those two kind of objects. I would give a PersistableInterface to those classes and put to another NS just make it clear what’s what.
The thing about CORS is that the client needs to implement it. So it will stop anything from the browser, but not any regular non-browser HTTP requests (curl, postman, etc).
Blimey, thanks stranger 
I'm all for teaching, but you couldnt have done an ounce of research on this one yourself? www.google.com/search?q=php+dollar+sign The first few results for me answer it all in pretty good detail.
As Magento is one of the leading open-source eCommerce platform, therefore the demand for Magento developers will always be high in near future. Also magento's ability to extend its existing functionality and to be easily adapted to meet particular requirements is one of the most important feature of Magento . &amp;#x200B; The extremely user-friendly interface of Magento 2 makes user love Magento based online store more than any other eCommerce platform. The architecture of Magento 2 has a highly upgraded architecture which is useful for Magento developers to integrate out of the box features and tailor an eCommerce store as per the requirement. &amp;#x200B; As far as users are concerned, they can install Magento themes and extensions in a very quick and easy manner. These extensions are very helpful in terms of giving business a competitive edge as the users can add extensions like Store Locator, Amazon Pay, SMTP Email settings, Special Promotions. &amp;#x200B; SEO wise, Magento 2 is pretty strong as it enables the use of different meta tags for every product, category, and CMS page and this makes online store developed using Magento 2 be easily discovered by the search engine. &amp;#x200B; Another interesting feature of Magento 2 is support for multiple language and multiple currencies. This is helpful in terms of increasing the reach of an online store to maximum users from the different geographical background. &amp;#x200B;
&gt; While not stored in a 'models' namespace, would this object/class be accurately described as a Model (of the request)? Think of Models more as the "state" of your application. Because HTTP itself is stateless, I don't necessarily see anything wrong with treating the information contained within a request as a *kind* of model. But if we were to be pedantic about it, I would hesitate to call a request object a model in and of itself. A request is merely a payload of dirty information. It's the job of other moving parts to first sanitize and prepare that information and then commit / persist it to a given state. However you should decide your mode of persistence - be it a database abstraction layer, cookie, JWT, or even just a simple file on disk - I consider the "model" a representation of that final state.
As PHP does not have a variable declaration, the parser has harder to understand what is a variable or not, and therefore the leading dollar sign was chosen to identify the word as a variable. Why it was the dollar sign specifically to be chosen I don’t know :)
No, it isn't an interpreter. This library only parses PHP files and generates AST, then you will be able to analyze tree to find bugs, or modify and print modified AST back to the file.
What is 'goteliphense'?
same. every time I discover that a thing I'm familiar with already has a name I just assume everyone is a wanker. so many wankers.
&gt; but an understanding of the context in which the framework will be frequently used Unfortunately Laravel markets itself as an enterprise solution and 80% of its user base believes it is the one and only solution to everything. But yes, you hit the nail on the head, AR is also popular in ruby and python.
Absolutely. I model can be read only, write only. Whatever. 
Nope, in concept, but it may vary by platform/language/technology. Doctrine ORM (object relational mapper) encourages you to put models that tie to relational databases in an “Entity” namespace and Doctrine ODM (object document mapper) encourages the use of the “Document” namespace to represent models destined for NoSQL databases. Neither are required but it helps you know at a glance which ones are destined where. At my work, a top-level Model namespace indicates a value object not bound for a persistence layer. Lower level Model objects can be used for specific purposes such as holding form data, validation, transient data during a format interchange, etc. I build tons of models to handle all kinds of situations - this is somewhat self documenting and leverages the language to enforce my constraints than having to write a ton of array checking and validating.
I was hounded for saying something similar in response to a question like this. Truly is just laziness anymore. Why put thought into something yourself when you can have someone else spoonfeed you. Not being rude to you in the slightest, but looks like you did just that for them. As funny as it is, I never once questioned it myself in the 10ish years I’ve used PHP.
What I love about laravel is the ease in which you can switch things in and out. Using a data mapper instead of eloquent models is possible. I guess any framework with composer at its core supports that. 
This.
Thanks, The trouble is that array\_walk passes 2 arguments to the functions.. so using many of the core methods (such as strtolower, ucwords etc), throw errors and don't work... &amp;#x200B; EG **Warning**: strtoupper() expects exactly 1 parameter, 2 given in **index.php** on line **6** **Warning**: strtoupper() expects exactly 1 parameter, 2 given in **index.php** on line **6** Array ( \[0\] =&gt; test \[1\] =&gt; this )
If you’re talking about a huge delay and then it works at normal speed, packagist seems to have intermittent IPv6 connectivity issues. But realistically it could be a dozen different things. 
Language server written in go to serve a php intellisense ide extension
Please re-read your post. If so many people talk about "patterns", you may question your assumptions and try to discern why having a common naming for development schemes is useful. Also, as seen in https://www.reddit.com/r/PHP/comments/auq7u7/does_a_model_require_a_database_ive_been_going/ehamone/, those patterns were established decades ago. So it's not pull out of thin air.
Absolutely. That's called a "value object": it's an immutable model.
It's a parser that can analyze the code. The real advantage is that, because it's written in go, you can use it cross-platform without some kind of VM and embed it in pretty much every CLI program, even a web interface, without any problem.
Other languages (e.g. Basic and Perl) did it before PHP, so that's where that comes from. :) https://en.wikipedia.org/wiki/Sigil_(computer_programming)
**Sigil (computer programming)** In computer programming, a sigil () is a symbol affixed to a variable name, showing the variable's datatype or scope, usually a prefix, as in $foo, where $ is the sigil. Sigil, from the Latin sigillum, meaning a "little sign", means a sign or image supposedly having magical power. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
That's literally how C structs look like?!?
Praise PSR-4 \o/ 
I keep it in mind. But there are many issues with the parser. I want to change the AST data model to improve performance and implement CFG.
There are two different types of models predominantly, Rich Domain Models (Active Record Style with methods on the model itself to interact with persistence layer) and Anemic Domain Models which are usually just there to hold data. I personally like the Anemic Domain Model as I believe it’s not an object’s responsibility to save itself into a database. Instead, a repository can do the job. Single responsibility principle is one I like to follow religiously when building applications. 
I think it's a reference point to learn many features of php. But where or which book should i read to learn php from the scratch?
More so in PHP perhaps, than in ruby, where its a more fully featured ORM implementation. ORM overall can be an anti-pattern, however, here's one article for starters: &amp;#x200B; [https://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html](https://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html)
&gt; TIL: ActiveRecord can be an anti-pattern It kind of always was a bad idea. You're stuffing your business logic in extremely specific implementation of an ORM. You're basically married to that ORM for the lifetime of the app. Thing is, most applications don't store all their state in one place. Some of it may be in an SQL database, some in a document store, some on disk as files, some in RAM as cache, some may come from third party APIs, some may be computed on the fly through other objects and app services. ActiveRecord assumes all you need is a golden hammer hammering your state, record by record, in a database. Works for simple apps only.
Using different php.ini files that you map in your Dockerfile will produce a simpler result.
&gt;The trouble is that array\_walk passes 2 arguments to the functions Because if you need to apply a transformation to an array in a single function, you use array\_map: [https://3v4l.org/Dsvv0](https://3v4l.org/Dsvv0) &amp;#x200B; You walk the array if you need to both transverse and iterate through the contents/do more than just a simple per-element callback. &amp;#x200B; &amp;#x200B;
Whether a model is rich or anemic is not related to what persistence pattern is used (e.g. AR or repository pattern). Rich models are full of business logic and business language. Persistence logic is not business logic.
Good models are built primarily around behaviour, not state. A checkbox is a weird example. I cannot imagine a scenario in which a checkbox interacts with the business rules of an application.
To quote myself: &gt; &gt; describe the state of something, **including some business rules about what states are valid and which are not (and how the state changes one way or another).** The checkbox model wasn't an example of an application's business rules, it's an example of how the model looks from the PoV of the checkbox. In a real application, one model rarely is enough. There's a lot of mapping happening between domain model to backend implementation model and UI models. When models interact, it allows the objects that handle irrelevant concerns (such as how data gets stored on disk, or how the checkbox is positioned and styled for user's app) to be separated from the model concerns.
Your model is for business logic. It should be designed primarily around behaviour, not data, and should mostly be made up of language and concepts that non-technical stakeholders define and understand. Good: "When an order is placed, decrement stock." Bad: "When an HTTP request is sent to X URL, persist Y to the database." Some of the objects in your model should be entities, but not all of them. There should also be value objects and services in your model. model !== entity. It is rare that an HTTP request should have an analog in your domain model because HTTP is a technical concept, not a business concept. It might be that you have message objects which exist in your domain model which you create when you receive an HTTP request, but your business logic itself should usually be completely agnostic of HTTP.
what exactly is slow? &amp;#x200B; * `composer install` with existing composer.lock -&gt; prestissimo * composer autoloading -&gt; you can optimize autoloading on production e.g. `composer install -o` * `composer install` without existing composer.lock / same as `composer update` \-&gt; check if xdebug is enabled otherwise there is little you can do other than optimizing your version constraints on your dependencies. Composer needs to resolve dependencies of everything required to each other, as well as their dependencies and their dependencies and so on ... trying to find the best installable versions for everything, see [https://en.wikipedia.org/wiki/Category:SAT\_solvers](https://en.wikipedia.org/wiki/Category:SAT_solvers)
This one is a much better choice to extend and modify the tree: https://github.com/nikic/PHP-Parser (see ["differences" section in Docs](https://github.com/nikic/php-ast#differences-to-php-parser) to php-ast). I use it in [Rector](https://getrector.org/) and it allows me to migrate from one framework to another. Piece of cake compared to manual work :)
I don't get it either. There is https://github.com/nikic/PHP-Parser for this. Why do I need go to parse PHP?
These functions are slow because PHP doesn't support inlining for higher order functions, these functions don't have to be slow For the reasons why you would want to use them is basically a trade off between blocks vs functions A block in php is this : ```{}``` you'll often see them on loops but they crop up on if statements and a few other things So the trades off are: Blocks are faster Blocks display no intent Blocks do not state what they import into scope Blocks are not reusable (unless wrapped with a function/method) Compare these two pieces of code: ``` $new_users = []; foreach ($users as $user) { if ($user['status'] === 2) { $new_users[] = $user; } } ``` What does that tell you about the problem space? We had to read the entire loop to find out, we're still not sure why $user['status'] === 2 is significant (admittedly naming the 2 with a constant may have helped) ``` function is_blocked(\User $user) : bool { return $user['status'] === 2; }; $new_users = array_filter($users, 'is_blocked'); ``` Now with array_filter we can see the problem space is about blocking because of the function name, we can see that a $user is ```\User``` and there might be a bug here because we're treating ['status'] like an array and \User might not be array like &amp; we can easily reuse is_blocked around the code base That said array_walk isn't usually a good replacement for foreach, unless you have a function already like: ``` $arr = [[1, 3, 2]]; array_walk($arr, 'sort'); ``` That's because foreach is much more general, array_walk is usually for running side effects, array_map for changing items in a collection, array_reduce for generating something new from an existing collection and array_filter for removing elements from a collection I wouldn't discount any of them from your toolkit (including foreach)
You're right. Its a bit worse than that-- returning a new value doesn't change it (needs it to be passed by reference). So the functional use cases are limited to functions that pass by reference or need to iterate without modifying the result. ... and there's more. None of the PHP functions seem to work with it, so even if you use functions like `end` or `reset`-- which do use references, they have no effect unless using a wrapper function. In effect-- the usefulness is limited to non-core functions-- which may suggest that PHP has room to support functional style programming more. (`array_map` and `array_reduce` taking their arguments in different orders certainly doesn't help): array_reduce($array, function($v) { return $v; }); array_map(function($v) { return $v; }, $array); 
https://www.youtube.com/watch?v=_9U-f-vtXkQ
Once you use them for a while you start to understand why you might want to return a function from a function or accept a function to a function, you'll see that in concrete examples here: https://phptherightway.com/pages/Functional-Programming.html It's kind of like dependency injection on steroids because it's not behaviour replacement on a class level but behaviour replacement at the method/function level The main problem with it (as with any runtime behaviour system) it's hard to follow what happens at runtime because there's a intrisct over there and a over here, code locality is important when it comes to simplicity Some people get uncomfortable with the callee typing against itself rather than the receiver being able to type against what it wants In my eyes once I delegate responsibility for something it's a relationship between me and you, if I provide typing restrictions on my side on you, I will limit how you achieve the functionality I will ask for, which limits what I recieve back, but if I call you and you validate my inputs with type hinting that will ensure our contract together is solid
Hey, slifin, just a quick heads-up: **recieve** is actually spelled **receive**. You can remember it by **e before i**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Thanks CommonMisspellingBot
Yes we are
It's very useful for performance testing, not for production.
It's a shame symfony native sessions do not work atm. I'd love to use it
And here I thought maybe I should start getting back into Magento since it’s at 2.3..
This lib inspired by [nikic/PHP-Parser](https://github.com/nikic/PHP-Parser). Since [z7zmey/php-parser](https://github.com/z7zmey/php-parser/) is written in Golang, tools can compile to single binary without dependencies, therefore it is easier to distribute through package managers. Also, Golang suggests more performance and memory efficient.
I have to ask, Just to confirm, did you forget to include the test folder or there's no tests? 
I'm currently doing the tests, so I'll include them in the next update. I'm making efforts to manage everything because this version is very amateur and takes a long time to make sure that everything runs perfectly. If there is anyone interested in helping me, can contact me in private
IMHO it's just a retelling of Fowler\`s books. 
Okay, I'm going to put my cards on the table here... I've seen the max process calculation thrown about by many people, including some very expensive consultants, and I think it's absolute nonsense, in no small part due to the reason you put, and so I think it's a fairly terrible thing to include as a tuning recommendation. Here is my suggestion, and it's basic profiling: 1. Set the maximum number of PHP processes equal to the number of cores on the server. 2. Throw apache benchmark or similar at it, ideally have something which hits multiple pages and does an average amount of IO. 3. Use the ratio of CPU to requests to work out what it should be. 4. If you have 8 cores, 8 processes, and you're using 33% of your CPU while you're trying to murder-overload-to-death it, then you're 33% CPU bound, and 66% IO bound. That means your CPU can support 24 PHP processes, it's usually safe to throw a 1.2x multiplier on this number. 5. The actual maximum is MIN(ram_calc, cpu_calc) which you then set as your max children. I would argue you should leave add at least a 1.5x multiplier to your PHP-FPM per-process memory value, because if your memory usage creeps up at some point during heavy load, and you start getting paged virtual memory thrashing, you're going to have a *really* bad time. 6. Sit back, relax, and realise you just avoided thrashing the absolute hell out of all of your external services that probably don't come close to having the processing power to deal with what you would have in the memory-bound calculation.
Very nice!
Some insights - for the first ever project is is rather good. it is much better than one would expect from "my first php project". - for Goodless sake, do not model your framework after CI, it's from another epoch. It's like coming to Pentagon with your brand new invention - an improved muzzleloader (it is not to make fun of you, it is *really* like that). Take Symfony for a model instead. - for your database class I already have a review, [our first database wrapper's childhood diseases](https://phpdelusions.net/pdo/common_mistakes). Sadly, you managed to contract almost every one of them. - some functions in your functions file are just fun. The double die in deny_direct_access() and calculations in microtime_float() are my favorite. - you should really make www.phptherightway.com and symfonycasts.com your home pages for a while and come back with the new version. 
Disclaimer: I think we should seriously consider the possibility, but I'm not particularly sure we'll actually be making the change.
If you haven't already you might want to have a look at [Composer](https://getcomposer.org/).
Just wondering if you could elaborate on what this means: &gt; Please, help the develpment of the first public domain php framework To a casual reader it almost seems like you are claiming that this is first public domain php framework ever released. I know you have a somewhat unusual license but is this really what you are claiming?
I think this would be an incredibly valuable change, but I wonder if it would stiffen adoption of 8.0.0 for certain legacy projects even more. Heck, I know projects that have only recently switched to 7.x . I can imagine having a somewhat shitty, untested codebase with lots of loose comparison where this change would be HELLA scary. Though a php.ini setting in that case would help a lot I guess.
I usually completely decouple my domain model from my persistence model and create mappera/transformers to transfer data between the two. I definitely wouldn't want any persistence dependencies in my domain model. But there's for example annotations that would be a valuable option to tell a persistence library how to interact with domain models directly without coupling the domain model to some persistence code. 
&gt;Some insights &gt; &gt;for the first ever project is is rather good. it is much better than one would expect from "my first php project".for Goodless sake, do not model your framework after CI, it's from another epoch. It's like coming to Pentagon with your brand new invention - an improved muzzleloader (it is not to make fun of you, it is really like that). Take Symfony for a model instead.some parts that are considered essentials nowdays are completely missed. Tests are mentioned already, there are others - DI, autoload, Composer. check this article for the quick heads-up: https://kevinsmith.io/modern-php-without-a-frameworkfor your database class I already have a review, Your first database wrapper's childhood diseases. Sadly, it managed to contract almost every one of them.some functions in your functions file are just fun. The double die in deny\_direct\_access() and calculations in microtime\_float() are my favorite.you should really make www.phptherightway.com and symfonycasts.com your home pages for a while and come back with the new version. Hi, thank you for the feedback, very constructive. &amp;#x200B; I also enjoyed your complete view of the code and I really appreciate your comments. &amp;#x200B; I'd just like to respond to a few criticisms, one of them about CI. Yes, it is true that it comes from another era but, the project and remotely inspired by it. I love the lightness of CI and this is what led me to take it as a reference. &amp;#x200B; The essential parts of the files (I answer with this also to the last part of your comment) are under construction since the framework is under constant development. &amp;#x200B; I would like further explanations for the DB class, since I know very well that I am a neophyte but I would like further explanations maybe more detailed. Thank you in advance, if you do. &amp;#x200B; The microtime float function has been added really for fun and has been deprecated in the current version (which I'm developing). I don't remember how it ended up in the source but I should have used it following an article found on bitcointalk to make something. Forgive the mistake. &amp;#x200B; Thank you so much for the feed. 
Further explanations for the DB class can be found by the link I provided. If you have any questions regarding different issues covered in the article, I will be pleased to answer. what makes microtime_float() a fun is the fact that it does cast $usec to integer, essentially making it zero, so you are getting only seconds, without any fractional part. 
The site is slower than crypto miner ([Direct repo link](https://github.com/RefactoringGuru/design-patterns-php)) I don't think this format was a good idea - now both description and code is unreadable. "RealWorld" pseudo code is cool, but nothing original beside that. Yay! That's probably first time I see *Factory method pattern* done right in php.
I don't know C so this may be possible, but the thing I was referring to from that page was not the struct definitions (though I can understand why you saw that first) but the tags. Here's an example from the docs: ```go struct { microsec uint64 `protobuf:"1"` serverIP6 uint64 `protobuf:"2"` } ``` The *protobuf* tag is the interesting part that I'm referring to. Again, I don't know C so maybe that is part of their syntax but I just want to be clear.
&amp;#x200B; No, I just forgot to insert "my", unfortunately I'm not a native English speaker. Forgive the misunderstanding. It wasn't intended.
Fowler's work is a retelling of every mention of "pattern" online.
Possibly you're using Symfony or any other large root package that has a large number of rules around which packages each version will work with, and so Compose has to evaluate thousands (if not 100,000s) of rules. I think I've heard of people adding more rules to their root composer.json to exclude older versions of packages, which will cut-down on the total number of rules that Composer would need to evaluate. e.g. if you add a rule about requiring the latest version of Twig, that will mean that all the other versions of Twig won't be considered as possible packages to use. btw, posting an example of your composer.json that is slow would allow other people to try it.
I'll try to improve the class in the next few days. Thank you for the good feedback and for saying that my first project is not so bad :)
I'm always in favour of the language forcing people to be explicit in their intentions so personally I'd like to eventually see automagic string to numeric comparisons consigned to the dustbin. In the mean time, I'd like to see any implicit juggling for non-strict comparisons throw an E_WARNING if it's anything other than an incredibly obvious conversion. Leading spaces, trailing spaces, exponents, unexpected characters, the whole lot, if it's anything more complicated than (-)12345 it should throw a warning, as in "WARNING! Something is playing with fire and poses a significant chance of exploding in your face!"
I've actually heard an alternative perspective - ie, that models are not for *business* logic, just *data* logic. *Services* are where business logic live. Thoughts on that?
I would disagree. Here is someone smarter than me to explain why. https://www.martinfowler.com/bliki/AnemicDomainModel.html
Just a simple question, but why can't this proposed change make this one false? `var_dump("0" == "0e214987142012");` &amp;#x200B; It could have the added advantage of making hash comparisons that are not using hash\_equals or password\_verify a bit more secure by default. (i.e. remove the magic hash vulnerability)
IMHO escaping is part of the template engine / process... Do you create separate DTO objects for your templates or what? Cause escaping stuff inside the "real" objects wouldn't be a good idea either. &amp;#x200B; And there might be times where you switch views json/html/xml... and might need to escape differently
While you might enjoy the "lightness of CodeIgniter", it simply no longer belongs in this day and age. You can't just make a PHP7 version inspired by it and think you're good to go. If you don't want a full fat framework with a higher learning curve like Symfony, Zend or Laravel (the latter's learning curve isn't even that steep), I highly suggest having a look at a modern, accepted micro-framework like [Slim](http://www.slimframework.com/). If you want to stay relevant as a developer, you need to stay with the times, there's no point in reminiscing about outdated frameworks. At least that's my opinion.
That's list for internship?
A question that I long wanted to ask. For the moment a single `compare_function()` is handling all comparison operators. Would there be any sense in moving "equal" and "not equal" comparisons into a distinct function that would consider operand types, and if both are the same, then do not perform the "usual math"? So `"1000"=="1e3"` would return false (but `"1001"&gt;"1e3"` would continue to compare as numbers)? Or may be I am just overthinking and it just doesn't worth the trouble?
I agree, and think that an INI setting would make a lot of sense here.
That would make writing portable libraries a complete madness, where you'd have to consider each comparison depending on what the ini setting is - even if your library only supports 8+.
Yes, that's your opinion. It's all very well what you say and staying with the times is what you expect from every professional, this is clear to anyone. I'm alone, the only developer of this framework and I tried to make a version from scratch trying to keep myself to a minimum with the size of the release without sacrificing performance or security and I do not think I have to throw the project completely. Since another version of this framework, much improved, I still use it for my projects and my clients' projects. I think it's nice to vary and use laravel, symphony, slim, codeigniter and all the other tools that this world offers us but, I think that developing something on your own with your own means and skills is not bad. Those of CI have never missed a single step, maybe against them (I'm not talking about version 4) the time started to flow too fast. I conclude by thanking you for the comment and I conclude by telling everyone that this version is my first version of the framework developed and I decided to release it in the public domain to allow anyone else to improve it by contributing to the project. I have another version, more modern but it is private. Thanks 
You would just use explicit casting. 
That this is even a thing is a really bad reflection on PHP.
Good point, I hadn't thought of that.
Glad to know I’m not the only person struggling with comparisons. For my projects, I built a comparison function for cases where I need strict types and use it everywhere. I am guessing most people have something similar built on their projects. While this change would have been nice to have, I also worry about legacy projects that rely on the cirrent behavior. Why not add this as a new library, like the SPL? Legacy would be maintained and new adopters will have fewer headaches.
Why would need a comparison function when you have `===`?
Unpopular opinion: Package managers shouldn't be removing old versions of run times like PHP. An old version of PHP doesn't automatically make the software vulnerable. As always it depends on how the code is written.
Personally, I'm against this change. It will reduce adoption for PHP 8 for sure. Just imagine you have a huge legacy codebase without any tests out there and lots of many comparisons. Sure, this change seems logical, but for legacy projects it's just a lot of work and not really an improvement. &amp;#x200B; Everyone else who cares about types uses strict comparison already anyway. We have `===` and `!==` to use.
When I mentioned "projects switching to 7.x", I did not mean libraries available through Composer but legacy systems still running on 5.6 (or worse). While I get that some packages are perfectly okay being compatible with older versions, I totally get why library maintainers want to move to a newer version to use new features. 
Why do you need exactly that way? In PHP all I need to do is: composer require nikic/php-parser Also Rector and PHPStan using it are distributed as single files - PHARs..
Are there some post series for Laravel 5.8 news in sexy and short format?
Well yes but there's the rub: legacy systems. Imagine you're a business that hired a dev to build you a perfect custom made CMS. The dev leaves after completing the job. The software works at intended. There are no security problems or new features you'd like to implement. The thing runs fine for years. Then all of a sudden the version of PHP gets pulled from the linux repo. Everything continues to run fine since you're not deploying anything new. Everything is going as normal. Then all of a sudden you push a simple new template containing some new HTML and the whole thing comes crashing down. You have no idea what happened. Now you need to literally hire someone to figure it out. I just think it's stupid. There's nothing inherently wrong with an old version of PHP. I could write a totally secure and clean login system in PHP 4.x if I really wanted to.
Some of Fowler's work is quite old and was out long before a lot of the stuff you see online today. That said, Fowler's Patterns of Enterprise Application Architecture, he credits _several_ books.
[Laravel News looks like they have a summary.](https://laravel-news.com/laravel-5-8) (I was looking for one too.)
&gt; I could write a totally secure and clean login system in PHP 4.x if I really wanted to. PHP 4.x doesn't receive security updates. If a security hole of any kind is discovered, it's vulnerable. Running an old version of PHP absolutely does put your software at risk. 
silly weirdness and code smells like __call and even __get and __set are fine if they're hidden away in some well-tested framework and/or library. the reason they're bad is because they make the code hard to read and test, but that's not a problem since you're not the ones reading and testing that code.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What is the best way to prevent wrong states in an object? This is the source of my question. &amp;#x200B; Basically my curiosity started with the intention of not letting a class exist with wrong values. Prevent programmers from making mistakes in class implementations and extensions. &amp;#x200B; I did not want a class to even bother to have to deal with a wrong value. I just wanted it not to be started if a wrong value of a given status or type was passed. &amp;#x200B; I work a lot with types in string, due to a demand for legacy code. For this I find it interesting to work with "value objects". That aparently is the primary design idea. I tried to go for something with stringly-typed (another new term I just found out). &amp;#x200B; So below I have the first example. The scenario is: a class need a type and instead invoke a string 'type\_x' invoke a class and this class solving the value if it is valid. This class is the one we will see below. &amp;#x200B; `/**` `* StringlyTypeSecondOption` `*/` `class StringlyTypeFirstOption` `{` `private $type;` `public static function type_1()` `{` `return new self('type_1');` `}` `public static function type_2()` `{` `return new self('type_2');` `}` `private function __construct(string $type)` `{` `$this-&gt;type = $type;` `}` `public function __toString()` `{` `return $this-&gt;type;` `}` `}` `echo StringlyTypeFirstOption::type_2(); //here its ok` `echo StringlyTypeFirstOption::type_3(); //here we have an error cause type_3 doesnt exists` &amp;#x200B; This is a very good example because we havent no if or throw exception or any logic of verification. Is oop on its own. And I think its good. &amp;#x200B; And now we have the second example. Will provide a solution for the same problem I proposed. &amp;#x200B; `class StringlyTypeSecondOption` `{` `private $type;` `const TYPE1 = 'type_1';` `const TYPE2 = 'type_2';` `private const ALLOWED_TYPES = [StringlyTypeSecondOption::TYPE1, StringlyTypeSecondOption::TYPE2];` `public static function factory($type)` `{` `if (!in_array($type, StringlyTypeSecondOption::ALLOWED_TYPES, true)) {` `throw new Exception("Invalid type: {$type}");` `}` `return new self($type);` `}` `private function __construct(string $type)` `{` `$this-&gt;type = $type;` `}` `public function __toString()` `{` `return $this-&gt;type;` `}` `}` `echo StringlyTypeSecondOption::factory('type_2'); //here its ok` `echo StringlyTypeSecondOption::factory('type_3'); //here we have an exception cause type_3 doesnt exists` &amp;#x200B; Is a very good example too but I already have some logic and is not so pure like the first one. But solve the problem like a charm too. &amp;#x200B; Both imlementations have strengths and weaknesses (I think). But if there is a consolidated design that fixes allowed values for a state of a class, what its name how to implement and what is the best oop beatiful and designed strategy to prevent an invalid value in an object? &amp;#x200B; I think this is more a discussion over an exact solution. If this was not the right place I ask the moderators to direct me to a better channel. &amp;#x200B; Thanks advance!
At the moment to me your argument is complete [FUD](https://en.wikipedia.org/wiki/Fear,_uncertainty_and_doubt). Can you please elaborate? How would you exploit PHP 4.x when the entire source of the code is? echo 'Hello World'; Please be specific. Handy wavy "it doesn't get security updates" is not an answer.
**Fear, uncertainty and doubt** Fear, uncertainty and doubt (often shortened to FUD) is a disinformation strategy used in sales, marketing, public relations, politics, cults, and propaganda. FUD is generally a strategy to influence perception by disseminating negative and dubious or false information and a manifestation of the appeal to fear. While the phrase dates to at least the early 20th century, the present common usage of disinformation related to software, hardware and technology industries generally appeared in the 1970s to describe disinformation in the computer hardware industry, and has since been used more broadly. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Definitely worth the trouble imo. I have a branch that achieves this in core, as a proof of concept for another attempt at a Comparable RFC. It splits comparison into two contexts: equality and ordering. The concept only applies to objects though, but I don't see why we can't consider this for scalars too. The problem I'm trying to solve is where Decimal(0) and 0.0 are not equal, but have equal relative ordering. A stable sorting algorithm would incorrectly put Decimal(0) after the scalar based on the existing single-context comparison function. Also some classes can't be compared (apples vs oranges) but equality can always be defined. I think a fundamental split is the only way to construct sensible comparison rules. 
I use Github daily, so single plugin, 2 amazing Github shorcuts and console command hacks be really time-saving. Here are 5 tips from my daily work, that take just few seconds to learn. Would you add some? :)
I absolutely do fear software that doesn't receive security updates, and belittling that isn't going to change my poit of view. Your argument is that an application that only uses basic built-in functions cannot possibly have any security flaws. I don't think I need to be more specific to disprove that. If a previously undiscovered flaw was found in the \`echo\` function, your application would be vulnerable. Sure, if you're confident that having read the PHP4.x source code there is 100% certainty that that can never happen (and if it does, you're happy to fork the source and fix it yourself), then I guess you can be fairly comfortable with software that is literally just echoing a string. But I'll let you be the one to attempt to draw the line at which point your software becomes 'complex enough' to need to be run on a platform receiving security fixes, and I'll stick to my opinion that using a current version of PHP is not just sensible but necessary.
Can someone give a quick opinion/info on what larvel is good for? I’ve never used it. 
So, I have been running some benchmarks on my docker container (nginx connecting to php-fpm) and it's over 70 x slower than bare metal. I can manage 100 requests a second compared to bare metal which is 7,000 a second. &amp;#x200B; &amp;#x200B; docker-compose.yml: &amp;#x200B; version: '3' services: #web frontend: build: context: ./environment/nginx dockerfile: ./Dockerfile container_name: nginx_software restart: always ports: - 80:80 volumes: - ./environment/nginx/nginx.conf:/etc/nginx/nginx.conf links: - php php: build: context: ./environment/php args: version: 7.3-fpm dockerfile: ./Dockerfile container_name: php_software restart: always ports: - 9000:9000 volumes: - ./api:/var/www/software:cached links: - mysql mysql: build: context: ./environment/mysql args: version: 5.7 dockerfile: ./Dockerfile container_name: mysql_software command: --default-authentication-plugin=mysql_native_password restart: always ports: - 3306:3306 volumes: - ./environment/mysql/data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: software MYSQL_DATABASE: software MYSQL_USER: software MYSQL_PASSWORD: software &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; My nginx.conf &amp;#x200B; user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { } http { include /etc/nginx/mime.types; server { listen 80; listen [::]:80; server_name software.test; root /usr/share/nginx/html/software; add_header X-Frame-Options "SAMEORIGIN"; add_header X-XSS-Protection "1; mode=block"; #add_header X-Content-Type-Options "nosniff"; index index.html; location / { try_files $uri $uri/ =404; } charset utf-8; } server { listen 80; listen [::]:80; server_name api.software.test; root /var/www/software/public; add_header X-Frame-Options "SAMEORIGIN"; add_header X-XSS-Protection "1; mode=block"; #add_header X-Content-Type-Options "nosniff"; index index.php; charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } error_page 404 /index.php; location ~ \.php$ { include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; fastcgi_pass php:9000; fastcgi_index index.php; } location ~ /\.(?!well-known).* { deny all; } } } &amp;#x200B; My dockerfile for nginx, just copies the conf file to the /etc/nginx folder. &amp;#x200B; if I build a custom fpm file, or use the following one: [https://github.com/uvd/php-docker-bench](https://github.com/uvd/php-docker-bench) I get the correct amount of RPS (7,000) but with my current nginx/fpm setup, I barely surpass 100 RPS. What am I doing wrong, any ideas?
Prototyping projects fast, then later once it's setup, re-write it in either raw php, or another language.
Awesome, thanks for the link!
Running serious, robust PHP applications at a variety of scales (small, medium, or large applications). Includes great support for testing, event broadcasting for building real time applications, queued jobs, thorough automatic dependency injection support, middleware, and more.
Maybe someday down the line we'll use ≡ for ===, not that we are gaining much from it, other than making the identity operator look sort of higher rank than ==.
Indeed, should have been more explicit. The function is mainly for comparing strings that takes into account uppercase, lowercase, accents and special characters. For example, in some cases, I need the string “Elephant” and “éléphant” to be considered as the same. In other cases, I need to determine whether a numeric string with a separator is the same as another number: “1,235.00” and 1235 So while I can use the ‘===‘ in some cases, that doesn’t apply to everything I am comparing. Again, this is a specific use case I have for the projects I have, and I’m guessing others have their own use cases. The broader point I was making was that when legacy projects were built, they were done taking into consideration the existing quirk, so perhaps it would be better to have a new comparison library created instead if modifying the current behavior.
So I have this project I developed and maintain. In short companies post jobs/careers. (About 5,000jobs get posted each year) I wrote this from scratch and we are going to start developing version 3.0. Would larvel be good to use? Primarily looking for something I can do better with caching/session management. And queries. Thoughts? 
For the PHP Image used in the build, instead of using "php:7-fpm", use "php:7-fpm-alpine" and try it.
Sorry, I mean OS package managers like \`brew\`, \`apt-get\`, etc.
Still the same.
This would certainly do well to help shut up the PHP sadness crowd that likes to use bizarre examples of non-real-world code to demonstrate why nobody should ever use PHP...
Yes, that sounds like the kind of general web application that Laravel would be a good choice for. It would handle that kind of application easily.
"why" still stands.
I'm not belittling anything. I just think that when we build software we should respect package versions. We should also respect reality. Currently the reality is about 20% of ALL PHP installs are running PHP 7.0.x as per https://blog.packagist.com/php-versions-stats-2018-2-edition/ 7.0.x is end of life meaning no security updates. Are we seeing sites being exploited left and right because they are running PHP 7.0.x? The answer is no. This is the reality. The truth is almost every single one of these buffer overflows requires a very intimate knowledge of the way the binary interacts in memory for that specific thing just to construct a proper payload to exploit the overflow to be able to run some arbitrary command on the target. And you'd also need to be able to see the source code of the target in most cases. A flaw in echo would only work if I was passing unsanitized input data into echo. Furthermore I believe at the moment there has been no vulnerability found for echo itself. Let's take a look at what has been found: https://php.net/ChangeLog-7.php Just do a quick find for 'overflow'. You'll see dozens of issues in every version of PHP. Even having the latest and greatest version doesn't protect you when a CVE comes out almost weekly showing a buffer overflow in a commonly used function. If what you are saying was a real actual problem botnets would be exploiting every PHP website on a daily basis.
In this case I suggest to run PHP benchmark Script in the host machine &amp; in Docker containers (you application or nginx is not included in test). http://www.php-benchmark-script.com/
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What is the best way to prevent wrong states in an object? This is the source of my question. Basically my curiosity started with the intention of not letting a class exist with wrong values. Prevent programmers from making mistakes in class implementations and extensions. I did not want a class to even bother to have to deal with a wrong value. I just wanted it not to be started if a wrong value of a given status or type was passed. I work a lot with types in string, due to a demand for legacy code. For this I find it interesting to work with "value objects". That aparently is the primary design idea. I tried to go for something with stringly-typed (another new term I just found out). So below I have the first example. The scenario is: a class need a type and instead invoke a string 'type_x' invoke a class and this class solving the value if it is valid. This class is the one we will see below. /** * StringlyTypeSecondOption */ class StringlyTypeFirstOption { private $type; public static function type_1() { return new self('type_1'); } public static function type_2() { return new self('type_2'); } private function __construct(string $type) { $this-&gt;type = $type; } public function __toString() { return $this-&gt;type; } } echo StringlyTypeFirstOption::type_2(); //here its ok echo StringlyTypeFirstOption::type_3(); //here we have an error cause type_3 doesnt exists This is a very good example because we havent no if or throw exception or any logic of verification. Is oop on its own. And I think its good. And now we have the second example. Will provide a solution for the same problem I proposed. class StringlyTypeSecondOption { private $type; const TYPE1 = 'type_1'; const TYPE2 = 'type_2'; private const ALLOWED_TYPES = [StringlyTypeSecondOption::TYPE1, StringlyTypeSecondOption::TYPE2]; public static function factory($type) { if (!in_array($type, StringlyTypeSecondOption::ALLOWED_TYPES, true)) { throw new Exception("Invalid type: {$type}"); } return new self($type); } private function __construct(string $type) { $this-&gt;type = $type; } public function __toString() { return $this-&gt;type; } } echo StringlyTypeSecondOption::factory('type_2'); //here its ok echo StringlyTypeSecondOption::factory('type_3'); //here we have an exception cause type_3 doesnt exists Is a very good example too but I already have some logic and is not so pure like the first one. But solve the problem like a charm too. Both imlementations have strengths and weaknesses (I think). But if there is a consolidated design that fixes allowed values for a state of a class, what its name how to implement and what is the best oop beatiful and designed strategy to prevent an invalid value in an object? I think this is more a discussion over an exact solution. If this was not the right place I ask the moderators to direct me to a better channel. Thanks advance!
On second thought, what I just described is the exact definition of what "Equal" (===) operator does. So, seems it really doesn't worth.
Understanding common design patterns and their relative strengths and weaknesses is a fairly important part of being a senior developer or architect. &gt; Oh look, wrapping a DB table with a class? ActiveRecord pattern! There are several different common design patterns that can be used for an ORM / DBAL implementation depending on requirements, ActiveRecord is one type of them. 
Thanks for the info. Appreciate it. 
Can't back this given that this has been the state of things for 25 years and changing the rules of something as basic as equivalence is about as high-stakes as it gets. Not opposed to the sentiment or the suggested ideas, but I find it awfully late in the game to consider such changes.
Oh that crowd will have ammunition for worries. Don't you worry.
Have you tried without mounting your code directly to the php-fpm container? I see you already have it set for cached so that should help. I get better performance (developing on a 2016 macbook pro) with docker-sync instead. Unfortunately it's still not quite as fast as bare metal or a CentOS VM w/ docker. Developers on my team tried to use docker-sync with Windows but didn't see much of a performance gain.
Congratulations!
&gt; Used by companies like Discovery, WWE, McDonalds, Vice, Fox, and more. Of curiosity -- for what, exactly? "A big company uses it" is not quite the same thing as "they bet their whole business on it."
Very good for a first project! If I were, you, to fix your "namespace problem", you better use composer ;) Even if you not intend to use external packages, you should do it for your own project. It is one of the best package manager (with NPM) I know. Will save you tons of time.
Previous post: https://www.reddit.com/r/PHP/comments/atuxsm/first_interview_for_a_php_role_in_3_years_this/
Grats!
Huge congratulations mate!
It's not an improvement... until the third party component you're using somehow roflstomps you with a security vulnerability because someone it's been fed bizarre comparisons. 
PHP does a lot more than just execute the PHP code you write, specifically it parses request headers and body, converts them into PHP variables. If this code has a security problem, it doesn't matter how simple your php is. &amp;#x200B; In addition PHP loads extensions that execute and load code even if the extension itself is not used. This can also be vulnerable.
u/nikic I see in the RFC you mentioned a depreciation warning if the results would differ from previous behaviour, I'm curious what you might think to the idea of a warning / notice when a potentially risky formatted implicit conversion is done. 
Every Business man not beeing totally mad, would have a SLA contract for the hardware the application is running on. Why are people always arguing this isn't neccessary for the application itself, though? 
&gt; Laravel, Drupal, WordPress Drupal and Wordpress are better suited for managing content (think a company's blog / announcement pages / etc). I've been using Drupal 7 at work for custom application development, and I would not suggest anyone to pick it for that purpose. It's got a moderate learning curve and a bit strange. Laravel is a framework. It comes highly recommended around here. &amp;#x200B;
The idea is to have one MySQL image that doesn't go down, and then two (or more) load-balanced PHP images that run my API and that I can perform rolling updates on for zero-downtime deployments.
No, we're not seeing servers/sites being attacked using a PHP7.0.x-specific attack vector but one day we could - why put yourself in a position where you're running unsupported software? As soon as 7.0.x is not supported for security fixes, you should, ideally, upgrade to a version that is. Telling people otherwise isn't an 'unpopular opinion', it's dangerous advice. You're right that in reality a lot of servers are left running out of date versions of PHP, and out of date versions of software packages. Being 'realistic' is realising that, but you don't have to take that reality to mean that running such out of date versions is just as secure as running a supported version.
You running this locally? Seems like one is passing through the network and the other doesn't.
Sometimes big companies hire external providers to make their projects. For example I have used Laravel to create few websites for Berkeley, if that counts.
Thanks for the comment. I'm really pleased with your response. Right now I'm fixing the namespaces problem using RecursiveDirectoryIterator and spl_autoload_register to create an autoloader that will browse all the project folders.
Installed software: Gallery3 [http://photos.timchuma.com/gallery3/index.php/](http://photos.timchuma.com/gallery3/index.php/) &amp;#x200B; It is currently on hiatus for development but it is too much trouble to try and transfer to other software and I have tried. I do not think it is meant to deal with as many photos as I have on my site. &amp;#x200B; Installed Module: Captionator [http://codex.galleryproject.org/Gallery3:Modules:captionator](http://codex.galleryproject.org/Gallery3:Modules:captionator) &amp;#x200B; This module saves me from having to click on EVERY SINGLE PHOTO to edit the photo caption. I like having photo captions. &amp;#x200B; Example URL: [http://photos.timchuma.com/gallery3/index.php/RRR-BBQ-Day-2019](http://photos.timchuma.com/gallery3/index.php/RRR-BBQ-Day-2019) &amp;#x200B; I have used this in the past to much success and have added dozens of galleries using it. I am sure it was working last time I used it back in December. I don't like having to dig around in the PHP unless I break something. I have sent a report to the web host in case they have turned something off on the server that stopped it working. Thanks.
Well actually, if the security hole was in the code that populates $_GET or $_POST, even that snippet could be vulnerable. Also, you've given an awfully contrived example. In the real world, you're going to be taking user input at some point, and that opens up some attack vectors. Heck, all the old register_globals issues would apply to PHP4 code - and those weren't even bugs!
This is one of the beauties of `declare(strict_types=1);` - it's a file-level configuration, rather than request-level. While it's super tedious to write every time, it completely sidesteps the problem. IMO this change (if accepted) should just wrap into strict types, but I could see an argument in favor of having a separate directive.
Yep, running locally.
Good work! Maybe post a summary of the questions asked (at least what you can remember), for the next you!
Looks like a bugfix to me honestly. If it breaks anything, it's something that was already broken.
There are multiple reasons why we should keep unsupported versions in the repository. It is objectively an unreasonable burden. If someone installs some PHP script meant for say version PHP 7.1 or else it will literally break due to syntax backwards incompatibility in 7.2 it's not a reasonable expectation that they must perpetually retain a PHP programmer on staff to fix the code, update the server, the run time, and the PHP script itself every time a new version of PHP is released in perpetuity. I just honestly don't see this as a realistic expectation. Especially because it's not even really like every operation that uses PHP is even an organization that has staff. Many are simply self hosted for fun or community operations running on donations really at the whim of the open source community to patch bugs. PHP started as a very grass roots type of language and many people still use it this way and I have to defend that use case. If I feel like spinning up a wordpress install on a $5/month ubuntu VPS and never touch it again for 5 years because the database is auto backed up every 24 hours and it never touches anything even remotely important like banking or medical data then it doesn't even matter if it is hacked, if it even is. I've seen systems in production not get updated for longer and never actually be compromised. When brings me to my next point: Local Area Networks Sometimes software built for businesses is running internally on their LAN. Employees are using it and it's never exposed to the internet in any meaningful way. If I wrote some code that said in it's composer file that it's using PHP 7.0.x. Well then I better get PHP 7.0.x. Which brings me to: personal use. I could write a custom script for my raspberry pie that edits the hosts file on it so that I can adjust DNS resolution on my LAN. Is it reasonable that I keep going back to it every time there's a new version of PHP? Nope. Finally: Command Line. I love using PHP for CLI scripts. PHP is a great scripting language and the code is usually cleaner than bash files so I tend to use it quite a bit. If these CLI scripts are accessing external services it's again reasonable to use an old PHP run time. tldr; stop removing old php runtimes from package managers. there are valid use cases. not everything lives on the public internets. not everything is mission critical
That does not apply to objects though, and therefore not this RFC. ^^
congrats!
No, Hard drive 
No
Okay thanks 
Sometime it takes up to 10 mins 
I am on Linux but HDD
Will try
Okay thanks 
Okay 
Thanks bro 
Indeed, I see this as a door opening to doing serious AI projects in PHP...
Good news really
There could be a compatibility mode or something. The comparison situation has been bad for 25 years and I'm not sure that's a reason why it should have to be bad forever.
Looking forward to 2044 when we have to use ≡≡===≡ to express a comparison that addresses all the issues with previous comparison operators.
&gt; 7.0.x is end of life meaning no security updates. It's still getting them from package maintainers at Debian etc., because it's what they're shipping in their stable release.
I have a very slight feel-good moment when I see posts like this, validating my decision to skip learning Doctrine.
I’m sure my struggles give Doctrine a bad name, but I don’t think I’m inept as it sometimes makes me feel. 
This is an excellent list! I find it rare to read an article that has entirely things I've didn't know about. You hit the jackpot on this one, I learned 5 new things today! :)
Congrats man! 
amazing
Never used doctrine but everyone speaks in high regards and laughs off ActiveRecord alternatives (like Laravels Eloquent). Yet have to fully embrace it and check it out. And yet: we're having a new hire since a few months, he worked with Zend and Doctrine and first thing he asked about Eloquent (he never worked with Laravel): where's the entity manager? Aren't the objects cached (i.e. you get a model by id and when you get it again, you receive the same object). I was like: uh, nope. Just pure objects, thin SQL layer, nothing else in between. Don't know what I expected but for a moment I found my answer inferior to what he expected, to my surprise he said he was glad, because this stuff always made things complicated. I've been working over 3 years in every growing Laravel / Eloquent project. Everything is a challenge: database size (nearing a 1TB data), complex SQL queries (window functions, lateral joins), figuring the best / perfect index, properly distribute background jobs, throttling, thresholds, complex business logic, proper architecture and abstraction, writing good tests, everything, But. Eloquent? That's really the least of the problems we're having. In fact, we don't have any. It feels super thin, new devs pick up more-or-less easily, there's no-so-much-magic involved (query you write is what you get), only has a few gotchas in its basic usage. TL;DR: 🤷‍♀️
Intresting
Thanks man, that's very nice to read! :) Which one do you find the most useful to you?
How to pay outrageous prices for SMS.
I would say, start simple and small. You want two php containers and one mysql container? And I suppose you simply have some php code to run in those php containers? Start by directly using the standard php containers from docker hub, and mount the code inside them. To manage everything, stay with docker-compose. It works great for small things. Until you start deployment on multiple machines, you do not need docker-swarm or kubernetes. Oh, and most containers have the philosophy to do one thing. So you probably also want an nginx container. 
Come to the dark side and use ActiveRecord ;-)
There's a "BSD license" joke in there someplace. ;-)
What seems to be the problem? You almost never need to use uow except in \`\`flush\`\` events. &amp;#x200B;
Congrats!
I simply can't get it to run. The existing route seems to be looking for app/MVC/ - subfolders that aren't in the project. &amp;#x200B; So it's hard for me to give it a deeper dive, but this is what bothered me while exploring: &amp;#x200B; \- Defines &amp; htaccess-bases as well as the direct use of $\_SERVER\['DOCUMENT\_ROOT'\] require quite an amount of re-write to use this outside of the web-root of my server. &amp;#x200B; \- The "auto-loader" creates an issue with code-completion, an important factor when using a framework. Additionally, the file\_exists (line 17 of bootstrap.php) will always return false &amp;#x200B; \- The excessive use of global functions pollutes and makes it hard to maintain/update functionality (e.g. mail) &amp;#x200B; The folder-structure is a matter of taste, of course, but since you are working on documentation I would suggest providing some guidance here for an easier start. &amp;#x200B; On a completely different note: I know from experience that finding people to participate is rather hard. Provide a starter-app. This will give testers immediate benefit as a start and once they are invested (e.g. because they are using it somewhere), they are more likely to help you.
Probably 3 and 4, but all of them are good to know. :) I use Up on lots of chat clients, never thought to try it on GitHub.
The entire section about "faux sockets" is just completely wrong. The author seems **very** confused about how unix sockets, network sockets and loopback addresses work.
Fopen...fwrite...fclose. Fopen...fgets... fclose
Would you not want to catch that particular exception in some cases rather than general exceptions? I can see where littering your own code with specific exceptions would just add clutter but I think that it is useful for a library to allow handling their exceptions in very specific ways.
You could try tideways. 
There’s also this (videos of course): https://laracasts.com/series/whats-new-in-laravel-5-8
I can simplify that: `file_get_contents` and `file_put_contents`.
It's perfectly deterministic. It will consistently produce those results. Why is it that way? Philosophically, PHP is a web programming language and a lot of input is as text, so treating strings containing numbers like numeric types sort of makes sense. Anyway, you are looking for `sort($arr, SORT_STRING)` or `strcmp()`.
I’m not using the UoW, it’s just its order of operations that’s killing me. Or it was. Now, it seems I have some dangling entity somewhere that is causing two copies of the same entity to be try to be persisted (it fails due to a unique constraint on a FK), though I can’t for the life of me find where it is. I’m hip-deep in xDebug stepping through the EM implementation trying to find where in its mapped entities I somehow have managed to mis-wire something. At the end of the day the problem is me, not Doctrine, though if this were 15 years ago I’d have finished this with a couple of simple queries about 5 hours ago. Maybe I should just roll back to native queries and go on. 
tracy
Nothing stops you from compiling old PHP versions and using them. You don't need a repository for that. 
Good job man!!
Trust me, you are doing it wrong. Doctrine has identity-map so it will automatically take care that you \*\*cannot\*\* work with copies of same entity. This is what is makes Doctrine so bad-ass. &amp;#x200B; You can only break it if you do $em-&gt;clear() but \*\*don't\*\* use it if not sure what it does. That's the only way that can lead to problems you described but it is easily solvable. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Can you give me an example?
Or use \`natcasesort\` [http://php.net/manual/en/function.natcasesort.php](http://php.net/manual/en/function.natcasesort.php)
I think I just admitted that the mistake was mine (other comment). I know the map prevents duplicates of the same entity. It does not, however, prevent one, through a series of manipulations and cloning, from accidentally connecting two clones to the same entity in a way that violates a FK constraint. Again - I know the mistake is mine. It’s just been a long day. 
I do know how to use file put contents and file get contents but with the keys I am not able to figure it out
&gt; Since another version of this framework, much improved, I still use it for my projects and my clients' projects. This is the problem. With all due respect, if you are using CI or this project for client work then you are, at best, doing your clients a disservice. Personal projects that you are financially and legally responsible for? Go for it. Client work? Different story. I used CI extensively in the in the late 20-aughts. It was excellent because it was architected in a way that made PHP 4 and 5 less crappy. Nowadays, there is no such excuse. Think about the next developer who comes in to maintain your client work. Do you think they want to spend the time learning your framework or do you think it would be in the best interest of the client if you used something a little more standard? 
The php docs can give you an example.
This tutorial seems a little backwards. Auth in Symfony 4 / Flex is so easy now, there is no reason to use FOS User bundle. I've gone so far as to refactor FOS User bundle out of my projects because it is getting in the way. Second, why FOSRest bundle over API Platform? API Platform is the preferred way to rapidly build a REST API with Flex, it even has an official recipe.
Hell yeah! Congrats!
Invest 100$ in an SSD, it will speed up your development a ton. Mainly for searches. Some things take 24 sec vs 4min from SSD to HDD. (Ubuntu)
Check you aren't stuck using the userspace proxy, that thing is infamously slow. I didn't think that was the default any more, but I'm not positive. Side note: You might want to use an upstream block in nginx, and set up the resolver time out stuff. Otherwise it can end up only resolving "php" during startup, and when your containers rattle around on a production cluster nginx won't keep up with the IP changes.
When you run base metal, your network request go through the loop-back, so they pretty instant (kind of like sockets), when you use an LXC or docker, it goes through the network, adding a few extra hops. &amp;#x200B; Your 7000 requests per second, seems very wrong, looks more like downloading a cached file, to the same location (gets it from the disk once, puts it in the cache, and moves to to another cache location). Should probably be like 700 for a normal php script. &amp;#x200B; Your 100 requests per second, seems a bit low, but should be lower than bare metal, depending on your use case (mainly because those extra network hops), should be like 500-600 for the same job on the same machine with docker. (or close to 700 if set up good) &amp;#x200B; If your comparing apples to apples, chances are something stupid is wrong, file descriptors, using some bad dns, etc. &amp;#x200B; Try installing netdata ([https://docs.netdata.cloud/packaging/installer/](https://docs.netdata.cloud/packaging/installer/)) on your metal, and run that while you benchmark, you should see where it bottlenecks to give you an idea what's wrong. &amp;#x200B; 7000 vs 100 tho, seems like cached static files vs some script.
Nope. It's a simple echo 'hello world' and that's why it's worrying. As stated in my OP, when I use a ubuntu image and configure nginx/php-fpm it gets 7k, unlike my nginx and php-fpm images together which is 100rps...
What's your CPU? And try netdata
When I put the keys using file\_put\_contents("key.txt"); and again retrieving using $key=file\_get\_content("key.txt"); and using it in openssl\_public\_encrypt it gives me the following error: "openssl\_public\_encrypt(): key parameter is not a valid public key". Is there a specific way to store the keys in a file or a specific way to retrieve them from a file? 
That's assuming he wants to run a web app. Use the PHP images from dockerhub and yes docker-compose is pretty much all you need until it is not.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Symfony and Laravel (Mostly Lumen for smaller projects).
You didn't generate a valid SSL key. GOOGLE: public key generator php 
Why the proposition isn't to make 0 == "string" into "0" == "string" is surprising. This is one of the more backward thinking conveniences in PHP.
That is yet another unreasonable burden. Especially for a VM with only 512MB of RAM designed to pull precompiled packages from repo. Heck half the time composer will run out of memory. I tend to have to setup a temporary swap on small VMs like that. On top of the memory requirement you also need to install the build environment and all it's dependencies which on a small VM might easily overwhelm it's tiny disk allotment. But honestly I'll let the top commentator from this HackerNews post from literally *today* speak for me as to why these security notices are mostly all FUD. [The most popular docker images each contain at least 30 vulnerabilities](https://news.ycombinator.com/item?id=19255603) My favorite parts: &gt; The quantity of vulnerabilities in an image is not really all that useful information. A large amount of vulnerabilities in a Docker image does not necessarily imply that there's anything insecure going on. Many people don't realize that a vulnerability is usually defined as "has a CVE security advisory", and that CVEs get assigned based on a worst-case evaluation of the bug. As a result, having a CVE in your container barely tells you anything about your actual vulnerability position. In fact, most of the time you will find that having a CVE in some random utility doesn't matter. Most CVEs in system packages don't apply to most of your containers' threat models. &gt; Why not? Because an attacker is very unlikely to be able to use vulnerabilities in these system libraries or utilities. Those utilities are usually not in active use in the first place. Even if they are used, you are not usually in a position to exploit these vulnerabilities as an attacker. &gt; Just as an example, a hypothetical outdated version of grep in one of these containers can hypothetically contain many CVEs. But if your Docker service doesn't use grep, then you would need to manually run grep to be vulnerable. And an attacker that is able to run grep in your Docker container has already owned you - it doesn't make a difference that your grep is vulnerable! This hypothetical vulnerable version of grep therefore makes no difference in the security of your container, despite containing many CVEs. Speaking of docker. Docker images rely on specific version numbers in it's manifest files. If a version is missing from the package manager the correct solution would not be to upgrade the syntax to the latest and greatest version and then edit the code. No in that situation the correct solution is to simply switch package managers or Linux distros because clearly the package manager is no longer doing it's job. Here's a great example of this: https://old.reddit.com/r/PHP/comments/a4vggg/php_70_removed_from_homebrew/ebhyad6/ It is the antithesis of a package manager to de-list packages to be more "secure". Software sometimes relies on old versions and no amount of feel good "you should be upgrading" will change the numbers for a business. &gt; "The site is down. Fix it". The cost of having your site down right *now* is greater than a hypothetical intrusion in the future. In other words no sane project manager would ever approve hundreds of hours of work to update the code and servers instead of just pegging the version of PHP to whatever they damn well please. And I'm not even getting into the use case of wanting to potentially try out an old abandoned piece of code and having to use an older version of the run time because it literally would not work on the latest and greatest.
Laravel with all of it’s buried code (via Facades) always stood out like a sore thumb to me. It seems wrong when you have to add a package to get code-completion working on an IDE. I’m always amazed when I see how quickly Jeffrey from Laracast or Alex from Codecourse makes it seem working with Laravel, but I just could never “get it”. I think it’s mainly eloquent that I dislike the most really. Symfony (and Doctrine) on the other hand? It just feels so natural and easy.
I wanted to get and analyze AST, CFG+SSA, node positions and comments with performance as [nikic/php-ast](https://github.com/nikic/php-ast) without requirement PHP to be installed. I think the best purpose of using my lib is projects like [SourceGraph](https://sourcegraph.com) which works with big codebases. ps: I am a typical developer, I first do then think why)
No. Stop using anti-patterns.
I've never tried Symfony because I heard it was more difficult, or something, than Laravel. Maybe I should try it. 
What are pros and cons of Symfony. I too feel the same about laravel.
Oh, I do believe for almost everyone who isn’t me, Laravel is/should/supposed to be “easier” than Symfony. It just doesn’t feel right to me having to dig through a bunch of files to see how/what a facade is doing. For lack of a better word, Symfony on the other hand seem like “natural” code.
Oh, I do believe for almost everyone who isn’t me, Laravel is/should/supposed to be “easier” than Symfony. It just doesn’t feel right to me having to dig through a bunch of files to see how/what a facade is doing. For lack of a better word, Symfony on the other hand seem like “natural” code.
For me, the pros are it feeling (and reading) like “natural” code. You don’t go digging through a bunch of files to find what something is doing. You don’t need to install a package to have your IDE have working code-completion. There’s no feeling of black magic to the whole framework. There’s no updates to the that introduce breaking changes. I really, truly wish I could “understand” Laravel but for whatever reason Symfony just clicked so much easier.
Facades are entirely optional, by the way. It's just sugar over the DI container.
I expect that issue is related with cascading persist: [https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/working-with-associations.html#transitive-persistence-cascade-operations](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/working-with-associations.html#transitive-persistence-cascade-operations) Doctrine is very powerful tool and you definitely should use it. I't has it's bugs as any software but they appear only in edge cases and in case of very complex entity mappings.
Laravel is a great entry point for beginners.
Dude, It's blogspam. Report it and move on. 
Note that one of the important addition is **hasOneThrough** and **hasManyThrough** in Eloquent. They are not listed in *what's new* lists but you can find them in Eloquent: Relationships docs.
Blackfire
Sharing useful information is called blog spam?. I can't understand you dude!
&gt; While using the gateway implement all method where you get Not implemented exception: lmao &amp;#x200B;
I personally preferred to use laravel. Thanks for every one for suggesting your feedbacks.
Oh the dreaded Payum. Every single developer who did their first custom gateway struggles a lot because it is just weird and when you consider integration into Sylius is get's even more weird :) But it works, I actually did 3 gateways to date and it is way better now than it was a year ago. I strongly suggest you join Sylius Slack and start asking questions when you get stuck - we are quite helpful and if you show understanding of the subject and just got stuck - you might even get a full implementation example sent :) I know I sent my implementations for the gateways quite a few people to use as an example. &amp;#x200B; I suggest you stick with it and learn it. It is a very powerful piece of software and it is a treat to work with. But as any good and rather complex piece of programming tech - expecting to master it in a few months is ridiculous. 
What? A talking karma-whore? You have not a faintest idea which information is useful and which is not, so dom't bother posting here. This particular article is written by an imbecile. It's a model example of a useless blogspam, each framework 's description could be applied to any other, it's just a list of random features. WTF Codeigniter is "free to use"? ARE TWO OTHERS GOT TO BE PAID FOR?
New relic
laravel entirely new platform in 2019? slow? no community support? lol there is no reason to use codeigniter nowadays since its so outdated it doesnt use anything that new php versions introduced. things might change with 4.0 but we are not there yet. you gotta hate yourself if you start new projects using it
seems you answered your own question: Docker is the difference its added not only software bloat to your stack but also more networking try test compare on live cloud server instead you also do not share what is your Nginx config on other server....
You should ask yourself: Do you really need docker?
This is great. I am just about to start a internship to develop API using PHP damn, Im still a beginner lmao
&gt; Here's a great example of this: https://old.reddit.com/r/PHP/comments/a4vggg/php_70_removed_from_homebrew/ebhyad6/ &gt; It is the antithesis of a package manager to de-list packages to be more "secure". Software sometimes relies on old versions and no amount of feel good "you should be upgrading" will change the numbers for a business. This is wrong. As /u/nikic said in that post. https://old.reddit.com/r/PHP/comments/a4vggg/php_70_removed_from_homebrew/ebhy7eo/ &gt; If you provide a package, you need to provide security support for it. If there is no upstream security support anymore, then it becomes the responsibility of the packager to directly deal with security issues, for example by backporting upstream fixes for newer versions. This is what Linux distributions commonly do, and how RedHat basically makes their money. If Homebrew does not perform security maintenance themselves, then of course they must remove packages as soon as security support ends. There's also the maintenance burden of keeping old versions in a package manager. 
&gt; Oh the dreaded Payum. &gt; &gt; Every single developer who did their first custom gateway struggles a lot because it is just weird and when you consider integration into Sylius is get's even more weird :) I'm not quite sure I understand _why_ Sylius has gone down this road, added the way you speak of it too. Payum seems like a terrible solution, poorly documented and less than developer friendly. &gt; But it works, I actually did 3 gateways to date and it is way better now than it was a year ago. Well, I do understand that it works and that the problem probably is probably in my skillset. &gt; I strongly suggest you join Sylius Slack and start asking questions when you get stuck I already joined, but my problem currently isn't Sylius - it's Payum. And I see that other already made questions about Payum, but most answers just confirm what you're saying - that people struggle with Payum. &gt; I suggest you stick with it and learn it. It is a very powerful piece of software and it is a treat to work with. But as any good and rather complex piece of programming tech - expecting to master it in a few months is ridiculous. I think you misunderstood me; I'm not expecting to "master" Sylius within the given timeframe, but I was certainly expecting that something as (what I consider) simple as adding new payment gateway would be a lot less "here are som notes, do some reverse engineering and guess works" and more "here's the documentation, have fun". So currently, I'm stuck with that "simple" task before even being able to get back to Sylius; I do think that Sylius seems promising, but this hurdle has gotten me demotivated.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I find sourcemaking a good website: https://sourcemaking.com/refactoring
Drop a line in #support, tag me (same username), I'll help with payum. It is fairly simple, it just has to click (and yes, I did think that I was stupid after I got it). OmniPay lib is even worse, so whatever payment lib you use- it's a struggle anyway.
I've done about 7 Payum gateways. It became quite easy to made one. I agree that Payum documentation is quite hard to understand, but english is not my main language so I think my documentation would became hard to understand. Would you be interested in tutorial how to make Payum gateway step by step?
Stick with it, eventually you'll get it, and it's going to feel amazing. I don't know how many times I've had to reverse engineer things by looking at source code of other working examples because the documentation is so bad.
&gt; Would you be interested in tutorial how to make Payum gateway step by step? I'd appreciate it and I'm sure that a lot of other new Payum gateway developers would like it too.
&gt; Drop a line in #support, tag me (same username), I'll help with payum. I'll do that when I get home. Thank you. &gt; OmniPay lib is even worse, so whatever payment lib you use- it's a struggle anyway. I agree, OmniPay is not better in any way. I think it's odd that both is so difficult to get started with. 
Yes, that’s what I thought also, which is why the last thing I did last night was remove all cascading persist settings on the entity in question and set it to deferred explicit change tracking. That’s when I found my problem. It was in a custom __clone method I had written but failed to update when I added another relationship to the entity. Thus, when I cloned the object and rebooked the new parent/child entities, the clone of the parent carried with it a reference to its old child. In some scenarios this would lead to two entities trying to point to the same new parent, which is what was leading to the unique index violation. As I expressed earlier - my fault, not Doctrine’s. I don’t have any plans of leaving it, but after using it for the past several years on projects with Symfony, I am becoming a big fan of avoiding all cascade annotations and setting entities to deferred explicit change tracking (especially as they are phasing out the ability to limit a flush operation’s scope by passing it an object). 
1e3 is a number, it is 10 ^ 3, scientific notation. The results seem to be correct and have nothing to do with sorting.
`hasManyThrough` was around before. I'm using it in a `5.6` app...
Sorry about that, you're right, I mixed stuff.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What is the best way to prevent wrong states in an object? This is the source of my question. Basically my curiosity started with the intention of not letting a class exist with wrong values. Prevent programmers from making mistakes in class implementations and extensions. I did not want a class to even bother to have to deal with a wrong value. I just wanted it not to be started if a wrong value of a given status or type was passed. I work a lot with types in string, due to a demand for legacy code. For this I find it interesting to work with "value objects". That aparently is the primary design idea. I tried to go for something with stringly-typed (another new term I just found out). So below I have the first example. The scenario is: a class need a type and instead invoke a string 'type_x' invoke a class and this class solving the value if it is valid. This class is the one we will see below. /** * StringlyTypeSecondOption */ class StringlyTypeFirstOption { private $type; public static function type_1() { return new self('type_1'); } public static function type_2() { return new self('type_2'); } private function __construct(string $type) { $this-&gt;type = $type; } public function __toString() { return $this-&gt;type; } } echo StringlyTypeFirstOption::type_2(); //here its ok echo StringlyTypeFirstOption::type_3(); //here we have an error cause type_3 doesnt exists This is a very good example because we havent no if or throw exception or any logic of verification. Is oop on its own. And I think its good. And now we have the second example. Will provide a solution for the same problem I proposed. class StringlyTypeSecondOption { private $type; const TYPE1 = 'type_1'; const TYPE2 = 'type_2'; private const ALLOWED_TYPES = [StringlyTypeSecondOption::TYPE1, StringlyTypeSecondOption::TYPE2]; public static function factory($type) { if (!in_array($type, StringlyTypeSecondOption::ALLOWED_TYPES, true)) { throw new Exception("Invalid type: {$type}"); } return new self($type); } private function __construct(string $type) { $this-&gt;type = $type; } public function __toString() { return $this-&gt;type; } } echo StringlyTypeSecondOption::factory('type_2'); //here its ok echo StringlyTypeSecondOption::factory('type_3'); //here we have an exception cause type_3 doesnt exists Is a very good example too but I already have some logic and is not so pure like the first one. But solve the problem like a charm too. Both imlementations have strengths and weaknesses (I think). But if there is a consolidated design that fixes allowed values for a state of a class, what its name how to implement and what is the best oop beatiful and designed strategy to prevent an invalid value in an object? I think this is more a discussion over an exact solution. If this was not the right place I ask the moderators to direct me to a better channel. Thanks advance!
How to fix this?
No it is not. It is a string, not a number. I want `&lt;` and `&gt;` to behave like `===`. Its insane it converts numbers to strings just because it thinks it is a number.
It converts strings to numbers because `&lt;` and `&gt;` only work on numbers in PHP. If you want to sort strings as strings, you have to use something else.
Just bringing this up here as well: [https://github.com/php/php-src/pull/3300](https://github.com/php/php-src/pull/3300)
I see :) And what is the ultimate goal of all that? Just having some statistical numbers, or action steps to change the code?
&gt; I use Up on lots of chat clients, never thought to try it on GitHub. TIL. I never knew it works somewhere else :) will try
Congrats! 
[symfony stopwatch](https://symfony.com/doc/4.1/components/stopwatch.html) is pretty easy to use. also, you can always just use standard \`memory\_get\_usage\` and \`memory\_get\_peak\_usage\` (to get the 'heaviest' memory usage).
Yes, it is.
There are several ideas that I want to validate: * a visualization tool that shows a call graph * a search util * PHP Language server * code style formatter
&gt; yet we still found we could push through nearly twice as many requests to PHP-FPM from nginx when switching to TCP sockets. Are there any benchmarks backing up this claim? I was always under impression that unix sockets have less overhead and thus are always preferred if everything is running on the same machine.
Nice, are you using a specific noise algorithm or just some randomness? Is this considered good practice, a class that does nothing except define some constants? Interested to see what people think &amp;#x200B; class FileType { const PNG = 'png'; const JPEG = 'jpeg'; const GIF = 'gif'; const WEBP = 'webp'; } 
A possible refactor would be to have a class for each one of these types to separate concerns. &amp;#x200B; These class instances would be used instead of having swiches: [https://github.com/IndyIndyIndy/landmap-generation/blob/86b876211b3b23bdb2740c8f3bb35a6a8506e321/Classes/Utility/ImageUtility.php#L20](https://github.com/IndyIndyIndy/landmap-generation/blob/86b876211b3b23bdb2740c8f3bb35a6a8506e321/Classes/Utility/ImageUtility.php#L20) &amp;#x200B; It would also be easier to add a new file type
\+1. Didn't even initally plan for an ImageUtility output and everything in there is made for quick'n dirty output right now. That class would be the first candidate for some refactoring and decouplement.
I am using a diamond-square algorithm for creating a authentic looking altitude map. This is the most expensive part of the map generation and I had to implement some tricks to speed it up a bit. Like only creating the altitude for every fourth pixels, the rest will be interpolated by traversing through the 2-dimensional array, looking at the neighbours that already have an altitude and creating a middle value. The water is placed after that by simply the waterlevel to an initial value and checking how much of the map is now below that level. Then do a binary search up or down (raising or lowering the water level), check again, until the water level is the desired one (like 70% water) with a low error margin of about 0.5%.
Oh, and by the way, the algorithm is still really slow in PHP (being a JIT compiled language). I'll probably try to port everything to statically typed, compiled language like GO next, which should improve the performance drastically. (I really want to try out Go more...)
Really cool. As someone who's not very good at math but took a liking to it after leaving school, how did you learn the math you applied to this?
Sorry, I have no idea what you mean by those points. It would help me to describe something I can imagine, e.g. in scope of PHP code.
This question would be better suited for r/phphelp
I also rarely do any math-heavy stuff. The most complicated thing in this project would be the diamond-square algorithm. Everything else is really simple. For the diamond square algorith I looked up some pseudo code, tried to implement it in a object oriented way in PHP, and then started optimizing the performance with a few tricks. (But you can't help it, PHP is not the best language to do such a performance heavy task. You usually do something like this in C, C++, Go ...) Here is a simple explanation about the diamond square algorithm: [https://en.wikipedia.org/wiki/Diamond-square\_algorithm](https://en.wikipedia.org/wiki/Diamond-square_algorithm)
yes, keep telling yourself that not learning a widely adopted tech is good for you.
That's been my experience as well. Like I said elsewhere, very slight feel-good moment reading that. Doctrine is just so overly complicated IMO. Eloquent/AR has so much less of a cognitive burden when developing.
I don't doubt that in the slightest. I've read some of the Doctrine docs on a few occasions, and I kept thinking "damn this is complicated". I hope you get past this speed bump and solve your issue!
Well, haven't worked with a team that uses it yet, so it hasn't been a hindrance. I'm really happy using Eloquent. Literally never had any issues with it. Feels great to use.
Much appreciated. I figured it out late last night - as I expected, it was my code (__clone issue) that was introducing the bug, I just had trouble tracking it down until I modified my Doctrine config to do nothing automatically (disabled cascading and switched entity to require explicit marking for persistence). In fairness, one could say Doctrine helped me find the bug in my code, though that credit actually goes to the underlying unique index on my database schema. 
I have a non-trivial example project here : https://github.com/danack/example that has nice setup of multiple docker boxes for an example 'real-world' project, not just a 'hello world' example. And yeah, I know it needs more documentation but it might be useful for you to look at. I'd strongly recommend avoiding Kubernetes until you have a clear reason to use it. Although it is a very powerful tool, and provides a solution that is appropriate for many projects, it is quite difficult to learn, and is massive overkill for what most people need. For example https://phpimagick.com/ is running with just `docker-compose` with auto-restart on the containers. That means there is approximately a minute of downtime when a new version is deployed.....which for a project that no-one is paying for, is perfectly fine. If it's not for you, then you would need to add that capability elsewhere.
&gt; The idea is to have one MySQL image that doesn't go down, Why do you think you want to run MySQL in a container? Either run it on the host machine, or use AWS or Google cloud databases....MySQL in container is only useful for local development imo.
Hello, with great appreciation, thank you and answer the points that you highlighted in your comment. 1) I don't think PHP is really suitable for cli scripts but, I think it's light years superior to Python for the web development and for this reason I think that for now I'll focus only on developing it web-focused 2 and 4) My mistake, I wanted to publish it quickly waiting for someone to hack it to make it work. All you had to do was create a Controller called an indexed MainController to make it work. You know, the real problem was publishing it without coming out of my head first. I apologize to everyone, I repeat that it is my first PHP project 3) I modified the autoloader last night and I'm integrating it, rewriting the whole structure of the framework to ensure that it integrates the namespaces correctly. The import function will remain only for those who do not want to use the namespaces. To solve the problems that have arisen and to make sure that the feedback received have served something, I tried to make it more modern (composer, autoloader, strict types, correct documentation ...). Also in response to your advice I decided to publish the new version on github showing an example of a website (like a hello world page) that tells you how to start. I believe, subject to unforeseen circumstances, that everything will be available by tomorrow morning.
Those operators do work on strings. https://3v4l.org/q8oW7 *Numeric* strings are converted to numbers: https://wiki.php.net/rfc/string_to_number_comparison.
My fault and this reflected all evening was the extreme resilience to some methods, as a first project all in all I consider it valid and for this reason, following the many tips received and that I continue to thank, I am actively developing a more modern version of the framework. With regard to the criticism raised, I talked about some things but I never said not to use laravel or slim and yes, for customers I use these solutions especially because when you have to pass the work to another developer, the good community and the established standards count, much more than performance or whatever. You're right. This, or rather a more advanced version of this (but after tonight I think it is not really adapted to the latest standards), is used for some personal projects. Works, well and without bugs, so great. Now, however, having published this version and wanting to update, improve and make it really effective, I've been focusing for 24 hours on releasing a more recent, modern version that is possibly appreciated in the future. Thank you for that. 
Lots of things could be the problem. It's going to be hard to say without seeing the project in action. Can you put a clonable working version in github? The way I would investigate this is to run strace inside the PHP box to see exactly how long requests are taking to process and which system calls are taking up the time. Script is here: https://gist.github.com/Danack/de16db746dd2c6a29c8d If you send some load at the box, you'll be able to trace through (eventually once you understand the output) to see where the time is being spent.
Please try /r/phphelp This subreddit is meant for language/ecosystem-related discussions rather than providing support. Good luck!
You mean I share a folder on my windows environment and use that share for the linux VM using samba, setting it as the document root?
Doctrine is a powerfull tool... And that's part of the problem. You start using it, it feels cool, at some point you get confident, hit the throttle, and suddently you get throught the wall you intended to bore. 
It's just a basic index.php file with hello: [https://github.com/TheDeepNate/debug](https://github.com/TheDeepNate/debug) that's all I'm trying to run atm
&gt; (being a JIT compiled language) I guess you missed a "not". It is still in discussion for php 8
This might work for a project I am doing. Is there a way to tell what is water and what is land? Is there a way to recolour the water? And finally is there a way to generate rivers and lakes in the land mass?
You should also make the heightmap generation algorithm configurable since several ones are well known in that field, with different trade-offs. For instance it might be faster with a perlin noise and even faster with a simplex noise. &amp;#x200B;
I'm curious to know this as well.
&gt; there is no reason to use FOS User bundle can you elaborate on that, please? &gt;why FOSRest bundle over API Platform and on that, if you don't mind. I'm used to use the FOS solutions and quite surprised they fell out of use. &amp;#x200B;
Thanks, will give the diamond square a look, need to produce something similar and looking at different ways. 
It is. The LandmapGenerator just requires a AltitudeGeneratorInterface in the constructor and you can create your own one. (forgot to document this)
Knowing how to code and knowing how to work with some particular tool are very different things. I've also been at it for ten years, have done lots of studying during that time, and feel like I can intelligently approach many coding problems, but have no experience with Magento (or Payum) and would take probably weeks to do something simple because I've never worked with it. You can't know everything and when running into something new, there's always going to be a ramp-up time while you learn the requisites to being functional with it.
Thanks but that's a whole lot of money in my country and I can't afford it for now. If you still got any work for me, I will appreciate
this is pretty general, but do you use phpstorm? it shows available public methods and whatnot and makes it way easier to develop against a library imo. mix that with unit tests and i think you could get through this. awesome that other devs are stepping up and offering help here. you're not an imposter.
Well done ! About naming: why "Altitude" when "HeightMap" is by fat the most common name ? And why the default implementation is named "AltitudeGenerator", wouldn't it be clearer if named "DiamonSquareAltitudeGenerator" ?
I feel dumb for never realizing till now that mirrors weren't just used as site backups but also as a proto CDN. Pretty cool.
For auth in Symfony 4, install the Maker bundle. Now you can just run `bin/console make:user` and make a user entity. Customize this entity however you'd like, add doctrine annotations if it is going to be stored in a database, etc. Now run `bin/console make:auth`. You have a guard authenticator, a login form, a controller, everything you need to log in. At this point, the only thing FOS User bundle simplifies is registration, which isn't terribly difficult, and to me at least, not worth dealing with the config and overrides of the bundle. FOS rest bundle isn't bad in my experience, especially if you already have an app and want to add API functionality. But if you're starting out with a brand new app/API, it is much quicker to start with API platform because it simply uses your entities to define the API endpoints. It uses a lot of autoconfiguration, but it is customizable. So really, the above article could be done with the following commands: composer req maker api bin/console make:user // Follow prompts to make user entity bin/console make:auth // Follow prompts to create auth bin/console make:entity // Follow prompts to create movie entity bin/console server:run
Make sense. In addition, if there's any issue with the current CDN, I'd be willing to bet a pizza there's probably half a dozen major CDNs with marketing teams that would be happy to host for free in return for some kind of simple recognition. 
Well back in the day they'd tell you their location and bandwidth. Usually sorted by proximity to you.
Nothing. It's just that all the busy work is done for you, and done well. 
Laravel is vanilla PHP
You don't need a car to travel. It just makes it a lot easier and faster. Laravel is the car, standard PHP is your legs.
If you can make it with laravel, you can make it with vanilla php. If you can’t make it wich vanilla php you cant make it with laravel🤪
I like the idea you shouldn't start using a framework until you can code your own. Once you know why they are there and what they do you'll be able to make a decision about what is needed for your projects.
To build a call graph I need to know about which type variable contains, so I need SSA+CFG, I can create it from AST, so I need AST. Therefore, I need PHP-parser. Same with search util. For example, there needs to find variables that, depending on conditions may contain values of different types. Typical PHP project with dependencies contains more than 10k files, so I think performance matters. Golang faster than PHP and more straightforward than C for writing tools, so I believe, there is someone to whom it will be useful.
Honestly, I disagree. I wish all these frameworks were available when I started, I had to unlearn so many bad habits instilled by writing everything from scratch.
I mean, nothing... because Laravel is build with vanilla PHP itself. It's just more a matter of "what do you want to not re-implement yourself". There's so many common patterns and services you'll end up needing along the way, and a framework just gives those for you right out of the box so you don't need to worry about implementing them from scratch. Every system you connect to ends up having some edge cases you probably won't think of your first go-through, but with a framework you can instead lean on the years and years of knowledge/experience that other developers spent learning and polishing those tools.
I understand what parser does and that Go makes it faster. I don't understand what change it produces in the real world.
EECMS is extremly great, but it was extremly costly, each upgrade was more and more money, they did not care enough about third party developers and they destroyed online forum with online help, so in the end, you could not even search for something new. EE as CMS is extremly fast, you can make lot of stuff with it, but it required lot's of manual effort to maintain. &amp;#x200B; My personal opinion (since I just got the news even though I had around 20 sites on EE CMS that each costs around 1500$ in licence fees and upgrades) is that ellislab just destroyed it's community and they try to get it back.
Does it need to be in the same directory? Using Composer you can mark php codesniffer a dependency of your tokenizer. If it absolutely need to be in the same directory you can create a custom installer for Conposer to take care of this.
It was a command-line config problem. My new code was a tokenizer and a standard. It turns out the tokenizer was being found just fine, it was the standard that was missing. Instead of specifying the name of the standard, I needed to specify the path to the standard in the CLI call.
Okay, so Reddit wouldn't let me add any body content, so I'm adding it as a comment. Anyways, here's the details. I am writing a small portable C++ web server I plan on using for quick and easy site testing. I found details on compiling PHP7 for embedding, and adding it to my makefile. It generates `libphp7.a` ( or whatever it's called, PHP is not building at the moment for some reason ). My primary code method now seems to be working, it does (minimal) parsing of the header, finds the file they want, pulls the contents, and gives it to the user. Checking for file extension is easy, and I can easily implement that. However, I can't seem to figure out how do I access the embedded methods in the shared library? I want the easiest way possible, if there is, to simply tell PHP/Zend/whatever "Hey, here's a `std::string` that has PHP in it. Can you parse it for me, and return the HTML output?". If I have to provide the file itself instead of a `std::string`/`char*` array, fine. I just need it to parse the PHP for me. I don't plan on adding really any modules into PHP at the moment. That may change latter, adding modules to allow for scripts to control the portable web server ( maybe even using php to allow for an optional config file; if not php, likely JSON or a serialised structure ). &amp;#x200B; Any help you can provide is really appreciated. I am doing all the programming on my MacBook, however, I am soon going to be trying to setup automatic CI with a GitLab runner and Docker on my server (Ubuntu 18.04) if that's important. The instructions I followed to build the embeddable PHP file is located at [this StackOverflow response](https://stackoverflow.com/questions/6953864/building-libphp5-so-for-embedding-in-c-c), the first response. Thanks in advanced for any help!!
Yeah, right. And then you will be spending ten years on the boilerplate :) I haven't done this with PHP, but I have most certainly created my own game engines in C++. Very useful, but hardly productive.
Maybe Laravel is teaching you some different bad habits. At least you got to learn what it offers you, if you never get it wrong you'll never learn.
A few small complete php projects should be first done with no framework.
op is a troll, look at their history
Well in my case, I'm trying to achieve load-balancer / rolling update -style architecture... while living 100% on a free-tier EC2 micro :P So there's that.
Funny how all of r/PHP are aghast at you saying this, yet long time JavaScript devs all learned the hard way why it was important to understand the language separately from jQuery. 
Laravel is a great framework, as far as frameworks go, but I'd recommend simply putting composer into your project, and reading up on the PSR defined interfaces first. With good dependency injection and a better understanding of what your objects actually implement, you may find yourself continuing to wonder why you need to install a whole framework instead of just the libs that you actually use. Personally all my work renders to JSON , and I deal with so many legacy tables that configuring a full orm would be a nightmare, so I'm just Slim for routing, php-graphql, and PDO for all my querying via prepared stmts. My presentation layer is almost 100% React, and my php is mainly graphql resolvers calling my models, which run a very thin orm (but could be any orm, really) for doing PDO. Personally, I'd rather have a solid hammer, screwdriver, and buckknife than a big fat Swiss Army knife. 
Use Laragon?
may I ask what you goal is? Do you want to sell goods online? Or do you want to sell your software to E-commerce companies?
&gt;Laragon Maybe I'm confused and missing something, but that seems like an entire web server itself. Not what I really want. As my comment ( since I couldn't add text to the post ) said, I am writing my own portable mini web server. I built PHP7 as a embeddable static library, I just need to now know how the heck I am supposed to use it, haha. I just need to know what to do, either creating patches in the PHP code to expose the APIs, or what already exposed methods I need to call, so I am able to tell there PHP "Hey, take this file('s content) with PHP in it, parse it, and give me back the HTML result. Thanks!" I'm sure it HAS to be possible. Otherwise, how could other web engines use it, like NGINX, Apache, etc. I know it's somehow possible, but the problem is actually figuring out the how. I don't want to write an entire PHP parser myself, since it wouldn't likely work right, it would be riddled with bugs, flaws, patches, and be slow as heck. Thanks for the response, and any further help you can provide.
I just realised I should've posted this in r/PHPhelp. Sorry, I am posting this over there.
I'm not entirely sure what you're trying to do/goals are (e.g. if you are targeting an OS with processes, which wheels you are reinventing for fun), but if you are in a traditional multiprocess environment, and it's compatible with your goals, I would consider delegating over IPC to PHP FPM (FastCGI) which is purpose-built for this. Historically, the PHP interpreter has been less than perfect about memory hygiene - coming from a background of CGI-style execution, where if you leak memory here or there it doesn't matter because the whole process gets cleaned up with every request (or with modern mod_php or FPM usage, every N requests). I wouldn't personally want the interpreter in-process with anything else I care about/am responsible for. 
I think it would be very hard to get a grasp on PHP enough to use a framework without learning some vanilla PHP first but /u/MatthewPageUK's assertion that someone should be able to code their own framework before using one is silly.
I'm sure frameworks can teach you some bad habits as well, but structure compared to no structure will always be better.
It is not intended for commercial use. The project as of now looks really bad for recruiters to look at, and I want to make something presentable.
As a hiring manager I put more weight on the activity within a personal project and the substance of that activity. Meaning your code can be poor, but by looking at your commit history, can I see sound decisions being made in refactoring your application, and is the code quality improving. Here’s a few other things I look for: A good commit history. There was a blog post by a Chris Beams (on phone, so apologies for no link) on writing commit messages. This should be required reading IMHO. Following a code style standard is crucial. You can roll your own, as long as it makes sense (meaning easy to read) and you are consistent in its use. Comment your code accordingly. Write tests. Any kind of tests. Functional, Acceptance, Unit, Any rest is better than no tests.
Thank for your insight, I'll look into writing better commits. And yes I also think that a coding standard and test unit is crucial as well as documentation. I have another project: address book in C (https://github.com/rmzelnick/addrbook) which I created, unfornately there is no commit history because I wrote the whole thing in one sprint. But I do follow my own coding standard (naming variables and functions, and syntatic stuff), I debugged &amp; checked the whole thing for leaks, documented, wrote test cases, setup the deployment system, and added continous integration. And I also made use of a nice Readme template so that recruiters can read. Unfortunately for this PHP project things didn't look so good because my partner and I worked side by side going into each others home, and we split up the work by files because he didn't know how to use git. But we got a good grade and it works. But I want to do the same thing for this project. So now I am re-writing the GUI for views and later on I want to write down the user roles, use cases, class diagram, and sequence diagrams as well as documentation classes and methods, unit testing, deployment and if possible continous integration.
&gt; PHP.net team has no access to the mirror servers, we also can’t make sure the mirrors are up-to-date, and some mirrors are still running PHP 5.3 (actually, about 25% still run PHP 5.3!). Haha holy crap
laravel is vanilla php at the core. So .... Your question doesn't make sense
A fact is that over the 20+ years of PHP company's come and go and management changes priorities. Thus selection of provides for core infrastructure is critical. The main providers are recognized on http://php.net/thanks.php individual mirrors in the current structure are recognized on http://php.net/mirrors.php
I'm a little bit confused but .... from my understand, you're basically trying to tell me to interface with PHP on the system via PHP FPM. That won't work. The idea with my program, is while you might have to build it once, once you do ( at least on your system ) you can move it around anywhere, you don't need to worry about installing and managing softwares. Everything is contained in one executable file. From my understanding, I should be able to build two .exe files, one x86 the other x86\_64, and then all (most) Windows users would be good, and MacBook should require more-or-less the same. I only want to have to distribute either the source or the executable. No preinstalled software requirements. That's a big reason why I'm working on this project. When I'm testing code on my MacBook, for example, I don't want to have to install a website, install PHP and whatnot, configure everything, move my files into the directory, then check everything out, and make sure I don't mess anything up. I just want a click-test-done solution. That's the point of my project. Start the software, view your local website, close the software.
Is it possible to remove the mirrors without 7 years of bad luck?
FPM wouldn't have to be on the system, you could bundle it, just as you plan to do with the embedded interpreter. Thanks for more illumination on some of the "why" answers. If you want a portable desktop app... is there any reason you're dead-set on PHP? If it's for an academic exercise, I can see this as a potential interesting challenge, but if it's for an end-goal within an envelope of economic tradeoffs...
Sure, so long as you don't remove them by DoSing them until they break.
Mostly because I am writing it part for debugging. I write PHP code, so to debug my applications, I need PHP. I didn't know you could embed PHP-FPM ( just that ). Do you know a resource showing how to do that and how to interface with it? It's in part for learning, but again, as I said to meet a goal. I am going to be learning how to use .dll/.so too, so you could dynamically add/remove/update languages. I use PHP, thus, I need to parse PHP.
For postman, you need to select POST for the request type, select the Body tab, select raw and then JSON (application/json) like in this image: https://i.redd.it/5gsh5igk98j21.png That aside, i'd like to warn you that the tutorial you are using can be good for understanding the concepts of an API, but you should not develop your application like that. It is very insecure and would allow a hacker access to your entire database or worse. 
Yeah. In my case it usually comes down to opening ports in Windows firewall.
120gb SSD for 30cad, if that's too much $ and your looking for a free solution, then there's only so much you can do.
So in other words, modern load-balancing and more efficient methods of content distribution made the mirroring project obsolete?
We use Laravel where i work (Which is a giant multi-national travel agency). We used Laravel as the API layer for our hotel search and booking engine. Which then has a react/redux app built on top of it.
The clickbait-y title here is a bit of a shame because the underlying concept of using Netlify for your static assets \*isn't terrible\*. I wouldn't use Netlify as a proxy to my app, but you could easily have Netlify just run NPM and build your assets with Mix, and then use \`ASSET\_HOST\` in Laravel to point it to where your assets are built. 
Care to explain?
Thnx, looks great. Can it also handle cronjobs? All the answers are services, I am actually looking for code.
thank you for the answer, I will have a deeper look into this matter (maker bundle especially).
If you have only one free server, then you gonna get more bang without docker. And you can just have symlink from /var/www to /var/build/v1234, and on deploy just pull project to new dir and change symlink when it's ready. No reload, no docker run or build. Very fast. With docker you just adding another layer and unnecessary complexity to application. P.S. I have 61 container running on production and 80% of them I don't need. I learned that hard way.
&gt;All just to be clear, my answer was all code
Yes. https://blackfire.io/docs/cookbooks/profiling-cli
Haha true! Tnx
With all due respect to /u/nikic. It's absurd to remove versions arbitrarily from package managers which have previously been released as primary version releases. The responsibility for assessing whether something is actually a security risk or not is at the user level. Not at the package manager level. To paraphrase a Windows user-space desktop example: If I download an old version of Winamp and play an mp3 with an embedded code execution buffer overflow, that's on me, not oldversion.com. Basically what we have right now is me being able to pull 7.0 for ubuntu on any vps provider where the risk profile is huge (open internet) but I can't on my Mac mini on LAN. wut? The maintenance burden is kinda almost negligible. /u/brendt_gd makes the point here https://old.reddit.com/r/PHP/comments/a4vggg/php_70_removed_from_homebrew/ebhyxac/ Brew was always meant to let you quickly install a thing you needed in your dev environment on your mac. If I take a project where I'm explicitly working on upgrading to PHP 7.1 I might need to run 7.0 on my local. And now I can't. Without jumping through hoops. This isn't security. This doesn't speed up adaptability of the platform.
Hello OP! Disclosure: I'm the founder of Sylius. :) I share your frustration about lack of the documentation for the payment gateway implementation, let me try to fix it with help of our partners, who have implemented many of payment plugins (\~1 week is reasonable). Bests, Paweł
&gt;damn, Im still a beginner lmao We all are and that will never change. 
&gt; I share your frustration about lack of the documentation for the payment gateway implementation, let me try to fix it with help of our partners, who have implemented many of payment plugins (~1 week is reasonable). Thank you very much for investing time in listening to your userbase and trying to improve the foundation based on community feedback. I appreciate it.
Exciting
Surprised they didn't mention security in the initial email. The current system is a bit vulnerable to hijacking.
I'm actually surprised they have versions that new. I thought there might have been 5.2 or 5.1 in there somewhere.
Remember how the plugin is called? My google-fu failed me :-)
It's not dying. We have a variation of this thread every week. You don't even have to search. Just scroll down.
Posting this in the PHP subreddit - well ... ¯\\\_(ツ)\_/¯ Click-baity title of the week :)
How to make a chat?
Post javascript for karma.
Can someone explain to me how these layers are actually represented in a project? Like are they just conceptual or is the project split up with directories for each 'layer'?
Now I have a lot of experience in web development I'd rather use vanilla php than a framework. &amp;#x200B; \- With vanilla php: spend time setting up a DI container articulating together the libraries I like \- With a framework: spend time trying to learn how the f\*\*\* doing what I want with the framework &amp;#x200B; Point 1 is way more fun.
\&gt; Analyzing statistical data available on Internet, it is clear that PHP has lost its strategy, its strength reflecting market position in last 5 years What?! If anything PHP's strategy is paying dividends and is bringing the language into the 21st century. There are a lot of lofty statements in this article that aren't backed up. The statement above is a good example of this... what analysis was undertaken? You've mentioned usage stats that are largely rubbish because I think most of the other languages don't publicly list which version they are running for security reasons. \&gt; Python, node.js, ruby, C# are some of the fastest growing server-side languages which are shrinking PHP’s usage. Again, how do you \_know\_ this? There is no evidence to back this up. \&gt; PHP language community has staged its growth with no new release of frameworks or CMSs This is plain wrong. Laravel is a relative new comer for PHP (in comparison to how long PHP has been around) and has exploded in popularity. I get super angry with posts like this that just spout nonsense. To save time I can summarise the post: PHP = Bad, Python = Good. Die PHP. &amp;#x200B;
What do you mean by a sales registration web app? Is this for a learning exercise, or because you actually need one? If the latter, have a look on sites such as Code Canyon, as I bet someone's already written one.
It is not dying, PHP 7+ is really powerful and lightweight. People who hates are probably university students that can’t find “php jobs” or positions. Or just some trolls without any knowledge. Also for some people, the reason is the bad or untidy code they download from the internet.
Sorry, I was only able to post a title. Yeah, I have a internship project in which I have to build a sales registration web app that can register sales (by manual input), have those sales stored in a database (I figured through MySQL), and call that information when asked (like, give me all gross sales and respective VATs for January). &amp;#x200B; I only have HTML/CSS/JavaScript experience so I'm new to the back-end part of this. But I want to learn :)
No content at the URL. Just a bunch of quotes taking up the full screen. Pretty sure this an SEO scam. Trying to bring up the page rank for a shitty studio with no actual content. Lemme help you with that. [Creolestudios is a spammer with no talent and produces garbage over budget and constantly late code.](https://creolestudios.com/) See? I can make up bullshit too. Moderators: This garbage really should be deleted. Downvoting it to hell is not enough. Search engines will still scoop this up and give these people traffic.
Unix sockets are not "pretend sockets" and they aren't really "file-based" either. A unix socket can have a path, but that's just a way of uniquely identifying one specific socket. The actual data going through that socket is **not** written to or read from disk. So SSD performance is completely irrelevant here. Furthermore, traffic going through the loopback device is not handled by the networking hardware at all - "high speed network cards" are also irrelevant in this context. Unix sockets should usually offer better performance too.
Thanks
&gt;I only have HTML/CSS/JavaScript experience so I'm new to the back-end part of this. But I want to learn :) Well we're a bit biased here but definitely go with PHP. Learn PHP, study OOP, proper design patterns and then pick a popular framework - will help you get things done faster and better. My favourite is Laravel. &amp;#x200B; Yep, mysql as well.
Where's the update mate??
There are no unicorns. It just an alternative parser, with own cons and pros.
With all due respect, the creator of that blog post is a nobody that works in a little company somewhere in India. 
This sounds like very basic sql select and insert with php. [https://www.w3schools.com/php/](https://www.w3schools.com/php/) go through everything here and you should be able to do it.
Send a post request to another file using a form that stores the data in a database using PDO.
I don't usually downvote, but when I do, it's for clickbait. 
first pointer: - read the sidebar &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help
Thanks a lot, this is really helpful!!!
Thanks! I'll use the w3 link to go through PHP first.
Interesting! Facebook provides PHP with SSL?? How does that work
Thanks, I'll repost 
Before you start coding, draw up some specs. What functions do you want the system to do? What sort of reports do you need out of it? Do you need to have multiple users with multiple permission levels? Is the VAT rate the same for every product? Will you allow users to delete data and, if so, how will that affect the integrity of the relational database? Do you need an audit trail that logs who does what? Once you know what you need the system to do, THEN you can design the database schema. Tables, column names, column types. Be driven by your specs. For example, you need reports about VAT, so make sure that data is available and easily found. And don't store things twice. Eg, by all means store the VAT-exc price of £100, and the VAT rate of 20%, but don't store the VAT-inc price of £120. You calculate that on demand. Then set up a development environment. The "server" can be on your own PC for now. Doesn't need to be in the cloud. Easiest option is to download a ready-made LAMP appliance (a complete installation of Linux, Apache, MySQL and PHP) and run it in a VM on your computer. Or standalone on a spare computer if you have one. Or sign up for an Amazon AWS account and you get a server free for a year. (Even if you're using the company's server, set up your own one too, so you can work on it from home etc if you need/want to.) THEN you can start coding. I know you have HTML/CSS experience but don't be tempted to concentrate on that side of things too much at the start. Things don't need to look pretty yet. And remember that, while you could probably do a lot of the processing in Javascript, it runs client-side and is thus open to abuse. Anything security-related needs to be done server-side, in PHP. &amp;#x200B; &amp;#x200B;
If you're stuck at some point I might still have old files with code samples ;) but going through the whole W3 website on PHP should be enough.
The payment gateway documentation isn't the strongest part of Sylius, but you can learn by examples. First, I encourage you to take a look at our GitHub: https://github.com/BitBagCommerce. There's a lot of existing, working payment gateways you can use out of the box. If you still need to develop something custom, you can take a look at https://github.com/BitBagCommerce/SyliusMolliePlugin. It's our most advanced payment integration yet. It supports standard payment process, refunds and recurring payments. What’s more - it’s tested with Behat and PHPSpec in a proper way. I know this doesn't solve the documentation problem, but I think that for an experienced developer it should be enough to boost the progress.
As a tip, install apache xamp and use localhost/ instead of C:/xampp/htdocs/ when opening any file that uses php in browser.
We sell 10 products. Each product has three different types. The type determines the price and VAT rate (type A has a different VAT rate than type B/C). I will store VAT rates separately from prices, since the VAT rate on type B/C has been changed before, so it might change again in the future. &amp;#x200B; Most important functions are to store the sales data, and convert the sales data in to useful reports, including interactive visualisation. Think a graph that shows sales over the year. Another important function is that the creators of the products (each product has a different creator, there is one creator that made two products, there are two products that are made by two creators working together) all get a percentage of the earnings of a book. This percentage depends on the type of the product (A/B/C). &amp;#x200B; There would be one user. After the system functions well, I can start thinking about about adding more users with certain permissions. The user should be able to delete data (e.g. when the user makes a mistake in the manual data input). &amp;#x200B; What equivalent of LAMP can I use for Mac OS? &amp;#x200B; Thanks for the tip on using my own server. I hadn't thought about that yet. And thanks for the advice in general, really glad I came to this subreddit :)
Thanks dude! I'll definitely keep that in mind
There is some content once you get past the quotes. It's a terrible article though.
Trigger warning: extremely opinionated advice: Use a restful framework like yii2’s restful controllers and use the react-admin boilerplate as front end. You will be up and running in no time if tou just follow both of those tool’s getting started. 
I agree. When I learned laravel without much knowledge of php itself everything was very confusing and just magic for me. Even though it's just basic php wrapped in abstraction.
How are you doing the RPS test? I want to benchmark my Vagrant setup, but have no idea how to.
You need to open the code in an editor or IDE to read it
Exactly what I do. Except it can be a problem when working with a team. On the other side I know so many people who completely lost how the language actually works. Which is way worse in my opinion.
check the community mate
That's like reading recipes to get better at cooking.
Reading it out loud helps a lot /s
Because they work without throwing a notice/error, it doesn't mean that they produce meaningful results, e.g. https://3v4l.org/8sVDc
Try this method [https://en.wikipedia.org/wiki/Rubber\_duck\_debugging](https://en.wikipedia.org/wiki/Rubber_duck_debugging)
**Rubber duck debugging** In software engineering, rubber duck debugging is a method of debugging code. The name is a reference to a story in the book The Pragmatic Programmer in which a programmer would carry around a rubber duck and debug their code by forcing themselves to explain it, line-by-line, to the duck. Many other terms exist for this technique, often involving different inanimate objects. Many programmers have had the experience of explaining a problem to someone else, possibly even to someone who knows nothing about programming, and then hitting upon the solution in the process of explaining the problem. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I like encapsulating myself in an Edwardian persona while I read, helps me understand abstraction. I think it's easier to watch presentations, since they often take "bad" and make it "good". Bad and Good are both vague concepts, so no presentation is enough but seeing how the solutions were derived is extremely useful. 
yeah this is not php related. look at the postman documentation. learning the basics of simple tools without posting in forums not related to the subject is a skill you need to learn.
This one: &amp;#x200B; [https://github.com/malukenho/mcbumpface](https://github.com/malukenho/mcbumpface)
What is your recommendation?
You need to practice. The more your practice the easier it gets to understand oop principles. I have a course on design patterns. I am solving real life problems using design patterns. Of course everything is done using oop principles and best practices. You will learn interfaces and dependency injection and you will be a pro at it. The course doesn't use animal and shape examples. Here is the link https://devlob.com/courses/design-patterns-in-php-to-solve-real-life-software-problems
If someone louses his weight is he dying?
&gt;Def learn OOP not PDO. What? Why shouldn't he learn how to use PDO?
It's not exactly mutually exclusive :D
I am working with PHP for more than 10 years now.. just had to look up the specific differences... I don't use interfaces that often, so I never looked it up or forgot. Would you think that "Interfaces don't contain functionality, they define methods and variables, kinda like a template" is a sufficient answer for that question?
I assume it was arranged before LetsEncrypt existed.
Dude, I love this feedback! &gt; A container interface implementation that allows libraries in some ways to inject stuff into the di container? I would make that clear in the first line of the README. That's a great point. I'm working on it. &gt; The idea of having a some form of di in a package does not appeal to me; it is MY project, and therefore I don’t like the idea of having a package put stuff in my di container. Sure thing. That's your perogative. Gravity degrades gracefully. If a package defines services and settings in Gravity but you don't use it, there's no error. &gt; Why do you limit the length and structure of the service identifier? Why would you care if someone wants to give services names without dots of namespace separators? We choose to be opinionated about the identifiers so we could detect whether it was a service or setting. Otherwise, every DSL method would have to be suffixed with `Service` or `Setting` (e.g., `setSetting()`, `setService()`, `getSetting()`, `getService()`, etc). In the end, we decided it didn't seem too intrusive. Most frameworks suggest using classnames as service names for the same reasons we do. &gt; In all the examples you use the name of the implementation as the service identifier. The whole idea of dependency injection is to inject a functionality without any knowledge of the actual implementation. It would therefore only be logical, in my opinion, to give a service the name of the interface and not that of the actual implementation. That's a great point. And, I'll add some examples (and documentation) to that affect. Gravity doesn't care about the service name, except in the case of a newable service. You can use an implementation, an interface, or whatever you'd like as long as the service name includes a namespace separator. &gt; What is the idea behind the aliases and namespaces? We added those to make it easier to work with setting identifiers. Instead of writing the same `foo.bar.baz` prefix on all your setting identifiers in a file, you could use a namespace. Unfortunately, it gets a little complicated if you're mixing services and settings in the same file, because we also decided we didn't want the complexity (and confusion) of separate service and setting namespaces. So, there are just some things to be aware of if you're mixing services, settings, and namespaces. &gt; I would personally not use folders that start with a dot. My IDE hides those folders by default. We went back and forth on this one. Gravity is supposed to be out-of-the-way for setting and service consumers. So, having your IDE hide it like git's directory or some CI configuration directories, makes sense. However, it also definitely needs to be visible for developers, because they write to it. So maybe thinking of ourselves more like a not-gitignored `vendor` directory, instead of a `.git` directory or `.circleci` directory, makes more sense. &gt; You allow a folder per environment but I don’t see any explanation on the order these files are loaded. That might pose an issue when using services from other files in the same folder. Good point. I'll add documentation about this one. The files are loaded in the following order: package-global, project-global, package-environment, project-environment, where the last definition wins. That way, the _environment_ definitions take precendence over the _global_ definitions, and the _project_ developer definitions take precedence over the _package_ developer definitions. Since Gravity loads all settings and services definitions before instantiating anything (except its own services and settings), there are no dependencies to resolve. Before anything is needed, everything is defined. &gt; I would like to see some additional examples on using services and settings in the instantiation of services. Sure thing. I realize I really glazed over that part in the documentation, and it's super important haha! &gt; Why would you allow access to `$this`? That means you give the configuration access to the private methods of Gravity. I didn't think binding an anonymous function to `$this` would give it access to the manager's private methods, but I'll double check. We don't want that. We decided to bind to the manager to make things a tiny bit easier for authors. It's a little bit magic, but it seemed palatable. &gt; I don’t think it is a bad library, but I think it has some design decisions I would have done differently. There are a lot of di container implementations that are simpler, more feature complete and probably more robust than yours. But if it works for you and you’re happy with it, then I’m happy for you :) Awesome, and thank you! We're definitely just getting started, and we have tons of room to grow. I really appreciate your questions and your feedback. Thank you for taking the time to read through the documentation and write up your thoughts. This back-and-forth is fun! 
Google "object calisthenics". It explains 9 rules (of thumb) for what good object oriented code actually ends up looking like. Use them as clues to writing better code. If you notice you are "breaking" several of these rules then it's probably a good sign you need to rethink what you are building. They are guidelines more than hard rules. It's okay to break them but just be aware that we'll structured OO code breaks few of them. 
I agree, they destroyed their ecosystem, with that developers moved to other products as well. Without a market they can't survive as they have nobody to sell commercial services or support. This is clearly a way for them to try to get back what they lost by some horrible business decisions. Killing the community was even more of a negative factor than their pricing since this is one of the things everyone raged about EE in the past, them having an amazing community and high quality ad-dons.
This is completely wrong. PHPs memory model easily supports embedding and this has been a major use-case. The way PHP uses memory it is all destroyed when a request is shut down, cleaning up everything that potentially leaked. u/coderboy14 you should get Saras book on PHP extensions. It is quite old, but the basic premise about embedding should hold true still.
forgot the link [https://www.amazon.com/Extending-Embedding-PHP-Sara-Golemon/dp/067232704X](https://www.amazon.com/Extending-Embedding-PHP-Sara-Golemon/dp/067232704X)
A serious response from someone who has had to deal with reading legacy PHP OOP code, without any documentation, I created my own readme that included a workflow. [Draw.io](https://Draw.io) is convenient for mapping out what I need, jotting down what is called from where, along with what the methods do if it's not exactly clear or is acting as a bridge for other methods. 
Hey did you build that entire site from scratch?
In my experience OOP is easier for newcomers, something I've observed in my classroom (we did both).
Yes. I used lumen, graphql, and nuxt.js.
Most chefs do that. When I make a new dish I look up three or four recipes for the same dish and synthesize something from my arts I like from each.
I think you mean OOP over Procedural/Functional programming. PDO is an interface for databases...
sounds good to me - might be important to note that type declarations made in interfaces and abstract classes are enforced when implementing/overriting them: &amp;#x200B; `&lt;?php` &amp;#x200B; `abstract class AbstractClass {` `public function __construct() {}` `public function dummy():int { }` `}` &amp;#x200B; `class ExtendingClass extends AbstractClass {` `public function __construct() {}` `public function dummy():string {` `return 'g';` `}` `}` &amp;#x200B; `$extendingClass = new ExtendingClass();` &amp;#x200B; `echo $extendingClass-&gt;dummy();` // Fatal error: Declaration of ExtendingClass::dummy(): string must be compatible with AbstractClass::dummy(): int
I don't think I can help you in a direct way, but you might want to checkout the SAPIs that PHP builds by default to see how they take a PHP program and execute its code. SAPIs are the binaries that most folks who use PHP interact with -- the PHP command line program, the apache module, the fast cgi server (PHP-FPM). Like here https://github.com/php/php-src/blob/master/sapi/cli/php_cli.c#L992 This is where the PHP CLI program hands off a file handler to "the internals" of PHP in order to run the program. Taking a look at how these small SAPI programs are created and built will probably lead you to the solution you're looking for. Also, if you need help getting PHP's build process up and running I've found [this page](http://www.phpinternalsbook.com/php7/build_system/building_php.html) incredibly useful. Good luck!
I've never heard it called that before but I've definitely experienced it where I'll sit and hack on the code for hours and then suddenly realize the solution while trying to explain the problem to someone else
So works well and is a great place to start, got it.
Paprika from this one, chilli from that one, ignoring coriander from both.. I definitely cook like this.
You need to create some functionality that turns that data into a schema and inserts it into the table. Look at your language/ framework and see if it has a MySQL module or library. 
Perhaps [https://www.w3schools.com/php/php\_mysql\_insert.asp](https://www.w3schools.com/php/php_mysql_insert.asp) 
pinging u/OdBx
Which is a perfectly normal way to go about improving your skills. I've stumbled on some really neat techniques while reading through other peoples code (and recipes for that matter).
You don't have a fucking clue
https://www.w3schools.com/php/php_mysql_insert.asp helped understand basic concepts https://m.youtube.com/watch?v=XhLAB1wwzNk&amp;t=0s&amp;list=PL0eyrZgxdwhwBToawjm9faF1ixePexft-&amp;index=39 This youtuber’s tutorial taught me a lot honestly. This should cover what i think your looking for
You‘ll have to provide a form. A POST request submits form data to the server. You need a php file there that accepts the form content, converts it so you can shove it into a database. That does answer your question but let me tell you this is the beginning of a looong way. 
What's the actual point of this comment?
Thanks, that really helped me find my feet. Do you know the difference between MySQLi object-oriented and procedural though? Does it change much?
What would you guys like to know? /u/gonz_ie
Thanks, both links really help. My only question is if you know the difference between object-oriented and procedural. If it's in the video, I haven't finished it yet, but thanks.
learn a framework
 I am not experienced enough to tell you object-orientated and procedural differences and which is better. I have used procedural because that was what was used in tutorials i followed. It has become easy for me to read and understand now. When i look at object-oriented i feel lost
Yeah, I know. I don't have to go to far into PHP for now anyways, but I feel like it's the sort of thing where the more you know, the faster you learn.
Yeah, procedural seemed a lot simpler to me as well. Thanks a lot though.
No problem, good luck with your coding
I think it's considered the standard now to use mysqli and probably good practice to do so. Once you get your head around the object notation it's fairly simple.
Yeah, I was always using MySQLi, but I found examples for MySQLi object-oriented and procedural which sort of confused me at first, but I think it seems like procedural is simpler overall, but they aren't too different. Thanks for your help though, I really appreciate it.
you need to know what object oriented is and how its used and how a project is structured around the concept. then you need to know what OO code looks like and from there you can start to better understand the code in question.
Cool, thanks! I've been doing lots of OOP in other languages but I am currently stuck with Symfony since my boss started our corporate backend systems in it and now I am the only developer for them so I basically just use Symfony all day.. plain PHP knowledge get's a bit rusty over time and it seems like I miss a bunch of cool "new" stuff like autoloading..
I would suggest looking into PDO abit more. If you ever were to change your database provider its a simple one-line change to do so. Mysqli would require a complete rewrite. https://websitebeaver.com/php-pdo-vs-mysqli might be a good read for you. There are clear pro's and cons to each method. Consider what type of work you are likley to do, and decide on that basis. You can ofcourse always go back and change what you're using later aswell.
Personally I learn better by doing than reading. I’ll come up with a simple problem, choose a set of tools, and figure out how to solve my problem with those tools. Instead of reading code per-se, I will read tutorials to help solve the steps of my problem. An example: I host my local homebrew club website using the Drupal CMS and wanted to make a custom block. I read tutorials on how to make a custom block, which involves a handful of OO (classes, interfaces, abstract methods, the whole bunch). After following a couple examples and doing it a few times I learned how it all fits together. Similarly, I wanted to add a math function to the math-php library. Lots of OO there, but also JavaDoc, PHPUnit, and Travis-CI integration.
Please do not link w3fools. the information there is awful
Please do not link w3fools. the information there is awful 
Can you provide a link to an informative resource instead of w3schools than if you think they’re bad?
Go straight for PDO. The question OOP or procedural is not what makes the difference. Here is [how your database connection file should look like](https://phpdelusions.net/pdo_examples/connect_to_mysql). And here is the actual example on [how to insert into mysql database using PDO](https://phpdelusions.net/pdo_examples/insert)
Yes I can but that's not the point. And it's not that I "think". You can google your question, "why w3schools is awful". There is A LOT of information.
That’s not the point of what i was trying to ask. The point was if you knew of a site that had great resources I would like to know for future reference.
Ah, sorry. Here you can learn how to use PDO properly: https://phpdelusions.net/pdo
This person needs to learn how to use PHPDoc to accomplish what they want for their models. A few assumptions are made that blow up when you sit down and write an ORM from scratch.
Thank you for sharing that, I’ll read through it the first chance i get.
I don't understand what the big deal is with any of this because as you so pointed out in most of the examples, there are multiple ways to accomplish the same goals. If you have an app large enough to not want to use helpers functions, don't use them. If you want to avoid facades and pass in interfaces instead? Do that. Laravel isn't forcing you into any of those decisions. Hell, even eloquent can be swapped out for something like doctrine if you don't like its implementation. Leaving the framework because it might allow some other developer on some other unknown project of unknown scale the ability to rapidly develop their application seems a bit of a weird reason to do so, much less write a blog post about.
&gt; This person needs to learn how to use PHPDoc to accomplish what they want for their models. Do you realize how funny that sentence is. "Just figure out how to write critical code in comments, god damn, what so magical about this?"
I was just thinking the same... I can't speak for Laravel, but usually ORMs that use __get / __set will spit out @property values in the class docblock to facilitate auto completion and static analysis. 
Sounds to me like you’re one of the haters. Not that being that is bad or good. Laravel has always had the nay-sayers. It’s not SOLID, Eloquent is the biggest god object in the world and so fort. Sounds to me like a matter is personal preference.
Well it's weakly typed, if you want your IDE to detect it, use comments, if you want your code to throw an exception when it's unexpected, use logic in the __set. Or if PHP eventually gets actual properties-as-methods, most of this can go away.
Yes, you just need to store 3 VAT rates. Personally I'd store them in the database, in a config\_vars table, rather than in the PHP code. Your choice. For graphing, there should be some libraries that will do this for you. Although you could possibly do it with HTML and CSS if you wanted to be clever! Bar graphs with shaded divs for example. Make sure you know what figures you need to capture in order to work out the creators' percentages. And you might want to store something against each sale to say whether or not the creator has been paid yet. This is all about relational databases. If you don't know these, you'll need to read up about them. As a VERY rough suggestion, let's say that you have tables for: creators products sales customers &amp;#x200B; The creators table will have, as a minimum, fields called creator\_id and creator\_name. The products table will have fields called product\_id, creator\_id, product\_description, product\_price, product\_price. The customers table will have fields called customer\_id, customer\_address, customer\_name The sales table will have fields called sales\_id, product\_id, sale\_date, customer\_id Get the idea? &amp;#x200B; Now, when you delete a creator from the creators table, the products table will have references to a creator\_id that points to a non-existent creator. How will you handle that? Sure, you can edit a creator's details and change their name if you make a mistake, but don't delete a creator once there are references to them in other tables. Instead, each creator/product/customer has a column in their table called is\_current. To delete someone or something, you just set is\_current to "NO". Then when you produce your reports, you ignore anything that isn't marked as current. &amp;#x200B; See? &amp;#x200B; For MAC OS, look at MAMP Server. You install it on your Mac and it adds PHP webserver facilities to your computer. Free. &amp;#x200B; &amp;#x200B;
From what I read, your arguments are totally valid and I think a framework like Symfony would be a better alternative for you( but I'm sure you already know that). Although your points are valid those things like Eloquent and Facades are easily avoidable. Use Doctrine and just inject objects instead of using Facades (I know you mentioned this in the article). It's really not much work to set up Doctrine. What I'm trying to say is: with Laravel you can easily build any app level(small, medium, enterprise) with a tiny bit of additional setup
While I agree with his comments on Eloquent, I firmly believe that wrapping your database layer in \`Repositories\`, and then those Repositories in \`Services\` is an essential pattern for separation of concerns. It is in your best interest to define data objects within your domain that aren't using Eloquent (or any ORM for that matter), and then to define contracts within that domain which instruct your \`Services\` to return these objects instead of Eloquent models. You may recognize this as [Hexagonal Architecture](https://fideloper.com/hexagonal-architecture), and it resolves a number of issues outlined above by creating a clear separation between your data layer and the systems that want to access it. I believe Laravel can be used to create highly maintainable applications, but that part of it's strength is that it's convenient tooling allows Laravel to be just as good of a *prototyping* framework.
I can't quite understand to be honest why Laravel doesn't generate this code for you. It can generate an abstract class with all the PHPDoc annotations and physical methods and properties, then you extend it and implement if something is to implement.
What sort of questions did they ask you? What were the exercises based on? Any particularly tricky question?
I know. I'm just curious what do you really use it for :) E.g. I use php-parser for [Rector](https://getrector.org/), that can upgrade from PHP 5.3 to PHP 7.4 for you. Also, you can use its AST to write your own rules in PHP, e.g. to migrate from legacy spagetti code to MVC of your chioce. It's written in PHP, so PHP developers can use it.
Amazing work! How did you refactor your code? Did you use Rector with custom rules? Many other devs would use such set to help them solve similar problem.
Yes yes yes. We use laravel essentially for its DI and routing. I'm don't like the models that have no members and my oppo doesn't like the relentless statics and magic helpers.
Technical questions were actually a really straight forward written test split into three sections: PHP, HTML/JS, and miscellaneous. Questions like “how would you detect whether a string ended with a space or line break” and “what’s the difference between unlink() and unset()” (which I got wrong hah, never use unlink). Then there was a more traditional set of verbal Q&amp;A about my background, examples of particular scenarios I’d been in or what I’d do if X or Y e.g. what would I do if I had a customer on the phone saying they have a blank screen. Tricky technical questions were the unlink/unset one just because I didn’t know the answer, would be easy if you knew it haha. But also explaining reflection in PHP was something I couldn’t find an answer to and asked them to explain to me. One interview question I got caught on was about a scenario I’d been in where I disagreed with a company policy change; mainly found it hard because my previous company never really had any changes to policy in the time I was there. Besides that the interview questions were quite straightforward, just had to think of scenarios that fit their questions. 
Saying the WHOLE framework is not SOLID is bit of an overstatement isn't it? Just because one (or a few) component does not fit well with "S" don't forget the rest of "OLID" (which most parts of Laravel do well).
About eloquent, bold is mine : &gt; The first thing you see is that there are no properties on the model. [...] Everything is injected “magically” into the class by *reading the table metadata*. Nope, not reading the table meta data. There is no `DESCRIBE` statement involved. It just uses the fields of your select clause (which default to `*` so all). I didn't recheck, as I never really use it, but the `barryvdh/laravel-ide-helper` has a `php artisan ide-helper:models`, which even take the `$casts` into account, and gives you 100% ide-typed properties. The scope parts is not that good, as only the first static call will be understood but : For the scopes and the `separation of concerns`, something I never see dev do but which works very well is having a `class PostBuilder extends EloquentBuilder`, convert all your scopes and move them to that (added bonus, no more scope prefix and `$this` refers to the current query), and overide the `Post` `newQuery` method to use `PostBuilder`. Kinda like what Yii and some other do. And you can't tell that those previously `scope`methods don't belongs to a specialized builder. Traits for `publishable` are so easy to use to share behavior between model builders. If you still don't like eloquent, swapping out to doctrine is easy. --- ide-friendliness I'll agree that it is hard to have a 100% typed/ide understood codebase, without either a lot of phpdoc comments or convoluted patterns. It doesn't prevents me to do my work, and most of the place which are not ide-understood are so common that after some times, the ide doesn't help me that much. I mean `$post = Post::published()-&gt;latest()-&gt;firstOrFail();`, I don't need my ide to tell me what `$post` contains. With a bit of memory, most of the gaps are filled after a few months. I do loose autocompletion, but wether you do TDD or TAD or manual testing, typos are easy to catch. --- Global helpers and facades, common, they are totally optional, that point (at least the angle you took) is moot. Even if I agree that the name facade is stupid, and responsible of so many confusion.
I moved away from magic too. The problem with magic is it prevents you from learning how things are done. You end up learning the framework's way of doing one particular thing instead of improving your coding skills. There is plenty of wonderful libraries, it is not that hard to articulate them together. Moving away from frameworks is one of the best choice I've ever made. No more countless hours of searching how the hell what I want should be done with the current framework I was using.
Why to use crippled Laravel after one can opt for Symfony?
&gt; I firmly believe that wrapping your database layer in `Repositories`, and then those Repositories in `Services` is an essential pattern for separation of concerns. &gt; Hexagonal Architecture Only when this level of overhead is necessary. I have several projects where such patterns would be overhead with no real benefits over conventions. We devs are sometimes too obsessed with "clean" code, "proper" architecture, and the likes (even more when we just learn those). Every bit of complexity you add should be justifiable. The answer "because it's cleaner" without proof in THIS context holds no value to me. SOLID, Hexagonal, TDD, DDD, all those should always be balanced with YAGNI and KISS, or you soon become an overengineering crusader.
I don’t want to start a flame war, but IMO the defaults are important. People are fragile beings, and even if they start the project with great code quality in mind (i.e. without using the magic or other questionable solutions — in their opinion), the defaults will surface eventually. You’d have to actively develop against the framework and its ecosystem. All (ok, most, its a figure od speech) the tutorials point to using facades and eloquent. You can’t freely use any library without eloquent (same for Symfony, try swapping out Doctrine), because most of them assume eloquent in the model layer. Even if you somehow keep your codebase clean of all those unwanted things, suddenly you grow and hire a Laravel dev and in the best scenario they are confused with the codebase — in the worst they refactor the shit out of your app or quit. You could as well use React without JSX, use Redux in Vue, insert eloquent into an Symfony app or use node.js without MongoDB ;) — all would be equallly confusing. If you don’t care about most of the unique selling points of a tool, why bother? And if there’s anything I learned about building software in large-and-growing teams, is to limit the non-standard solutions to a minimum. 
I also wish PHP had native getter/setters, but let's face it - methods also work. It's not like your code is THAT much different by calling $foo-&gt;bar() instead of $foo-&gt;bar.
BTW, the CSS on your landing page does not load in FF if you have uBlock Origin installed.
Phptherightway.com ?
[https://phptherightway.com](https://phptherightway.com) [https://laracasts.com](https://laracasts.com) &amp;#x200B;
This is a garbage article. His arguments are essentially, "Laravel offers all these things I don't need to use, but because they are available they could be confusing!" Uh, no shit, that's every framework ever. I'm going to guess this person is not in charge of anything or else they'd understand the enormous benefits you gain from a well made framework. 
Don’t get me wrong, I’m a big fan and have used it for years, and am planning to continue doing that for the coming years. Just sharing my opinion on matter.
I did test the site on 4 main browsers, but I would have never thought that ublock block the css 😂😂😂 Does it load when you disable it?
Once you get into working with databases and `PDO` you might also want to check out [https://phpdelusions.net/pdo](https://phpdelusions.net/pdo).
Look into PSR 1 and 2. Learn GIT via command line. Use tools such as PHP Codesniffer, Mess Detector and PHPStan/Phan/Psalm
Alternatively open the code in an editor or IDE and let [software](https://www.nvaccess.org/download/) [read it to you](https://code.visualstudio.com/docs/editor/accessibility#_screen-readers).
Fortunately I'm not part of a team. If I were, I'd rather have teammates who know how to code with php than teammates who know how to use framework lambda.
&gt; without using the magic I'm sometimes teaching to very green devs. There is nothing less magic to them than DIC. Modern containers forces you to think backwards, compared to how newbies think. And those containers are the base of what is nowadays called clean. The entire idea of asking the framework to do it's magic and construct object with already configured and constructed parameters is bonkers the first time you see it. I hate the "magic" trope, because what it really means is "I don't bloody know what's happening", and we have created some rules about good and bad magic, where the good magic is stuff we say every competent dev should know (like DIC), and bad magic is the rest. Take a well learned dev who knows laravel well, and even in an helpers and Facade ridden code base, with no repositories and eloquent inline, his code will be clean as hell, but here cleans means works, is easy to change, and is performant. SOLID, DDD, TDD, insert acronym here, their point is allowing code that is easy to maintain. Applying the methodology has NO VALUE IN ITSELF. We shouldn't write repositories because repositories are cleaner or a best practice. We should write repositories because in the current app, they will give us a net gain in maintainability. Which sometimes isn't true. KISS and YAGNI are higher on my priority list than SOLID, TDD or paterns. &gt; You’d have to actively develop against the framework and its ecosystem If you don't use conventions, well... what do you expect. A library dev won't do a bridge for all the projects in the world, you will have to do some work yourself. Even then, non laravel packages are eassy to pull in, you sometimes will have to write a service providers yourself, but hey... You got what you want, a non pre-integrated package. Or you can go the other way around and use a custom service provider for a package which already has one and reconfig things the way you want. &gt; You can’t freely use any library without eloquent (same for Symfony, try swapping out Doctrine) It's not that hard to drop eloquent and use doctrine in laravel... &gt; hire a Laravel dev and in the best scenario they are confused with the codebase — in the worst they refactor the shit out of your app or quit. Hire a PHP dev or a competent laravel one if you have a complex custom app. Don't go for the wordpress integrator equivalent in laravel. Your whole post is trying to eat your cake and have it too (or the other way around, non-native here)
&gt; It’s also partly due to PHP not being very well designed. Proceeds to not giving a single example of that.
While I wouldn't go so far as replacing Eloquent, as I generally use Symfony when I see a need for a DataMapper, not using facades and "magic" helpers is fairly common with professional Laravel developers, as they're not particularly hard to avoid. Much of the code of a well written application is going to be independent of the framework. I wouldn't particularly consider them one of Laravel's strength, or an important selling point.
https://symfonycasts.com is great too
I already did a few posts on the rest so I'll focus on : &gt; The problem with magic is it prevents you from learning how things are done. You end up learning the framework's way of doing one particular thing instead of improving your coding skills. Or you use more than one framework in your life ... (Even better, a new language. Learning a lisp is the best thing that can happen to you, comming from PHP/C/Java) Or you are curious and learn on your own ... Or you **read the source, luke** (which seems to be a lost skill) and what was magic isn't anymore ... Magic just means "I am using this thing as a black box and don't bother to look into it."
Not necessarily only I will use it. I promote it there for others. You use [nikic/PHP-Parser](https://github.com/nikic/PHP-Parser). Similarly, anyone can build their projects using [z7zmey/php-parser](https://github.com/z7zmey/php-parser) I have seen your project before, and I am delighted with it. In your case, writing rules in PHP is a key feature, but it isn't the case for other projects.
In isolation, everything written here is pretty true. However, in the real world, we sell products, not code and if we went to a client and pitched we build everything from the ground up and triple their production time, they'd go elsewhere. Reasons to use a framework? time..
Hmm this is interesting, I didn't that PHP had it's own coding standard. I will most definetly look into that. I already know how to use git over CLI, including stashing, changing remote, pushing, tagging, ammending commits, and in my other project (addrbook) I wrote a pre-commit hook script. I am fairly comfortable using git over CLI and never used any GUI. I have never heard of these tools, but I'll definetly research them as I continue to progress with my project. Thank you. 
Clearly 2 years of Laravel experience is not enough to learn it properly if the concern is that it doesn't have good engineering or that it's too simple
That's the whole point: instead of spending time learning many frameworks and reading their source code I'd rather use exactly what I need. Good luck understanding the source code of Eloquent. And I agree with you about learning other languages. Why do you think I don't know some lisp?
I wouldn't say Laravel is crippled by the above. Using DI over helpers and facades is just a design decision, it has no impact on Laravel's functionality. All of the above resolve the same exact way from the container. Autowiring with dependency injection was in Laravel before it was in Symfony. Laravel just includes multiple ways to do things compared to more opinionated frameworks. Symfony also doesn't have a built-in ORM like Laravel's Eloquent, but you can use Doctrine with both. Laravel Doctrine is a drop in replacement for Eloquent.
Every decision should be weighed against the "are we going to have to deal with this later" thought. If the answer is no, then it's fine to take the shortcut, but if it's yes or even maybe then taking the time to clean up the code should be highly considered. It's far cheaper to pay for your code up front than it is to sit on technical debt for ages. Truth be told I feel like most languages make it harder to implement these coding patterns without things getting "over engineered", and that feels so backwards to me. Granted, this is a PHP subreddit so relative to this language, yes, writing clean code up front comes with a cost that may be cheaper to ignore depending on your circumstances.
Personally, all of my database schemas use snake case so that there's never any issue with case missmatches when working with strings, so for me accessing $row-&gt;col_name_here is just more preferable to $row-&gt;getColNameHere() or $row-&gt;col_name_here()
&gt; Good luck understanding the source code of Eloquent. Having enough of an idea for it not to feel that magic is quite fast. As long as you don't go down to the SQL gramar conversion level, that shit is brutal. You just have to understand that the model proxies to eloquent builder which proxies to sql builder, how the relations are just class which extends the query builder with some defaults... I couldn't rewrite eloquent (at all), but I understand it well enough to not be puzzled by its behavior anymore, or infer quite easily what could be happening. &gt; Why do you think I don't know some lisp? That was a general "you", not a target to you yourself. As far as I'm concerned, I really should find ways to write more clojure, for my own fun.
Deprecation*
There's actually very good pattern reasons for using dynamic getters and setters which unlock features. For example one feature in my ActiveRecord implementation is $this-&gt;isDirty which simply tells me if the model was changed since it was last saved or instantiated. An indispensable feature when you're doing a multisave on a collection of models and you only want to save changes. If you don't have magic setters but your variables are actually part of the class for real then __set will never fire. So you can never run $this-&gt;_isDirty = true. My work's ORM (also custom) doesn't have magic setters and getters for Model fields. They are all just there in the model and it assumes that the name of the variable is the name of the column in the table. I recently had to implement multisave with only saving things that actually changed. I had to make it so that it maintains $this-&gt;_originalValues as an array from when it was originally instantiated. To lower memory usage I made it an opt in feature by setting Model::$_trackOriginal to false. __get: $this-&gt;isDirty simply maps to protected $this-&gt;_isDirty which itself runs a foreach on all fields to check if they are dirty. And that's just one little thing. You also need magic getters for relationships and derived fields. Relationships are self explanatory. Derived fields are literally fake returns from SELECT DB which aren't savable. They are read only. You want them to work for data pulls but not attempt to save those fields as they will cause an error. So you make a static::$ignoredFields to now have those fake fields be ignored even though they are in your model. I could go on and on. And just to be clear PHPDoc is NOT critical code. It is documentation. Auto complete literally shows you exactly what it says in the docblocks. And static analyzers do make use of it. Maybe when PHP 7.3 lands and we can use type hinted properties some of this stuff will get cleaner but honestly not by much unless I implement every single MySQL field type as a PHP object class for doing data serializing/unserializing and comparison.
nothing easier than that, this would be mine: spl\_autoload\_register(function($className) { $path = \_\_DIR\_\_ . '/dependencies/classes/' . $className . '.php'; &amp;#x200B; if(file\_exists($path)) { &amp;#x200B; require\_once $path; } }); 
The difference being that chefs already have plenty of experience with cooking, and thus get the gist of a recipe quickly, whilst understanding what makes the recipe better than what they already know. Throwing someone with no programming knowledge into an actual OO project would result in nothing but confusion, frustration, and misunderstandings.
&gt; For example one feature in my ActiveRecord implementation is $this-&gt;isDirty which simply tells me if the model was changed since it was last saved or instantiated. An indispensable feature when you're doing a multisave on a collection of models and you only want to save changes. How is it more indispensable to call `$this-&gt;_isDirty` instead of `$this-&gt;_isDirty()`?
So, in smaller projects, Laravel and Eloquent's "magic" was very helpful in getting a project up and running quickly. In a larger project with multiple contributors, I can definitely see the point of moving away from these things. Code flow can be hard to maintain and understand. I don't blame Laravel for this. We delayed important design decisions in the project and chose to deploy quickly rather than emphasize strict patterns. Laravel isn't as opinionated as some frameworks and so it lends more to you making the design decisions of using facades over dependency injections, using activerecord over datamapper, using magic methods over real methods. If I had a choice to start from scratch in PHP on a big project, I'd probably still use Laravel but I'd probably switch out Eloquent for Doctrine. For small projects, I'd take Eloquent over Doctrine.
No... depreciation means something that it's going to be removed in a later version, that isn't what I'm suggesting, which is that potentially risky implicit conversions come with a notice or warning that the operation may be unsafe. 
If you achieve code reuse mainly through DI when Laravel isn't an optimal option. First of all, is due to the fact that Laravels DI is actually Service Locator under the hood. The way it "injects" dependencies is by the service itself calling for dependencies it needs rather than them being passed as an argument. This is a problem, because for this to work runtime reflection must be used. And reflection is very costly process. Symfony's DI, however, is actual DI IoC container. Which only uses reflection to build compile a container, which is being cached and when used without reflection for all of your processes. This adds to efficiency as well as provides some type safety as there is part of application which actually compiles. If you want to get more in the details you can watch Beau Simenson talk about autowiring and containers where he goes in depth. There was no need to invent new ORM. Symfony is port of Java Sring to php to an extent. Spring uses Hibernate. There already is Data Mapper ORM in php, and that's called doctrine. However there wasn't very good Active Record ORM in php before Laravel, which mainly got it's inspiration from Ruby on Rails so Eloquent was developed. That being said AR doesn't scale in complex systems. As you actually need to compose your queries and execute them at the end of the process. To build scalable AR you inevitably end up mimicking Repository pattern anyway, and at that point, Data Mapper is simply superior.
In *my* framework $this-&gt;_isDirty is set during _setFieldValue which branches out into every data type the ORM supports and can actually compare itself to the old value before applying the new value. Simple boolean off/on switch. In my *work's* framework when you run $Model-&gt;somefield = 'blah' it never runs __set so I never know the field changed and unless I was tracking originalValues already there is no way to know if the $Model is dirty. The first method doesn't require originalValues at all. It's not super memory intense. You're just setting and returning a boolean. There is no method for isDirty there because there's nothing to run. The second method requires originalValues and requires repeated iteration and comparison. That's where you need a function. However isDirty is just one property. There are others in the same format. https://github.com/Divergence/framework/blob/master/src/Models/ActiveRecord.php#L28-L33 isPhantom, wasPhantom, isNew, isUpdated The rest of these are simple booleans which can be defined and adjusted through the life cycle of the object via the constructor, the record instatiator, and the save method without making any function calls. So at this point I'm really just trying to keep it clean and not have boolean properties for some things and functions for others. It's really quite fascinating work on multiple ORMs are the same time.
Man the answers here suck. OP if you're new to programming, or even just OO, read up on OO princples in theory before throwing yourself into actual implementations. You won't gain much by reading a Wikipedia article, but simply searching for things like "solid principles PHP" will give you decent, more easily understood introductions like [this laracast](https://laracasts.com/series/solid-principles-in-php) (_disclaimer: I have not watched this series, nor do I have any opinion on laracasts as I haven't watched anything from them before_). Now, when you've done some light homework, try implementing something _by yourself_. Drawing inspiration is totally fine here, so long as you actually write the code yourself, and understand what it is you're doing. The general rule of "change things, watch them break, fix them" applies here: experiment all that you can. * _What happens if I do X instead of Y?_ * _What actual benefits does this principle/technique/whatever give me as a developer?_ And if you're completely new to OOP, do start by reading up on how using objects to encapsulate your logic benefits you in general, and how to do so, before reading up on principles and patterns. When you _actually get it_, you can definitely start learning from reading random code. Before that, you're just going to confuse yourself.
Hey nothing about react really pushes you to use jsx. I was on jsx for years (even used a similar idea with xhp on PHP before that), and I think we're past it as something that adds value. Eg why is `&lt;Foo bar={bar}&gt;Baz&lt;/Foo&gt;` worth programming in a language superset with a babel transform, if I can `h(Foo, { bar }, 'Baz')`? The former is maybe more familiar to some devs, but it's adding complexity because someone thinks it's "simpler". 
&gt;You just have to understand that the model proxies to eloquent builder which proxies to sql builder, how the relations are just class which extends the query builder with some defaults... &amp;#x200B; I know but I just don't care knowing how eloquent works and how to use it. And trust me I used it a lot, I guess I'm still on the laracast leaderboard two or three years after I stopped visiting this forum. &amp;#x200B; I admit I have the chance to have a work I'm not pressured with time. But I surprisingly discovered I spent the same amount of time managing to get eloquent doing what I want than writing my plain old sql queries and formatting the results according to my needs. Eloquent is just an example by the way. &amp;#x200B; I also admit some topics are sensitive and pretty boring to implement, like error handling or CSRF protection for instance. What I'd ultimately want is some very very lightview library handling all those security concerns, giving me a bare PSR-7 server request and let me process it to a PSR-7 response. Maybe I'll release this someday lol. &amp;#x200B; And by the way we share the same desire of more clojure !
That line lost my interest in the post. _a bad workman blames his tools_ 
I stopped reading at this point: &gt; Take Symfony for example. No need for IDE helper files, because it’s well designed and implemented. What [utter bollocks](https://plugins.jetbrains.com/plugin/7219-symfony-plugin). Without PhpStorm and the Symfony plugin, it is nearly impossible to find *anything* in a large project. An object can be defined for the DIC in config files, which is fine except that the particular file might be YAML, PHP, or even XML. And if you want to override that file and your project uses YAML, but the source is XML, you have to convert it manually. Symfony’s freedom to mix and match *anything* is one of its biggest pitfalls for me. That, plus YAML is *horrible*.
May I ask why do you need a custom tokenizer? I've only written custom sniffs, I also wanted them to use vendor/autoload.php, no new standard, everything in same project. I was able to just add them to phpcs.xml specifying full path to PHP file. I had to use XDebug to find out how sniffs are loaded. It's a real mess. I'd image that adding custom tokenizer may be even more difficult.
This guy develops.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I agree with a lot of the individual points the author makes, but I don't agree with the conclusion of moving away from Laravel. I've worked with other frameworks, like Yii and Symfony, and I still prefer Laravel. Yes, Laravel has a lot of magic, but there is always a non-magic alternative. I haven't used global helper functions or Facades in years. My code is clean, I have type declarations everywhere, Psalm and PHPStan are happy (strictest levels). And you don't have to fight the framework to achieve this either. 
For Laravel/Eloquent, you use https://github.com/barryvdh/laravel-ide-helper which does just that. Great tool. Actually uses Doctrine DBAL as a dev dependency to pull down the DB schemas, ironically.
100% agree with you there. Core app config in yaml/xml/neon/whatever is frankly insane to me. Just use PHP arrays!
I’m not disagreeing with you, I made a React project without using babel myself. And yet, I am yet to find a React dev that would like to join a team coding this way, and hiring JS devs is part of my job description
Yeah I feel you, I personally moved away from laravel back in 2014 when things got a bit difficult as the project got larger. Oddly enough I still use eloquent in this project, but it's starting to become a hindrance on my productivity. Been meaning to switch it out, but the project is extremely large and they scope keeps changing or other things become priority, but eventually slowly incorporating doctrine is going to happen. Right now the project is pretty much slim3+php-di+twig+eloquent and I use s3 purely for routing and php-di for setting up everything in the configuration file. Allowing me to not worry about DI on a surface level and still be able to have my interface aliases setup, everything being constructor injected without passing the DiC around. I think that's where people make mistakes with the DiC, when you use it right she's a happy camper.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
&gt; Every decision should be weighed against the "are we going to have to deal with this later" thought. If I know I am doing a quick v1 and I'll need multiple payement providers in a v2, yes, I'll go ahead and start using a modular approach. But this agrees with YAGNI, as I know already I'll need it. If you know, you know. &gt; it's fine to take the shortcut Wrong way to look at it. If you don't know where you go yet, there is no shortcut. Naming this shortcut implies that you already know it's suboptimal, which in turns implies you already know that it won't be a shortcut. I'm not talking about doing a quick and dirty POC to match the deadline and offloading refactoring/cleaning to the next week. That is either lazy, or a planning error. &gt; It's far cheaper to pay for your code up front than it is to sit on technical debt for ages. On the other hand, devs and clients are notoriously bad at knowing how a project will evolve. And NOTHING is worse than writting clean code upfront, but for the wrong problem, because you didn't understand at the time what your real problems was/will be. This is the hardest technical debt to get rid of, as it compounds with sunken cost falacy, and cement a misunderstanding of the problem. Yagni/Kiss don't mean sitting on technical debt. It just mean paying the costs of complexity when you know you need it. And refactoring along the way to the current simplest implementation.
Just because PHP is good for what it does, doesn't mean its well designed-- that's one of the reasons for many of the BC breaks: inconsistent function names, multiple core error handling patterns, per-file `strict_types` that gets ignored by reflection.^[[1]](https://bugs.php.net/bug.php?id=75345), inconsistent argument order, and inconsistent [unicode support](https://www.phproundtable.com/episode/character-encoding-and-utf-8-in-php) (remember PHP6?) Nothing is perfect. PHP has a lot of good things going for it, including their improvements. Objects work better being reference-like, rather than values: so they changed it. Exceptions work better than the custom (@) error handling functions, so they changed it. Having a DateTime object makes sense, so they added one. `function()[0]` should be valid syntax, so it is now. It's good progress-- but 'well designed' seems like a stretch-- at least enough of a stretch that I wonder: Which part of PHP is/was well designed?
&gt; Laravels DI is actually Service Locator under the hood. The way it "injects" dependencies is by the service itself calling for dependencies it needs rather than them being passed as an argument. Not true at all. This is using the Container as a Service Locator: class One { public function __construct(Container $container) { $this-&gt;foo = $container-&gt;get(Foo::class); // alternatively, using a static call. same principle. $this-&gt;bar = Container::get(Bar::class); } } I have **never** seen anyone do this in Laravel and the framework certainly doesn't encourage it. You might be thinking of Facades, which do something similar, but you don't have to use those. This, on the other hand: class Two { public function __construct(Foo $foo, Bar $bar) { $this-&gt;foo = $foo; $this-&gt;bar = $bar; } } Is regular dependency injection. It's what pretty much every modern framework, including Laravel, encourages. This has nothing to do with reflection either. Both variants can be done with or without reflection.
&gt; Hire a PHP dev or a competent laravel one if you have a complex custom app. Don’t go for the wordpress integrator equivalent in laravel. Thanks for your reply, its an interesting point of view to consider. I can agree with most of it except for the above part — you simply can’t always have the luxury to hire people that fit your project the best. And even if you do, they will be working against their habits and make mistakes. Unless of course those conventions aren’t as common as I thought in larger projects / with more senior devs. &gt; Your whole post is trying to eat your cake and have it too (or the other way around, non-native here) It’s rather describing the eat/have cake dillema when going against the default with any framework — you either play along with Laravel-way and really have the RAD experience, or you choose your way and do a lot from scratch, forfeiting the benefits of a RAD framework. And to me that was Laravels USP, so I suggested going straight to Symfony in similar situations (aka „Why even bother?”). But I must admit that you took part in slowly changing my opinion on the L-framework :) 
My last deception with frameworks was with zend expressive. I though it would do exactly what I need but I was disappointed during the first few minutes of work with it. &amp;#x200B; So I start a new project, I wanted to use it with Plates and I needed to add a custom extension to the Plates Engine. &amp;#x200B; I know zend expressive container factories can be decorated. My plan was to decorate the Plates Engine factory to attach my extension, this is a textbook example of why container factory decoration feature exists in the first place. So I register my decorator and nothing happens. &amp;#x200B; I spent a few minute hunting for information and discovering that for some reason, the zend expressive Plates configuration provider does not expose a factory for the Engine class. The Engine instance is created within a freaking PlatesRenderer factory (a framework specific adapter) and I don't have a direct access to the Engine factory, so I can't decorate it. &amp;#x200B; I finally figured out you could add extensions in a freaking configuration array which is used when the Engine instance is created. How frustrating it is to have to find the name of every configuration entries I will have to use in order to do something which would be very straightforward without the framework? Then I figured out if I register my own Plates Engine factory within the container it will be used instead of the default one. You have to look in the source code to figure out this. How silly it is to not directly expose the Plates Engine factory and let me search for a freaking configuration entry name or let me figure out that if I provide my own Plates Engine it will somehow be used? This is a useless framework configuration trick. &amp;#x200B; I love the work of the zend expressive team, I learned a lot from them. But how this could be more understandable than my home made code where I every factories I need are registered in some container of some DI container package?
Maybe your use-case was different or you were using an older version. In PHPCS 3 I would make a new standard that uses all the same sniffs as the standard you are modifying, and just place a new sniff file inside the standard. Phpcs can then use your new sniff in your new standard. I am making a new tokenizer because I’m Tokenizing files that are a different language. A new tokenizer is easy, you make a class in the Tokenizer namespace and call `phpcs —extensions=&lt;filetpye)/&lt;tokenizertype&gt; &lt;filename&gt;`
If you're specifically looking for PHP, it's going to be Magento. It can be bloated and frustrating to work on, but nothing else really holds a candle to it.
&gt; And trust me I used it a lot, I guess I'm still on the laracast leaderboard two or three years after I stopped visiting this forum. I wondered, as I knew a similar laracast handle. You are still top 50. &gt; And by the way we share the same desire of more clojure ! Nice !
&gt; Every decision should be weighed against the "are we going to have to deal with this later" thought. If I know I am doing a quick v1 and I'll need multiple payement providers in a v2, yes, I'll go ahead and start using a modular approach. But this agrees with YAGNI, as I know already I'll need it. If you know, you know. &gt; it's fine to take the shortcut Wrong way to look at it. If you don't know where you go yet, there is no shortcut. Naming this shortcut implies that you already know it's suboptimal, which in turns implies you already know that it won't be a shortcut. I'm not talking about doing a quick and dirty POC to match the deadline and offloading refactoring/cleaning to the next week. That is either lazy, or a planning error. &gt; It's far cheaper to pay for your code up front than it is to sit on technical debt for ages. On the other hand, devs and clients are notoriously bad at knowing how a project will evolve. And NOTHING is worse than writting clean code upfront, but for the wrong problem, because you didn't understand at the time what your real problems was/will be. This is the hardest technical debt to get rid of, as it compounds with sunken cost falacy, and cement a misunderstanding of the problem. Yagni/Kiss don't mean sitting on technical debt. It just mean paying the costs of complexity when you know you need it. And refactoring along the way to the current simplest implementation.
&gt;Wrong way to look at it. If you don't know where you go yet, there is no shortcut. Naming this shortcut implies that you already know it's suboptimal, which in turns implies you already know that it won't be a shortcut. I don't want to get caught up in semantics but for the sake of simplicity I'll say I agree with you. &gt;On the other hand, devs and clients are notoriously bad at knowing how a project will evolve. &gt;And NOTHING is worse than writting clean code upfront, but for the wrong problem, because you didn't understand at the time what your real problems was/will be. This is the hardest technical debt to get rid of, as it compounds with sunken cost falacy, and cement a misunderstanding of the problem. This is a communication and planning problem, not a programming one. Writing messy code up front that solves the wrong problem can be just as bad. Don't write code if you don't understand the problem inside out, and ask questions until you do.
Can i give some things i don't like? - There are no arrays everything is a weird fake hashmap - No return type covariance for sub types unless you give weak type definitions on the base type being inherited - No multiple function signatures/overrides like in C#, useful when building a API endpoints that can get same using different params instead of saying getWithXYzAndPxy 100 times. Easily abused and made confusing if not used properly. - No proper function annotations, we have like comment or PHPDoc annotations not something like: `@route='/member'`
oh I read this, there is a lot of abstraction and magicalness to Laravel but I think that was designed because Laravel was inspired by Ruby on Rails which has more magic then I know what to do with. &amp;#x200B; What I don't understand is the hatred of laravel. There are some people, like my self, who swear it's the best thing since sliced bread because of how fast one can develop and create new things of any size, from facebook scale to mom and pop. Right now I work on two professional applications one for medical and one for oil and gas and both pump tons of data thousands of records across a multi tenant site. We have had some scaling issues but we learned to move away from the query builder (in sorts) to the raw SQL (still using DB(), so not totally away from the query builder) and to queue our longer running jobs that would other wise time out or take too long on the browser side of things. Laravel is enterprise ready and there's tons of proof of that. its all in how you develop. If you spend decades abstracting away from laravel, you have no laravel. If you use it properly, you wont have issue.
The container works to get the arguments into your constructor, not what you do once they are there. Again, I suggest to watch the talk I was referring as you missed the mark.
Your argument is from the perspective of client work. However, in the real world, you are not representative of the entire spectrum of software engineering. You also argue from the false position that you either use a kitchen sink framework (with any presumed flaws) or you write from scratch.
Yes, Facebook paid for a bunch of certificates (not exactly sure which, but PHP.net needs a bunch, for SVN, git, secure.php.net, mail, ...) and when that was configured there was no letsencrypt or didn't offer wildcard certs. I assume on next larger update letsencrypt is an option. (While a sponsor might eventually pay for EV or organization validation) Note: I'm involved in some PHP.net system debates, but not in the TLS specific ones, so only can talk with limited authority
The first part is flat false. You cannot use PhpStorm with Laravel and expect any sort of code-completion or ctrl-click discovery without using a plugin. Even then however, you’d be clicking through methods galore to get to the core functionality of what you wanted to see. I do agree on yaml being yuck. 😃
Magento would be considered enterprise level but you need to expect to devote months of time for the initial development and years to become proficient with it from what I've seen. It seems the general consensus from the last bunch of recent questions regarding this around here is to use WooCommerce if you're not going to go with Magento as it's going to be better than any other alternatives like osCommerce and the like. &amp;#x200B; It's hard to provide much more feedback since it really depends on your business needs, skill level of your development team, etc. Even building something custom on top of a framework like Symfony or Laravel could be an option if you don't need all the extra bells and whistles that a full eCommerce framework typically provides.
That's interesting. What was your method? Did you make sure the 5.6 code analyzed clean first, or the 7.0 code, or both?
I dont mean to be rude but this is a ridiculous article. Ive used nearly all the main php frameworks and if you need to get a project going and a prototype up and running quickly then laravel is the best out there.
Well Said.
It's unreasonable to believe that creators of the tools are somehow above error. And that phrase is thrown around to avoid valid criticism all to often. PHP is full of garbage as a language because it maintains BC promise. And originally it was never ment to be a programming language. But a templating engine for C.
I think you are confused by what "service locator" means. A service locator is an objet. Both Laravel and Symfony are service locators because they can *locate* services (via `get()`). That doesn't mean it's incompatible with dependency injection. If you inject a dependency via the constructor, as /u/AegirLeet showed, it is dependency injection. The opposite of dependency injection is not "service locator", it is service location. That means calling `$container-&gt;get(...)` to get a dependency, instead of having it injected.
Well, if you are looking to learn it perhaps, but Magento devs can be pretty expensive as development is quite convoluted. Out of the box though, it's fully functional. 
Again. We are not talking here about what we do once the arguments reach the class constructor. We are talking here how the arguments are resolved behind the scenes by the container to reach the constructor in the first place. The example being provided is irrelevant to the topic at hand.
Those are issues that can be solved. And will likely be in the future: \- The reflection issue can be fixed when reflection supports knowing if a file is strict or not \- Inconsistent argument order is about the cost of opportunity, at this point, does it really make sense to break a gazillion applications just to satisfy the pedantic? All projects have that kind of issues, but in older projects, the cost of fixing this stuff is just not worth it. \- What inconsistency with unicode? AFAIK, you have different functions that can deal with multibyte characters, so if you use the right functions for your strings, you should be in the clear. &amp;#x200B; But either way, I'm not defending that PHP is thoroughly well designed. My issue is that the article takes a jab at it without backing it up.
Actually it has nothing to do with uBlock, it doesn't work with it disabled as well. Why are you loading your CSS like this: &lt;link rel="preload" as="style" onload="this.rel='stylesheet'" href="bulma.min.css"/&gt; That doesn't make sense
Ahhhhh, I thought you were talking about [devlob.com](https://devlob.com), but you are actually talking about [http://design-patterns-in-php.com](http://design-patterns-in-php.com) &amp;#x200B; I am preloading my css, but this feature is not available in Firefox yet. &amp;#x200B; Take a look at this: [https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading\_content#Browser\_compatibility](https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content#Browser_compatibility)
&gt; There are no arrays everything is a weird fake hashmap You can use them as arrays. How does that affect you? &gt; No return type covariance for sub types unless you give weak type definitions on the base type being inherited Not anymore: [https://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters](https://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters) &gt; No multiple function signatures/overrides like in C#, useful when building a API endpoints that can get same using different params instead of saying getWithXYzAndPxy 100 times. Easily abused and made confusing if not used properly. It doesn't make sense to use overrides in PHP. If you can have \`foo(string $a)\` and \`foo($a)\` which one should be called given that both are valid. You can say that it should pick the most specific one possible but I'm not sure if that could be properly implemented. Or well, keep using it properly then :P &gt; No proper function annotations, we have like comment or PHPDoc annotations not something like: &gt; &gt;@route='/member' I feel meh about the engine supporting annotations when there are userland solutions that solve that issue properly. Either way, you may also get them soon: [https://wiki.php.net/rfc/annotations\_v2](https://wiki.php.net/rfc/annotations_v2)
Great, thanks!
Great, thanks!
The first part of what? I’m not sure you read my reply correctly. I’m not saying Laravel can be use without a plugin, I’m saying Symfony can’t be used *without* one. 
&gt;You can use them as arrays. How does that affect you? The fact that `array_keys` exists is a hint to the problem. Any userland arrays that you take in need to be sanitized to even be trusted as a robust array. I understand that it works currently but it's not "nice". `Deal with it` type responses mean nothing in a discussion of brainstorming how things could be better. I'm glad there is an incoming RFC in the future for return types. &gt; If you can have `foo(string $a)` and `foo($a)` which one should be called given that both are valid I keep seeing people give that example and i think it's missing the point. If we did get method signatures it should be for strict only and would throw on vague casting in your example. Every single overriding signature would have to define and give the same return type with different amounts or types of expected param. It's in all honesty a non problem that people make it confusing to even talk about. &gt;when there are userland solutions that solve that issue properly. Don't you feel strange though about the way it's being done? It's so hard to even discuss PHP with other engineers because of the `it's working whats your problem` attitude. There is nothing wrong with considering how things might be done better. SRP for annotations having their own system to make them seems like it would be more clear and easier to teach people instead of it still all being dumped into comments.
By this logic nobody less than a chef can learn anything from a recipe. Do you really believe that?
Thanks &amp;#x200B;
I'm sorry but the "it was never meant to be a programming language" line is too old. It evolved and became one, bam, just like that. With that out of our way, I'm not saying it is perfect, but the quoted sentence in the post didn't bring anything to the table, it was pointless in my opinion, and something that many developers learned that was cool to say. 
Absolutely it is? Now if you’re talking things like annotations, etc sure. I mean core code-completion and the like doesn’t work without a plugin on Laravel.
I'm not disputing the fact that it is one. I'm just stating that it has a lot of garbage in it left from old times, which are kept due to BC promise. And it makes language at times somewhat clunky to use at lower levels of abstraction. For example when your building cli tools. The experience of modern frameworks is great though.
Can you even work on a Symfony project without using annotations? I don’t know what to tell you, I tried working on several Symfony projects without a full-on IDE and found it completely impossible. The plugin for JetBrains IDEs makes it more bearable, but I still hated it. 
&gt; they will be working against their habits and make mistakes. Unless of course those conventions aren’t as common as I thought in larger projects / with more senior devs. That is what code reviews and styleguide are for. I'm pretty sure decent senior dev know when and when not to use facade/helpers/whatever. Facade abuse disapear quite fast I think. --- &gt; you either play along with Laravel-way and really have the RAD experience, or you choose your way and do a lot from scratch, forfeiting the benefits of a RAD framework. I'd say laravel docs are not good enough yet to explain you how to customise the framework heavily, without having to source dive sometimes. But you definitly can create a laravel app with twig, doctrine, sonata admin, instead of the laravel equivalents. In one of my projects, there is only 5 of the 26 default one that are uncommented. In an other, I swap some with custom ones (the blade one) to use a custom blade compiler. In some, I have a module architecture, so no app folder at all. I still have eloquent when needed, notifications when needed, websocket when needed, and custom blade when needed. I'm sure a lot of people tried to bend their code to fit in laravel default set up. I'm also sure not many of those learnt how to realy customise the beast before dropping it/going to symfony. Where it won't be necessarily easier, but a clean slate and a better understanding of the problem is bound to do better. --- &gt; And to me that was Laravels USP, so I suggested going straight to Symfony in similar situations Laravel is not a one trick pony. At all. To me, the most important question to choose between Laravel and Symfony is team prior knowledge. Nowadays, there is more philosophical differences than actual ones between the two. One could say we are at a phase where symfony is taking some ideas from laravel in some places (laravel elixir/mix vs symfony encore, symfony moving to conventions over config in the version 4, leaving the bundle approach ...)
Hey, Lelectrolux, just a quick heads-up: **realy** is actually spelled **really**. You can remember it by **two ls**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
You're absolutely correct!
&gt; Then I figured out if I register my own Plates Engine factory within the container it will be used instead of the default one. I might have been spoiled/be used to it from previous experiences , but that's what I would have done straight away. Remap a key/interface to a concrete implementation and it should swap everywhere. Like I said, I might have been spoiled/be lucky/be shown that trick when I first learnt dic, but that seems obvious to me. That or I didn't understand your problem with zend, might be just that \ ^\ ^
I still don't understand what the hell you're talking about. You just seem confused. Laravel's container doesn't have to use Reflection at all, if you explicitly define the things you're trying to resolve. Reflection is only used as a fallback. I also fail to see what this has to do with the service locator pattern. 
Have a look at Sylius. It is specifically targeted at mid (and large size businesses, as long as you don't wanna be Amazon or AliExpress). Might not be as battle tested but everybody's gotta to start somewhere and it's as good of a starting point as you'll get in PHP nowadays.
I don't think this article is an argument against frameworks in general, it's an explanation of why this person doesn't like Laravel. While I don't have any skin in this particular game, it mirrors many of my issues with web frameworks in general. In particular Django (cause I'm a snake boy at heart) and to a lesser extent Flask (these are the two premier web frameworks in Python land for those who don't know). Django does _a lot_ of magic behind the scenes. Something you reference as a string somewhere magically becomes an entire subsection of your web app. There's secret thread globals that control quite a bit but are hard to interact with. The only reason Flask annoys me less is because it wears it's magic on its sleeve and makes it easy to interact with. Similarly, C#'s MVC and WebAPI feel the same way - lots of magic, not always easy to interact with - but at least there's a very strong culture around using DI with them.
Anything sufficiently complex \*and abstracted\* is magic. You're tilting at windmills.
Everyone has a budget. Nearly everyone has a budget primarily driven by time and cost. Even if they don't do client work. In addition, the position presented while not absolutely the case is logically the case since any other framework is likely to have its own warts and they won't be the same warts that Laravel has. Therefore, if your goal is to remove perceived warts then the only end state of this ego-driven framework wart nihilism is to roll your own.
How could anybody disagree with this?
"Technical debt" is the cheapest tradeoff you'll ever make if the area related to the debt never actually changes.
It’s funny how Laravel/Symfony community can be so split, while having the same argument as the other side. However, if you truly could use Laravel without a full-blown IDE (and third-party plugin for code-completion) , damn. Major kudos are in order for you.
&gt; This is a communication and planning problem [...] Don't write code if you don't understand the problem inside out, and ask questions until you do. This year alone, me and one of my clients made plans for feature release calendar. We had the same view of the project and what would be needed down the line. Most of the work laid down for latter had to be scrapped down when competition forced us to change our plans.
Seems like a strange choice to alienate some users because the choice of a browser for something trivial like that. The browsers are smart enough to understand that they need CSS files to render the site :)
Unfortunatelly, CodeSniffer stil uses own autoload. You need to include it. Like this: https://github.com/Symplify/Symplify/blob/35b583dc85a6ccbf3a9d366aa0b14980e081411b/tests/bootstrap.php#L6
Ohh trust me buddy, I had no idea. Your username actually is my answer to you 😂😂😂 I thought they had it fixed, it's already been 2 versions now. Thanks to you I will fix that first thing in the morning. It was simply a performance improvement to rank better on Google. Thank you for letting me know! ❤️
Well, I expect a package with a configuration for a library to provide me an instance of the main class of this library. Instead I'm given a framework adapter and I have to figure out how to configure the main class of the library. This is just an example. I know that's a detail, but that's 10min of searching repeated for every library. It's faster to manually configure my container myself. Also, anyone with knowledge about php and DI container can very easily understand my code and could work with me on the project. I made few very lightview libraries to ease the process a bit, I'll release them someday.
There's just so much implied with JSX. It requires an `import React` at the top, unless you config the pragma. It uses a convention where all uppercase-beginning tags are assumed to be functions while lowercase ones are strings, so while `&lt;P&gt;Hello, world!&lt;/P&gt;` is perfectly valid HTML, this actually means `React.createElement(P, null, 'Hello, world!')` which it's not. So `&lt;DIV&gt;&lt;p&gt;Hi&lt;/p&gt;&lt;/DIV&gt;` will fail. Then there's this shift I've seen where people like short propnames so much you'll see `&lt;Foo {...{ handleThis, handleThat, name }} /&gt;`, so you're essentially using JSX to wrap simple javascript objects instead of simply using them directly in the first place. I've hired a couple guys who were trained on JSX, and they're both getting by without it just fine. We've avoided a lot of errors I used to see, and we don't lose time configuring all our tooling to also support JSX. If it works with JS it works, because that's all it is.
The Doctrine documentation is really quite nice. It's complicated because ORMs are just ... well ... complicated. I highly recommend reading it all. I have used parts from every single page. Some other good documentation is from the Symfony website: [https://symfony.com/doc/current/doctrine.html](https://symfony.com/doc/current/doctrine.html) I think with both of these sites, you can become an expert in Doctrine.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
PHP - named parameters &amp;#x200B; Tip: &amp;#x200B; Instead of &amp;#x200B; mktime(15, 30, 0, 5, 13, 2019); &amp;#x200B; You can do this: &amp;#x200B; mktime( $hour = 15, $minute = 30, $second = 0, $month = 5, $day = 13, $year = 2019 ); &amp;#x200B; Just sayin'
Awesome Doctrine - https://github.com/biberlabs/awesome-doctrine
Would this not be considered an unpredictable transition of business objectives that would lead to code being scraped no matter what? I don't think that assuming the worst is a good reason to write hard to maintain code.
Seems all points don't make sense to me. And if if they make sense, they are not enough reasons to leave Laravel. 
First decide if you really need object relational mapping and deal with model based objects in your code, or do you want to deal with pure SQL or DB objects and simply want an abstraction layer to keep the DB agnostic? If the answer is latter, then I suggest DBO instead of Doctrine, since it will be faster and more efficient.
https://symfonycasts.com/screencast/symfony-doctrine You have to pay for the video, but the transcript is free
W3schools to learn the syntax: [https://www.w3schools.com/php/](https://www.w3schools.com/php/) This PDF: [https://downloads.mysql.com/docs/apis-php-en.pdf](https://downloads.mysql.com/docs/apis-php-en.pdf) Then learn basic CRUD: [https://www.youtube.com/watch?v=mjVuBlwXASo&amp;t=1147s](https://www.youtube.com/watch?v=mjVuBlwXASo&amp;t=1147s) Then make something you're passionate about using what you've learned,a blog is a popular option.
Please explain what you mean by "crippled". I'll wait.
Yes, you can work without annotations. We use XML for or data mapping in doctrine and YAML for routes were I work. Of course persinally I do the the no framework, since it allows me to make the choices of the best fit tools, instead of having to fight oddness.
Hi, This subreddit is mainly used to discuss the PHP ecosystem and related software engineer, and doesn't offer coding help. Please see r/phphelp
First it looks like you are missing the closing p tag. Second I encourage you to use the alternate syntax for if statments when conditionally outputting HTML. It allows you to advatage of your editors syntax highlighting and intellisence. Makes it easier to spot code errors. https://secure.php.net/manual/en/control-structures.alternative-syntax.php
Remove the double quote after world
I would say shopware. It is easily customizable and looks really good by default.
&gt;https://www.amazon.com/Extending-Embedding-PHP-Sara-Golemon/dp/067232704X Thank you. I will defiantly think about checking it out. However, I'm likely going to look at other resources first though, because buying a book for a project which still has a shaky future... &amp;#x200B; I would've thought it would be easier then this. Like, I'd assumed many people would've wondered this, and it would take at most a couple Google searches, then poof, my code could now parse PHP. I was very wrong. Anyways, something I was unable to do because of my GitLab server not being able to keep up, was post my repository URL. I'll include it with this response, but I'm including it with my initial comment (body) too. URL-&gt; [https://git.meproduction.org/coderboy14/microweb](https://git.meproduction.org/coderboy14/microweb)
This isn't a place for coding help, but a couple of suggestions: * break out of code to output html if you have to mix the two, echoing it out makes debugging the html harder * if you break out of html and still need to output a php variable's value, use \`&lt;?= $variable ?&gt;\` to do that * personally I find the style you're using with your curly brackets harder to read, take a look at the PSR-1 and PSR-2 standards, which are widely adopted: * [https://www.php-fig.org/psr/psr-1/](https://www.php-fig.org/psr/psr-1/) * [https://www.php-fig.org/psr/psr-2/](https://www.php-fig.org/psr/psr-2/)
Funny you should say about Flask, considering I was winging it while trying to upload a web-based app onto AWS Lambda. I may not know truly about Python (I was coding primarily in PHP at that time) but it gets the job done. In the same vein, Laravel saved me time to code for businesses.
Don't get me wrong, I love Flask. But I find it important to be critical of our tools and aware of their flaws. Like I'm a Python guy at heart and I can't see myself letting that go, but I'll also be the first to start throwing rocks at it as well. Blind acceptance of tools is never a good thing.
[https://laracasts.com/series/php-for-beginners](https://laracasts.com/series/php-for-beginners) &amp;#x200B; This and the other courses on laracasts about PHP (and on the laravel framework if you choose that path, which I do recommend) are the best learning resources for programming I've seen
&gt; or use node.js without MongoDB [MEAN](https://en.wikipedia.org/wiki/MEAN_(software_bundle)) has alwyas been more a marketing term than a dominant paradigm. It is very unlike LAMP or ELK. It's referring to AngularJS, anyway, I'd assume; it's not ME[A8BETA](https://en.wikipedia.org/wiki/Angular_(web_framework))N.
My definition of bad magic is "voodoo at a distance", something in the code base far off in the distance from my code that materially affects how my code operates. And probably un-discoverable from any means other than digging through framework code, not even bad documentation is any help other than swallowing hours of fruitless effort. The best bad magic is in a framework that swallows the calls tack on you so not even a clue where to set watchpoints. Ruby metaprogramming is magic extraordinaire.
You are ranting about Facades. Well, then don't use them, use DI if you prefer. &amp;#x200B; You rant about Eloquent. Well, don't use it and use Query builder instead. &amp;#x200B; You rant about global helpers. Well, don't use them? &amp;#x200B; See, Laravel does not locks you to something you have so much choice what to use.
I think that’s it! Thanks! Now it looks like there’s a whole lot of other things to figure out, like how to get PHPUnit to call something as if in command line mode and pass in arguments. Also an environment variable that the code mentions is to allow it to run in unit tests. Or maybe I should just wrap my class up and test it in isolation.
But why even load all that stuff into your app if you are never going to use it? Laravel has the slowest ttfb of all PHP frameworks and it is because of all it loads with.
I wouldn't send sms over loops like that. I prefer to use the built-in service twilio has where you send a message, a list of numbers, and twilio does all the work.
https://www.doctrine-project.org/projects/doctrine-orm/en/current/tutorials/getting-started.html They're own documentation is fabulous.
 if (is_page('1')) { echo ''; } elseif (!is_front_page()) { echo ' &lt;p class="someClass"&gt;Hello World!" '; } ?&gt;```` I'm going to clean it up a little to make it easier to read. if (is_page('1')) { echo ''; } elseif (!is_front_page()) { echo ' &lt;p class="someClass"&gt;Hello World!" '; } So, now that we can read it, I can tell you that there is no issue with your syntax. &amp;#x200B; What your code is doing is this: if is_page('1') is true echo else, if is_front_page() is not true echo &lt;p class="someClass"&gt;Hello World!" if neither of those are true do nothing Essentially, is\_page('1') is coming back false and is\_front\_page() is coming back true. &amp;#x200B; You do not have a case for anything else. If you need to test for it being the front page, add an else statement. If you don't, take away the else if and change it to an else statement.
I’m not clicking that link. Let me know how it turns out.
Thank you for pointing out what I've been telling people for years. We can complain all we want about "magic" in our frameworks but in the end PHP is one of the only ecosystems where this kind of thing is debated so hotly. In dotnet the whole thing pays very little heed to how much "magic" it has. DotNet isn't afraid of magic it embraces it. Almost every other language has more "magic" than the average PHP framework. With the exception of some of the modern ones like golang frameworks. In other languages developers know that this kind of thing isn't ideal but they also love their magic because it usually makes their jobs easier. Also they have tooling that can recognise that kind of stuff. Especially in dotnet. In the end if this really is a problem then PHP and laravel isn't doing that bad in the scheme of things. Also I feel like I just said magic too much. I wish there was another word for this stuff.
*Hey just noticed..* It's your **1st Cakeday** nerdroid_95! ^(hug)
Time up front? Sure, but you are forgetting time in the long term. If your projects are all simple then Laravel is a good fit, but it really, really doesn't scale (in terms of code/developers). There are better alternatives to Laravel that do NOT require building everything from the ground up. &gt;Laravel’s approach to making everything as easy as possible is good. But it’s hard to get along when your apps become more advanced. I prefer awesome IDE support, stronger typing, real objects, and good engineering. I might even go back to Laravel when I want to write a smaller app. 
&gt;I mean core code-completion and the like doesn’t work without a plugin on Laravel. Wow, I've worked for _years_ in phpStorm without a Laravel plugin with near to zero issues, because 95% of our codebase is our own well-written code that phpStorm understand just fine. In retrospect, I probably should have installed that plugin but I never felt the need because of how little we used façades.
Time you’ll lose again when a year from now your client returns and wants a few changes. Shortcuts always come back to bite you. Allowing additional start up time for a project to think about the task at hand instead of just going at it _will_ pay off the first time a change request comes in. The suggestions given by the author here do not require extra time; using proper dependency injection over global functions - which seems the big take away - adds the flexibility you want. And need.
It seems a recurring theme within Symfony; trying to cover all bases. It makes there components needlessly blosted and complex. But that’s just my two cents. Agree with the configuration: pick one and stick to it. And I don’t care if it’s yaml or json or xml or whatever format.
&gt; My issue is that the article takes a jab at it without backing it up. I think it actually made sense for the article to stick to its subject matter about Laravel, did it really need to re-list the usual stuff about poor design choices in PHP that we've been hearing for years? Like all things, PHP has good and bad things about it. We've heard them all before, and they're mostly fairly well accepted as so, including by Rasmus. That doesn't make it a bad tool overall. &gt; But either way, I'm not defending that PHP is thoroughly well designed. So it sounds like you might also accept this in some areas too then. So did you really want this stuff re-iterated once again, in an article that says it's about Laravel? Personally I'm sick of reading articles that can't get-to and stick-to the main subject, no time to dilly dally. 
&gt; It's not that hard to drop eloquent and use doctrine in laravel... It is near impossible because some like you already did this: &gt;We shouldn't write repositories Laravel is a cancer on PHP. It would be absolutely fantastic if it was that RAD framework you could use for agency work, or just to get shit done, but it's sold as an Enterprise Solution to everything, and everyone that starts out with it drinks the cool aid by the gallon. I agree 100% with you that DDD is not a requirement for every project (possibly not even that many) but the lack of understanding that sometimes it is, and that when it is Laravel is an absolute shit show of a framework is quite sad. It's not even possible to have a domain model just using Eloquent. There is next to no integrity and no ability to control your model.
If you are only interested in products and customers, you could try to export those things via adminhtml and import it into m2(after altering the csv to suit m2). I think both version have import/export for those entities. You could set up both shops and databases in a single container and then use the mirgration tool. As i dont have much experience with docker i cant give you more information. The same works for using a VM with linux system. Would be my go to. Just set up a VM, bring both databases on there and migrate them. 
&gt; With a bit of memory, most of the gaps are filled after a few months. You should remember what all your code does? What about new devs? This is crazy. &gt;About eloquent TableA::select('table_b.*') Fuck Eloquent. Yes, I have seen that in production.
&gt; define data objects within your domain that aren't using Eloquent (or any ORM for that matter), and then to define contracts within that domain which instruct your `Services` to return these objects instead of Eloquent models Doctrine provides the clear separation without having to have two "models". That is, you get to use an ORM **and** have a separate domain. AR and Eloquent fuck this up, not "any ORM", just Eloquent.
But if you want to keep it going it's the worst. The author actually agrees with you BTW, see the conclusion.
Laravel uses symfony components, you can choose what symfony components to use in your project making your own framework, so you really have freedom to mix and match :)) lol
:facepalm: At this point I know I'm talking to someone who doesn't know how DI containers work. PHP doesn't use Dagger implementation of DI containers. None of the frameworks do.
Hello, I'm making an e-commerce website and I have a sorting feature witch sorts according to category and price. My PHP code for sorting by price is as follows: &lt;?php include 'common.php'; outputHeader('Books'); outputNav(); $mongoClient = new MongoClient(); $db = $mongoClient -&gt; harrypotterdb; $findCriteria =[ "price" =&gt; 1, ]; $cursor = $db -&gt; products -&gt; find().sort($findCriteria); //Line 13 foreach ($cursor as $prod){ echo '&lt;div class=cat-item&gt;'; echo '&lt;a href = "product.php?_id='.$prod["_id"].'"&gt;&lt;img src="'.$prod['image'].'" height=390px&gt;&lt;/a&gt;'; echo '&lt;div class=aname&gt;'.$prod['product_name']. '&lt;/div&gt;'; echo '&lt;div class=aprice&gt;'.$prod['price']. '&lt;/div&gt;'; echo '&lt;/div&gt;'; echo '&lt;/body&gt;'; echo '&lt;/html&gt;'; } ?&gt; However I'm getting this error:Catchable fatal error: Object of class MongoCursor could not be converted to string in C:\\www\\HpStore\\PHP\\sort.php on line 13. What am I doing wrong?
Read down the other posts.
You have added `"` in elseif condition also `&lt;/p&gt;` is missing. `if ( is_page('1') ) { echo ''; }` `elseif ( !is_front_page() ) { echo '&lt;p class="someClass"&gt;Hello World!&lt;/p&gt;'; }` 
[removed]
What you've done is confuse the MongoDB shell syntax and PHP syntax. The killer here is the `find().sort(...` bit. The operator for methods on objects is `-&gt;`, but you're using `.` as in the shell. This is the string concatenation operator in PHP, so it's trying to convert the return value of the `find()` method (a MongoDB cursor) to a string first.
You are calling sort method with a dot, you should use an arrow.
Keep in mind if you are using additional plugins (3rd party) it‘s very common that migration tools do not cover upgrading these data.
Just disable them?
So, Java or C#?
I think you're harming your product more than doing it good with all the spam.. 
I mostly see people disagreeing with the post, so I wonder where the gold-givers and upvoters are? I mean, if you're going to give gold but not defend your opinion, it sure looks like bashing on a framework you just don't like?
&gt;it simply no longer belongs in this day and age For this very same reason we shouldn't be using Apache as a webserver anymore, after not being able to provide the same performance greatness of nginx without great tuning. But Apache is there. Heck, even some of us still use lighttpd because is still good enough and still updated. I'm sick of holy wars and words like "accepted", "standard", people complaining about "having to learn other people's code" and having to religiously proceed with any best practice just because is date("Y") instead of knowing your options and take the good/performant enough approach for the given context. /rant
Reflection is only used as a fallback, when the container has to resolve something that hasn't been bound explicitly. Why would it have to use reflection if you do something like this? $container-&gt;bind(Foo::class, function() { return new Foo('whatever'); }); $container-&gt;bind(Bar::class, function(Container $container) { return new Bar($container-&gt;get(Foo::class)); }); 
Wha experience do you hace with Yii? How do you compare it to laravel? I used yii for a lot of years, switched to laravel because of a client requirement and honestly, I didn’t understand all the fuzz about L 
Upvoted. I'm using Laravel very successfully but it has its pitfalls. However, no matter what framework, people will also manage to shoot themselves in their feet… :-)
&gt; EDIT: I'm not sure why I can't include this on the post. It says "post cannot contain text"? This is probably a safeguard to ensure that people don't post help posts (as stated in rule number 4). Help posts are for /r/phphelp
People say they save time by using frameworks but all i see is developers spending a lot of time understanding the weird stuff that a framework does. Take bootstrap for example, just for forms you are adding thousands of CSS lines and that is only 1 of many components.
Done! Thank you again &lt;3!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I mean, there are people who sleep on nail beds, doesn't mean I have to be one. 
sure ... if you see java as an alternative to laravel
&gt; However, no matter what framework, people will also manage to shoot themselves in their feet Why don't we apply that logic to car safety? People will always kill themselves in cars so why bother with air bags? The current problem is all these Laravel experts running around saying they can easily drive to the shops and almost never die, so we're stuck building cars with no safety features that I have to drive across country.
Thank you very much! I will check it out!
Thank you!!
Thanks for the recommendation!
Thank you for the detailed answer!
Thank you very much!
Magento if you have over 10 000 products and WooCommerce if you have less than 10k products. I can say that WooCommerce is cheaper because it's based on Wordpress and WP developers are cheaper than Magento developers. Also, there are many more Wordpress plugins taht you can integrate in your platform. You can also consider using Shopify or Bigcommerce, and you'll have to pay a monthly tax. This is way cheaper than paying a developer/company to customize a Magento website. Also, keep in mind that updating Magento from version 1 to 2 (and keeping existing modules and custom work) is almost impossible (or too expensive).
Yii has some really weird stuff going on. A million different things extending BaseObject and using magic $config array injection. No real view system. But a ton of widgets injecting HTML and JS in weird and unpredictable ways. Asset handling, but it just adds a ton of individual script/link tags. Magic naming conventions to resolve routes/controllers/actions properly. It just feels very "oldschool" in many areas, like something people would have written 10 years ago, but feels out of place today. Looking at Yii projects, I found it very hard to actually figure out what's going on and why certain things are happening. It all felt too convoluted and unpredictable.
Yeah no.
Not sure how much of original logic you want to keep, but if it's PHP 5.3+, you can use Rector for migration: https://github.com/rectorphp/rector
This is exactly my problem. I have tried to get a grasp of laravel. The time it takes me to understand the shortcut, I could just code myself. Or copy from a former project at nudge into what I want. But I have issues with not understanding the whole code. If it's magic I get paranoid. All power to those who can live that way though
r/lostredditors r/fortnitebr is over there -&gt;
"Comments are closed."
Erm DATE_RFC3339_EXTENDED ?
You can remove the action attribute from the form and change the input type from ‘submit’ to ‘button’
* This is not a support forum * Your problem is not related to PHP, but your gaps in knowledge about how forms work I would suggest you delete this post and look for online resources that cover the workings of forms
Huh? Who is you?
OK I understand that Laravel uses the reflection at runtime, and Symfony doesn't because of its cache. This is an implementation detail. But this is what people are reacting to: &gt; Laravels DI is actually Service Locator under the hood &gt; &gt; Symfony's DI, however, is actual DI IoC container Your interpretation of Service Locator and IoC Container are incorrect. Both are containers and can be used as service locators, so **both of them are service locators**. On top of that both of them can let us do dependency injection, so **both of them are DI containers**. And furthermore you said: &gt; Laravels DI is actually Service Locator under the hood. The way it "injects" dependencies is by the service itself calling for dependencies it needs rather than them being passed as an argument. That is true when using it as a service locator. Just like you can do the same with Symfony. But again "The way it "injects" dependencies is by the service itself calling for dependencies" is false if you choose to use dependency injection with Laravel. As a side note I want to reassure you that I know what you told me to learn about. I have seen Beau's presentation and I've met him. I have written the [PHP-DI container](http://php-di.org/), I have analyzed both internals of Symfony and Laravel's containers and I have worked on [PSR-11](https://www.php-fig.org/psr/psr-11/) to standardize containers. I know how these containers work. But you are thinking that because they have an internal difference (compiled or not compiled, cached or not cached) there is a difference in _design pattern_ (service locator vs DI). There isn't. What matters is how they are actually used.
&gt; an unpredictable transition of business objectives Yes and no. I couldn't have guess where we went, sure. In that it was unpredictable. But these changes happen enough that I could also take a bet there would be one. &gt; code being scraped Yes, code would have been scrapped no matter what, duh. I agree on that. But suken cost fallacy and other things make the wrong abstraction harder to refactor than the down to earth code that would have done the same. &gt; good reason to write hard to maintain code. Strawman. Simple, non abstracted code is often easier to refactor/scrap than the alternative. Facades, helpers, eloquent inline queries, a lot of the "bad things of laravel", all of these aren't that hard to refactor in themselves. It's when you have these scattered over hundred of files interacting with each other that it compound in an unmanageable mess. On refactoring, there is a saying : make the change easy, then make the easy change. In that order. The wrong abstraction always make the change harder.
Active Record in Rails is no different (Eloquent is heavily based on AR).
The base and basic of the OOP is the use of a model/domain class. Every (business) project has two viewpoints: * Business viewpoint. * Technical viewpoint. Let's say that you want to do a form to insert a user. So, you will need a "model" that, ahem, model the business viewpoint of the customer What "information" are useful for a customer?. (aka, the called states that technically are our fields or index if it is an array). For example, the name, age, address, phone and such. But, do you need to know if the customer is pretty or blond?, Maybe not, so they are not part of your business needing (i.e. you don't need to add those). So, our model class (or we could use an associative array) is as follow: ``` class Customer { var $name; var $age; // etc. } or $customer=['name'=&gt;'','age'=&gt;'',...]; ``` Also, we should comply with the technical viewpoint. For example, we could need a "primary key". ``` class Customer { var $idCustomer; var $name; var $age; // etc. } or $customer=['idCustomer=&gt;'','name'=&gt;'','age'=&gt;'',...]; ``` 
If you are looking for a less-complicated data mapper, give [Atlas](http://atlasphp.io) a try. (I am the lead on the project.)
Every major SQL engine's date formats in all their precision(s) should be constants.
&gt; It's not that hard to drop eloquent and use doctrine in laravel... &gt; It is near impossible because some like you already did this: &gt; We shouldn't write repositories First, if you really read what I wrote, I use repos, I just don't think we should always start with one. It must be a concious decision, based on the current project context. Don't put incomplete/exagerated words in my mouth. Second, I've made the switch between no repos and repos, several times, in both directions. I also made the switch from eloquent to doctrine or the reverse, but less often, as you generally can know which one would be the best on project start. So I'm pretty sure I know what I'm talking about... It's totally doable. What prevents you from doing the switch is not the absence of repos themselves, but the littering through the codebase. Which can also happen with repos, as it is more a testament of the devs abilities than the tool. &gt; There is next to no integrity and no ability to control your model. Single table inheritance, and non primitive casting are on my christmas list, true. Anyway, I'm losing my time, you are not here to discuss, but to shit on laravel...
Type your question into google and read the many articles with graphs detailing these things.
&gt; Ruby metaprogramming is magic extraordinaire. You don't have to remind me... Some of the things discussed in this thread don't even need to exists in ruby... But duck typing would break the mind of a good deal of the basic I hate laravel because it is not symfony crowd.
&gt; However, if you truly could use Laravel without a full-blown IDE (and third-party plugin for code-completion) , damn. Major kudos are in order for you. Fun fact, most of the well known Laravel devs use Sublime Text as their main editor (taylor does for sure). &gt; It’s funny how Laravel/Symfony community can be so split, while having the same argument as the other side. The sublime text use is one of the (bad) arguments thrown against laravel for some symfony devs, as if it meant sublime users are not true devs^tm.
&gt; You should remember what all your code does? What about new devs? This is crazy. Are you really telling me you go to the docs for each line of code you write ? Come on. If you want me to be extra clear : &gt; With a bit of memory, most of the gaps **you use every day** are filled after a few months. And the non every day thingy ? Either you are a senior dev and you already know it too, or a newbie, I don't know, will ask for help or it will be caught in code reviews...
I just need the data but this looks promising for other projects I have. We are needing to upgrade many sites from php 5 to 7.
You need to learn how to cache it instead of queries to the database
The update comes from a webhook which I post to a db, is this not the best way?
You can create an endpoint and send Ajax requests to it regularly to check whether to redirect. Your endpoint could be a php script that checks your database and returns the appropriate uri to redirect to?
Not needing the M1 site up is a really big relief thanks for that. I’ll look into a VM too, I’m new to using VM and Docker. Never needed them until we started getting clients wanting Magento. PM thought it would be just like WordPress. Nope.
I would send the data to a cache and if it’s not touched or queried within a certain time then it would write to the db 
I did see that, but it makes his argument less convincing. I personally dont write monolithic applications now. I would use symfony or laravel for basic auth and crud stuff as thats what it best at. If i then need something else that needs to be done in a specific way the i would up another container and write it in a language or framework that best suites it. For experienced devs magic is essential as most of the magic does the boring stuff ive seen many times before. If you really need to know what its doing, your IDE (if its a good one) will take you down the rabbit hole. 
We called ours *ATOM\_EXTENDED...*
I think what he's trying to say is check out r/PHPhelp &amp;#x200B;
&gt; Best online help desk &gt; all questions have zero answers Somehow I doubt that
Wow, what a lively community, with 0.5 questions per year in average.
I was, but then I realized OP's problem is not even related to PHP
You'll be polling either way. DB is probably fine if you don't have access to a cache already. Also, if you need the result long-term anyway, putting it in the DB is probably ok. No reason you couldn't do both, if you have both a cache and you want to limit calls to the DB. Lately I've been playing with [pusher.com](https://pusher.com) to get more real-time messaging working. Something like this (or websockets or whatever) would let you poll less frequently (keep polling in place; always good to have a backup) but still get messages super fast. Your webhook handler could first store to the DB, then send a message directly to the messaging service you setup to deliver the update more quickly to your subscriber(s).
Are you okay with paying for good courses for you to learn PHP?
&gt;and now I need to take a step further... And this lead you to Doctrine? :) If you want to see what it is like to use Doctrine ORM without worrying about the setup and "how it works" just yet, you could pick a framework that works nicely with Doctrine ORM in the same way that Laravel works nicely with Eloquent. I've used Symfony 4 and Maker bundle extensively lately. If you want to press out new entities just to play with, it is a great way to start tinkering.
As I thought. So you don't actually have a reason, you just felt like using the word "crippled" as an insult to make yourself feel better. Got it.
Oh, I would never harp on someone because of their IDE. In fact, as long as it’s not hindering them, as in doing things slower, I give major props to those using vim, sublime, etc. In the vase of Taylor though, I’d damn sure hope he could use notepad and get it done. ha
If Magento is too high of a burden, you don’t belong running your own e-commerce implementation. Go to Shopify or another SaaS product. 
&gt; Good luck understanding the source code of Eloquent How Eloquent works is fairly easy to understand once you read through its [source](https://github.com/laravel/framework/tree/5.8/src/Illuminate/Database/Eloquent). The key components are the Factory, Builder, Collection, Relation, and Model classes. Eloquent is much easier to understand than a datamapper ORM (like Doctrine or Hibernate) because there is no unit of work to maintain the state of. Doctrine's unit-of-work implementation is very messy and difficult (at least for me) to follow; the problem domain is essentially the same as what frameworks like React and Angular do on the front-end -- maintain a virtual DOM and quickly detect changes in that virtual DOM, initiating a render when changes occur, only substituting the domain object graph for the virtual DOM and updating the database instead of the browser DOM on changes.
Good article and I really like what you said about the three different kinds. While they're very similar, they vary slightly in nuanced ways. That's something that I miss with a lot of the popular service/message bus implementations that are out there: they use the same interface for all three types. &amp;#x200B; I wish there was a way to more clearly interface "this is a query bus that will return a result" etc... But without generics, I think that's difficult in PHP anyway. 
Thanks for feedback, I didn't notice.
Laravel's [query builder](https://github.com/laravel/framework/tree/5.8/src/Illuminate/Database/Query) isn't particularly complicated, the Builder class is just lengthy to handle all of the different possible possible builder methods. Laravel originally used Symfony's DBAL for a query builder. I don't really understand why Taylor rewrote it to avoid the dependency.
Haha this article is so confusing to. What I got from it was: Through his examples he says you can use Laravel in what he thinks is a shitty way or in another way which he likes better. His conclusion: Im gonna stop using Laravel because you can use it in a shitty way.
I'd be interested in any other commentary you can add about what you learned working on active record ORMs. Patterns, observations, etc... thanks for what you wrote here.
I can't. I *have* to understand the magic or I can't sleep at night.
Yeah, there is no easy way to do that. But the fact that you use a query bus to query things pretty much indicates the same. So that is why I like using (and sharing the knowledge about) these patterns. They have a clear affordance. For the command and query bus you could definitely create the interface so that the *dispatch* method (or whatever you want to call it) has a void return type. This can be done since PHP 7.1.
I don't think anyone said static helpers are magic. That's about magic getters/setters and `__call()`.
I use Sublime Text for just about everything, including Laravel and some C++ 'scripts'. So... kudos to me?
I agree that "magic" is the wrong word here. I would call those "lazy shortcuts"; they are not just shortcuts, they are cut corners, that'll come back and bite you later down the road. Probably that's why they are so hotly debated: "magic" is expected in frameworks, it's "dirty magic" that makes all this stuff for some people.
So, I have an html and it has the tags for php as described in the title. &amp;#x200B; I cannot find, anywhere, how to write php like this and if I try to use &lt;??&gt; or the other tags it just submits it as plain text
There's a HUGE difference with that plugin: it let you *navigate configuration, not code*. All code in a Symfony app is clearly navigable by a vanilla IDE/editor, especially if you use dependency injection correctly, up to your controllers (and they changed the docs to encourage that). Also, thanks to Flex and autowire, config is trimmed to a minimum now, so you're basically left with POPO and DI all over, which is a pleasure to Ctrl-click trough.
Yep.
&gt; Managed Version &gt; A managed, high-scalability version of Mercure is available in private beta. Drop us a mail for details and **pricing**. I think I will still stick to Socket.io, thank you.
Nothing prevent you to use (and modify) the free and open source version on your own infrastructure. You can even implement your own hub following the open protocol. But if you don’t want to bother with the ops part, you have the option to use a managed version. What’s the problem?
Reminder that Mercure itself is open-source and that websockets are incompatible with HTTP/2.
Echo json_encode(your-array-of-data).
[http://php.net/manual/en/class.jsonserializable.php](http://php.net/manual/en/class.jsonserializable.php)
thank you, but in my output i have like this { "test_0": [ { "t_1":"1", "b_1":"test"}, { t_1":"2", "b_1":"test"} ] } and i want it to be like this { "test_0": [ [ "1", "test" ], [ "2", "test"] ] }
Loop on it.
&gt; hello, can /r/PHP please write me a solution how to export only data as json file from my database? 
In the case of PHP, you can't use socket.io without running a dedicated HTTP server for the websockets; so does it matter that the PHP app is HTTP/2 and the websocket server is HTTP/1.1? 
That's not a great example, considering it's trivial to shake out unused CSS (or just not to include the parts of bootstrap you don't want); and considering understanding the complexity of something isn't causatively related to the lines of code it adds. 
Citation needed. I have been maintaining several Laravel apps (read: adding new features and refactoring old ones) for years. Perhaps your personal experience is one of poorly built apps you inherited.
 $data = ["test_0" =&gt; [["t_1" =&gt; "1", "b_1" =&gt; "test"], ["t_1" =&gt; "2", "b_1" =&gt; "test"]]]; $data["test_0"] = array_map(function (array $row) { return array_values($row); }, $data["test_0"]); echo json_encode($data); // {"test_0":[["1","test"],["2","test"]]}
I used to take interviews couple years back and was looking for basics of language. Now, things have changed a lot. I would suggest to go through: - design patterns used by your application - when a particular design pattern is to be used. - architectural details of the framework company is using. - configuration files used. - In some cases a use case can be asked to converted into implementation - check for unit testing too. Hope this helps.
One word: [StackOverflow.com](https://www.stackoverflow.com/). However, your question is of such low quality and undoubtedly a dupe that I'm pretty sure it'd be -5'd and VfD'd so fast that you'll be lucky receiving a quality answer. Better just Google your question first, noob. 
I .. have no idea what you're trying to say :-) 🤷‍♀️
As far as PHP is concerned all it will do is respond to an Ajax request made by the browser. Ajax stands for Asynchronous JavaScript And XML (ignore the XML bit, we all use JSON now). So the actual Ajax request will be made by JavaScript in the browser. PHP will respond with a JSON object, and your JavaScript will update the page. If you're using jQuery already there is a built in Ajax method and helpers for making that request. For the PHP you'll want to JSON encode your response and set a header to let jQuery know the response format.
Just to add: you can build the php in a separate file that the Ajax requests are served from, so the original HTML page can be left as is...
 Hey guys, I'm the person who wrote this article. I created this account so I can answer some of your comments, which I'll do over the next time. You can find the confirmation of me being the author at the bottom of the article. I just edited in my Reddit profile URL. Please give me some time to read through all of this, since it's a lot more than I expected when writing this article. Thank you u/Risse for posting and bringing this article to broader attention. I want to make sure you all know that I didn't intend to offend anyone with my article. I just wanted to write down my train of thoughts why I think Laravel is not the right choice. To sum it all up, it's essentially that it provides quite a few bad practices out of the box , uses some patterns I don't want to follow and avoiding all the pitfalls makes it harder than just using a different framework for me. I know that not everyone agrees and a lot of people love Laravel. I also see why they do. Please make sure you read the whole article. I tried to make it clear that it's not a kind of general "Don't use Laravel, it's inherently bad" article and not a hate speech against Laravel either. I even concluded by saying I might come back to Laravel for some projects. Currently, I am writing a follow-up on how to use Laravel the "right" way, where I try to describe common pitfalls when following the docs or when using everything how it is out of the box. Thank you everyone for your time, I appreciate the nice discussion. Please refrain from insulting me for the article though. I know it's not perfect. It was my first article and I am of course willing to improve on my further posts. Have a nice day!
Assuming that you have PHP installed and configured, all you have to do is rename your HTML files to have the PHP extension as they're otherwise already valid PHP files. In no particular order: - Subscribe to /r/phphelp to ask your questions and to read what other people are getting helped with. - Register with StackOverflow and make sure to search your questions there, first. - Bookmark PHP.net, as it's actually a rather good reference source. Just don't look too closely into the comments section. The quality of those are sometimes bad.
As u/kurashu89 correctly said, my article is not against the usage of frameworks. It's solely about why I *personally* currently don't continue working with Laravel but other frameworks instead. Of course, the usage of frameworks is highly encouraged and has a lot of benefits.
If I were you, and as you built a static website, you should start using Laravel (which provides a very high level of abstraction over many tedious processes like connecting/fetching/closing on a database, making routes, ...). It will help you quickstart very, very fast, even if you think this is a lot to understand. Starting in pure PHP will drive you crazy because you will have to manage a lot of low-level tasks, so Laravel will help you bootstrap all of this. Maybe creating a [api.yourwebsitename.com](https://api.yourwebsitename.com), and you [yourwebsitename.com](https://yourwebsitename.com) will start doing AJAX request to this api url, which is pointing to your Laravel (or whatever framework you feel good with) to responds with JSON responses, in order to keep your website up-to-date. Hope it helps.
Great, my brother also made his own spl\_autoloader and he loves it. Hope it fixes all your issues and more ;) Happy coding, and good luck, let us know when you release new features :)
&gt; https://github.com/IntouchHealth/vcp/pull/2090 Do you have bounded context on top level of structure or technical aspects (like separation by layers)?
Are you running docker for mac? If so, - Cache your volumes - Make sure that docker is using the .raw image format as opposed to .qcow There are other improvements you can make, but in my experience, those help the most.
Linux
Yes, you can circumvent the magic parts for the most time (but not everywhere I think). But going from the documentation, without reading the source and figuring out how it's done better, I find it harder than in other frameworks. It costs me the time that using a RAD framework yields me, so it's effectively not doing anything for me. I've started using Symfony and despite it being a little more complex to set up, the development doesn't feel slower but a lot cleaner. But as I already said in the article, it's of course very subjective and I can see why a lot of people love Laravel (and why I used it, too).
X = 1. Or var x=1. Thatll usually do it.
I agree that we shouldn’t all be following a single dogma - primarily because we can learn a great deal from diversity of ideas But a better analogy would be writing a new HTTP server. Would you try to take influence from Apache or from nginx? I certainly know which codebase I’d rather take a deep-dive into
The good news is, PHP and HTML work very well together! In fact, you can even embed PHP into your HTML file...although it's not as recommended now, because it's not good practice to just have one long file with all of your code in it. But for beginner purposes, it's definitely doable and not a big worry. People hate on W3Schools, and truthfully, if you can afford a better resource, you should go ahead and do that by all means. However, since you don't know how to convert an HTML file into PHP but you do have Javascript and CSS, I'm going to assume you know *some* programming but not an extensive amount. W3Schools is a perfect resource for a beginner to intermediate level of syntax understanding before you start moving on to more complex pieces of code. https://www.w3schools.com/php/default.asp
I totally agree on the last point here. I hate the default configs being YAML as well. I'd really love to have the option to choose which configuration style (YAML, XML, Annotations, PHP) you want when setting up the projects. And I also agree that you should be able to set a fixed config file format that you want to use and all other files are disregarded. I think you can do so by changing the `CONFIG_EXTS` constant in the Kernel.php file to only include XML for example, but I don't know if that has any side effects like silently failing/falling back to defaults because the configs are just not read.
Following your advice I decided to make this framework more modern by integrating composers, some good practices and now I think it's not so bad. Of course, being constantly in development, he hoped that anyone who wanted to help me further optimize it.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
Following your advice I decided to make this framework more modern by integrating composers, some good practices and now I think it's not so bad. Of course, being constantly in development, he hoped that anyone who wanted to help me further optimize it.
I highlighted that it's personal preference in the very first lines of the article :) and I am definitely not a hater, see my conclusion.
Following your advice I decided to make this framework more modern by integrating composers, some good practices and now I think it's not so bad. Of course, being constantly in development, I hope that anyone who want, can help me further optimize it.
Seems super early to be using in production. There's also no testing which raises a red flag for me.
Your .html file is stored on a web server somewhere. The good part is that you can change that file to .php and insert logic by using &lt;?php ... ?&gt; blocks, for instance if you want to iterate over a list of ads that show only non-empty ads (if for whatever reason you think you might have an empty ad stored), $ads being the data object that contains all the ads stored &amp;#x200B; &lt;?php foreach($ads as $ad) : ?&gt; &lt;?php if(!empty($ad)) :?&gt; &lt;h2&gt;&lt;?= $ad-&gt;title; ?&gt;&lt;/h2&gt; &lt;p&gt;&lt;?= $ad-&gt;content; ?&gt;&lt;/p&gt; &lt;?php endif; ?&gt; &lt;?php endforeach; ?&gt; PHP courses on line are everywhere, just search for free ones if you don't fancy paying or just can't &amp;#x200B;
"It is in beta" means it's not ready for production and it's written all over github. I don't want to be offensive but, a red flag just for not having taken a look at github seems excessive to me. The tests are on their way. I am the only developer of the project and I struggle a lot between the wiki to create, the code to check and use, the improvement of compatibility with different solutions (servers and cli), the tests to do... Don't be in a hurry when you judge. I do not want to start a war or oust all those who use something more robust but, create a simple alternative for rapid and free development. Public domain, it belongs to anyone who wants it.
I will give you an advice that will save you 5 years of your life: Skip to Symfony.
&gt; Great, my brother also made his own spl_autoloader and he loves it. Hope it fixes all your issues and more ;) Happy coding, and good luck, let us know when you release new features :) Really? I can't believe it :) . Thank you. I'm really flattered. Just Now I've released a new version a more performant, safe and "modern" version. I suggest you take a look at it on github.
Your database connection uses emulated prepared statements and you do not properly set up the encoding. &amp;#x200B; Also there are several places where I would expect to be XSS vulnerabilities. &amp;#x200B; // the password will contain at least 1 uppercase, 1 lowercase, 1 number or special char, min 8 char length "password" =&gt; "/(?=^.{8,}$)((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$/", // good security &gt;good security &amp;#x200B; Is it though? Or is it just annoying innocent users and/or password manager users instead? &amp;#x200B;
&gt; Is it though? Or is it just annoying innocent users and/or password manager users instead? Hi, thanks for the feedback. As for the class of DB, it is changing these days. Unfortunately, I only have 24 hours a day, 8 of which I use to work on other things. As for regex, that file is a mixture of things that absolutely must be fixed and improved. Would you like to help me?
FFS, don't spam adverts as useful information. C'mon...
Safe and in beta? You can’t have both.
Definitely but, we're trying... The next release will fix all the security issues that have been identified. 
What you are looking for is AJAX, which can bring in data after a page is loaded
&gt;And for the timing attack... it has been solved by adding a middleware but must be integrated with the validation class. It is present in the index where an expiration is inserted to the csrf No it is not solved. I was hinting at doing time constant comparisons instead.
The point is that these Laravel fuckwits think they need to reinvent ORM because they somehow simultaneously hold the opposing views that Eloquent is the best and only ORM and Eloquent isn't an ORM.
Also by looking further please just use a mail library instead of using the raw \`mail()\` function. &amp;#x200B; Mail is hard and it is too easy to screw it up as you did by introducing [header injection vulnerabilities](https://github.com/ngineweb/publicngine-framework/blob/master/system/Core/Base/Functions.php#L73).
I was about to disagree with you but read through the entire article and you’re right on everything. Hiding things don’t actually make anything easier it makes it more complicated IMO. 
&gt; as you generally can know which one would be the best on project start. I'd be interested in hearing more on that. What sort of project is Eloquent good for, and what is the downside of Doctrine that makes it a bad choice for the same project?
Thanks, for the feedback again. Love your interest. For the mail function: must be removed; as it was a function that I sincerely never used, and was put there and never removed. I'll follow your advice to remove it asap. As for the other vulnerabilities you've identified. The regexes and the timing attack will be resolved by tomorrow afternoon. Thank you very much.
&gt; Are you really telling me you go to the docs for each line of code you write ? Come on. No. I use the fucking IDE. That's the bit you are throwing away because you'd rather remember things ... come on.
THAT DOESN'T SURPRISE ME.
That doesn't excuse shitty code
Regardless of all the bad practices, I think the general attitudes and responses of these people should tell you all that you need to know about whether or not you want to be a part of the cult.
To be honest, there is nothing wrong with emulated prepared statements. PDO uses them even when emulation is disabled, for the queries that don't support native prepared statement. And nobody hard of the successful real life injection yet.
This is not safe. Email header injection: https://github.com/ngineweb/publicngine-framework/blob/master/system/Core/Base/Functions.php#L73 Command injection: https://github.com/ngineweb/publicngine-framework/blob/master/system/Core/Base/Functions.php#L577 Probably XSS: https://github.com/ngineweb/publicngine-framework/blob/master/system/Core/Base/Functions.php#L320 I'm sure there's plenty of other examples, this is just in one file
This should not exist: [https://github.com/ngineweb/publicngine-framework/blob/master/system/Core/Base/Functions.php](https://github.com/ngineweb/publicngine-framework/blob/master/system/Core/Base/Functions.php) Even as "I will try to build a framework to learn" this file should not exist. Period. &amp;#x200B; Overall, this is very early and there is a lot to do. Thing is - this would fly 5-7 years ago, these days, sadly, there are no frameworks that do not use external packages. Here are some candidates to pull from composer and just use: Validation library ORM (Db layer - there are numerous - Doctrine, Atlas for true good ORM's, I'd not recommend Active Record though) Twig (templating - I'm gonna go on a limb here and say that this is the only real good choice and should be used) Security stuff - unless you ARE a security expert or had enough bumps and bruises to prove you are decent - DO NOT ATTEMPT. Or, alternatively, dive into security hardcore - see you in a few months. Others have pointed out a few things already. &amp;#x200B; TL;DR: In 2019 your first framework has to look a lot more different. Take a look at Lumen, Slim and Flight micro-frameworks for inspiration. Unfortunately your style, approach and architecture is about 10 years old. This will be a negative impact on your github profile when applying for jobs where people do modern stuff.
MySQL is unlikely to get merged as it doesn't contain timezone information https://github.com/php/php-src/pull/3690
Although not directly a vulnerability in using prepared statements Drupal may have wished they were doing it \[a while ago\]([https://blog.ircmaxell.com/2014/10/a-lesson-in-security.html](https://blog.ircmaxell.com/2014/10/a-lesson-in-security.html)).
First impressions: - I'm not sure to understand why this is needed (reasons are unclear to me) - The use of traits for code reuse is questionable - And especially, the heavy use of destructors to throw exceptions look like a recipe for nightmare-style debugging sessions for any users of the component 
Many people take this article wrong. It is not emulated statements that led to injection. There is nothing special in this case, SQL injection always there when you put untreated data in your query. Don't put user input as a pert of your query ansd there will be no injection, no matter whether statements are emulated or not. As simple as that. 
Many people take this article wrong. And it does a considerable harm drawing attention from the real cause towards that trifle affair with emulation. What Drupal folks would have really wished is **not putting the outside data inside the query.** As long as you follow this simple rule, no injection would be possible. And if you don't, the emulation mode will be your least problem. 
Well, this heap of functions didn't improve since last time the guy posted it here. This file is rather amusing. That double die in deny_direct_access() and casting in microtime_float() are my favorites :)
&gt; Don't be in a hurry when judge. Here's the thing, what you've presented, its been presented before. Not this project, not by you, but it has been presented before. So called "frameworks" that are promoted as safe, fast, lightweight, etc, with nothing to back up these claims. They all look the same, and they're all poorly designed and none of them are worth contributing to. You promote the framework and ask for input and contribution, but then get defensive at any criticism. This framework has no redeeming qualities other than it was a fun exercise for you.
I've provide the reasons and I've pointed where you can find them in rather lengthy discusion about framework specific implementations. If you care more about jerking your own opinion by making snyde remarks I cannot help you.
Why introduce an http client with so many implementations? From the PR text I count a `fopen` based implementation, a cURL based implementation, a PSR-18 implementation and a traceable implementation. Why not introduce an interface as a package or bundle and offer implementations in separate packages?
What's "official" about this?
You might have better luck at /r/PHPhelp This is a discussion subreddit.
You can rename your .html file into a .php file and the page should still work. Then go from there replacing pieces you want generated with PHP by embedding them eg: &lt;span&gt;&lt;?php echo "Hello World"; ?&gt;&lt;/span&gt;
• why reinvent the wheel instead of following PSR-7, -17 and -18?
&gt;https://github.com/php/php-src/pull/3690 that's really a shame we are not getting this constant because of that (why even care about it). We have RSS format and ATOM as constants, I maybe used the rss one once and the other one never. Yet I used like hundred of times mysql format and each time I had to go to the stackoverflow/docs to get the correct time format.
I recommend google
You don’t recall the Fabien rage-quit recently around this? He thinks that PSR-7 is overstepping the bounds of PSR, basically outlining a framework and was a political move by another competing lib/project.
Why reinvent the wheel with psr 7,17,18 when there are already so many solid implementations of request/response frameworks?
Hey now, this has to be super safe. What could be more secure than a random string derived from a random string derived from a random string? $this-&gt;fname = hash('sha1', hash('ripemd160', $this-&gt;fname.microtime()).bin2hex(random_bytes(12))).'.'.$this-&gt;ext; That's like three times more secure than most frameworks. You can tell how committed to security someone is by how many times they hash their random numbers.
The term was maybe not very appropriate. I’ll reword. “Official” means that this integration is part of the Symfony project (it’s not a “community” lib), and is the new builtin solution to push data to clients.
&gt; “Official” means that this integration is part of the Symfony project Got it! I did not understand that part at first.
&gt; And especially, the heavy use of destructors to throw exceptions look like a recipe for nightmare-style debugging sessions for any users of the component I'm not even going to look at the code to understand what you mean by that. That's how scary it sounds to me :)
My personal fave is ``` function debug($var): void{ var_dump($var); } ```
&gt; Don't be in a hurry when judge Don't be in a hurry when release If you release your code to the public, it **will** be judged.
From the readme: " The existing state-of-the-art puts a quite high bar in terms of features we must support if we want any adoption. " Those implementations are commonplace in the market.
So http guzzle is not good enough. 
&gt; the heavy use of destructors to throw exceptions I just took a cursory look at it, but it's not even clear to me what benefit this is supposed to provide.
Rage quit? Is making a decision to no longer vote, a rage quit these days?
This package is introduced as several symfony packages depend on http abstractions. The alternative was to depend on external libraries. Symfony wouldn't introduce a new component like this if there were other packages that were good enough.
From the looks of it, destructors are used to clean up streams, exactly what they should be used for afaik.
This is a replacement/transition from goutte, not to replace guzzle.
I mean, good on your for having the courage to contribute, but to be honest, you probably need to spend some time reading books, the PHP documentation, and other framework code before you try to develop this. &amp;#x200B; This global core function really, really bugs me: function timestamp(): int{ /** * Get the current timestamp (Year-Month-Day / Hour-Minute-Second) * Using $_SERVER['REQUEST_TIME'] for Performance */ $date = str_replace(" ", "", date('Y-m-d H:i:s', $_SERVER['REQUEST_TIME'] )); $date = str_replace("-", "", $date); return str_replace(":","", $date); } &amp;#x200B; You are getting the value of the request time (which is \*NOT\* the "current" timestamp, but the timestamp of the request), for "performance reasons, but then make \*THREE\* unnecessary function calls to format the formatted date! If \`return (int) date('YmdHis');\` is a performance bottleneck for your context, you're not using this framework . 
guzzle is basically perfect. http clients are very well solved at this point. 
Gotta have the drama
&gt; PSR-7 is complex Ugh? It’s as explicit as it gets when you look at the interfaces. I’m sorry but you lost me there. 
This is something I've been trying to wrap my brain around. I keep seeing "websockets not compatible with HTTP/2", but I've been wondering under which circumstances that actually matters to me if I'm using a hosted service like [pusher.com](https://pusher.com) to manage websockets. What you've written here seems to confirm for me that it doesn't matter a whole lot in these situations.
They're becoming very similar to work on and I am currently working with both. The IDE support is *imperative* you lose so much if your IDE thinks PHP is all about dynamic typing when laravel relies on typing for so much. Plus in both static analysis finds so much before you even finish writing your unit tests (or feature tests in laravel which are a fantastic idea I've been embracing a lot)
It makes the people go ape.
And I know laravel is not the first to embrace the new world of typing we have in PHP, lots of what I write is composer packages that also rely on it in the same way.
laravel and java are very similar ???
with laravel you can call a static method using `-&gt;` syntax, and call an instance method using `::` syntax. it doesn't embrace anything but hacks.
I strongly agree. This inconsistency is one of my two major gripes with the modern state of PHP.
It’s been an issue since version 3.x which I first learned around 20 years ago. Don’t hold your breath...
Yeah, I believe the policy is ... more important things, considering BC and not breaking changes just for consistency. Lot of PHP usage means lot of code to break.
Not going to happen, the inconsistency is here to stay as most of internal (and I agree) is against adding aliases as they are going to be there for ages. Best case to get some consistency is having arrays act like pseudo-objects with better and more consistent signatures (and similarly for strings). 
They are doing a fair amount of cleanup, but I wouldn't expect them to go changing the function names / parameter orders (some of which, while seeming odd, do have niche reasons). Most clean-up in that context will come when we eventually get scalar methods. 
That's PHP not Laravel per se. You can do it but you shouldn't, and PHP does give warnings for it. You should use Model::query() to retrieve a builder object rather than using Model::where() directly.
That's not what I said. Or not what I meant. Java and PHP are becoming very similar, if you embrace the direction the PHP devs seem headed towards strong typing. Seperately there have even been projects to produce a JVM like PHPVM (See HHVM / Hack - although I'm not sure where that sits today)
Does it have to be a *current* security issue? If not, https://www.cvedetails.com/ is a good place to start for previously reported issues.
PSR-7 is a bit too opinionated of a standard for a lot of people.
As much as I hate the PHP sadness I think sadly this has to stay this way, imagine running a piece of software built for PHP 5.6-7.3 and it doesn't work at all in PHP 8.0 because all functions were suddenly changed, it would create a mess, imagine longer codes like this: `if (php_version() &gt;= 8.0){` `str_pos($haystack, $needle);` `}else{` `strpos($needle, $haystack);` `}` &amp;#x200B; I say, let's keep things "as is"
Yes, it has to be a current security issue. I don't think it has to be something big,I might be able to talk a feature that it lacks. I just dont know where to start, any help would be greatly appreciated 
Until when... You gotta break some eggs... We need at least a PSR for this and to start depreciate stuff for a couple of years maybe to give folks time to catch up... 
"FrameworkName version 3.X.Y will be the last release supporting PHP versions &lt;8.0. From version 4.0.0, PHP 8.0 will be the lowest supported version"
If you make it too difficult to migrate code from 7.4 to 8 people simply wont. If you look through the RFCs which do break backwards compatibility there is always a strong reason to do so as well as an assessment of how much code is likely affected. Changing around function parameters or renaming functions in minor ways feels like a bad type of break because the reason is... aesthetics? My IDE or editor already reminds me of what the arguments are and where they go so even consistency isn’t that compelling because the tools mean that I don’t need to remember the differences.
The fact that people keep referring to it so negatively lends credence to his assertion IMO. It feels like a narrative is being drawn against him.
Maybe take a look at the session handling system, or how session information is transferred to controllers? That'd be the first place I'd look.
Thank you very much, you've been a great help
Scroll down to the very bottom of that first page.
I just wrapped a lot if these functions into easier to use classes in a framework I built for my projects
that doesnt really answer the question, as neither of those are valid email addresses
Yeah, lack of backwards compatibility froze Python 3 adoption for years, and Python 3 vs 2 had a lot more worthwhile improvements than PHP 8 vs 7. 100% killing backwards compatibility for aesthetic reasons would stop PHP in its tracks. 
Can’t they alias the whole clusterfuck in a consistent way and deprecate the old method signatures for removal in 2024 or something
Short answer. A laravel application. Or more specifically, a series of laravel applications spanning all of your clients that any other laravel developer would be able to jump into at pretty much a moments notice. Applications that take advantage of the architectural and security considerations of a community. If you tried you'd just end up making your own framework. One which nobody in the job market would be able to intuitively use, and that would be inferior to laravel in stability and probably in features. &amp;#x200B;
You can’t remove things or change existing functions too much because as other have stated backward compatibility. I would love them to rename functions, change arguments around so their consistent and remove functions no longer needed. But alas they cannot.
XSS, SQL Injection ... take your pick?
There's been talk in PHP internals about addressing the function naming inconsistency by means of creating function aliases, and deprecating the old names. The general feeling is that it's a lot of work and a lot of code to change for very little gain. The function argument order is a much harder problem, since you can't alias and deprecate like you can for the function names, you pretty much have to do a hard cut-over, which is going to break a massive amount of code. Overall, it's just not worth it. 
I would think you would have to read the code?
At this point in PHP life, were these change proposition has been around for a lot of time, I wouldn't count on doing that right now. Simply put, changing these methods and arguments would literally break applications. From your tiny project to very large ones. The only solution that I can come up for this kind of scenarios, where there is an opportunity to clean core code, is to manually add a flag in PHP.ini to keep using these old conventions, while leaving the new ones opt-in until PHP 9.0. In this 9.0 version every old method should throw a deprecation warning. That gives enough time for developers to do adjustments. New projects would be able to use the new conventions, which will allow shit like [`strcspn()` ](https://secure.php.net/manual/en/function.strcspn.php) (seriously what the fuck) to become `string_character_mask()` and so on. This ain't 1999, we can use methods with large names, and the text editor won't get mad about that. In the meantime, the only solution is to make an extension or package (if it's not already done) that aliases all the conundrum about this. 
Swapping the order of arguments around in existing functions for aesthetic reasons is 100x worse than the problem it's supposedly solving. Of all of the complaints about PHP, I think these "inconsistent argument order" ones are by far the least important. With such huge breaking changes in fundamental stuff like this, and without a good reason, I imagine more people would just jump ship to other languages. It gives them a good time/opportunity to at least give it a go, more so than any other time. Even if they come back in the end. The breaking changes between Python 2 and 3 are still an annoyance to have to maintain and cause of confusion, all these years later. I don't even write any Python code at all, it's just a pain as a sysadmin and user of a few CLI tools. A better solution would be: * named arguments, like python has. * or something closer to proper native object literals (like usage of JSON in JS), and having aliased functions that take a single object as an argument - kind of surprised this hasn't been added yet (as far as I know?) ... it's one of things I've liked the most about programming in Typescript/JS lately. The constant swapping between objects and loose assoc arrays in PHP is a huge mess.
Screw that. I would just `require('php8_compat.php');` and the top of my "broken" files and shove stuff like this in it until I converted for reals: function strpos($needle, $haystack){ return str_pos($haystack, $needle); } once I converted for reals I could just shove in the opposite version of that file for pre-8.0 compat. Would be way less work than sprinkling your snippet all over the place. Hell internals could already do this make all the "bad" variations throw a depreciation warning that they will be removed in php9. Giving people plenty of time to prepare. Still won't happen though.
I'm interested in those classes. I made a custom file class for wrapping fopen. Then I later learned about http://php.net/manual/en/class.splfileobject.php I was mad at myself for not searching first. Now I check php docs then packagist because someone's already solved my problem for me. lol
Yeah and they could even provide a "__php_future__.php" that provides the old version of the functions on php8+ and the new versions on pre-php8. Kinda like how python2 and python3 did.
&gt; You gotta break some eggs... Which most opposition will ask "why?" Yeah, there's some good reasons to switch over, clarity and consistency being chief among them. But then in exchange you have to sacrifice clarity and consistency by coding to be ready for the future and backwards compatible. The PSR works to a point. You can deprecate stuff, and encourage using a newer method. But there are limitations. Take OP's example of `in_array` vs `strstr`. The parameters are "reversed" between needle and haystack. There is no BC-friendly way I can think of to swap the order of parameters for one of those without making an entirely new function and deprecating the function entirely, forcing a BC-breaking change just because "the order felt wrong." You're asking for everything to break compatibility on stable libraries, force updates to every IDE plugin, make all those tutorials and StackOverflow answers obsolete, and undo decades of PHP knowledge just because the order fits a different paradigm. That's even assuming you can pick which one is "right" enough to justify the forced switch, which would be a debate and a half of itself. I completely agree that it would be nice for PHP to have consistency. I don't think introducing PSRs and forcing everyone to sink or swim is the right way to do it. I'd rather see what new paradigm could be introduced in the future that would solve multiple problems at once, not just BC-breaking changes for the sake of "eh, it works a bit better in my head."
Introduce a new function? string_contains?
Seriously. Python is still a mess with the 2 vs 3 thing, and it’s been *over ten years* since it first happened. I’d love a cleaner standard library, but not nearly as much as an unfractured ecosystem. If “scalar object syntax” lands in some form (eg `[3,2,1]-&gt;sort()`) they could clean things up in a non-breaking way. But massive widespread BC for the sake of telling that one stupid article from 2012 to shove it? No thanks. 
Well, I like that solution too
In case of function names, they can simply be aliased and throw a depreciation warning. When it comes to argument position, while I agree that named arguments would be a good solution, it would still require a rewrite of the codebase to use them. Instead, I'd use the fact that the functions with reversed arguments also usually have a naming scheme in need of an update and just create aliases again. When it comes to single-argument function, I'd love to see PHP going more OOP and having arrays (and perhaps even basic types) as objects. ``$array-&gt;find($element)`` vs. ``in_array()`` or ``$string-&gt;length`` vs. ``strlen($string) `` One can hope, one can hope... 
A combination of a flag and a set of aliases with the base function depreciation warnings would be the best solution, I think. 
this thread was about laravel, comparing java and php makes no sense, also, if you're trying to give an example of a php project embracing strong typing etc then laravel is definitely not it.
``` function strstr($haystack, $needle) { return string_in_string($needle, $haystack); } ``` At least some of the problematic functions can be aliased to fix both issues - naming and argument order - at the same time. 
Could you tell me something more about those scalar methods? Tried looking it up, but all I got was "what are scalars in algebra". 
Honestly, it might be worth creating a Github repo for wrappers like those. Then you'd just ``composer require whatever/sanephp`` and done. 
It's entirely because of laravel. It injects *magic* to intercept things that make no sense and remap them to things it thinks make sense. &gt;You should use Model::query() to retrieve a builder object rather than using Model::where() directly. No, you should use $this-&gt;builder in some sort of repository. Static is almost always a very bad idea. Like laravel itself.
Er... have you actually *subscribed* to the mailing list?
For a lot of those proposed changes, it would be quite trivial to write Rector rules to fix them. Not that I agree with such a hard BC break, but tooling does exist to make it easy to migrate.
A few already exist.
Right, I mention that is the only way I think of doing this. But then that has its own problems. For a time, it will pollute the global namespace, which is okay for how much time? It's a major complaint now, so then we would have to have the old `strstr` and the new `string_contains` (or `str_str` or `str_find` or whatnot ... or maybe `in_array` changes to `array_find`...). They would exist at the same time for a whole version or however long until enough people upgrade. Odd growing pains for a 20+ year old language. Second, what if the original name was the better name and you are forced to break consistency just to reorganize function names? Your BC-friendly new function could cause more discrepancy than the original. Especially if we change enough functions just to create new versions with different parameters or naming structures. It's a weird thing to try and adjust a bunch of function simultaneously but without overlapping any existing functions. Not saying these aren't solvable problems, but I don't believe the solutions are all that great for what could be gained. I think it's a little tired for people to beat the horse of "things are messy, they should get fixed by making things messier for a few years" because that isn't much of a solution. Even if it happens, it's met with "Great, now all these books and tutorials and classes and knowledge are completely outdated." Also not a fan of how many people bring up the problem but pass the buck of actually thinking of the intricacies to others to make a PSR, but I understand that's necessary at some point. Again, I want improvements as much as a next person. But more importantly, I don't want bugs to occur just because it feels uncomfortable coding with an IDE or Google to remember global namespace. I much prefer to encourage pulling things out of global namespace or finding other intelligent mechanisms like how Python handled the upgrade from 2.7 to 3 with `__future__`, which still wasn't entirely pretty and required a lot of work.
Every time this comes up, I wonder: but what is the point? You will only cause a regression and your idea of cleaning up will just break things and create more work. And if you don't want to put up with this, it's not like you can create yourself or for your team a library "doing it correct" or whatever. But many idioms have been there for almost 20 years, why is it so important? Yes, I too still struggle sometimes to remember what is the haystack, what the needle. But in reality the IDE autocomplete told me already and in fact I moved on as quick as I would have remember; like 0 friction. I've to say PHP has one of the longest legacy and carries a heavy burden and yet the developers manage to evolve in ways which increases the joy to work with it over years (biggest favourite here being type declarations plus strict types). I think time should better invested to flesh out "the next thing": JIT and better (integrated) concurrency.
Even reordering arguments can be impossible for tooling to fix in pathological cases. Cases involving dynamic invocation of functions by way of `call_user_func`, for example, can be impossible to introspect from a tool.
Good point.
Why not an alias with the proper parameters and naming? It would at least preserve BC. 
Or maybe a new extension with that exposes similar functions with the proposed changes all under a namespace. Could even do this in php code, much like lodash for js. 
The rips tool. The company that makes it scans a couple frameworks with their rips static analysis security tool. That will give you some suggestions.
&gt; Welcome to the PHP Framework Interop Group! We're a group of established PHP projects whose goal is to talk about commonalities between our projects and find ways we can work better together. To encourage interoperability. With multiple solid implementations you can find yourself in a situation where your project uses two packages that require some form of http but require different implementations. You would end up with two implementations that do the same thing. I don’t see _any_ benefit in such a situation.
I think for a long time. Php is the most used language in the web. It is going to be a huge task to migrate every single site to the new style. Even now there is a big portion of the web that runs on php 5.* unfortunately. Personally i also don't like that the native functions are inconsistent, but a rarely use them because of frameworks and my own abstractions for this reason
I’d like to see Fabian and Taylor duke it out with those big sumo suits on
I agree with you that feature completeness is a good thing, but you can still accomplish this via separate packages, right?
No BREAKAGE, get over it and make your god damn function wrapper, as a good motherfucker.
Yep, sadly it's one of those changes that would have had to be cleaned up about 20 years ago. Doing this change now is just so big of a BC Break that it would LITERALLY break every single website on the internet. Meaning: adaption to the new PHP version would be ultra slow and unlikely to happen. You'd then have a mayor part of the internet run on outdated PHP versions because the work required to update would be too big.
Instead that, should be $array-&gt;sort() , $array-&gt;map(foo)
I think we will need to wait till a standard namespace fir functions is settled. This way the old code will work and we will have a new set of functions that has the proper args. 
Whilst I like what you propose I'm afraid of the upcoming BC break. &amp;#x200B; What I would do, I would add primitive type boxing and then we would not need to have core functions changed, they will be just old-procedure-style functions which would be going to fall out of use. &amp;#x200B; And we all will be migrating our code to constructions such as: $x = "string"; $x.getPostion(...); $y = [1, 2, 3]; $y.isIn(5); or even [1, 2, 3].isIn(5); that'd be great, wouldn't it? No BC at all btw
Such a great news, people will be more likely to contribute I hope! I definitively gonna check this out ;)
I disagree with you, but it's 9am on Saturday morning and i've been up since Thursday dealing with a family emergency, and I don't even know what words to use. I'd love to debate it with you though, rain cheque?
that would likely be the solution indeed!
Laravel Collections for arrays, for example.
There should be separate layers, and there should be minimum awareness between each layer. In fact the inner layers (e.g. business/service/domain) shouldn't know about the outer layers (e.g. http). That it to say your business logic shouldn't know it's running in a web application, and it shouldn't be aware of any storage mechanism. This approach is covered here: http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html
Everyone talking about breaking changes, code *could* be upgraded though Know what will be soooo much more confusing though than the inconsistency in function names and arguments? A world where they also change based on what php env you're in and what the code was written for. It's not enough to worry about just the weight of the change, *they would have to coexist* for at least a while and possibly forever
It's usually not a big deal, but if you use a reverse proxy to serve both your app and you push (it's the typical setup when using most cloud platforms), then with HTTP/2 (and HTTP/3) the browser can open only one TCP (or UDP in HTTP/3) connection. With two servers, it means (at least) 2 connections.
Symfony4 and doing new to instantionate with new instead dependency injection?
Well, it’s not a great idea to change function names and signatures just because they feel messy. It will require not just migrating the code to a new version but rewriting a lot of things. If you are a developer and use particular language, it is time to learn function names that you use a lot not assume them. For others just lookup the documentation and use a proper IDE, and this is always the case even with those languages with “proper” naming conventions.
Python 2 versus 3 is something I am currently dealing with at work. Especially painful is making code that runs in both.
This sounds like the best solution, just object everything and add methods on it with proper signatures then in time deprecate the regular functions and stay with the object approach.
I'm sorry to hear that, feel to reply later if you want.
I agree, i dont get the "oh it will break things". JS has done something similar with their es6. We should basically go heres the line ______ going forward from 8 we will now have conisistency. 
Scalars are things like int, bool, and string. I think he is referring to a possible introducing of scalar wrappers, such as $x = new String(“...”)-&gt;indexOf(“abc”) to replace current functions such as “strpos”. 
Why not to deprecate some of these stupid name functions, propose a replacement with a clear pattern. Then delete the deprecates eventually. If someone wasn't able to migrate his code, I guess there will be polyfill on Github anyway.
Subscription is not required to send a mail to the lists, just sending a mail to the list address is enough to get a thread started. To help with this, our mailing list rules require folks to use "reply all" when responding, which means that replies, as well as going to the list, will also go to the thread starter even if they are not subscribed.
I have added the lists' emails addresses to the mailing lists page, to make discovery easier for folks just wanting to mail the lists without subscribing. The changes should start showing up on the page as the website mirrors update themselves over the next hour or so.
Core library consistency comes up frequently on the internals mailing list - one developer has started to maintain a "codex" of frequently discussed changes which includes this topic: https://github.com/Danack/RfcCodex/blob/master/standardise_core_library.md
Sure, but the specific goal of this project was to make Symfony native package that does.
It might be helpful is the list sent a message back when it blocks messages for this reason. I recently sent a reply message to the list and it disappeared. I just assumed it was the mailing list servers being their frequently dodgy selves. After seeing this and checking, it looks like this was the reason.
If your main focus is getting the business up and running, go with a well known ecommerce provider like Shopify. It saves you ton of work, is easy to use and very optimised in what matters most in eCommerce: Generating sales. &amp;#x200B; In case you want to provide a solution for your customer, I'd recommend you to go with Shopware. They provide a great framework and got alot of attention and reputation in the EU in the past few years. So it's easy to sell this to your customer. &amp;#x200B; Regarding Magento and WooCommerce, I'd suggest to stay away from them. Magento has a very steep learning curve. Producing high quality code in its framework takes years of experience. Debugging errors is really painful. It could set you back months from making your first sale. WooCommerce as you probably know is just a Wordpress plugin. It's easy to use but wordpress in itself is a huge in terms of coding dept. If you need a solution for multiple years, don't do WooCommerce. Source: I provide ecommerce services (primarily Magento) for a living.
Very nice to know the "official" notes
BC breaks like function names are not an issue with instant upgrades anymore.
Why don't you just fork PHP if you want to make it completely incompatible will all the code written in it? Seriously, just go fork it and let people switch to your fork it would be much less disruptive to everyone involved.
Scalar methods remove the need to do the wrapping: $x = "hello".toUpperCase(); 
Yes, that would be a good solution. The old, not standardized, procedural way would stay for backwards compatibility, and a new, OOP qqy would follow some naming standards. 
array_map takes multiple arrays as a parameter while array_filter takes an optional function as an argument (defaults to checking for empty()) These two functions won’t change or you’d have to change how the functions work and that won’t happen. Also, Imagine the amount of strpos and in_array in today’s code. Do you want PHP 8 to take like 4 years to be deployed to production the first time? Every single Code base ever would have to be refactored in an annoying way. Better solution (and one you can implement in userland, too!): Use a namespace. PHP could implement a clean standard library under an own SPL namespace and also move all the spl_* and Spl* stuff there. 
Because Guzzle is NIH.
&gt;Just install the framework but don't use it. This is what Laratards actually do.
Please share :)
Exported by the appropriate extension.
IMHO, It is the main complaint against PHP (and the second complaint is about spaghetti code). But in reality, it is a very small issue and we could live with it. For example, the migration of Python from 2 to 3 was painful, Python 3 is not backward compatible with Python 2 and it broke a lot of code, libraries, and other features. Perl too did the same (breaking backward compatibility) and it was a mess, it was its demise. However, I think it is possible to please everybody: What if instead of change string strstr( string $haystack , mixed $needle) to string strstr( **mixed $needle,string $haystack** ) ...we created a new function? string **strstr2**( **mixed $needle,string $haystack** ) 
Or better yet, created a new function that follows a set naming convention, say, snake_case: ``` string string_in_string(mixed $needle, string $haystack) ``` and turned the old function into an alias ``` string strstr( string $haystack, mixed $needle) { return string_in_string($needle, $haystack); } ``` Yes, that would certainly solve the issue and add the ability to deprecate the old functions, one by one, over the span of multiple updates.
Or you could just use docker or vagrant ;)
I think this is indeed the only way at this point. Redefine or alias string/array etc functions in their own namespace. Problem then is also clashing with common 3rd party library namespaces, and extra keystrokes to import them. But I think it would be worth the effort because it allows deprecation of the "old" function call signatures so that they can safely disappear in a future release.
One potential solution that would avoid breaking anywhere near as much existing code is to do the cleanup as part of two other long standing requests: scalar objects and namespaced functions. So, leave the existing global functions and data types exactly as they are for BC. But, for things like `in_array` and `strpos` you could have `Array::indexOf` and `String::indexOf` with class-like implementations. Then, for functions that maybe don’t make sense as a class method, for exactly `bin2hex`, add `\Conversions\binary_to_hex` or something. You could probably argue that method should be a member on a String class but whatever, you get my point. 
I would love native scalar objects in PHP. You could keep the old functions for legacy reasons.
People make the needle/haystack thing into a much bigger deal than it needs to be. In Python, as a PHP developer, I have the same thing in Python's `split` and `join` and you don't even have method visibility in Python. And yet everybody seemingly *loves* Python.
Yes. The problem is that internals don't like to apply aliases, so I don't know... 
&gt; Instead of having mirrors, we are moving all of PHP.net to HTTPS This is the real important one IMO. If having mirrors is what kept them from doing that then they should have ditched mirrors ten years ago.
Some of them haven't used PHP since PHP 4 was a thing.
I agree that the types need to become first order objects and then they can have all of these functions dangling off them as basically aliases.
Seriously. Considering it's 15 or so functions and if a person has such a hardon about consistency they can fix it theirself I would just let it lie.
&gt; but Docker can be complicated for many reasons and one might not be ready to get started with Docker. Getting a simple web-server, mysql-server docker-compose setup is quiet simple. I would argue spending a day or two to familiarize yourself with docker enough to get a project container up and going would be more productive in the long run than knowing how to run multiple PHP versions on a single instance. Additionally, you should be shooting to have your dev environment match prod as close as possible. 
"We slowed down adoption of an entire new language version so that you could remember strpos... errr... str\_pos... err fuck it... easier." It's a trade-off I don't want to make personally and if I need consistency so bad because my OCD flares up I can alias them myself.
&gt;and you don't even have method visibility in Python Honestly didn't know that! Really interesting because visibility is such an important factor once a project reaches a certain size.
There's plenty to criticize in PHP 7.
SOLID, DRY...etc isn't some sort of magic bullet for maintainability &amp; none of them are the one true answer to maintainable code. their principles have to be applied with common sense not blindly.
You say that, but I've spent weeks working on a docker-compose for a simple webserver then abandoned it due to unfixable bugs (iirc, PHP sessions weren't saving, which is a bit of a showstopper for our site). If you know of a good tutorial for doing it "the right way" (rather than just guessing like I did) I'd really appreciate that.
FFS tell us about it here, instead of making us go to git hib to find out it a library for SEO stuff.
Sure. But remember that the frameworks came first. So if you want to develop (for example) a standard request interface, would it not make sense to look at what the existing implementations were doing and try to find a common ground? Something that everyone could agree to follow with perhaps a few minor tweaks? Instead, fig went off into la la land by insisting on immutability. Existing frameworks would have to be completely redeveloped to support this new approach. And maybe it was worth the attempt. Maybe there was something so compelling about immutability that it would be worth the price of rebuilding existing frameworks. But alas no. It's been almost 4 years now since PSR-7 was released. Some packages do use it. But the big guns still have not found a compelling reason to switch. 
Doesn't cover the argument order ones though cause you can't redefine those
Doing it for the sake of doing it is different to doing it for the sake of improving the language 
&gt;Why &gt;= PHP7.1 ? &gt; &gt;Why you are using an old version ? Could've just required `7.2.*` and dropped `7.1.*` altogether (see [supported versions](http://php.net/supported-versions.php)). Have you had a look at [spatie/schema-org](https://github.com/spatie/schema-org) regarding the fluid builder for [schema.org](https://schema.org) types/properties?
Couple of points. With respect to the needle haystack order. Lets imagine that every function was made consistent. Nirvana right? Probably not because you would still have to remember which comes first especially when using the function for the first time after a pause. I for one would still rely on IDE hints no matter how consistent things are. Secondly is this desire for "other people" to make all the decisions and do all the work. Instead writing a post with a few examples, why not do the hard work of generating a comprehensive list of everything that needs to be fixed and what the fix should be. Put that list out there and then somehow get the community to agree on it. Meanwhile, start programming the changes yourself and implementing whatever upgrade process you see fit.
thank you so much! it seems the previous answer was "just subscribe and the list email is sent to you" but of course that advice fails if you dont want to subscribe
Useful as rules of thumb. Deadly to adhere to as some kind of unbending, absolute mathematical principle. 
Then why did they do it with implode/join ? http://php.net/manual/en/function.implode.php &gt; Note: &gt; implode() can, for historical reasons, accept its parameters in either order. For consistency with explode(), however, it may be less confusing to use the documented order of arguments. They could do the same for sort/map. And why do we have strXXX and str_XXX ? Creating aliases and deprecating the "non-consistent" form won't break any code. Especially since the PHP devs take a lot of time to remove things from the language, people will have plenty of time to adapt (think about mysql vs mysqli adoption, it took years for mysqli to become the default, and today people are still using the mysql extension).
Cause the world isn't a perfect logic puzzle, different instances have different requirements, and philosophies change over time.
i was considering writing about the lackluster unit testing in ci ,how it can couse problems further down and was going to contrast that with other framworks like Laravel, do you think that would be a good idea? if so do you have any points i could write about?
This is /r/PHP. You're in the wrong sub
Or a way to overload functions and then provide a shim that can be loaded.
I think you can already overwrite them... But then it's only for your project. 😜
I think this: - They're way, way, way overexposed, and hardly the most significant or well defined way to design good code. They're coined by a single person: Robert Martin, to whom this is a marketing buzzword for selling books and consultancy. - Many of them (except the "L" in SOLID, i.e. LSP) are defined in murky highly subjective terms, which means they're like a Rorschach test. You see whatever you want to see. For example, does something follow SRP or not? Depends on your mood. Technically even the simplest class can be sub-divided into "responsibilities" infinitely. 
they should just move core functions into namespaced classes (e.g. string functions in a String class) with a consistent parameter order. Keep the global functions intact and start campaigning against them (e.g. on [php.net](https://php.net) when ready about strpos, have a big note that its deprecated and point to the class version). By PHP 9 popular projects will switch to using the new versions.
One thing i like to use to get up to speed fast is the site 'pluralsight.com'. It is basically video courses but in good. Costs about 30€ a month but it is really worth it in generall (lots and lots of tutorials for various technologies). Often much better than the default online available tutorials. I learned docker in a day with it
The argument “the frameworks can first” is not really valid as every framework had their own implementation. The choice could have been made to pick one of those, but would have let to the situation where the other frameworks would probably feel done wrong - as proven by Potenciers recent response - and all but one framework would have to implement the new approach. They opted instead to try and do it “right”. Something that is admirable, as it wasn’t the path of least resistance. I personally favor the choice for immutability. I have come across way too many issues that were caused by (accidental) mutability. Since the psr was accepted a majority of the voting members - excluding those that opted not to vote of course - was positive about this psr. My Google skills are letting me down at this moment, so I don’t know what Symfony and other frameworks voted back then. Remember though that php-fig does not only consist of framework maintainers, but also library maintainers. The latter benefit from a single interface as it prevents them from creating all kinds of bridges and adaptors. Something that the frameworks are now resorting to. But in this case a new implementation is introduced that will likely (?) not be backwards compatible. So the question of why not using an existing standard (recommendation) is a valid one. 
This is a little as if you ask "I want a tourguide for Europe".. :)
I'm just trying to see what people would reccomend for a php7 guide as I'm trying to relearn it from the ground up essentially 
It's 2019 and your script offers 2003 SEO tools. Few meta tags (keywords lol), a site map and submitting it to 3 search engines. 
Your php sessions were probably not saving because you didn't specify a data directory that was linked into the container
[removed]
Such an ini option is unpractical. This means you can't use libraries. The only way this would work is if **each** (public) **function** would check the value, set it to the value it needs and on all exit paths (including exceptions)resets it to the caller's value. This is slow and cumbersome. The only way is to slowly migrate to replacement APIs. I.e. for string operations one could create a new unicide-aware string library and have people move slowly from str_foo() there. Key point is that a new API has to bring benefits, else nobody will use them.
Yet only since ~2018 with php-parser we don't have to care about BC.
I agree especially between PHP developers, for some reasons, PHP community tend to over engineer stuff compared to Python or Ruby communities. I personally saw a lot of developers who start to split a simple functionality into a fuzzy architecture (interface with abstract class and inheritance layers) without any clear reason and that kills maintainability over time and increase complexity.
don't tell me these things are mysql_* functions
Backwards compatibility isn’t the issue, it’s “dual compatibility”. You can have code on 7.x that will break on 8.x, but there must be a way for the **same code to run on both**. For example when they changed “indirect access” in 7.0, it meant this code does something different in 5 vs 7: $$foo['bar']['baz'] But you can make it work on both using: ${$foo['bar']['baz']} With a lot of what you’re proposing, it’s not easily possible to do this. If you change the ordering of `in_array` you will now have to wrap every single call to that function in an if clause or custom wrapper function. The function naming changes would be possible since there can be aliases in the stdlib. Incidentally, it would be great if they fixed the ternary operator to work like all other languages when nested. The current version is literally useless. 
looks good. Kudos
In my error logs it calls it an "Undefined function" 😂😂
So if there aren't any weaknesses you'll fail your report? What kind of crap is that
Just for clarity, you shouldn't have been using these functions in PHP 5.6 either. These functions were announced deprecated almost 10 years ago. And PHP 5.6 raises a warning every time you call such a function. Did you notice such errors in your logs?
I'll try and work up an example when i have time with a demo app, so you can see how I currently implement it.
This is now another reason why I wanna learn PHP7 haha 
There would be way too many broken applications. It won't happen... &amp;#x200B; So, now we have to push for PHP to die and to get a new language: PHPx &amp;#x200B; It looks just like PHP, but it has all of the stupidities written out.
I believe what you're looking for is called **scalar types** and currently there is a PHP extension implementing support for such called [Scalar Objects](https://github.com/nikic/scalar_objects)
I think are very useful in the design phase. They make you ask the right questions in order to find the right design path.
&gt; array_map takes multiple arrays as a parameter and it could still do that. whatever is the last parameter would be the function, no?
Just learn to use PDO prepared statements, instead of mysql_functions. https://phpdelusions.net/pdo Everything else would work in PHP7 seamlessly. What you rather need to learn is not some specific PHP7 syntax (there is almost none) but how to write in PHP properly in general. For this purpose make www.phptherightway.com your home page 
should also fix DateTime::ISO8601 - due to a bug, PHP's DateTime::ISO8601 is actually INcompatible with ISO8601, and due to backwards compat, the devs didn't want to fix it.. instead they made a new name, DateTime::ATOM for the real ISO8601...
PHP is moving most of its core stuff to namespaces, maybe this will be rewritten as well?
Yeah, LSP is such a clear requirement I wouldn't mind if it were a straight-up LogicException in the future.
You didn't even get close to what I was saying in my article. And you are in charge of what exactly? Of course using frameworks is good, but for me it's not this particular one. If you are in charge of things, please make sure you improve on your reading skills.
\&gt; use node.js without MongoDB ;) I just wanted to add, off topic, that I worked for a company that used node js with PostgreSQL. Carry on.
Usually attacker that finds vulnerable query and decides to exploit it will try to do the schema mapping of your database by elimination system. For example, imagine you have a query like "SELECT * FROM users WHERE user_id = $userId". If the $userId variable value is fetched from the GET parameter, attacker could do something like setting the GET parameter to "1 AND email = 'sampleemail@example.com'". If the 'email' column of that table is really named 'email', SQL query will run perfectly fine and attacker will confirm name of one column of your table. If it's not named 'email', this sql query will fail and page will return an error and attacker will try another zillion combinations until he guesses the right name. And this can be applied to table names as well and after attacker maps schema of your database that suits his needs he will proceed with planned exploit. Hope I explained it well. Have a nice day :)
DRY in particular is often misunderstood. Many people think it means "code duplication is bad", when it actually refers to *information*, not code.
I know this is just my brain being weird (lol), but I wish they would stop using the whole needle/haystack metaphor, too. I like the search/subject phrasing. Needle and haystack means nothing to my brain for some reason. I always have to stop and consciously think which is which. 🤪 Or, is it just *my* brain? Anyone else have this block, too?
I think there are two reasons for the over-engineering. 1. A backlash against the old days and the fractal of bad design type criticisms. 1. PHP's OOP is more similar to the stricter java/C++ style than it is to ruby/python, so it tends to fall into the same traps.
So what makes it a 'women' thing? Thought coding was for everyone? 
It's not a "women" thing. It's a PHPWomen thing. They're a non-profit and produce their own purple ElePHPant for fundraising, the PHPWomen logo is on the side of it.
What a baby. Coming in here to whine at people 2 days later because they didn't like your article. 
hm my email was bounced it seems you cant post without being subscribed?
Whoops, I saw I posted from the wrong account, sorry. I am not whining. I just think that before calling something "garbage" (which is whining to me, tbh), you should read carefully. Maybe you could explain what you mean by your last paragraph. Anyways, since it seems that I have offended you, I am sorry :) Continue using Laravel, I don't care. But I'd appreciate if you could express yourself in a less insulting manner. I am always up for productive discussion. Also more than 2 days later, if somebody wants that :)
&gt;it seems you cant post without being subscribed? That shouldn't be the case, AFAIK. I do see your email to internals though, so that's a start. 
[https://github.com/nkkollaw/zubr](https://github.com/nkkollaw/zubr)
&gt; [www.phptherightway.com](http://www.phptherightway.com/) I second this website.
its only because i subscribed, posted, then unsubscribed but i would rather not have to do that every time.
* https://php.net/migration70 * https://php.net/migration71 * https://php.net/migration72 * https://php.net/migration73