Thank you. Your explanation is what I needed. I saw definitions but it wasn't really explained in a way I understood. I appreciate the help!
its not required https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#3-namespace-and-use-declarations
I actually was worried there might be enough to id it. 
All of that being said, don't use codeigniter for any new projects. It doesn't represent "modern php" or OOP. Laravel or Symphony would suit you well. Also, I can't recommend https://laracasts.com highly enough. Jeffrey Way can explain even the most complicated subjects with ease.
I know its not required. But i still don't like it.
Generally they don't have one. In C++ you prepend the name of the class with `~` like this: class Foo { public: ~Foo(); // this is the destructor }:
Dude... Commiting or ignoring bower_components is up to you. Bu there are STRONG arguments against not commiting it http://addyosmani.com/blog/checking-in-front-end-dependencies/ 
I couldn't quite tell from your language, but it seems you might think that we are removing them pronto. This is not true; the RFC proposes deprecation for PHP 7 and removal in PHP 8.
Debian testing, Apache 2.4 with mpm_event and PHP-FPM. The reason I'm not using stable is that it's often too old. For example, Debian Wheezy is still on Apache 2.2. Unlike the name of the branch may suggest, testing is stable enough for most purposes. Oh, and it's rolling release ;)
Same. It would be fantastic if this rfc was passed https://wiki.php.net/rfc/nophptags Would allow us to forgo the &lt;?php tag entirely so namespace would just be the first line.
If you told me in an interview that you're an expert, I wouldn't hire you. Even if you are an expert, you wouldn't be a good culture fit for my team. In my experience, the best developers I've worked with and hired have been very humble about their level knowledge. And those that think they're experts aren't.
I should have phrased the title differently actually. I'm looking to see whether people agree this behavior should change or not
You wouldn't be able to do this using PHP. Your best bet would be to use something like [PhantomJS with the Flash player enabled](http://www.ryanbridges.org/2013/05/21/putting-the-flash-back-in-phantomjs/). If you were insistent on using PHP to store the data you could have the user upload via a PHP script and save everything that needed saving and then execute a PhantomJS script with parameters on what video to load in a Flash player or some sorts (or maybe HTML5 but I personally haven't tested that in Phantom) and you can take screenshots as the video plays. As far as 'off the shelf' scripts to do this, you might have difficulty. Good luck.
No one voted at all for it, and the voting ended yesterday..... :/
No, this is not data sanitization, it's hard typecasting. It's not *remotely* the same. htmlentities is for removing html entities from a string. If you don't put a string with html entities into it, you get exactly what you put in back. Aside from that, htmlentites still shouldn't be used to validate your input, which is what this person is doing with intval here. These are things to apply to your input ***after*** it has been validated.
Can also do an MD5 check, but this will only detect **identical** videos.
Not saying you need to call him out on list, but showing your support does massively help. I encourage you to stay involved (and get more involved if that's your thing). :-D
So, mr smart guy, how would **you** validate an integer?
Thank you! :)
i bet your zend diploma is really shiny on the wall :)
10/10 would not hire.
Another of your ideas? :P
Something like this is great to get started out with. Keep up the good work and continue to learn as much as possible. Once you have a solid foundation, you should look into utilizing frameworks to help speed up development. My personal favorite is Yii. As you grow, you'll want to start learning more front-end stuff (it'll be a good marketable skill) and in doing so, you'll want to start weening yourself off of using tables for design.
Interesting read, thanks. I wrongfully assumed that currency formatting was tied to what currency it's in.
Exactly. I am hoping that one day we see a more stronger push with divergence and see hacklang provide features that the php-internals crowd are not able to agree on or can't due to legacy code or supporting earlier versions. I directly benefit from whatever FB are doing. HHVM has been such as gift, it's not even funny. I am happy that they also cater to their own business model rather than coding for the lowest common denominator for that guy who runs crappy wordpress on a $2/mo shared hosting plan. Seriously. HHVM should be enterprise only. If it doesnt pass all tests or doesn't run something obscure, then use PHP. 
&gt;and in my experience there is a very low chance you wouldn't hire me Confirmation Bias.
[php the right way](http://www.phptherightway.com/), [laravel is god](http://laravel.com/) /thread.
Yes, that's right. The idea of a value object is that the original object is never modified, instead a new one is created. 
Don't give yourself a hard time. PHP has evolved a lot in the last few years. PHP-FIG has created PSRs to be aware of, we have composer now, and great engineers like Fabpot and Taylor Otwell are bringing sophisticated design patterns to their frameworks. Plus, we have tools now like PHPSpec that have an entire vernacular to wrap your head around (mocks, stubs, dummies, unit tests, TDD, BDD, etc.). It's a lot to wrap your head around that didn't even exist a few years ago. If you've been in the game for 7 years, you started before most of this stuff was around (for PHP). You can still accomplish pretty much anything today that you could back when you started, the tools just make it faster to do, the design patterns encourage more maintainable/testable code. I've been building pretty funky PHP apps since 2002, and I feel the same way. I've built payroll systems, document management systems (with TCPDF), e-commerce systems with fedex/ups and payment integration ... all kinds of fun complicated stuff ... yet when I approached Laravel for the first time, a lot of the design patterns went right over my head. I felt like an idiot and felt like I was very far behind. I think that's normal for people who feel seemingly confident in their skills when exposed to an entire new batch of stuff they have no clue about. It humbles your ego and that's scary sometimes. Just try to keep learning every day and you'll catch up before you know it. Most of it is pretty easy in retrospect. As the great MMA fighter Nick Diaz once said, "Don't be scared homie."
better than using *OR*: WHERE id IN (3, 4) when more than 2 consecutive id-s, i.e 3,4,5,6,7,8: WHERE id BETWEEN 3 AND 8
Meh, Laravel is interesting, but there a plenty of things about it that you shouldn't take as "the right way" to do PHP.
Posting code would be much more helpful than screenshots. The basic functions appear to be there, but other than that, we cant say much.
Can someone please explain the arguments for and against the `__construct` method? I like them and use them, but I'm probably wrong
Awesome project name!
Ubuntu 14.04/12.04. I always stick with LTS releases. Reasons are mainly same OS for servers and desktop (Ubuntu with Gnome 3 is my choice for work machines) - Debian based and Ubuntu has great support on AWS to boot which is a nice bonus. 
Ok good idea! Sorry ------ &lt;?php session_start(); if(!isset($_SESSION['user_name'])){ header("location: login.php"); } else { ?&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Admin Panel&lt;/title&gt; &lt;link rel="stylesheet" href="admin_style.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="header"&gt; &lt;a href="index.php"&gt; &lt;h1&gt;Admin Panel&lt;/h1&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id="sidebar"&gt; &lt;h2&gt;&lt;a href="logout.php"&gt;Logout&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a href="view_posts.php"&gt;View Posts&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a href="index.php?insert=insert"&gt;New Post&lt;/a&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div id="welcome"&gt; &lt;h1&gt;Welcome &lt;?php echo $_SESSION['user_name']; ?&gt;&lt;/h1&gt; &lt;/div&gt; &lt;?php if(isset($_GET['insert'])){ include("insert_post.php"); } ?&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php } ?&gt; 
The common use case for sessions is to hold data too large, too weird, too structured, too important, or too private to stick in a cookie. Dumping the entire session out as a JSON structure is madness. Somewhere else in your code, something is sticking something with security importance in the session, and now it's possibly exposed. While there's only a slim chance of this leading to an actual security threat, it's still a bad idea.
I prefer Symfony to Laravel, but I wouldn't suggest he learn PHP on it really unless he already knows Java. Laravel is better for learning, IMO. It just shouldn't be presented as "PHP".
If you want to mock objects and write unit test for single class, I recommend you to use AspectMock. It is easy to integrate AspectMock with PHPUnit (and Fuel) and could mock almost any classes and objects.
Hi! Thanks, I forgot to add it, but I have experience with Python, Django, C, C++, R, MatLab, and even Haskell. :)
VMs eat up a lot of space e.g. Vagrant. Even docker images aren't exactly small.
120 is relatively small, in my opinion. It fills up quickly and becomes a major pain in the ass when you constantly need to delete or move data because the drive is full.
You're right, that's a bad example. I was thinking more about PHP extensions (like curl and mysql) which are basically wrappers around C libraries - you don't need to know the ins-and-outs of working with curl in C to make web requests in PHP. (But still, its not a great example.)
Forgot to mension a very important detail I am running debian. have around 20gb used so far.
Yeah 8 dlls more is not bad at all. The laptop will only be running debian. It is just for little projects on the side since it is not my main machine.
Ahh, that's true. I can see where you're coming from.
&gt; 120 is relatively small, in my opinion. That is a pretty safe comment to make. Yes, 120 is relatively small to say, even 121.
I would use debian as main OS. The laptop is just for running some tests/little projects.
Don't start you. 
I guess I'll just ask, how good are you at keeping the secrets secret? That was when I knew I arrived, when I didn't have anyone better to ask questions to. There is still so much more to learn, I know a fraction of the things I wish I knew. What do you know about the technology stack your work lives in?
True!
It is an old xps laptop maxed out at 4gb of ram. It is not my main development machine. I would only use it for code editing/ tests in a debian OS.
&gt; I know I can update an LTS in 2 years, or wait for 5 years This helps me sleep easy at night. I LOVE the LTS versions and the longevity that comes with them. 5 years a seriously long time in server land and I love knowing that any of my 'launch and forget' servers will be nice and secure for about 5 years (as long as I remember to keep them updated, or enable auto updates). 
I'm by no means an expert in PHP, and I'm pretty sure you know more than I do, OP, but I'm pretty decent and I don't believe there's a huge leap from what I know now and what I could know if I seriously commited myself to learn more PHP. I mean, there's a chasm between us and gurus like Fabien Potencier, for example, but among developers, strictly in terms of PHP knowledge, the difference is subtle. Now, don't get me wrong. Besides strict PHP knowledge there are patterns and paradigms that regard metaprogramming and apply transversally to several if not all languages. Having those concepts at hand in your mind, even in pseudocode, can be more valuable than knowing every PDO constant like a lethany. Automation tools to manage dependencies, asset minification and deployments are transversal too. Basic sysadmin knowledge, or at least being capable of installing debian and configuring a LAMP environment. Virtualization (docker or vagrant), security concepts. Data modelling, database optimization, backup policies, continuous integration. I could go on forever. Finally, I believe it's important to know the right tool for each job. If I was interviewing someone for a senior PHP developer position and I asked him to make me an ODM for MongoDB, perhaps I'd consider more valuable the guy who'd say to me "I wouldn't know how to do that, but don't waste your time, there's a Doctrine package already" than the one who would blindly hack to get it done. And I'd consider even better a guy that could tell me "I wouldn't use PHP for that. I'd rather install node and do that with Mongoose". 
How is that different from http://php.net/manual/en/function.parse-url.php
Thanks guys! PHP the right way looks like what I'll be starting off with.
In some SSDs the smaller sizes are also slower; you just have to check the specific drives to see.
Ubuntu 14.04 in most of my machines (plus a couple of debians in Google's Cloud just because Ubuntu wasn't a choice when I instanced them). I'm a long time user of CentOS, but a couple of years ago I grew more and more frustrated with yum. I feel like apt is literally years ahead in terms of stability, integrity and ease of use. 
Does `__invoke` also work internally to a class? Can I do `$filter = $this('this and that');` ? What about calling it from a an extended class? Do we have I have to `parent::__invoke('this and that');` ?
If you were told you need to build a chess piece (let's say a rook), you'd suggest using wood and a carving tool. But you'd also ask for advice, and someone might tell you to buy a lathe. You see, if you really knew your way around building chess pieces, you'd find that a lathe might speed up your work a lot. But if you are at the level of carving stuff, perhaps the learning curve of a lathe is overkill right now. If you don't have a grasp at the concept of MVC, chances are you won't know how to get advantage of a framework. Just like a novice carver won't know how to use a lathe just by looking at it.
lol for what its worth, I don't play chess either
Ah i see
Overloading methods at all would be nice, not just overloading abstract methods.
&gt;commence down voting... ok
He also has a site which looks like it's from 2001 which leads me to believe he writes software like it's 2001. I don't think his concerns are very well founded.
Ah, see that's exactly why I was asking in this thread. I KNEW it was too useful to be unique. Thanks for the insight.
Dunning–Kruger effect
Don't let yourself become stale, first and foremost. Learn something every single day. Expose yourself to new technologies/frameworks/data stores/patterns. Learn about security. Are you proficient with unit testing? If not, learn about that. Integration tests? Caching layers? NoSQL? Behat? Selenium? There are things out there that you aren't familiar with. Find them and learn about them. If you just sit in your MVC world doing the same thing over and over again, the world will pass you by.
How strictly is this conforming to PSR2? Is there a list of what's gonna be ignored? 
No dice :( I also tried disabling opcache completely, along with all other plugins. Only ssh2.ini (which contains only extension=ssh2.so) is causing the headaches.
Could I don't use some shell command with PHP?
There's a whole bunch of them http://www.php-fig.org/psr/ There aren't many others these days. Projects like Zend used to roll their own, but they all just use PSR-2 as style guides now. 
While a good example, I've got to believe Doctrine already has some caching layer plugins.
It supports it. Just a check in preferences. 
It's only considered a constructor if your class is in the global namespace, AFAIK.
Just for using Pimple you hate Slim?
I don't love the idea of a dynamic call to `"func_get_args"` fataling out ... Functions should all behave in the same way. Generally I like the proposal, but I am opposed to special cases like this. Inconsistency is exactly what people lambast PHP for already.
In theory, you'd be correct if `func_get_args` was a real function, but it's *already inconsistent*. It looks like a function, sort of acts like a function, but unlike regular functions, it has its own scoping rules and limitations on where it can be called. If you are really opposed to special cases like this, the solution is to remove them. Since that can't be done due to BC, making sure they are discouraged is the second best thing.
It emmits a warning, not a fatal. Personally, though, this kinda smells more like a strict notice than a warning, but didn't someone just propose retiring all the strict notices?
That would break so many syntax highlighters... you wouldn't be able to know how to highlight it without reading the ini.
I actually *started* doing this after I saw it. I kinda like it. It's the namespace for the whole file, I think it kinda makes sense to open with it, rather than putting it on its own line as though its a line that executes and does something.
Read it again. &gt; Therefore, this RFC also proposes to block `func_get_arg()`, `func_get_args()` from being called dynamically by emitting a fatal error
amen!
ew.
&gt; He also has a site which looks like it's from 2001 which leads me to believe he writes software like it's 2001. Great assumption. Check out his application "framework." He has it behind a login wall, but there's a working login on bugmenot. There don't seem to be any mirrors despite the *entirely unironic* AGPL licensing. Everything's an .inc file, including the classes. Critical functionality seems composed out of simple include files, not functions. Filenames like 'filedownload.php' and 'filedownload2.php'... like 'std.multi1.inc' through 'std.multi6.inc', all variations on a single theme. Singletons, global state, almost no sign of any sort of PHP5 feature use, even in areas of the code that use PHP5-only extensions. No autoloading, instead using lots of `class_exists` checks and doing the requires manually on demand. Use of `addslashes` in SQL escaping. Hand-rolled "encryption" for passwords. The main library is 7000 lines long. The database access abstraction layer is a shade under 9000 weighing in at 375kb. I think I'm going to be safe discarding the opinions of this guy...
I think function parameters should be explicit about allowing an undefined amount of parameters, perhaps through the use of a special value. For instance `function print($namedArg, ...)` would allow any arguments to follow the $namedArg without warnings/errors, while `function print(..., $namedArg)` could be a way to get the value of the last argument while allowing 0-* arguments in front of it. This allows normal use of these functions, IDE support and better documentation. Any other implementation that applies to this RFC would then rightfully give this warning.
Ooooh. Hm. Honestly, I personally have no problem with that, as I'd want to track down anyone performing that level of magic and smash them in the face with a crowbar. I suppose a fatal error would have to do instead of a crowbar to the face, and anyone that disagrees will just have to be happy that I don't have voting rights. :) We have variadics now. There are better ways to deal with functions that can take a variable number of arguments than to perform *obfuscated* dynamic programming.
Well..yeah, okay. If you can just ignore the unit tests while you're working and glance over when you're ready, I guess it doesn't hurt. As long as it's running in parallel and doesn't lock up your PC for a second.
A question mark, in general, is a quantity of "zero or one times" for the previous thing. In this case, it allows the non-capturing group to appear once or not at all. You'd want to include it if you can expect the car to not be new, old or fast, but to just be a car, as demoed in the 3v4l link. Check out visual regex tools like [Debuggex](https://www.debuggex.com/), which can generate things like [this diagram of the regex](https://www.debuggex.com/i/WRuvv_9Lixt3LK0h.png).
Correct, but given that the inner pattern has that final or pipe with nothing after it at the end, `I have a car` -- *two* spaces there, I don't think they'll render correctly inline -- would.
How to enable auto updates to sleep good at night ^^,
We use the symfony 2 standard. I would recommend to chose one that comes with a PHP_CodeSniffer config and can be plugged into your IDE auto format. That makes it way easier to actually enforce it. 
I can only agree with you on the support part. There is so much help to find around the web.
What is Gnome 3 if I may ask noobish :p
Just a question, is `apt-get` user maintained. I mean, can users create packages into `apt-get` or is it only the Ubuntu Team which can release packages into `apt-get`?
Laravel is pretty good for this sort of thing. It does json APIs out of the box and a bunch of filters and stuff you can use easily.
Check out [Apigility](https://apigility.org/).
Isn't it risky to run on a unstable version? EDIT: Ohh, you only do it on testing environments. :D
Am I right if I say that all of these above is Linux based?
What exactly is this `fpaste` which you seem so excited about?
That's true, but wouldn't that eventually become true for everyone else as well? I mean, if hosting providers start offering HHVM and the current [PHP5 incompatibility](https://github.com/facebook/hhvm/labels/php5%20incompatibility) stuff gets reduced to only edge cases, who would need/use PHP? I'm not trolling, I'm generally interested in hearing your opinion as an internals contributor. Because the way I see it, if there are two competing almost-fully-compatible implementations and one of them is always faster / less resource hungry, the weaker one would eventually die off.
I feel this is a good addition - minor overhead sniffing out the use of func_get_args() in function bodies - but any of that will be squashed once using the opcache. So let's do it!
check the year again
&gt; I could be wrong here but the template engine should not really have to know what each variable is for nor should it provide some kind of interface for you. But how should the developer know then? &gt; What happens if a template engine has been set or coded to work with a certain User object from project A and you try and use the template engine for project B which has a different User object. I don't expect them to be copypasta approved, should they? Different user "object", may have different properties/methods, etc. so it wouldn't occur to me to copy them around blindly. &gt; Also, most template engines allow you to set the data globally Yes, a problem I didn't mentioned; to me it's equally to working with global variables when programming -&gt; no one does that. Thanks for sharing!
CentOS for servers, when I was 18 and I first got a dedicated server this what I was given, so I've just kinda kept on using it for 7 years now. Works really well, tends to be very stable and it's well supported. As for desktop, Win 7 with putty to manage the server. Though I have a few virtuals I use to manage my servers occasionally and those will run some variant of ubuntu. Xubuntu/Elementary/Mint, whatever takes my fancy. I have tried using CentOS as a desktop OS before and just couldn't get on with it... Weird.
&gt; This is where documentation plays a massive part ... and then pass the documentation to the front end developer and he/she knows what to do with it. Documentation for views? What would that supposed to be? Some .md files? External documentation? &gt; the end of the day, it is like any class constructor/method or function; you should only be passing what is needed This is how I view them too. The difference, it's accepted and absolutely common practice to document what a constructor/method receives. Why would views be exempt from that? thx
Cheers mate look interesting.
This looks like a very nice RFC, very well done, catches (AFAIK) all possible use-cases of variable arguments (or better: excludes the checking for those cases), even the @ operator, and seems like a good addition especially with variadic arguments - so +1 Nevertheless I think critics will nag on this but as stated in other comments here, the critic will be on variable arguments inconsistency itself and not actually on this proposal. Keep it up!
It would be optional. Opt in. Either by an .ini setting or a new extension. For instance myfile.phpx
Presumably around the time when [5.4 market share](http://w3techs.com/technologies/details/pl-php/5/all) becomes less significant. I massively prefer the short syntax and use it in my own code, but for frameworks I can see why they'd want to preserve backwards compatibility. At least that way developers have the choice.
Require an ORM layer like Eloquent with composer. It would provider the ability to use MySQL, SQLite, MSSQL, Oracle, Postgres etc
Hey guys, Thanks for the thoughts and input on this! It's given me a place to start.
Firstly, follow the [PSRs](http://www.php-fig.org/psr/). [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) is the style guide one but start off by reading [PSR-1](http://www.php-fig.org/psr/psr-1/). There's a few things the PSRs aren't explicit about, so go with [Symfony's code standards](http://symfony.com/doc/current/contributing/code/standards.html), as they're based on the PSRs. Use the [php-cs-fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) to automatically fix as much as possible to start with.
No mention of Zephir?
I'll look at Eloquent. Thank you!
&gt; In theory, you'd be correct if func_get_args was a real function Opinions aren't correct or incorrect. They're just opinions :) However ... `func_get_args` is [just as much a real function](http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_builtin_functions.c#467) as anything else. Just because suboptimal decisions were hacked in to make it work doesn't mean we should pile more on top. &gt; If you are really opposed to special cases like this, the solution is to remove them. Since that can't be done due to BC, making sure they are discouraged is the second best thing. This would be great, but like you say, it can't happen because BC.
Quoting from the RFC: &gt; Therefore, this RFC also proposes to block func_get_arg(), func_get_args() from being called dynamically by emitting a fatal error:
Good, I hate micro-managing tabs for indentation and spaces for alignment.
PHP 5.4 has the short array syntax. Laravel has required PHP 5.4 since v4.2.
Yeah, if you tried to do that, in practice you'd end up writing logging code against every method, or doing some incredibly obtrusive like class FooWithLogging { private $foo; __construct() { $this-&gt;foo = new Foo; } __call($name, $args) { /* enable E_DEPRECATED */ call_user_func_array([$this, 'foo'], $args); /* disable E_DEPRECATED */ } /* similar stuff for get/set */ } I like 'use strict' in javascript, especially when part of a CommonJS-style project. It's incredibly obvious what it means, and you just stick it at the top of your file and everything in it is in strict mode.
&gt; However ... func_get_args is just as much a real function[1] as anything else. My problem is with the "as anything else" bit. Having `ZEND_CALL_INFO(ex) &amp; ZEND_CALL_CODE` in it makes it *unlike* anything else :) &gt; Just because suboptimal decisions were hacked in to make it work doesn't mean we should pile more on top. See, I think making it harder to call this function actually *removes* from that pile. Eventually (and hopefully) we can remove it completely in PHP 8.
your concept (most engines allow you write php): &lt;?php assert(is_array($tags), "$tags must be an array"); ...
As far as *userland* is concerned it behaves exactly the same as any other function. This is the key difference. What it's doing under the hood makes no difference. `func_get_args()` makes no sense outside the scope of another function -- it's an ugly hack, but it's at least a sensible one. Invoking a function dynamically from a string should always work the same way regardless of where and with which function it happens. This is the problem. You shouldn't say "all functions work the same way ... except this one." Doing so is a problem. Always. There's a big difference between a warning because you did something silly (`func_get_args()` in the global scope) and *fataling* out because you did something that's allowed for every other function in the language.
Actually I dont think that repository is the best place to put logic related with saving entity changes. Repository is more a collection rather then facade of database connection or any other storage. You can add new entities to repository (which can register them in UoW) you can also remove them from it (which will also mark them as "to remove" at UoW) but you should not tell repository to "save changes" because its not the responsibility of repository to do it. Saving, editing or removing entities in the specific storage is the job of UoW. The job of repository is to give us collection like interface to access entities and not to deciede when or what should be saved in storage. When you will extract the "saving changes" from repositories into UoW you will find out that is much easier to keep them clean. About the example of using UoW without repository pattern I have no idea to be honest if such thing even exists. 
&gt; In theory, you'd be correct if func_get_args was a real function, but it's already inconsistent. It looks like a function, sort of acts like a function, but unlike regular functions, it has its own scoping rules and limitations on where it can be called. If that's the case, should we consider replacing it with something like a magic constant like `__ARGS__`? A language construct that would have consistent rules?
&gt; Eventually (and hopefully) we can remove it completely in PHP 8. This would be great ... perhaps you could propose an RFC to do just this. In a world with argument unpacking and variadics it really has no reason to exist other than BC.
That is already supported via variadic arguments. See [this](https://www.reddit.com/r/PHP/comments/2wyk6a/php_rfc_strict_argument_count_on_function_calls/covdc91) comment for more info.
You deploy the same OS version on the server, withOUT the Desktop component (which does not include packages that impact an application). I do the same thing... we use Ubuntu 12.04 LTS on our servers (considering an upgrade eventually). I have Ubuntu 14.04 on my desktop (with Unity GUI). I use Vagrant VMs since some projects use older versions of PHP (5.3/.4). 
Have you tried CakePHP 3? You may leverage the knowledge you already have for using cake while at the same time using a modern and flexible codebase.
I can propose it when master becomes PHP 8 in a few years :)
Hate is a strong word. If the actual main app class doesn't even follow the single responsibility principle, then it shows a little naivety.
In laravel, for example, PasswordsController is using ResetsPasswords trait. In that trait, we can see that it checks if (property_exists($this, 'redirectPath')) { return $this-&gt;redirectPath; } And in your PasswordsController if you set protected $redirectPath = '/home' the trait will then use that property from the controller. I guess you can actually use the properties, just do not define it in the trait. Or define it in the trait but not in your controller 
5.5.5 is affected (5.5.5 &lt; 5.5.22). Each set of versions specified is only relevant to the [minor version](http://semver.org/) (5.5.5 was released before 5.4.38, and before the bug was discovered) The bug was [fixed in 5.4.38](http://php.net/ChangeLog-5.php#5.4.38) ([Bug #68942](https://bugs.php.net/bug.php?id=68942)).
Not like this.
That's a good idea and I'll probably do that. Thanks for reading my rant. :)
This is nothing short of impressive. I'm especially interested in the extension generation, which could be immensely helpful in real world scenarios. /u/ircmaxell do you think the docblock requirement will go away if some version of scalar type hints passes?
Hi, Thanks for the reply, i'm not looking to sell it i'm looking to implement it into my website to stop people from uploading songs owned by record companies to my website, so i or the uploader doses't get into trouble. Do you know of any decent scripts that could possible work as i'd like? Jake.
And you can't specify primitive types in PHP at moment either, so that wouldn't be possible.
Yeah i don't think people would opensource them, So what about -&gt; http://echoprint.me/ do you think i could use this to do what i'm trying to achieve? 
seems legit. should definitely work for music-videos. 
https://github.com/thomasbachem/php-short-array-syntax-converter
what part of this could you not do with php.....? 
Lol. Voting ended LAST year. Still not on board the 2015 train yet.
http://php.net/manual/en/function.echo.php Yeah, nothing super wrong with that though
If you need a super robust API, to do multiple output formats, and lots of complexity, this is probably the best answer. For simple API's, i'd say apigility.
Hm, you're not wrong. I feel like the `property_exists` check is a bit ugly, but that's more a personal preference than anything else. I was thinking I might create an `AbstractResourceController` class to implement the accessors through a property, but at that point is it really any different than doing a `property_exists` check in the trait anyway? This makes me wonder if an RFC for abstract properties in PHP7 would be nice.
I'm struggling to understand - does this allow one to leak any information that is outside of the privilege scope of the user running PHP?
&gt; if there are two competing almost-fully-compatible implementations and one of them is always faster / less resource hungry, the weaker one would eventually die off. There are more factors at play than just the raw speed and requirements needed to run. One factor is how hard it is to contribute to one or the other. HHVM does native code generation which brings about complexities not present in the Zend Engine. In general this leads to it being harder to contribute significant code changes, which generally leads to fewer people being able to contribute. I can also configure, build and test PHP in a few minutes. HHVM takes significantly longer to build (some people have reported build times *in days*). This is another factor that makes it difficult to contribute to HHVM. You need powerful hardware and to routinely update and build from source just so your productivity isn't drained by waiting hours to build HHVM. Lastly, people seem kind of eager for one or the other to "win", somehow. There can be room for both a simple, slow engine and a complex, fast one.
Thanks for the response! As far as engine contributions are concerned, you are right. PHP is much more approachable. But that doesn't matter for the end user, as long as the hosting provider installs it (or, if it's a single `apt-get install hhvm` away) the user doesn't care. &gt; Lastly, people seem kind of eager for one or the other to "win", somehow. There can be room for both a simple, slow engine and a complex, fast one. I'm not *eager* for a win/lose scenario but I think, as far as the end user is concerned, it is inevitable in the long term. Personally, the one big, *massive* problem with HHVM is that it's owned and governed by a corporate entity, so it's not a democracy (you can't just merge a patch with 66% support from committers). If Facebook ever starts a foundation (as Anthony [suggested](https://www.reddit.com/r/PHP/comments/2w12sf/to_all_php_internals_devs_or_php_userland_devs/comn7lu)) that problem would go away as well.
&gt; Ive been told about this http://echoprint.me/[1] but I don't really understand it. echoprint.me is a C++ program. You'll need to [download and compile it](http://echoprint.me/start#identify) or find an existing binary. &gt; Admin uploads song -&gt; Algo / Script breaks it down ready for another script to match it When you've created an executable out of the echoprint code, you can run the program using exec or some other system call function in PHP. That's how you'll create a "fingerprint". Then you can take the output and put it in a DB to check against. &gt; -&gt; Make the script smart enough to allow cover songs just not the original from a CD or from a youtube mp3 download. (I understand some will get through but we can manually remove them) This is up to echoprint to implement. You're using them to do the actual matching, so it depends on what it's capable of. &gt; -&gt; allow the script to get smarter and better but make it a standalone product If you're relying on echoprint, you aren't going to be able to do this. All you would be selling is a wrapper around echoprint. As others have said, you really shouldn't do that, unless you develop you're own song matching algorithm (which is non-trivial). &gt; -&gt; Stop and refuse the audio upload if there is a match and explain why. Again, the song comparison would be done with system calls to the echoprint command line app. Interacting with the user is done with PHP.
https://gist.github.com/tmm08a/66810644f89f293a7b8b#file-determineendianness Are those lines supposed to be terminated or is that a bad copy/paste job? 
I heard 2008 was a nice year
lol why do you think I was all like, "Hey bro, maybe *you* could RFC this?"
The contents of the PHP binary were probably accessible anyways, no? Also, if one is using php-fpm the mod_ssl thing shouldn't matter but I can understand that being an issue. Seems like an Apache security issue, though, if modules can read each others' memory. Accessing PHP symbols and module information doesn't seem like a security problem.
I'll second CentOS. It's strengths as a server OS: 1. **Security**. SELinux works great pretty much out of the box. I usually have to write a trivial custom module here and there, but that's acceptable to me. SELinux on Debian/Ubuntu, in my experience, is a complete undocumented and broken mess. The US Department of Defense runs RHEL on all their servers, and I can tell you from experience those guys take netsec seriously. 1. **Long term support**. I run CentOS 7 and I feel comfy knowing that it'll be supported until **[2024](http://wiki.centos.org/Download)**. 1. **Stability**. Like Debian stable and Ubuntu LTS, CentOS/RHEL are targeted at customers that don't want things to suddenly and mysteriously break. Of course, you still get security patches as they're available. 1. **Documentation**. RHEL has, IMHO, some of the best [publicly-available documentation](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/) for any Linux distro. Any sysadmin task you can imagine, they have a section in the docs on it.
thats not a good reason to write the internal code in array()
Fair enough. This should probably be proposed by someone who has never even *read* the list :)
thanks :)
One minor point: all projects in the blog post work off of normal PHP code. Zephir is a different language entirely (requiring existing code to be rewritten). So not exactly apples-to-oranges...
&gt; Or are you referring to when working with multiple people on 1 project, and consequently a designer starts working with the templates, not knowing the data formats? Yes, this is my main concern area. The (backend) developer obviously knows the models and such, has a nice API, designed the Entities, etc. Now the frontend guy receives what? A bunch of arrays? That's not really fair. But I'm not saying "dumb frontend guy", TBH this also concerns me when I write the templates. When I've nice e.g. doctrine models, great getters, I certainly don't want to loose this information in the view what kind of Entities they are. IMHO I still want my type hint and autocomplete, why would I want to give that up?
Both Symfony 2 and Zend Framework 2 have excellent Config components: http://symfony.com/doc/current/components/config/introduction.html http://zf2.readthedocs.org/en/latest/modules/zend.config.introduction.html I can understand why people want to make their own (learning experience?). Adding it to League? Why? Personally I think League should be reserved for components that are not part of popular frameworks. I.e. by just adding any other component to League for which there are industry wide accepted versions available, does seem like adding clutter to League. 
Perhaps I am reading the article incorrectly, but from what I gather, this goes beyond just dumping memory contents and goes as far as allowing for remote code execution. Which, as the author seems to hint at, one could use to do things like dump SSL keys or take control of the PHP interpreter.
True, I wouldn't dispute that. But that presumably requires you to be able to pass input directly into unserialize(). I struggle to fathom a situation where this might occur in production code. I'm not disputing that it's something that should be fixed. I'm just disputing that it's a substantial attack vector.
**Question 1:** For small projects, I typically use a pair of PHP files, like `package-root/setup/config.default.php` and `package-root/setup/config.php`, with the latter excluded from version control. I then load the config via a bootstrap file. For example: &lt;?php require_once '../vendor/autoload.php'; if( is_file(__DIR__ . '/config.php') ) { $config = require('config.php'); } else { $config = require('config.default.php'); } **Question 2:** I'd prefer a solution that lets me conveniently merge the regular and default config and gracefully handle cases where the second file doesn't exist. If that was implemented I'd switch to this package in a heartbeat.
Example for question 2: require_once('../vendor/autoload.php'); $config = Config::loadOne('config.default.php', 'config.php'); (formatting wasn't working in my original comment)
That's quite interesting ... I'll add it to the to-do list EDIT: Sorry, I saw the reply on the mailing list and went off to read that first. Right now, if you include the path of a file that doesn't exist, then it will throw a `FileNotFoundException`. That could easily be fixed, maybe you could prefix the path with ? and if it's not found then all's cool? Sound good? Code would be more like: ``` $c = new Config( 'config.default.php', '?config.php' ); ```
I agree it doesn't make sense to have in the League components that reimplement existing stuff… It should be about collaboration and reuse instead of yet another ZF/Laravel/Symfony that rebuilds everything (or most of the things) from scratch.
I don't run my development server through SSL/TLS either, but I do in production. Because: 1) There are other servers in-between development and prod: dev, qa, staging. 2) The built-in server is fine for development. 3) I hate messing with vhosts and all that nonsense in a development environment.
What ? Mongo cant store php associative arrays. It stores them as objects and I'd like to retrieve them as such
Great minds think alike Phil. 
In general I'd agree. But if an author actually recommends against his own code, I'm reading that as "I've given up", and there are questions about how viable the project would suddenly get because one person contributed a PR.
Thanks for replying! Somebody opened an issue (possibly from your comment), so that's definitely happening. We felt that writing back to files was out of scope for what we wanted. Also cheers for pointing out the piwik library, it's awesome! I'm still in the process of writing a response to the replies on the thread, which will be more detailed (I'll probably post it here, too). The gist of it is, the other packages we've used seem to be a bit complicated, when we just want to get going.
God help us all. Why is anyone still referring to PHPClasses? This must be /r/phpfunny.
From just looking at the template, no. But that's the case for a lot of PHP code. In the code that calls the template it's generally clear what the variables are (and where it isn't you can add comments). You could still have comments in the template like you describe, maybe they get out of sync with your calling code but it's useful to have a reminder there instead of needing to switch files. But I don't see any advantage in forcing that.
Could we try to keep it civil, please? I've been giving you the benefit of the doubt, but much more of this and I won't be able to.
seriously. how do this people find the time to do this awesome stuff. I want to be in the /u/ircmaxell inner circle to see if i can become half the developers they are
You clearly have no idea what you are talking about. When you use json_decode for example you have an option to serialize json objects to php objects. I wany same for serializing mongo data. Anyway I have already asked the devs and they said this will be inclused in the next version
Hey!!! I posted this just yesterday I think!! PHP 5.6: http://www.permamarks.net/mandelbrot.php Time: 2421.9489097595 ms HHVM 3.6: http://www.hhvm.rocks/mandelbrot.php Time: 330.10681915283 ms Be sure to reduce your browser font to ultra tiny to be able to see the ASCII art!
&gt; So what are the non-technical benefits? &gt; &gt; Adding these functions to PHP may give them more legitimacy. &gt; &gt; Adding the functions to PHP perhaps give them a broader audience and more visibility. Adding them to PHP core allows PHP to upgrade the usage of password_hash and no one needs to do anything to benefit from it. If you're a good developer and using the suggested PASSWORD_DEFAULT with a varchar(255) column for the password, then when bcrypt isn't sufficient or when we get a better algo, you get the free upgrade when PASSWORD_DEFAULT points at the new method. You also need to be a good PHP developer and use password_needs_rehash as well, but doing it right with these new functions is much easier when they're core, as *everyone* has them (once we drop less than 5.4 from existence).
How do any of those points not apply to a pure PHP solution? &gt; no one needs to do anything to benefit from it. Except installing or upgrading PHP, which is harder for most people than updating a pure PHP package.
I like your attitude. Keep on truckn
I like everything except the lack of write support, and for some reason the php config format makes me feel unhappy.. I can't explain why but I feel it lacks structure being a function that returns. I don't know what the best alternative would be, so I guess I can't complain much; but it's something that rubs me the wrong way.. Our current php configs use a variable that defines the group of the config items, so possibly something that could ride that wave. Looks good though, if not a little overly complex supporting all those config types; but I likely would have done the same myself if I was the author.... Soooo..
I agree with your points, but I believe the language should solve the common problems of it's domain. Password authentication is a common problem with in the domain of web page development, which I would say is php's domain.
&gt; Be sure to reduce your browser font to ultra tiny to be able to see the ASCII art! CSS, use it!
Password hashing written as a PHP library instead of a C library does not preclude it from being part of PHP as a whole.
This year brought new vibes, bird sounds, and hope
If there was ever any doubt regarding this, [this vulnerability](http://blog.sucuri.net/2015/02/security-advisory-wp-slimstat-3-9-5-and-lower.html) only just cropped up because people didn't see a better way of getting random data.
You would echo it along with the rest of the variables. Example: TEST COMMENT TEXT test username &lt;a href="report.php?id=COMMENT_ID_GOES_HERE"&gt;Report this comment&lt;/a&gt; If it's all echoed at the same time then the proper id will remain with the associated comment. 
&gt;there are significant benefits to do it in PHP, such as performance. Wait, is he arguing that crypto code written in pure PHP has a performance advantage over C?
&gt; How do any of those points not apply to a pure PHP solution? PHP gets upgraded (by my host, by my admins, etc) and don't upgrade the PHP-implementation, I don't get benefit. Code, once released, has a habit of sticking around for a long long time. Someone will bundle an older pure PHP version of it and it'll affect people from the older PHP versions right up to the newer ones. &gt; Except installing or upgrading PHP, which is harder for most people than updating a pure PHP package. "Most people" = "anyone on shared hosting". That said, when the host upgrades, everyone benefits, even if someone wasn't planning on upgrading their bundled PHP-only solution (see point above). The major advantage of this being core is that anyone using 5.4 or higher has the code. This means that anyone who upgrades to a future version that changes the default aglo gains the benefit as long as their code was targeting at least 5.4. The speed improvements of PHP 7 look to be a massive draw for hosts (less CPU and memory usage = more people on a single box = more profit). Plus with a "Go PHP 7!" effort uptake of newer PHP versions could be dramatic.
How do I find the time? I don't. Which is why I haven't had the time to get what I want to get done with it done ;-). &gt; I want to be in the /u/ircmaxell inner circle to see if i can become half the developers they are I am always accepting applications for minions^H^H^H^H^H... ;-) In all seriousness, check out phpmentoring.org and #phpmentoring on Freenode
Pop into IRC then and chat it up. Many people idle in there (me included). Come in and say hi some time :-D
For long polling, its ok to block the process, thats kind of the idea, but do be careful. Also, be careful setting a low sleep count, as you can slam your database. Throw a `debugger` statement inside the `success` to see whats happening in there.
From the documentation changelog Recommend PHP 5.4 or newer to be used https://github.com/bcit-ci/CodeIgniter/commit/fe9309d22c1b088f5363954d6dac013c8c955894
yii2 uses two validations, javascript and php. if you put a field wrong and hit 'send' the js should show you an error. does it happen that way?
It also supports a PHP file that just returns an array, which is what I use for all of my configuration anyway. Just use that instead.
Downloaded 189 times this week. Yay!
I absolutely see the advantage. If you change the perspective and view a template like a function (mentally) it becomes clear. The comments/phpdoc could serve as a requirement and before"calling" the template the passed variables are matched with the phpdoc. If not, hard error follows. That way you can never forget to pass a required var or a wrong type. It's a contract for both sides actually. The backend dev knows what to deliver to the view. The Frontend dev knows what he receives. If the backend what to add/change things, the contract must be updated otherwise the system won't proceed and error out instead.
Open Sans.... god damnit... Am I the only one that finds it ironic that Open Sans (available through Google Web fonts) is borderline unreadable on Google Chrome in Windows? http://i.imgur.com/8NA16iU.png Firefox doesn't have this issue. Neither does IE. Just Google Chrome...
Finally an RFC proposing a feature I might actually use. I'm totally behind this, I can see lots of real world uses for this.
&gt; The only sane way to write templates is to write HTML, and embed the PHP. To embed the PHP, it means you need to either include() the HTML template file, or include() the data source to be used in the templates. Thus the template file can never really have any control over how the variables it depends on, are supplied (the way a function definition can explicitly call out the arguments, and then internalize the parameters). To a certain extent I agree with you. But: &gt; Thus the template file can never really have any control over how the variables it depends on, are supplied But that's an implementation detail of the "template/view engine" or whatever. As today almost everyone is using an array of key =&gt; values of certain depth to pass around all that data. The template/view engine knows about what it received form the action and knows (itself or told from the framework) what template to display. At that point, it usually pre-processes the template before passing the vars (pre-compilation and stuff). At that point, if a PHPDOC block is present, it could also parse that and verify that the variable types match. About the narrowness of the use case: I'm not sure. The last big project I worked on hat &gt; 600 individual template files. Think about that. Six hundred. And I bet I'm actually in the lower segment of a scale what a "really big" project constitutes. How are you going to document this? Outside, separate documentation? IMHO doomed for failure. That's only solvable if the requirements for any given template are right there in the template. The contract by which you call it, what it requires to render itself and/or subsequent templates.
What part of that isn't simple? My point is that you can have simple scripts where the built-in server is completely appropriate.
i wonder if this could be used to enhance the solver in composer. that'd be a big win for everyone.
And, in theory, if PHP gets generics then we won't even require docblocks for things like `int[]`.
&gt; require / include I found that out the hard way, trying to diagnose a big procedural ball of mud. IIRC I was using the runkit extension, and since they aren't real functions you can't redefine/wrap them to log their runtime arguments and behavior. I ended up running the code a few ways with XDebug tracing instead, and then using some scripts to mine the trace-files.
True, but IMO you *should* use it like a function. It looks more consistent, it reduces the scope for certain kinds of surprises or bugs, and it makes it much easier to search or replace usages with something else later.
I'm going to use it for all my projects from now on :-P
&gt; The release schedule is tied to the release schedule of PHP. Lots of people can't or won't update their PHP, so if a vulnerability or bug is introduced in the functions, they have no easy option to upgrade. Regarding to security issues, the release schedule is actually (at least most of the time) tied to the security updates provided by the OS. Which is huge plus. &gt; I'd argue that it's easier to introduce buggy code in unmanaged languages such as C, as opposed to PHP. I agree with this, but given the security effort put on planning and implementing password_ functions, I think it is reasonable to say those functions are made "security first", which is the only meaningful way to introduce such security related features.
This is something PHP has been lacking too long. About the implementation, I'd drop arc4random_buf and arandom stuff and just go with "the standard" urandom (as it is the universal UNIX-like way and will be OK even on Linux in PHP's case).
 echo("foo") . "bar";
Yeah, don't do that.
You could do the matching based on the band, the genre, the user feedback (from sites like http://www.allmusic.com/), etc. It would be a first step before the one you describe.
So, two mistakes. Or do you agree with him that the user should be changing their browser's font to view it?
Still, they are supporting PHP 5.2 which means that some advanced PHP features and practices since PHP 5.3 or 5.4 cannot be seen in CodeIgniter's source code, including the now almost standard namespace. The minimum support version is a more useful attribute here than recommended version, since the former is a limiting factor while the latter is just a recommendation that can be changed anytime without touching the source code. Either way, my point stands that CodeIgniter's supporting PHP 5.2 is vastly irresponsible and incompetent.
Use sessions
phpbb or invision power board are decent places to start.
I'd rather it support better (no file-descriptor exhaustion issues) methods (arc4random_buf, getentropy, etc) if they're available and fall back to urandom if there are none.
Don't put that in the session and definitely don't create a global variable for that. Both of these solutions make unit testing a pain and they are definitely an antipattern. I'd create a helper class that wraps this logic. Inevitably you're going to want other date related information and having this in a centralized location that is easy to unit test will make your life much simpler.
 I think that's what I was looking for, thank you.
To expand on /u/anlutro's comment, the reason that you want to avoid global variables (like the plague) is because variables can be changed, and if they are global then that change can happen anywhere at any time, and often cause unintended consequences. Using a constant means that after setting the initial value, the state of the constant (as hinted at by its name) cannot be changed, and so you can always rely on that value no matter where in your application you are. Also, for simple stuff like date() that is an inexpensive operation (the expense in this case is the CPU time it takes to run the function from beginning to end), don't worry so much about defining it once. It's okay to do so, don't get me wrong, but keep in mind that there may be circumstances where you need to display the date differently for different reasons. One example might be a database table that uses a different format. If this happens, then instead of storing an already-formatted date, you could simply store a UNIX timestamp (time()) and then simply format it as you need to, when you need to display it. Granted, this is entirely contrived, but is meant to be an example to get you thinking of different ways of doing things. But generally, you want to do something like this for those expensive operations that would take many seconds/minutes to compute but that won't need to be changed very often - this is referred to as [caching](http://en.wikipedia.org/wiki/Cache_(computing\)). As a new PHP programmer, I would strongly recommend reading up on the three main ways to program†: [functional](http://en.wikipedia.org/wiki/Functional_programming), [procedural programming](http://en.wikipedia.org/wiki/Procedural_programming), and everybody's favorite, [object-oriented programming](http://en.wikipedia.org/wiki/Object-oriented_programming). Decide for yourself after some research which style would fit you best, and focus on honing those skills within the scope of PHP. † I am presenting the methodologies not to tout one over the other, but to introduce you to something you may or may not already be aware of in programming. I am an object-oriented programmer myself, but that was a personal/professional choice that I made for myself many years ago. Edit: added note about caching.
you dont mean.. like a \*cough\* [*Route*r](https://github.com/thephpleague/route)?
Ironically the [documentation on the compat lib](https://github.com/ircmaxell/password_compat) has the correct usage of password_needs_rehash: if (password_verify($password, $hash)) { if (password_needs_rehash($hash, $algorithm, $options)) { $hash = password_hash($password, $algorithm, $options); /* Store new hash in db */ } } It's that simple.
Because you actually want to use PHP. You do realise HHVM isn't a drop-in replacement for PHP right? There's still quite a bit of the language that hasn't been, or will never be, implemented.
&gt; \0\0\0\0\0 Oh boy.
Unfortunately, I'm not taking on any Apprentices at this time. I simply don't have the time to devote to it to be fair to the other person. Again, with that said, come talk in the IRC room. If you get to know people, a good match can likely be found.
Actually, if someone wants to build a back-end targetting HHVM's extension API (just like I built a PECL backend), then you could have the best of both worlds. That's why this isn't integrated into PHP. It's designed to be integrated into any existing runtime.
Currently, classes aren't supported (only functions). I've been working on it, it just requires a very significant amount of work to support. And finding time for it is non-trivial with everything else I have going on. I do intend to do it though.
Why aren't we just writing websites in Assembly?
MyBB is ok
Nice, didn't realise it was that simple. I like how the there's no effect on the UX at all!
[/r/lolphp](http://www.reddit.com/r/lolphp)
... to be fair, it's pretty bad. But it does work I suppose, and it looks nice.
It's the only forum software I've used that makes any decent use of ajax. I mean, it's **2015**, dammit, why am I still hitting refresh just to get an updated post count?
Maybe they should get a valid SSL certificate first
Those are excellent points. It never hurts to know about other paradigms, but depending on what you (any developer) wants out of programming may or may not necessitate needing to be well versed in more than one. Also, know that with Javascript it is object-oriented, but differently than some other object-oriented languages (i.e., PHP). PHP uses a class-based object-oriented approach, while Javascript uses a prototype-based approach. For the former, you make your changes to code and then run the code. For the latter, you can do the former, but more importantly, you can also do it at run time - and in such a way that can modify the underlying Javascript framework. Prototype-based object-oriented programming can be very powerful, especially since you can change objects at run time. Feel free to checkout Mozilla's [documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).
Thank you all for your answers! I have self learned PHP as my first language without any books or classes or anything. I'll read your links, dohpaz42, and I'll see if I can find some more free stuff out there and take some steps forward in my learning!
Two signs it's written by a php n00b. - there is a closing php tag - no spaces before the {
&gt; there is a closing php tag Funny story. I have since dropped the practice, but there was a time that I thought, and enforced, that if you are too stupid to be able to detect invisible characters after the closing tag then your code sucks. Omitting the closing tag is a technique used to prevent problems that shouldn't be there in the first place. Suffice to say I gave up on my crusade.
Don't make fun of phpclasses.org, [it has 1.3 million users!](https://www.youtube.com/watch?v=0ktiTRwd-pg)
Yeah, I incorrectly used the term "ajax" in this case. Presumably any decent solution would use something like [Pusher](https://pusher.com/) or Web Sockets, not ajax-based polling.
If you have a few bucks to spend and want to avoid some of the hassles, you might want to try [Vanilla Forums](http://vanillaforums.com/), it's in PHP but their cloud platform they do the heavy lifting Or, [Invision Power Board](http://www.invisionpower.com/apps/board/). Same kind of cloud offering.
I know it was submitted quite a while ago. It's a shame nothing has come from it!
I have to agree. Also it seems like a lot of people have been using this subreddit to forward their own projects and smear others which is really something I don't like to see. I want community vetting not self-promotion.
The last commit to master was 2 months ago. I have been working on-and-off on getting classes to compile as well in a separate branch (locally mostly). But yes, it mostly is due to time constraints. The compiler work isn't something you can bang on for a few minutes here and there. It's something that simply requires a lot of time to sit down and work in a shot (so many moving parts). And lately I haven't had time like that.
Yeah the guy who wrote the article suggested that, and it seems like it makes Elastica a lot easier to work with. Originally I was aiming for the official client, but with the bundle it seems like a better fit.
&gt; Why wouldn't it be practical? Simply because I think it's too much overhead for the goal and a more practical solution is to have the data inside the template. Because a frontend guy only needs to look at the template to know what he has got and not be concerned about "view model" classes.
This sounds familiar to me from a lot of other languages or API's in general! I like it! However, PHP returns -1 way too often as an "error" return value (instead of null or false or - if we may dream &amp; pray - an exception, because in case the - valid - return value is 0 an a developer still uses weak comparison and gets `0 == false` but `-1 != false`) which *may* leads some hard to detect BC breaks and edge cases!
I would think it would HAVE to be the former for backwards compatibility. If you want the latter, then just use array_unshift().
Since I started using composer and just using the symfony components I need per-project, I haven't given a shit about individual frameworks.
Personally I don't think this is a good candidate for a League package because it's not really adding much functionality for the typical use case for stand-alone packages (ie use in end applications). The ability to parse configs in multiple formats is something that a framework obviously needs (since end users of the framework may want to choose different formats), but is of less value to me as a (non-framework) application dev because I simply choose my preferred format (personally YAML) and use that for configs. Using a package like this over simply calling Symfony's YamlParser (or XMLReader, etc etc) directly doesn't seem to offer me any benefits. Of course, maybe there's other use cases here I'm not considering.
You're probably right, but with the former you've made PHP arrays even more complicated than they already are. You'd need a rule like "$array[-1] yields the last element of an array unless -1 has been assigned as an array index, in which case it yields the value explicitly stored at that index". A lot of code would break in either case: $array = ['bob', 'carol']; echo (isset($array[-1])) ? 'set' : 'not set'; And most of those breaks would also be tricky runtime breaks. My least favorite thing about PHP is the mixture of dictionaries and lists into the "array" data type.
I think that is 495 pages of packages that either have the name Symfony or Bundle in it. And then, so what? 
Some really great options have been posted here, thank you guy a lot. I will go through all of them and see what fits my needs the most! I gave everyone an upvote. 
Hey Phil, just thinking about this a bit more. Not sure if this is already covered somewhere and I'm not to familiar with League's policies etc. But maybe a good rule of thumb would be (without intentionally being arrogant), you don't submit packages to League, you should be invited instead. Maybe that will make the submission/acceptance process easier? 
eridal: who gives a shit
If you're running on a UNIX-based system, most of them should allow you to run the script through strace or gdb or something like that. I haven't used gdb much, but I have looked at PHP scripts through strace. It shows you the system calls that are made - really gives you some insights into what it does. For instance, I found that running date_default_timezone_get() results in hundreds of hits to the filesystem as it checks all the zoneinfo files.
I'd assume that negative indices only work for accessing data, not setting. If you're setting, then the actual key would be literal.
They address this in somewhere by using something like: echo $array[:-1]; 
That's because it isn't finished yet
That is a really good point, thank you!
Personally I'm a fan of [SMF](http://www.simplemachines.org/), I've used PHPBB, found it to be coded somewhat weird, not bad mind you just oddly which made modding it more of a hassle than it should have been. Vanilla2 was good for a quick forum but I didn't care for the layout much. MyBB is actually pretty good but very basic (*not a bad thing if basic is what you're going for*) I just needed more features and SMF has some built in SSI that made it really easy to integrate into a website.
That also has a meaning in languages with actual arrays. Namely, you'd expect it to return all elements of the array except the last one.
According to the document, it would be the first for associated arrays, and the second for numerical arrays.
That's no different than it is today - does `$array[2]` return the 3rd element, or an element named `2`? You just have to know what kind of array you are working with.
PHP loads and parses the file, then starts executing it. The same goes for every file you require/include. The error you mentioned occurred because syntax errors are fatal so the whole execution halts when PHP can't parse a file. Starting from 5.5, PHP comes with [OPcache](http://php.net/manual/en/intro.opcache.php) that stores *precompiled script bytecode in shared memory, thereby removing the need for PHP to load and parse scripts on each request*, which improves performance. Prior to this version, the APC extension was a common alternative. Other than this cache, PHP itself *shares nothing* from your code between requests. So what you say about "keeping a reference for all members in a class" is true for the scope of each request. Classes are defined on each request when the code defining them is executed, and keep defined until the end of each request. Objects exist from the point they are instantiated to the point when the [garbage collector](http://php.net/gc) identifies they're no longer needed; longest case scenario, they're destructed and freed from memory at the end of each request. That's pretty much it without going very deep. Does it answer you?
For strings it makes sense and I would really want to see it. For arrays I can already see a ton of problems as current code sometimes rely on negative indexes being real indexes.
I think a better title for this would have been "The problem that password_hash() makes apparent."
I think your right, thanks
I'm so confused. What is this supposed to be for?
Well, except for the fact that it's more secure to write in C. C has access to native `fopen()` while PHP has to go through the streams layer. Meaning core can access a RNG directly, whereas PHP needs to go through an abstraction layer. One that could theoretically be backdoored. Crypto and Randomness should be kept in C as much as possible. This particular case is one right on the line, just barely doing enough IMHO to justify being in C.
Don't underestimate logins and registrations. There are millions of ways to screw this up. The new password_hash() API is very nice, but it doesn't provide anything new that didn't exist before. And securely hashing and storing the passwords is only a very small part of the whole process. Don't forget rate-limiting (brute-force protection), session hijacking, password reset, password rules, event logging (user notification), etc... I suggest you to read up on the whole subject before you start coding. PHP 5.5 helps a little, but it's hardly the key here.
In any given array, $array[2] can only return one specific element, the one at index 2. $array[-2] is ambiguous for some arrays and you have to be aware of extra rules to resolve that ambiguity $a=[-1=&gt;1,2,3,4] is a valid array literal. What would $a[-1] evaluate to?
I'm glad nothing has come from it. It's ridiculous. -1 is a valid array key. This RFC doesn't say at all how it would handle that being the case.
Hydration is the process of "filling out" an object structure with data. For example, you have a model like so: class person { public $name; public $age; public $job; } $john = new person(); Hydrating the object '$john' would fill out one or more of those variables (like with data from your database). // Hydrate John's name $john-&gt;name = 'John Smith'
Yep this is exactly it.
Yes it does say. If the array has -1 then it is an assoc array - and this code would not have any affect. It's only for numerical arrays.
It means your database connection requires the correct username/password.
I don't know how you set up your webserver. If it's not set up properly, try username 'root', no password. Otherwise, ask your webhost / whoever sets up your MySQL server. 
I'm running locally through wamp. In the book he uses the command mysql which gave him an error. When I did it there was no error. I went back and used the command mysql -u root and it worked, thanks
I think questions like this should go into this subreddit: http://www.reddit.com/r/phphelp Note this one is not a support subreddit, newbish questions should be posted somewhere else. 
I just made my first functioning registration/login system today, and these are all features I aim to implement straight away. Any advice or resources on these specifically? A lot of online resources appear to be pretty dated. I'm not saying they're not right, just seems like there's no amazing modern website that walks you through it. I've found the PHP Docs to be useful, but only if you find out the name of the function first. 
&gt;Simply because I think it's too much overhead for the goal and a more practical solution is to have the data inside the template. It does add overhead to be sure, but the front end guys don't need to worry about the view model classes themselves, the tooling exposes what they can/can't work with as properties off the model. 
I have no experience with large scale applications, sorry.
Yup http://www.phpclasses.org/browse/statistics/statistics.html#user-count Sad trombone.
http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html#query-result-formats Hydration appears to be the way in which one can choose the form of data which is the result of a query.
http://pastebin.com/A70PTUBf Appreciate it, I am just sort of doing this as a learning exercise for PHP. I am well out of school.
I suppose the part I am stuck on is importing text from a .txt that scans it line by line. Would I do an array like the other commentors suggested?
you may also find http://www.phpinternalsbook.com an interesting read if you want to dig further.
Don't they require you to log in to download stuff though?
Most of the time. The author has the switch and I'm fairly sure its default on.
PHP 5.4 = Time: 6.03 seconds, Memory: 104.50Mb PHP 5.5 = Time: 6.05 seconds, Memory: 105.25Mb PHP 5.6 = Time: 8.05 seconds, Memory: 104.50Mb PHP 7 = Time: 1.31 seconds, Memory: 72.00Mb https://travis-ci.org/laravel/framework/jobs/52221697
This could be helpful in cases where a server misconfiguration reveals the source code of your php file. Because of this reason, it is always recommened that credential containing config files be located outside of your web root. 
You make a good point, I did not realize that. But if I do: $a = array('2'=&gt;'4', 'a', 'b', 'c'); Then `$a[2]` is not really the third element, since there are gaps in the array. So maybe this negative array stuff is not so bad.
HHVM = Time: 39.08 seconds, Memory: 138.84Mb wat.
&gt; This sounds familiar to me from a lot of other languages or API's in general: +1 In other languages arrays are, er, arrays - so it the idea of "2 back from the end of the array" makes sense. In PHP the arrays are actually ordered hashmaps which means that the 'array' has two different ways in which you can consider the ordering i) by the value of the key ii) the order of the keys, which makes this idea not be so good, as it's not obvious which order it should apply to, e.g. $x[2] = 2; $x[1] = 1; $x[0] = 0; var_dump($x); gives: array(3) { [2]=&gt; int(2) [1]=&gt; int(1) [0]=&gt; int(0) } Would the element 'two back from the end of $x' have value 2 or value 0? Other languages also tend to just have a limited set of what can be considered the value key for an array, 0 to N-1 for an array of N values. That allows them to clearly determine values in that range as a request for that element, and negative values as a different type of request. Because PHP arrays are hashmaps, and negative values are valid values for the key - it's not possible to have this separation between 'normal' requests and other requests. 
But you could argue including the lock file serves as an indicator to the end user the known good dependency versions.
I see a gap - before the element called '2', there is no 0 or 1. So '2' is not actually the 3rd element - it's the first. I'm saying that PHP arrays are not "pure" anyway, so including `-1` as an option doesn't really hurt anything.
i'd say that's the problem of running hhvm from cli. from what i've learned. 
That helps a lot, agreed. Afaik nothing like that is available in the php world, thus I initiated this thread. It's certainly in the realm of php devs to enhance the actual frameworks but I wouldn't know how to fix the tooling side. Unless someone like jetbrains backs this I fear we won't enjoy such luxury and need/can/should enhance what we've right now. Very valuable input, thanks! 
HHVM also requires a warmup period.
I think he meant "why is it slower than 5.5 ?" I'm curious too
So I guess it's just a way to populate the properties of an object (or array) from the data received from an SQL query? Is it SQL specific, or can an object be 'hydrated' from any data source?
That's just assignment, really. Hydration is a more specific term which means assignment of the contents of an array into properties on an object through a "hydration strategy" (assigning to public properties, calling setters, etc). The inverse, extraction, is creating a key=&gt;value array from the properties of an object.
Where would you group this? use Vendor\Package1\Component1\Class1; use Vendor\Package1\Component1\Class2; use Vendor\Package1\Component2\Class3; use Vendor\Package1\Component2\Class4; use Vendor\Package1\Component3\Class5; use Vendor\Package2\Component4\Class6; Where would you group them if it was just lines 1 &amp; 2? Or 1 &amp; 3? Or any other combination? Unless there's consistency then we're going to get a lot of meaningless diffs every time a new class is used. If group use statements are being used, we should have a standard point at which we group. Eg always group classes immediately after Vendor\Package\. 
You got me wrong here and I change my comment accordingly: the "+1" was meant to say "I like it". I facepalmed myself as I just realized how weird this must have looked in this context.
It also shares connections in a pool and session data, and FPM processes if you use that.
From what I've read so far, most software uses a finger-print for a buffered part of the song, those fingerprints are compared to fingerprints of other songs. But yes. The efficiency of the algorithm and the overhead are probably the most difficult issues here. 
Passed by a hair. Required a 2/3rds majority, and it got 39 of the required 38.666... votes.
When you dehydrate something, you suck all the water out of it. Like an empty husk, devoid of data. When you hydrate it you shove all the water (or data) back in.* *citation needed 
Are you trying to `echo` the resulting array? Because that is not going to work. You could try this (which worked for me): &lt;?php $datenArray = array('20.12.2014','12.4.1999','7.9.2025','25.2.1972','13.3.2033','5.5.2005','13.9.1872','1.3.2017','13.3.1615'); function formateDateArray(array $datenArray) { // ... function goes here } var_dump(formateDateArray($datenArray)); Edit: Maybe I should've been more clear: the function doesn't edit the entire array in-place, it loops through a copy of the array and works on each item in that array, then returns it. If you want to work on the array itself, that's possible, too; just change the function signature to `function formateDateArray(array &amp;$datenArray)` (notice the **&amp;**), and remove the `return`. I'd advice against that, though; functions that take an argument and return something are easier to test and chain together.
He asked for Propel2, which is totally different to v1. See my answer.
Well, when we're talking about Propel 2 (not the current alpha) then we're talking actually about not so much technical differences. So what we should compare is what Propel2 is when it's released compared to already released Doctrine 2, comparing an not complete alpha with a stable version makes no sense, even if you have to wait for its release. https://github.com/propelorm/Propel2/wiki First thing to note here: Propel2 will be a data-mapper, too. The biggest advantages over doctrine based on that: * (IDE) Code completion (through code generation) for active POPOs and query classes * [Better performance](https://cloud.githubusercontent.com/assets/450980/4826815/e8efea9c-5f73-11e4-93d8-a7e4134b3d14.jpg) through code generation and better unitOfWork usage * The definition is not so complex as in Doctrine, especially entity relations * Schema Migrations is part of the core * Many common behaviors are part of the core as well * Optional Active-Record ((almost) API compatible to Propel1) through traits * [Sandbox](http://sandbox.propelorm.org/) What both have: * Excellent documentation * Great Symfony bridge * Community * data-mapper/unitofwork What's not so cool compared to Doctrine: * Not released yet * No ODM yet
Be aware that travis build time are not a good way to benchmark anything, performances can vary a lot.
While this is just a nitpick (the additional code for arc4random etc. is small), but still I'd personally prefer "simpler and less code" approach. As you need to anyway test for the fd (you can't rely on arc4random etc.) it saves a tiny amount of code if dropping those "additional" sources, and thus less room for bugs ;) Edit. Actually I'm not sure if there should be a "test/sleep if failure" when getting the fd, maybe it is better to go as it is now (just plain and simple exit with an error).
Run composer with HHVM and it's a lot faster (usually 2-5×). I also run some workers with HHVM because of the performance gains. I guess YMMV.
just my 2 cents...elastica bundle is great for "simple" models. In case your associations are complicated you will reach a point where extending it will not work efficiently and you will end up creating your own solution using the elastica as library only. The listeners it provides are really handy for smaller apps but be careful when working with a lot of data.
An elegant solution would use with array_map or array_walk to format your string dates.
~~Could you provide me with a source for Propel 2 making active record optional in it's final release? There's no indication of that that I've seen thus far.~~ Also, regardless, Propel *is* alpha, another reason to use Doctrine over it for now. There's no use suggesting that OP waits for Propel 2 to become stable before using it over something that has been stable for years. Edit: Just seen the wiki link you gave below in your answer. That's pretty interesting then actually. But I still stand by Doctrine being the obvious choice for now. Propel still has to prove itself yet. But, it does look like it's shaping up nicely.
why dont you strtotime() them on declaration, then you can output them in any format at anytime.
yes, you do have to clone the whole thing. I've not seen a project that accepts PRs against such subtrees.
I'm working with an existing database and I cannot modify it
Maybe a dumb question, but what happened to PHP 6?
Disclaimer: My own blog post on our company's blog. But wanted to see what you think about this approach?
http://www.reddit.com/advertising
it just got skipped like windows 9 (just bit different reasons) [source](https://wiki.php.net/rfc/php6)
It is just for sample, actually I prefer using controller as service as we can inject dependency to the controller, also once serviceController is registered, I can do deep route nesting with it Route::group('/admin', function(){ Route::get('/', 'AdminController:index'); Route::group('/user', function(){ Route::get('/', 'UserController:index'); //admin/user/ Route::get('/create', 'UserController:create'); //admin/user/create Route::post('/', 'UserController:store'); Route::group('/group', function(){ Route::get('/', 'GroupController:index'); //admin/user/group/ Route::get('/create', 'GroupController:create'); //admin/user/group/create })-&gt;before($app['admin.auth']); })-&gt;before($app['admin.auth']); })-&gt;before($app['admin.auth']); when using the controller providers, it is a bit hard to do deep route nesting 
It's [in the works](http://www.reddit.com/r/PHP/comments/2x0tzm/config_a_lightweight_configuration_file_loader/covxs4l)
Yeah, if it would be like 1 sec, could be just "rounding error" whatsoever. But 2 Seconds is pretty big imho.
Hi guys. So we've released the platform and would really appreciate feedback of any kind. The code is all on http://github.com/mothership-ec and we've also got a forum at http://forum.mothership.ec We're really excited about this and have worked really hard on it, so we'd love to see a bit of a community develop around it
https://wiki.php.net/rfc/php7timeline
The nature of what the methods are doing in the example (printing a string) is not the key bit. It is just an example. A more appropriate example may be a class Foo which has to do a call to a static function to retrieve a record from a database. Making it difficult to unit test and mock the database interaction. The proxy approach solves that problem I feel.
I guess if the static method has hardcoded SQL strings and instantiates it's own pdo object in line this is the best solution. In most cases I would still say that hitting the DB is the behaviour of this method so you should test that, and mock out the DB connection
Google docs should be more than enough for the task at hand.
Years ago, there was a big RFC to [remove opening tags](https://wiki.php.net/rfc/nophptags). You could probably dig up the discussion from Google.
&gt; prefer using controller as service as we can inject dependency to the controllers You can do that with controller providers. &gt; it is a bit hard to do deep route nesting $app-&gt;mount('/something', new SomethingProvider()); $app-&gt;mount('/something/else', new SomethingElseProvider());
Google docs or git 
I personally like [Coercive Types for Function Arguments](https://wiki.php.net/rfc/coercive_sth) better
I don't. That RFC would introduce a potentially huge BC break, and lacks much of the static analysis benefits offered by a strict mode.
Why I think this RFC is the best approach: http://news.php.net/php.internals/83895
Thanks! Be sure to let us know how you get on :)
This adds some pretty great functions. It would be nice if it also included `generate_nonce($bytes)` too.
Not sure why someone downvoted you. That is an extremely relevant RFC for this discussion. That said, I also learned some good points from theodore's writeup on this RFC and I feel it is the best current option.
is a "Cog" basically folders of code being pulled into the "main" bundle ?
There are a lot of applications that still use &lt;?PHP ?&gt; in templating. Especially with the short PHP [short echo tag](http://perishablepress.com/php-short-open-tag/). I wouldn't mind removing it, but I think there is too much backwards compatible stuff that would break.
[Whoops, typo!](https://github.com/mothership-ec/cog-mothership-fedex/blob/develop/src/EventListener/OrderListener.php#L22) Random, I know. Just wandering through code and I noticed that.
Awesome! Let me know how it goes :)
Congratulations! That's the first issue submitted since going open source! Imma fix that right now! edit: https://github.com/mothership-ec/cog-mothership-fedex/commit/c94d838e54d6ce158f57c1d99ab32253b6661def
This is a good question, still no one has any answers to it. 
0.072% of the tests failed.
Am I reading it wrong or does HHVM still beat the nightly by 3 seconds?
I reran the build and it is indeed not such a big difference this time, very strange. Originally PHP 7 was 45 seconds. I'll rerun once more
Dropbox
Alright, you convinced me, thanks for writing this up! I'll be more than happy if this passes
no screenshots, videos, demo installation? why?
Because some people use the downvote button as a disagree button. Anyway I've changed my opinion on the matter after reading Theodore's and /u/Danack 's explanations on things I hadn't thought about before
look at it now ) it's fast again
Yes it is an intermediary step, you can start writing new unit testable code earlier and when you can refactor away the static implementation, the proxies get removed too.
I fucking love your username btw.
Yes, you are right. But since they are automatically generated and never purposely read by the user (except when debugging) they could be changed to do the reverse. So instead of "?&gt; some html &lt;?php" you would have "&lt;?markup some html ?&gt;"
This "mode" paradigm is a prime example of why PHP is the laughing stock of the development community. We can't ever just do something normal... it always has to be *almost* normal, but with a healthy sprinkling of WTF, just to make sure we aren't ever mistaken as a legitimate language.
I'm sorry if I sound rude, but I think if you feel you need to prepare for an interview test, the purpose of which is for you to demonstrate a working knowledge of PHP, you probably don't have the proficiency required and would be doing both yourself and your prospective employer a disservice in trying to "cram" for such an exam.
Didn't we just get a new version? 
The previous release cycle was roughly every 6 months but they took about a year for version 8 because of the number of changes they wanted to go into it
Damn that array comparison!
time is not random... sigh... even using time + mt_rand would have been better. (which was already possible in PHP4)
PHP 4 was far, far worse than even 5, let alone 7. However, that doesn't mean that we're not still the target of ridicule - and rightfully so, with stuff like this *still* potentially going into the language. Weak, strict, strict with widening primitives - it doesn't matter. They're all respectable typing approaches with plenty of precedent, regardless of people's personal preferences. Adding hot-swappable language behavior is a huge WTF, though.
I wonder how good the code coverage of laravel is now. PHPixie database test alone has 514 tests ( 3320 assertions ), and that's excluding ORM which is much larger. The entire laravel has only 1372 tests ( 2921 assertions ) 
Obviously this is historical baggage from PHP's humble origins. That's the point. The fact is that is started that way, and now changing it would be a massive dick for reasons mentioned above. The fact that the other mentioned languages never had it that means they do not have that baggage. Just saying "It's 2015" over and over again doesn't change anything. :-/
Basically there is an old "PHP 6" and there is a lot of information out there regarding "PHP 6". Regarding not skipping 6; "The worst case scenario is widespread confusion in our community and potential negative perception about this version."
I got downvoted a few days ago for suggesting Zeev/Frascois don't understand what static analysis is, but I really have no other way to interpret their RFC other than malice.
I'm getting you a beer at PHPBenelux 2016.
PHP has many purposes. While in a modern application built using a framework all your logic will be pure PHP files, in the real world PHP is still very much used for quick scripting where html and PHP are interleaved. You may not like it, but it is what it is.
&gt; Frankly it's useless if I can pass "automobile" as an integer... You can't. See https://wiki.php.net/rfc/scalar_type_hints_v5#behaviour_of_weak_type_checks "Non-numeric strings not accepted. Numeric strings with trailing characters are accepted, but produce a notice."
This is all I want.
How is this getting upvoted? 1. This doesn't belong here, it belongs in /r/PHPhelp 2. Wordpress is such a steaming pile of shit that asking other people to help is a complete crapshoot 3. This doesn't even deal with Wordpress, but a specific *theme* for it 4. My favorite... **the answer is literally in the error message**. The class instantiated at the end of line 32 hasn't been defined so there's an include missing somewhere.
This is really good stuff, and I appreciate it a lot. We're pretty (very) new to the open source thing so I imagine there will be a lot of learning to be done! The black box thing hadn't really occured to me, I suppose some other options like you suggest would be good. The .phar itself isn't actually the application, it's essentially a small application that downloads a theme from Github, creates some files and directories, and some database tables, and runs a Composer update. We went with .phar because I love the way Composer comes packages as a single file like that. We definitely aren't trying to compete with Magento directly, we are mainly just aware of how many developers out there feel stuck wih Magento as the only option. Of course, there are others out there, like Sylius, but we are mostly interested in providing people with options for what is important to them. We feel like the platform is well suited to smaller scale sites that are easy to set up while still being easy to customise
"Hack language support" This is what I'm excited for. It's hard to work with a statically typed language without an IDE.
This might be useful. http://stackoverflow.com/questions/23582444/what-ides-have-support-for-the-hack-language
What would you prefer? 
I've seen it truncate before, but I've never seen that behavior documented anywhere.
They're trying to reach a middle ground, where hints exist and do something, but the proposal as written is going to cause some significant BC problems. We'll see what changes in it before it gets to vote...
[View the results here](https://docs.google.com/forms/d/1V66-UuX1RpFZSod21Z6WAqXiEVcXmBOONmroDNxSmZ4/viewanalytics) if you've already voted.
Awesome! Where can we send pull requests with improvements?
I think it's a good question. I had a PHP interview a couple of years ago and I was astounded at the stupid crap they asked me about. The test was just a bunch of PHP "gotchas" I had never seen before and still cannot for the life of me imagine how I would come upon such problems in normal development. I thought it was a programming test but it was a PHP test. I easily had the programming skill, that was not the issue in this case. Perhaps I found it difficult because I was jumping around in 3 different languages at the time - anyway - point is they probably want to make sure you know something specific or something trendy. So, I would study up on the newest features of the latest stable releases and that sort of thing.
I would suggest that you would do a quick review of the highly used functions in PHP (arrays, sorting, a bit of mysql_*) If you have time, take a quick look at some big PHP frameworks on Github (laravel or any other) and impregnate yourself with "the PHP way", more on that, I would suggest you look at the existing [PSR](http://www.php-fig.org/psr/) publications. A good suggestion maybe would be to take a quick look at [PHP the Right Way](http://www.phptherightway.com/)
&gt; It means that any code that currently uses PHP's built-in conversion will suddenly start giving a huge number of warnings when it moves to 7. That would affect almost all of every code base. Do you have any evidence to back this up? Have you tested the patch (if there is one yet) against a ton of existing codebases? &gt; No sane company would do this. Everyone would stick on PHP 5.x until 8 was available - and then upgrade directly to 8, which mean having to touch all of their code base just once, instead of twice. Why would they need to fix their code twice? If they hide the notices in v7 that's not fixing anything. Seems reasonable to me to emit some notices in PHP7 that can be gradually fixed, then upgrade to PHP8 without issue. I still prefer ircmaxell's RFC but don't start spreading FUD or you're as bad as Zeev et al.
Ah I see what the issue is, the script runs git clone on the skeleton theme, however, the directory you tried to clone into was not empty, so it failed. I need to add some more checks to the installer to ensure it exits if anything fails instead of persisting
Not that my voice matters, but the "optional" part of this makes it a "no" in my book. Either implement it fully or don't. These half-way measures to appease dissenting voices in internals bothers me. That aside, I really feel like this proposal increases the cognitive load required to develop PHP as well. I'll just keep happily coding C# instead.
&gt; All sane apps 
check the site mate. It says on the top-right 'fork me on github' 
Judging by the "Fork me on Github" ribbon on the site: https://github.com/beberlei/php-rfc-watch 
In all fairness, it wasn't there until I suggested to the author that it was added: http://chat.stackoverflow.com/transcript/message/21801983#21801983
In all fairness, it wasn't there until I suggested to the author that it was added: http://chat.stackoverflow.com/transcript/message/21801983#21801983
Consider also the second part of my comment.
Travis build times are just not reliable at all, you shouldn't draw any conclusion.
Sorry, I should have specified I was only responding to the first part.
Why would that be different to random_bytes?
Normal people will never understand :(
Yes, all composer stuff works, but I've only ever seen "PSR-0 Namespace Root Detection" in PhpStorm, never saw a PSR-4 option, even when the codebase is PSR-4.
Zend Framework 2 support.....just in time for Zend Framework 3. Joking aside, I'd be pretty pumped about getting support for ZF2 and remote tools. 
&gt; it ***was*** utterly fundamental Yes, it was. But let's stop living in the past, shall we? If you have application code under your webroot in the year 2015, you should step back from the keyboard, take a deep breath, and go read up on security best practices. What you most definitely *should not* do, is drag the entire language and all the competent people down to your level.
So? This wouldn't prevent that at all. It just allows you to omit the opening that if you are in a pure-PHP file.
Well, see, both Andrea and I had tried that in the past. More than once. Officially, [1](https://wiki.php.net/rfc/scalar_type_hints), [2](https://wiki.php.net/rfc/scalar_type_hinting_with_cast), [3](https://wiki.php.net/rfc/parameter_type_casting_hints). And that's just the ones we proposed. Andrea's first one (#1) had three iterations. I had at least 5 that I never proposed by played around with locally. We both tried to avoid a "dual mode" situation. We settled that it's just not possible. It's not possible because you have to choose from the following tradeoffs: * Make userland more inconsistent with internal functions * Break a TON of code * Be overly weak to appease people who want stronger types * Be overly strong to appease people who want weaker types At least 2 of them will happen without a doubt. What we learned, was that there's no real balance that can be walked. Hence the two-mode approach. It solve all of those issues. Yes, strict may be more strict than many want, but any weaker would be weaker than many want. This way, you get the best of both worlds. And you get to choose. I hope Zeev can find a better middle ground than either Andrea or I could. I just really doubt it (especially given the flip-flopping the RFC he's proposed is doing). Experience has told me that the thing he's writing off as a trivial "tweak" is actually one of the most difficult lines to walk in this project. And the fact that he keeps saying "we just need to tweak" shows me that he either doesn't understand the scale at stake, or he just refuses to show that it's a difficult problem. And I personally find that part insulting, as it insinuates that neither Andrea nor I "really tried" but instead chose to ram something down everyone's throats instead... I'm writing off his proposal, because I see where it's heading and I think it's bad for PHP (either massive BC breaks, or overly weak, or inconsistent behavior between internal and userland functions). Until I see something to counter those concerns, I can't accept it.
Thanks :)
Yes +99999999999 on that :) Namespace aware moving would be the bomb. 
&gt; Not that my voice matters, but the "optional" part of this makes it a "no" in my book. Either implement it fully or don't. These half-way measures to appease dissenting voices in internals bothers me. It's not so much to appease dissenting voices in internals, there is legitimate concern that a large portion of the PHP userbase want, or perhaps even need, to continue working the way they always have. It's a pragmatic approach to a complex problem. If it was implemented entirely one way or the other, history has shown us that it would not get support. &gt; That aside, I really feel like this proposal increases the cognitive load required to develop PHP as well. Really? If you just ignore the proposal entirely and do nothing else whatsoever, the behaviour remains entirely the same. If you opt in *it behaves how you'd expect a sane language to behave*... so either you have no additional cognitive load because you don't opt in, or you opt in and reduce cognitive load by no longer having to concern yourself with utterly insane conversion semantics.. &gt; I'll just keep happily coding C# instead. Ok! 
Can we get the ability to open up multiple projects in one window with separate scopes? Their Java IDE has this, and i think their python one does too.
This needs to be a top-level comment ... and resaid when Zeev's RFC opens for vote.
Perhaps someone on interals (/u/ircmaxell perhaps?) can let us know what coercive type hinting *also* going to a vote will mean? Let's assume that 0.5 gets up, and gets broad consensus (and I dearly hope it does, despite misgivings about the aesthetics of "declare")... that wont be the end of it. Zeev will still try to ram his fail down everyone's neck.. so Coercive goes to a vote and it also succeeds...which one do we get? Assuming that some people vote yes for *both* RFCs, how is their vote ultimately counted? Is it going to be the case that it accepted that STHs find their way into the language but there is a final "vote off" to see which one? This situation where 2 RFCs fundamentally cover the same ground seems to me to be counter productive and perhaps even contrary to (dare I say it..) the "spirit" of the RFC process. Has there been any precedent for competing approaches in the past? 
Honestly, I would be more than pleased if they would finally repair the broken shortcuts for Mac and Linux systems on non U.S. Keyboards, instead of fancy new features.
&gt; Is it going to be the case that it accepted that STHs find their way into the language but there is a final "vote off" to see which one? We've talked about it here and there. Basically, there would be a vote-off (a limited RFC where you chose one, the other, or both -since they technically are compatible). Then that would be the final nail...
Really need this. I'll continue to suffer with Aptana in the interim.
Bookmarked for that ~~Scalar Type Declaration RFC~~ User-land CSPRNG.
Not very impressive new features compared to what Phpstorm 8's new features were. Sorry to say this, but PHPStorm is already way too awesome and it's getting harder to improve even further :P
Behavioural testing serves as a compliment to unit testing to ensure code performs as expected under real world conditions. This is especially important when underlying library code is not entirely predicable in general or unpredicable across different php versions and environments. Regarding your second point... yes? as I explained I did not want to have to deal with NPM dependencies. As much as I like node it adds unnecessary complexity to the testing environment (e.g. CI) which I wished to avoid.
Well, a web server isn't physically serving Python files. In brief, it calls a Python program via an interface (CGI) and returns the generated content from that program, which is then served back to the user. Python isn't physically able to be embedded within HTML and parsed in the same manner as how PHP can be embedded and parsed. (Python needs templating engines to simulate things like this.) Also, Javascript does use script tags.
whoaa, I didn't know it can be done like that :), thanks for enlightening me, &gt; You can do that with controller providers. I can't find sample for this case provided in silex documentation 
I think you're going to have some bias problems there :-P
My linux dev machine/4k monitor thanks you.
&gt;If you rely on userid=1301 to automatically log user "John" in without having to re-enter their credentials, you've created a trivially exploitable backdoor that could have disastrous results. That was the very first security hole I ever made, at the tender age of 15! Confused the hell out of me when my friend started posted as random people in my custom forum software.
Admittedly, the guy has a preference for Yii2 when he starts the comparison, but I've been looking for someone to compare the frameworks for a while and this is the closest thing available.
&gt; Live debugging data overlay directly in editor Anyone know what this means? It sounds nifty.
So PHP is bad because it doesn't do type hinting to protect users and it is bad for trying to protect users from server configuration errors.
I dont think so, why this "mode" paradigm is a prime example of anything bad? PHP is an established language and has its own circumstances, it's impossible to make it fully strict but is a valid option to make it partially strict if a developer wants it, and as /u/ircmaxell and others have explained multiple times over the last few months it's totally possible and will result in multiple benefits to the developers, I just can't see how it can be seen as a demonstration of something bad regarding the language quality
Comparing the current 26 votes (19-7, 73%), there are three which have changes their votes from the [previous vote](https://wiki.php.net/rfc/scalar_type_hints). All three (peehaa, danack, leigh) have switched from no to yes. If that trend holds, then this will easily pass. If those three hadn't switched, then the vote would be 16-10 (62%).
Best wishes on this venture. I'll do what I can to get exposure of this in the Magento community.
Guy who is selling a book on learning Yii 2.0 says Yii 2.0 is better than Laravel 5. Shocking! A better way to compare the two frameworks would be to build small applications for each and write about how each experience differed between the two. They could then post the code for each on github so users could see for themselves. As it stands, there are exactly 2 single-line code snippets in the entire article, which is...not very illuminating.
Parallel voting seems to be the idea. From https://www.mail-archive.com/internals@lists.php.net/msg76231.html : &gt; The vote will remain open until March 13th, 2015 or until the date a competing RFC closes voting, whichever is later. ~~So I am guessing that if the other RFC is put to the vote before March 13th, then the RFC with the most votes (and &gt;=2/3) in parallel voting wins.~~
Completely agree. It is not an end all solution. It's just a stepping stone. We have been doing something similar in our main codebase for some time now, but with a series of traits containing protected methods wrapping the static calls.
&gt; I can't find sample for this case provided in silex documentation Same way you do it with `$app`. You create a new controller collection, add routes to it, and then return it. The controller collection can be used pretty close to how app is used. class SomeProvider implements \Silex\ControllerProviderInterface { /** * {@inheritdoc} */ public function connection(\Silex\Application $app) { $c = $app['controllers_factory']; $c-&gt;get('/some_route', 'SomeController:indexAction') -&gt;bind('some_route'); return $c; } }
Just don't watch it, things will happen faster.
Nope, you're thinking [the other way around.](http://i.imgur.com/sJtlXvF.png) 
Ah good thank you for the answer!
I'm curious what changes are holding you back from L5? The directory structure is completely optional...
Thanks, I guess I skipped that part in the new RFC! I still prefer Zeev's take on type hinting and rejecting it on BC ground is bullshit considering that PHP7 will break BC in all sort of little ways anyway, what best opportunity are we going to have? But after re-reading ircmaxell's version I agree it might be more appropriate, all things considered.
What is going to happen if ircmaxell's RFC is accepted? Will Zeev's RFC go to vote anyway? Will they compete?
http://php.net/manual/en/language.oop5.php
&gt; Either implement it fully or don't This was the point of view of Zeev's original RFC - it'd issue an `E_RECOVERABLE_ERROR` on various type mismatches. To [quote ircmaxell earlier](http://www.reddit.com/r/PHP/comments/2x8jsz/voting_started_on_scalar_type_declarations_v05_rfc/coy7ffc), &gt; And yes, a lot breaks. &gt; &gt; It took me about 30 minutes to get PHPUnit to work enough to start to run Symfony's tests. And I couldn't get that to complete because of too many breaks (and I didn't want to spend hours on it). &gt; &gt; And that's for two clean and well tested applications. And that's with *looser* typing rules than the strict mode proposed in *this* RFC! The reason for the drastic change is that internal PHP functions suddenly become correctly hinted in both RFCs. Since that test, Zeev's RFC has changed the type of error emitted to an `E_DEPRECATED` and has expressly stated that it'll target going back to `E_RECOVERABLE_ERROR` for PHP 8. If the other RFC went forward, in PHP 8, *any user can fatally crash your application* by manipulating incoming data unless you are *obsessive* about casting and validation *or* unless you drop every type error on the ground. That might fly for new code, but it'd be a disaster for legacy applications of any nontrivial size. Imposing rules on code that **always** force errors is a non-starter for backwards compatibility, even if the code *is* "broken." This RFC doesn't error out unless the *caller* is in a state where it will *expressly* request strict hinting, which means that it'll have been written to deal with all of the problems. Meanwhile, userland typehints will continue to guarantee getting the correct data type, even in weak mode. Zeev's will be a much larger, more annoying burden for all PHP developers going forward, while this RFC will cause strict hints and only strict hints to be a burden, and then only to specific code that opts in to the burden. I don't think I'd vote *against* Zeev's RFC, though, if I had a vote...
&gt; Middleware seems like a step backwards, but once you get to using it you really dont notice a difference. You can easily retrieve any params from the url, session, etc by calling the request object that is passed through. `$this-&gt;middleware('permission:add.user')` is not possible, and a permission system is a perfect thing to apply as middleware - yet you can't really do it because you have no way of explicitly defining the action to check against. &gt; The chaining is completely optional. You can still use the facade. ?? That's not the point I was making...
Search Amazon for "PHP 6" and you'll get dozens of books from publishers who jumped the gun. Most of it wound up in 5.3.
Well the middleware isn't supposed to be a permission checker. Its supposed to be the "are you logged in" checker and the form requests handle the individual endpoint checks. I misread what you were saying about the forms/chaining. I agree I would have liked to see it included by default. 
Well middleware is just that: it executes after the route match, but before the controller call - hence it's name. Therefore you can (and should) put anything in there that needs to stop requests from even reaching the filter - which permission checking (in addition to auth checking) is perfect for. Secondly, not every request is a form post. I don't want non-admin users doing GET requests on /admin any more than I want them performing POST actions they're not allowed to. If middleware is a good place to invoke auth, session, and CSRF checks, it's also a good place to invoke permission checks.
&gt; Secondly, not every request is a form post. I don't want non-admin users doing GET requests on /admin any more than I want them performing POST actions they're not allowed to. You can (and should) use FRs for GET requests too. 
How is that going to help me with a permission system? I'd have to create a new object for ever single permission action since I have no way of passing in a parameter. `BanUserRequest`, `EditPostRequest` etc. That's a ridiculous amount of work for what literally just has to be a string representing the action to check permission against. The *ONLY* sane way to implement a permission system in Laravel 5 is like this: class SomeController { public function someAction(Permission $permission) { if (!$permission-&gt;check('do.some.action')) { return redirect(....); // or abort, or whatever } ... } } But I shouldn't have to inject the permission class on every controller method, and then call the permission check within that method, EVERY TIME. That's *precisely* what middleware is for.
Command bus may make sense for commands (e.g. POSTS/PUTS/DELETES), but not for GET requests. I would prefer uniformity and consistency in how my ACL/permissions work. I wouldn't want some permissions being defined at the controller/route level, and some being handled in the command. I also think that that ACL checks (even if delegated to a permission class) is outside the purview of the responsibility of a command. A command should be executed under the assumption that someone has already been granted permission to execute it. Say you have an admin backend that gives you some cache management. You'll likely wnat to create a PurgeCacheCommand that can be invoked via the admin GUI, but also invoked by a cron job. If you tie permissions to the command handler, then the cron can't execute it unless you expose some global permission disabling that can be called before the cron runs. Really, ACLs and permission checking needs to happen as close to the request layer as possible, before the application is allowed to continue doing anything.
But when you're already doing validation for all post/patch requests its not much more work to add them for the get requests too.
If there is one thing you invest in make sure it is Laracasts. You'll learn a crazy amount of stuff even when you think you're a pro.
I disagree. A community-based website that includes forums, comments, content publishing, user management, and a whole suite of other features, is going to have hundreds of different GETs that you're going to want to filter out and restrict. I would rather write 'permission:my.permission.key' a few hundred times at the route level, than write a few hundred distinct classes that represent GET requests, and then inject those.
I run a pretty large application that does all of that (not forums but collaboration on real estate sales). I've found form requests to be more powerful because I can do actual logic if needed with in the authorized() method instead of just passing a string. For instance for some projects the user has to have the general view permission as well as specific permission for that single project. Form requests allow me to do that vs a single string (or closure) all tied up in the routes. To each their own really. I just find Form Requests extremely helpful in separating concerns. The routes route, the middleware keeps track of general auth/csrf/etc and FRs control validation and endpoint authorization.
I need to seriously spend time setting up my keymap for the Vim plugin on PhpStorm. I really miss the quick shortcuts in Vim when I use PhpStorm.
&gt; francois voted No on RFC Scalar Type Declarations FUUUUUUCCCCKKKKK
Sorta. You get an upgrade within the first year. Then you're locked to the latest release in that year without a renewal. 
It's not a one-to-one comparison, but here's the [framework's trait](https://github.com/laravel/framework/blob/5.0/src/Illuminate/Foundation/Auth/AuthenticatesAndRegistersUsers.php) and [controller class](https://github.com/laravel/laravel/blob/v5.0.1/app/Http/Controllers/Auth/AuthController.php) that handles user registration, login, and logout.
With respect, it's not tabs vs spaces. Tabs vs spaces have zero impact on the actual code - so "just picking one" is completely acceptable. It really doesn't matter. In this case, weak vs coercive vs strict all have their own sets of advantages and problems, and they are all quiet unique. Coercive *tries* to find a middle way so that only a single option is required but as others have pointed out it's brittle and will cause a lot of headaches. The only logical way forward is a dual mode approach really. Neither weak or strict on their own would gather enough votes to go through.
Neither is a code problem. They're *team* problems. And like tabs vs. spaces, this is a pointless, petty point of contention that will do nothing but divide the team (read: PHP community). Look at what it's already done, ffs. Imagine the fallout if/when it actually becomes pervasive.
Does PHPStorm already have "hover over variable to see current value"? (I'm just use an old IntelliJ version.)
It maybe true that they are both team problems (I don't necessarily agree with this, but I will grant it in this case), but they are very different "team problems". Tabs vs spaces have zero impact on the side effects of your code. This is clearly not the case for strict vs weak vs coercive. Clearly they do different things or else there would be no need for the alternatives. Now, team problems they may well be but your original assertion that the argument is just "spaces vs. tabs all over again" is patently untrue. Just picking one clearly isn't going to work, even at a small team level, let alone at the level of the entire PHP community.
Of course you can, but I'm specifically talking about PhpStorm's root detection.
&gt; like this https://github.com/yiisoft/yii2/blob/master/apps/advanced/frontend/controllers/SiteController.php Those are 171 lines. All those features in as few lines is remarkable. &gt; Doing validation / auth checks in a FormRequest class is so much cleaner and it stays out of the way of your "actual" controller code. On yii2 the model validation is done in the model, not the controller
I would like to move on to 5 once more resources become available , just don't want the time spent on learning 4 to be a waste is all.
I wonder, 5 years down the line, how many things I'll have to put into my `declare()` in **every single file** to have sane behaviour. Maybe I won't even bother, because users of my code can simply drop (or forget) the strict types declaration, and suddenly my code is just as unsafe as it was in PHP5. I foresee a lot of this: public function doStuff(int $foo, string $bar): MyClass { return $this-&gt;safeDoStuff($foo, $bar); } private function safeDoStuff(int $foo, string $bar): MyClass { // real logic here } Because that would force strict typing regardless of who/where `doStuff` is being called from. Correct me if I'm wrong.
I don't know what I should study for, it's not like I'm cheating. I'm applying for a programming job, obviously reminding the brain how to code algorithms and stuff would make sense. Or would you go apply for a Piano job that you used to be good with, but had a break playing Piano for some months but is loooking to get started again
Your argument can suck my ass.
Learn 5. Best starting point would be Jeffrey Way's aforementioned Laracasts, in particular "[Laravel 5 Fundamentals](https://laracasts.com/series/laravel-5-fundamentals)" followed by "[Build Your Own App](https://laracasts.com/series/build-your-first-app-in-laravel)".
RFCs should have a link in the right sidebar, so that I don't have to hunt for it in the votes just to take a look at the RFC.
Tried reinstalling. Got it working now, but when I go to create a new product the AJAX request throws the following error: http://pastebin.com/qJfGDGhq
I would learn 5 focussing on the tutorials that are available for it, there are a lot and only fall back on doc's for 4 for stuff that is the same. And since a lot of Laravel is based on Symfony 2, you can fall back to that to. But unless you got an existing project I would go for 5. Just remember that if you use it in a commercial project that version 6 will probably be different again. That lack of backwards compatibility and lack of long term support is an issue you should take into account.
OK, we're in agreement then. I hadn't considered that weak type hinting converts types, so the inner strict function call I imagined is indeed pointless.
go straight for 5, there's a lot of stuff conceptually different and better. learning 4 first will get you used to things that are done a lot better in 5
Yes, you'll definitely be able to update to PhpStorm 9 for free in this case. Your license includes a full one year of any updates (incl. major).
Thanks a lot!
technically, it's not really live.. you are still polling data between intervals :P
this better go in this round. Zeev's version of this is just retarded. 
JS's strict mode is because of the extreme importance of backwards and forwards compatibility for the average JS program. Unlike most programming languages where a company can dictate their own upgrade path for their software, JS devs need their software to work on every machine from the latest to the oldest. For this reason, "use strict"; doesn't change any semantics of the actual language, but instead enforces correct usage of those semantics. Python doesn't have different modes. It has two different versions, but it makes clear that the latest version is the version that will go forwards, and the older version is being maintained for those who cannot move forwards *right now*. There are also I guess the future imports, but again, these are features that *will* be added to the language, rather than optional extras. I guess there are now optional typing mechanisms, but these are explicitly optional, and solely for the use of readability and third-party tooling. There's also no 'mode' to enable them because they don't affect semantics. I confess I don't know enough about VB to argue whether that model of modes is at all similar to this proposal. However, from the preceding examples, I would like to point out that the guiding principle behind any changes is consistency. A strict JS program will run exactly the same as a non-strict JS program, and the declaration of strict behaviour will only ever affect their defined scope anyway. Python programs equally ensure that any future imports will not affect other modules, but remain confined to the module that imported them. Thus there is consistency, which makes them very easy to reason about. This proposal, on the other hand, changes semantics outside of a strict scope. A caller's variable may or may not be silently coerced into a different form depending on the declarations in a completely separate module. This might be okay for some things, but in more complex projects with different dependencies, there is no longer a set of unifying semantics, only user-defined semantics that will spread their reach over multiple boundaries in the most insidious and unnoticeable way. Of course, there's an obvious solution which is to only write code in the most restrictive of modes, and ensure that all your dependencies do so as well, but if that's going to happen (and is also the only safe way of writing code) why not make it a forced breaking change?
Suggestion: detect the visitor's time zone and display the correct time :)
I did have xDebug installed but I've removed and tried again to no avail. Here's the PHP extensions I have installed if it helps: http://pastebin.com/w8fbm44K Not had a look at the code yet but could it be something to do with trying to find products/categories? I've not got any products or categories (and don't know where to create categories)
Well, you've got to wait longer than 11 minutes to come out and proclaim it's a joke. Now you've deprived us all of the joy of reading through hundreds of rage posts. :)
I tried that but no dice. I can't seem to get the php files to even display properly in my browser. I have simple commands to test and even they will not function
You're dead in the water whether you're hired or not, based on your comments below. No one wants to hire a dickhead, but they love firing one. 
Honestly, there's not much that was introduced in 5.5 that would make much of a difference to the casual login/registration system outside of the [password_hash](http://php.net/password_hash) functionality. The real keys to it are: * using prepared statements (PDO or mysqli) for all queries * using the password_hash handling for bcrypting passwords * using timing-safe hash comparisons (too bad [hash_equals](http://php.net/hash_equals) is in 5.6) * using correct validation on username and password information, including a password policy * throttling on the login/registration (and maybe forgot password) handing to prevent brute force attacks * Forgot password handling revolving around a one-time hash sent to the user I've followed a lot of this in [Gatekeeper](https://github.com/psecio/gatekeeper). Feel free to poke around and see how it was implemented there.
Sweet. I bought my license last June so hopefully I will get be able to go from 7 - 8 - 9 and not need to renew until next year for version 10
somebody please put a pull request in for ✔ and ✘
I like it!
Just in case anyone is wondering what caused me to switch: * The declare strict being changed to top of file only - the ability to switch modes mid-way through a file would make debugging/coding be pretty horrible, as you would continually need to check what type of mode you're in. Although I could see some people might think it was needed, it seemed like a choice that would come to be seen as a design mistake. Limiting the mode to the top of the file is the better design choice imo. * The change to allow ints to be accepted for built-in functions that take an float. In the scalars v0.3 this wasn't allowed, which would have caused a lot of pointless casting to float when calling built-in functions. The real problem here is that the PHP could really do with a numeric type 'hint', both in userland and in the built-in functions which might be implemented as a union type of int|float. This isn't feasible to add for 7, but the strict scalar types don't block it, and would make implementing it easier. * The alternative RFC. For the record I think strict types are far more useful in making code 'correct' and I will almost be certainly end up using strict hints most of the time. The alternative RFC does not support strict types, and instead has a new set of conversion rules for people to adapt to. I understand that other people just want weak scalar types because that fits their needs. And this RFC gives them what they want, and it gives the 'strictest' people what they want. The alternative RFC only provides support for weak scalars, and does so in a way that would make upgrading to 7 far more difficult. 
EDIT: No longer recommending Easy Laravel 5 ebook. Plenty of better free resources available.
Just as a warning, they start the license based on the expiry of the last one. So when you renew for 10, it will be 12 months - however many months there are between June and the 10.0 release.
Hmm, I'm not sure, I'll have a quick check to see if I can recreate the issue. Is the error message still the same even with xDebug uninstalled, because as far as I'm aware that error message come from the extension itself.
I just rebooted the server and seems to be working now. Hoping to try it out properly over the weekend now
&gt; Zeev's will be a much larger, more annoying burden for all PHP developers going forward, while this RFC will cause strict hints and only strict hints to be a burden, and then only to specific code that opts in to the burden. I don't think I'd vote against Zeev's RFC, though, if I had a vote... Just think of all that new PHP work coming our way porting nasty old legacy apps to PHP8
I like him! (PHPStorm too)
This is great news! I hope you like it :) Any feedback of any kind would be greatly appreciated. If you have any questions, the best place to ask would probably be http://forum.mothership.ec
... if they have AllowOverrides On, which a lot of servers do not as it slows things down quite a lot. I know you're trying here but there is not a silver bullet to make this change easy. At least not that I know of.
Did you know Haskell has [a type of Maybe](https://wiki.haskell.org/Maybe)? It's very useful as it can contain a Nothing or the expected result type. (No joke) It allows you to have something akin to a nullable type.
I laughed my ass off when I saw how maybe perhaps and possibly were defined. 
I threw up a little bit in my mouth when I saw this. "Hey so you're going to need to make people wait up-to 6 and a half minutes for your website to work" 
Anyone who talks about good OO code and disparagingly refers to it as "Java-style" raises some red flags for me. I don't know Yii2, and maybe some of these points are valid, but a lot of them didn't seem to be to me. Yii's "widgets" sound godawful, and the point of migrations seems to have flown utterly over the writer's head. They allow you to version control your DB changes. In fact, a lot of this reads of either circular arguments that Yii is better because that's the way Yii does things, or just... not having a very good understanding of the subject matter. 
It looks like JSON wasn't good enough for enterprise. ( https://pbs.twimg.com/media/ByUETcKIIAELf7h.png )
Wait!! I've seen [that movie](http://www.imdb.com/title/tt0211443/) (2001)! It didn't end well for JSON at all!!
&gt; With a beatiful &gt; &gt; multiline &gt; &gt; quote. &gt; &gt; -- jtreminio edit: and some non-quoted text.
I didn't run these tests, so I am not sure. I would assume so, but you know what they say about assumption...
[Chris Cornutt](https://twitter.com/enygma) [Ben Edmunds](https://twitter.com/benedmunds) [Anthony Ferrara](https://twitter.com/ircmaxell) [Alex Bilbie](https://twitter.com/alexbilbie)
Someone didn't get the memo. [http://www.json.org/fatfree.html](http://www.json.org/fatfree.html)
You might be better off in /r/phphelp Haven't really looked at the code, but the general thought process for pagination is: $itemsPerPage = 10; $currentPage = isset($_GET['goto']) ? (int) $_GET['goto'] : 1; $end = $itemsPerPage * $currentPage; $start = $end - $itemsPerPage; $items = query("select * from users limit $start, $end"); 
If you're looking for some examples of Pagination Controls, Zend, Symfony, and Laravel all have pagination packages you can look to for inspiration. In addition, there's a whole pile of packages on packagist https://packagist.org/search/?q=Pagination
I listen to [defensive security](http://www.defensivesecurity.org/) on a weekly basis. The podcast is hosted by Jerry Bell (@maliciouslink) and Andrew Kalat (@lerg)
The guy writing this blog post doesn't seem to know much about PHP. Did he seriously try to blame PHP's deficiencies for the absolutely awful design decisions made by the WP core team?
I would hazard a guess that's part of the reason, another would be supporting some middle tier that only speaks XML.
I've seen solutions for line numbers on code blocks. Do we have that yet? $test = "123"; 
&gt; Unless you’ve goofed something up, the slowest part of your PHP-based application should be PHP itself Wait what ? I'd say if the slowest part of your application is not the database then you've definitely goofed something up...
Well hello! Thanks for making the podcasts!
Exactly what I was thinking when I read that. A(nother) clueless Wordpress developer with his head in the sand.
 Throw new 💩
You're missing a trailing A from my name: *Ferrara* :-D Also: thanks! :-D
Output: touch: cannot touch ‘this’: Permission denied [^source](http://ideone.com/Pr6CbU) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20http%3A//www.reddit.com/r/PHP/comments/2xd9ey/jsonx_is_an_ibm_standard_format_to_represent_json/coz7375%20Include%20your%20reason%20for%20reporting%20here.) 
[Header looks funky](http://i.imgur.com/ztRiRnb.png). edit: so does the little RES Preview image that shows up next to the URL above.
It provides an elegant and object oriented interface for HTTP in PHP, otherwise you are stuck with superglobals and a bunch of network functions that may be either obsolete or not getting the job done. 
.... Or Guzzle?
&gt; public function getJoiningDate() { ... } This is perfectly valid to have in the model. At the end of the day, `getJoiningDate()` is an API method that the `Membership` object SHOULD tell you about itself. The fact that you're calculating that from the fees history is just an implementation detail. You could just as easily record this date upon creation, and then do: public function getJoiningDate() { return $this-&gt;join_date; } So don't think of `getJoiningDate()` as an encapsulation of your relationship call that should be extracted out of the model, think of it as something the model should in fact tell you about itself, and it just so happens to use a relationship call to do so. Though, I would personally find a better way calculate the join_date than relying on a query, as the current strategy will make eager loading and solving the N+1 problem kind of a pain in the ass for you.
I love it. I think it'd be even better without the drop shadows that surround top level comments. You could use a light border instead.
The problem with that is that the numbers always start at 1. If you're quoting a part of code from somewhere, you might want the line numbers to match the source line numbers which can't be done.
Yeah... it's not like I don't understand why having an HTTP library makes sense, but why *this* one? And it has been absent for so long that the PHP community has basically solved this problem from both directions with Guzzle and HttpFoundation. If you *were* going to make a standard library, I would think you make it based on one of the well maintained and highly used libraries.
The upvote icons are super annoying when they have focus: http://new.tinygrab.com/37897525d4f8d69868b13d878a9e903015fed8299f.png Thinking it's a bug? I'm using Firefox + RES
[Pádraic Brady](https://twitter.com/padraicb) [Daniel Lowrey](https://twitter.com/rdlowrey)
I get your intention, but I don't get what you've done. I'm with lord2800. It sounds like you want to test a real world use case, but you're doing it with a fake server anyway. What's the point of having a node/emebed webserver if you want to test a real world use case? Isn't it same as mocking Guzzle response as described http://guzzle.readthedocs.org/en/latest/testing.html?
[Blog post announcing this](http://blog.jetbrains.com/phpstorm/2015/02/phpstorm-9-early-access-program-started/)
Yeah you make the point. The PECL HTTP has lots of issues though, with one of them being it's tied to at least two more PECL extensions. To make this change in PHP core, it will be a very dramatic change. I guess this was partially why it was turned down, if there's a better solution to the problem, I'd doubt so many PHP internals would be voting down for its RFC. Still, I'd definitely love to have an object oriented interface for HTTP, I am an object purist and advocate for elegant quality design, so using superglobals is something I want to avoid. 
Nope, Guzzle is written in PHP itself, a PHP core package and PECL package should be written in native C code, so unless the author rewrite it as a PHP extension in C, it's not as useful as PECL HTTP. 
Looks great only issue with it is that I can't read my karma: http://i.imgur.com/FFa9Kpo.png (Had to select it to read it.)
that last voter must have felt like a saviour 
I agree. Or allowing XSD validation which is pretty much invaluable when exchanging stuff like invoices between businesses.
As per the link: &gt;You almost never need to use this test web server. You should only ever consider using it when developing HTTP handlers. The test web server is not necessary for mocking requests. For that, please use the Mock subcribers and History subscriber. E.g. this is a curl multi handler: http://ringphp.readthedocs.org/en/latest/client_handlers.html#curl-multi-handler The issue as as follows - Take the following function: http://php.net/manual/en/function.curl-multi-exec.php What do you think it's doing in this "basic" example? How do you test that the numerous functions, constants, loops and conditionals are arranged correctly? How do you make the tests repeatable in automated test environments? If you add a timeout to each handle can you guarantee that the overall time taken to execute the session is within a strict set of bounds? What happens if you add 1000 sessions to the multi handle? Can you guarantee they will return within a strict time limit? Mocking doesn't help answer any of these questions. You really only need the webserver to work in as much as it serves specific responses for a given request and follows the HTTP standards.
Just as a side note, if you have a fees column on your table and a fees() relationship you're going to have a bad time.
 $up = new \Exception(); throw $up;
Sorry I didn't clarify -- I meant Server Sent Events
Sculpin is pretty nice. Just add disqus
Is that book any good? It seems pretty pricey for a ebook. I thought about buying it, I just can't afford that sort of money as a student.
More details on the JIT here: http://news.php.net/php.internals/83994
Looks good on Reddit Is Fun
Looks great, now my boss thinks I'm reading docs instead of slacking off. Thanks!
Hi, I'm the author of pecl_http and the RFC. There've been several requests over the past ten years to include it in core, but I never felt like it would be in a state to warrant inclusion, until lately. Now, I'm sure that this is not wanted by the core dev community. 
The dependencies on those two PECL extensions are quite artificial, though, because they have been split off the pecl_http source to be re-used. One of those "extensions" actually covers functionality that was supposed to be present in ZendEngine2 but was severely broken. The other "extension" is more complicated, but all of that is covered in the RFC already.
I know, but I thought the deep level of dependency was the main reason why your RFC was being rejected so far? Or is it for another reason? 
nice - one of the cleanest themes i've seen on reddit
That... is absolutely insane. Looking at the code, it's obvious that they didn't purposely make anything inefficient there. Artificial, yes, but not irrelevant.
I recently saw this in the real world: &lt;xml&gt; &lt;json&gt; &lt;![CDATA[ statusObj = [ 'Data obfuscated to', '&lt;span class="hurr-durr"&gt;protect&lt;/span&gt;the innocent&amp;nbsp;', '&lt;span class="derp"&gt;vendor&lt;/span&gt;', 'More data obfuscated...' ] ]]&gt; &lt;/json&gt; &lt;/xml&gt; XML (with a root element called `&lt;xml&gt;`), containing an element called `&lt;json&gt;` that contains a `CDATA` inside of which is something that is not JSON, which is used to store HTML.
&gt; We can only affect CSS; syntax highlighter would be Javascript-based, which we are disallowed from adding. I didn't know what is allowed and what not. But awesome style anyway, good work.
Apparently, people felt like it would be a bad precedence to put those abstractions into core, which would provide sort of a standard, whatever this means. Also, there's PSR-7 upcoming, with lots of OO stuff and PHP4-like value objects. Anyway, pecl_http will continue to provide a native alternative to its users, and it's already PHP7-ready, too. 
Please stop calling it JIT. It's not. It's an Ahead-Of-Time compiler. The only thing jit about it is that you don't invoke it. Conversation: http://news.php.net/php.internals/84026 and http://news.php.net/php.internals/84032
the stuff nightmares are made of
You can try mine if you like. It'd be great to have feedback on what could be improved in the docs and/or bugs: http://inkwell.dotink.org/docs/
That's a laravel quirk. $this-&gt;fees accessed as a property, is a magic alias of: $this-&gt;fees()-&gt;get(); // returns a Collection It doesn't mean fees is a column on the membership table. Meanwhile $this-&gt;fees() accessed as a method returns the query builder so you can chain additional constraints on it. If you call it as a method, you have to remember to call get() or first() to terminate it.
Looks like a hacked version of naut! Nice.
Yeah, I'm constantly refactoring my namespaces?
That isn't the question I asked.
Cool, thanks!
Dat line... so thick :/
I can only copy and paste ✔ I cannot type....
Yep, I'm completely aware how it works, just giving a heads up for a really common problem.
The unread message popup is [fucking awesome](http://imgur.com/b7Maqq2), kudos on that.
&gt; They surprisingly were not fond of all those OO APIs, either; they'd obviously preferred procedural APIs working with arrays (no pun). Or perhaps that the RFC pretty explicitly stomped all over the PSR-7 doc?
+∞ ... this makes me very happy. The popup when you go to downvote is particularly helpful. Thanks for the time that went into this :)
Love PHPStorm, thanks guys
Wasn't exactly like it is in Haskell
With a little shameless self-promotion, I'd also suggest [@securingphp](http://twitter.com/securingphp). It's a project with a Twitter account, a series of [ebooks and a weekly newsletter](http://securingphp.com) I've put together dealing with PHP-related security concerns.
Try Ratchet http://socketo.me/
Do you have this as a Laravel package? I only use Laravel packages. 
+1 for man / help syntax
with apologies to /u/PleaseRespectTables function （╯°□°）╯︵┻━┻(){throw new ┻━┻;} class ┻━┻ extends Exception {public function __construct() {parent::__construct("Please respect tables! ┬─┬ノ(ಠ_ಠノ)");} public function __toString(){return "table";}} // try/catch try { （╯°□°）╯︵┻━┻ (); } catch ( ┻━┻ $niceguy) {echo $niceguy-&gt;getMessage();} // ok now lets go （╯°□°）╯︵┻━┻ (); &gt; Please respect tables! ┬─┬ノ(ಠ_ಠノ) &gt; Fatal error: Uncaught table thrown in C:\inetpub\wwwroot\tables.php on line 4 
A man filled with the gladness of living Put his keys on the table, Put flowers in a copper bowl there. He put his eggs and milk on the table. He put there the light that came in through the window, Sounds of a bicycle, sound of a spinning wheel. The softness of bread and weather he put there. On the table the man put Things that happened in his mind. What he wanted to do in life, He put that there. Those he loved, those he didn't love, The man put them on the table too. Three times three make nine: The man put nine on the table. He was next to the window next to the sky; He reached out and placed on the table endlessness. So many days he had wanted to drink a beer! He put on the table the pouring of that beer. He placed there his sleep and his wakefulness; His hunger and his fullness he placed there. Now that's what I call a table! **It didn't complain at all about the load.** It wobbled once or twice, then **stood firm.** The man kept piling things on.
Yes, it is, but as always, don't trust any benchmark, you didn't fake yourself ;)
I may be very wrong about this, but I think you're going way overboard on the token generation. It doesn't matter how weak or strong a token is if that token doesn't exist in the database or session and/or doesn't line up with the user's ID (which is an implementation detail that your library doesn't - and shouldn't - provide anyway). A CSRF token is a one-time key - it's lifetime is too short to benefit from any kind of cryptographic security.
Leave it to IBM to take something good, and make it bad.
Fad? This is how things were done for regular websites before "web 2.0".. on any websites that weren't visually raped by EyeCandy 3.5 Fire plugin. I'm fucking blown away when I see dark backgrounds
&gt; With WP-API, you could get rid of all that PHP code, do less work on the server, and build the entire admin user interface in the browser with JavaScript. That might sound strange, but it’s how most modern web applications are built today. WordPress can adapt… again! *sigh* The major shortcoming of Wordpress is its terrible relational data structure for content. You can't just fucking shove everything into a table call `posts` and then a bunch of flex data into a meta table, and call it a day.... Working with data that doesn't fit Wordpress's confined, cramped little world is what makes working with Wordpress such a crotch ache... Of course, you can create whatever data structures you want in Wordpress, but then you have to interact with them via it's weird-ass PDO wrapper thing (and of course the API doesn't expose any meaningful ability to work with custom data). The real problem is that people think Wordpress is a swiss army knife, when in reality it's more like a butter knife.
The concept of "cognitive dissonance" comes up sometimes, and it's a bit hard to define, so it's nice to have such a perfect example. This is terrible, and in many ways indicative of the attitudes and skills of people who are "wordpress developers" as opposed to developers or programmers. They see WP's numerous flaws as assets, or at worst as PHP's fault rather than their beloved "CMS". &gt; The other night at WordPress Sydney, I couldn't honestly think of much I'd want to attend. WP developers are the lowest level of developers. WP developers are the PHP developers of PHP. :) &gt; It’s still here because it is a great product. No. It isn't. It's here because it fills a very specific niche, one that thrives on ignorance and ease of use, and one that doesn't in any way value code quality or architecture. It is relied on by people for whom it is **their only solution**, so every problem become a nail for wordpress. "It's a great, versatile solution for your CMS needs!" is actually that it's a terrible bit of software that can be warped to do anything if you're enough of a masochist. &gt; Suffice to say that WordPress has thrived on PHP’s ubiquity and ease of adoption, while suffering its mediocrity and recent (albeit now firmly interrupted) stagnation. I swear to god how *fucking dare you* criticise PHP's "stagnation" literally while singing the praises of the single most stagnant (widely used) bit of software in the entire ecosystem. When Wordpress supports Composer, autoloading, namespacing, when Wordpress requires a version of PHP from *the current decade*, when Wordpress implements a template system, when Wordpress moves to an OO architecture... then maybe we can talk. Until then the level of ignorance and arrogance displayed here is utterly staggering. &gt; Unless you’ve goofed something up, the slowest part of your PHP-based application should be PHP itself. This couldn't be more wrong. The bottleneck in your application is 99.95% of the time not PHP. It's almost invariably IO or DB access. He commented in response to /u/jtreminio to say the following: &gt; My comment on relative performance is unsourced because it’s experiential and, frankly, obvious: If you’re spending more time during each request doing database work rather than PHP work, then you’ve got a problem that needs to be fixed. This is utterly, utterly wrong. Dangerously, disastrously, concerningly wrong, and a woeful misunderstanding of how PHP performs, what is "expensive", and why. Connecting to a database and running queries is expensive. &gt; Such as… turning database rows into HTML while more database rows are coming down the wire. Which is pretty much what WordPress does. Among other things. Can someone explain this to me? Because it seems like complete shit. Wordpress basically runs a "while" loop over a database request. Can anyone explain to me how that's in any way like async programming? Am I missing the point, or is this guy just completely clueless? &gt; Based on the WordPress team’s conservative approach to PHP dependency updates Is there a prize for misleading spin? Conservative?! Archaic, outdated, and absurd would be better terms. The WP-API thing is something that's been talked about for ages, but... honestly. WP's architecture is so crappy that on any custom code... ie, anything that isn't just a blog, but uses custom fields, etc, is going to have shitty performance. The way WP joins its abstracted data out of the box is just terrible. What the hell does React have to do with Wordpress? I can only assume the the connection is that WP-API will work with React? But why React? Why not Angular? Or Ember? Or... weird thing to put in there with no connection to Wordpress. 
Fixed: https://github.com/beberlei/php-rfc-watch/pull/11
Done. Even better, we have relative times now: https://github.com/beberlei/php-rfc-watch/pull/11
I'm sure it's fast but that benchmark is not accurate at all. The ob_start() means the PHP one doesn't have to write to the output buffer until the end.
&gt; A CSRF token is a one-time key Most CSRF implementations provide keys valid for a reasonable lifetime with reuse expected. This is exactly the problem the BREACH attack on SSL exploited - continual provisions of the same key over modifiable cipher streams. [I wrote a long abandoned wordpress plugin to address this](https://github.com/technion/wp_breach_patch) but there was never any interest in it. &gt;if that token doesn't exist in the database or session They are assigning the CSRF token to the session. &gt;it's lifetime is too short to benefit from any kind of cryptographic security. If you follow a large amount of developers and use md5(time()) as your CSRF generator, the system is predictable and broken. 
Are you like... new to the internet? It honestly sounds like you got interested in ux/design maybe 4-6 years ago, and this is a huge jolt to you. Most of everything you're complaining about started with "web 2.0" and the only real tangible difference are the buttons and gradients.. they turned themselves into the new lens flare.
The problem is not with PHP or your PHP code. The problem is that query parameters need to be encoded properly. In this case the = and &amp; characters of the other URL need to be escaped.
Nope
I've started with this business over 24 years ago on a UNIX terminal. It was far more readable than the "flat design" fad. Also prettier, because at least it was not ugly.
I fixed it by using GET for the id as well, then adding the resturl . "&amp;id=" . GET .... but that's a bit ghetto.. would love to see it resolved with escape characters.. How would I escape the =/&amp; in this case?
What specifically do you have issues with ooi?
Sometimes when I pop autocompletion's documentation it steals focus and the only way to fix this is to restart PHPStorm, I hope they will fix it for phpstorm9
Thanks for addressing that. p.s. The drop shadow under the "compose comment" section also seems unnecessary: http://cl.ly/image/0n0t3C1E412X
Yeah, @securingphp is pretty good. :)
@ircmaxell I spent the longest time memorising your name ;). Almost as bad as mine!
Almost everything you mentioned, we're not doing.
I'm actually opposed with your post: I love the UI and feel that it was designed by programmers for programmers. The same goes for Clion and PyCharm, which I use extensively moreso than PHPStorm. Perhaps there should be more extensive customization options for the UI to suit everyones needs? 
These are very valid concerns. The problem with these kind of benchmarks is that there are too much variables to actually make them say something important. Any recent C compiler has a shitload of options to set, which all optimize (or not) a different part of the compiled app. Take a look at line 10 of the C program for example: double ci = x; We store a var that we already have in another var, for no reason other than to make the program a bit more readable. A lot of the compilers throw that out and just use x directly, but what if a certain missing compiler option does not? I know that this little example would not make much of an impact, but there are just so many little differences that you can tackle specifically in a language.
Well many developers have been able to play the same trick to simulate PHP enum, so the approach is not really fascinating honestly. A really worthy topic for Enum is when someone writes some native C code that enables us to create enums in natural way, like this: https://wiki.php.net/rfc/enum For some reason, that RFC was inactive and no one seemed to be proposing it. 
Of course they're not safe. We're *not* going to allow a discussion on pirated software on this sub.
Will I use it? define('unlikely', !(bool)rand(0, 10)); :) 
Nope. This experiment was done at the end of last year, and found while interesting, not feasible in the short term. The statements about the experiment and how it 'showed' that JIT couldn't take advantage of knowing the type of a variable to make optimizations were done in the past two weeks. They made those statements to try to shut down an argument in favour of strict type hints, and so they were either doing so with full knowledge that they were being misleading, or they don't know the difference between JIT or AOT.
Ok. I wasn't trying to argue, just throwing out another scenario, but it sounds like you've been following things a lot more closely. 
Ah.... I missed that part when looking at the examples. Oops. :P But then, you lose a lot of the type safety if you don't allow instantiation, as you can't type hint arguments for the enum.
For what it's worth, Facebook used to do something similar until first-class enum support was added to HHVM. 
Not if you can easily predict them. 
Thanks. One last tiny detail: The top right corner of the main area doesn't seem like it should be rounded: http://cl.ly/image/060e0c0N0J1E
You win it back by doing the assert on line 1 of the method. I feel that it's a smaller conceptual compromise than making the enum be both the value and the container for all values. None of the enum packages I've seen share my belief, hence "another PHP enum package". Not having the enum instantiable also makes it easier to use within Drupal and Doctrine, cause the ORM doesn't need to care about the enums at all. (Though that can be worked around, of course, and Doctrine 2.5 has value object support).
I stay on top of PHP7's status a LOT, because it *will* be a large percentage of my income in the [near?] future. **This is absolutely the first time I have heard it is not a Just-In-Time compiler!!** I have been hearing for *months* how they've been working on the JIT engine for *months*, even in secret (remember *that* controversy?). About how it was going to be equivalent and better to HHVM's JIT. Now you guys in php-internals are telling us, "No no, we never said JIT"???
You don't need a cryptographically random string to make it difficult to predict.
&gt;&gt;&gt; [Core Engine Dev]: JIT integrated into opcache, it compiles php script(s) of first access and stores code in shared memory. &gt;&gt; That sounds more along the lines of AOT like I did with Recki rather than a true JIT (which compiles when a function is called). &gt; [Core Dev]: So yes, our JIT uses some kind of AOT approach, but completely transparently for the rest of PHP. So. Doesn't sound like he knows what a JIT is, *and* it sounds a lot like (the same as?) how APC works... Right?
I've been reading OWASP and on best practices in general lately and your library seems to cover a lot of what I've learned. Thank you, I'm gonna try it later.
If you stay on top of internals you probably know that internals is somehow divided between Zend and the unpaid volunteers (which do a lot of the work). As far as we know Zend kept it secret (besides some teasing) from the rest of internals (a substantial part of PHP-core) until today. So stop being a goddam drama queen for one second here and if you really have to be a drama queen at least stop generalizing, only Zend is at fault here. They've never promised (and it was never planned to have) a JIT-flavored PHP-7 *release*. PHP-NG is what was meant to be PHP-7 all along.
Do people confuse the two? One is for showing you're human, the other that the request came from the right source.
And of course the thing I just typed up disappeared... Anyway, surely this is perfectly fine: function random($length = 128) { $alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; $random = ''; for($i=0; $i &lt; $length; $i++) { $index = mt_rand(0, strlen($alphabet) - 1); $random .= $alphabet{$index}; } return $random; } That, combined with: 1. Generate the token ONLY on a form request 2. Tie the token to both the user, and form (no unbounded usage of that token) 3. Destroy the token the instant the form submits (whether it passes or fails) 4. Expire the token after 10 minutes (unless it's one of those mile long forms...) And I don't see why there needs to be emphasis on cryptographic security. CSRF defense is 90% how you apply it, and 10% how random the key is...
Sounds cool, but have you actually gone through my list to back your "almost everything"? The PHP theme is doing points number 1 (margins) thoroughly between posts, 2 (no contrast) big time, 4 (lack of UI elements and 3D) slightly, 5 (ugly geometric icons) big time and 6 (uppercase) in the header.
Yep it's all good material, as a pen tester it's always bothered me that PHP doesn't take security seriously ( search shell_exec on githup ) and look at all the unsanitized input. I'm very familiar with the content on OWASP and I really think this guy has his shit together. Certainly worth reading. Edit: And I want to add that I like PHP a lot, I'm not bashing the language it self.
Hey that's the first time I've seen an implementation that I kinda like!
It's pretty easy to achieve transparently using [mysqlnd_uh](http://pecl.php.net/mysqlnd_uh). I wrote a blog post on this [here](https://blog.engineyard.com/2015/writing-custom-plugins-for-php-mysqlnd). Otherwise, you'll need to somehow replace all calls to your MySQL extension with something else. If you're already using something else, look into extending that. It's also pretty trivial to extend PDO directly to do this, but you didn't specify which extension you were using.
Looks good!
If you use [Doctrine DBAL](http://www.doctrine-project.org/projects/dbal.html) -- you can use their built in [logger](https://github.com/doctrine/dbal/tree/master/lib/Doctrine/DBAL/Logging). Same story if you use their [ORM](http://www.doctrine-project.org/projects/orm.html). Here's an example: use Doctrine\DBAL\DriverManager; use Doctrine\DBAL\Logging\DebugStack; $conn = DriverManager::getConnection([ 'url' =&gt; 'mysql://root@localhost/some_database', ]); $logger = new DebugStack(); $conn-&gt;getConfiguration()-&gt;setSQLLogger($logger); $conn-&gt;fetchColumn('SELECT 1'); $conn-&gt;fetchAssoc('SELECT 1'); foreach ($logger-&gt;queries as $query) { echo $query['sql'], PHP_EOL; }
I hope this RFC passes. This would be huge for PHP7.
You can also turn on query_log in mysql itself in order to log all interactions.
I will use this in my code from now on. It's even better than the link.
I really like how enums implemented in go, wish that got added to php.
"PHP currently has around 64 globally reserved words" &lt;-- this is a huge "WTF". wonder why the haters dont use this argument against php.
What's the downside to this. Seems like a pretty big win? I don't understand parsers and lexers, is this a performance issue?
It's not overly large compared to other programming languages * Python: 33 * Ruby: 37 * Java: 50 * Javascript: 36-60 depending on the standard * C#: 79 * C++: 84 And the number itself is less important compared to what the reserved words actually are (it's not like anybody is jumping to use `reinterpret_cast` or `endforeach` for example)
lol great minds? I missed ruby and javascript... idk how.... Or even C#... 
It's actually not.
RFC author here. The issue is indeed not related to the number of reserved words itself but the usefulness that some words might have on userland code :) Also when comparing and counting reserved words lists from other languages go check if they are **globally reserved** or just **contextually reserved**, this makes a huge difference and might vary for each language implementation.
http://www.reddit.com/r/PHP/comments/2xinw1/voting_started_on_rfc_context_sensitive_lexer/cp0lf6f
It gets to the point that the whole "PHP sucks" thing gets so diluted that people just start making shit up.... messy? Confusing syntax? Old? This is getting ridiculous.
Can we brigade the thread with pro PHP talk? (Only kidding. I saw that thread early and left after seeing the antiphp circle jerk).
I would like to know, too. Why would this possibly *not* pass?
http://php.net/manual/en/class.splenum.php
Those concerns came from /u/nikic, and given that the RFC credits him with assistance, I expect that those concerns are resolved. 
It sucks because genuine and positive criticism of PHP's legitimate flaws gets swallowed up in FUD. This often makes us reactionary to all (rather than just poor) criticism. 
&gt; They collect 1000's of tokens Only takes 624 outputs to fully recreate a mt_rand() stream and predict it indefinitely :) 
That's not php not taking security seriously. That's php devs not doing it. Php offers all the tools you need to secure your exec calls, and those you need to execute raw calls when you need them. If some people can't or won't educate themselves on the difference, then they wouldn't do it in another language either 
Others already answered what it is, just thought I share my screen whilst debugging an application in Laravel: http://i.imgur.com/hYVkUyE.png At first I was confused because I haven't seen this feature before. But only a while into debugging I found it very useful.
Yeah, thanks, didn't realize that! For everyone else interested, here's the final mail prior vote on that decision by the RFC author: https://marc.info/?l=php-internals&amp;m=142465079503782&amp;w=2 . I think this proposal is great with no drawbacks.
is this blue and black, or gold and white? but overall, nice theme! inlining with the php doc theme (y)
Usage of PHP 5.2 is down to 16% from 32%. It's still quite a bit, but these data are far more reasonable. ...on the other hand: &gt; One-sixth of all sites running PHP 5.2 is still many millions of sites. If we move the PHP minimum version too early, we risk stranding millions of installs on older versions of WordPress. &gt; &gt; So, I wish to note that this does not change our calculations for keeping PHP 5.2 as the minimum for WordPress core — we had these numbers available to us when preparing our 2015 plans. 
Unfortunately, SplEnum lives in a PECL extension.
Now you have the right to vote on every upcoming rfc
eh? why -1 for derping myself? O__o should get more points for solving my own problem and admitting I messed up lol
pecl_http is not only a client.
This is old news - people were face palming to this on twitter late last year. Still, it nicely shows that as far as software development goes - IBM circa 2015 sure do make great salespeople :)
&gt; If we move the PHP minimum version too early, we risk stranding millions of installs on older versions of WordPress. Seems like a very tenuous excuse. a) if they increased the minimum version I bet you'd see hosts follow suit b) there's nothing stopping them from raising the minimum version and backporting security fixes
I'm loving it.
Urgh! mysql_*? It's deprecated in PHP 5, with big red notices everywhere and removed in PHP 7!
Well, one has a for-loop, a chr() call, string concatenation and the other doesn't. Think maybe it can impact your benchmark? 
Reddit's large enough now that the admins really, really don't want to go around building custom configurations for specific subreddits, unfortunately.
I'd love to see how it works on other peoples' devices/OSes. Maybe in some setups mt_rand() is faster.
Also not to be picky, but you don't put if(function exists) then (do something else) in your benchmark code and expect people to run the code unknowingly testing some other method then yours and getting different results.. 
Are they really more complicated? I mean, you can use reserved words now in some cases (e.g. variables like $foreach), this RFC pretty much just allows some more (e.g. class methods).
It's at least a bit more complicated - exactly how much I can't say accurately. Although being able to use those keywords would be 'nice' it's not the most important thing ever, and so this change shouldn't be done just automatically.
Wake me when wordpress starts doing something like cleaning up their shitty codebase, or adopting modern coding practices.
Enjoyed some of the site. Downvoted though cause this ain't anything to do with PHP. Try /r/webdev.
Thanks. 
So. Everyone is speechless.
That's pretty much not going to happen without breaking backwards compatibility, which is one of its best features.
Lol it's so funny I need to find more of these!
There comes a point where you need to stop and decide what's really important. Having a maintainable codebase, or having a codebase which runs a bunch of old plugins, most of which are really badly made.
It's not only the plugins but also the themes. I know the core wp developers know how shit the code is but they have to live with their past decisions.
You could check PHP version before you do any plugin loading, and if the user is on a version that isn't 5.4+, you just offer a message explaining why yours won't activate and how to possibly get their hosting upgraded.
Everyone is sleeping or doing something else because it's Sunday morning.
/r/shittytumblrgifs/
It would be nice if the library was actually free. Seriously, the AGPL?
Of course, but people have cited it as a performance concern. Others have cited it as an entropy draining concern; allegedly, if you read a lot from /dev/urandom, processes that seed from /dev/random will block more. This sounds to me like a kernel bug.
Step up! In your WP plugin "index" do this before calling any other code: $plugin_minimum_php = '5.6.0'; function _plugin_minimum_php() { global $plugin_minimum_php; echo '&lt;div id="message" class="error fade"&gt;&lt;p&gt;'; printf( __( 'Plugin will not work with your version of PHP. Plugin requires PHP version %s or greater. Please upgrade PHP if you would like to use this plugin.', 'plugin-namespace' ), $plugin_minimum_php ); echo '&lt;/p&gt;&lt;/div&gt;'; } if ( ! version_compare( PHP_VERSION, $plugin_minimum_php, '&gt;=' ) ) { add_action( 'admin_notices', '_plugin_minimum_php' ); return; // Exit gracefully } Notice that I could have used an anonymous function that used() the $var instead of this global using atrocity, but didn't because that would break on PHP 5.2 which is supported by WP, so I wrote this on purpose. :(
I'm not sure I'm following here. Is openssl_random_pseudo_bytes alias for mcrypt_create_iv or both have the exact same code? if so, ignore my last comment.
What makes it more complicated to use?
You're checking whether $_POST is empty or not, but you're not checking $_POST['username'] and $_POST['password'] before using them. This allows the user to trigger error notices. It's not a huge deal, but bad practice. The "wrong username"/"Wrong password" messages makes it quite easy to leak user info. I can check if someone has registered simply by typing in their username. It's better to have the error say something along the line on "Wrong username or password". mysql_query()... yeah... no... wat. md5() terrible, but not using salts is unacceptable. You're querying the same database row four times. That's insane... Pull all the info you can get at once, and then check the data. In "Registration Form and Validation (Part 2)", the validation is terrible, as you're iterating over the supplied POST values to make sure they're not empty. This can be easily bypassed by simply removing elements from the form. Do it the other way around. Iterate over the required fields, and make sure they exist in $_POST and are not empty. md5() is not encryption. The email activation code (username + microtime) is waaaay too easy to guess. Better randomness is required here. An don't include the email address in the activation link. User settings and profiles are vulnerable to XSS... (Actually fixed much later in another video) Again, you're redundantly querying the same database row three times on the profile page for no apparent reason. The password recovery is very very bad. It allows a user to reset anyone's password, without email verification. And the random password generation is even worse. Don't ever email out passwords, even temporary ones. Instead, send a unique link to the user and have them set a new password on your website. File name generation for profile pictures (md5(time()) is not good enough, as users can upload images at the same time, and thereby override other's images. 
Well, he began this thread with "I wrote an RFC ..."
Thanks for the clarification.
"I don't always code PHP, but when I do, I make sure I'm *well lubricated* for the job!"
I love you so much right now.
This sounds great. I would love constructors to throw exceptions instead of returning null
Hey, better Dan Ackroyd than Michael Bolton.
Note that that's Automattic and their wordpress.com service, not WordPress as a whole which is also a standalone application that many people install on their own hosting accounts and see zero of that reported income.
Try using both of them and you will find out :) Seriously boris or my preference psysh are a lot better than php's interactive mode.
Code maintenance. You don't know the process of the plugin into the future or how many times you'll need it. Much better to establish variables at the top, if the value isn't a 1 or 0.
WP core devs can't be held responsible for the PHP code used by 3rd party plugins, which are the actual source of most of those security issues.
doesn't that get tedious? no history/variables, have to echo what you want to output, and have to wrap it all in quotes every time check out http://psysh.org/#features and https://presentate.com/bobthecow/talks/php-for-pirates for a similar alternative either better than php -r or R
#sadpanda 
I think the downvotes were from people who didn't get the Office Space reference.
I have been working from a plugin skeleton for the last week, and that has something very similar. It takes a wider view and defines a "validate_dependencies" function for looking at *any* dependencies that the plugin may need. This includes the PHP version, maybe curl and XML extensions, other plugins that may need to be installed too. It's probably the way to go. Once you have your little library of checks, you don't really care if it involves a few extra lines than is absolutely necessary; it is readability, flexibility and reuse that trumps all that. Reuse especially, because you only want to find a bug once, fix it once, then replicate that fix across everywhere it is used. Oh, composer spoils us...
Lord Salathe: instead of crushing souls with you infinite php wisdom, why don't you just bless us with an ounce of your superpowers :/ 
&gt; As Matt shared at WordCamp San Francisco in October, we’re engaging individual hosting companies to move sites to the latest versions of WordPress, with a secondary focus moving sites to PHP 5.4+. How about 5.5+ ? Until they will start to see some movement in that area, PHP 5.4 will reach EOL. Ah, secondary focus .. right.
[Here you go](http://www.securityfocus.com/cgi-bin/index.cgi?o=0&amp;l=30&amp;c=12&amp;op=display_list&amp;vendor=WordPress&amp;version=&amp;title=WordPress&amp;CVE=). I could probably find more if I cared to, but that should get you started. If wordpress were actually using best practices, it wouldn't work with php 5.2.
You're right, they can't. However they *can* be held responsible for the multitude of vulnerabilities in the wordpress software that continue to pop up year after year. Believe me, there are *tons* of them. Moreover, they *can* be held responsible for the automatic installer which showcases a number of horribly written plugins that they host. These allow clueless users to blindly install potentially harmful things. These have no quality control whatsoever. Given that wordpress is one of the most used php projects in the world, they really have a moral obligation to police that better. When something raunchy makes it in to the IOS or Android store we scream bloody murder. When it's a wordpress plugin, we go "meh, par for the course". Does this seem right to you?
This indeed needs some care to do right. That said, PHP's serialize/unserialize will work in such cases just fine (serialized data in a cookie), as long as you, say, HMAC and verify the MAC correctly. As an example, [TCrypto project](https://github.com/timoh6/TCrypto) I maintain sticks the data (by default) into a cookie using PHP's native serialization (or optionally igbinary). For some more use cases and information and pros/cons about storing session data into a cookie (using TCrypto) there is this short websec.io article: http://websec.io/2012/08/29/TCrypto-Encrypted-Data-Storage-for-PHP.html
And they take care of those once reported. Edit: Are these "tons" of bugs things that exist because there is code written, or because of something specific to 5.2 that is fixed out of the box in a future version? Which plugins are they showcasing that you have in mind that are part of a problem?
The internal application state should not be handled on the client-side at all. I find the conversation the github issue appalling as they seem unwilling to fix the problem, citing scaling concerns which could trivially be handled through other means. 
Hey there. I know WP has a bad and outdated reputation, but you might be surprised if you take a second look. The site you listed isn't very good. Most of the links have no information in them or are terribly outdated. http://www.securityfocus.com/bid/64564 In fact, the site only listed 10 vulnerabilities from all of 2014, and of those listed, updates were promptly released. http://www.securityfocus.com/bid/69096/exploit This one even says an update is available even though there is no known exploit. http://www.securityfocus.com/bid/72589/exploit The most sourced vulnerability DB I've seen is the National Vulnerability Database. If you read through it, seemingly every 'WordPress' vulnerability is actually a poorly written 3rd party plugin, with an SQL or XSS vulnerability. These vulnerabilities are the responsibility of the 3rd party dev and is a concern for any web application, not just PHP or WP. https://web.nvd.nist.gov/view/vuln/search-results?query=wordpress&amp;search_type=all&amp;cves=on Core WP is incredibly secure and gets an unfair amount of judgement using outdated and incorrect information. 
Those voting in opposition might want the feature, but disagree with how it was implemented.
I know they do something similar with WP version. If I have 3.8 installed still somehow, and I have a plugin that gets moved to a minimum of 4.1, I don't get an upgrade notice for that plugin until I upgrade WP core to 4.1. I'd support a similar thing in the plugin header details.
It already throws an exception with `new stdclass` in place of a filename. It's pretty much only excess parameters that put it in an unitialized state. Keeping it in line with core functions doesn't harm anyone. What's the practical use case that would warrant an exception there? Who would ever construct it per `ReflectionClass("Phar") -&gt;newInstanceArgs($_GET);` or suchlike?
Thank you I was looking really hard at that quote and couldn't find the joke…
&gt; openssl_random_pseudo_bytes alias for mcrypt_create_iv Neither function is guaranteed to exist - nearly every implementation anywhere checks which, (if either) of these functions exist. 
&gt;A single function call is overkill. It is much better to use a for loop that repeatedly calls a shitty function and concatenates results I don't follow the argument
&gt; Speed isn't a good argument one way or the other As proven by the fact that it's faster, simpler and more secure having no bearing on people still preferring mt_rand(). 
I feel obligated to also add my own code to that list. https://github.com/technion/matasano_challenge/tree/master/set3/chal23
&gt; mt_rand too? mt_rand() has a defined, consistent output. A different implementation is broken. 
For all I know, the session ID has to be stored on the client anyway (using GET/POST parameters or cookies). Thus, at least some part of internal application state always needs to be handled on the client. Rails actually stores the session data in cookies by default since Rails 2 ([see](http://guides.rubyonrails.org/security.html#session-storage)). The session content gets hashed together with a secret key (disabling manipulation on the client, but enabling to see session contents). Since Rails 4 the session content also gets encrypted (disabling manipulation also)([see](http://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html)). I think this a pretty neat way to handle sessions, however I feel like the content should always be encrypted on the client. Also frameworks should implement other cookie storage methods (opt-in). Iirc both Laravel and Symfony have multiple storage methods but default to the native php session storage. Edit: Linebreaks
&gt; processes that seed from /dev/random will block more. This sounds to me like a kernel bug It would be a bug in that program. No user-space application should ever be reading from /dev/random, specifically because it can block, and it presents a DoS issue for that application. The random(4) man page even tells people not to use it for this reason. Have you ever generated GPG keys and not had it just sit there blocking on entropy, asking you to type some random key strokes? That's because it generates keys from /dev/random, and the entropy required for one set of keys is enough to make it block. You can tolerate it there, and it blocks literally every time, even when the server isn't doing anything else or consuming entropy in any fashion. OpenSSL uses /dev/urandom to generate SSL keys precisely because it doesn't block, and you can't have web users just waiting for a server to gather entropy. That's never been considered a weakness. Rails uses /dev/urandom for tokens and keys. Android applications written in Java use/dev/urandom, for things like Bitcoin keys. There's literally no legitimate reason to be using /dev/random, yet people do, for no apparent reason other than introducing this whole "muh system drained its entropy" argument.
This brings up a question that's been nagging me for a while. Now that PHP has a spec, is compatibility across minor/patch releases guaranteed for the spec or the implementation?
This. PHP, the language, *can* be compiled to machine code (see phpcompiler.org + the recent JIT announcement + /u/ircmaxell + HHVM). But PHP is nothing without its runtime. It's like C without the stdlib, it can't do much; You have to write a lot of boilerplate code to even print something on the screen. But if /u/ircmaxell do write a compiler that creates C extensions from PHP code I can see a future where a lot of new PHP features that do not affect the language syntax itself (eg a BBcode/Markdown parser or a template engine) will be written in PHP and compiled to an extension.
Heh, their switch to OpenSSL mirrors a change I made to defuse's library. ;) https://github.com/defuse/php-encryption/pull/33 Gains: PKCS#7 padding by default, access to AES-GCM, AES-NI if they're available... Losses: Dependency on an abandoned library. Oh wait, that's a gain.
Not [strictly true](http://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29). Besides, PHP is not an interpreted language, it is compiled. This is an exceedingly important distinction to make. Yes, the compiler doesn't emit native machine code, but there is a compiler none the less. And every single operation that the VM uses could theoretically be replaced by emitted machine code. Take a look at [Zend's "JIT" compiler](https://github.com/zendtech/php-src/tree/zend-jit/ext/opcache/jit) which totally is not a JIT compiler, but an AOT compiler. And it does exactly that, it generates native machine code instead of VM code (but with identical semantics). So if we take a compiler written in PHP ([Recki-CT](https://github.com/google/recki-ct) or [PHPPHP](https://github.com/ircmaxell/phpphp)), we can use it to compile itself. Which means that once we get it bootstrapped once, we no longer need the "interpreter" (virtual machine). So very much not this.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bootstrapping (compilers)**](https://en.wikipedia.org/wiki/Bootstrapping%20%28compilers%29): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __bootstrapping__ is the process of writing a [compiler](https://en.wikipedia.org/wiki/Compiler) (or [assembler](https://en.wikipedia.org/wiki/Assembly_language#Assembler)) in the target [programming language](https://en.wikipedia.org/wiki/Programming_language) which it is intended to compile. Applying this technique leads to a [self-hosting compiler](https://en.wikipedia.org/wiki/Self-hosting_compiler). &gt;Many compilers for many programming languages are bootstrapped, including compilers for [BASIC](https://en.wikipedia.org/wiki/BASIC), [ALGOL](https://en.wikipedia.org/wiki/ALGOL), [C](https://en.wikipedia.org/wiki/C_(programming_language\)), [Pascal](https://en.wikipedia.org/wiki/Pascal_programming_language), [PL/I](https://en.wikipedia.org/wiki/PL/I), [Factor](https://en.wikipedia.org/wiki/Factor_programming_language), [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language\)), [Modula-2](https://en.wikipedia.org/wiki/Modula-2), [Oberon](https://en.wikipedia.org/wiki/Oberon_programming_language), [OCaml](https://en.wikipedia.org/wiki/OCaml), [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp), [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language\)), [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Scala](https://en.wikipedia.org/wiki/Scala_(programming_language\)), Nim, [Eiffel](https://en.wikipedia.org/wiki/Eiffel_(programming_language\)), and more. &gt; --- ^Interesting: [^Jikes ^RVM](https://en.wikipedia.org/wiki/Jikes_RVM) ^| [^Bootstrapping](https://en.wikipedia.org/wiki/Bootstrapping) ^| [^Self-hosting](https://en.wikipedia.org/wiki/Self-hosting) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cp1akkl) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cp1akkl)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; we risk stranding millions of installs on older versions of WordPress. Good. Let them be stranded. For starters, anyone dependent on Wordpress for a site doesn't have absurd amounts of shit to port - it's a Wordpress site afterall, it's very likely a small site. If it's a big site, they didn't get big by being on Wordpress alone - after 6 years, they've probably gone through a fair amount of core hacking and/or are relying on plugins that are not going to be compatible with newer versions of Wordpress anyway, so they simply can't upgrade with a pretty heavy rewrite, even if they wanted to. Third, if they have been keeping up to date this whole time, then it's really a non-issue. They've at least got the latest version which should last them quite some time.
The idea that anyone still does this is just baffling to me.
I assume you meant to reply to the parent comment?
Totally disagree. 100%. Yes, it's completely fine to store state information in a cookie. `serialize()` here is the problem, not the "internal application state should not be handled on the client side at all". Stop using serialize. Start validating. But if you want to encode state in a JSON token, go for it. And the thought about using an encrypted JWT sounds like a pretty good idea (one that I know more than one system is using).
Ehm. Okay, so it's a warning. But again, how realistic are constructions with arrays or empty objects? Is this a thing? &gt; Using the squelch operator to just disable the warning That's not what it does. It just disables their display. In the *default* error handler.
Something to keep in mind, a lot of those listed affected releases are not recent. WordPress doesn't do semantic versioning, so 3.3 is considered a major release, and not a security fix. 3.3 was released on December 12th 2011, with 4.1 being the latest this past December
&gt; how realistic are constructions with arrays or empty objects? Never. The Phar object should never be constructed with anything other than a string as the first parameter. Which is why the RFC wants to make that throw an exception, rather than having a Phar object that is an unusable state.
Sounds like you just don't know security very well. Signed cookies present no security risk as long as you aren't storing information meant to be secret (e.g. server secrets). Storing session state on the client is a great idea in many cases. Also, in case anyone is still under the impression that signing cookies is hard, hash_hmac makes it absolutely trivial.
Regarding the second part of your answer, IIRC, HHVM supports that, i.e. some of the userland is actually written in PHP and gets compiled at runtime.
Do you recall where the performance discussion may have taken place?
Sigh, about 2 years ago I learned laravel 4 instead of laravel 3 even though there was like 5 total tutorials out at the time. I look at this and even my small learning is already behind a new version... :(
Fyi, there are a large number of typos throughout the RFC. Good proposal though. Hope it passes!
Your point about session forging is moot since I specifically said that **signed** cookies present no security risk. If you've signed your cookies, it becomes impossible to alter the cookie without the secret key used to sign the cookie. Basically it works like this: 1. Generate your cookie contents in PHP 2. Convert the cookie contents to a string 3. Generate a cryptographic signature of the string using a secret key only the server has (for extra security, you should absolutely include an expiry date in the cookie before it's signed) 4. Append the cryptographic signature to the cookie Then when you reading the cookie you basically do this: 1. Read the cookie string 2. Split the signature and the rest of the cookie into separate variables 3. Generate a cryptographic signature for the cookie using the secret key, just like in step 3 above 4. Check the expiry date, if it's expired, discard the cookie 5. Compare that signature with the one attached to the cookie, if they don't match, the cookie is invalid and should be discard Assuming your secret key is a decent size (say 128-256 bits), nobody is going to crack it with modern computing power. As for user ids, I don't really think exposing them is a big deal, assuming you're signing requests to prevent forging user ids, but there are various common and well documented techniques to avoid it (e.g. private and public user ids, encrypted user ids, stuff like that). Basically, stop storing session state in cookies unless you're going to do it right.
&gt; I wouldn't be able to call the isPerfectSquare() method on a string, would I? I guess you would start seeing $number-&gt;coerceFloat()-&gt;isPerfectSquare() on the outer layers of your app. But yes, you do lose the native coercion that a lot of developers depend on. 
Also, since you primarily discuss problems with improper implementations, it seems like a silly argument. You don't see people often argue against accepting ANY user input because most people can't be trusted to safely handle user input. Instead of telling people not to use a perfectly valid technique, tell them what mistakes they should be avoiding. Or stop using shitty frameworks that can't do security right.
Cool. Yeah, I agree with what you're saying, I just don't think you should have generalized it. Doesn't really matter, I'd rather people avoid it all together than attempt it incorrectly.
TL;DR they're wild but usually require installing extensions/recompiling PHP. Other downsides cross-over with the downsides of modifying prototypes in JS. It might interest you to read a book I wrote (https://leanpub.com/typedphp) on exactly this topic. Feel free to dm me, with your email address, if you would like a free copy.
I wonder if the increase from 5.x to 7.x is the same as what would be lost going to scalar objects?
It's actually quite fast. And from what I've seen on linux, 9 is faster and smoother
Well I agree that having them as extensions sorta kills the purpose of using scalar objects in most projects as it stands now, from a developer's point of view of course. However, if scalar objects are built into the core of PHP, the situation can be different. Its a long way to go till this happens, but I do believe it will in future, maybe in PHP 7.1, 7.2, 8.0 or even 9.0, but it will get there. 
I was wondering the same thing. Seems like the perfect opportunity to attempt this feature again.
Every since his appearance with The Lonely Island, Michael Bolton is cool with me.
Thanks, it should be fixed now. I'm not a native English speaker, so reviews are helpful.
Have a look at http://securepasswords.info/php/
Ok I can probably help out a bit on this, I setup the userland implementation you linked to above and started working on the implementation here: https://github.com/rossriley/scalar_objects (I've put the project on hold until PHP 7 is nearly ready because of the major change in internals ) I've only been able to run a crude non-scientific benchmark together since I only got to implement a few basic methods but generally I'm not thinking that there's going to be any performance impact and if so it will be very minor. The opcode check which can be found here: https://github.com/rossriley/scalar_objects/blob/master/scalar_objects.c#L158 may add a very tiny overhead but this is balanced out by the fact that once you know exactly what type of scalar you have received (eg string, array, bool etc.) then you can also skip a few of the argument checks that normally verify what arg you have passed to an internal function, so this part could be theoretically quicker. Once the extension was installed this meant that on 10,000 runs of the array count call, the scalar object version was very slightly quicker, so on balance I think the performance will be very similar. Obvious disclaimer to this is that I haven't had a go at getting this working on PHP-ng so this may affect the outcome. 
he's referencing Office Space
It's not your English. This appears to be a domain specific problem. I'm a native English speaker, and even after reading the Wikipedia description, all I'm thinking is that it's a topic none of my classes happened to cover.
Here is the Firebird adapter https://github.com/ksideks/yii2-firebirddb
Can we maybe have a more differentiated view on these aspects? **Stop using serialize** Yes, everyone can agree that using unserialize on data from an unsafe source is a bad idea, even if you validate it someone might tamper using hash collisions. **storing session data in a cookie** This is controversial for a good reason, but in the end should be decided on a per case basis. is_admin -&gt; do not do this selected_locale -&gt; why not? this leads to the third aspect: **Framework Developers** If you are giving lesser educated developers a tool to store session data, make sure your APIs explain what they do, and give the user (-&gt; developer) the information needed to make to correct choices where to store what data. 
I guess our opinions of where to draw the line are different, at least in this case. Not that there's anything wrong with that.
How are you comparing the hash? Are you using == or === ? If so - congratulations, you're now the proud owner of a timing attack vulnerability. This is why security is hard, and we need a set of good, well audited libraries for people to use. PHP 5.6 made it a bit easier with hash_equals, which is a constant time comparison function.
Something like this? &lt;?php $datenArray = array('20.12.2014', '12.4.1999', '7.9.2025', '25.2.1972', '13.3.2033', '5.5.2005', '13.9.1872', '1.3.2017', '13.3.1615', '1.9.2033', '20.12.1972', '2.3.2033', '1.1.1999', '1.1.1615', '20.02.1972'); $newArray = []; foreach($datenArray as $date) { $parts = explode(".", $date); $newArray[$parts[2]][] = $parts[0] . '.' . $parts[1]; } var_dump($newArray);
sup /r/php--don't know much (read: jack) about the language. came here for some quick help. all i need is a script that will advance either a series of strings (or go to the next page in a series, either will work though i prefer strings to keep things simple[?]) whenever the user clicks anywhere on the page. the only elements on said page will be a string of text. can anyone help a guy out?
You should add some tests...
I think he's one of those "parody" accounts that just posts other people's jokes
Since the posts were deleted I can only assume the topic was about storm being slow. If that's what it was about then I have to agree, but only for the first time something is to be shown. Storm loads slow, and menus load slow, but once it's done it's done and it's all gravy from that point on. And, while I'm on the subject of Storm, instead of me making a thread just for this... is the todo panel broken in the 9 EAP? I get an exception in the event log and nothing in the todo panel. edit: nm, I just noticed it's already listed in the release notes that they broke the todo panel.
Bookmarked. /u/ircmaxell's talk on compilers was interesting, even if 90% of it went clear over my head.
&gt; Can you elaborate on why they are brittle? Alright, sure. While the problem *mostly* goes away with type hints, some variable you expect to be a string might actually be an integer or float, or vice-versa, because of PHP's type juggling. That'd make the method call fail, unless we supported string methods on integers and floats.
Just a week ago [I was ranting about the state of statistics libraries for PHP](https://pay.reddit.com/r/PHP/comments/2wzun0/rant_the_statistics_extension_is_so_bad_it_has_a/), and you're working on this. Good job.
&gt; This is the sort of occasion where I wish we didn't have an RFC process for every little thing. I would agree except that the main author and maintainer of the intl extension, which is where most of the majority of classes with this behaviour live, is ___still___ arguing that returning null is a good behaviour. 
An interface is basically a blueprint for a class. If you make a class which uses (implements) that interface, then you're saying the class must conform to the interfaces' rules... eg, pretty much just have the same methods as the interface. It's just a way of enforcing rules really.
Wow! Thanks. That helped a lot!!
Right. Well nevertheless, you'd rather use a non-integer index labeling.
Obviously not, it's well known that you must use a constant time algorithm to check these things (which I probably should have specified). I agree, security is hard, but that isn't a reason not to store session state in cookies. Just use a well audited library as your base, like you say.
Stick to the PSR-4 autoloader specification. You don't need to have includes all over the place. http://www.php-fig.org/psr/psr-4/ Here you can see some example implementations of the PSR-4 autoloader: https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md
&gt; and give the user (-&gt; developer) the information needed to make to correct choices where to store what data. Do you think the information will be enough ? What about those developers who are susceptible for mistakes, like beginners (_in PHP and/or specific framework/library_) ? Would not be better if besides the information, the defaults will enforce some good practices and if someone has a more specific use case, (s)he would need to do some extra work in order to achieve that ? If something goes wrong, at least you can't be blamed. For example, in a REST client, you could expose a `-&gt;get()` method which enforces some good practices for the transport library and if someone needs to change those settings, (s)he will need to get the transport library instance and alter the settings (_that extra work I was talking about_) before executing the get request: `-&gt;getHttpClient-&gt;setConfig(/** something */)`.
Just because your code has a class does not make it OOP. What your idea would do is basically namespace your procedural code. Learning about the concept of OOP takes much more than simply adding a class everywhere. I would highly recommend you read the book [*PHP Object-Oriented Solutions* by David Powers](http://www.amazon.com/PHP-Object-Oriented-Solutions-David-Powers/dp/1430210117) to get you started.
This didn't seem like a very modern or exciting deployment from the headline -- it might have been interesting to hear more about the challenges of migrating a big legacy environment and less about a move to a single Wordpress. That's an odd CMS to *continue to use* at all for a new deployment on such a big magazine, since 90% of the codebase are kludges and implementations of patterns that may have been necessary to compensate for PHP's shortcomings a decade ago. The part I did find interesting was given just one bullet at the bottom, which is the planned move to ReactJS. I've moved PHP CMS based sites to use ReactJS for its views before, and it actually works extremely well -- PHP's always meant to be a thin wrapper around some C functions for grabbing data from one place, applying some business rules, then giving it to another. Instead of having a basic HTML page which uses PHP to pull from a DB, it works very well grabbing data from a DB, external services, etc. and responding as JSON, then letting your client-side templating apply all its view logic. I'm inferring that if they're going to ReactJS, they're using WordPress for little more than just posting blogs, and responding with those blogs as JSON. This is a completely appropriate place for WordPress, especially if most of their bloggers are already familiar with its admin menus and how to post articles. Hopefully they can avoid the spaghetti of piles of WordPress events, shortcodes, and unnecessary global functions, and just let WP handle the blogs, vanilla PHP for their more complex business rules, and ReactJS for managing their views. edit: added clarity around continued WP use.
Thanks! Just note, I am the author of that one package that you found with the big deprecation notice. The biggest issue with that old thing is that I cannot account for the quality or accuracy of the special functions. Things like the beta function, gamma function, etc. The probability distributions and the statistical tests really depend on those working. I don't want somebody using it and thinking that the numbers are more accurate than they are. Unfortunately, writing robust approximations for them is out of my depth. :(
Fuk
People say the same shit about choosing PHP in the first place. None of it matters for a heavy-read based content site behind varnish/cdn/cache/whatever etc with disqus handling most of the dynamic stuff They could run this on a potato if they wanted
At my job I've written a php port of pandas' dataframe for handling datasets. It is on my list to write some rigorous linear regression classes, but I may just end up using this. Looks very nice!
What could possibly go wrong 
The simplest way to ruin you plan for the next 52 weekends.
Thanks! Lemme know how it works out for you.
Hm.. What is atoum?
pfft potatoes aren't webscale. Parsnips.
My mercenary heart requires that I recommend my book [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). There's an entire chapter on moving from functions to classes, and how to autoload them. (There are reviews linked on that page as well, so you don't have to take my word for it. ;-)
I would use the new library for regression, hands down. For the correlation, it depends. The regression library can give you the r-squared value, which is the square of the correlation of the predicted values and the observed values. If that's not what you're after, PHPStats has a simple two-variable correlation in it. That's not going to have any issues with it.
Thank you, I'll have a look at the new one in more detail then.
[You are such a slow learner](https://twitter.com/voodooKobra/status/569969744201318400)
[**@voodooKobra**](https://twitter.com/voodooKobra/) &gt; [2015-02-23 21:19 UTC](https://twitter.com/voodooKobra/status/569969744201318400) &gt; I probably should STFU more ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
PHP is actually the right tool for the job in this instance. I question their decision to commit to WordPress. The reality is that WIRED can afford 100's of servers which means they can afford bloat. If they ever end up in a situation where they have to scale infrastructure back 10x they will probably run into tons of issues. If.
&gt; We ruthlessly axed redundant third party analytics and consolidated the serving of advertising and marketing units. These cuts reduced our HTTP requests by more than 50 percent. Best comment ever! That analytics crap makes the web slow...
Glad I'm not the only one who noticed. Stopped reading Wired about 9 months ago...
SEO nightmare
 - http://stackoverflow.com/questions/ask - http://www.reddit.com/r/phphelp
I'd disagree a little with the blueprint analogy because it's important to understand that an Interface is only concerned with public API. It's not at all concerned about the inner-workings of the class, just the way in which other classes interact with it. I think describing it as a blueprint implies that it's telling you how to build the entire house, when really it's just telling you that it needs a door on the front. Also, you can implement multiple interfaces, you don't really have multiple blueprints. 
very important to point out. wordpress is one of the reasons, that there is so much php hate.
And on this day all hackers targeting wired simultaneously got massive erections. 
Ghostery still blocks 11 trackers on that page...
Aside from all the wordpress hate, it does look pretty nice and everything loads fast.
Are Wired's business rules and content publishing systems really that simple that Wordpress is good enough for them? Don't they have an editorial flow / process they want to optimize for their own purposes? Surely trying to code that in Wordpress is more trouble than it's worth? You could build and test your own system in a proper framework, with a proper codebase, in a month. And then the sky would be the limit in terms of where you want to take the site. But being stuck on Wordpress means being stuck with its restrictions and limitations, or pounding your face against the wall trying to break through them... What next? Amazon moves to Magento?
The drastic speed gains made by the PHP 7 codebase so far mean that fractional slowdowns are less of a problem. If we cut it by 50% and slow it by 1% then whatever.
WP is the ass hole of PHP
In PHP's case, interfaces + traits could be combined to give that author the separation of concerns he wants from multiple inheritance.
Absolutely agree. I was going for the ELI5 version as there was already a more complex example. 
I'm rewriting a website (built on wordpress) and I don't want to use frontend features (layouts, posts, etc). How does WP works acting as a backend-module only? Do you have any other CMS recomendations (which will have the same purpose)?
I agree it's not very good. Also, PHP4-style constructors will be removed in PHP7 , so it's already half-broken.
The official Google SDK isn't any better to be honest. And it's the only package for all Google APIs including Youtube.
Pretty sure a lot things will break in PHP7. But I agree it's not up to modern "standards"
Probably best in /r/programmerhumor
Created a PR with some of the missing ones (a couple didn't have readable slides/screens so I left them out). 
quick and dirty... change [] to array() in string definition on php&lt;5.5 &lt;?php $strings = ["First","Second"]; $id = (int) @$_GET['id']; if (!isset($strings[$id])) $id = 0; ?&gt; &lt;html&gt; &lt;body onclick="location='&lt;?= $_SERVER['PHP_SELF'] ?&gt;?id=&lt;?= ($id + 1) % count($strings) ?&gt;';"&gt; &lt;h1&gt;&lt;?= $strings[$id] ?&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;
That hasn't been true in my experience. Dynamic sidebar behavior, custom URI schemas, and a plethora of other annoyances that simply don't exist when you have full control in a proper framework, have made me come to hate Wordpress for any project where the client has an opinion. If the client doesn't have an opinion, and Wordpress dictates what they can and can't have (or the client has a big budget to pay for the inefficiency of making Wordpress do what the want), then Wordpress is ok.
...Well in that case...
Reading some PR comments, it needs to support PHP4, for reasons.
works like a fucking charm. thanks for the help big bruh, it is much appreciated.
Worried about an attacker sniffing out what you're reading?
Dynamic sidebar behavior? Uh... what problems exactly are you having with sidebars? Because you generally write those yourselves. I'm also interested in what URI issues you're having, as the entire URI mapping system is pluggable. Honestly the only time I've seen anyone have actual usability issues with WordPress was because they didn't bother to read the codex and did something wrong, or blamed wordpress for the shitty plugin/theme they used - so you'll have to excuse my curiosity.
&gt; Traits are not for multiple inheritance. It should only be used for reducing stupid code duplication. Why not?
If you're on Ubuntu or Debian, it's a few apt-get commands to install any PECL extension. 
I doubt they will. The article mentioned getting a single design that works responsively across all devices. Why bother making an app when the website *should* perform fine?
&gt; They plan to do any talks in any upcoming conferences? LoopConf
Not a great example, but an example nonetheless: [Kaboom](https://github.com/beryllium/kaboom), which was inspired by a joke on twitter and hasn't evolved very much since it started. Heh.
Yeah. Well, they did make an iPad app for some reason. I don't usually like downloading apps for things I can just use websites for, but for a magazine it's really nice to have an app that shows me what I have and haven't read and lets me start reading again from where I left off.
It's cute that you looked at some PHP 4 code on a GoDaddy site once and came to that conclusion. Tell us more about your experiences.
Not much PHP, apparently. Keep on trucking, little tyke.
Ooooooh, burn from the Rockstar PHP guru. How's your CodeIgniter 1.4 app treating you, sweet meat?
Yep that's what I'm using, and I'm hoping to try out Mockery this week too. I've got the general gist of writing tests, I just really need to study and practice the **art** of writing good tests.
Haha thanks for the recommendations, I will check those out :-)
I'll be around. Let me know if you also need help configuring your copy of Eclipse so you can work directly on the server. Version control is for pussies. YOLO
I commented on github, but I'll also post my results here: openssl_prng = 225800 iterations per second (Fastest) mcrypt_prng = 107595 iterations per second better_prng = 99619 iterations per second shitty_prng = 51612 iterations per second (Slowest) 
Is `mcrypt_create_iv()` "better" than `openssl_random_pseudo_bytes()`?
Where can I find the Drupal training material that you mention?
Cool idea, but it only takes into account the issues. For projects that don't use issues (google/recaptcha for a recent example), this doesnt really do anything. It'd be cool to see commits/week and PR information (% of PR's merged, open PRs, avg PR open length) 
That'd be wonderful :)
could it be they want the developer community do a fork? it's open source after all. or maybe they don't give a damn about PHP, and want us to move on from it?
My intuition was right, the if(function_exists()) does actually slow it down.
Not hate, no. Actually, I was rather fond of CI. Though, no new apps should be written in it for the time being. Ever since the original company stopped maintaining it, it kind of went downhill. Hopefully 3.0 breathes some new life back into it, but I'm afraid it might be too late by the time it gets off the ground.
Lots of Wordpress hate here. I've never had a problem with it after a couple years deploying it for clients and a couple high availability apps. Hey if it smells like shit everywhere, look under your shoe. 
&gt; And they take care of those once reported. [No they don't](http://seclists.org/fulldisclosure/2015/Feb/42)
&gt;If I have a main page with only a navigation in it with 3 links. All three links are included from PHP, everytime I open one of the 3 links, **the broswer** will send my request to the server/**php** and then send the html page back to my view, right? My corrections are in bold. In other words, a) when you click a link, your browser sends a message to the server. b) you should think of php and the server being the same thing. I strongly recommend you look at "Learning PHP, MySQL &amp; JavaScript: With jQuery, CSS &amp; HTML5" by Robin Nixon. Just find it on amazon, click the cover to open the free preview. The preview alone will answer many of your questions about how all these things fit together. 
And Drupal, and also, Wordpress after version 3.
Another. Router. So, what sets this one apart..?
Yeah, I don't think I've met anyone that has positive feelings about it. Unless it's "at least it's not CMS Made Simple" or something.
I just ran across this one that has pretty good code and a full suite of tests: https://github.com/lanthaler/IRI
Ok here is a quick `.tar.gz` http://www.perturb.org/tmp/csprng-bench.tar.gz I realized that my benchmark doesn't have any CLI output. I'll go hack on a CLI mode for the next version. Let me know what you find.
Last two make sense....
Both of your examples are trivially small libraries, though. You won't find something the size of Symfony or ZF going 6 months without a commit unless it's abandonware. I think "maintainedness" as a function of commits-over-time and project size would be a pretty good metric, actually. You could come up with a relatively safe baseline by averaging a bunch of known-active projects.
Yes. You always want to `require_once()` the PHP File that has the class definition. It's an error if you pull it in twice (so use `_once()`) and if it's not there your code is going to break anyway (so don't use `include_once()`.) You can do that either manually everywhere you need it or (preferably) through the magic of autoloading. Once that class-definition has been loaded, you can churn out as any little objects--instances of that class--as you want. &gt; I want to transition my webapp to OOP. I would only worry about "proper OOP" [after](http://www.reddit.com/r/PHP/comments/2vd7gh/procedural_php_to_oo_php/cogl7ud) you've used classes/autoloading to reduce global-state and load-order issues. That'll help any old PHP codebase, and it's a prerequisite so that you can do procedural-to-OOP refactoring without major frustration.
Wordpress 4+ is super easy for quick sites and dead simple to train clients on. But I agree about Drupal for the most part. 
oh good lord. that piece of shit. dude, stop scaring me. :O
No it doesn't, and it won't, ever.
Sometimes I'm not sure whether people are joking or not. This is one of those times. 
I respectfully disagree. Yes there is most certainly a correlation between commit activity and "maintainedness". But commit activity doesn't tell you anything IMO. You can probably imagine there are a lot of commits in Zend Framework 2, but did you know that it takes them on average [*1 month* to fix an issue](http://isitmaintained.com/project/zendframework/zf2)? and that 1/4 of the issues are unresolved? Issues are closed faster [in ZF1!](http://isitmaintained.com/project/zendframework/zf1). These stats really tell me something (with all due respect to the great people behind this project, I don't want to point fingers just illustrate my point).
Because you can't cover traits with test without some ugly hacks. You can use it for class composition for example, but this is kind of rare case. p.s. I really try to avoid inheritance when it is possible in flavour to decorating/composition. I don't see any cases when multiple inheritance is a only correct way.
Also try phpspec + prophecy.
It appears that the PHP League stuff has plenty of tests: https://thephpleague.com/
can't you see the travis and coveralls badges? 100% test coverage?
&gt; I just really love php.. Why? Because it is easy? Are you aware of its limitations, and why is it good for and what it is not? Have you really tried any other similar languages. (Like Python)? Do you want to program in a language where you have to keep a growing list of gotchas in your mind when you write every single line, if you want to make sure it works as expected? Do you want to work in a language that has a very good chance to be obsolete in a couple of years? Do you want to work in a langauge with no kind of module system, and the only way to organize code is to put them in classes (even when it does not make sense, one per file according to standards), manually adding long namespaces at the top (Which should match the path of the file according to standards), for every one of these files...AFTER 20 Years of its creation? (But [real PHP Programmers use PHPStorm, so it is not an issue for them](http://www.reddit.com/r/PHP/comments/2vpnk3/irestfulconcretemultiplehashmapqueuemessageretriev/)) Read [this](http://www.reddit.com/r/LOLPHP) for a while and make up your mind... Similar things can be said of MySQL. Leave it and learn PostgreSQL. You should only learn php and MySQL if you only care about getting work easily (Quality varies greatly depending on your location). Those two can hurt your learning process and should be avoided if possible. But you should be willing to put good effort into this, and should not think "Oh this was so easy in PHP", understand that doing and learning things properly is always harder/slower at first, but pays itself greatly over time. 
Searching for PHP jobs on linkedin gives 59507 results. Look around, there are tons of jobs.
So.. what is the difference with http://symfony.com/doc/current/components/process.html ?
Personally I don't care for the syntax of Python, so that also precludes languages such as Ruby. PHP, for all of its short comings, provides a syntax similar to Java or C which I find better suited. As for what you're claiming regarding PHP... well, PHP isn't going any where. At least not yet. Ruby hasn't stolen the show, Python doesn't seem to be doing that either. Java, PHP, C# seem to be the bulk of the Internet at current and likely for the foreseeable future. That said, some of your other points were valid and should be thought of. 
Lots of companies use open sourcey stuff. SOURCE: where I work
You're fundamentally misunderstanding the point and purpose of both of these. Which is fine because you asked a question. On the ORM thing, I'll just share something I've said before. ----------------------------------------- Essentially the connections between tables has to be put somewhere. You can put it in each and every SQL query or you can put it in the data object's defined relationship one time, and let it be used automatically. Let me give you an example. A few years ago I built a site for someone. It was a vehicle trading website, cars, etc. It ended up quite complicated, building over time. It had a vehicle details table, and a bunch of interconnected lookup tables for make and model, things like colour and body type. There were buyers, bids, sellers, locations, preferences, dealerships. Loooooots of relationships. And there were classes with lots of methods. And lots of SQL. Here's the query for "getAllItems" $query = 'SELECT a.*, year, make, model, badge, colour, u.city, st.state, st.state_short, aus.status as auction_status FROM auction_items AS a LEFT JOIN auction_bids AS b ON b.itemID = a.ID AND b.typeID = 1 LEFT JOIN auction_status AS aus ON a.statusID = aus.id LEFT JOIN auction_users AS u ON a.userID = u.ID LEFT JOIN states AS st ON u.state = st.id LEFT JOIN vehicle_details AS v ON v.auction_id = a.ID LEFT JOIN '.$_SESSION['l10n']['table_prefix'].'models AS md ON md.id = v.model_id LEFT JOIN '.$_SESSION['l10n']['table_prefix'].'makes AS mk ON mk.id = md.make_id LEFT JOIN '.$_SESSION['l10n']['table_prefix'].'badges AS bg ON bg.id = v.badge_id LEFT JOIN type_colours AS c ON c.id = v.colour_id LEFT JOIN type_transmission AS t ON t.id = v.transmission_id LEFT JOIN type_body AS tb ON tb.id = v.body_id LEFT JOIN type_drives AS td ON td.id = v.drive_type_id LEFT JOIN type_fuel AS tf ON tf.id = v.fuel_type_id WHERE a.auction_end &gt; '.time().' AND u.country_id = '.$_SESSION['l10n']['country_id'].' AND a.statusID = 2 AND a.userID != '.User::getSimpleUser(); That's a single query. There are slightly shorter ones for similar stuff. Get Matches. Get Search Results. The getAll used by Admin. Get one. Get recent. Get upcoming. Get by buyer. Get by seller. Half a dozen more. Each of these... maybe 20 lines of SQL. I'm looking at a class maybe 1500 lines long, and about two thirds of it is SQL queries, the vast majority of it is . Then the same stuff duplicated in the "bids" object, as it has to get all the related stuff from the other end. I'm not exaggerating. It was a massive system. Can you imagine what it was like trying to add a field? Or to change the name of a table? Dozens of places. Lots of unintended consequences of changes. Forgot one? For some reason it shows up blank. Editing form keeps resetting one of the dropdowns? Why's that? This is not how I would do it now. I'd use an ORM. In a heartbeat. $items = Auction::with('bids', 'users')-&gt;auctionEnds('&gt;', time())-&gt;isActiveAndNotMine()-&gt;get(); That would replace the above. And it would make the changes that were required later trivial. You would just make that single change in the settings, or just not bother at all. ----------------------------------------- Moving onto Blade. You're taking it out of context. There isn't any benefit really to what you're doing there in isolation. The benefits come in using it as a whole system in context. For example, Blade is an entire template engine. It allows you to build a scope of variables limited to just that template or view. It allows you to separate your display code from your general code for getting stuff out of a database, formatting it, handling post requests, etc. This lets everything be clearer and cleaner. Separation of Concerns and all that jazz. That said, the helpers like what you posted ARE genuinely useful, just not as you posted them. Helpers can be updated dynamically based on the route, or they can be created programatically much more easily. &lt;a href="/permissions/auth/logout" class="btn btn-info" id="button_logout"&gt;Log Out&lt;/a&gt; vs {{ HTML::linkRoute('logout', 'Log Out', $logoutButton) }} The second one has the advantage that changing the $logoutButton class to add an extra class (or whatever) will propagate anywhere you've used it. The same applies to the url, which is programatically generated from the routes. Other examples include the form helpers, where using {{ Form::model }} clears away a lot of confusion about how to populate and refresh forms, etc. That said, these things aren't **that** useful in isolation. They're useful for minimising extensive concatenation and switching in and out of PHP required for generating programatic urls and HTML elements. But most particularly, things like Blade are useful, or I'd even say **important**, for making sure that you have a clear and effective separation of the code that handles the way things look, vs the way things work.
&gt; Do you want to work in a language that has a very good chance to be obsolete in a couple of years? What? PHP drives the majority of the whole world wide web. It wont be obsolete in many many years. 
i had to save this one in /r/redditquotes -&gt; [link](http://www.reddit.com/r/redditquotes/comments/2xrxxe/being_a_joomla_developer_is_easy_its_like_riding/)
Thank you for making my inspection result queries look sane compared to that mash up of vehicle data. 
With the availability of cheap virtual hosting providers, PHP's availability is no longer relevant. And with better alternatives available, it is only a matter of time people starts noticing that they don't have to use PHP for everything. In due course the 'web' support for other platforms will improve greatly (It is already very easy to get a python web app running with something like uwsgi and Nginx), and the barrier of entry for them will be greatly reduced, so that people can migrate to them easily. You can argue that the constructs in Python is a harder to wrap ones around than it is in PHP. But if you don't want to dig too deep, then using a framework like Django or Flask is really a no brainier. So the learning curve is not much steeper, at least till the point where you can create something useful. This situation can only get better... Once this trend starts, more and more programmers will migrate to another languages, making the developer pool for them bigger, and 'availablity-of-cheap-devs' will no longer will be relevant factor for selecting PHP for new projects.... These are the things that can happen in the next 5- 10 years. As it see it is, most of big projects will disappear (Because lesser and lesser new projects will be done in PHP), leaving behind legacy apps, and only the available PHP jobs will be cheap jobs, Good luck getting one of them competing a sea of 10 USD/day developers from India. Those are some of my reasons...But as you said, there is a huge momentum in favor of the language, which may trump all of the above factors. Not sure how far it will take it, but it is a bet I am not willing (or is required, if you are willing to put in the effort) to take.... 
mrterryh is right, now I've got more into it, it seems very rushed with loads of missing information. All in all a very disappointing purchase. Luckily for me, refunds are available on Leanpub! Off to checkout the laracasts instead.
I once worked in a government-sponsored organization that hired a guy to embed a Drupal install in Joomla. That is all I'm going to say on the subject.
&gt; Eloquent is used to make queries easier to write. Well, the query builder makes queries easier to write (you can, if you wish, just use Laravel's query builder and ignore Eloquent altogether... or you can bring another ORM such as doctrine along in place of Eloquent). This can be very useful, for example when doing things like scoping queries by a logged in user or some tenancy context etc. Not to say that it's impossible to do with raw SQL, but in my experience it's not nearly as clean and you end up writing a bunch of helper functions that emit SQL fragments...at which point you are not really doing raw SQL anymore anyway. And anyway, even if you are completely comfortable writing raw SQL, isn't easier appealing in it's own right? Eloquent goes a step or two further than just making queries easy to write. It provides you with the ability to programatically define relationships between entities and then retrieve them in a relatively simple fashion. If you for example have a Book model and a book has many chapters, you can just do things like: $book = Book::find(1); foreach ($book-&gt;chapters as $chapter) { } and it would work as you would expect. It also provides some very helpful utility around polymorphic relationships, many to many relationships, eager loading, scopes, management of common security issues etc etc. Of course none of this is beyond what is possible with raw SQL but it's undeniably more productive, and potentially more comprehensible as you are defining your data as concepts within your domain. So it's not really just about making things easier to write. There are of course tradeoffs - you will generally trade improved developer productivity (through improved comprehensibly, testability, maintainability and brevity) for outright raw performance but this is *usually* a fairly good trade to make given the relative cost of hardware vs people. And you are writing in pointing out that long and complex queries may not be possible to write efficiently using eloquent (one trade most ORMs make in exchange for their productivity is that they tend to be relatively query heavy, often performing many more queries that a well crafted hand rolled statement could achieve with far less), but you can always dip down into the builder directly, and failing that there is always Db::raw() which would let you ultimately write something completely by hand if you absolutely needed it. But often it's better to cop the generally minor performance hit for something human readable then craft a perfect if utterly unreadable slab of SQL. 
&gt; And with better alternatives available, it is only a matter of time people starts noticing that they don't have to use PHP for everything. Variations of this argument have been floating around for over a decade. I distinctly remember being told that Ruby and Rails was going to replace PHP as the dominant web development platform.. where are we now? &gt; Once this trend starts, So, future tense. If the trend hasn't started... then where is the trend exactly? Really without evidence you are just crystal ballgazing and sprouting the same tired theories about PHP's demise that we've all heard before. Here are some real "facts" about the state of PHP: * It's not quite the "terrible" language with many shortcomings as it once was. Sure, it has it's own set of gotchas, and sure there are legitimate problems with it - but the same is true of LITERALLY EVERY PROGRAMMING LANGUAGE OUT THERE. There is no such thing as a perfect language. * The cost of migrating to other platforms is immense. More so than a complete rewrite in a lot of cases because you are not only throwing away your current IP, you are throwing away the skills of your current set of developers. Putting aside all of the great *modern* things which are happening in PHP (both from a userland perspective, and in the core with some great additions in recent versions and a lot more good things coming in PHP7), sheer inertia alone makes PHP a viable choice for business on both existing maintenance work and greenfield development. * Now, not putting aside all those great things, the amount of good things coming out of the community at the moment is staggering. If nothing else the community is maintaining PHPs relevance in the business world. Brilliant frameworks, fantastic tooling, first rate testing frameworks... all those good things that Ruby and Python have, PHP has them too. And the language itself has been undergoing relentless modernisation for a number of years. Sure PHP still has it's warts, but it's not unique amongst languages for having them. And hey, if the modernisation isn't happening fast enough for most people there is an alternative path - hhvm+hack which doesn't require burning down all the knowledge in your company to get a more modern language sooner. &gt; These are the things that can happen in the next 5- 10 years. 5-10 years is a very long time in tech. in 5-10 years who knows what we'll be working with. Python could just as easily fall out of vogue in favour of some new hotness. &gt; As it see it is, most of big projects will disappear (Because lesser and lesser new projects will be done in PHP) As you see it based on.....? &gt; leaving behind legacy apps Even if PHP did just fall over and die, the sheer scale of PHP's deployment footprint means that there would be enough legacy there to keep most of us in work through to retirement. &gt; and only the available PHP jobs will be cheap jobs Working on legacy code (especially when there is demand for people who can work on it - we've all moved on to become pythonista's when PHP stopped being used remember?) is usually very profitable for those doing it. Pretty much everything you've said is based entirely on speculation. PHP could just stop being popular tomorrow. So could Python. Go could become abandonware. There are currently *no signs* of PHP's popularity dropping off so there is currently no cause for alarm. That said, we should all learn as many languages as possible. Knowing more languages is good for your craft. 
How is that Eloquent call the same as the query above? Where are you getting the other tables (vehicle_details, type_colours, type_transmission, type_body, type_drives, type_fuel...) ?
No, they won't. If you read current version of this RFC, you'll see that they are going to deprecate them in 7.0 and remove in 8.0 IIRC. RFC content has changed.
I think it is great!
Oh I'm not at all suggesting that the approach is correct, only that it appears to be the approach. You are right, a proper "modern PHP" composer package for those of us who are not stuck in the dark ages would be a great thing... but it seems they have 1 version to rule them all right now :/
All those relationships are defined within the Model. [http://laravel.com/docs/5.0/eloquent#relationships](http://laravel.com/docs/5.0/eloquent#relationships)
&gt; Variations of this argument have been floating around for over a decade. I distinctly remember being told that Ruby and Rails was going to replace PHP as the dominant web development platform.. where are we now? I like how you conveniently ignored the my clause "With the availability of cheap virtual hosting providers,"...which is the deciding factor... &gt;PHP could just stop being popular tomorrow. So could Python... The difference is... /r/lolpython 2 readers /r/lolcpp 5 readers /r/loljava 29 readers all with &lt; 1 page of posts .... And now, the winner is... /r/lolphp 4,526 readers and god-know-howmany pages of posts..(Holy Shit! Surely, there should be some conspiracy!)... Now, Jokes aside, the point I am trying to make is, PHP continue to exist largely due to its momentum and not by it's merit. Once you remove the aforementioned 'edge' (availability and ease of deployment), it is bound to decline in popularity... 
ORM solves one complex problem - transforming objects into database rows and vice versa. Even if you are well versed in SQL, ORM can be useful, because it automates a lot of boilerplate (how to create an object from various DB tables, how to save it when it changes, how to compose multiple objects etc.). It's not free, however. In order for it to do its job you must follow its conventions and basically learn a new language, a DSL standing between the programming language (PHP in this case) and SQL. Also ORMs have strange edge cases and are of course not as flexible as writing SQL by yourself. With that said, I would recommend looking into an ORM that uses the Data Mapper pattern (where an external object solves the O-R transformation), eg. Doctrine ORM. Eloquent uses the Active Mapper pattern (the transformation runs inside the transformed object itself), which is considered a bad practice because it violates the single responsibility principle.
But I thought those tables are not joined automatically. If you have 10+ relationships like above, that would mean every time you ask for one Auction row you're fetching from 10+ tables.
I just wondered about that in the last days, but I was mainly motivated from searching for a procrastination project ...
I never knew about this. We built our solution a couple years ago for Symfony1 but we have no dependency on symfony. Just the PCNTL extension. However just from reading the component doc it seems as if it only executes external commands ? For php you pass it another script either via command line execution or as a string. ProcessExecutive does not execute external commands but itself in a specific way. It can allow any class to execute a portion of its own code in a child process. Actually I see value in using both of these together possibly though If Symfony's Process component can do what ProcessExecutive does then ProcessExecutive is useless. But I do not see the same use case covered.. do you?
Perl! The initial bootstrap for Perl 6 was a simple Perl 6-subset-compiler written in Haskel which then created a full Perl 6 compiler written in (a subset of) Perl 6. It think this one is mainly used as a reference implementation though.
It's not quite the same query. But in fairness in the case I was referring to, a lot of the data - state, colour, status, etc - was not actually used or needed. It's not a very efficient query and it's getting quite of data it doesn't use. You'd make it more efficient by adding more things in the `with()`. The following would probably be more accurate to the actual usage. Auction::with('vehicle_details', 'seller', 'make', 'model')-&gt; But I couldn't tell you exactly. I wasn't trying to replicate it exactly, just make the point that it's vastly more readable.
Picture or didn't happen. 
Over time it just kind of... grew.
I've been using wp for 2 years now. It is easy to use but the code base will be soon come to an end if they do not refactor it.
There is nothing wrong with Joomla itself but the people who runs the show.
When someone asked me what do i do for a living, i said "i'm a Joomla/wp developer". Recurring responses fascinates me! ---Responses-- For non-internet savvy: yes i have a blog in wordpress. Btw, what is Joomla? For average to expert user: Joomla is dead or dying. This is why i moved way from Joomla. It's a dead end! I have pity for those developers who has built their business around Joomla only. They are stuck! 
Joomla is like a horse who lost a leg.
i have similar experience
If you stole something, make it into something better, or at least something different. Not worse! Disclaimer: I understand about open source which makes stealing legal. But at least if you take somebody else work and ideas, make it better.
&gt; I am of the opinion that php is itself a very good templating engine Your opinion is wrong :) Specifically, you seem to be conflating the **syntax** of a templating engine with the function of it. You can have a good templating engine written in native PHP syntax... [Plates](http://platesphp.com/) is particularly well regarded. But there is still benefit to a templating engine all in all. PHP is not only not a good one, but not even one. It's just a language that allows the mix of logic and presentation. A templating engine exists to specifically not do that.
I frequent /r/lolphp because I can laugh at myself for using it. That doesn't mean I'm going to stop using PHP any time soon. :)
I'll never understand the hate for Joomla. I use it every day at my day job in both small and large deployments and it works great. The way it does some things are questionable but definitely not deserving of the unjustified hate in this thread.
The primary purpose of an ORM is to basically forget you have a persistence layer. It requires a different approach to how you structure code from being DB-first, to domain object-first. There's nothing wrong with writing MySQL queries and mapping the data manually, or using the PDO output directly, per se, but it's far more tedious and will wind up having inconsistencies and data integrity in the long run. When you use an ORM, you end up working with more consistent data in the layer that arguably counts the most: your domain layer - the layer that *is* the heart of the application. I make it a point never to try and use a join in Eloquent, because that means you're getting back either arrays, or stdClass objects, rather than defined objects. I basically make my data layer conform to the business rules of my domain (and bend a little bit to the needs of Eloquent - which almost always results in a relatively clean database - if a little over-normalized).
They are joined automatically, based on how you ask for them
It's not about "better than," it's about offering more functionality. If you don't need it, don't use it. One thing that others haven't said, but by no means the entire argument: if you're passing this codebase off to somebody else - especially if they are not as experienced or comfortable with long complex queries as you are - then an ORM might be a little easier for the hand over. ORMs come with a slight performance hit, but that is a tradeoff you have to make for the functionality they offer. Stored procedures for examples will be a bunch quicker, but less flexible, and you still have to find a way to map the relationships if you're looking for that sort of structure. HTML helpers are often confused too. Here's something I wrote [about HTML helpers in CodeIgniter](https://philsturgeon.uk/blog/2009/12/Why-CodeIgniter-HTML-helper-functions-rock/), which was doing the same thing.
stolen from Mambo by it's own developers!
How so?
In my largest project dragonagekeep we used doctrine originally. Later in the project we had a lot of issues with building complicated objects, optimizations, and trying to wrap our heads around how to accomplish something in Doctrine that was trivial in SQL. We ended up realizing that we were struggling trying to work with Doctrine to do things we all knew how to handle with PDO. It took approximately a week to strip Doctrine out and test properly, but for our team it allowed us to hit our optimization goals, and implement features we were struggling with before. Honestly given unlimited knowledge, I'd bet an ORM is a good idea, but I personally recommend just using proper design patterns and using PDO. 
Why do you think it is dying? It is extremely popular? I get the feeling that the popularity might be dropping in the US, but here in Europe it is very popular. Maybe because it handles multiple languages relatively well.
If you can not see that Joomla is miles better than Mambo, then you just don't know what you are talking about. 
Agreed. I don't get it either.
I wish this would fit in a tweet. lol
I've been both an active Joomla user and a semi-regular extension contributor for some time and I can't say any of this is untrue... though you may want to throw in snakes along side the spiders, and maybe squirrels, lots and lots of squirrels especially older installs.
You must download and install something like [xampp](https://www.apachefriends.org/index.html) or [wamp](http://www.wampserver.com/en/). I am sure there are others but to start experimenting any of those should be fine. For someone familiar with computers it should be easy to install and figure out how to use them. In case you have some difficulties you can always search on youtube for a video tutorial (e.g. [install xampp](https://www.youtube.com/results?search_query=install+xampp) Anyways good luck. Programming is awesome but the initial setup is a bit of a hassle if you don't have someone experienced to nudge you in the right direction. **Note**: Seems like the source you are reading is a bit outdated. The programming world moves kind of fast and the way things are done now is a lot different from when that tutorial was written and you might pick up some bad habits. Try to read the following site for some community suggested best practices: [PHP the Right Way](http://www.phptherightway.com/).
* For starters, I can't keep Xdebug Scream enabled because of Joomla's rampant abuse of `@` instead of doing `file_exists()` checks beforehand. I traced one error down to the fact that Joomla core was attempting to write to a cache file before creating it, so the `@fwrite` supression was getting hit, and making Xdebug throw a tantrum. Like, I can maybe forgive the lack of `file_exists()` checks, but why was the cache logic structured such that it would attempt to write to a cache file that didn't exist yet?????? * I also can't keep E_STRICT enabled on my environment, because my screen fills up with Xdebug warnings and notices thanks to loose/lazy development standards by the Joomla team, and the myriad of 3rd party developers. * Joomla has no out-of-the-box support for working in a team environment. Have to make sure to add a .EDITME version of configuration.php, and then make sure configuration.php is in .gitignore. * Extension management in source control is a nightmare. Joomla requires you to install "plugins" (therefore, they're not plugins). So here's what happens: if I have a local database, and I install a plugin, and then commit the source code to the repository, the source code is there, but the plugin isn't installed on any other environment. No problem, just commit the zip file so others can install if they need to? Nope. It errors out because it sees files in the directories, and refuses to overwrite them or just skip ones that already exist. This means for every extension we install, we either have to run a manual query to install it, or provide a database dump/"migration" to make it available to other developers - OR - force all developers to use a central shared development database (scary). * Numerous UX stupidness, like items are not visible until you add them to a menu, and you have to press "close" or "cancel" just to redirect back to the previous page to get out of a form.... * The extension ecosystem is AWFUL. I tried using VirtueMart, and it's abysmal. It has more UX "wtfs" than I care to count. And extensions all try to isolate themselves from any sort of interaction. We had a project where we needed to use RSMembership to handle recurring subscriptions, and VirtueMart to handle digital downloads. The business rules were such that a subscriber got discounts on the digital downloads, so VirtueMart needed to know who the RSMembership subscribers were. That would have been easy if both RSMembership and VirtueMart used the core Joomla user table and worked with the same groups (that is, we could have made RSMembership give you a "subscriber" group, and then VirtueMart could have used it's group-based discount system to give "subscribers" a discount on purchase. Instead, VirtueMart *only* had its own shopper groups, and pretended core Joomla users and groups didn't even exist..... so we had to write all kinds of nasty hook functions to bridge the two. * Speaking of nasty hooks, the Joomla ecosystem is rife with examples where they think it's ok to do store and execute PHP in text input fields. Literally, you put PHP in there, and then that is how the "hook" is executed. This means you have PHP in your database, instead of in source control. God forbid you provide a normal API of events to listen for so we can use code-level hooks.... * The extension ecosystem is scamware. "Open source matters" means "we're going to make it hard for you to get the source code even though Joomla requires it be free, and then we'll make it seem like costs money by charging you money for "support" and documentation". * And support and documentation for these plugins/extensions? Awful. Mostly Engrish, incomplete, and/or not free documentation. Plus the communities are really unhelpful and unfriendly. You ask why something is so complicated, and they immediately get combative and defensive, because they KNOW how nasty their shit is.... * Joomla core documentation is also shitty. Tried to figure out what Joomla means by "MVC" when talking about how you build its plugins, and it's a shit show. The examples they give are inconsistent and/or incomplete. The router/routes/views/templates/models structure they use is ridiculous... * The fact that you need to build an XML manifest of extensions you build in order to install them is also absurd. And because they DO need to be installed, you can't just go ahead and create a new extension or component, you *have* to make it installable (or write SQL queries to manually register them in the DB). At least Wordpress handles this gracefully by seeing that a plugin is inactive, and all you have to do is click a button to activate it (which writes it into the DB for you). * In general, I found it be flaky and unstable. There were times I would get a feature working, close up shop for the night, and come back the very next and it would be broken. Literally, like gremlins got into the computer and started ass fucking the HDD. This happened more than once, and it really, REALLY confused me. * Nailing down what should be in .gitignore was like playing a game of whack-a-mole. Ignore a file type or folder, and a new one would pop up later. The location of cache/tmp seemed to be scattered, and could be because different plugins/extensions used their own shit... * When I first started learning Joomla, it was an unintuitive nightmare. Once I figured out that you needed to add an item to a menu to make it viewable, I started playing around with the customizations on the right side (show print button, hide author etc etc) for the item. Kept refreshing the page, and nothing would happen. It turns out that the *menu* settings for that item override the item's settings, which begs the question: if an item cannot be shown unless it's connected to a menu, and the menu settings override the item settings - *WHY DO YOU HAVE SETTINGS ON AN ITEM AT ALL????* * Working with skins and modules and templates is SO much more cumbersome than just writing out templates in a framework-based app. Blade, Twig, Smarty... I can create views so much faster and with so much less effort than doing the equivalent of fucking around with Joomla's modules and plugins and templates and template locations. Honestly, there are so many more annoying little things that I ran into on a daily basis, and I fucking hate Joomla because of it (both 2.5, and 3.2). When I write shit in Laravel, it's like a breath of fresh air. There are NO assumptions getting in my way, everything is clean, terse, and logical... Nothing Joomla provides me is worth the headache I have to go through to use it. For any project that needs light-weight CMS work, I can bust out a perfectly usable one with a WYSIWYG editor in Laravel in a day, 2 minutes if I ever make one into a package. And then I have the freedom to create all kinds of custom content types without any interference. I can use Eloquent, and proper routes, and proper controllers, and proper PSR-4 autoloading, and proper dependency injection, and proper documentation, and my life is great and I'm happy and I love all the things. Then I use Joomla and I want to quit my job and fuck myself off a cliff.
I don't agree with everything, but I must agree to a lot of it. And yeah VirtueMart is awful, and I feel sorry for you for having had to work with it.
What about [Bolt.cm](https://bolt.cm/)?
Those are no longer the case in Joomla 3, at least the E_STRICT one, and I am also pretty sure the @ is gone too.
The raw SQL vs ORM debate has been going on for years. I will promise you, every ORM will "fail" you at one point, and perhaps generate slower queries. The Clojure crowd has something called yesql, and its look very promising, im not sure there is anything like in PHP though. For a basic crud app, sure use a ORM, but anything more complex id go with raw sql.
Hey - let's not forget that turn key solutions are available for PHP setups, too, in regards to virtual hosting. In fact, there has been turn key LAMP (PHP, specifically) solutions for Debian based linux distros for over 5 years. Ultimately - if you're so unsatisfied with PHP, or you think it's going to die, why are you posting here? Ignore this subreddit and go about your day!
Doing this for a couple of years now using reactphp. The secret is to keep an eye on your memory usage. PHP can handle it without issues as long as you don't have memory leaks, close resources etc etc. One thing though the newer the PHP version the better. 
OK fair enough. Problem is, the way Eloquent works now you're running an extra set of queries (4 with your example) to `select * from` other tables which is much less efficient than a join. And what if those tables are large and won't fit in memory?
You're too kind.
Hej, from a Danish/European perspective would you advise building a simple business site from scratch in Joomla?
You should certainly never, ever call `unserialize()` on data that can be changed by the user. However, storing the session data as some signed (and optionally encrypted) cookie has some advantages (and disadvantages) over storing it on the server. In-fact: Every method for session storage has different trade-offs to keep in mind: * Storing on the file system limits you to one application server and limits the concurrent requests per session to one as the session-files are locked (which is something your application might need, whether you know it or not). * Storing on memcache also comes with optional locking if the extension you're using supports that. It has the advantage of working even when you have multiple app servers, but you might run into early evictions due to the way memcache organizes its memory in buckets (most of your sessions will probably have the same size, causing all of them to fall into the same bucket). You also create a dependency on additional machinery that you now have to keep up and fail over lest you want to risk logging everybody out. * Storing in the database by default doesn't lock the session, so be careful that you really don't need that feature or implement it manually using advisory locks. But then be mindful about timeouts and deadlocks. Also, are you sure you want to set aside some chunk of database performance for handling session? Isn't that a waste of hardware resources? Your application's performance is most likely bound by database performance, so by reducing the load on the database, it will be able to respond more quickly which will directly improve the performance of your application. Moving session handing off your database does exactly that. * Storing them on the client naturally doesn't give you any kind of locking and puts you in a position where you have to deal with crypto, so you have to be really, really careful. On the other hand, this means that you don't need to allocate *any* resources on the server-end. This removes a point of failure from your application as there's no memcache that can be down, no database that can be overworked, no deadlocks, etc. On the other hand, you're limited to a relatively small session and you better have a separate asset host or the retransmission of the huge cookie on every request will start to consume quite a bit of bandwith as you get many users (which is where this method shines to begin with). Be mindful of what you want/need when making the decision and then be careful to keep the drawbacks and gotchas of your selected method in mind. As the advantages and disadvantages of the various methods are so varied and balanced, I think blanket "don't do this"-advice like what's given here is not actually good advice.
I use ratchet and autobahn. though I don't like how ratchet is languishing on v1 of autobahn.
Great examples guys. How about some with database mocking?
&gt; you should at least want to learn why they prefer (Eloquent) ORM over raw SQL queries. That's ... that's exactly the point of this post, is it not?
Thanks for the decent reply. 1) I agree, the constant suppression of errors is irritating. 2) We don't keep E_STRICT in production environments anyway. I don't see why you would. 3) Admittedly I have no experience on working on it in a large team environment. The office I work in only has 2 other developers and we don't have issues with stepping on each others toes. 4) This appears to be down to your workflow. The way we usually work is a development site which is stored online on a server and the files in version control. Then we make changes locally, upload to the dev server to test and commit to the repo. Then when it's ready to go from dev to production we move it over to the live server. So we do use a 'central shared dev database' which you deem scary but we have not had any problems working this way. 5) I agree, the admin interface takes some getting used to. Items are accessible before they are added to a menu item. The menu item simply gives them cleaner URLs (with SEF turned on) and some display options. I think it's a good thing that the content asset and the menu item are separate. When a user edits an item in the admin it is 'checked out' to prevent another user overwriting the changes. The 'close/cancel' buttons need to be used to check the item back in. I don't see an issue with this. 6) There are a LOT of shitty extensions. Hikashop is the better cart software for Joomla- we do not use VirtueMart. We usually write our own bespoke code and use a few of the leading components for things like the forms and media (widgetkit). 7) I have not used an extension that does this. 8) I don't see an issue with this either, really. It takes time to create software for any CMS, why is it a scam to then ask that the user 'buys' the extension or a license in order to receive support for it? Especially if the software is free to begin with. 9) Again, down to the 3rd party developers. I wont say that it's not fair to judge a CMS on this because it is, but you can't *blame* joomla for it. 10) I wont even defend this. The documentation is shit and we are always moaning about it :P 11) They don't *need* to be installed. You can upload the extension files and discoverit manually through the cms- although it does still need at least a barebones XML file. Again I don't see an issue with this as it contains publishing and developer info. 12) I can't say I've ever experienced something like this and we have deployed Joomla in some high traffic, large user volume environments. 13) We only commit files we change. This way we don't store unnecessary files in version control, as they can be obtained from, for example, a fresh install of joomla. 14) Agreed. When I started working here I felt like I'd never understand Joomla. 3 years down the line, I can use it blindfolded. Definitely not intuitive but it becomes a very powerful CMS when you know how to use it (especially if you know how to develop for it). The issue you've described is down to lack of experience with the system. Items can be accessed without menu items which is why they have separate options- the menu just takes priority. You can also have a menu that points to a category and you can subsequently access the items within that without needing menus for them individually. 15) I haven't used the examples you've given, but once a site is set up and configured it makes creating new views through the CMS very easy (providing you know how to use the interface, lol). I was in a similar position to you before I had worked with it for years so I understand your gripes. I really don't think it's as bad as people say. We've deployed joomla hundreds of times over and in varying environments with minimal aggravation. There are definitely times where we come to the conclusion "it cant be done" and we slag it off all the time. But it'd be the same no matter what CMS we're using. When you know how to utilise it it stops becoming a pain in the arse (somewhat) and starts being a strong tool, just like any CMS. They all have their shortcomings.
Pretty much every site owned by cbsinteractive.com is run with php. How do I know? I built one of them.
Is that a problem though? No no, seriously. You're inventing issues. If those tables are large and won't fit in memory **then don't do this**. They're lookup tables. Cache them in something like redis or a text file or something, and then just echo `$cachedMakes[$car-&gt;make_id]`. The short answer is... they're not. I know this situation, I know these tables. Trying to answer an infinite series of "but what if" on made up scenarios is pointless. Use the solution that solves the problem. The problem in this case is **not** ultimate high performance optimisation of the database. It's a high maintenance overhead. Nobody has ever said that an ORM is the most efficient and highly optimised solution. It's not. That's *not what it's for*.
I'm happy with Homestead for my own stuff, because I do a lot of Laravel. But anything that makes Vagrant based environments more accessible and available has to be good for everything. I think a lot of us forget how hard and intimidating some of that stuff is. 
http://i.imgur.com/qiW6m.gif 
Do I have to zip up all my dependencies? Does this deprecate Vagrant?
Second this. I have a websocket-driven chat server that uses Ratchet, it's been running 24/7 for weeks with no issues.
Commit activity *by itself* does not tell you anything, but commit activity factoring in project size will tell you quite a bit. The larger a project is, the more effort it takes to maintain. This much is a software development fact. So, it stands to reason that the larger a project is, the more commit activity it should have. Lack of commit activity in a project the size of ZF2 suggests very strongly that it isn't being actively maintained. On the flip side of that coin, lack of commit activity in a project the size of myclabs/enum does not suggest that it's unmaintained, because it's trivially small, and will require virtually no effort to maintain, as a result. Anyway, I wasn't suggesting that you use a *different* metric; only an *additional* one.
https://laracasts.com/series Jeffrey Way is the best teacher on the Internet. Sometimes I wish he's into Java so I can become a Java guru. Yes, it's $9 per month and worth every penny. 
Looks pretty, but doesn't really work with my workflow :/
This is built on vagrant..... FFS it even says so in the title.
Have a look at [Thruway](https://github.com/voryx/Thruway), it implements WAMP v2.
That's a philosophical question. Some people like to build very thin api wrappers. This way, a user can mostly operate off of the api docs, and there's more parity with other libraries. Others prefer idiomatic wrappers. These require more documentation of their own, but they'll feel much more natural to a developer used to the implementation language. I tend to think that thin wrappers are just ones with less work put into them.
[**@philsturgeon**](https://twitter.com/philsturgeon/) &gt; [2015-03-03 17:56 UTC](https://twitter.com/philsturgeon/status/572817720955297792) &gt; I had to block that guy. Sorry if you caught some spam from this, but seriously that guy was from the past. [[Attached pic]](http://pbs.twimg.com/media/B_MOrn9UsAA6H8S.png) [[Imgur rehost]](http://i.imgur.com/M2f4IX0.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Seems interesting but why not just use a provisioner like Saltstack?
I would go with having your SDK return immutable or [value objects](http://en.wikipedia.org/wiki/Value_object) that represent the parsed XML response in a way that makes sense for the domain. Bonus points if you can pass those immutable objects back to the API to do things like updates: /** @var Acme\ApiSdk\User */ $user = $apiClient-&gt;getUserById('someIdentifier'); // clone the current object, set a new email attribute // or provide builder classes, named constructors, or // make object creation easy. $user = $user-&gt;withEmail('test@example.com'); // builder example, where `fromUser` is an example // of a named constructor. $user = UserBuilder::fromUser($user)-&gt;withEmail('...')-&gt;build(); $apiClient-&gt;updateUser($user); The idea is you use object because they can be typehinted and provide an know interface (and don't require a bunch of `isset` shit). Use the same object for updating/other commands so there's less surfaces area for your users to have to remember.
I use RabbitMQ as a message queue. RabbitMQ allows you to create an asynchronous message bus. Most of my workers are written in plain PHP and are listening to RabbitMQ for specific messages. When ever they receive a message they can handle they'll execute it and wait for the next message. To make sure my workers stay alive, or are respawned when they die, I use Supervisor. Supervisor not only allows you to restart a worker but also allows you to run multiple instances of the same worker. I.e. it makes sure that e.g. there are 100 instances running of a specific worker. I have some PHP workers that are not plain PHP and use things like Doctrine. These can be memory flaky and what I do here is, I just exit the worker once they've execute their task so that Supervisor can spawn a new instance. I process a high volume of messages and most of my workers run for months and months at a time. If I didn't update and restart the machines they run on every once in a while they'll probably be running forever. 
What I would rather have is a time machine to make it right in the first place. The inconsistency of function names is annoying and weird, for sure, but I feel like making a tonne of aliases for the sake of consistency is weirder. We will end up with projects that use a mix of different versions of the same function based on when something was built, and who built it, and for new developers I can see this being extremely confusing.
Same here, but I use BeanstalkD. Works fantastically.
Yes, very much so. There is a big and active Joomla community in Denmark. In fact the largest Joomla company in the world (as far as I know) is Danish. http://redcomponent.com/ They develop web sites for many large organisation in Denmark using Joomla.
&gt;Do you mean architecturally, big-picture "new way of doing things" organization, or do you mean the nuts-and-bolts of defining and using classes? Well, I guess a little bit of both. For example, with a front-controller pattern, how should it look? Is it like fetching a template based on some parameters? &gt;Yes, there always has to be *some* procedural code that kicks everything off, a style often referred to a a "Front Controller". (This is some of that architectural-side stuff now.) &gt;For example, you might have a web-root with only a `index.php` and maybe an `.htaccess`, rather than a PHP file for every URL The user might visit. The single `index.php` code--the front-controller--loads up and configures some objects, and then says: "Hey, the user said they wanted `/foo/bar`, so go handle that." This is more along the lines of my confusion. Let's say we have an object that gets a list of customers from the db. From that objects getter (right?) we would be able to access that information in order to show a user the list. Would there be an object for each customer with fields for phone, email, etc. or would there be one customer object that houses all of the customers? In a CRUD app, what constitutes a good/proper object? This is kinda where I'm getting hung up. 
it's /r/php downcirclejerk
This must be rewrited to classes. 
Careful, it looks like Pacman is going for those testicles.
Leaving the old names for backwards compatibility is just making it more inconsistent. 
I would expect the return type to be what I would feed the system: example.com/api/datasetname/xml example.com/api/datasetname/json example.com/api/datasetname/someotherformat 
The configuration page once you spin up vagrant is pretty sweet. Would like to see this project merged into PuPHPet or for them to build similar features. https://puphpet.com/ Btw: Started the vagrantphp group on github after messing around with vagrant. Ping me if anyone wants to do something with it. 
Okay, I will look into it then. Is it possible to build a template from scratch with bootstrap 3? From my quick googling it doesn't seem like Bootstrap 3 is supported yet? Thank you
&gt;Created by thenewboston. Pretty sure these were created by Alex at PHPAcademy **for** thenewboston. o.O
Why are they deprecating PHP4-style constructors instead of the __constructor() syntax we have now? __constructer() is so far removed from what other OO languages have for constructors that it's a little strange to me that they'd keep it in favor of deprecating constructors that are the same name as the class.
&gt; and basic html skills Oh I see. *THAT* must be what I'm missing....
Yes you can. You can build anything with Joomla really.
Nicely done, OP delivered. 