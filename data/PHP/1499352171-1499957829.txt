Thanks! Here are all the postcards we received: https://spatie.be/en/opensource/postcards
Yeah, I was looking through them. I think this is a really cool way of making it feel like a personal appreciation while also showing how widely your software goes.
This is not a coding help question. Just a best practice, or what most people do. 
I do use git and GitHub to store the projects i'm working on and while i don't know everything about it and i'm probably not able to use it in the best way it could be used, i feel confident that i understand the concept of it and how it works. Thanks a lot for your answer!
He forgot he is one /r/PHP where a bit of sarcasm will go amiss.
Did you do that by yourself or are you using something like fail2ban?? If the former, can you explain (in a few words or in 7 post, your call!) how did you do it? I want to do something similar for my PI. Thanks!
Why would hosting an empty file with no public link be malicious?
You can always just use raw SQL $sum = Yii::app()-&gt;db-&gt;createCommand() -&gt;select('SUM(party_score) as sum1') -&gt;from('announced_pu_results') -&gt;where('polling_unit_uniqueid = :cal2', [':cal2' =&gt; $whateverVariable]) -&gt;queryRow(); // sum is an associative array of the data in the first row if($sum !== false) { echo $sum['sum']; }
Yes, yes, Php doesn't has covariant argument/return types... I tried to check is there any limitations in PHP itself (maybe this will cause runtime overhead) but I didn't found anything. Maybe someone who know internals (especially zend_inheritance.c) could tell why this wasn't implemented.
What is wrong with copypaste your auth controller and views ? The reasons to oursource that are pretty poor, imo.
Not the database your already using, it parses the documents and stores what you need it it's own database, it's been a while since I used it but I used it to make CV's searchable. All CV's were stored in text format, thousands of them and it would do a pretty good job of matching. You might find it works better if you strip all the XML out of the files for better processing. I have no idea if Sphinx can process XML but since it's a document based search I would be surprised if it didn't.
Check out https://mathiasbynens.be/notes/mysql-utf8mb4
Because it's supplemented for a real request automatically. Imagine if you will (it shouldn't be hard) the type of user that spams the login form. They could get their browser jammed. No matter if you think they are an idiot and shouldn't be doing or not, it's an over-the top response and isn't based in any system design or architecture I've seen.
Thanks for your work. Do you think opening a pull request to merge this with Monolog is a good idea?
Direct link to the Docker Hub repository: https://hub.docker.com/r/colinodell/php-7.2/
Context... They are making them so users can download them, serving with a mime-type that common browsers download. OP is serving gzip content without declaring a different `content-type` header and using readfile to output a very large file. It's a different concept altogether
FYI, if your post is titled "5 Common Mistakes..." don't write your headings like "Do not use the old mysql api", as that implies it's a mistake to *not* use the old API.
It's a good wagon. It'd make something like this a cli command that could be run by a CI tool. 
This includes the `object` type.
I would assume object can be used for typehinting any object (ie anything that isn't a scalar/array).
my setup is bit more complex as my (indeed self written) stuff checks everything: webserver(s), mailserver, databaseserver, ... so on the front machine (all incoming traffic has to go through there) I have a small daemon running that listens to internal http request and knows the two commands "add" and "del" with an ip address as parameter. once called it either adds an ip to the blocking chain or deletes it. now on every machine runs a watchdog that checks for unwanted behaviour and if that occurs calls the daemon with "add" $ip. cleanup is done by a cronjob that just eliminates all entries that are older than 24 hours. as said, this is maybe a bit overkill for a simpler setup. if you want, I can clean up the the front daemon sourcecode and paste it (although be warned, I'm no good C-programmer at all) and for the watchdogs that scan machines - they are mostly written in php (yes, yes - one should not do that). exactly the http-watchdog would be a lot work to cleanup because there are a lot of special cases that would reveal my sites and my identity but to give you an idea - I show how the ssh-watchdog looks like: $fh=popen('tail -f /var/log/sshd/current 2&gt;&amp;1','r'); while(!feof($fh)){ $l=fgets($fh); if( (preg_match('/.*?Failed password for.*?from (.*?) port.*?/i',$l,$a)) || (preg_match('/.*?Invalid user .*? from (.*?)/i',$l,$a)) || (preg_match('/.*?User .*? from (.*?) not allowed because not listed in AllowUsers/i',$l,$a)) || (preg_match('/.*?Bad protocol version identification \'.*?\' from (.*) port/i',$l,$a)) )detected($a[1]); } basically all watchdogs are the same, hang on the logfile for the service, watch for patterns and sum up hits. if the specified limit is reached just inform the door daemon: if(count($att[$ip])&gt;=3){ file_get_contents("http://$host:$port/add/$ip"); } and that's pretty much it.
Helpful hint for anyone that wants to use this to process a folder of images recursively: $optimizerChain = OptimizerChainFactory::create(); $imageDir = realpath('/tmp/images'); foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($imageDir)) as $file) { $optimizerChain-&gt;optimize($file); }
That's not what I meant. I mean something like this class MyClass { } function doSomething(object $thing) { echo get_class($thing); } doSomething(new MyClass()); //output is MyClass
I personally don't use else unless it's needed, but I appreciate that in some cases the indented code is a tad more obvious to read than looking for a throw / return in the singular block.
1. add a .gitignore and keep the .idea dir out of your repo. 2. Skip the requires and use Composer with a PSR-4 autoloader. 
I also follow the practice you're describing. The less nested I can keep my code, the better (of course there are cases where you simply must use it). Also applies to functions that return either true or false depending on whether something happened successfully or not, for example. For beginners though, which is likely much simpler code, I suppose having the extra *else* makes the code a bit easier to "read aloud" to help understanding. At least, that's partially how i learned coding :)
There are certainly times when if/else is needed. Making a decision based on state for example. It's tough because a majority of the time, a novice will post some code that the need guidance on and you need to make a decision on whether to just help make the code work, or make it work with improvements and an explanation.
This "Khawer ." sounds like he learned C# first, and is having trouble adapting to a C-based language. Also: http://news.php.net/php.internals/99791
Save you a click: Someone trying to imply C, C++ and PHP are not mayor languages.
great idea! I've implemented away to automatically and safely remove all useless `else` statements from a code base in the PHP-CS-Fixer; https://github.com/FriendsOfPHP/PHP-CS-Fixer
Second way every time if I can. I'm almost to the point where ive decided any time im using an else... I should probably be in a switch anyway. 
Nope. https://3v4l.org/Uvu18
It goes without saying, but if you test the object type on a PHP version that doesn't support it ... it's not going to work. On PHP 7.2 the last call will succeed. Prior to PHP 7.2 `object` was just a class name (albeit a reserved one). Please see the [RFC](https://wiki.php.net/rfc/object-typehint) for more information.
deleted, because T_D runs scripts to exploit comment history in an effort to threaten doxxing... ^^^^^^^^^^^^^^^^0.3065 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/94729)
 if (condition) { // do nothing } ...should be avoided at all times. Sadly, I see it all too often. Makes me cringe.
Just nope, it be confusing between method access and concatenation of strings.
ChangeLog will be produced for final release. Until then you can check the NEWS file. https://github.com/php/php-src/blob/master/NEWS
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [php/php-src/.../**NEWS** (master → fc336c7)](https://github.com/php/php-src/blob/fc336c78e7106d237cf98f9579790c23ca81c60a/NEWS) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djvdcrd.)^.
This is bikeshedding, except the person doesn't seem to realize their "bikeshed" is actually the solid aboveground piece of a vast subterranean complex.
One thing I've learned over the years is to take advantage of IF ELSE IF wherever possible. It's awesome in the sense that you can have many chained If statements but they will only execute until the statement is true and then it skips over the rest of the chain. In large chains, I just use switch because I think it looks nicer. 
It's important to note that anyone can post to internals - it's an open mailing list. It's not uncommon to have people post crazy ideas that obviously aren't going to pass the collective gaze of the PHP core developers. As you'll see from the replies, this idea was quickly shot down by the list regulars. Entire thread on one page: https://externals.io/thread/997
yeah most definitely not, however they would likely use a typical HTTP request library (e.g. cURL or wget) which would theoretically use sane defaults, prefer gzip encoding and handle it on the fly -- meaning the gzip bomb would still occur with those tools. That said, if more people started serving these "gzip bombs", the bot authors could just change their crawlers to add an `Accept` header that explicitly says do not send gzip data, only send uncompressed. At that point you'd have to make a decision: Will you force clients to accept gzip encoding? For these specific exploit URLs that normally would be a 404, I'd say yes, just send gzip no matter what they request.
You could also do `if (!$condition) {}` Right?
ZeroMQ with Ratchet worked great for me. I used Autobahn.js and server-side push, too. Works like a dream.
I'm with you on switch. If an if/else if gets too long, straight to using switch. 
Just curious, do you use any version control at your job? Also it shouldn't take to long to get the principles down of everything at the new company. I would think they would want you to have an overview of the development process and then ease you in on learning different parts with each task they give you. 
Yeah 4+ and it's over to switch()
We have production environment and a staging environment that you can merge with the push of a button which also does automatic backups several times a day but we don't use GIT, SVN, or any others. I know GIT relatively well I just don't use it on a regular basis. 
You are correct. I just wanted the example to be clear. 
Lookup password_hash and password_verify
Luckily, [password_hash](http://php.net/manual/en/function.password-hash.php) does what you need.
we do this at my work. We call it "exit first" : )
Hello! We're looking for valuable feedback for our repo in Github: https://github.com/flyimg/flyimg Any kind of feedback is much appreciated (code, architect, design pattern,...) we're looking to improve our microservice and to reach our main goal which is `Free image manipulation and compression for a fast and open web.` Thank you! 
That was my first thought as well. 
&gt; Looks like those Javascript kiddos Hm? Why JavaScript kiddos? Dot is how it's done in many many other large languages. I mean, I like what we got, but just because someone is used to how languages like C#, Java, Kotlin, Python etc. do it, doesn't mean they're JavaScript programmers
I believe the name for this is [Happy Path](https://en.wikipedia.org/wiki/Happy_path) programming, and it's something I'm a huge proponent of. I've found refactoring code to follow this makes the logic a lot easier to follow in almost every case
&gt; Could anybody provide some up to date information of best practices for encrypting passwords. [You aren't supposed to **encrypt** passwords](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded#passwords). Instead, you're supposed to run them through a password hashing algorithm. Password hashing is a compound noun; a fast cryptographic hash function like SHA256 is not appropriate for password storage. See also: [How to Safely Store Your Users' Passwords in 2016](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016). &gt; either built in functions/classes or external libraries are fair game You want `password_hash()` and `password_verify()`, as other commenters have suggested. EDIT: If it seems like I'm emphasizing semantics too hard, I've encountered *literally encrypted* passwords in production before, and the encryption algorithm used wasn't very good.
deleted, because T_D runs scripts to exploit comment history in an effort to threaten doxxing... ^^^^^^^^^^^^^^^^0.3065 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/94729)
might as well change the string concatenation operator to -&gt; while they're at it. That should solve the problem.
Look at ReactPHP project. here is a very good blog post about it: http://seregazhuk.github.io/2017/06/24/reactphp-chat-client/
If you use a database, just put in some postgresql one. You can have XML fields and use xpath in your indexes and queries to check specific attributes or elements.
guard methods: for example https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html
my main intention was to learn about sockets and the PCNTL library for php , unless anyone could suggest a better project on to incorporate PCNTL and possibly some more in depth PHP library's
Looks good but now is too late :) &lt;?php define('LOREM", '53'); $object = new String("test"); echo $object.LOREM So what should be the result? "test53' or Exception: $object do not have property LOREM ? PHP is not a Java, is not Javascript, is not CPP. PHP is PHP. PHP have own syntax and that is it. 
Literally the second point made in "PHP The Right Way" http://www.phptherightway.com/pages/The-Basics.html
A patient record system I was involved in auditing allowed patients to log on with a password or by entering a few pieces of non-secret personal data (name, DoB, place of birth and a few others). The password and all other data was run through `mcrypt_ecb()` with a key, hidden *brilliantly* under a column called `salt`. The encrypted personal fields were concatenated and stored in a separate column. In order to authenticate using personal information, the input was encrypted, concatenated and then used in a lookup on the `patients` table. All authenticating did was redirect you to your patient record (`patient/1343`), but there wasn't any actual authorisation check and you could freely traverse the IDs and view any patient's record without logging in. The system never went into production.
TIL I don't have to try to read the internals mailing list using news.php.net/php.internals/
Incoming mcrypt not working posts on stackoverflow.
I find switch to still be quite verbose. I prefer the "lookup table" method where possible. [Example here](https://stackoverflow.com/questions/26650389/replace-switch-case-statements-with-table-driven-approach)
How to do ?
Search for `CURLOPT_POSTFIELDS`
Fatal error at line 2 :p
Next someone will want to drop the `$`
That define feature (or rather the way if accessing the constant) is so weird to me. I never access a defined constant this way, mainly because globals are bad and using `constant()` makes it more obvious I'm using it. (Also I'm scared of overwriting or typo-ing reserved words, but I don't even know if that's possible...) 
I thought it was called "return early" or something. 
&gt; It's not uncommon to have people post crazy ideas that obviously aren't going to pass the collective gaze of the PHP core developers. It's not that crazy of an idea. There's a way to change just about anything in a language, with a very well-thought out process of change management, slow deprecation and replacement. Is it worth it is another question. But just for the sake of mental exercise: - PHP 7.3 introduces a new operator for string concat: "$foo .. $bar". It's introduced with the goal of not confusing newcomers to the language, where dot looks like the object member operator, and because it's more visible than just a dot. The old "$foo . $bar" operator still works. - A year or two pass. - PHP 7.5 deprecates the old string "." concat operator, prompting further move to the new ".." concat operator. Old code still works fine, but up to three E_DEPRECATED errors are issued for occurences of the old operator. - A year or two or three pass. - PHP 8.0 drop "." concat operator, all code must use the ".." operator. - Several years pass. - PHP 8.4 introduces "." as a new alternative to "::" and "-&gt;". Old operators still work. You get the idea. You just need to spread these over time and always repeat the same steps: - Introduce alternative and suggest people move to it. - Wait. - Deprecate old version. - Wait. - Remove old version. Sure it takes a lot of time, but you can be doing several changes like this concurrently, and time always passes anyway, and before you know it, PHP can look as a different languague. Plus... we have a precedent for operators changing mid-flight in PHP. Who remembers this: - Introducing $foo[$i] as a string index operator! - Deprecate $foo[$i] and introduce $foo{$i} as a string operator! - Ah screw it, undeprecate $foo[$i] and deprecate $foo{$i}. And somehow... we're still alive after this, to tell the stories. Oh, by the way, I have an even faster/clean/less disruptive proposal: the new "Modern PHP" block, which can co-exist with old PHP code, and will be maintained for years to come as people migrate. People can mix code from both as their heart desires, and they're 100% interoperable. For example: &lt;?php class Foo { public function showSum(string $label, int $a, int $b) { return $label . ($a + $b); } } $f = new Foo(); // Instantiating my own class. $b = new Bar(); // Instantiating "Modern PHP" class. $f-&gt;showSum('Sum is: ', 5, 5); // Calling method on my own class. $b-&gt;showSum('Sum is: ', 5, 5); // Calling a "Modern PHP" class method. ?&gt; &lt;?p class Bar { showSum(label: string, a: int, b: int) =&gt; label .. (a + b) } var f = Foo() // Instantiating "Classic PHP" class. var b = Bar() // Instantiating my own class. f.showSum('Sum is: ', 5, 5) // Calling a "Classic PHP" class method. b.showSum('Sum is: ', 5, 5) // Calling method on my own class. 
Congratulations, you've discovered guard clauses!
"However if the outcome is to define the return value…" As it's written, it's not clear that the concept can be applied to more than just return values. The concept can also apply to setting state.
It should be noted that this can also be a code smell. Looking to see if polymorphism can be applied, shouldn't be over looked.
I've always used `array_keys` anytime I needed to operate on just the keys. Didn't know you could actually filter the values you'd like too. 
I am a fan of the early function nope-out: `if (!$param) return;` In certain very specific cases only, I should add.
You're not wrong, silly bot. You do however have a thing or two to learn about humans. I was replying on my phone while pooping, so the URL was generated by hand, not by opening a tab and copying. :p
Wait, I thought we were supposed to only have one return statement, or else we would ruin lives? Isn't that a Joel Spolsky rule?
As far as typehinting, the only real change is the addition of the 'object' psuedo-typehint. Sorry.
When I am walking through my code in my head I always say "if this is true, jump out early". Also, I return a false on early returns, but I don't know if this is a good or bad practice.
Do robots dream of electronic Reddit poops?
Yes, move all float → string.
Not the first time suggested; it won't be the last. In all cases, it was shot down pretty immediately and strongly. This was suggested for PHP6 (now PHP7) while back.
I also found the title misleading. From the title, I expected issues in writing SQL queries common to PHP developers. I would suggest changing 'writing' to 'using' or 'accessing' in the title, as nothing in the article covers actually writing SQL, on in how SQL databases are accessed and used in PHP. 
&gt; The system never went into production. Happy end to a tragic tale. Also, whoever designed the system you described must have gone on to build the same system I diagnosed. :(
Yeah, I tried it: agrajag@penguin:~/src/php/php-7.2.0alpha3/sapi/cli$ ./php &lt;?php declare(strict_types = 1); function foo(object $a) {}; foo(1); Fatal error: Uncaught TypeError: Argument 1 passed to foo() must be an object, integer given, called in Standard input code on line 7 and defined in Standard input code:5 Stack trace: #0 Standard input code(7): foo(1) #1 {main} thrown in Standard input code on line 5 agrajag@penguin:~/src/php/php-7.2.0alpha3/sapi/cli$ ./php &lt;?php declare(strict_types = 1); function foo(object $a) {}; foo(new \stdClass()); agrajag@penguin:~/src/php/php-7.2.0alpha3/sapi/cli$ 
Would be possible, unquoted strings will no longer work. I'm in favour of dropping $ if we get types in return (which can also be done without dropping the $) We just need types for properties and variables.
That hirarchy is wrong. All exceptions should be under the base Exception class and all errors under the base Error class.
Haha doesn't really matter to me, symantics 
Just going to link to https://securepasswords.info which has details for multiple PHP frameworks, plus vanilla PHP, and a couple of other language/frameworks too.
I don't know that much about internals, but the reason for not supporting all cases of covariance/contravariance has to do with class loading and processing order. Currently, PHP does not actually need to load classes that are used as (return) type hints in the definition of another class that implements some interface. If the signatures in the class match those in the interface (or satisfy the very specific covariance/contravariance rules /u/ciaranmcnulty pointed out) it's ok. The classes used for (return) type hints need not even exist. When full support for covariance/contravariance would be implemented, PHP would need to load both the types used in the interface typehints and the types used in the class typehints to compare whether they are compatible. This would be a breaking change to the way type hints are processed and autoloading works. It becomes even more difficult if the relevant classes are specified out-of-order in the same file, as illustrated in https://externals.io/thread/683#email-14129.
Reading your story I would think your main focus should be learning the Yii framework and getting familiar with PHPUnit. These will be your every day workspaces and where you work your "magic". When it comes to Git and Jenkins, I would not be to worried about it. Just make sure to do one thing: ask how they want to use it. And when in doubt ask again. I rather have a developer asking me 4 times a day to check if he/she is doing something correct then having to revert repositories ;)
Unless it's a boolean function, I'd consider it bad practice. Functions should preferably return one specific type and throw an exception if it can't. Null is acceptable instead of an exception depending on the context. 
How would you do variable variables if PHP were to drop the $ thingie?
Me too! 
I'ts not a crazy idea if they decided to support "-&gt;" all through 8, add deprecated warnings in 9, and remove it fully in 10. There is a metric **** ton of code using "-&gt;" and that is the only way to be fair. To be sure there are massive problems with implementing this, those reasons are obvious to most of us.
Not. You shouldn't be doing this kind of stuff in the first place. It's a hell to work with. Never had the need to do this in the 10+ years I've done PHP.
If I had to learn a new technology when starting a new job, I'd expect myself to cram for that new language before I started my job. Now I wouldn't expect to be an expert in 1 or 2 weeks, but I'd have the basics down and know what questions to ask more experienced engineers at my new job. From my employer, the expectation would be that a senior engineer would answer my questions. I'd expect myself to be at an intermediate level within 2 to 3 months. If I expect these things of myself, then I'd expect them of those I hired. I would hire someone with aptitude and answer their questions. - PHPUnit is easy to learn, with their help, you should get it quick. It's something you can get the basics of on your own and then they can guide you with their process. - GIT is easy to learn, half of it is how an organization uses git as well. You should get it quick. - Jenkens should be setup already, not sure how much you should learn. Someone set it up at my last job and I just clicked a button, but I suppose it shouldn't take too long to learn...maybe a few weeks or couple of months? - I don't know anything about YII, but I know SlimPHP, Code Igniter 2 and CakePHP 1, 2, and 3. So learning a new MVC doesn't scare me. Prob a month for me to feel confident in it. I'd start a new YII project, just build anything. Install it using composer: http://www.yiiframework.com/doc-2.0/guide-start-installation.html then setup git with it and learn basic commit stuff. Then do some basic unit tests. Figure out which version of YII they are using, looks like there are v1 and v2. Wait and see with Jenkens. They'll be happy if you got the basics of YII, GIT and PHPUnit on your own. You can do it. It's all XYZ or ZXY man. They should start you on simple nice-to-have projects that are not critical, stuff that has been sitting in queue forever that no one has gotten around to. At least that's how I would start a new engineer, experienced or not. Good way to learn application structure, culture, and gives them enough leeway when they fuck something up cause its not critical. And you will fuck something up man. Just how it works - we all do. TL;DR Don't tell them your reddit username is "rusty_blumpkin".
Code analyzers tell you when to remove this stuff after it yells at you enough you don't really need the code analyzer. I use https://codeclimate.com/ for personal projects. I don't even really need it anymore for cyclomatic complexity. It's kinda like when your browser yells at you enough for misspelling a word, eventually, you just learn through error. I like the 2nd option, learned that from the code analyzers yelling at me. Minor gripes though.
I'm personally a fan of if (isset($array[ $key ]) { // do something } I generally go that route, there are times when I use array_search and methods like that though.
I personally don't believe in it, at least not in many higher-level languages. It's a relic from certain languages with fewer control flow statements and features, such as assembly. If it applies at all, it applies to the happy-path of a method. Allowing multiple early returns for errors (or exception throwing) makes the main purpose of the function easier to read and reason about. 
But what if you need to email them their forgotten password? I kid, I kid...
One advantage of "early exit" that doesn't really fit in with this gist (which is really more of try/catch but not his point) and I already apologize for the number of sub-clauses in this sentence but.... Early exit is a good way to catch yourself when you violate the Single Responsibility Principal. If you try to exit when a condition is false and find yourself saying, "No, I can't because I need to..." then you are doing more than one thing in your function. I'm not saying that is *never* correct for what you are doing, but it is a good way to catch yourself &amp; consider your code for smells
You can probably nab a junior dev job working in wordpress or something like that. My first programming job paid peanuts, something like $14.50 an hour, but that was 11 years ago and I was also a self-taught programmer. Only difference for me was I was 21, not 18, and had an Associates in Computer Network Systems and a year under my belt as a Junior Admin. Still, the market is good in most areas. You should be able to sharpen your skills at some shop that doesn't like to pay a lot for developers, then move onto better things. That or take some sort of weird part-time gig or something at a shop that knows what they are actually doing. In any case, definitely keep developing stuff in your spare time, that shows a lot. Another thing: when you interview for a job and don't get it, ask the person who interviewed you for advice and what you could do better at. They will give you some pointers. Learn from them. Unless they are asshats, they should totally be willing to provide some pointers - I would. When I was your age I only knew basic CSS and HTML. So you're already ahead of me in the programming stuff.
We need an answer that we can copy-paste, similar to the ones we put for "parse HTML with regex". 
What? An if-condition with literally no content?
A few weeks earlier I was refactoring a old code to PSR-2 and later on I came to a logic which I didn't wanted to touch to much, because a few things happened that would need me to test way to much (free unittests, they are no slaves! /s), but something triggered me way too much. public function abc() { if () { } elseif () { } elseif () { } else () { } } I don't know why PHPStorm wasn't triggered like me (normaly it is and tells me to do it better).. so I pretty much did what was explained in the link /u/mYkon123 posted (https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html). Took me the time to write some basic tests that doesn't include me to spend a few days to find out every single case that can happen here (I wish I could take the time, but tell a QM and a CEO that you have to do a clean and quality prozess instead of doing things that could lead to money in their eyes,.. and at all I don't care if they really want this, I will not take the blame or responsibility if something not going like expected) 
Well, it's only anecdotal evidence, but my company only expects you to be up to speed with the project after a three to six month period. BUT ... most of our projects are rather big and have grown over several years, so a new developer can't be really expected to understand it from day one. On the other hand - we absolutely expect our developers to have using knowledge of git (you don't have to know how to rebase or how to cherry pick, but you DO have to know how to commit, how to push, how to pull and at least the basics of how to solve a merge conflict yourself). We also absolutely expect our developers to have good to very good knowledge of PHPUnit, because it is such a big part of our development. Jenkins, I think, you don't really need to know, because normally someone sets up the system and then it is almost never touched again. My suggestion would be: make a two to three day cramming session getting familiar with Git and PHPUnit, then build a tiny little app using YII at home to get familiar with the framework and you should be up to speed. Everything else comes as you go. Oh, and if you are anything like me, expect for the first twelve months short bouts of "Oh gooooood, I'm so bad at this, I'm never going to understand all this shit!". They will go away with time...
Yes exactly this. In many cases classes would need to be autoloaded to tell whether the co/contravariance rules were being broken.
Have you got the PHPStorm Plugin "Php Inspections (EA Extended)"? - This thing is awesome
Don't be scared, they are no sorcery and you will learn that pretty fast. I somehow liked following page for a quick "guide" http://rogerdudler.github.io/git-guide/ If you don't want to struggle with the commandline tools, you could use TortoiseGIT, which is plain a ContextMenu for you that does the things for you (Right click on the file and choose action). Of course knowing the commands to use them on console is very helpful, esspecially if you somehow fuck up and the context menu is not enough for your need. At first it's a bit complex, but the basics are pretty easy to understand. When I started my junior career, I had "heard" of Git(hub) etc., but never used them in a professionel basis, so I had to learn it too and they just show me a few basics that I should know and how the basic "got to go" for the team is and that's it. Well, the expectations for a junior are not very high, so you more or less have many month time to get into the basics and then more month to get used to everything. It's always a steady process of learning and becoming better. In my time I had to learn 3 new frameworks from the scratch, Git and the internal guidelines.. also the current existing system is legacy of doom combined with extrem complex procedures. I still struggle on some parts (even my team leader needs to think a lot before knowing how it was going), but mostly I just need to inspect the code and then slowly,.. reach the goal. Important thing is, that you take your time to learn by your self, everything that you don't know right now. Learn design patterns, best-practices, user experiences, read some blogs etc., keep your self updated. Even if you read everyday, you still will lack on information here and there.. the internet is way too big :)
Yes, I do. It's very helpful even I am not using it in his full potential.
Interesting as someone who only flirts (not convinced for a large scale deployment yet) with Docker I don't know the in's and out's of it. Do you have any advice/guide on running multiple containers on a dedicated server? How do you manage such a thing, managing logs, SSL certs, container start/stopping, container health etc
Interesting, to me that looks pretty clean and obvious, I looked through my recent code for an example but it looks like I don't code in such a manner either. Whats your objection to it though? EDIT: After looking at my code again I see the point now, check and exit rather than the above. Its too early and I've not had my tea yet
It's a crazy idea because it does not a fix a problem. There is no problem, so why fix it and cause all the packages to break?
If we're talking about using a new operator symbol for concat, why not take advantage of PHP's unicode support ? &lt;?php $foo = 'bar' 🐈 'baz';
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Awesome! :) Is there a feature stop for PHP 7.2.0 in place now?
Being at a junior level I wouldn't get bogged down with worrying about I know x or y. At this level you will mostly be picked on your attitude and how well you fit in the team most people hiring (thinking back to when I hired juniors) will be hiring based on someone who is willing to learn and has the correct personality fit rather than someone who "knows 10 languages". Believe me what you think you know now is nothing to what you will know after a few years of experience. I look back on code I wrote when I *knew* PHP a few years ago and its pretty clear I really didn't know programming concepts that well. I even look back on code I wrote last month and think who has wrote this pile of **** then realise it was me. The point being you're ever evolving in this field and its having the correct attitude to progress and improve that will get you the jobs.
It looks like this: https://twitter.com/coderabbi/status/883043080705802241
Easier way to read it: https://externals.io/thread/997
Personally, I favour 🔗 to chain together strings 
Can you point me somewhere to start using this?
I found this to be a decent talk on the subject: https://www.youtube.com/watch?v=GtB5DAfOWMQ
Check out [Docker Swarm](https://docs.docker.com/engine/swarm/#feature-highlights) for a good starting point. 
&gt; We will still keep "-&gt;" until PHP 8 to maintain backward compatibility. Oh, "we" will, will "we"?
What is wrong with "-&gt;" ? In my editor i use macro (Alt+O for typing "-&gt;"), it is very easy to type. I think that the arrow functions will be more useful.
Did that person just describe traits?
we are thinking about extracting to a database, it seems like a better solution as we have thought of ways we can make money comparing products prices using the MPN the consumer we think will prefer it too we also think we can use it to suggest products to others we have taken a look at XMLs and determined XML are not suitable for live remote searches so we won't be doing them. unfortunately everything we do has to make money so if we are to store this massive amount of data and update it daily it will have to be automated then . but our web application involves items being tagged in photos by our content creators our content creators make up a small percentage of our userbase so we know it won't be a database that is queried frequently. but thank you all for your help
That is extremely useful! Glad I scrolled all the way down in this thread.
I would consider that he next point in refactoring. Making the change towards readability then looking to see how the design can improve 
First thing I'll be doing today!
I'll have to take a look at code climate
Amazing! I've read through the slides before but never actually saw the talk!
nah, that'd be for method chaining. &lt;?php $foo = new DateTime(); $bar = $foo🔗modify('+1 days')🔗modify('-2 months')🔗('+3 days')🔗format('c');
This is extremely crazy. So much effort for next to no real return.
I don't mind -&gt; much at all because I'm used to C/C++ (I started out with C++ a little bit before learning Java then C#), I really don't think it's a big deal having to use -&gt; even if all you know is Java/C#/etc.
Get phpstorm -&gt; https://www.jetbrains.com/phpstorm/download/ get plugin -&gt; https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-
On that same note should I also keep the final JSON response as string and not use the `json_encode()` option `JSON_NUMERIC_CHECK`? I'm currently using `bcscale(12)` so I should be able to safely convert it on my site (PHP 7.1+), see [this 3v4l.org test](https://3v4l.org/UNQfr). I'd figure most JSON implementations can deal with a precision of 12 fine? Is there a common opinion or best practice on this? Is returning an actual number data type preferable if no higher precision is required, or is string all the way no matter what better?
This is the kind of forward thinking design php was born out of!
I remember reading somewhere that the rationale for having`$` sign before vars is that the interpreter can gather variables instantly in a single sweep (as against having to distinguish between multiple tokens like constants, operators, class names, etc.). This should (at least in theory) make PHP faster than say other interpreters like Python and JavaScript because of this edge. The other interpreters will have to first evaluate the type of token and then determine whether its a variable or something else, and more such checks in an interpreted language means more waste of precious CPU cycles.
Yeah the example may not have been the best to explain the table concept, it was just the first that came up in Google. I too use the `isset` method in most cases.
&gt; PHP 8.4 introduces "." as a new alternative to "::" and "-&gt;". Old operators still work. So how would you differentiate between a static and an initialized object? PHP OOP has been like this for 10+ years, with millions of packages written etc. Asking for all these packages to be updated to the wana be javascript php 8.0 is a tall order and would have EMENSE backwards compatibility issues. &gt; showSum(label: string, a: int, b: int) =&gt; label .. (a + b) It looks like you want to change the entire language spec to Javascript. If you want to turn php into javascript, just use javascript.
I would allow 3 months for them to get comfortable with the stack and 6-12 months for them be able to work independently.
why you wanna be javascript ? its a ugly language from bad to ugly ? leave it bad i love the -&gt; please
This page isn’t working labs.play-with-k8s.com is currently unable to handle this request. HTTP ERROR 503 How 'bout dat autoscaling? 
I have seen so many broken ways of preventing concurrent jobs and checking if they are running. I hope this will help someone.
Same.
&gt; So how would you differentiate between a static and an initialized object? Why do you need to? Other languages manage it just fine. For the most part it would be obvious anyway since static usually uses the class name (`Foo.func()`) while objects use the instance variable (`$foo.func()`).
&gt;PHP 7.3 introduces a new operator for string concat: "$foo .. $bar". It's introduced with the goal of not confusing newcomers to the language, where dot looks like the object member operator, and because it's more visible than just a dot. The old "$foo . $bar" operator still works. How on earth can you say thats not confusing for people? .. means absolutely nothing.
&gt; So how would you differentiate between a static and an initialized object? One is an object, the other is a string... (either a literal identifier, a literal string, or a string in a variable). There's no need to differentiate further. PHP doesn't allow static and non-static members of the same name. &gt; PHP OOP has been like this for 10+ years, with millions of packages written etc. With this kind of thinking, PHP would have stopped evolving at PHP 4. Again, I didn't say any of this is worth it, but the **mentality that it's crazy to propose it** is toxic. It stops progress and causes pointless fights on the internal mailing list. Not long ago short array syntax was a major argument for fights amongst PHP-ers on the list. "But people won't be able to understand what `[` and `]` do, because you can't Google them! We can't change this, it'll be too complex in the parser! Blah, blah... blah blah blah!" Then after 2-3 years of this B.S., short array syntax was implemented, it was good, and it didn't cause issues. Go figure? Now we can even write `list()` like `[]`, as well. &gt; Asking for all these packages to be updated to the wana be javascript php 8.0 is a tall order and would have EMENSE backwards compatibility issues. "Immense" BTW ;-) Also, you didn't seem to get the point of the `&lt;?p` block I was proposing. It wouldn't have introduced any backwards compatibility issues. Existing code would've kept working like this for years.
The website complains about an invalid ssl certificate
Cool, now do Rule 34.
Why are you mandating the lock file to be created ahead of time? Seems it would be friendlier to create the file if needed by fopening it in mode 'c'.
Seeing how PHP already fucks me I can just show you any PHP code to satisfy rule 34
Good point, I will change this
bonus points: 🔗 symbol for method chaining can only be used when both operands are of the same type or the right operand is a child-class of the left operand :P
if it is running slow, that means that you didn't optimize it...
 const RULE_34 = [ '111' =&gt; 0, '110' =&gt; 0, '101' =&gt; 1, '100' =&gt; 0, '011' =&gt; 0, '010' =&gt; 0, '001' =&gt; 1, '000' =&gt; 0, ]; Here ya go. The porn of the one-dimensional cellular automaton world.
Many people will get alerts via their package manager, but I was a bit surprised this hasn't been posted already.
In 7.1 that would be a list destructuring. foreach ($list as list($a, $b)) {
&gt; How on earth can you say thats not confusing for people? &gt; .. means absolutely nothing. Precisely, `..` means absolutely nothing, hence it's better than `.`, which already means something else in half the computer languages out there. :-) Anyway, I'm not attached to `..` at all, I don't care about any of this. I'm just making a point that a transition is always possible, *should we want it*. Do we want it is another issue. I think the PHP syntax can be much cleaner, and I think it has impact on the perception of the language and the readability of the code. Just the use of dots by itself doesn't mean something. But put together with some related changes, it can change a busy looking code into something rather clean: Compare: &lt;?php use Foo\Bar\Validators as Val; $form = (new Val\Form()) -&gt;add('name', new Val\String()) -&gt;add('age', new Val\Integer); foreach ($dynamicFields as $name =&gt; $type) { $form-&gt;add($name, $type); } And: &lt;?p use Foo.Bar.Validators: Val let form = Val.Form() .add('name', Val.String()) .add('age', Val.Integer()) for (dynamicFields as [name: type]) { form.add(name, type) }
I teach, and I've seen two reasons: A lot of people do it to remind themselves that they did think it though, and yes, nothing should happen in that situation. For others, I think the more natural language of "if this happens do nothing, otherwise, do..." is easier to grasp than "if this isn't what happened, do..."
**Rule 30** Rule 30 is a one-dimensional binary cellular automaton rule introduced by Stephen Wolfram in 1983. Using Wolfram's classification scheme, Rule 30 is a Class III rule, displaying aperiodic, chaotic behaviour. This rule is of particular interest because it produces complex, seemingly random patterns from simple, well-defined rules. Because of this, Wolfram believes that Rule 30, and cellular automata in general, are the key to understanding how simple rules produce complex structures and behaviour in nature. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
The more I dive into functional programming the more I was lacking some of its elements in PHP. I know that PHP is not the best choice in terms of functional programming but still I wanted to give it a try :) The library is inspired heavily by Ramda.js. It still lacks few things - better object support, data structures support etc. I'll try to implement those in my free time. It's my first OS project of this size - if there's anything to improve let me know. Also, leave me feedback about your impressions. 
Yaas, bring your inner Ross once in a while. 
&gt; if($condition == false) { } over &gt; if(!$condition) { } IMO, `== false` is more succinct. Negation unary operators can get confusing if you're nested deep depending on what you're doing. Always better to expect human failure and just KISS.
I don't think my Ubuntu 14.04 will support this :&lt;
[upgrade](https://www.digitalocean.com/community/tutorials/how-to-upgrade-to-php-7-on-ubuntu-14-04) ?
Don't ask for elephant porn if you don't want elephant porn.
&gt; I remember reading somewhere that the rationale for having$ sign before vars is that the interpreter can gather variables instantly in a single sweep (as against having to distinguish between multiple tokens like constants, operators, class names, etc.). This should (at least in theory) make PHP faster than say other interpreters like Python and JavaScript because of this edge. That's cute, but no. - Python's parser can easily tell something is a local variable, because you first have to assign a value to it, before you read it. So anything that's "name =" is a variable. - In JavaScript it's even more trivial, as it requires declaring variables (with "var", and now also "let" and "const"). Also JavaScript is at least 5 times faster than PHP, we're only breathing its smoke right now... The day PHP is faster than JavaScript, I'll eat my shoes. The reason PHP looks like ass is because it just copied randomly from whatever was laying around, and using shortcuts to keep parsing logic simpler. 
As usual, it depends. You can store the straight-up output of your text area in a TEXT field, which is more than ample for the job unless you're going to be pushing 65k characters or more. Images etc are entities in themselves, backed by external resources (such as the image binary written on disk) and are best represented by separate rows for management purposes. You can also use these rows to map internal representations i.e. [img=1234] to a URL path when re-writing your content as part of the rendering process. Or, if you're wanting to package everrrrythinggg about the post (text, picture binaries, etc etc etc) into one single blob... the best solution is to realise that in all but a few very niche situations it's a terrible idea and you need to re-think.
I checked VirusTotal.com, this one is not being flagged as a virus by Webroot like 5.6.30 was. I tested Win32 NTS VC11 php.exe
I'd never even heard of random_int() until now. If we're using PHP7, is there any reason not to replace all usages of mt_rand() with the new randon_int() ?
Nope. Also, you don't even need to wait until PHP 7. https://github.com/paragonie/random_compat
I have php 7.1 running, just on 14.04. Ubuntu 14.04 doesn't like those icons in fonts, they turn into squares :/
Dumb, newbie question: can you gzip it multiple times (say, 4 times) and still get the same results? As in, is gzip x4 going to result in 10G file in the receiving end just the same as gzip x1?
True, at a glance it's easy to miss the ! operator. To add to your point, I just read that it's a good practice to do `if (false == $condition) {}` to avoid accidentally assigning and spending time debugging why the function always evals to true, instead of comparing. I think it's a good point. 
in theory yes but in practice I couldn't make it work with all browsers. This is why I was sticking to 1 gzip
Not only this, but if you're not careful you'll end up flipping your BOOL value (`!!`) and your logic will be polarized by accident. I've seen it a few times. So it's rare, but does happen.
Cool, thanks for the quick reply! (one more question if it doesn't bother you: would it work with command-line scrapers, then?)
yes it should but depends on the version of the program
amazing video..just watched like 3 versions of it :)
Thanks again -- I can definitely see why you went with only 1 zip
Hey man, I have the same exact story as you even down to the languages you've learned. The only difference is that I was extremely cocky about my skills and so I was 100% confident I could get an entry level programming job right out of high school. Two months into summer, I had my first job. That was exacltly two years ago now and I have since been promoted and doubled the salary I started at. If I did it, so can you, but let me give you a few points of advice out of personal experience: - Confidence Developers are a hot commodity. If you are good, you are needed. Period. Sure, you are lacking professional experience, but so is every junior dev that would be hired out of college. If you can prove you know more than a 23 year old with a comp sci degree, you're off to a good start. When it comes to web dev, comp sci majors don't learn what they need to in school. Your experience building passion projects and getting a few freelance gigs will likely already put you in the top 30%. However, don't be cocky. I learned quickly that I still had a lot to learn and I still do. You're never as good as you think. So, be confident but be humble. - Use your age to your advantage You can use your age to your advantage. Employers can hire you for cheaper (technically age discrimination, but it will happen) but you don't care because you just want to get your foot in the door. Any salary you get is going to be significantly more than any part time job the average 18 year old works at. Your top selling point is your age. The company can shape you into the employee they want and they can save some money doing it. Once you're in, it's time to prove youself and become an asset to the company. Start out cheap, become valuable. - Become active in the community Contribute to open source, answer questions on Stack Overflow, read articles, and specialize in one or two small areas. You have to be passionate. If you truly love this industry, let your passion drive you. --- I'm at work right now and only had a couple minutes to write this out. I'd love to talk to you more about this. We literally have the same story and I'm only a couple years ahead of you. Happy to answer more questions if you PM me!
i don't want . for concatenation but i want -&gt; for functions and i find :: pretty good too but yeah . should be +
To be fair, dot(.) is a terrible choice for concatenation, but then thats a different topic. I dont have a problem with single arrow(-&gt;) as object operator though, C++ does it this way and it works fine. 
Yes, the type has always existed, now it can be used as an annotation.
Looks like isLocked() will release the lock if locked. LOCK_EX → LOCK_SH → LOCK_UN.
You are right, though it is not common to check a lock which you locked in your own process. I would have to add a boolean property "lockedBySelf" if I wanted to fix this, I suppose?
Yes, a property should replace the need of LOCK_SH. The issue I see is that it is not expected that isLocked() changes anything.
guest what Doctrine sends to database? surprise: SQL.
Wow, that is awesome! Thank you for taking your time to write this! Its when i read stories like yours that i get inspired and confident that i can succeed. I'll definitely have some questions for you if you don't mind.
bewsat pratica might be a good name for an application or something. Just saying.
Counter attacks are not legal in many parts of the world. The question is of course if the attacked would bring it to a court of law. Now having a honey pot where some attacker pulled the file rather then had it sent. That is a different situation. 
My brain clearly isn't at 100% but even given the example I'm not sure I understand 'happy path' programming. If validation doesn't raise errors when do you raise errors?
I always loved his title. Insult then help.
You are not sure "is PHP metrics accurate"? If so, Yes. You could just use phpmetrics.
Lately I've been finding myself doing `if ($condition === true) {}` and `if ($condition === false) {}`. I had a friend do a code-review on simple project and he asked why not just `if ($condition) {}` or `if (!$condition) {}` and it made me question if I was being a bit too verbose and cautious, but I know I've been bitten by not considering the type-juggling on values that return integers.. it was my fault, but every since then I just go the verbose route.
No, it means that the happy path is the one without errors, and you raise errors or return early. For example public function validate(int $number): bool { if(!is_int($number)) { throw new Exception(); } if(strlen($number) !== 16)) { throw new Exception(); } if($this-&gt;isMasterCard($number)) { throw new Exception(); } return true; } Imagine the conditions as paths in a road, where each if and else is a fork with paths. In Happy Path programming, as far as I understand it, you seek to remove the paths that aren't the happy, expected use case. If the data is bad, return. Instead of utalising elses to create branching paths, you simply say "If the data is bad, throw an exception or return early", that way the ONLY path left is where the data is good. That way, when you look at the code, instead of trying to keep in your head a model of the nested ifs and else's, you can just say "At this point, we have exactly what we want" 
Oh - I totally do that. Return early. Thanks btw.
Yup. Return Early is probably the better name for it. I don't know why, I just prefer Happy Path programming. It seems more intuitive to me.
Well, I've always seen it as, our jobs as developers is to be as succinct as possible. If that means a small degree of verbosity then it should really be no big deal to ensure that what we're writing is easier to understand for someone else.
For some reason the title reminded me of "Order 66"
 &gt; Sadly `and` keyword is reserved so this function has to be prefixed with `ƛ` Please no.
does it have codeception support?
Yes, it should work with Codeception too: Add to `codeception.yml`: reporters: report: Coderabbi\Phpumoji\EmojiPrinter then execute tests like: codecept run --report However, I didn't try it myself. Couldn't install this package with unstable dependencies
Harry Potter library. 
Yes! Thank yoU!
I use "all" and "any" as common replacements for "and" and "or" -- it makes sense to me as "and" generally implies **all** conditions are true and "or" implies that **any** one of them is true.
This is the second or third "functional" library I see that takes the word "functional" literally and implements it with PHP4 style "function" declarations. That's not practical. It's inflexible, error prone, verbose, and you get no autoloading. And the `ƛ` prefix is a really terrible idea, for what should be obvious reasons. You had enough awareness about this to create your static class, but you didn't go all the way, you instead made it a wrapper that proxies the functions, rather than implement them directly this way. The current approach isn't pragmatic I feel. For every single function you have four things: - The function. - Namespaced constant (pointing to a function's name). - Static class proxy method (that runs the function). - Static class constant (that copies the namespaced constant). Two of those are unnecessary. I would propose you drop the function and namespaced constants *entirely*, and implement directly as static class methods + constants. This will be faster to maintain, faster to use, faster to run, and much less confusing. Here's a proof of concept: namespace Foo\Bar\Math; use Foo\Bar\Core as c; static class Math { static const sum = [self::class, 'sum']; static const subtract = [self::class, 'subtract']; static const multiply = [self::class, 'multiply']; static const divide = [self::class, 'divide']; static function sum($a, $b) { return $a + $b; } static function subtract($a, $b) { return $a - $b; } static function multiply($a, $b) { return $a * $b; } static function divide($a, $b) { return $a / $b; } } // ----------------------------- // Usage: // ----------------------------- use Foo\Bar\Math as m; use Foo\Bar\Core as c; $c = m::sum(5, 5); $arr = array_reduce([1, 2, 3, 4], c::partial(m::multiply, 2)); And again, through this approach, you can have all the x::or() and x::and() methods you like etc. That said, I'm wondering about the purpose of these libraries. The implementation of curry is *very, very expensive*, and it bogs down the whole library, in service of implementing a feature that's *really not that important to functional programming to begin with*. You don't need to have curried functions, in order to have partial calls. And frankly, you don't need a dedicated partial function, in order to do a partial call, it's as simple as: $partial = function ($c, $d) { return x::something('a', 'b', $c, $d); }; With a simple wrapper like this I can achieve the same purpose with much better performance, clarity and type-safety, and also *I can partially apply arguments out of order*, which is important in real-world applications. The only thing we truly need, is a short closure syntax, then we won't need a functional library for partial application, and basic math/collection/etc. operations, because it'll be easier to just write the code inline: array_reduce($arr, $a =&gt; $a * 2); 
I agree for your concern regarding your action for newly created accounts. But I assure you i wont post and generate illegal traffic from my end.
o, there's a version of PHP less than 7? ;)
There's a syntax error in the usage example (missing concatenation operator before the ternary): `echo 'busy? ' $lock-&gt;isLocked() ? 'yes' : 'no';`
I just commit the lock file, composer install with the lock file is instant compared to without it. Dep tree calculation is a time sink, installation is not.
Thanks. In this case, `all` and `any` is reserved for collections (plus they accept predicates) so I can't use those names.
Thank you for the feedback (and time!). Let me answer to some points: &gt; This is the second or third "functional" library I see that takes the word "functional" literally and implements it with PHP4 style "function" declarations. Could you elaborate on this bit more? Or did you do it later in comment? :) (sorry for dumb question) &gt; That's not practical. It's inflexible, error prone, verbose, and you get no autoloading. I found that those functions are quite flexible - could you give me some example where they fail? Autoloading is "fixed" - composer will load file with functions definition. Static wrapper loads via PSR4 autoload. &gt; And the ƛ prefix is a really terrible idea, for what should be obvious reasons. Yes, I totally agree with you :( &gt; You had enough awareness about this to create your static class, but you didn't go all the way, you instead made it a wrapper that proxies the functions, rather than implement them directly this way. The reason was that I wanted to avoid LOC in this class. It is meant to be just a proxy, without any significant code. Right now it has &gt;1000 LOC. With full functions definition it would be much bigger. &gt; This will be faster to maintain, faster to use, faster to run, and much less confusing. In my head development was focused on writing only function definitions. I've created a bundler command which bundles them to proxy function. During development this approach was quite suitable, however I can imagine that for someone new this may be confusing. I've looked at your example - it makes sense. It's quite possible that in future I'll split main class to smaller chunks. If so, it will be reasonable to put all the logic there (drop the proxy). &gt; The implementation of curry is very, very expensive, and it bogs down the whole library, in service of implementing a feature that's really not that important to functional programming to begin with. Before writing Phln I've used a lot Ramda. Now I'm learning Haskell and both of them curry their functions out of the box. I know that in PHP this comes with a cost. Yet I find it super usable. Instead of writing: &lt;?php $filterFoos = Phln::partial( Phln::filter, Phln::partial( Phln::equals, 'foo' ) ); I can write simply: &lt;?php $filterFoos = Phln::filter(Phln::equals('foo')); This lowers significantly cognitive load. &gt; You don't need to have curried functions, in order to have partial calls. And frankly, you don't need a dedicated partial function, in order to do a partial call, it's as simple as: It's just a convenience. Specially in case where PHP has no simplified lambda functions. Part from contains() function: $stringContains = partial('\\strstr', [__, $value]); $f = typeCond([ ['array', any(equals($value))], ['string', both(T, $stringContains)], [otherwise, F] ]); Without partial it would be bit bigger (and imo bit clunky): $stringContains = function ($str) use ($value) { return strstr($str, $value); }; $f = typeCond([ ['array', any(equals($value))], ['string', both(T, $stringContains)], [otherwise, F] ]); I guess it's a matter of coding style. &gt; With a simple wrapper like this I can achieve the same purpose with much better performance, clarity and type-safety, and also I can partially apply arguments out of order, which is important in real-world applications. Agreed about performance. I hardly agree about type safety - partial is just a wrapper, however when type error appears it will be harder to debug. Partial implementation in Phln supports placeholders so you can apply arguments out of order. &gt; The only thing we truly need, is a short closure syntax, then we won't need a functional library for partial application, and basic math/collection/etc. operations, because it'll be easier to just write the code inline: Yes, totally agreed. Again, thank you for your feedback. 
Curious to know how it compares to https://symfony.com/blog/new-in-symfony-3-3-lock-component
https://m.imgur.com/t/reaction/n3RZCFS
textaera ----
That's not what stringly typed means. It means using strings to differentiate type, as in using say a generic object with a string $obj-&gt;kind field. In this case you have no proper type to hold decimal data. So your options are using some other type. String can do it without data loss, and float would result in data loss. So the choice is obvious IMO.
ZeroMQ was created by the developers and architects behind RabbitMQ and the AMQP protocol as a response to all the problems they encountered with big centralised message brokers. &gt; When you switch to ZerMQ you will have to unlearn the AMQP patterns and learn new ones. Essentially, ZeroMQ gives you intelligent sockets to which you can delegate various messaging patterns. It is like having small brokers all over the network. The lack of a single "stable" point of reference may be disorienting at first. &gt; Both technologies are open, fairly cheap to learn and use, and better than anything else that exists. **Where they overlap, ZeroMQ does it better, with smarter queuing, less management costs, less complexity, and significantly better performance.** A smart team would learn them both and possibly use both in parallel, i.e. applications talking to a central broker via AMQP but also to each other via ZeroMQ. If AMQP/0.9.1 survives its own working group, it may become an IETF standard for messaging. -- The creators of RabbitMQ But of course you know best because you've programmed your own MQ protocol and server from the ground up and had it made into an IETF standard for messaging, correct?
so you do a composer update --lock myvender/*, before pushing projects? hmm, could this be done with a githook perhaps edit: not a very good my situation, i dont want to do this for multiple projects everytime some core library has a release. when a lib gets released it has to trigger the build processes for all the projects that depend on it. so it has to be part of the deployment strategy
Wait until you hear about the "in production" system "encrypting" medical records by xoring then with md5(password). 
No, I install/update vendor libs while developing and commit the lock file. When deploying, I run composer install to just install exact versions requested in lock file, no version changes or additions / removals are allowed on production.
Commit the lock file for dev purposes, but have a build server in place for staging and production purposes hat prepares complete bundles (e.g. Our build server creates an AWS code deploy bundle automatically when all tests pass). 
100% this. As long as you can show you're not a 'developer' that needs handholding to learn things, then you're good to go. Get out there and start applying for jobs already! Ps. Hi Twiggy
Article needs more explanation as to why and what the difference is
Heh, 1000 articles on this already, why write another in 2017
Because it's still a relevant, ongoing issue in 2017. And the tools to make it a non-issue are more widespread and easier to use, so there's even less of an excuse. 
Thanks for the feedback, added more info.
Well at least this one is short and concise. The author was probably just proud of himself learning how to do this, but still doesn't really understand it (hence the lack of detailed information).
Fosuserbundle doesn't handle authentication or password encryption, that is still handled by symfony's security module KNPUniversity has a great course on symfony security, you should be able to read it without purchasing the videos https://knpuniversity.com/screencast/symfony-security
Groundbreaking stuff.
I omitted the detailed information *because* there are 1000 articles on this already, new PHP devs still use md5/sha1 in 2017, and maybe it's because they can't be bothered to read the details, give up, or are just looking for simple answers? I added Wikipedia links to Rainbow tables and Bcrypt for people who want to learn more. Good times.
It won't happen overnight and (hopefully) your team and boss will understand this. I was in a similar position last year when I moved from a support position to a project team where we are building a new platform. I've had to learn Symfony, React, AWS Services, Ansible, Jenkins Pipeline, SASS, PHPUnit, Docker and some other stuff I can't remember. Even now though I wouldn't say I am an expert on all of them and there is always something new I find.
TIL `password_hash` and `password_verify`. Thank you.
Your title is clickbaity, your article light on content and you should feel bad.
If you read the docs it's not an ongoing issue. They literally tell you what to do for password hashing. http://imgur.com/a/PulS3
ZeroMQ is library. Rabbitmq is message broker. Fill the difference. You can't say "ZeroMQ is the answer" for such general question. All this benefits that you highlighted are comes from the fact that this is library, which you could use to build communication between your services/actors almost without overhead.
Forking on each connect is generally a bad idea because the more users connect the more forks you have running and you'd run out of system resource real quick that way.
Touché.
[/r/php: Remove unnecessary else statements](https://www.reddit.com/r/PHP/comments/6lnp1j/remove_unnecessary_else_statements/)
It works now
Ongoing issue in 2017? We were using md5 for passwords 10+ years ago because a lot of us were learning from a certain 'user system' that taught us to do it that way. Heh, oh the good old days when we were all noobs and a 'user system' was so very impressive!
Eh. It says what it has to say clearly, and skips the fluff. It's true that most sites run on some sort of rot13 + md5 hashing scheme (if any). Are those people reading blogs is another question.
It's not unnecessary, but he "abstracted" the code for the `else` to a comment. In the real world it'd be showing an error page.
If you have the ability to update packages on this box, look into IUS. You could, at minimum, bring it up to 5.6. https://ius.io
No, the point is that he should flip the condition to exit if it fails to verify, not use an else. i.e. if (!password_verify($input, $hash)) { // Invalid password / show error, etc exit(); } // Check if pass needs rehash, login, etc. 
Oh right, plop that thick `exit()` right there, that really improved the code. I love when code I use just calls `exit()` out of the blue on me. We sure avoided that pointless `else`.
... That's not the point of what I'm saying, I just put that to point out that you stop execution there, i.e. `return` with some error page or whatever. Sigh. It's a damn example. The point of removing the `else` clearly went over your head. I guess I need to restate what that thread was saying. If you constantly have the error handling in the else, then all your success cases end up within the if body, meaning you're nesting code. Do this a few times in a row and now you're indented like 3-4 times in, making the code needlessly unreadable. Also the condition code ends up separated from the exception thrown or the error message displayed, further adding to confusion and unreadability.
https://www.reddit.com/r/PHP/search?q=hate+php&amp;sort=relevance&amp;restrict_sr=on&amp;t=all TL;DR is that most people who hate on it remember it from the days of PHP 4 and such, where it actually was terrible, but now it's basically just an unwelcome meme.
Because it has big ears. But seriously, everyone makes fun of php. 
PHP used to be a much worse language than it is now, it's ecosystem used to be painful and it's features lacking. But we're talking a decade ago. The main reason is it's low barrier of entry, very much like JavaScript. It means it's easy to get started without knowing how to write good or even secure code, there's 101 tutorials out there on anything and everything written by people who don't know how to write good and secure code and there's tonnes of people coming in who don't know how to write good and secure code. The ease of entry is what I believe is the languages strength is, but it also means that there is A LOT of bad code out there, because it's one of the easiest languages to start as a first language without doing a course in programming or Computer Science
&gt;tonnes of people coming in who don't know how to write good and secure code Whoops... I guess I'll have to learn again. I swear college professors were shit. 
So long as you know some basics of SOLID principles, know what a package manager is and have a vague clue on how to avoid SQL Injection through Prepared Statements, you're far away from what I'm talking about. If not, now's a good chance to read up on SOLID, learn Composer and look up SQL Injection and PDO Prepared Statements. Then at least you won't make the worst mistakes... Also `password_hash`. Go read the doc page on that Edit: Better wording
&gt; Sigh. It's a damn example. Just as OP's example was an example? &gt; Do this a few times in a row and now you're indented like 3-4 times in, making the code needlessly unreadable. It wasn't the case here. But nice job making a storm in a teacup.
Maybe this [kind of questions] should be added as a sticky thread/announcement. Like an FAQ, literally.
Hey, you're the one who brought out the attacking tone here.
If you wrote the simplexml function(s) yourself, and are happy with what it does on small files, why not convert the code to be compatible with streams? As you pointed out big files don't scale well when trying to load them in memory via defaul simplexml behaviour. Here's a lib that you could probably salvage. It does streaming and is simplexml compatible: https://github.com/prewk/xml-string-streamer
And yet, when I do a google search for "php user password" or "php save password", results like [this](http://www.phpeasystep.com/phptu/6.html) and [this](https://stackoverflow.com/a/19531260) come up on the first page of the results (the latter being the _first_ result, above PHP's own documentation which states best practices). Even PHP's own [FAQ](http://php.net/manual/en/faq.passwords.php) on the subject is a giant wall of text, that fails to say "tl;dr: use `password_hash()`" at the very top. Until easy-to-follow best practices documentation dominate the search results, this will continue to be a problem. And these need to somehow be *more obvious* than just storing the password in the database as plain text, which is what newbies will do by default.
The skill floor is basically nothing. Also, Wordpress.
You mean we aren't supposed to use mysql_pconnect($_REQUEST['db_stuff']); ?!
Because Reddit is [written in Python](http://techstacks.io/reddit) and Reddit is cool. But the anti-PHP memes they use to make fun of us are posted using Imgur which is [written in PHP](http://techstacks.io/imgur). Joke's on them!
&gt;even a monkey can do php I've seen the depths of abhorrent C code, VB6 accounting software, C# "management software" atrocities, but they won't end up on GitHub nor will they end up serving a broad audience. Your average beginner writing code in these languages will leave in tons of security holes and bad practices, but such code won't wind up online in front of billions of people, and chances are they won't be uploaded to GitHub. Writing PHP, on the other hand, usually means you *will* throw your creation in front of billions of people, and that's where the shitstorm begins... it's just too easy for a complete beginner to write a simple script and drag it over to a shared host via FTP. This also means complete beginners will try to use PHP for anything and everything, even when another solution would be a better choice. This also means said beginners will flood public forums asking the most basic of questions, and this also means the "average wage" of a PHP programmer will go down. Also, in my experience, when a beginner programmer doesn't get what he wants, he will tend to bitch about it publicly and blame the language and the technology, which makes things worse. When they do switch to their second language, they will badmouth their first one like they would their ex. Yes, PHP has some crap which needs sorting out internally, and it will get there in time, but I can't say PHP has ever left me stranded. It has been very good in regards to backwards compatibility and its performance was just fine. Compare this to an application I was writing in C# a few weeks ago... it was a simple threaded API, and it was supposed to listen to a port and spit out some data when requested. Yes, WCF was recommended and I used it. It held my hand, but it *did not let go*... ever. I had to fight that thing tooth and nail! When I wanted to do anything more (as in - spit out a custom 400 page), I got recommended to use ASP! What?! To make things worse, it doesn't work in .net core nor is it supported in Mono. And configuring the limits and parameters in XML is confusing and unintuitive, even with the MSDN documentation. The JSON it spat out was weirdly formatted as well. So... is C# crap? Hell no, it's fun, performs well and has plenty of features. Just because I had a bad time with a part of the language doesn't mean I get to bitch about the whole thing, nor will I spend my valuable time complaining about a first world problem such as that one. tl;dr: Plenty of beginners worldwide. Easy to get into the system, easy to deploy, easy to fuck up.
Never thought about this. Good idea.
As a general rule, your web app should not be written like it's worth 10 points in a CTF.
Jeesh, I know! Counterpoint: Give me a plain and simple Wordpress over an overengineered Symfony catastrophe any day. Usually has better performance, too (==needs half as much Varnish to be tolerable). I'm not kidding here. I have 11 years of programming experience and I'm convinced that a lot of the "enterprise" stuff (and I count most of the big, "professional" frameworks in that camp) is just pointless architectural masturbation that serves nothing but the egos of the lead developers. People love to hate on Wordpress for sport. Usually, though, their job is implementing the exact same architecture that Wordpress has, but with 20 times the complexity and code and obscuring all the simple concepts with byzantine monstrosities hiding behind fancy sounding buzzwords.
Not sure I would call SOLID principles basic. I haven't met that many people here who can explain them all correctly in their own words.
&gt; Is php that bad? Yes. It's very much a usable tool, but its pervasive and numerous flaws impose a higher cognitive overhead on the programmer than something cleaner and more competently designed. &gt; Are there better things out there? Most every one of PHP's contemporaries. &gt; Is it because "even a monkey can do php" quote? PHP's barrier to entry is slightly lower than some other platforms, but only really in the aspect of getting to hello world. The rest of it is just as hard. ---- You will hear “PHP used to be worse, it's not true now” a lot. People have been saying that for years. It's not entirely wrong: PHP isn't as bad as it was. But it's still worse than its contemporaries, even JavaScript, and a lot of things that have been fixed are low-hanging fruit, so more fundamental improvements may never come. That being said… should you avoid PHP? If it's a productive tool for you, no. But you really should learn at least one other modern programming language, lest you not know what you're missing.
Having worked with both Node and PHP 5-7, I would not say that Javascrpt is better. ES6 a huge step forward, but it still isn't there yet.
deleted, because T_D runs scripts to exploit comment history in an effort to threaten doxxing... ^^^^^^^^^^^^^^^^0.3065 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/94729)
[removed]
how?? 
I don't know man, wordpress "architecture" is pretty terrible. I'd hope people aren't reimplementing whatever that is. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I partly agree. I think it could be improved a lot by making it *even dumber*.
Some devs really need a big complex message broker to act as a single point of failure, precisely like some devs really need a big centralised version control server to manage software projects, users, rights, commits, etc. I concur, these devs really exist! Small and distributed command line tools like Git and Mercurial is the sure road to failure. All the benefits that people highlight about them comes from the fact that these command line tools, could be used to create version control between developers almost without overhead and without involving a server in the equation. Surely, the future belongs to CVS, Subversion, Perforce, VSS and Team Foundation Server. These are reliable and battle tested products from software vendors you can trust.
&gt; Whoops... I guess I'll have to learn again. I swear college professors were shit. I don't think it's college professors being shit (while many are), it's just different languages have different standards and features. I've been programming for years, but it took a little bit to write Node where there wasn't callback and promise hell everywhere. Or write Objective-C and figure out how to structure classes that make sense for app development. Or write PHP in a clean, organized structure. I learned a ton in college about SOLID principles and data structures, but a lot of education isn't designed to make you learn a specific language or tool.
Eh, CS is often expressed as code and with code creation in mind, but the driving forces behind student code and academic code are very, very different from what drives production code - so it's not too surprising that the outputs from the two are very different as well.
&gt; Give me a plain and simple Wordpress over an overengineered Symfony catastrophe any day. Usually has better performance, too (==needs half as much Varnish to be tolerable). There is not a chance anyone would write an enterprise system in Wordpress or even have close to the complexity that some Symfony projects have. &gt; is just pointless architectural masturbation that serves nothing but the egos of the lead developers. Yes, keeping your controllers, views, models, services is masturbation, not something smart to keep your code organized and clean. Having good dependency injection, easy configurability and highly tested and scalable tools is a bad idea apparently.
[removed]
Because people have been creating terrible code with PHP for years. Although quality has gotten better and there are great tools out there, there is still code that's coming out like it's PHP4. And a lot of the time people have to work with this code and maintain it daily and it leaves a horrible taste in their mouths. Here's something posted today in this sub. If I had to work on this system, I'd hate PHP too: https://github.com/yTakkar/Instagram-clone/blob/master/config/class/post.class.php
 [yTakkar/Instagram-clone](https://github.com/yTakkar/Instagram-clone) &gt; *Description*: An Instagram-clone with my own flavors and features. Screenshots below!! 😍😅😆👁🙏🍻📸💝☢️🏳️‍🌈🤞 &gt; *Stars*: 13 &gt; *Forks*: 6 &gt; [Issues](https://github.com/yTakkar/Instagram-clone/issues) | [Pull Requests](https://github.com/yTakkar/Instagram-clone/pulls) *** ^(This is Earth radio, and now here's human music ♫) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [yTakkar/Instagram-clone/.../**post.class.php** (master → 258639b)](https://github.com/yTakkar/Instagram-clone/blob/258639b91b014d41c0a5dcf8a468171b3365b07b/config/class/post.class.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djyj1no.)^.
top notch projection, keep it up 👍
Where are the namespaces, unit tests, doc-bocks, PSR format, separation of concerns? I hope you had fun doing this project, but for anyone reading, this isn't a good example of how to code in PHP. Everything about this class makes me shake my head, from the PHP4 naming convention to no namespaces, to HTML in the file, inconstant formatting, no return types or consistency of return types, accessing global variables where, no dependency injection (or is there I have no idea what that "N" class is). https://github.com/yTakkar/Instagram-clone/blob/master/config/class/post.class.php Besides that, the interface looks nice!
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [yTakkar/Instagram-clone/.../**post.class.php** (master → 258639b)](https://github.com/yTakkar/Instagram-clone/blob/258639b91b014d41c0a5dcf8a468171b3365b07b/config/class/post.class.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djyj9n5.)^.
Sorry, I didn't mean that it's basic, I meant the basics of it. Bad wording. In my opinion, SOLID is something you hone over your career, but if someone at least has an idea of Single Responsibility and Dependency Inversion, it'll go a long way. 
N class is for db and its static method _DB() returns PDO connection which is in config/class/needy_class.php. I created the project when I was new to PHP. When I was developing the web app, I never thought of implementing namespaces, unit tests, etc.... you just mentioned, all I wanted was to create it &amp; provide it as many functionality to it as I can!! I am not a PHP expert &amp; not a fan of PHP, So I am trying to convert this project into A single-page MERN app, only javascript &amp; Go for back-end. 
But what if I _really_ trust my users?
JS is worse without any doubt, and ES6 does not change that. 
There is no architecture in wordpress. Only hooks. 
I guess architecture only exists when it fits the currently accepted canon of buzzwords. You might think you want to use globals, but nope, you should actually be using a configuration service without any injected dependencies. CLEAN
Looks good! I've been looking at pattern-matching with images (not facial recognition) with PHP or whatever cause it's going to be a queued action - have any experience in that area?
Looks nice. Why would I use it over my favorite FP libs: * https://github.com/lstrojny/functional-php * https://github.com/nikic/iter * https://dusankasan.github.io/Knapsack/ * https://github.com/widmogrod/php-functional
The purpose of OP's example was `Read the snippet and reason about it`. It's relevant because it increases readability.
More specifically it returns a NEW PDO connection on every call. We just went over this [here](https://www.reddit.com/r/PHP/comments/6ldhme/jokes_irl_a_man_and_a_genie_or_a_failed_singleton/). Make your naming meaningful and also follow all of the advice/criticism expressed by /u/domdomdom2.
Along with what has already been said here, there was also a blog post in 2012 which generated a lot of PHP Hate. [PHP: a fractal of bad design](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) was very influential in the community and though now ~~completely~~ mostly irrelivent, has had a lasting effect on people's opinions of PHP and PHP developers.
Oh, but there is no "utils" class. Those concerns are well separated to the classes `universal`, `random` and `needy_class`.
&gt; Most every one of PHP's contemporaries. ... &gt;so more fundamental improvements may never come I'm gonna regret asking this question, but... Why are you contributing to PHP anyway? You always claim there are more better solutions out there, and are very much negative when it comes to the future of the language itself. So, why even bother in the first place?
I started this project in December of 2015, and I have to say this has been an incredible learning expierence. I've since managed to land a job in the Software Engineering field even with a completely unreleated degree. I figured I'd include some learning points that have come up during the course of this project. Feel free to ask any questions, or provide feedback. I'm nowhere close to perfect, and always love getting feedback and suggestions for how I can improve. * Being the sole core maintainer on a project of this size is quite time consuming. I've had to do a lot of re-prioritization and learning to say "No" to things that sound cool, but would simply set back core development even more. * Tests are important. I made the mistake of saying "I'll deal with tests down the road" at the beginning, and that has certainly come back to bite me more than a few times. Now that I am starting to do unit testing with all of my new refactored code it has snown me quite a few places where I am doing things in a not-ideal manner, or where things could be simplified. * There are so many different systems out there, making something that works smoothly across all of them seems impossible. * Memcached requires a gentle touch and a few short prayers to get installed on some systems, good luck documenting that. * Being open about security vulnerabilites is a double edged sword. I've gotten plenty of positive feedback about my openness, but it also can be difficult to balance when there are commercial instances running that you don't want to cause problems with. * Turn off direct notifications if you value your sanity when using software that users can ping you in. * Websockets are now being blocked by AdBlock in some cases which can caused a lot of debugging confusion when working with users, but has since just become a nusiance. * There is always a different way to do something.
/u/frozenfire Time to update the wiki, maybe?
As someone in of a similar mind to /u/the_alias_of_andrea: because I run into a lot at work and need to work with it. Keeping up with the general news about what's going on with the next major release or whatever is something I ought to keep on top of. I don't care much for Go, either, but I also keep an eye on /r/golang because the odds of me needing to use a project written in it or otherwise finding knowledge of it useful are high.
**Here's a sneak peek of /r/golang using the [top posts](https://np.reddit.com/r/golang/top/?sort=top&amp;t=year) of the year!** \#1: [The struggles of a C programmer switching to Go](https://i.redd.it/2ckqvxbhib0z.jpg) | [18 comments](https://np.reddit.com/r/golang/comments/6dwm8t/the_struggles_of_a_c_programmer_switching_to_go/) \#2: [Rewrite from Java to Go had made things 10X slower](https://i.redd.it/h64ned6whn5z.png) | [51 comments](https://np.reddit.com/r/golang/comments/6ja8mn/rewrite_from_java_to_go_had_made_things_10x_slower/) \#3: [Go 1.8 is released](https://blog.golang.org/go1.8) | [66 comments](https://np.reddit.com/r/golang/comments/5uhu4b/go_18_is_released/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Tell them to start unit testing. I found that this helped bring home/hone most/all of those principals. 
I'd love it if you go through an early(ish) copy my Docker for PHP Developers book as one of your learning resources. DM me on Twitter!
I also keep an eye on /r/golang, even though I don't use it much. But I don't think you understand... [she *contributes* to the codebase of PHP](https://wiki.php.net/rfc/unary_null_coalescing_operator). I do appreciate her work, but the constant negativity is tiring.
Is there a thread you'd like to see referenced in the wiki for this question? I've yet to see one where the answers really encapsulated the various reasons why people take issue with PHP as a language.
By far the the best plugin for PHPStorm! **edit** never mind...[this exists](https://plugins.jetbrains.com/plugin/3799-hotornot-plugin) 
Thank you
To go with a Python example `getattr(obj, name)` will take some object and attempt to access the attribute `name` on it. It is effectively identical to `obj.&lt;name&gt;` except that it allows `name` to be any arbitrary string rather than needing to be an identifier. Of course PHP could choose to add a new keyword or syntax or operator to do such a thing. Hell, make things nice and confusing, drop the `$` sigil to denote variables and redefine it as an operator to access members using the name in a string! `obj$"some_name";`
To quote Rasmus Lerdorf &gt; I was really, really bad at writing parsers. I still am really bad at writing parsers. Most every language eschews something like the `$` required for variable identifiers because you can make grammars for your language that make it unambiguous whether a specific token is a variable identifier or not. In fact you can make many pretty good grammars for programming languages with that property. Lerdorf just wasn't big into parsers, though, and going with the `$` made it easier to work with writing up a parser. As /u/LtAramaki said: it doesn't really confer any advantage speedwise - languages without the `$` have to be parsed out in a very similar way to PHP, and the time difference in determining what's a variable identifier because it starts with a `$` and what's a variable identifier because that's the only thing it could be given the language's grammar is trivial.
Almost; beta1 marks feature freeze. I'll be dropping that on 20 Jul if all goes as planned. https://wiki.php.net/todo/php72
I don't understand your question. Add filter and add action are core WordPress functionality. The template files are loaded by WordPress and thus the template files can use the WordPress functions.
If those libraries are in active development, I'd strongly recommend either: * moving everything into a single monolith repository. This makes it easy to keep the projects in sync with the any changes in the libraries, particularly if you refactor the code using PhpStorms refactoring tools. * duplicating the libraries into each of the projects, and the either keeping them in sync by copying and pasting the files across on a regular basis, or just letting them diverge, and then revisiting them every few months to see if the changes should be synced or not. Trying to keep libraries across projects up-to-date has a massive cognitive overhead, as well as the technical details of keeping the versions up to date.
But how can a file use a function from another file without including it anywhere?
Not a Wordpress user. Pretty sure the file was included/required at some point, doesn't have to be included in the file that's using the functions. Best you can do is start a debug session with breakpoint where the functions get registered by the engine. Then you'll get a backtrace as who called/required the file.
It has a horrific security track record. Which is related to the fact that it is usually implemented in a very poor way. It seems those who choose to rely on php heavily, are really shitty programmers and generally have a lack of concern for security.
The header.php, belonging to a theme, is not an entry point, just an included file. /index.php is the standard front end entry point to WordPress. header.php is itself included by WordPress after template-functions.php was required. So WordPress includes the theme template files, not the other way around. Hence, template functions, and the rest of WordPress core and all active plugins, are already available when header.php executes. No magic.
WordPress includes all standard files for you. You're the thing being included, instead of you including other things.
Oh, what you'll find is the programming community pisses on PHP. And PHP programmers piss on Wordpress developers. And some WordPress developers piss on WordPress Framework Developers. Ad nauseam.
without looking does this support bf4 ?
* [What Chronicle is](https://paragonie.com/blog/2017/07/chronicle-will-make-you-question-need-for-blockchain-technology) * [Earlier Reddit discussion](https://www.reddit.com/r/PHP/comments/6jw9oz/introducing_chronicle_an_auditable_immutable/) If you'd like to see this in action, we have a public test server set up and I've provided a basic script for writing arbitrary data to it. Publisher access will be granted to anyone who's interested. Version 1.0.0 is coming soon. Hopefully this gives everyone a feel for how it works now, so when I start working to use Chronicle to help build secure automatic updates for CMS plugins and themes, it won't be totally foreign.
It is correct as @knutsp said /index.php is a entry point of wordpress and many other cms/frameworks. Basically all the files are required into this entry point.
People on ~~reddit~~ the internet make fun of everything, everything. You can find someone making fun of every single language. Go look at the Java bitch threads.
Better explanation!
Exactly. It's projection all the way down. Nobody talks about what the code does (because... that's *hard*), only how they have found they can dismiss it and how THEY would never write THAT kind of crap. See that other comment about how WP has NO architecture, only hooks. Because - *sure*... *that's* what WP did: become one of the most popular pieces of software by being shit and having no architecture. Jfc, it's so shallow. Reminds me of this tweet: https://twitter.com/jayspectech/status/808858546658013189 &gt; The answer to, "What idiot did this!?" is almost always, "A smart, well-intentioned person making tradeoffs you hadn't even considered." I would add: ... and probably having a much deeper understanding and more experience in this area than you could ever dream to have with THAT kind of attitude. And dismissing architectural extravagances precisely because they are not necessary or even actively harmful. 
I am a java dev by day (at work), and a php dev at night. Why? Because I actually love php and I'm really productive with it. People make fun of it because of it's history... however I believe php is really great right now (i'm really enjoying php 7+). Some of my coworkers make fun of me for using it so often for my side projects... but at the same time they are all amazed I can churn out stuff so quickly... while they take forever trying to do the same with java or scala etc.
I call it defensive programming.
&gt; Featuring support for Vanilla Minecraft, Spigot, Source Dedicated Servers, BungeeCord, and many more. Even looking, I can't find a concise list of supported games.
 &lt;?php /** * The main template file * * This is the most generic template file in a WordPress theme * and one of the two required files for a theme (the other being style.css). * It is used to display a page when nothing more specific matches a query. * E.g., it puts together the home page when no home.php file exists. * * @link https://codex.wordpress.org/Template_Hierarchy * * @package test */ get_header(); ?&gt; &lt;div id="primary" class="content-area"&gt; &lt;main id="main" class="site-main"&gt; &lt;?php if ( have_posts() ) : if ( is_home() &amp;&amp; ! is_front_page() ) : ?&gt; &lt;header&gt; &lt;h1 class="page-title screen-reader-text"&gt;&lt;?php single_post_title(); ?&gt;&lt;/h1&gt; &lt;/header&gt; &lt;?php endif; /* Start the Loop */ while ( have_posts() ) : the_post(); /* * Include the Post-Format-specific template for the content. * If you want to override this in a child theme, then include a file * called content-___.php (where ___ is the Post Format name) and that will be used instead. */ get_template_part( 'template-parts/content', get_post_format() ); endwhile; the_posts_navigation(); else : get_template_part( 'template-parts/content', 'none' ); endif; ?&gt; &lt;/main&gt;&lt;!-- #main --&gt; &lt;/div&gt;&lt;!-- #primary --&gt; &lt;?php get_sidebar(); get_footer(); Here is the most basic index.php for Wordpress and functions are already used. Unless PHP doesn't work like Javascript, somewhere before index.php is loaded, must have these functions declared. The only other file that I found that has require in it, is function.php. But even then, doesn't function.php need to be loaded before index.php? And also, inside function.php, there is a function in require that must have been declared somewhere before function.php. 
I remember having to revert a repository just because a developer didn't ask if commiting +10.000 images was OK for a project
&gt; I know you shouldnt update outside of dev Really shouldn't. 99% of the time it will be fine which puts you in a false sense of security, and then you'll hit that one time that causes massive problems. &gt; I dont want to update the cores during development all the time, takes too much time, not just the updating itself, but also composer. This is unfortunetly part of the cost of using libraries. Deal with it. This is still a tiny cost to pay compared to the price of writing your own. &gt; that always need to be up to date. Why? There is nothing wrong with sticking with an old version. If a new version comes out, and you read the change logs and there is nothing you need/want, save yourself the hassle and just stick with the old! (Just watch out for any security issues, you always want to fix those.) Do what everyone says about commiting composer.lock and running composer install in prod and move on.
The index.php file in your theme is not the entry point of the WordPress application. Take a look at the index.php file in the root folder, and go on a journey from there. I would not advise you to look through the WordPress source to learn though, as it's not really - how to put it - a best-practice kind of application.
Then you should provide them with a button to wipe the whole database, and then trust that they won't push it
I wasn't making a list of skills you can stop learning once you know these, just some basic things that a new programmer should at least have a clue about to have a good footing to start with
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; to act as a single point of failure Ok. Let's say that we have system which produces messages. We don't have control over consumers. They could be offline for some reason, or fail to process message. And message must be delivered. In this case I would put something in between my producer and consumer which will store events and wait for it's acknowledgment. Or we are implementing payment gateway and we need to provide customers something better than webhooks. Something like ability to read stream of events using cursor. And we want to use ready-to-use things. For example - [siberite](https://github.com/bogdanovich/siberite). And there are a lot of distributed brokers which allows you to build fail-tolerant system without single point of failure. As for zeromq - this is best solution if you just need one-to-one communication between processes. So yes, if you are building distributed system, this could be answer for you. But remember first law of distributed system - do not distribute systems until there are no other way to solve problem.
If I was asked these questions in a PHP interview I'd walk out.
&gt; What is register_globals in php? OMFG
&gt; moving everything into a single monolith repository. actually leaned towards this one for a while, and i mean everything, like google &amp; fb did, with one big git repo. but somehow it just feels wrong 
problem is i literally cant move on because the composer updates are taking too much time ;) the core libs are very actively updated and released. im guessing this is the major reason why large corps are using 1 big monolith repo
Thanks, we'll keep on eye out on the planning (link) and start making changing to support 7.2 (@ https://github.com/FriendsOfPHP/PHP-CS-Fixer)
That is horrifyingly bad. Two of them are arguably relevant to PHP; and even they wouldn't make good interview questions.
The answer is: _Instant dismissal_.
"What is the difference between mysql_fetch_object and mysql_fetch_array?" I'd walk out if I were ever asked this.
Me too, the php questions are just soo idiotic. Such poor links should be deleted from this subreddit. EDIT: thetechdb, please do yourself a favour and delete the website and also change profession. What you do here is of no help
I think its better to let them be here so people actually know according to his comments and points, how wrong they are.
but is this an ok thing to do?; it seems useful and good... but i don't know im still learning
I've had to manually implement what password_hash does way before it even existed(thank god it does). The article is really light, so maybe go in depth of the different hash types etc.
I created a package to make working with enums easier in PHP. Let me know what you think.
One has been removed since 7.0 and the other has been removed since 7.0. I guess the major difference is, if you think these functions are relevant, it's good you're interviewing for different developers. 
In my experience it tends to reduce code size and reduce the mental load it takes to look at any one line of a function and understand how you got there, especially as opposed to long, nested if statements. Short, quick, early returns allow for clearer, easier to read code.
OH. MY. GOD.
That's the standard way to do it. Also, if you're using Jenkins anyway, you have a build server. Let it do the composer install, copy to server, symlink deploy folder. However long the build takes doesn't really matter then does it? 
What is different from the existing packages, e.g. [php-enum](https://github.com/myclabs/php-enum)?
Hmm this version requires manually writing a "values()" method and is not type-safe. An alternative [that solves these is here](https://www.reddit.com/r/PHP/comments/6it21f/why_are_there_no_proper_enums_in_php_are_they/dj8yrup/?context=3), that I wrote as a toy. If this keeps popping up, I might need to promote it to Packagist :P
I think PHP is fun to contribute to *because of* its flaws. It means there's always something to fix or improve or add. Anyway, I don't hate the language. There's a lot of things I like about it, and for better or worse, I use PHP a lot. I just think people are overly willing to dismiss its problems. Also, perhaps my negativity comes from, well, contributing. It means I've seen more of PHP's problems than the average person.
I feel like JavaScript's problems are mostly concentrated in a few fundamental issues, compared to PHP which has quirks around every corner. That being said, I'll admit I personally prefer how PHP does things in general. Immutable class and function declarations, namespaces, Java-style OOP, by-value arrays etc.
Looking a little more, i found in the database seeds: Teamspeak, mumble, Terraria, source, gmod, csgo, ark, tf2, insurgency, and Minecraft, 
Javascripts issues are more like foundational issues. You are building a house. Javascript's foundation is weak and brittle, but you know some tricks while building the frame to make it work. It doesn't look great, and other builders will have to know the unique style to work on or fix it, but it will work. PHP has a pretty solid foundation, so you can generally build the frame like you would any other house. However they use special European based tools and drivers, so in order to work on or fix the frame, you need the special tools. Javascripts infrastructure is weak but supported by what the developers can hack it to do. Eventually those hacks become standards. ES6 is helping to remove those hacks for now. Php's infrastructure is pretty good (not great) but they recently made big strides to make it better. 
you can always report a post to a mod
I like the way you think!
You should be doing that anyway 
Those are just the ones that we ship by default, but the software supports adding your own game types to it or branching off existing ones. 
I'll get that fixed up and made more clear on our documentation later today!
Ask them how they hash their passwords^ if you see `md5` or `sha`, then they are probably not what you are looking for. Also, OOP is the future, so I guess you can ask if they follow OOP techniques. 
what are you basing that upon? I could understand in some contexts, but blanket "don't use `rand()`" seems like telling someone to never eat with a fork because it's bad for eating soup. 
You should hire a project manager 
We have account managers that handle the clients and this position would be more for building internal tools to track analytics, etc. we currently have a very talented director of business intelligence that will be supervising the developer. 
For me this was nice. I'd never heard of that RFC before. I'm pretty sure that this isn't a full rfc1867 implementation... I spent some time looking to patch it, but it seems the easiest way to bring it forward was a rewrite; so last night I sat and thought of what it needs, then I coded it, ran tests, and kept at it until it passed-tests. When I was done I wanted to share it. https://github.com/Lewiscowles1986/rfc1867 * don't know if "binary content" should be base64 encoded or 7-BIT? Does it have a max-char length? At which point I should line-break like e-mail? Not at all? If you've got suggestions, create issues, PR's, add tests. Another reason I wanted this was so I could dump a valid block of content to disk to use in language agnostic test-suites available to everyone. RFC documents seem such an outdated idea, compared to unit-tests. Most "Implements RFC XYZ" I've come across, tend to be missing some functionality. Wouldn't it be easier to build test-suites for all RFC's?
Are those problems contained within the codebase, or inside the core community? I mean... I have talked to Rasmus during a conference in May about perhaps introducing a namespace with more standard function names and parameters, but he was pretty conservative about it stating that the current function names are fine and that anyone who wants to write a namespace with wrapper functions can do so already. I may not agree, but I respect his opinion. Is this what causes the negativity? And isn't the grass always greener on the other side? How much do you know about the internals of other languages and their inner politics? Either way, what I'm trying to say is: was such negativity ever helpful? I'm not suggesting putting on a cult-smile and throwing pamphlets around at people confirming your love of the language, but perhaps throwing in a bit of context and quick suggestions when dismissing PHP wouldn't hurt? Many future and current devs are reading this, and your words have lots of value.
 &gt; How can we submit a form without a submit buttom? This isn't something that a PHP dev _should_ know or required for a PHP position. It's more HTML/Javascript/whatever JS framework you're using. &gt; What is register_globals in php? An evil function that has thankfully been removed for many versions. &gt; What’s the difference between include() and Include_once()? Sorry composer and the autoloader handles loading my files, so I hope to never see includes in my code. (yeah I know there are exceptions like the index page that calls the router/kernel/etc) &gt; What is the difference between $message and $$message? I wouldn't merge the pull request if someone had $$message, you're obviously doing something hacky. &gt; What is the difference between mysql_fetch_object and mysql_fetch_array? There is no difference, trick question. They were both removed for version 7. &gt; How many ways can we get the value of current session id? Only one since you're always working with sessions in the injected HttpFoundation class and never with globals or something stupid like that.
I'm not even sure about that. It's just another terrible link when someone is trying to find interview questions for PHP when they google. It's no wonder people hate on PHP when terrible information like this is coming out even today.
If it's for home and not some mega-corp, why not make it AGPL? It basically means "Here is something for free, your data is yours, the application is open to view, edit, etc for every single person that uses it." There's no lock-in, easy (as possible) to extend, etc. If the license could change I'd be happy to take some time in the next few weeks to create vagrant or docker (Laravel uses a vagrant box called homestead, that makes it easier to use and contribute toward).
There are numerous major security issues with the code: - there is really no excuse using sha1/md5 for password hashing, just use `password_hash`/`password_verify` and forget that anything else ever existed - `Guard:slashes` does not protect against path traversal, `foo/....//bar` will be transformed into `foo/../bar` - using string concatination for sql queries, while the attempt at cleaning user input seems decent (not an expert at sql injection though), using prepared statements with parameters is an easy and much more reliable way to avoid sql injections. - (depending on the way php is setup) it's possible to directly include certain scripts (such as `resources/filesource.php`) and bypass the login check. Also since `$CONFIG` wont be set that way, `$CONFIG['path'] . $file` will evaluate to `$file`, making it possible to access the entire host filesystem. - `Cloud::handshake` takes the active userid from the cookie, a value the user controls, allowing any attacker to become any user by simply guessing the user id (trivial since they are incremental) - Probably more, security is really, really hard, and I just browsed the code. Don't let any of that stop you from continuing the project though, read up on some php security bad practices and have a critical look at your code.
Sounds like someone needs a hug. The framework itself is doing fine but some of the eco-system definitely needs work. The FOSUserBundle is by far the most widely used bundle and is required for many other bundles and yet the bundle itself is badly and poorly maintained. Really quite a mystery. I use to host my own fork just so I could fix as needed but eventually just gave up. I remember taking a look at the Sonata admin stuff and just never saw the point. I agree that there is some over engineering going on but over all, I think the trend is towards simplifying things. 
thnx i'll try!!
Yeah I feel your pain, I love symfony components, but I could never wrap my head around third party bundles and getting them to work with other things . Too much time learning and not enough programming. All my sites are filled with symfony but I don't use symfony framework. Hopefully everything improves with Flex 
It depends of the tools you want to build. Without further details, I'd just say look at their projects (personal or from previous work, no project no interview), and then discuss during the interview about the things they're going to do and how they would be building them? If your agency is not into "code" at all maybe there are extra skills you should be looking for. Will it be avaiable on Internet? If so, do you have servers? Is there anyone who can handle them or should the dev be able to manage them? Is it only a backend position or will there be things like designed page to port to web for example? If so they should also know some html, css, maybe some JavaScript with some known framework ? Depends on the mission :)
The main problem is that people who hate PHP they're exactly looking at these guys' articles &amp; sources. And even worse, the newcomers are looking at resources from these guys and think that's the "PHP mentality" and adopt the miserable coding style and attitude(s).
Sounds like you just dislike Sonata and not Symfony. I don't like it either, it does seem impossible to master. Been using [EasyAdminBundle](http://symfony.com/doc/current/bundles/EasyAdminBundle/index.html) since about 6 months and never looked back, super easy to customize and very fast and easy to understand.
You might want to look into some other options before making a direct-hire: 1. Going with a company that specializes in software development. 2. Eschewing direct-hire, instead going with contract-to-hire. 3. Using your network to find someone. If not direct, at least through a past co-worker who can help or make a solid recommendation. Since you don't have the technical skill set needed to hire a programmer, this will insulate you're company a bit from making a bad decision. This is the route I'd go if I needed an accountant, a field I have little knowledge in. The company I work for, went with option 1 when they were bootstrapping their business idea. For 1.5 years they contracted out to an agency. Finally, they used the agency to help them hire a full-time developer (me). Caveats, the agencies code sucked. But that's just like, my opinion, man and I've been fixing their shit-tastic code for 2.5 years now. Disclaimer: None of these options is bullet proof.
Business intelligence != project management. Find a competent project manager, have them work with your DoBI to find the developer team you need.
In almost every way, `random_int()` is better: * Less susceptible to bias * Larger number of possible sequences * Far less predictable (since it's CSPRNG) And there's no real performance cost to `random_int()`, especially on newer Linux kernels.
Haha..this is eerily similar to what we have/planned at our office. A TV mounted on the wall in our dev space. We were going to build a dashboard much like yours and in fact built the initial version, but then it got pushed off for years. I might have to bring it up again! We do the same thing. First dev into the office turns the TV on and last one out (is supposed to) turn it off. We have it hooked up to a Chromecast though so we can cast things to it.
Thank you for the reply! I really appreciate it.
&gt; Are those problems contained within the codebase, or inside the core community? I'm looking purely at the language itself, not the environment of which it is a product. &gt; And isn't the grass always greener on the other side? How much do you know about the internals of other languages I understand JavaScript and C quite well. Both are standardised with multiple high-quality independent implementations, so they lack PHP's implementation quirks in that regard. &gt; and their inner politics? Little, but it's not what I'm talking about. &gt; Either way, what I'm trying to say is: was such negativity ever helpful? I don't know, really.
I cost $85/hr but I'm fucking amazing. PM me
I've been experimenting with adopting Symfony in a specific project, and this comment intrigues me because it relates to a question I asked before. At what point would you consider yourself to be using the Symfony framework, and what is the difference between that and just using Symfony components, or as you say, having your sites "filled with Symfony"?
A few quick points about your post. * Just an FYI, Symfony doesn't really have models built into it. You're probably thinking of Doctrine. * For a lot of stuff, you generally won't be dealing with the security component directly. Anything you do require to use the code directly getting used to standard design patterns will help you a lot. * FOS User bundle is nothing to do with Symfony. It's a third party bundle which only provides some functionality. * Again Sonta User bundle is nothing to do with Symfony. * Same applies with the Sonata admin system. If you want to master Symfony. Stop using third party bundles. But honestly, it sounds like you would be happier in the Laravel camp. The reason most of the Symfony stuff is very rigid is the majority of Symfony apps (or the ones I've come across) don't use third party bundles that much. They use the Symfony core and extend upon that. These third party bundles are for people who want basic functionality but don't care much about it. Whereas with Laravel, my understanding is the majority of things built for it are easily extendable because the people using it want that and require that sort of functionality.
The major components I use from symfony: - symfony/yaml - symfony/forms (which practically requires you to use **symfony/translations**, **symfony/validator**, **symfony/security-csrf** &amp; I believe **symfony/config**) - symfony/HttpFoundation (for things like session) - symfony/psr-http-message-bridge (makes using forms w/ psr-7 simpler) - symfony/twig-bridge (making forms work w/ twig) And if I need anything else from symfony I'll probably check what they have first before looking for an alternative, but I don't necessarily need anything else from symfony after that bit. So yeah a lot of my code at it's core uses symfony for a lot of important things.
Nice implementation using class reflection. I was looking for something with more flexibility. The reason for putting it in a values() method is so that one can tweak the representation when using it in an interface. One such use case would be to translate the values before returning them. To keep it compatible with older php versions, I removed some type-hinting.
The added flexibility to mutate the values that are returned for an enum. The -&gt;values() method allows you to change the strings for other languages or present a sentence related to that enum. The options are countless.
Sorry I'm not suggesting it's not better for what it's designed for, but generating random non-colliding boundaries in multi-part systems where there is basically no downside to being insecure? (remember these boundaries are local to the document they reside in). It's one boundary per-envelope, so 1+(number of fields sharing name param). I could post 100 files and only have two boundaries, or 50 sets of 2 fields per-name, and have only 51 unique boundaries (probably at the fringe of what we'd do in such an arcane system). I Appreciate your time taken to explain the benefits of `random_int(int min, int max)`, I'm just not sure this implementation requires it. As the one I've linked has a test-suite, I'll maybe make a PR so the source of randomness can be supplied and create two implementations for `rand(int min, int max)` and `random_int(int min, int max)`, then it gives people the choice and is no skin off my nose, they can do what they like. What I've instead done to avoid collisions is to generate 4 random numbers 0-65535 and cast to hex to generate a "unique within reason" 16-char boundary. I Haven't had a single collision yet.
A bad workman always blames his tools. I think Symfony can be a great tool when in the right hands. It can be an equally disastrous tool when in the wrong hands. For good results, you need a good understanding of programming principles, of architectural models, of implementation approaches. If this isn't for you, maybe you should pick a different tool or hire someone else to do the job.
if you're using frameworkbundle then you're using the symfony framework. 
You'll get a collision at sqrt(keyspace). So with `rand()` it's guaranteed to happen at least once after 65536 iterations (&gt;= 50% probability for each sample after that point).
U use Symfony for everything actually..from small to big sites..Symfony is awesome..but you really need to select 3rd party bundles with care and only if you really need it..for instance I used FosUserBundle only once for a project and I regret it till today. I mean setting up the User to work properly is no more than a few hours of work anyway..why use a overarchitectured bundle for it
You should ask yourself why again do you need FosUserBundle..because setting up the user (registration, login, JWT...) is a matter of hours. I am using Symfony for a few years now for everything..and working with it is like a charm..but I do avoid using 3rd party bundles if not necessary. You can not just rely on Symfony bundles because they have a bundle in their name, they are done by people..on the other hand you can integrate any 3rd party library if needed. I just see people installing bundles just because they are there and have a nice description, you should always consider your needs and evaluate if the bundle you want to install will not bring you more cons than pros
Sounds like a snobbish thing to say. While I can empathize with your point in general, *Symfony does indeed makes things much harder that it could have been and that complexity propagates to its entire ecosystem*. Like, consider the [sheer awkwardness](https://github.com/FriendsOfSymfony/FOSUserBundle/blob/v2.0.1/DependencyInjection/FOSUserExtension.php#L46) of using Dependency Injection Extensions to load a bunch of configuration values that might as well be stored in php array.
Okay it's guaranteed to happen at least once after 65536 iterations, but we're doing it four times, four separate calculations. So what does that do to the calculation? The chance that we get &gt; 65536 iterations per-document? (the boundary only matters it doesn't collide within a single request. Remember all four calculations would have had to line up. What are the chances of? [ rand(0, 65535), rand(0, 65535), rand(0, 65535), rand(0, 65535) ] lining up be? That's essentially what it does, gets 4 x 16-bit range-number. That's what I'm asking.
What does it make harder? I mean we could talk of the security for example: it's complex, it's annoying, but that's because the subject itself is hard and complex. If you just need a few ACL rules it's trivial to do in Symfony. It's always the more complicated stuff that is harder. As for the dependency injection extension, I think it's a very bad example. I _love_ to have the config validated and avoids a lot of pain IMO. It for sure requires you however to declare that configuration, but that's relatively simple compared to rolling your own. Loading the config file could be simplified, and it has been with flex which provides an auto-discovery. And the example you point is quite different IMO: it's some quite advanced config and not very representative.
Serious question, is _REQUEST not deprecated? 
Nope, not deprecated.
It's exactly the right example, because third-party bundles waste hundreds lines of code for what could be done with [less then a dozen](https://laravel.com/docs/5.4/packages#resources) providing framework maintainers prioritized real-life use cases rather than addressing issues that are mostly academical in nature. Imagine you being thrown in a wizard high school and being told to read history books for hours on end instead of doing magic. That's what Symfony stands for, I dare say, a lot of web developers.
You could stop updating until you are about to push branch, then update composer dependencies, run your tests, and commit them
It's already GPL, I don't understand why you'd want it to change. The only benefit would be that you couldn't create a SaaS solution out of this without open sourcing it. I'm pretty sure you're covered with Google Drive, Dropbox, and iCloud.
Symfony's components are easy to understand and easy to master, me too, never use symfony as full framework, but it's components are everywhere in my project. mostly, I'll just pick Silex or Slim, and add required symfony component into it
I really wish we could make PHP itself only run signed code.
Wow that's actually a great idea! Private key in php.ini (hidden in phpinfo) and a file with signatures for current folder and subfolders. A tool to generate signatures for existing files. And if signature missing or invalid, don't run the file. Can it be done as a php extension? 
It would have its difficulties with file scope (for example, the vast majority of PHP applications store their most basic configuration in PHP files, often built server-side). Also, there's potential things like PHPStorm would wreck any signatures when applying things like code formatting at commit, or FTP clients replacing the EOL sequence. A signed integrity file might have a few interesting uses through.
What about ignoring whitespace for signature? And cache based on timestamp and filesize.
I would suggest not building such an extension until PHP 7.2.
So you're saying I cannot make your code rogue with just whitespaces? Interesting challenge...
Without additional non-whitespace code? I don't think so
What's your definition of whitespace?
`\s` ? EDIT: for the purpose of security signature I don't think it's important to distinguish between meaningful and not meaningful whitespace. But if it bothers you, then minified php code as signature input would work as well `php_strip_whitespace()`. EDIT2: my main concern is hackers uploading and running malicious code to my server, which I think would be resolved with this. 
It's not sexy, but it does the job. Particularly when the job is manipulating data in a database on the internet. I've been working with PHP for for about 15 years, and it has vastly improved in that time. I went to a presentation on React js a while back, and the sample app they walked through was cool. But with PHP and a database it would have been WAY easier to implement and way easier to secure. Over time I've gone from purely (often bad) procedural code to using classes, Composer, reusable code, etc. It has worked well for a number of projects for me, all of which involve moving data around in a database. I've written user authentication from scratch many times. Carts from scratch. You name it. I have written portable libraries to handle these kind of things now, and having those solved and secure I rarely depend on frameworks or third party libraries to implement the basic stuff. PHP is not the best choice for everything, but for running an average site with a database back end it is hard to beat. it's not the latest or coolest thing, and therefore the internet says it is meh. But, it works and works well. 
Depending on what the original code did (e.g. http://php.net/manual/en/function.halt-compiler.php with trailing opcodes), it might be possible to append arbitrary data that could be considered whitespace for signature verification purposes but still alter the behavior of executable code (e.g. with OpCache). Or, if you've got a chosen ciphertext attack against e.g. ionCube, this might also succeed. I'm hesitant to dismiss entire attack vectors before I've done the research. It's better to enforce a signature on the file as-is than perform some black box function on the input and sign that, and expect the other end to do the same, without the black box doing something evil successfully.
As long as I could easily re-sign the code I would be happy. It could be easily built into what ever build process you are using. 
My comment isn't related to the code base itself, but the project seems to have a fair few dodgy accounts under the starsgazers section (https://github.com/yTakkar/Instagram-clone/stargazers).
Even now, you engage in this slander. I'll have you know that Java's threading model is far superior to PHP's!
Hm... I thought __halt_compiler() was more of a hack, and serious apps don't use it. The idea is to sign existing trusted code, so it can't be changed or new files can't be ran.
Why is artisan the first bullet point? What the hell does that even mean?
Every PHP Archive uses it. Open a `.phar` (PHPUnit, Composer, etc.) in a hex editor if you don't believe me. More importantly: It is possible to conceive of a legitimate program that, when appended with chosen "whitespace" that happens to be legitimate opcodes, will create a malicious version of the program. Stripping before signing would produce the same signature for both copies of the program. The next question is: Do the existing technical constraints allow this hypothetical malware to be created? Can we side-step the issue simply by never stripping before signing? (The answer to the second question is "Yes".)
Heel leuk!
Of course, if it's simple to regenerate the signatures after every intended code upload/change, no stripping required. I was just approaching it creatively :) it can be also an option, for sites that don't use phars or halt_compiler
That's fine, but do you remember CRIME and BREACH? Compressing before encrypting led to an exploitable side-channel that provided a practical break of TLS. Be very careful of adding steps between receiving a message and verifying its integrity. Otherwise, [doom](https://moxie.org/blog/the-cryptographic-doom-principle/) is likely to follow.
Yes, teacher. (No sarcasm)
This is a poor article riddled with errors. How is it a top 5 post? &gt; One of the top reasons why Laravel gets edge over other frameworks is object oriented and pre-installed libraries. Nothing against Laravel, but which other major PHP framework isn't object oriented? 
That guy is a huge Indian spammer, glance at his post history to be convinced. Just report for `Reddit rule: Spam` and go on with your life. He will get reddit banned eventually...
Your complaint is against a framework but your issues seem to be with bundles developed with the framework.
Could you ELI5 the problems this would be solving? Asking for a friend… :p (I think naming explicitly current attack vectors could help understand better the proposed solution)
A. PHP used to be much worse B. People like to bitch-about the tools that they are not using. C. You can find a lot of people building crap, people asking foolish questions on stackoverflow yada yada. D. For the people hating on PHP, most of them are just following the hyperbole, others who tried it years ago when it was a mess (I am not saying it has no problems now but it has namespaces, strong OO, reflection, lambdas, good frameworks, libraries, testing frameworks etc) and others hate it just because of the fanboy ego. E. It is known to be having slow development pace; but it is equally slow in Python, Ruby and Java (languages, libraries, frameworks, ...) or maybe even slower. Personal recommendation; don't become a language developer; try to become a developer. Keep a healthy appetite for learning; languages come and go, try not to become a language developer. A professional developer should constantly be adding tools to the belt, and be agile enough to take on the demands of a company/industry. Lastly, your customers and business does not care what you use to build your app as long as it solves the problem and brings money to the table. Heck, even use Cobol if it brings you money.
You posted this exact thing just four days ago. Why the repost?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Just use @$_REQUEST['db_stuff'] to be sure! \s
This is actually an interesting comment. I know and use many languages (mostly PHP) for more than 10 years now and haven't found that many problems. That may be my Stockholm syndrome speaking, but either way - can you list some of the issues that you ran into? I recently only stumbled upon one - `\DateTimeImmutable::createFromFormat('Ymd', '20170101')` puts whatever you require from format, but will not zero the rest, it will take the environment (current) values for time and timezone.
There's a spectrum of automatic update security. At the very bottom, you have `curl http://foobar.com/update-1.0.1.sh | sudo bash`. Somewhere near there you have what WordPress does. Then you have what Google Chrome already does. Finally you arrive at what I'm trying to accomplish. To work with a more well-known example: If you hack WordPress's update servers, you get [full access to 27% of the Internet for free](https://www.wordfence.com/blog/2016/11/hacking-27-web-via-wordpress-auto-update/), at the cost of a single 0day or security misconfiguration. The work being done here will ensure that, in order for an attack to get carried out, it will require access to the Ed25519 secret key used by the software vendor. You can't attack this scheme by hacking the update server and silently replacing the update file with malware, you have to attack the vendor (who may keep their signing key offline). Even if you pull this attack off, in order for it to succeed, you must alert the entire Internet to the existence of your attack by committing metadata about it to a public, replicated, independently verifiable database. This prevents two types of attacks: * Targeted attacks, which compromise the security of a few people. (See the attack on Freedom Hosting by the FBI for an example of a targeted attack.) * Silent attacks, which operate without alerting the user to their compromise. In order to pwn someone, you have to pwn all of the users, and alert everyone (users and strangers) to the existence of your attack. This makes forensics easier, attack containment simpler, and as an added benefit, deters law enforcement from ever obtaining a warrant that would authorize them to perform such an attack.
Not everyone on reddit does. However somehow on `/r/php` this question is kept on being asked so often it is nearly always on the front page of it and always gets the same answers.
Sonata isn't easy to master but once you made some stuff with it, it's very flexible and powerful. Yes, the documentation could be so much better but we should help with that as a community. And when it comes to FosUserBundle...you don't really need it. You can use any method of authentication with Sonata (including http basic auth which is the easiest thing to use). The Symfony Guard feature of Security should be very easy to understand, maybe take a look at that instead?
doggy accounts?
Good idea. But PHP 7.2 will came out soon (maybe 2 months). So he or someone else can start working on that extension.
PHP 7.2 won't be out until December. :)
I forgot about beta and RC releases. So yes, PHP 7.2 will be launched in December or maybe next year.
Probably he wanted more coverage, more community involvement or just a feedback. My feedback - easy to use, I see a few optimisation options to choose from: JpegOptim, Optipng, Pngquant 2, SVGO, Gifsicle. So Freek, good job! 
Do you mean provisioning tools? If so, the most popular ones are: * [Ansible ](https://www.ansible.com/) * [Puppet](https://puppet.com/) * [Chef](https://www.chef.io/chef/) * [Salt](https://saltstack.com/salt-open-source/) I personally favour Ansible, but YMMV. I don't know of any provisioning tools written in PHP... I can't imagine the demand is very high TBH!
That does not make this allowed. He posts a lot about his own stuff, which is entirely fine - they are quality submissions. But reposting after just a few days? Hell no, that's entirely against rediquette.
Vaguely related : I've found : https://github.com/rflynn/imgmin/ to be quite good at (lossey) compression/minimisation of images.
Oh, I've just realised you mean "open source deployment tool" not "operating system deployment tool"... sorry! In that case I would go with [Deployer](https://deployer.org/) as it is written in PHP and is fairly battle tested. Failing that I'd probably use [Capistrano](http://capistranorb.com/) or maybe just a BASH script for extremely simple scenarios. On the other hand there's nothing stopping you using the provisioning tools I mentioned above for deploying as well. Ansible deployments are quite commonplace. A good [Makefile](https://en.wikipedia.org/wiki/Makefile) is a useful tool for deployment also. Don't think they are just for C projects anymore!
Hello hows it going? Are you missing me yet?
Why saying "I am not a PHP expert &amp; not a fan of PHP" on the PHP reddit page? You said you want to convert it to go. You will find that go style is so different that it will take you a lot to transform all this code. My suggestion is to convert all your work to a PHP7 coding style. Maybe use a framework. That will be appreciated.
Thanks. I'd say that you can use it along with your libraries of choice. BTW thanks for the links, I didn't know some of the libraries you mentioned.
I am converting it to go &amp; nodejs. Yes I agree go style is very different when compared to PHP, but I am taking it as a challenge. I've been coding Go since a month &amp; NodeJS since 3 months, so I kinda love these. I appreciate your suggestion, I'll try with PHP7 as well!!
Haha, I made the same mistake. FWIW Ansible also has it's own [deploy helper](http://docs.ansible.com/ansible/deploy_helper_module.html) module
Sorry, I have updated the description to state this is about Open Source deployment tools written in PHP, it was confusing before as it said 'OS deploying tool' :) Thanks for the answers, Deployer looks good, I think I will go with that.
[Reposted from 20 days ago](https://www.reddit.com/r/PHP/comments/6ilh0j/building_a_realtime_dashboard_powered_by_laravel/).
Sorry, totally forgot that I had already posted the link to github repo.
Here's the full blogpost about the package: https://murze.be/2017/07/easily-optimize-images-using-php-binaries/
I beg to differ, Laravel is good if you do everything on their way as it is very opinionated. This is not bad but the moment you don't follow their philosophy, it breaks, you end up with bad designs, even some ways that Laravel does can be questionable from the design perspective. But the same could be said for other frameworks. At the end of the day, use the right tool for the job. If an array is enough and you don't need validation of the config, go with arrays. The learning curve is high in symfony but can be extended better, but this means more boiler plate code. I'm talking from experience here. But again, if I have to do something quickly, Laravel is good, it shines for making prototypes and self contained services. There is no need to have an ultimate framework, just try and use the one that can adjust to the problem you are solving. If you only know how to use a hammer, everything will look as a nail.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I really don't follow you, the strict equivalent of what you gave is https://gist.github.com/theofidry/a547126a0e756271e76095bc64a193c5. &gt;providing framework maintainers prioritized real-life use cases rather than addressing issues that are mostly academical in nature. That's where I also strongly disagree. I know some Laravel folks are fond of duck-typing, conventions and assume everything is configured right, but that's certainly one of the point I hated the most when doing Laravel. In your application for some config, you don't care, it's some parameters which are key value ok: #services.yml parameters: foo: bar For thrid-party libraries, this most often than not result in shitty issues from people that do shit. And in those cases you definitely want an error as early as possible, and for the case we are talking about an error about the configuration, rather than having to figure out what kind of weirdness resulted in the described issue. You certainly can say "fuck that, just read the readme", but past a certain point you really don't want to deal with that anymore. I like how Laravel kind of forced Symfony to reconsider the DX or helped to bring out a lot of improvements that I really wanted as well. You can do compromises for your code, but for third-party code, you want stability and strictness.
You may want to build your own framework using Symfony Components (only ones that you need), that's the point. I'd say that is the only good idea when you have complex project architecture (not a bunch of CRUDs), DDD-way and so on.
https://en.wikipedia.org/wiki/Damning_with_faint_praise
**Damning with faint praise** Damning with faint praise is an English idiom, expressing oxymoronically that half-hearted or insincere praise may act as oblique criticism or condemnation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
&gt; For thrid-party libraries, this most often than not result in shitty issues from people that do shit. I understand what you're saying, but I've never had this issue. Never. Like, yeah, people do mistakes. So what? It's like killing a dog because it has flies. You kinda solved the issue, but in most stupid way possible. If you wanted to validate config, you could do it directly when retrieving a value. Knowing how to fill it out is also a non-issue when you have a stub with default values. You're thinking hard about otherwise very simple problem. BTW, the issue with that *strict equivalent* of yours is that I haven't seen it being used in the wild which makes it purely hypothetical. If I wanted to contribute to a real Symfony bundle I would still have to deal with the whole package.
https://github.com/irutii?tab=stars https://github.com/robbyi?tab=stars https://github.com/pkjj?tab=stars https://github.com/Asfai?tab=stars Just to name a few... a lot of others look like star bots.
Phar files can already do this.
Don't bother.
There are definitely some poor practices that have become very common in the Symfony community, sometimes even promoted by the Symfony creators themselves. For instance, they recommend implementation approaches that lead to tight coupling of controllers to the container and other components. While this may be reasonable for simple and short-term projects, one would want to keep application logic uncoupled from the framework in the case of a complex enterprise project. Another problem I come across often is that integrations and implementations of domain logic get hidden away and obscured by configurations. I think the example you provide is a valid one as well, the configuration of bundles and modules can become more complex than needed.
Yes, [we](http://amphp.org/) throw instances of `Error` for every mistake that's a programming error and needs a code change to fix. We also throw `TypeError` instances where we have to do manual type checks, because PHP's type system doesn't allow to declare that type.
It depends. On whether you're planning to catch them in the future or not. So the rule of thumb is: - if it's a specific error that could be possible caught and handled - then making it a custom one is mandatory - if it's just a generic error that should make the app fail - you could use a predefined error exception 
@amcsi Wasn't aware you're going to ask the question here and I have asked it here: https://stackoverflow.com/questions/45011494/is-it-ok-for-my-own-function-to-throw-argumentcounterror-in-my-app-in-php-7-1 
&gt; mistake that's a programming error and needs a code change to fix Could you give an example of when you'd manually throw an Error indicating that you've made a mistake?
Your question is slightly different. And the answer is - yes, it's perfectly ok to throw any predefined PHP exception, ArgumentCountError included. 
well I have no knowledge of this
My question is more precise to what the argument started with, but I'd rather hear opinions about throwing Errors and descendants by user. Thanks for your answer ;]
&gt; but they won't end up on GitHub This is one of the main differences for me, I see it time and time again on this sub people saying to beginners "put your code on github as a portfolio" where in other communities I follow on here they certainly don't push github like the PHP community does. Even senior members on here you will often see them saying "well I've got so many stars/downloads on github" much the same way the JS community says the same about NPM and both lead to a shit storm of popularity chasers just pushing shit code.
Thanks guys, I like this tool a lot and I will continue using then.
&gt; wordpress "architecture" It has an architecture?
&gt; obscuring all the simple concepts with byzantine monstrosities hiding behind fancy sounding buzzwords It seems like you've never worked on a truly enterprise application before where the entire business relies on that system. I too thought just like you, 'writing tests is just wasting my time', 'adding extra layers to the application makes it harder to follow' etc etc until you work on anything of scale that's mission critical then you will instantly change your mind set. Sure Billy's Bakery or Sue's Pet Store you could get away with slopping some crap together in Wordpress and pushing it live but you'd never get away with that at enterprise level where auditing is a thing and down time/broken features is not an option.
 &lt;?php function add($a, $b){ if(!is_int($a) || !is_int($b)){ throw new TypeError("Argument passed must be int"); } return $a + $b; } function main(){ $sum = add("chicago", 5); // the line that must be fixed and not be catched. }
This is spherical example, and we can avoid it here just using type hints, but we could have composite type where $a is array|string|OurCustomNumberClass|int which we cannot typehint and we have to resolve it only by throwing TypeError
Beyond the amazingly common complaint of the inconsistently named and un-namespaced stdlib: * Inconsistent error-handling - some functions return `-1` for errors, some `null`, some `""` and some throw and exception. Sometimes you even need a `get_last_error` function. (Incidentally *no*, I don't consider "it's a wrapper on the C calls!" to be a valid excuse in general for high-level language's standard library) * Much too much adherence to the don't-break-compatibility given that PHP leaves known-broken code in just because it got mainlined before issues were noticed. `Datetime::ISO8601` is not ISO8601 compliant, `htmlentities` returns "" to signal an error despite the fact `htmlentities("")` correctly returns `""` as a non-error meaning that `htmlentities($some_var)` can only be detected as having errored if you do pre or post-checks on the contents of `$some_var` yourself - what a chore. * A programming language with a configuration file that can massively alter the behaviour of a program, and worse still it's not *just* a configuration file because programs can also override the config with their own `ini_set`s. * The fucking stat cache * Poor ergnomics. `-&gt;` is two characters, not one (Yeah, I know why it couldn't be `.` in PHP, that doesn't make it less of a bother), the syntactically not-necessary `$` must prepend all variables even though it's not required for the syntax to be unambiguous (hence why so very few other language do such a thing) and parentheses are required to delimit the expressions/statements used with `if`/`for`/`foreach`/`while` even though it's entirely possible to unambiguously parse a C-like language without them. I'm not the biggest C syntax fan, I'll admit, but look at Rust if you want a good example of how you can clean up the C syntax without changing the look or feel of writing code in it. * The PHP language is fine with the fact that it has undefined behavior in `money_format` on some systems. It can find things to gripe about with other languages too, sure. Even ones I actually really like. PHP, though, always feels like it imposes more issues on me than other languages.
Sure, e.g. https://github.com/amphp/amp/blob/916cf3119d96ba6d3b5a8c9d9bdd258960400141/lib/Coroutine.php#L123-L131
"Truly enterprise". Wow, thanks for the chuckle. Keep attacking that straw man!
I wrote a similar piece a while ago and whilst not complete or in depth it certainly goes more in depth than the above http://mstd.eu/index.php/2016/07/01/how-to-correctly-has-passwords-in-php/ 
Also, i would add, that I personally think that such checks are completely unnecessary and are visual garbage. We must treat our data as correct, except the third-party data, which we must first validate and then pipe thought out code without any further validation. The last case is where we must validate not the type but the value. There some checks must have place, but this is somekind of outstanding case &lt;?php function div($a, $b){ if($b === 0){ throw new DivisionByZeroError("Divider must not be 0"); //such checks are unavoidable, but in this example they are already handled by php itself } return $a/$b; } function main(){ $sum = add(5, 0); // the line that must be fixed }
&gt; Keep attacking that straw man! Apart from the obvious trolling and complete lack of logical debate, you don't believe there is a need for enterprise level systems and Wordpress could do the job?
A debate usually starts when you address something that I actually wrote. Not so keen on debating things you put into my mouth.
If you're using a WYSIWYG system then it will most likely already have features for external content like images and simply link to them somewhere on disk (depending on where you configured it). 
No new operator for concat, please, just 'foo' + 'bar' = 'foobar'.
Exactly, change `$` to `let ` for non-property/non-argument members.
We just developed something very similar for product images. A less resource intensive algorithm is used to deliver images on the fly, while a request is sent to a Gearman queue to perform sharpening, autocropping, metadata cleanup and resizing.
Thanks!
&gt;I understand for what you're saying, but I've never had this issue. Never. I wish I was as lucky as you. Literally 90% of the GitHub issues I had to deal with and I'm not even talking of the private emails, Slack or Twitter. And I'm merely maintaining a few libs and I'm far from being well-known or popular. I can't image the amount of shit some people can get. &gt;Like, yeah, people do mistakes. So what? So what? When you're maintaining libraries you're the one dealing that. I don't want to waste my time on this that's all. I'm not forcing anyone to do the same, but the one doing this kind of validation to think the same. You may be fine with those issues or if you don't encounter the problem to much that's cool. &gt;You kinda solved the issue, but in most stupid way possible I hardly see how saying "look, you have this value which can be that and that value that can be this" is the stupidest way to handle it. It's on the contrary quite simple. It does add the burden to declare it on the maintainer end, but it shouldn't change too much and makes it way easier for the consumers. There is no risk of the doc getting outdated, the code can be the doc. I hated to have to look at library X the way they consumed their config parameters because it wasn't clear if you could use any string there, regexes, null or empty string. &gt;BTW, the issue with that strict equivalent of yours FYI that's the default you get whenever generating a bundle. It's not hypothetical, if you want some examples in the wild let me give you some: - https://github.com/nelmio/alice/blob/master/src/Bridge/Symfony/DependencyInjection/NelmioAliceExtension.php: Barely any longer because I inject the config as params and do a recursive lookup for the files to avoid specifying each of them manually - https://github.com/theofidry/PsyshBundle/blob/master/src/DependencyInjection/PsyshExtension.php: literally what I gave you Also another thing to point out: complex configuration are there for a reason. People don't put complex configuration for their libraries just for the sake of it. Touching the extensions like that is already pretty advanced and there is not that many people doing it. And now to be clear, I'm not saying Laravel is bad, there is quite few things I liked from it, but missing a way to expose a configuration as a library and having a compiled DIC were definitely the things I missed the most from Symfony.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [theofidry/PsyshBundle/.../**PsyshExtension.php:** (master → c7e9bf2)](https://github.com/theofidry/PsyshBundle/blob/c7e9bf2524518696eeaf69047855b52553018221/src/DependencyInjection/PsyshExtension.php:) * [nelmio/alice/.../**NelmioAliceExtension.php:** (master → 59957af)](https://github.com/nelmio/alice/blob/59957afceb500bc88ab4fbbb5278c564a6a56582/src/Bridge/Symfony/DependencyInjection/NelmioAliceExtension.php:) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk0xlm8.)^.
&gt; I’m not shy. I’m just very good at figuring out who’s worth talking to. Most of you aren’t. I'm sure he'll get many jobs
Thank you for your response, it's an open source project? can you share the link?
&gt; We must treat our data as correct, except the third-party data, which we must first validate and then pipe thought out code without any further validation. But why? Having such checks shows you where the issue is right away if you try to pass something incorrect. This is especially useful when multiple people are working on a project and don't know well what's expected to be passed everywhere.
Did you benchmark what kind of machine (cpu power/ram/etc, or like aws instance type or digitalocean droplet) is required to run it in production with good performance, especially on some large files (dimensions/size)?
We've developed something similar. It uses [php-vips](https://github.com/jcupitt/php-vips) (a PHP binding for [libvips](https://github.com/jcupitt/libvips)) as image processor, which is typically 4x-5x faster than using the quickest ImageMagick. On average, we resize 1 million images per hour, which generates around 25TB of outbound traffic per month. See https://github.com/andrieslouw/imagesweserv for the GitHub repository.
Isn't the first thing what the [SPL LogicException](http://php.net/manual/en/class.logicexception.php) class is for?
Two reasons: * performance degradation * bloated code, where 30 of 35 lines it just argument checks. But, in php you actually could use assert statements, which both not so verbose as "if" blocks, and may be turned off in production. http://php.net/manual/en/function.assert.php
That's pretty cool, but where are your tests? Especially for a class like [this one](https://github.com/MiraFramework/render/blob/master/render.php) Also you use eval, how 'safe' security wise is your render class? public static function templateEngine($template, $variables) { extract($variables); if (self::multiTenancy()) { $app = self::getSubdomain(); } else { $app = $template[0]; } $app_template = $template[1]; if (file_exists($_SERVER['DOCUMENT_ROOT']."/application/app/$app/templates/$app_template.engine.php")) { $output = file_get_contents($_SERVER['DOCUMENT_ROOT']."/application/app/$app/templates/$app_template.engine.php"); $output = self::templateTags($output); echo eval(' ?&gt;'.$output. ' '); } else { self::getTemplate($app, $app_template, $variables); } }
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [MiraFramework/render/.../**render.php** (master → a2945ce)](https://github.com/MiraFramework/render/blob/a2945cec7989d372568dc94c5a40452aa5cbdcc9/render.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk0zql9.)^.
Interesting! 
That is impressive! We are only using Imagemagik for flexibility sake and for the bindings with moz-jpeg for compression, but for most operations we could run with a much faster image processor. I'll take a look at php-vips. By the way, on what sort of machine are you running so many images per hour? Thanks for the feedback!
Any reason to repost this so soon(18 days) after [the last time?](https://www.reddit.com/r/PHP/comments/6is643/dockerized_php_application_runs_as_a_microservice/)
We are fine tuning the benchmark scripts, we realised the content of the images we use affect the tests, so we are putting together a more comprehensive set of test images. The benchmarks posted in the readme are for a macbook pro i7 with 16 Gigs of ram. We first test them locally on the macs and then we will move to the Digital Ocean Dropplets, AWS containers and the Physical server. On my current setup I'm relying heavily on the CDN so the only work the server has to handle is new transformations. We are working on having a benchmarks list published along with the docs.
Meh too much renting. To be honest I think it's just a different philosophy. People have different opinions on this kind of things and that's fine. Ultimately I say develop a _library_ first, make a bridge from the framework _after_. Don't develop a framework library which prevents any form of re-use for other frameworks. That's all I want from library maintainers nowadays.
I've got you tagged as "Laravel Crusader" for some comments that you've deleted [here](https://www.reddit.com/r/PHP/comments/6eeutu/taylor_otwell_on_laravel_vs_symfony_debate/di9qumf/). You came here to bitch about a framework and spent most of your time complaining about 3rd party bundles. If you're looking for a discussion then start one. I don't think this subreddit is the place for you to vent about your issues with no intent discussion.
As soon as I wanted to authenticate users against LDAP, and store user attributes in a database that are retrieved upon user creation/update from LDAP it became a headache working with FosUserBundle. I wound up just writing my own user bundle to handle all of this which ended up being much easier.
we're looking for valuable feedback, this time we got more interesting comments.
Fyi on reddit the syntax is u/username, although if you're replying directly to them they'll already get a notification, so you don't need to specify anything.
Yeah it started out as a learning project. Building tests around every is next. Sadly. I didn't build this in a TDD way. Unfortunately. So testing is what I'll be adding to it next. If you'd like you can contribute some tests as well :)
Hello, I just checked out your samples. Starting with the simplest "hello world" app would be nice. Also, try a more secure way for query parameter injection: Route::get("baseball/player/{id}/", function($id){ // $id is now accessible : $id = 123 $model = new model("database"); $player = $model-&gt;filter(" id = '$id' "); // SQL Injection risk! Render::view("appname.template", [ "player" =&gt; $player ] ); }); https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide
Nice try Laravel
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phpsec] [Plan to bring Secure Code Delivery (Cryptographic Signatures and more) to Packagist and, in turn, Composer • r\/PHP](https://np.reddit.com/r/phpsec/comments/6mf83z/plan_to_bring_secure_code_delivery_cryptographic/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Awesome. Thank You! I'll check it out. If you'd like to update the provider responsible for that thatd be awesome! I'll fix that!
Which should really be `LogicError` now.
That would be very unreliable. It's one of the notoriously messy parts of JavaScript. Using the plus operator works well only in statically types languages. PHP isn't quite there yet and may never be. 
cheers!
yup..thats my experience as well..FosUserBundle is a pain honestly..it has some nice features but not worth the time end effort
&gt; Also, i would add, that I personally think that such checks are completely unnecessary and are visual garbage. We must treat our data as correct, except the third-party data, which we must first validate and then pipe thought out code without any further validation. So basically you're saying we should not use any typed language, because our data are correct anyway. Performances should never be a problem for Type Checking. If you have 35 lignes for argument validation, your method probably do too much anyway. Also type checking give you the possiblity to Fail-fast. If you don't validate the data, it might works and break later, somewhere else, and then you don't control what's going to happens. 
 function getDB($user = 'defaultProdUser', $pass = 'defaultPass) { return mysql_connect('127.0.0.1', $user, $pass, 'db'); // For create table access } \s -- actually, this hurt to write.
Yes, yes it does.
another way would be to just file put contents to a file and then render it like that, but that still doesn't get rid of exploits. Should i just make my own function that finds exec's and phpinfo() manually? is there a function that finds exploits like that and removes them? 
Nice work! It has tests, cleaner code with nice abstraction, and sounds like a useful library for those who need those features. May I ask you why haven't you published this library to packagist? It would be much easier with packagist so you don't have to copy-paste git repo information. 
If we talking about typed languages like c or java or even typescript, then yes, even compilator treats the data as correct and removes all types information while compilation because it ensures it all valid in compile time. So it's good. As for php, type hinting is just convenient self-documentation and autocomplete in IDE. I'm all for typed languages. But I'm against useless if blocks where we ensure passed arguments are valid. As for 35 lines, it's exaggeration, but ratio it still big. Even in listings from above, there is 3 line for checking, and 1 for actual business. Also, if we in paranoid mode then it goes just ridiculous, when we check every parameter multiple times in every function we pass it. For example: https://gist.github.com/Reeywhaar/f70c5d65faf0403ea93b168f5ff7d811 Performansce is a problem for type checking, minor but still. That's why you better to disable assert in production mode in php.
Found the term which I forgot: defensive programming. There are a lot of articles on that topic, for example: http://danielroop.com/blog/2009/10/15/why-defensive-programming-is-rubbish/
Hi, thanks. I've never put anything on packagist before, i was just going to wait and see if i got any feedback and if anyone thought it might be useful, but I could always put it there as well.
Might I be so bold as to suggest reading [semantic method naming](http://codelegance.com/semantic-method-naming/)? Function names like `templateEngine` should be considered invalid because they do not begin with a verb, and many method docblocks in the same file use verbs that do not agree with the method name. Furthermore, there seems to be an over-usage of the verb *get* where a more appropriate verb should take its place.
I didn't see it last time so I'm glad they did :)
Or you could do this with [nginx](https://nginx.org/en/docs/http/ngx_http_image_filter_module.html). A few lines of configuration and you're set. Beats developing and maintaining an application. I replaced a PHP app at work with this 8 months ago, I did not have to look at it since.
interesting. So what do you suggest templateEngine be called? renderTemplateEngine? 
Now tell us how you really feel.
&gt; Yes, we throw instances of Error for every mistake that's a programming error and needs a code change to fix. We also throw TypeError instances where we have to do manual type checks, because PHP's type system doesn't allow to declare that type. 👍 It's like you took every word out of my mouth. Exactly what I do. I also have a little tool that lets me set a stack "offset" for the line/file that Error/TypeError reports, so people see the line where they messed up, instead of a line where I implement the checking routine.
It was developed for in-house use only because of some business requirements and the way it is integrated with our media servers.
Assertions issue notices by default, which is not a very strong incentive for some developers. But sometimes you can make an omelette without breaking the eggs... class Foo { function bar(int $x, string $y) { assert(FooAssert::bar($x, $y)); ... Do stuff ... ... Do stuff ... ... Do stuff ... ... Do stuff ... } } class FooAssert { function bar($x) { if ($x &lt; 0 || $x &gt; 10) { throw new \TypeError('Argument $x is out of range'); } if (!filter_var($y, FILTER_VALIDATE_EMAIL)) { throw new \TypeError('Argument $x is out of range'); } return true; } } Now if you turn off assertions in stable code, the `assert(...)` lines are eliminated, and the FooAssert class *is never loaded*. Free type checks. 
OP, sorry, English is not my native language, so did you like it or not?
One of the motivations for getting libsodium into the core was to allow Phar files to support Ed25519 signatures. :)
As i answer in your blog, is not good practice process directly the input, and myself think is not good idea use REQUESTm you are vulnerable too to GET, not only POST attacks. In 14-16 years of using Php i only use request in a complicated function with a complicated POST dant later must convert to URL search in a java table, but dont was the original idea
&gt; But sometimes you can make an omelette without breaking the eggs... You can? 
You're pissed off that your app violates their terms of service and that they want you to conform to their authentication protocol? This has what to do with PHP, exactly?
Yes, because programming is ✨magic✨.
Would not work: you can't `render` a templating engine. You can either render from template engine. Semantic method naming means that your method name should be self explanatory. On this case, it depends. I can't find the exact method he talks about but if you had to render something from template engine the most appropriate in my opinion would be: `return $this-&gt;getTemplateEngine()-&gt;render();` Pay attention to getter `getTemplateEngine()` which should return the template engine, and `render()`method (which is neither getter nor setter), since the only action this method should do is render. Anyway, keep up the work and you'll find yourself be better at refactoring with every new line. 
There's a saying that experts are those who know *when* to break the rules... and in that case I think using `Exception` should be the rule. It's certainly the safer choice if you aren't sure. IMO `Error` should only be used when you can't imagine anyone ever having a good reason to catch/recover. In other words, you *want* the application to explode in a shower of sparks because it's the safest thing for everyone involved.
Awesome. Thanks this makes a lot of sense. 
Yeah, you could turn off notices and always throw error (AssertionError if no second argument provided), it may be enabled by "ini_set("assert.exception", 1)" or in php.ini http://php.net/manual/en/info.configuration.php#ini.assert.exception
It's probably https://deployer.org/ and why is because I don't think there is anything else written in PHP.
Other than tutorials, create real-world examples they can copy.
I assume the images were on same server. Can the module be configured to fetch images from external server (like Amazon S3)?
Images came from our media server, resized through a simple reverse-proxy. So S3 is possible.
Thanks. I'll have to investigate this more for one of our projects.
Because PHP is hilarious.
I find that hard to believe... at least 4 brand new accounts, all created just before you started posting about your instagram clone and all of which have star'd 100% of your personal repos. Edit: typo
Thank you zslabs. 
`Error` basically exists so that PHP itself can throw exceptions. Throwing it yourself only would make sense to me if you're polyfilling PHP functionality.
Do you think this is faster than using Thumbor? I had a relatively robust Thumbor setup, using queued face detection and S3 storage, but it was too slow for production use on our site. We regularly post photo galleries of 30-60 images, and it had trouble generating the thumbnails on a single page load. It was so bad that nginx was timing out (30 seconds). I'm now using Imgix, but the costs are quite high.
Lookin for a job ?
I'd love to see an example of type checking/if blocks causing a performance hit. I think such a "performance hit" would be measured in milliseconds at best.
[removed]
Thank you 👍🏻
Hey it's /u/opulencephp. How's the framework going? (Opulence)
Got any info on this middleware binding? To my knowledge, middleware is an implementation of an abstraction, so I'm confused what this is supposed to be and how you're supposed to use it
Can you please kindly explain in a few words what is it and why is it? I cannot make it from the link you provided. 
There is also [Rocketeer](https://github.com/rocketeers/rocketeer). Not that it's better or worse than Deployer, just it is also written in PHP. [Robo](http://robo.li) is also in PHP, and it allows to write deployment (and other) tasks in OOP style. And there is [Laravel Envoy](https://laravel.com/docs/5.4/envoy), which is not as feature rich, but simple to use because of Blade style syntax.
[Huh? What? Why?](https://hashtagfoundation.org/framework/huh) The Hashtag Framework is written in PHP and provides an HTML-like markup language to power complex Web Apps. Full back-end automation. Native API support. Use Google Docs as formatted markup. Use Google Sheets to store records. Write JSON-RPC API endpoints in simple markup.
To learn from a live example, check out this [Guestbook Form](https://bat.hashtagfoundation.org/guestbook/form), and leave a comment. All of the Hashtag Markup for those pages are included inline. Simple forms without SQL injection. The [Build Acceptance Test](https://bat.hashtagfoundation.org) is full of live examples. 
TIL you can `use` multiple namespaces in one line: ``` use Opulence\Routing\Matchers\{RouteFactory, RouteMatcher, RouteNotFoundException}; ```
~~Yup. PSR-2 doesn't allow it though.~~
PSR is not word of God set in stone lol
I know. ~~Just wanted to note that it's not the best practice.~~
Announcement tweet: https://twitter.com/phpexternals/status/884668964407738370 Github: https://github.com/mnapoli/externals Also, sidenote: The internals mailing list is an open list - anyone can join and post, so don't be too alarmed if you occasionally see crazy suggestions.
PSR-2 was accepted in June 2012 Multiple Namespace declaration was introduced with PHP 7 in December 2015 I am not aware of any updates / errata in PSR-2 which specifically addresses this point. It's unfair to say that "it's not the best practice". Real world usage will define what is the best practice for this construct going forward, therefore I encourage use of multiple namespaces until a best practice emerges organically.
Oh, it's all about &gt; Now consider adding an email address field to this guestbook process, and how it would require changes to each of those 3 pieces. In PHP we had this temptation long ago. And already learned that form-to-database relations are *not that straight* and, despite how tempting such a shortcut is, in the real life you'll struggle with exceptions. So if you really need it, you have to throw in a solid *validation framework* and a *flexible* data mapper. And still there will be a lot of cases where you would handle the form manually. TL;DR: "Full back-end automation" is a myth. &gt; Use Google Docs as formatted markup. Use Google Sheets to store records. The idea is funny, but I doubt you will recruit many followers in *this* sub. Also, I have a feeling that any ColdFusion incarnation looks a bit... archaic nowadays. 
Thank you for pointing out Thumbor, we didn't compare it with our repo. On our roadmap to do a benchmark with S3 storage, also with a fully AWS setup (Elastic Beanstalk + S3)
I'm currently looking for a routing package for a small PHP app that just needs a few classes loading when a URL is called but I can't seem to find anything that matches Laravel's simple syntax and works out of the box. Laravels Syntax is as follows: `Route::get('user/profile/{id}', 'UserController@showProfile')` Doe's anyone know of a package that is as clean as this?
But I can assure none of those account were created by me!! I did not even knew these things can be done!!
HAHAHAHAHAHAHAHAHAHA
Are you using a Markdown parser to format the emails? You should turn on the option to respect line breaks, as often code looks bad. Example: https://externals.io/message/99753
how does it compare to https://github.com/h2non/imaginary which is also based on libvips? especially in terms of concurrency &amp; performance?
What is your issue with FastRoute? It's as simple as your example. 
This article fails to note that even though most varchar columns in your database are probably 255 characters there is an index limitation of 768 bytes meaning the columns can only be 191 characters if using utf8mb4, simply changing the column length may cause data loss. Its not always as simple as just running a few queries to convert.
PSR-2 is not "best practice". The best practice is using *a* coding style, whichever one you choose. 
This may also cause issues with password lengths if you use the `password_hash` function and had the password column set to the specific length of the hashed value. It's possible that their users may not be able to log in now.
You didn't actually properly explain the cause. I'm guessing if you have user input, they tried to insert an emoticon which UTF8 doesn't support. This will break the database and is usually the main reason for using UTF8MB4. I remember making my first commenting system and trying to add an emoticon myself and it just broke everything. A little bit of research suggests using UTF8MB4 and thankfully I wasn't using a production server at the time.
&gt;I am not aware of any updates / errata in PSR-2 which specifically addresses this point. Isn't [PSR-12](https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md) exactly that?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [php-fig/fig-standards/.../**extended-coding-style-guide.md** (master → 0745733)](https://github.com/php-fig/fig-standards/blob/07457338de38459a4784fc627bdb780a3dacfb22/proposed/extended-coding-style-guide.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk2cww9.)^.
Was exactly gonna ask this as Golang is known for its low(er) footprint.
Wow, great info! Thanks ! 
FWIW PSR-2 does not even talk about this you may be referring to the upcoming not final PSR-12 when it will eventually come out. /me nitpicking
Are you referencing nikic/fast-route?
I'm not the site author. I'd suggest filing an issue on the GitHub project if one doesn't already exist.
tl;dr "Use utf8mb4, not utf8 in MySQL". A bit of a click-bait title. The author isn't telling any concrete story where they "almost lost an important client". They describe a hypothetical scenario where utf8 may lose data. At least I hope it's hypothetical, because for a company focused on SQL, not knowing how MySQL's "utf8" works would be pretty damning.
Misaligned dot over "i" in logo is triggering.
That's exactly it. I'm looking forward to the final published PSR.
The matched route will contain the middleware that are bound to the route, as well as any middleware parameters bound to the route (think Opulence or Laravel). You can grab it via `$matchedRoute-&gt;getMiddlewareBindings()`. Each middleware binding has two methods: `$middlewareBinding-&gt;getClassName()` and `$middleware-&gt;getAttributes()`. Then, you can dispatch to these middleware classes with the middleware dispatcher of your choice. 
Hey, it's me. It's going OK. I got tied up with this library (it started off as a fun sprint idea at my work). I'm still working on v1.1 of the framework. 
bcrypt hashes are all ASCII taking 1 byte each, So I don't think there will be a problem. 
I was going to say the same. This utf8mb4 thing isn't very new either. 
I'm sure he is. 
That's a good point. Though it doesn't mean that you can't create a longer column, it just means you'll have a problem indexing it because of this limit. Will add this information to the article, thank you for taking the time to comment :)
This might just be me, but what bothers me the most is that there was no proper MySQL error handling in place. Those errors are returned by the mysql/pdo layer but it takes 30 min+ to debug that... Those errors should have popped up somewhere, be it a mailbox, logging system or at least the system logs...
Yep, that's why we decided to blog about it. Took us a while to figure it out.
It's semi hypothetical - didn't happen to us, but it's based on stories we read online, more than once. See CheckeredMichael's comment for one more story :)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Suppose to be a star moving across an elliptical path. Although I can see how that's triggering lol. 
Yeah, and from the time there is this simple guard configuration of user authorization (you just setup your user entity, guard config class and config in security.yml and thats it) there is really no point in using FosUserBundle. Sooner or later you would end up overwriting every part of this bundle and it would be a mess...
class names as strings? why not use `ClassName::class`
join the club! http://php-news.ctrl-f5.net/
^ this man gets it. nice hobby project though
- FOS bundles are not symfony - sonata is definitely not symfony and has been a mess since it was created, the docs are useless
I wonder what they used to build Laravel /s
So... ...it's basically a re-implementation of PHP circa 1998 (ie, pre 4.0) (or maybe early ColdFusion?), written in PHP? I'm simultaneously impressed and horrified. It sounds like the least useful thing I've ever seen, and yet the attention to detail and thoroughness of the implementation is impressive. It looks like a real project (it's way too in depth to be a joke), and yet I can't imagine anyone ever using this. Certainly I don't think anyone *should*. Congratulations? I guess? In its way it's an extremely impressive, especially since (I assume) it's just one person behind it. On the other hand, there's a reason why we've moved on from code like this almost 20 years ago. This isn't the future; it's the distant past. Thankfully.
I definitely would use `ClassName::class` in the real world. I was using strings in the examples to simplify them, but I agree it might make more sense to show better practices. Updated the docs.
I went back to college for my Master's degree... 100% can confirm, professor didn't teach anything near current standards. We were told to write some of the worst procedural code I've ever seen.
So it's just a click-bait. A blatant spam article.
Literally externals
1. /r/phphelp 2. The best way to learn a programming language is http://programming-motherfucker.com
https://github.com/Reeywhaar/sillyphpcheckbenchmark on my machine (php 7.1.5) it's 5-15% performance loss. unchecked 6.7857758998871 checked 7.4037828445435
Nice. I especially like the matching on headers, which regrettably few routers do. A question, and a suggestion: 1. Have you considered collapsing the `src/Routing/*` to just `src/`, and `tests/src/Routing/*` to just `tests/`? (PSR-4 allows that and it minimizes empty intercessory directories.) 2. As a feature suggestion, you may wish to add header-specific comparison methods; e.g. `accepts()` to check the Accepts header for non-zero Q values on content types (Aura.Router does this). I've been toying with the idea of a `session()` method as well, to see if a PHP session cookie is in the request; that would tell you if the request is at least pretending to have a session already. 
Reddit is a fickle thing, that's for sure.
Interesting thing. I want the opposite: JS to PHP :-) BTW, there's one more huge difference not mentioned there. PHP arrays are passed by value and JavaScript arrays/maps are passed by reference. So that will be a very big difference in results in many places... It's possible to emulate, but not if it's translated naively, syntax to syntax.
indeed
Good idea to make them human readable, but why ASCII codes? Why not directly the characters? const IS_FEMALE = 'F'; etc.
Build shit, it's the only way. Start small, maybe a chat box or something similar, than add features onto it, database connection to save the chat logs, than add username/password to learn about security etc. Just keep building shit.
How do I know if I am writing good code? I understand the general want to write towards reusability, modularity, loosely-coupled. How do I know I'm making the right decisions towards that. How can I improve my design skills?
Outside of my usual development stack, I feel like there is so much going on in the dev world. I don't know what's available, what problems need to be solved (simple example is that you can write an API, but you might not be aware of op-caching to help improve that technology if you're not aware that is a problem). How do you keep up with new software technologies?
I could see many ways how this can go wrong and be popular with guys who have PHP code and want to run it on the browser because they 1. either don't master javascript or 2. want to save time.
1. Fair suggestion. I'll change this once I get back from work. 2. Also a fair suggestion. That could easily be handled by a [route constraint](https://github.com/opulencephp/route-matcher#custom-constraints). I'll look into baking some constraints into the library to simplify the common-use cases. &amp;nbsp; Thanks for the feedback!
The 1980s called. They just wanted to make sure you're still getting routinely kicked in the groin by character encoding complications.
Well, technically it's sort of HTML-to-database mapping with allegedly "fully automated backend", so it's not just a re-invented PHP, but rather a materialized dream of PHPers from '98 :)
The biggest use I immediately thought of was things like form validation—perhaps it might work perhaps it wouldn't. Wonder how it works with regexs and such.
Signs of the apocalypse.
The line I was referring to was "There MUST be one use keyword per declaration." PHP_CodeSniffer warns of this when I use compound namespaces, and I wasn't aware that the recommendation simply hadn't been updated. In light of that, I agree with you.
Using Markdown indeed. I played with different configurations for a long time and nothing is perfect. It boils down to "90% of the emails will look good, the rest won't". I'm fine with that, and I'd rather have a very good design for 90% emails than an "OK" one for 95%. My secret evil plan is that #internals posters will learn about externals.io, realize that their emails may be read through this platform, and maybe format their emails using Markdown knowing it will be nicely displayed there. I *think* some of them already do that, who knows. Anyway something that could be done is some sort of "community-contributed" moderation, where readers could "vote" for an email to be displayed as raw instead of parsed through Markdown. That could help take care of the last 10%.
&gt; You should turn on the option to respect line breaks Actually I'm stupid: I forgot that I already do that. What you are seeing is a bug caused by the `&lt;?php` tag: https://github.com/mnapoli/externals/issues/15 But I'm not alone this tag also breaks rendering in GitHub issues :)
If you did that and created a version compatible with PHP 5.6, I'd use it. I've got my own Enum package I use internally but it's definitely inferior to this.
This is like trying to turn a penguin into an eagle by taking it apart and putting it back together. In the end, it might look like an eagle, but it won't fly.
starting on your own without a solid symfony project is pain in the ass because you start looking into FOS, sonata and content management bundles. Those are not recommended by any respected seniors devs that I know. Also collection forms and doctrine ate up a bunch of my time when starting out so look out for that
In what way doesn't it work? Error Message?
Also: your WHERE statement is wrong. Use "=" not "=:"
no errors it just dont updates database when im returngint '$stmt-&gt;queryString' it look likes this 'UPDATE Question set (question) WHERE questionID =:questionID' and $insertKeyValueArray looks like this: 'Array ( [:question] =&gt; something )' i cant see any problems why it shouldnt work but it dont works just like that
im using =: beacause i bind values aferwards... i have done insert function with that where function and it works just fine.. function insert($table,$array){ if(!empty($table) &amp;&amp; !empty($array)){ $keys = ''; $keysForValues = ''; $insertKeyValueArray = array(); foreach($array as $key =&gt; $value){ $keys .= $key.","; $keysForValues .= ':'.$key.","; $insertKeyValueArray[":".$key] = $value; } $keys = rtrim($keys, ','); $keysForValues = rtrim($keysForValues, ','); $stmt = $this-&gt;connect-&gt;prepare("INSERT INTO $table ($keys) VALUES ($keysForValues)"); return $stmt-&gt;execute($insertKeyValueArray) ? $this-&gt;connect-&gt;lastInsertId('questionID') : FALSE; } }
Added a basic version to the Babel website if anyone wants to try it out: https://babeljs.io/php/ Source: https://github.com/babel/babel.github.io/blob/master/scripts/php.js, https://github.com/babel/babel.github.io/blob/master/php.html
Upvoting to support you as a developer. Writing a framework is challenging and time consuming, but a great learning experience. Keep up the good work!
source : https://twitter.com/blowdart/status/880277204319457285
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [babel/babel.github.io/.../**php.html** (master → 7760769)](https://github.com/babel/babel.github.io/blob/7760769dec702b14d87659aa18e00b57700e4d9b/php.html) * [babel/babel.github.io/.../**php.js** (master → 7760769)](https://github.com/babel/babel.github.io/blob/7760769dec702b14d87659aa18e00b57700e4d9b/scripts/php.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk2v7qj.)^.
Every day we stray further from His light
You might want to try /r/PHPhelp. It might also be helpful to understand what is not working. Are you getting any error messages? What is the expected output? What output are you getting? Why are you returning `$stmt-&gt;queryString`? I would start adding "dump and dies" for each step to make sure they are behaving like you expect (or better yet use a debugger). Also `$stmt-&gt;execute($insertKeyValueArray);` should return `false` on error. I would dump/log/throw `$stmt-&gt;errorInfo();` on false so you have more information about what is going wrong. You may want to consider refactoring this. It is hard to understand what this code should be doing.
im returning queryString cause i wanted to check if its was valid query and im not getting any errors
yes, i've explained it before as bringing back all of the things people originally complained about in PHP... but the implementation is solid, as you can see in the response times for the [Build Acceptance Test](https://bat.hashtagfoundation.org). you may find it ridiculous, but this framework was used to build a marketplace for a fortune 100 company bringing together resellers and vendors any every abstraction of vendor marketplaces, reseller marketplaces, agent promotions... it distributed pricing catalogs, handled AS2/EDI transactions with partners like walmart, instant reporting with responsive caches. it was a gigantic multi-year project, and has been very successful. the simplicity gained through the framework allowed a very small team to deliver. as long as browsers are consuming HTML, there is certainly still a future for languages like Hashtag Markup.
thankfully, Hashtag Markup fully supports inline PHP code, so anything you need to do in PHP, you can. you can change the database schema manually if you need to, and Hashtag Markup will still work. but in the "real life", i haven't needed to do either. the Hashtag Framework provides a solid validation framework, building off HTML 5 input validations, while offering Form Actions to further process and define exceptions to map data flexibly. if you want to handle the form manually, nothing is stopping you, but you won't need to. as for the Google API integrations, i'm hoping the subscribers to this sub are also freelancers with clients who are begging for features like these. makes life easier for everyone. if you'd like to provide a case of a form you don't think could be handled by Hashtag Markup, i'd be happy to show you how it could be implemented. 
What is the query string you were getting? So you checked the query string by manually running it? How are you getting the results? Are you sure there is nothing wrong with how you are getting the results?
Looks on mobile like Its a New page 
what an original, fresh meme
remove the : from insertKeyValueArray
not i turned on display error and it shows this error message Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number: number of bound variables does not match number of tokens in /var/www/html/online-poll/Database/dbHelper.php on line 54
not i turned on display error and it shows this error message Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number: number of bound variables does not match number of tokens in /var/www/html/online-poll/Database/dbHelper.php on line 54
1. /r/phphelp 2. Beside writing a code you must to learn how to *debug* it. **Print the resulting SQL statement and see what is wrong with it**. 3. [This code is vulnerable to SQL injection](https://phpdelusions.net/pdo/sql_injection_example) 4. Most likely your wrapper is a subject to [other flaws](https://phpdelusions.net/pdo/common_mistakes).
it dont helped
Seen it pass in /r/ProgrammerHumor ages ago. Anyway, upvoted because you've got the balls to post it in /r/PHP.
So this is basically, a PHP to JS transpiler? 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
I am going to venture a guess and say JavaScript, with a little CSS and HTML for good measure. I maybe wrong but I am almost positive it didn't involve PHP, the animation parts at least.
I just install YADR and have everything that it includes. https://github.com/skwp/dotfiles
Looks like React - so almost certainly custom JS and CSS handling those interactions. 
Thanks, would take a look at that
linux has a different filesystem..which is a hell lot faster than windows..for instance my symfony app which runs on linux under 300ms runs on windows under 10s
not php
Is this macOS/OS X only? 
I'd use this (with a heaping grain of salt). It would definitely be useful. But I can't see it working at large scale because of the differences between functional &amp; procedural code &amp; imported dependencies. I can imagine this in tandem with `var_export` and `json_encode/decode` to help transcribe functionality between PHP &amp; JavaScript.
There are parts in the automation script that sets defaults for OSX but I've slimmed down the install process before for Linux.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Do you by any chance have that slimed down version on a git repo somewhere or are you the maintainer of the one cited above? 
That makes sense. This simple benchmark script however doesn't test any I/O or database or anything else; it's purely "CPU" operations. 
Just as an aside: For people just looking for a less 'opinionated' dotfile repo manager I'd recommend [homeshick](https://github.com/andsens/homeshick) I'm open to hearing some alternatives for this type of thing as well.
I don't think you're generating valid SQL. You want something looking like e.g. update $table SET field1 = :value1, field2 = :value2, field3 = ..... WHERE whereKey = :whereValue Then pass in then an array like : [ 'value1' =&gt; 'hello', 'value2' =&gt; 'world', 'whereValue' =&gt; 'whereValueThing' ] to execute. There must be loads of examples on StackOverflow and the like to guide you through how to do this properly. Or even the PHP.net website (see the examples and comments on http://php.net/manual/en/pdostatement.execute.php ) 
Why do people want to transpire/compile/whatever PHP to other languages? The the whole .Net thing is more-or-less plausible due to similar OOP structure of languages + idea of making PHP into per-compiled code for sake of speed, but this just makes no sense to me.....
You can pass vars by reference on php, same as JS does.. 
The menu items have react labels, so this menu was probably built using that.
it would make sense to test it in a vm with same allocated cpu.since you can have a few things running in behind in windows..
Try hitting 127.0.0.1 instead of "localhost". Also if using a database, make sure you're connecting to MySQL with 127.0.0.1 instead of "localhost".
The Windows 10 Linux subsystem is "native", it doesn't run in a VM. Either way though, even if we were dealing with things running in the background (they don't), there wouldn't be such a drastic performance impact. Sure, a few percent, maybe even a few tens, but not a more than four-fold difference. Incidentally, I added xdebug to the Linux subsystem and it slowed down that benchmark three-fold. That's why I was thinking maybe it's a process or module that's the culprit with the WAMP.
[Whoosh](http://imgur.com/2wZtgzN)
There are two things which PHP does much slower on Windows: - File I/O - Function calls (any function calls, internal ones, user ones, methods), even if they're empty. For the file I/O I can see why it's the case, but for the functions, I feel PHP just has a Windows implementation for function calls that's not as good, and nobody bothered to optimize it, because running PHP on Windows is rare.
The microframework is dead. Long live the microframework. Symfony microkernel made Silex irrelevant. 
Depends where you want to fall on the lightweight text editor &lt;-&gt; IDE scale. But some of the more php-specific and IDE-like plugins I use: * syntastic, of course, using php and phpmd linters (with phpmd in unusedcode mode only - I don't want my editor constantly telling me that my constructor takes 1 too many arguments or anything distracting like that) * vdebug - vim plugin for DBGP (i.e. xdebug) * phpcd - really heading to the IDE side of the scale here. Makes omnicomplete work - i.e ctrl-x ctrl-o on a variable will offer method autocompletion and documentation, plus in normal mode ctrl-] will jump to definition. * vim-snippets/ultisnips - save time doing the things that make you wonder what is going through PHP's head in the first place (how much boilerplate do you need to create a value object with a constructor and some getters?? Too much to do by hand.) Apart from phpcd, I do most of my ide-type work on the cli using the various linters that you'll have seen on this sub (phpstan, phan, psalm), plus sgrep and spatch from Facebook's pfff for when text-based operations aren't enough. Ignoring the php-specific side of things shout-outs to some of the more standard plugins (airline, ctrl-p, gundo, nerdcommenter, vcscommand), plus I love vim-operator-flashy even though it does such a minor thing. Buuuuut the key thing as always, is to only install what you're sure you'll need and use. If you want a batteries included behemoth IDE that's slow to start, there's plenty out there. **Edit:** These are all for vim - not switched to neovim (yet), but presumably most will just work.
We use Fabric.
Comparing 7.0.x -&gt; 7.1.x probably isn't a great idea. Also, you seem to have the Debug Pack version of the Windows Binary. This could be slowing it down in general. Lastly, the difference is coming from the *test_stringmanipulation* code. What functions are you using? The underlying code that gets executed could be quite different between Windows and Linux based on lots of different things. Locale, UTF blah blah. Are you using mb_() functions?
thanks i fixed problem i wasnt passing enough values in $insertKeyValueArray i changed getWhere like this function getWhere($array,$forUpdate = false){ $where = !empty($array) ? ' WHERE' : ''; foreach($array as $key =&gt; $value){ if($forUpdate){ $where .= ' '.$key.' ='.$value.' AND'; }else{ $where .= ' '.$key.' =:'.$key.' AND'; } } $where = rtrim($where, 'AND'); return $where; } and im getting fields insted of array $where = $this-&gt;getWhere($fields,true); its not best solution but ill think refactoring about it later &lt;3 
&gt; i've explained it before as bringing back all of the things people originally complained about in PHP... but the implementation is solid, as you can see in the response times The problem with this design pattern isn't the response times. &gt; you may find it ridiculous, but this framework was used to build a marketplace The fact that the devs behind the project managed to build something with it is setting the bar very low. I may have mixed feelings about, eg, Laravel, but its defenders have much, much stronger arguments than "hey, it's not that bad, a single project was written in it once!" &gt; as long as browsers are consuming HTML, there is certainly still a future for languages like Hashtag Markup. Because it can generate HTML? Just like...every...other framework...ever? Look, I realise you're invested in this project, but if you want to convince *ANYONE ELSE*, you need to start by explaining concrete ways it's better than the existing tools. So far we have: "It generates HTML!" "It's been used in a single large project!" "It looks a bit like ColdFusion!" **These are not compelling arguments.**
Think so? [Seems like it's still undergoing development](https://github.com/silexphp/Silex/) at least, and Fabpot has his hands in both projects.
I thought mono had WCF
It does, but not all features are supported, which I found out the hard way when I got exceptions pumped up in the console and error log.
I get the impression that MySQL, Apache, and PHP don't give a damn about Windows and have nobody that actually optimizes the code for Windows. Regretful, really, since I've found PHP to be far easier and more powerful for scripting compared to regular batch files and PowerShell
I've developed all of my PHP in Vim exclusively for the last ~ 5 years. My [dotfiles repo](https://github.com/Firehed/Settings/tree/master/vim) is fairly up to date. Notable items: * Ale: fantastic linting plugin for Vim8 (and nvim, I think). Hooks into `phpcs`, `php -l`, and some other stuff. I am working with the author to get full Language Server Protocol support added based off of [this](https://github.com/felixfbecker/php-language-server) * PHPComplete is kind-of-okay. It's fairly slow on large projects (my tags file is 46MB...), and you need to keep your tags file up to date^(1). I hope to be able to replace it with some of the LSP stuff * Supertab is not PHP specific, but complements the above nicely * vim-php-manual is basically embeds `php.net/thing_under_cursor` * php.vim for general language and builtin function highlighting Like anything Vim-related, I would suggest starting with a blank setup and only installing plugins as you find a shortcoming in your workflow. ^(1): I have this snippet in `.git/hooks/post-merge` to regularly rebuild my tags file #!/usr/bin/env bash echo "Generating new tags file" rm tags &amp;&amp; ctags -R --fields=+aimlS --languages=php 2&gt;/dev/null &amp; 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [Firehed/Settings/.../**vim** (master → b809dd8)](https://github.com/Firehed/Settings/tree/b809dd823ec0ae95521a671bc56d8bcb3e60567f/vim) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk3ezdw.)^.
PHP: You can download compiled binaries from php.net, and there are many Windows-specific optimizations. Kudos to Windows maintainers! Apache: ApacheHaus and Apache Lounge both build Apache binaries, monitors, etc. They are quite fast too. Apache 2.4.27 is available in both AH and AL, but not in many of the Linux repos yet.
KnpUniversity has some Amazon tutorials although only some of them are free. The best way to learn is to throw yourself into a project you feel comfortable with and learn as you make mistakes and grow. If you're comfortable with programming in general or basic PHP then look into a framework like laravel or symfony. Both of those will make development much easier but it does add a bit of a different learning curve. If you need some ideas on little programs to practice with I would suggest working through some of the problems found on project eulner. The first few problems are simple and should help you out with getting used to solving problems and developing algorithms.
by this link, Silex haven't been update in almost a month. compare it to 9 hours on Symfony...
Yes. Like I said, it's similar to your example. 
Yeah dude, I know. I'm saying it's still being maintained. Both of them by Fabien.
translator, transpiler, compiler, converter. It's whatever you want it to be.
&gt; The problem with this design pattern isn't the response times. what exactly is "this design pattern"? and what exactly is the problem? this is a brand new approach, designed while fully understanding the weaknesses and pitfalls of similar JIT / MVC frameworks, while providing new solutions that demonstrably work. sorry about the varying height of your bar... you couldn't imagine "ANYONE"... "EVER"... so, i gave you one example, once. a pretty big example, for just about the most daunting web app you could imagine, and it is still performing well after 10 years. this framework has been in development for over a decade, and in prior releases, it powered many 100,000 CRM web app installs, it has been battle tested, and the big enterprise project required a security audit through the NCC group, which passed. Look, I realize you're invested in talking about ColdFusion, but you don't seem to understand the connection i'm making with HTML.... i never claimed "It generates HTML!"... i claimed browsers consume HTML... HTML is what needs to be created eventually, regardless of the programming language. yes, HTML certainly is the common denominator of every........ other.............. framework... exactly, right. refactor the dev process. now HTML is the programming language. and it works. I think you want to help, so please provide a real world example of where you think the framework will fail, and i'll explain why you're wrong with a real world live demo. **#compelling**
FYI, item 1 is done, and I'm working on compiling a list of useful constraints for item 2.
&gt; This project is silly and exists only to expand Atwood's Law. Yuh-huh
I'm sad about this too. I love Silex. 
[The League's Route package](http://route.thephpleague.com/) adds a friendly syntax on top of FastRoute, and works well with their container and whatnot, if you want a little more "packaged" solution.
Interesting to run some CLI benchmarks to see ifs its actually PHP or something else.
FWIW, silex has been dead for ages: it started as an experiment (together with pimple), then people figured out how to patch in "providers", then somebody thought to "scale" it (mostly igorw by the way - brilliant chap). Then we got some proper stabilisation of the ideas via PSR-7, PSR-11, PSR-15 and their previous interop-* experiments. Just go with those: same amount of code, more stability and less framework-specific details, plus you can pick your own microframeworks and switch relatively easily. Wanna go full-stack? Do it. Let's not pretend that using an older experiment was a future-proof choice. All that said, I am super-grateful for what it started, and what Igor's and Fabien's ideas have led us towards.
I run one of these benchmarks on a windows 10 without an ssh disk and the difference was actually 1000% performance loss without IO operations, db interactions..just running a big loop so really depends..
That's really interesting. Let's hope someone with a deep understanding of how these things work jumps in. 
Is "Linux subsystem" on Windows is stable and production ready? I thought it's still in testing. If it is - it can produce unpredictable results in some cases. Did you tried to find the slowest part of the code of the string manipulation test?
Python is better supported on Windows (although there are still some holes), and all your scripting should be as easy or easier.
I don't see why that would help, DNS lookups are cached and have no performance issue worth mentioning
https://www.google.com/search?q=chat+site%3Areddit.com+inurl%3Aphp
Your Windows machine uses ZTS (thread safe) version of PHP, and Linux - NTS (not thread safe). You can install [ZTS version](https://launchpad.net/~ondrej/+archive/ubuntu/php-zts) on Linux and check for your self that it is slower than NTS. 
&gt; It’s built on top of Pimple dependency injection container and Pimple is really awful I really like Pimple and honestly it's the best DI library I've used (obviously, IMO). I was surprised to read this. What do people dislike about it?
I realise this isn't a support subreddit, but I wasn't sure where to post this. Ever since I re-installed High Sierra beta on my MacBook, the top menu of PhpStorm completely disappeared. Am I missing something or is it simply as a result of some bug?
You can start with https://spacevim.org/
Mac OS 10.13 is not yet supported as it still is in **Beta**. 
Yeah I realise that but I was running it on 10.13 fine before I reset my mbp.
https://beta.apple.com/sp/betaprogram/
I'd like to know this as well, I've always liked pimple 
&gt; Windows is stable and production ready? Yes it has been for a while &gt; it can produce unpredictable results in some cases Citation needed
React tags so probably that but seems extreme overkill to load the entire react library for that, this can be easily achieved with just CSS
&gt; I'm simultaneously impressed and horrified. It sounds like the least useful thing I've ever seen, and yet the attention to detail and thoroughness of the implementation is impressive. Yeah I thought it was just trolling at first then I seen how much effort had gone into it now I'm thinking he's actually being legitimate 
As far as I am aware, Pimple doesn't use reflection, so using Pimple you end up passing the container around? I may be wrong, I haven't used it in a while.
Personally I’d take an open-source node.js solution for that but if you want to use PHP have a look at https://github.com/reactphp
I'm also thinking about node.js perspective, just wondering if it's compatible to LAMP stacking, and mixing them on the current PHP web based app
You should post this in /r/phpstorm/. And like /u/billcube mentioned Mac OS 10.13 is still in Beta. So it could be a bug on apples side that will be fixed in the future or a change by apple that Jetbrains will need to fix. You could also create a ticket here https://youtrack.jetbrains.com/issues/WI.
I thought this read as "Immutability of Dota" and I got super excited before realising this was on the PHP subreddit. Thought I was going to get a nice, well thought out discussion about one of my favourite games and how it has remained great after all these years... instead it's a discussion about ensuring your data is being stored with a view of expansion.
A "chat system" sounds like something that updates in real time (such as Slack) rather than updates upon refresh (such as Reddit). You could go the "AJAX polling every second" route, but I think any reasonable amount of usage will drain your resources quite quickly. Having said that this is a very simple system. If the [browser support](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API#Browser_compatibility) is acceptable to you I'd recommend using web sockets. They were designed for this exact type of thing and although a bit more complicated they will scale better. Having said that, if you go the "AJAX polling every second" route you could speed things up by storing messages in an in-memory cache such as memcached or reddis. This might negate a lot of the speed problems...
It doesn't use reflection but that doesn't cause you to pass the container to anything, you just have to configure how the class is created rather than having any autowiring.
Obligatory comment: Because Linux is better?
I like the idea behind this, but the approach seems to be a bit limiting. For instance, if a contract doesn't just have a mutable end date, but also a "cost per unit" can be changed whenever the contract is renewed, how would you go about this? Change the signature of *renew()* from *renew(\DateInterval $interval)* to *renew(\DateInterval $interval, Money $newPrice)*, which could (for some entities) lead to a super generic "update everything" method? Or do you add a *changePrice(Money $price)* method, which would mean *$contract-&gt;renew(...)-&gt;changePrice(...)*, causing two versions for what (from a business perspective) is just one change?
Yeah this is a thing to consider. I would like to point to a presentation by Ocramius where highlights a subject that is somewhat relevant. https://ocramius.github.io/extremely-defensive-php/#/67 (slides 67 through 69) "Single public API endpoint wrapping around state change" (slide 69), so you would add more parameters if it make sense as a single transaction. So if you think about transactions those multiple versions make sense, even from a business perspective it might not. But you can see that it was first renewed and then the price what changes (in that order).
Love the site design, very easy to read on my phone.
Silex got a v2 release 3 May this year so I'm confused how that matches `dead`. Looking @ lumen vs Silex, Silex was update more recently, so less dead. Just because Javier adds a slide to a presentation claiming its dead doesn't make it so. He is not the owner or member of the Silex project and has 3 commits on it which doesn't make him a core contributor either. If the project is dead to him because `SensioLabs focus on SF Flex`/ `he doesn't use Silex` / `thinks something else is more awesome` is fine by me, I just don't see why that would be PHP community news ¯\_(ツ)_/¯
Thanks for the clarification!
thanks! About 15% of our views are from mobile sources so we tried to make sure it was usable on a smartphone :)
How would JS' `async` and `await` translate to PHP?
https://twitter.com/macdigger/status/884946395567759360
Is this a wrapper for literally [one line of code](https://darksky.net/dev/docs/forecast)? https://api.darksky.net/forecast/[key]/[latitude],[longitude]
Woops, posted in wrong spot
I use it with neovim and it works flawlessly
"localhost" on Linux should be faster because it connects via a socket rather than TCP/IP port.
- no typehints? - https://github.com/iranianpep/darksky/blob/master/src/Darksky/Darksky.php#L45 okay...? - no docblocks 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [iranianpep/darksky/.../**Darksky.php#L45** (master → 506c770)](https://github.com/iranianpep/darksky/blob/506c770780fb58e563fe1383b95fdcc0bc4a87e7/src/Darksky/Darksky.php#L45) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk450sn.)^.
Woops, I meant to post it as a top-level comment
This is for Vim 8, not NeoVim, but there should be alternatives. I've got a Repo [here](https://github.com/Garethp/vim) so you can clone it down and take a look * Pathogen - Plugins * Ale - Async code linting for PSR-2 * Codi - More of a curiosity, but basically live preview of code results * DelimitMate - Automatic Braces * NERDCommenter - Ctrl + / for comments * NERDTree + NERDTreeTabs - For better project Tree * Vdebug - XDebugging * Vim Fugitive - Git management * Vim JSON * Vim Tmux Navigator - I like to use Tmux, and this makes moving between panes and tmux windows use the same keys There's also a couple more for ease of use, and some configurations, but I think it's well documented. I'm also building a couple of my own slowly (Something to make VDebug look prettier for example, as well as my own php completion), but I don't think I include those in this repo
Yeah, every time I see this stuff I just go...... why?
Link not working
well, there are a few optional parameters as well.
This is the correct answer... Similar questions before
How is the result different from something you can achieve with event sourcing?
wait with posting then
Oh. it was you with [another shitpost](https://www.reddit.com/r/PHP/comments/6ll92s/why_php_is_different_from_other_languages/). Then don't even bother when it's up.
He's saying it's dead as in there's no point using it after Symfony 4 is released, not that it's going to disappear.
Thank you. The Beta release is too often considered as a "free preview" instead of a process in bug-finding.
You appear to be using the 32-bit version of PHP on Windows and the 64-bit version of PHP on Linux. That could make a big difference right there..
Don't be sad. The good news is that the new Symfony is very similar to Silex. So Silex is not dead, Silex won :)
Ah thank you. I was wondering if it's an isolated issue or a bug, looks like it's a known bug. 
just read a lot and try to understand why people write the subject. You never know if a decision is the correct one. You learn that in the future. But if you have clean code, it will be easy to maintain and to switch frameworks and so on with leaving the real code intact. 
At first view of the title, I though this post was going to be about Immutable Objects, but I was pleasantly surprised to learn that it wasn't. I like the intention of this post, but I do see something wrong with the reasoning in it. For enterprise application development, it is very important to isolate domain logic from application logic. So it is very important to make the following distinction; is versioning part of the actual domain, or is versioning just part of the application management logic? The example in the post seems to mix these two distinct types of logic and implementation, which can quickly lead to problems and fragmentation in an enterprise context. Because in the case of the first, it is natural to include versioning in the domain entities. A version is a domain entity in itself in that case. However, in the case of the latter, versioning is only a technical feature, which means that the domain entities shouldn't have to know anything about it and that the logic implementing the versioning should be in the application layer, such as a concrete repository implementation, or preferably in the actual storage engine even, but definitely not in the domain layer.
It's a very similar and you are right. Only thing different here is that you do not store deltas but the full state in the version. So you do not have to recalculate the whole object (if you do not cache it) to see the current state. You can solve the same problem with event sourcing, but that technique is a bit more complex, so I choose to show it like this.
Interesting project to play around with it. But this two languages have differences in so many levels, i can't see this can be used anywhere, except to learn something new and fresh.
Why would he use browser supported web sockets? He can work with sockets on backend.
Empty repo?
[Ratchet](http://socketo.me/) might be interesting for you. It's a minimalist library, it's easy to get up-and-running, and I have yet to see it crash.
And having to configure it is not a big deal imo - in most cases I end up configuring the container regardless of autowiring support, because my classes depend on interfaces and no container can magically guess which concrete class is the correct implementor of the required interface.
The lack of /n makes me hurt inside :(
Do you guys know a website like this one, but better? https://www.phpclasses.org/ 
Another quality post from India.
Please stop your spam
It's not only my opinion. Don't forget that Fabien has been looking for new Silex maintainers for some months now. See https://twitter.com/fabpot/status/806157852628963328 And look at the repository activity: https://github.com/silexphp/Silex/commits/master If you exclude typos, code syntax issues and compatibility with Symfony deprecations ... there's almost nothing there.
&gt; The CRUD building is user interfaces to database, as they permit users to create, view, modify &amp; alter data. It works on entities in databases &amp; manipulates these entities. Any easy database table enforces CRUD restriction. Has Anyone Really Been Far Even as Decided to Use Even Go Want to do Look More Like?
https://github.com/h2non/imaginary is an awesome project, we didn't compare it yet to ours, soon will do. Regarding the concurrency and performance, Flyimg generates once the image and cache it, we did a benchmark based on that we got very good results. One problem with concurrency is requesting the same image with refresh option, currently, it generates many errors because it tries to write the same file at the same time by many processes. In our roadmap, we will try to benchmark it with AWS where many instances are created based on traffic load (Elastic beanstalk+s3). 
Ever heard of GWT? 
https://youtrack.jetbrains.com/issue/IDEA-175658
Your question boils down to "Why can't I do function overloading?" and the answer is "Because it's not been implemented in PHP"
The code is not 'logically right' if you give it more than a few seconds of thought. Take the following implementation of your example code. function map(AbstractMapper $mapper, ActiveRecordBase $object) { return $mapper-&gt;objectToArray($object); } $mapper = new ExactMapper(); $object = new class extends ActiveRecordBase { }; $result = map($mapper, $object); This code should work, and will work with the way PHP currently operates but would fail if the code worked the way you seem to want it to as you are breaking the contract of the interface. If you want a more specific method signature, you can use another interface like you are trying to do but define a more specific method that does not conflict with other interfaces. interface ExactMapper { public function productToArray(Product $object); } function mapProduct(ExactMapper $mapper, Product $object) { return $mapper-&gt;productToArray($object); } 
Well you're right, I guess
I think most of the site is built with React which is a fair reason as to why they're using it. You are right though, it doesn't really need to be a SPA.
&gt; index limitation of 768 bytes If you're using innodb (and you should be!), fix this by turning on innodb_large_prefix; your limit is then 3072 bytes (768 characters using utf8mb4). This is enabled by default on MYSQL 5.7.7 
The same way async/await are translated by Babel from JS with async/await to JS without async/await. Which is a form of "continuation-passing style" transform that is made simpler by generators (which PHP supports). Everything can be translated, that's not the issue.
I like Voyager (using it on a production app atm), but the docs leave much to be desired. I feel like I'm fumbling around in the dark with a lot of what I want to do. I'm most likely going to switch entirely over to Laracogs.
You've been banned from /r/leagueoflegends :P
-&gt; https://www.reddit.com/r/PHPhelp/ Aside: Why would you do that? You're certainly on the wrong path. 
Not exactly, but you can do something similar with [str_repeat()](http://php.net/str_repeat) or [array_fill()](http://php.net/array_fill), then trim() or implode() the result similar to what you're doing now.
Because it allows us to adjust privileges for different users without having to create a table inside our database with a bunch of users. We will be using multiple databases with multiple applications. This is a request from higher up, I would much prefer a simple login.
For DB query building, there are a bunch of libraries you might want to consider instead of "rolling your own" this way. &gt; but don't know how to multiply an array structure like `[?]` by an array count. If you mean the equivalent to `["?"] * len(data.keys())`, perhaps : $placeholders = array_fill(0, count($values) , "?"); 
There are some potential security/stability issues with your code: - Don't use "strip_tags" on people's content, instead encode text as HTML on output via htmlentities(), or html_special_chars() - You should validate $cols as SQL identifiers, or escape special chars in them (anything non-alphanumeric) and wrap them in identifier quotes (for MySQL, that's backticks).
I always took the call for maintainers by Fabien as he didn't want to maintain the project himself anymore for any reason, like he wants to focus on something else. Similar thing has happened for (for example) https://github.com/FriendsOfPHP/PHP-CS-Fixer and that project didn't die, it has seen many new releases and its user base has become bigger over time. The lack of new features for Silex makes sense to me as well. Silex has been scoped for what it is and as it is a micro framework it makes sense to me that at some point it is more or less complete. After that bug fixes, docs, CS and optimizing for new PHP features are to be expected. Other point of lacking more changes lately is that is not maintained very active IMHO. Therefor I hope new maintainer(s) will be approved by Fabien and we can happily keep using Silex and improving it. Some people suggest that SF 4 would be a good replacement, but this is biased to use cases. I use Silex a lot for embedded system where cycles, diskspace and bandwidth are scarce. Silex does out perform SF4 (and also the micro kernel SF release) for my projects. Secondly the learning curve for non-web developers of Silex is way lower than SF4. That is not to state I think SF is not good in anyway, I'm saying both projects have there place in the PHP ecosystem. All in all I think its not a nice thing to call something dead when people still try to help out to maintain the project and keep it alive. Calling the updates "almost nothing" might be true to you, but the authors put time and effort it in and the end users do appreciate the (little) tweaks as these improve their projects. I didn't get all of your slides because of the language, but I think you could have a made good case and get people excited for what SF4 is going to bring without calling Silex dead.
&gt; just read a lot and try to understand why people write the subject Where do you find "what" to read? &gt; You never know if a decision is the correct one. You learn that in the future. Point taken. Thank you. I'll keep trying.
Yep, that was exactly what I was looking for. I usually use libraries for serious work, this is just for a small blog I maintain just for fun and learning. What I've done until now works, except that the prepared statement execution (`sth-&gt;execute`) doesn't work with DateTime values for some reason. I want the `created_at` value to be a "proper date", so I did this: "created_at"=&gt;date_create($post-&gt;created_at), But then, I get this on query execution: PHP Catchable fatal error: Object of class DateTime could not be converted to string in /import_disqus.php on line 75 Catchable fatal error: Object of class DateTime could not be converted to string in /import_disqus.php on line 75 Is this a limitation of PDO? The Python (sqlite3 library at least) used to work with dates.
But if it somehow is sent to a user legally accessing your site (say by broken link)?
&gt; Don't use "strip_tags" on people's content, instead encode text as HTML on output via htmlentities(), or html_special_chars() &gt; This is just a migration script I'm using to fetch comments on my blog (as I'm planning to get rid of disqus and do my own comment hosting). And this is not user input, but `$post` elements are the already existing comments that I'm reading from the disqus xml. This is not the "actual" php page that handles the user comments, on that actual page I'm doing the proper input sanitation: $url = htmlspecialchars($_POST["url"]); $body = htmlspecialchars($_POST["body"]); $name = htmlspecialchars($_POST["name"]); $email = htmlspecialchars($_POST["email"]); $website = htmlspecialchars($_POST["website"]); $captchaCode = htmlspecialchars($_POST["captcha-code"]); //$created_at = htmlspecialchars($_POST["created_at"]); //error_log("session_phrase: ". $_SESSION['phrase']); //error_log("input_phrase: ". $captchaCode['phrase']); $phrase = $_SESSION['phrase']; $phrase_created = $_SESSION['phrase_created']; $diff = (mktime() - $phrase_created); if ($diff &gt;= 120) { //seconds header('Location: //' . $url . '#frmcomment?error=' . htmlentities("Captcha timed out.")); exit; } else if ($captchaCode !== $phrase) { header('Location: //' . $url . '#frmcomment?error=' . htmlentities("Invalid Captcha.")); exit; } 
and I don't agree its dead and I never stated something about `disappear`
It's a PDO-limitation, yeah. You'll need to do your own conversion of a `DateTime` to a string appropriate for whatever SQL database happens to be on the other end, ex: $pattern = "Y-m-d H:i:s"; $dt_as_sql_string = $dt-&gt;format($pattern); Basically `DateTime` doesn't have a `__toString()` method (equivalent to `__str__()` in Python.) I'm guessing the creators felt that they weren't ready to bless any particular representation (or calendar) as "the one true default that works with everything". Side note: There's also `DateTimeImmutable` if you want to code defensively.
The Management are idiots. I certainly smell a Goldberg machine in the making and chances are good you don't know why this has been mandated but its almost certainly coming from ignorance. Something like "but databases are always getting hacked"/" I just read about injection attacks"/"databases are slow" Or in other words a nontechnical person is making technical decisions they don't understand Or Some technical requirement exists here that is the hidden whammy. If I had to guess its that the boss wants single sign on on style authentication which would make this a [classic x y problem](http://xyproblem.info/) since you probably don't know what the problem is you cant solve it in a conventional fashion, you're just left with a half baked maintenance nightmare. Just hope that you are out of there before the house of cards collapses under technical debt. WordPress and Drupal have handled this sort of thing for some time. Its a multisite where the admin backend controls control with a user based acl.
The name, blegh. I never had a problem using it as a container though.
You could do this by having the credentials stored in the session, and your DB class could access them each time the script is run. That being said, its a terrible idea that has a huge risk of breach as your credentials are now essentially in plain text in your session store. Application users should not be database users.
&gt; classic x y problem I didn't know this had a name. I'd just gotten to the point where people would ask me how to do something at work, and if it sounded off the wall, i'd ask them what they are really trying to do.
Just because you can do something doesn't mean is should be done. Lots of great points above my comment. I just wanted to agree with other commenters and say don't bury yourself in technical debt that can not be paid later. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
It's simply not as good as a compiled container in Symfony imo.
FYI, you can have more than just the domain name in `site:` like so: https://www.google.com/search?q=chat+site%3Areddit.com%2Fr%2Fphp
I respect your opinion, but that's not the same thing as calling pimple "really awful". I think Symfony's DI container is a fine choice, and Laravel's. I just prefer Pimple. It's the fact that he thinks it's really awful that I'm surprised about, rather than the fact that his preferences lie elsewhere. If you also think Pimple is awful then I'd be curious as to why.
Why not use something like phpmyadmin? Or, you try to find hot water, just use mysqli_connect() with root (or user with grant all privilegues) and validate from table mysql.user, then use `show grants for 'user'@'host'` command. 
Another suggestion: https://github.com/rdlowrey/auryn
Always a smart thing to do. I've found that following up with questions like this tends to lead to good outcomes. The person is usually receptive to doing things differently, especially after having the underlying need understood and validated. It's also possible, though unlikely, that the seemingly off-the-wall request suddenly makes a lot more sense as-is.
Shameless plug: https://github.com/opulencephp/ioc. No dependencies, intuitive syntax, and it comes with "bootstrappers" to bind entire modules to the DI container. Those bootstrappers can be lazily loaded so that they're only run when their bindings are needed. Here's some documentation and examples: https://www.opulencephp.com/docs/1.0/ioc-container#basic-usage
I only have some experience with League's container, so I can't directly compare. It was pretty straight forward to use. I enjoyed the service provider functionality, as someone with a lot of Laravel history. Note that auto-wiring is disabled by default, however it's trivial to enable, just check the docs. They're both capable containers, with slightly different APIs and feature sets. One container might be easier to implement than another, depending on how you're currently registering services.
Say you want to replace event sourcing with this. How would you for example store the author of a change?
Laravel Backpack is great as well for CRUD admin sections
I used league in a project I made and found it to be pretty awesome actually. Easy to implement too.
The Symfony container now supports autowiring though it is still a bit of a work in progress. https://symfony.com/doc/current/service_container/3.3-di-changes.html Personally I have not come across a definitive use case for such functionality. Manual wiring takes little time and reduces the amount of magic your code does. 
A link would help
Maybe you didn't read my comment carefully. I was talking about linux subsystem on windows, not windows itself and not linux itself.
[removed]
Oops, sorry. Application: http://github.com/fondbot/fondbot Framework: http://github.com/fondbot/framework
im a 3rd year computing science ive gotten quite comfortable with procedural PHP, are there many professional programmers the code in the procedural was or its it all Object Orientated ? should i make the jump to the OO was of doing things
woocommerce has an option for downloadable products out of the box. there are also several support ticket plugins available, some good ones can be found on codecanyon.
That's true, but on windows, he's encounering this: https://stackoverflow.com/questions/11663860/mysql-connect-localhost-127-0-0-1-slow-on-windows-platform
https://stackoverflow.com/questions/11663860/mysql-connect-localhost-127-0-0-1-slow-on-windows-platform
https://stackoverflow.com/questions/11663860/mysql-connect-localhost-127-0-0-1-slow-on-windows-platform
No, function overloading is something entirely different. OP wants covariance, which PHP does not support (which is good since it would go against the LSP).
&gt; Where do you find "what" to read? Look up popular PHP projects on GitHub and read the code to get some ideas 
&gt; should i make the jump to the OO was of doing things Yes - if you want to get into developing software for business 
Great idea. In the mean time, I've started looking into the top posts from some of the subreddits that I'm on.
I've used and enjoyed [auryn](https://github.com/rdlowrey/auryn), which seems to meet your requirements. That being said, PHP-DI looks about as good to me.
Autowiring isn't "more robust", it's more automated, but less robust (because it just blindly sends the first type match, which isn't always what you intend). As long as you understand that, I wish you all the luck with your new DI container. But people should understand that autowiring is a nasty hack targeted at saving you a few lines of code, and takes away control of injection from you. It's more error-prone, it's also *slower* (due to the use of reflection), so it's not an overall improvement. I've heard architects describe autowiring like this: "if you need autowiring, it's a symptom there's a problem with your architecture. It's too flat, there are too many heterogeneous components directly hooked to the environment, needing dependencies". I don't need autowiring, for ex., because I split my app in modules, and I try to standardize dependency contracts through interfaces (i.e. I may have hundreds of controllers, but they follow one of a less than a dozen specific interfaces for receiving dependencies, hence I don't need autowiring).
Thank you for your efforts /u/sarciszewski and thank you to the internals team for pushing this forward. A big win for the PHP community!
This really is just great news. Very well done.
Dice is also nice: https://github.com/Level-2/Dice
How easy is it to modify?
osCommerce is super old at this point. If I were to guess it's going to have a lot of stuff patched on to the side of it. Luckily the system is relatively simple compared to other more modern commerce systems (i.e. Magento) There will be some pain but it should be pretty manageable 
Last question, if you don't mind me asking, what do you think a gig managing an installation should pay? Legacy work is rarely fun, and I get the impression they are going to want more than it can do easily.
Not good. I worked on it about 7 years ago, there was no joy in it. But, Magento is also bad if you are thinking about going that route. OS Commerce is like they didn't even try and make good looking software and you can tell by using it and working in it. Magento is like they tried, tried really really hard, but they just didn't have a clue and ended up making a convoluted giant (and I do mean giant) piece of garbage. Basically every attempt at a shopping cart both open source, closed source, and home brew has been a titanic piece of garbage when written in PHP. I've worked with Magento, OSC, XCart, and two home-brew solutions. All sucked. If starting from scratch I'd look at shopify versus writing my own. If I was asked to work on an OSC site I'd need $200 per hour. Thats how much money I would need to swallow that turd sandwich again. Magento would be $250 per hour.
Great work!
Hence why I was careful to say "potential" :-) I'm still not quite sure throwing away HTML content like this is a great way to migrate, but that's up to you. What about $cols?
If we had function overloading, OP's ExactMapper interface would have 2 methods named 'productToArray'. Implementing classes would have to write both, but it would work.
OO but with a smart sense in how to use it. Sometimes things are just attributes of a class, and not a class itself. Read about the KISS principle, then you know what I mean ;-)
So it seems that configuring Apache is the best solution. I've seen too many issues with IP addresses instead of hostnames.
I was hoping you had it build more like a conversational bot (like an Eliza variant). The should be more tests on the bot side ;-) I also wonder why you made a framework of your own, instead of using a micro-framework and put all other stuff o top of that.
I have used http://php-di.org in a couple of projects and am very happy with it, a lot better then most of the DI I had to deal with from various frameworks.
Not the way to go. What if you have a lot of users? For each user, you have to administer it in the database :-( Make a role, like reader, writer (and stuff like that) Look the user up via the reader_user connection you have standard. Then, if the user has a higher role, switch the connection the (example) writer_user. Far more easy to maintain withthe same goals. Better read about access control list (ACL) where all of the stuff can be handled.
Yikes. Their API is so simple that I would never think of needing a wrapper. Just run a json_decode(file_get_contents()) and be done with it.
If the DiC let's you take back control whenever you want, there was no control you lost to begin with. Any DiC worth its salt will let you set aliases against an interface (eg: a `Monolog\Logger` instance for a `Psr\LoggerInterface` interface). After that you can let the auto-wiring take over. If for a class you need a different instance, configure a factory for that class. Features of Auto-wiring DiCs include features of Non-auto-wiring Dics. Only downside is speed which can be addressed when the time comes.
What happens to password_hash()? https://paragonie.com/blog/2017/06/libsodium-quick-reference-quick-comparison-similar-functions-and-which-one-use advices to use sodium functions. What is the current best practica?
For tickets and live chat, you can always use tawk.to. It's great.
One does not "build" anything here. It's merely configuration and getting a ready-for-use application running on a server. That's lovely and all, but the title is misleading.
Thanks for your feedback. There will be helpers for testing bots like `assertIntentActivatesOn`, `assertBotReplies` and so on. I did not use any of micro-frameworks because I did not want anyone to complain about it. So I decided to use widely used components from League, Symdony and so on. 
Are you even aware what web sockets are? https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API &gt; WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply. How are the users of the chat system going to receive any data unless their browsers support web sockets? Of course he will work with sockets on the backend... but you need something to consume them. Otherwise your work is pointless.
You would have to store it relative to the session somehow, which either involves having a DB and table that you connect to first to get the user-related credentials which you seem to be trying to avoid, or having the DB credentials in the session (as noted by other comments). Whatever route you take, it sounds crazy - so talk to the people asking for it, get their reasoning behind the request before you start putting fingers to keyboard. As a developer, it is not your job to just follow orders, your job is to find the best approach and solution to a problem, if that includes telling them that you need to handle permissions within code rather than at the database level then that's what you have to do. Besides - if you're planning to restrict access to create/update/delete/etc. based on DB user, isn't that going to cause a bunch of fatal errors to appear when your users try and click a button that they don't have access on the DB to do? And if that's the case, you're going to need to restrict access to the buttons on the frontend in code by user anyway.... so you'll be most of the way there.
PHP 7.2 adds support for Argon2i in password_hash(), which is the same algorithm that libsodium uses, so it should be just as good as using Sodium pwhash. It won't be the default algorithm in password_hash though; you'd have to set it manually.
Technology for chat existed long before browser got web socket api support.
However, you are perfectly fine using the default hashing algorithm. Basically as long as you use one of argon, bcrypt or pbkdf2, you're doing good and choosing one of them over another makes very little difference.
What if I want to use different implementations of the same interface in various use cases (polymorphism)? How do I know which autowired component is used in particular use case? Is there any other option than going after typehint breadcrumbs?
next step : **recycling dom** for real infinite scrolling...
Speed is actually not the only downside. This is merely the most trivial, and therefore easy to identify issue. Far more sinister and harmful is the effect an autowiring container has on your architecture. In **theory** you would be writing your components the same as if there is no container, and everything is instantiated manually. That's in theory. But in **practice**, using autowiring container gradually, slowly distorts and erodes your architecture in many ways: - You become averse to designing objects that take in non-object constructor arguments, because it means you can't autowire them. In many cases, taking in string/boolean/number/array arguments for some object options is the best choice, but you can't autowire it, so out the window it goes, as it becomes inconvenient. - You start creating "tag" interfaces and classes - empty classes and interface, whose only purpose is to differentiate two different instances of the same class/interface. Why? Because the container can't tell them apart otherwise, and you'd have to write lots of factories manually. This has the effect of subtly coupling your objects to your environment as they ask for tag interfaces and not for the most generic interface they can ask for. The annotation alternative, @Qualifier, has the same negative effects as tag interfaces. - You start building components as if everything has access to everything - just add it to your constructor, and you get it. Autowiring magic! Thus one of the key benefits of DI, which is outside control of who gets what, is given back to the objects. The objects decide what they want, and they get it. No contracts or interfaces to follow. The constructor arguments become the new `StaticRegistry::get('thing')`. - You become accustomed to having "one of everything" because that's the easiest thing for an autowiring container. Thus you miss countless opportunities to reuse code where the same class can fulfill multiple roles by having different instances (of the same class) wired differently. Autowiring containers can't do that, so that also goes in the trash. So, it's not just what autowiring containers do. It's what they make *you* do. You and your colleagues, whose code you have to deal with. Because with manual DI, if a template asks for an SQL connection, the architect who's wiring the app will see that and deny the foolish template writer access to it. But autowiring containers? Heck, that template has some SQL queries to run, get out the way!
&gt; I was talking about linux subsystem on windows Yes thats what I was replying to
Yes, but the OP was asking about a web based chat system... so of course a web browser needs to be involved!
So if you want to call it in multiple places use that one line everywhere? What if you need to change your forecast API service later? Do you search in the code for those one line of code and replace it?
Make factories for particular cases, wire your dependencies manually, you know... think about it. With auto-wiring you think about it when you need, without it you think about it all the time. Whatever floats your boat.
&gt; Because with manual DI, if a template asks for an SQL connection, the architect who's wiring the app will see that and deny the foolish template writer access to it. But autowiring containers? Heck, that template has some SQL queries to run, get out the way! Good point. At my last job there was a guy in charge with the architecture who's sole job was to review the application dependencies. Once he took 10% off my salary for using `LoggerAwareInterface` and adding a `LoggerAwareDecorater` to the DiC.
If you're into reading books. Check the book list under caregory PHP here: http://www.phpdevbooks.com/p/suggested-reading-order.html
&gt; phpcd How does that compare with php-language-server.php?
fzf - the best thing since sliced bread. Much superior to ctrl+p in my opinion.
&gt; autowiring is a nasty hack targeted at saving you a few lines of code, and takes away control of injection from you. It's more error-prone, it's also slower (due to the use of reflection), so it's not an overall improvement. &gt; I've heard architects describe autowiring like this: "if you need autowiring, it's a symptom there's a problem with your architecture. It's too flat, there are too many heterogeneous components directly hooked to the environment, needing Interfaces are never "auto-wired", you always have to define an alias for interfaces.
I already use ale for golang development (on neovim).. Php language server is what I think I need.. I don't even need IDE stuffs, nvim has a great terminal (which I spend most of my time in anyways).. I ujust need basic code completion. Thanks
Well, they're still auto-wired, because you link one class to one interface, and a gazillion objects suddenly receive an instance of that class. What the parent poster is asking "what if I have multiple instances of the same interface". And the answer is auto-wiring falls apart right there. And the irony is that "I have multiple instances of the same interface" should be the default assumption in any sane architecture. So auto-wiring is then for the cases of insane architecture.
&gt; With auto-wiring you think about it when you need, without it you think about it all the time. I assume that by *all the time* you meant establishing composition, which goes in parallel to writing production code. The problem I see is that *when you need* has nasty tendency to take much more time than *all the time*, because decoding the structure happens more often than encoding it (reading vs writing code), and auto-wired structures are painful to decode. The argunment is actually quite similar to tests vs debugging when you think about it (including problems with TDD on poorly established stuctures). I don't mind DI containers, I like them and use them (for library modules, but it's just a preference), but **auto-wire is as evil as writing unreadable code**.
I can't change the title of this post, but "order tracker" might not be the best phrase. It is just a library for scheduling dependent task execution. I tidied the readme and updated it with a section on how it works if anyone is interested.
I ignore it. For the most part they don't know what they're talking about. When I do, from time-to-time, choose to engage with these folks it becomes rapidly clear that they're unqualified to hold an opinion on this topic.
That's no different from if you didn't have auto-wiring: you alias an interface to a class name (that you would have to define a ~~factory~~ service definition for with no auto-wiring), and then everywhere where you requested for that interface name, you'd get that implementation class instance. Okay, how would you have multiple instances of the same interfaces without auto-wiring, and how would you manage them without auto-wiring? Because you'd probably do the same with auto-wiring: ~~define factories~~ create service definitions for them to fine-tune the construction behavior.
1. Tell them "you're talking PHP3/4, I'm doing PHP5.4+/7" 2. Start ignoring them before they can even answer to 1. 3. Be happycat :-)
PHP Dependency Injection Container Performance Benchmarks https://www.sitepoint.com/php-dependency-injection-container-performance-benchmarks/ In the lasts months I've testet league/container, auryn, symfony/dependency-injection and PHP-DI. Without caching the performance is not very good. Today I use pimple in combination with a factory. Please take a look at the slim framework. Example: https://github.com/slimphp/Slim-Skeleton/blob/master/src/dependencies.php 
Let's take an example. You have some classes that required a dependecy on `Psr\LoggerInterface`. Your application uses `Monolog\Logger` which implements said interface. Now, any decent DiC will allow you something like this // set an alias $ioc-&gt;setAlias('Psr\LoggerInterface', 'Monolog\Logger'); // set a factory for that class $ioc-&gt;define('Monolog\Logger', $someFactory, true /* make it a shared instance, optional */); If I have 100 classes that depend on the `Psr\LoggerInterface` without auto-wiring I have to write 100 factories. With auto-wiring I only have to write factories when the default implementation is not what I actually want. 
&gt; I have multiple instances of the same interface" should be the default assumption in any sane architecture. One amusing workflow is to start with one instance. Everything autowires and life is good. Then, a few months later, some jolly joker adds a second instance. Hilarity ensues.
I don't know - I'd actually never heard of php-language-server until /u/Firehed's comment below. Phpcd is a complete vim omnicomplete plugin so is an all-in-one solution - but I prefer the idea of separating the editor concern and the language concern. Is there a vim language server plugin you can recommend? I'll give them both a try side-by-side, but I'm mostly finding nvim plugins.
Because, a service definition is a factory. So yes, you have to define different services for each instance type, but there is certainly no need to make specialized factory classes.
I often answer by [JavaScript|C|C++|Python|Ruby] hate. Most of them will compare with any of those languages. There's a lot to troll about. You may use as counter-arguments: * for JavaScript: pretty much everything, it's the worst designed language of all; * for Python: slowliness, duck typing, monkey patching, unsafe code, nothing is statically typed; * for Ruby: a lot of Python applies, and it has some own weirdness; * for C: language ambiguities, various compiler undefined behaviours, easiness of creating memory unsafety security issues and corruption; * for C++: very good language, but sadly the most complicated one that exists, it's pretty much impossible to masterize it (the 2017 revision brings 1500+ additional pages to the complete spec, which we can't count in pages anymore since a long time). 
Autowiring should be really considered as Anti-pattern, same as Service Locator really. Especially in php which most(all?) of those autowiring containers use heavy reflection api which will just slow down your app. To be honest i even like more service locator than autowiring.
I just laugh at all the haters, considering they're at least ten years behind in technical knowledge and they're missing out on some excellent market opportunities.
Object oriented is by far the most dominant programming paradigm in the professional PHP world. To get more into object oriented programming, read up on design principles like SOLID, on design patterns like those presented by the Gang of Four and Martin Fowler, on implementation approaches like Domain Driven Design, and on architectural models like Hexagonal. This will provide you with the most used object oriented programming theories en methodologies in enterprise projects.
/r/programming and Meetups
I just posted [this](https://www.reddit.com/r/PHP/comments/6mb7o2/php_weekly_discussion_july/dk5vnch/), maybe it helps!
ty. So perhaps look for online tutorials on small projects and go from there? I mean, to build something I need to know where to begin. I have always intended on following a path similar to the one you have suggested. TY for laying it out so clearly:) 
PHP is not special in being hated. Let's say you had decided you wanted to move from PHP to some other language for web development that was hated less, what could that be? Not Java or C#, too corporatey. Not node.js, because it is [one of the worst things to happen to the software industry](http://harmful.cat-v.org/software/node.js), according to some. Not Rails, because [it is yesterday's software](https://medium.com/@deathdisco/today-i-accept-that-rails-is-yesterday-s-software-b5af35c9af39), according to others. Not go, because [it sucks](https://kaushalsubedi.com/blog/2015/11/10/golang-sucks-heres-why/). Not Python, because [it has problems](http://xahlee.info/comp/python_problems.html). Not even going obscure will save you, because [haskell is a complete joke](https://www.quora.com/Functional-Programming/Which-of-Haskell-and-OCaml-is-more-practical/answer/Jon-Harrop-2?srid=OsrX&amp;share=1) when it comes to practicality. The truth is, any and every actual programming language is going to get its share of haters. This is unavoidable. The trick is not to care as long as you're getting things done. 
TY - I have had SAMS Teach yourself PHP in 24 hourssitting here for agessss meaning to start. Will check the books:)
I suggest an experiment - measure the time it takes to complete each step: * (A) Draw pseudo class diagram for use case composed with recursively resolved aliases (not from memory - you need to see where the aliased interface is required). * (B) Write a factory for it. * (C) Give this factory (B) to random junior dev and let him write class diagram. Assuming that auto-wiring takes no time at all, and you'll need to recreate this structure only once, the time you've saved would be expressed as: `T = (B) + (C) - (A)`. I'm saying `T` is still less than 0.
Wow great list! TY
I develop in Phpstorm and run in custom Docker containers with compose. In dev, the local source is mounted into the container so live changes are done. In prod, I tar the container, scp it over and bring it up there.
[It's really hard for me.](https://media.giphy.com/media/94EQmVHkveNck/giphy.gif)
Docker dev environment &gt; Bitbucket pipelines &gt; Deployer (testing AWS CodeDeploy now) It's definitely a work in progress and it's taken me a about a year to get a decent amount of tests built up and the application slimmed down to that a new deploy/setup is pretty painless. CodeDeploy works pretty well, although I've been wondering how some others (Ansible, etc) compare. So far I've gotten the CI process covered (just need more tests!), I really want to get a automated CD process in place. Or at least something like a one click deploy. Deployer works good, but I need something that adds a degree of separation between the person deploying and the production servers. 
haha I signed up, I looked at the first one. I have little hope but I will try. Mind if I hu up for advice?
The ideal workflow? Probably a voice interface. *Ok Zend, write a php management tool for my local sports league. Great. Now deploy.* Not quite there yet.
Bizarre to me that 2 separate people say use Docker for dev, but not production. Seems to be missing the point. 
Yep. Go write your blogs about fractals of bad design. Enjoy that. I'll enjoy reading them while relaxing on my boat. 
Yeah dude no problem.
You have 100 factories to write and 100 to give to a random junior dev. Is T still less than 0? Le't say your app has 100 routes and you have one route handler class (controller, whatever you wanna call it) PER route. Each route handler class needs the LoggerInterface because... potatos. How do you handle this scenario?
I just hate PHP too - it's that simple.
Precisely. There's theoretical gains here and choosing Argon2 does slow attacks down even with new hardware, but the real vulnerability is *not choosing a password hashing algorithm at all*. Which is still common (`md5(md5($password) . md5($salt))` is an ugly wart that won't go away ), but less so with each passing day.
I love FastRoute but it's nice to see an alternative that's just as fast. I will have to try this. Just one thing, I prefer to use invokable classes as controllers. It would be nice to see a method like `toInvokableClass(MyController::class)` so I wouldn't have to use `toMethod(MyController::class, '__invoke')` on every single one.
Most of the time, these people have never programmed in the language or haven't touched it in 12+ years.
What the fuck? No. I laugh and move on and watch money flow into my bank account. 
I only use nvim and I can't really recommend anything since I haven't had the time to get it to work properly with my legacy codebase.
There's no such thing as "aliasing interfaces to classes" with manual DI. I make a factory method, I name it according to *its purpose*, which is often *not just "it implements that interface"*, and then I call the right method everywhere. For example if I have two database connections, I'd call the methods `getJobServerSqlConnection()` and `getBlogSqlConnection()`, but they implement the same interface. There's no such "1 interface = 1 class" restriction going on here. It's methods. Why this doesn't work well with auto-wiring: - You alias interfaces, so if you use the same interface for multiple purposes, via different classes (or same class, different configuration) you need to use tag interfaces or qualifiers (which I already mentioned). - Projects that use autowiring have an uncontrolled proliferation of arbitrary heterogenous constructor contracts, because when you autowire, it's very easy to mess around and tweak controllers signatures on a whim, and not feel the pain of the giant mess you're making. This means if you have to write a factory for some subset of your objects, like you propose, suddenly you have hundreds of factory methods to write, at which point you say "nah, I'll just change (i.e. compromise ) my architecture and keep auto-wiring". The reason why I don't end up with hundreds of factories without auto-wiring is because, as I already mentioned again, without autowiring I'm forced to think about the architecture of my project, and the construction/method contracts I fulfill. So I keep them in check. I don't have every controller ask for arbitrary things in arbitrary order. Instead it implements one from a small set of interfaces, and the injection logic satisfies this small set of interfaces. So in a nutshell, if you start auto-wiring, you play by the rules of auto-wiring or you end up writing hundreds of factories. This causes architectural compromises so you can stay on the auto-wiring rails. While without auto-wiring, you keep your project well-structured, and you have a few dozen of factories (at most) to satisfy in your composition root, which makes it easy to change and control who gets what.
I never said you have to make *factory classes*. There's some misunderstanding.
Just by saying "100 factories you write" you admit your project suffers from the problem I mentioned initially (an overly flat structure of interdependent heterogenous constructor contracts, a.k.a. spaghetti code). As I said, needing auto-wiring is a symptom of an architectural problem. Auto-wiring seems to alleviate the pain, but it doesn't fix the underlying issue. It's just a painkiller pill, that lets you keep doing the mistakes you've already been doing for a little while longer. In no well-organized project would the composition root deal with 100+ objects. It would be constructing higher-level modules, which then take over and deliver some of those dependencies to their internal objects (which the composition root no longer has to worry about). Think about your composition root as a team manager. A manager can manage 5-10, maybe 20-30 people. When you give a single manager 100+ people to manage, they can't do their job. So they reach for automation and say "I can't talk to each of those people individually, my job would be impossible! I'll delegate to software automation for dealing with my subordinates!". The manager has a problem, but the problem is poor company structure, not lack of automation.
Maybe it is just the first step with learning to get comfortable with it and haven't gotten that far yet?
You're making assumptions about how auto-wiring is used. With non-autowiring, you can handle interfaces either by creating a default implementation by aliasing the interface to an implementation, or you never do that and rather for each class that uses that interface, you manually provide the implementation that should be used. Likewise with auto-wiring, you can either create an alias for interface's implementation, or you can not create an alias and rather manually create a ~~factory~~ servce definition for each class that uses the interface to tell it which implementation to use. Since auto-wiring can't possibly know how to instantiate an interface without a definition, any auto-wiring instantiation attempt involving a class using such an interface without a definition will fail. So in the end it's all the same.
I was responding to @amcsi's comment. He/she/other seems to feel that you need factories for manual configuration.
great! so in between do you use any dubuggers to dubug and test your code? 
so what's your take on it? what will be the best practice with docker here?
stupid spam bot 
There's no such thing as "aliasing" in non-autowiring DI. It's just passing arguments to constructors and methods, that's it. So when you say "it's all the same" and you use auto-wiring terminology to describe non-autowiring DI, I really have no idea what you're talking about.
Thanks! I used deployer once for my project it works well, wondering that docker is widely used for dev environments
Yes there is aliasing, it's not not enough; you also need to define the implementation class factories as well for non-autowiring. Or you can define the implementation factory class for the implementation class on the interface definition as well; whatever you like to do better.
Same applies to non-autowiring if someone made a definition for the implementation on the interface instance.
Create much better projects in the "worst programming language of all time" than all the cool kids doing [insert hyped language here].
The best answer.
There are some containers which encourage naming a container object after the interface it implements. That's harmful, and leads to some of the effects I described for auto-wiring. Objects (in containers, or otherwise) should be named after their concrete purpose to exist, not the interfaces they implement, or the types they represents. When you fetch an object from a container to pass to a constructor, you need to know what the purpose of that object is, not just blindly take something of interface Foo and pass it in, which I would qualify as "Hope-Oriented Programming".
I don't feel like you need to create factories. You don't have to take everything I say literally. I'm using Zend Framework 2 where you have to create factories if you want to define a service. I know there are other containers that are non-autowiring, but provide a configuration way of defining services (e.g. Symfony). It doesn't really matter, my point is the same.
You can easily do it on a php lamp satck with laravel framework , Vuejs and pusher for real time communication. Here is the nice tutorial I found on internet: https://www.cloudways.com/blog/realtime-chatroom-with-laravel-vuejs-pusher/
Great, some of our customers outright refuse to work with our hosting partners for a few pennies, some might not be supporting 7.2. password_hash() will at least be backwards-compatible. Do you know what happens if I would set it to argon on ie. PHP 5.6? Will it fall back on PASSWORD_DEFAULT or PASSWORD_BCRYPT?
Wouldn't using `__invoke()` restrict your controllers to only being able to handle a single endpoint?
100 routes, 100 route handlers, each having a dependency on a logger. Some have dependencies or a PDO, others to a image resize object, paypal client, S3 storage object so on and so forth. Heck... even if not all of them need the logger, without auto-wiring you still need to write 100 factories. Do you have a practical solution or just ivory-tower talk?
Well , Argon might be marginally better than Bcrypt, but it's more of a mentality thing really. Always choose the best security practices and algorithms available.
Yes, and that is why I use invokable classes. I prefer that each controller do a single thing.
PHPStorm development on a Windows 7(gief Windows 10 for WSL pls) Deploy to docker containers running on a development server Push to GitLab server(also running in a docker container) GitLab runs tests automatically when I push to the 'prod' branch GitLab spins up new docker containers using the same configuration as the development server but with production-like environment variables GitLab emails me with the results, if I set it up to it will also run a staging container so I can verify the app works in the browser Git pull the changes on the prod branch in a different directory(paranoid about dev stuff sneaking in so I keep this separate) Deploy with [Magallanes](http://magephp.com/) to docker containers on the production server Just to clarify/restate: All docker containers that the app runs in use the exact same configuration but different environmental variables.
The constant doesn't exist in 5.6, you'll want to use `PASSWORD_DEFAULT`.
Well for me, there was a pressing need to standardize the dev environment that could be easily shared and operated by new developers coming in. In the end, went with Docker due to how powerful its feature set is becoming and learning it opens up further options in the future with docker deployment, etc.
What's the benefit in having a single endpoint per controller? Isn't that going a little overboard with SRP? You wouldn't split up a "normal" class to only have a single public method, so why do that to your controllers? They certainly shouldn't be bloated with methods, but they should (IMO) at least contain endpoints for similar parts of your domain logic.
That's precisely why I said "aliasing", because I myself dislike the idea of defining the implementation directly. I'd rather indirectly do that with an alias. And if I'm not using auto-wiring, I'd have to also make a definition for the implementation. With your second paragraph, it is your opinion and there are upsides and downsides to each approach. There's no purpose to argue further.
Thank you for the suggestion, it's very clean and efficient solution, however, we created Flyimg to solve the main issue of image compression, we tried couple of algorithms (for jpeg) and we found the best and the fast was ImageMagick + Mozjpeg, it gives us very good images and the size was very small comparing to other tools. It also move the overhead of images manipulation to a specific service which contains also other options.
Yes I have a solution, and I already mentioned it. First of all, you seem to be putting business logic in your controllers, and that's already the "fat controller" problem. Business logic should be outsourced to service objects, which handles groups of related tasks independent of UI/delivery mechanism (GUI, JSON API, HTTP site, command-line etc.), instead of doing it scattershot around controllers, mixed with UI concerns. Then you need to identify groups of controllers that need the same access to services and other dependencies. Those groups of controllers should be separated in modules, where in a typical boring project you'll have modules like...: - AdminSite (handles all the admin UI on administering content, editing entities etc.) - PublicSite (displays all public pages of a site). Depending on the project, you may split each of those into modules as well, where it makes sense: - Blog - News section / articles - Documentation subsites - User dashboard / checkout / order / purchase experiences. Etc. So now what we have is those 100+ route handlers have become 4-5 modules, which contain their handlers, templates and so on. Each of those modules needs a specific subset of your Services to work with, which it passes to the controllers. You pass those when you construct the module, and I prefer to pass services "lazily" in the form of Context objects (you can look it up), which from the PoV of the module is a simple interface enumerating their dependencies and required settings, and from the PoV of the composition root, they're short and neat anonymous classes that implement said interfaces. My router doesn't dispatch handlers, it just returns the matching route (for an example of this, see FastRoute by Nikita Popov). Which means you can employ your own factory logic to build the handler. Which in our case means: 1. Instantiate the module the handler belongs to (one factory, one set of dependencies). 2. Call the module's -&gt;handle($handlerName, $request) and it takes over. 3. Done. In some projects I prefer the modules to have their own router, but that's subjective, and up to how you prefer to separate responsibilities. It may seem like "ivory-tower talk", but actually it works. And it works great, and I've never had to write hundreds of factories for route handlers, and I'm in full control about what each module has access to. I'd propose you start by eliminating business logic from controllers. You're essentially coupling UI logic (HTTP handling) to business logic (work with PDO connections, processing images etc.), and that's quite clearly an architectural mistake.
As long as Symfony is there, I will not worry about silex. 
Docker is still being adopted. It's not always a fast process to get devops or developers on board with adopting new processes. If a company has been running Ansible deploys the devops guys aren't going to be eager to move all of their services over just because the developers have started using docker.
And what are the downsides?
I listen to their points and see if they are saying anything legitimate. Which sometimes it can be. I hear them complaining about certain code that others wrote or they have seen and I agree that it's pretty bad. But I hold my code to high standards, make sure it's in classes, type hinted, namespaced, business logic and views are separated, controllers are small, everything is dependency injected everything is SOLID and DRY. I give them no reason so say my code is bad. I also realize when PHP is not the answer. PHP is great for API's and most normal sites. However PHP isn't great for queues, websockets and concurrency. Yes there are libraries to do all of that, however they are slower and require a lot more set up. For example in the same Go binary serving my API, I can have workers that can post-process all with simple code built into the language. If I were to do that in PHP, I'd have to set up RabbitMQ/Redis/SQS, then have another script constantly running that does the process, with something managing (like Supervisor) the workers since I'd need multiple ones as it's processing in serial not parallel. In the same place, PHP is also not great for creating large ETL pipelines where multiple processes have to run in parallel. tl;dr: there are uses for PHP and then there are places where PHP shouldn't be used. Also make sure your code is really solid before defending the language.
I'm also not a fan of docker when it comes to PHP. It's annoying creating different containers for Nginx, PHP-fpm and the app itself. I haven't gotten into ReactPHP too much, but that might make a different on how I feel.
I drink beer and don't listen :D
I'm still not sure I understand your point. I think we may be talking past each other. Suppose you had a regular expression validator class in which the expression to validate against is injected. So in Symfony I would have: services: reg_exp_validator_1: class: RegExpValidator arguments: ['exp1'] # this gets injected into the constructor reg_exp_validator_2: class: RegExpValidator arguments: ['exp2'] some_service_which_needs_exp1_validator: class: SomeService arguments: ['@reg_exp_validator_1'] The SomeService class just expects a RegExpValidatorInterface. Autowire would not be able to know which expression validator to inject unless you only had one. In which case, adding a second would cause problems. Using this manual approach I have never had problems with knowing exactly what is being injected into what. I suspect you are talking about a completely different use case.
&gt; My router doesn't dispatch handlers, it just returns the matching route (for an example of this, see FastRoute by Nikita Popov). Which means you can employ your own factory logic to build the handler. Which in our case means: &gt; Instantiate the module the handler belongs to (one factory, one set of dependencies). &gt; Call the module's -&gt;handle($handlerName, $request) and it takes over. &gt; Done. I do the same. Still the `$handlerName` is a an object... with dependencies. Somehow it has to be instanciated. An `AdminModule` for something like magento has 100s of possible `$handlerName`s. A CRUD for products, images, categories, discounts, promotions and bang... you have 20 handlers. So, without autowiring how does the factory code for the `AdminModule` looks like? Just because you organize everything in a hierarchical order doesn't mean the DiC definitions code magically simplifies. 