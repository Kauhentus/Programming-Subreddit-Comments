It's not about the lines of code. 1. Do you plan on using third party libraries? How will you import them? 2. How do you make sure that your code actually works? You can't properly unit test procedural code. 3. Do you plan on working with other people? Pretty much everyone is using Composer and OOP these days, at least for new projects. For very basic projects procedural code is absolutely fine but eventually you'll have to learn OOP. If so, why not do it now?
50 shades of Wordpress =)
I don't totally agree with your statement: "hiring perspective it's better to have more popular tools like laravel or symfony for example.". You choose Laravel and Symfony because they use the latest PHP features, the best standards. By knowing how to develop in these frameworks you prove that you know the latest PHP features, the latest technology trends.
There isn’t a direct answer to this. I’m 21, still studying at university and worked as a software developer for a year. I learned most of what I know of OOP from practical experience. Basically just coding, making mistakes and rectifying them. OOP is just a tool, an abstraction, to make software development in large projects easier and much better maintainable. Now I say OOP is an abstraction as it is just 1 of many that exist and it is probably the best known and most used one. Another example of a similar thing is Domain Driven Design, although this solves a different problem than OOP. I recommend reading about these things and try to use it in your projects. Getting good at these types of abstractions is what (in my experience) sets you apart as a good coder as it will be much easier for you when you have to design, code and maintain a big project. It can backfire as well though. I’ve seen plenty of projects where OOP caused the person to make a spaghetti of their code, but even then (in my opinion) OOP made the code easier to read and easier to change the code to something that did make sense.
It started as a CI (CodeInginter) fork, but now it's years of development difference between these frameworks.
Here's your answer: https://www.codeigniter.com/userguide3/general/urls.html#removing-the-index-php-file
OctoberCMS is built on Laravel and offer more features such as components. It's free and quite a mature CMS. This is what I'll recommend.
It's more about multi person teams in my opinion. Yes OOP can help a single user manage a large, complex code base, but in reality, that code will use libraries written by other people, and provide a service for people that aren't the original author. In PHP it's an interesting situation because nearly 100% of the PHP code that is used, is provided as source code (not compiled), and this lends itself to other people modifying it for their needs. Take the example of a procedural fruit script. You can define a bunch of functions like MakeApple() or MakeOrange(), and then more functions like EatApple() or EatOrange(), then decide that no, what you really need is a MakeFruit("apple") function that can take arguments. So you then make a new function EatFruit("apple") that can take arguments for the fruit as well. The return value might have even changed, so you update the code that uses MakeApple() to be able to handle MakeFruit("apple") or MakeFruit("orange"), and update the parts that use EatApple() to EatFruit("apple"). The problem here is not that you've done it wrong, with a series of functions in a procedural way, it's just that now you are approaching the program in an OOP method, and would save time by creating a Fruit class and extending/inheriting from there. The only differences between the two are the tools provided. In the real world, one of the main benefits of OOP tools, is allowing programmers to work on pieces in a modular fashion. Yes you can use includes with functions as procedural approach to modular programming, but you are still leaving out the rest of the OOP tools that will help. With OOP a programmer on a team can work on a class, another can work on an implementation of that class, and the specific code blocks won't be changed by 2 people at once. As well, a task can be easily described with a design doc or interface, and then this clearly defined work is assigned to a developer. 
*"A passionate story of vulnerabilities, exploits, penetration and plug ins. A must read."*
Need a job?
haha. I like it though, 50 shades of CI.
From your specification it sounds like Wordpress is a good fit. You can easily remove/disable/adapt the automatic thumbnail generation with a few lines of code. Custom content types are simple to create through plugins. Adding custom SEO data is straightforward to code yourself, assuming you don't want to go for something like yoast. Basic role management is pretty good in WP and if you need more exotic then that can be plugged in easily depending on requirements Analytics, i would look at something like PIWIK if you don't want to use Google. 
This may or may not help, but when I moved from procedural to object orientated it "clicked" for me when creating a simple shopping basket. It is just a very good example of representing a very common and non-abstract thing. I initially wrote a basket in procedural that ended with many functions and then a lot of if...then and session variables and all sort of bloated stuff. Big switch statement picking apart the query string. But if you imagine the same in OOP, you end up with something like: $basket = new Basket() $basket-&gt;add($item,$units) $basket-&gt;setQty($qty) $basket-&gt;empty() $basket-&gt;checkout() $basket-&gt;setGateway('paypal') etc... it is also fun constructing the basket class, which is fairly similar to creating a function. I suggest you give it a try. Like anything else, it becomes intuitive once you've spent some time practicing it. Hope this helps you.
Whatever provides the most help for the task in hand, in combination with what you and any fellow developers are most familiar with. The same goes for programming language choice.
Magento 1.x comes with built-in API. You can find more details here: http://devdocs.magento.com/guides/m1x/api/rest/introduction.html and here: http://devdocs.magento.com/guides/m1x/api/soap/introduction.html
&gt; you prove I had too many interviews... knowledge of symfony or laravel doesn't means anything nowdays... But yes, chances to find more qualified developer within symfony community are a bit higher that within code igniter for example. But don't think that all developers that using their frameworks understand ideas behind used concepts. Most of the time it's just cargo cult. 
Imagine you had to rebuild your project with a language that had less features. No constants, or no variables, or no arrays, or no for-loops, or no if-else, or no switch statements or no booleans. Sounds like hell right? OOP adds more useful tools to the toolbox. Even if you only learn how to use 2 of those OOP tools in 2018, you'll never want to go back to a language that lacks those tools.
build REST API in procedural PHP, it's fast and easy to maintain and you probably won't need anything else beside raw PHP, and it's fast, and it's fast build your app in Javascript and plain HTML maybe as a PWA use a 3rd party OAuth service for logins KISS
&gt; That would be a configuration change, not a code change (or maybe it is a code change if you use code to configure your container, but that is configuration code, not "logic code" - I'm sure you get the point). When you add one more configuration level, the previous configuration becomes logic code. After all, all code is merely configuring a CPU to run things in a given order. I'm just saying :)
&gt; A good real world example of OOP in PHP? Wordpress plugins. lol
The worst is methods/APIs which return null (or key doesn't exist in JSON/XML) when not found, an object when one is found, and an array of objects when multiple are found. This should instead use an array at all times, with none, one or more objects. For methods in objects, having it always return one type or cast an exception is just better. You don't need to interrupt the code flow every line to check your return value and do error handling. Instead that can be pushed to the catch at the end of the code segment/scope. And if you throw your own exception, you can refer to the original exception you received. 
&gt; Actually, OOP is quite a complex computer science Please don't call it that, I'm cringing. Sure, if you take the entire evolution of a given branch of programming to mind, everything looks like complex computer science. But all OOP does is introduce the idea of polymorphic instances of encapsulated state + behavior. An idea so old, it was common even before OOP was called OOP. It was called modules, closures, many names.
Thank you Mr. Troll for your contribution in the discussion.
At the front controller script. Or at an autoload.php/bootstrap.php file, if there are other entry points to the application that share the same DI container and its services (e.g. a cli console).
That same thread actually had someone post a solution that appears to have solved that OP's issue: http://www.showmycode.com/ 
https://www.patreon.com/oerdnj - Maintains Ubuntu PPAs for PHP, Apache2, MySQL and others.
The front controller would create the container, register a few service providers that define groups of related services together (e.g. Controllers, Middlewares, Repositories etc) and fires up the framework.
Click the link ;-) That project is closed.
OOPHP has more characters of code, but most of it is generic object-defnition and frame. The actual code that does something is smaller. When using automated and semi-automated development, pasting in a frame and filling out the blanks is just as fast as procedural. The big benefit of OOphp is, that you can modify objects, extend them, inject dependencies etc. That allows you to split your code into enclosed logical packages that can be mixed and extended more easily than classic procedural code. One of the biggest benefits is inheritance though. You can create a generic item and give it generic properties, but then have tons of classes that re-use those same functions. As soon as you change your first class, the others automatically use those changes. Another one is that you can prepare an action in an object by adding values in any sequence you like and tell the object to execute a function on itself or pass objects as parameters for another object. but whether you go for procedural, OO or functional, they all got their advantages and their disadvantages. That's why people work with all 3 of them. 
Seems incredibly useful. Thanks for sharing. I can't wait to start a project with this. It might be worth including a link to your post in the repos readme, or copying the install instructions from the post into the readme. It might help the barrier of entry (Even though it's fairly low).
I don't know of a specific tool for that type of analysis. I do know that you can calculate complexity with [PhpMetrics](https://github.com/phpmetrics/PhpMetrics) I did have a look through the Curated list of [Static analysis tools for PHP](https://github.com/exakat/php-static-analysis-tools) but I couldn't find anything. You might be able to find some tools and use them in conjunction with each other to achieve the desired result. I am interested to see if there are any specific tools for this type of analysis. 
Here's a different analysis, tuned to page-based include-oriented applications, based on my book [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp): - If you don't have an autoloader, start by adding one. - If your classes are being loaded by include/require, start autoloading them (and remove the includes/requires as you go). - If you have function files being loaded by include/require, change the functions to static class methods and start autoloading them (and remove the includes/requires as you go). (If you are already doing those things, right on! The book has about 15 steps total, so there may still be some steps that apply to your situation.) Good luck with your refactoring project! 
This shopping basket example is pretty nice for a new comer to comprehend and see the value. It takes a somewhat complex project to implement shopping baskets that one can actually replace, or use units (products, shipping methods, payment methods, etc) all available to plug into. This is where you really see how OOP make the process nicely structured and done with a lot less lines of code compared to such procedural implementation. 
I am new to oop also and struggle with the seemingly overblown complexity to achieve simple outcomes. However there is a massive shift towards oop collectively and if you develop using modern tools/frameworks you need to understand and internalize oop think. I would suggest learning oop with python rather than php, it’s a lot easier to grasp imho.
A 100% content free article combined with what I suspect is a politically incorrect title. I like it.
Can we give up on the framework vs framework bit already?
Yep. I can tell you from working on a project with 6000 files. OOP is a must
Once you know you need a car, you then go out and buy or borrow one. You can decorate it as you like, or just use it as it comes. Either way, you have a ready-made car and don't need to build your own. It's a functional machine with a well-defined interface you interact with. What's more, if a fault is found in your make of car, it can be recalled and fixed, and should be returned working just as well as it was when you first got it. It may have a fix to a potentially deadly problem with the brakes, but it looks and feels exactly the same when you sit in the driver's seat. I love car analogies.
Damn 6000 php files !!!
It was Java but still a lot. That was just class files, that doesn’t include JSP or Struts
raresp, thank you for your reply. The reason i've asked about adding additional framework/tools is because magento REST API has some weaknesses compared to more modern solutions: Unit testing, customized caching, etc. You can read more on it here. It's project were they are using following set-up AngularJS -&gt; REST -&gt; Laravel API -&gt; Magento Code I guess for our small API there is not need in this, but still i wanted to here your opinion.
DokuWiki: https://www.patreon.com/dokuwiki (shameless self plug)
Well. OOP is good when you have relatively static requeriments. As example, if u have an invoice system making in procedural, can be good Idea move to OOP, until you understand the owners of the business who owns the code put new requeriments often enough to be more practical use procedural well organized files. By my own rule, only use OOP when i have not changing requeriments.
[A Mexican standoff is a confrontation amongst two or more parties in which no strategy exists that allows any party to achieve victory.](https://en.wikipedia.org/wiki/Mexican_standoff) How is this a standoff and what is Mexican about it?
It it has been said before, it is mostly about organization. Separating things into MVC is nicer with object oriented programming. Here is the most [minimal example of a DB connection](https://gist.github.com/MattSandy/195a6fd4a32fa49810ff) I wrote a few years back. Imagine how easy it would be to refactor that code to work with two databases, just by passing the info into db instead of working with constants. 
Dunno, that's what the docs told me.
It's almost like nobody ever did a comparison between the ones in the article! Coming up next week by the award winning author; "The Mexican Standoff of Procedural programming versus Object Oriented Programming"
And yet, that's never been an issue for any WP work that I've done. You want to have an academic discussion on the code of WP and you'll have a few solid examples. You want to have a practical one and you'll be wanting. Can you show me a code base as old and as big as WP that doesn't have remnants of it's original version?
&gt; OctoberCMS : Built on laravel but isn't really a laravel experience. They have a very unique style that will feel similar to Vue or React but in PHP (mixing template and code in same file). thats not really true, i find php section in pages totally useless (unless we talk about really basic db fetch) you basically build stand-alone components that work with db/other services, no need to mix anything and to be honest - you should never use it 
Here is the package: https://packagist.org/packages/mediact/testing-suite I forgot to mention it also configures Phpstorm, so PHPCS and PHPMD use the correct rulesets and the formatting options of your IDE match the coding standards.
I think Fowler would say to use the tool between your ears. Read the code and figure it out for yourself. Don’t rely on some script to spit out a calculated answer for you.
as i am sure many people have pointed out, the point of OOP is not lines of code, it is about maintainability, testability and extensibility. your procedural code will be harder to test, extend and maintain. 
Was there not an OOAD component to your Comp Sci degree?
sorry to say its actually the other way around. well crafted OOP code is much easier to extend and add functionality. my guess is you are just writing procedural code in the OO style and not following [SOLID design principles](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)). If you want to PM me with a link to some of your OOP code I would be glad to give you a quick code review and show how you can make your code much easier to extend.
Still there is a need. Need to know where is possible place to start. Script result is just an additional input data.
There are many things in our Comp Sci degrees, that turn out quite different, or outright useless in practice.
Yes, i did, it is around 2.3K on my setup, but it depends on framework you use. More code you need to bootload - higher performance you should expect.
I don't really see how the race condition he described is specific to PHP. Or why your race condition would be. If you use multiple databases (a cluster) you can have this race condition. If you have any IO latency (read: you will) then you can have this race condition. Assuming you are using a single write database; I would suggest you add a unique index on the event id column, in the event-guide link table. Then, you can't have duplicate insertions of the same event id. Display the database error (well, with different wording obviously) so the guide who couldn't knows.
Thanks, the PHP-FPM aspect is what I care about. PHP-PM is completely irrelevant.
As I hear it, their problem was not PHP "per se", and their problem was not solved by simply switching to node.js. The problem was their architecture, and most explicitly that they didn't have any sort of locking in place to prevent 1 driver being sent to 2 customers or 2 drivers being sent to 1 customer. These problems could likely be solved in MySQL by using transactions (of even just switching to InnoDB if they were using MYISAM) with some sort of appropriate lock on both drivers and customers to ensure they can't be involved in 2 "journeys" at the same time. Additionally, the way PHP interacts with the web server has evolved - we now have PHP-FPM (it had been in PHP for 2 years by 2011, when this talk was given, but I believe there were some issues with Apache's FastCGI implementation in the "early days"), rather than having PHP run as a module in Apache. I believe the problems they experienced, at least today, could be just as easily solved with PHP as with node.js When watching videos like this, it's generally best to ignore the technologies mentioned and look at the changes in their architecture / what they are doing. Often the architectural changes are largely separate from the technology changes, but people like to conflate the two if they're trying to be hip or whatever. While it's sometimes the case that systems do have to be torn down and completely rebuilt, it's often easier to refactor the existing system (which would've avoided a lot of their issues about "sliding" the new system into their existing one). But that doesn't sound nearly as cool as completely rebuilding it and they'd have to read somebody elses code, which no one likes doing!
This right here. Back when I was a dev, OOP PHP wasn't a thing -- I spent far too much time trying to suss out what other developers had built. I wasn't building new systems, which would have been far easier because of my own direct knowledge of building them. I stopped being a dev a long time ago, but recently had the opportunity to look over an OOP PHP app that was written by pros -- and was flabbergasted at how simple it made my life. If this had been procedural code, it'd have taken weeks to figure out, in all likelihood. As it stands, this took a couple of days.
I get that, but that's not how automated testing works. "See if there's an error on the page" is not a valid test. I get that it could be worked into a test, but as is, without actually writing that test, the statement is simply not true.
Try Xmysql : a nodejs command which serves REST APIs for any MySql database. Since Magento Database is MySql - you get 6800+ APIs for Magento in &lt; 3 seconds !! https://github.com/o1lab/xmysql. Any questions are welcome.
ReactPHP team member, and maintaining a bunch of ReactPHP packages and projects myself https://www.patreon.com/wyrihaximus (shameless self plug)
Why not. It's a fast, simple and secure framework.
A default Magento 2 project, with no extensions or custom code, has ~65k files
Everyone, please take note. _This_ is how you troll.
up up up! :D
assertchris, thank you for your reply. Yes, we are using single "write" database (all on one server). I just could not understand why that problem could not be solved with php/mySQL. Now i see that i can. One more time thank you for your reply, it's very helpful!
&gt; This doesn't mean that you need to switch whole project on it as one single large step. Correct. You add the code for the autoloader and do nothing else; it is a preparatory step. You might find it worth your time to watch the video at the Leanpub page linked above.
AllenJB83, thank you for your detailed reply. Now i understand much better. "But that doesn't sound nearly as cool as completely rebuilding it and they'd have to read somebody elses code, which no one likes doing!" Agree on that. That's why node.js invited them :)
If you're going to have {namespaced,global} functions that aren't [static] class methods, you'll need to manually include the file that defines them. However, this ability to autoload functions gets [really fun](https://3v4l.org/ivOSN) when mitigating the risk of backdoors in software dependencies.
I've been a PHP coder for 14 years or so, and it has been my primary source of income. While I did have Java programming experience which was OOP, I stuck with procedural coding with PHP mainly because I built my own systems using it which I would code share from on multiple projects. I didn't like that PHP didn't have all the things I'd expect, like method overloading without argument filtering, so that helped me justify avoiding it. In short, I thought of PHP as a lesser and looser language, and didn't bother with PHP OOP for too long. Eventually, though, especially with Wordpress development dominating my work, I started needing to understand the features that PHP 5.4 and up have added. I needed to understand OOP for PHP, so I began training myself and rebuilding my systems using OOP. It was a lot of headbanging for some of it, especially when something just didn't make sense, and there are still challenges that I am coming across, but it was entirely necessary. I've been working on a complex AWS based project as my main work regularly. I couldn't imagine the spaghetti code that would exist if I had done this in a procedural format. I've broken nearly the entirety of the code down in to autoloaded classes, used interfaces where it made sense, but avoided using a factory method for database access (I used two global variables to store the two database connections). The vast benefit is once you have gotten everything in place, your code has a more high-level legibility (assuming you name your classes and methods that way), and everything is properly contained in a way that you know exactly where to go when there is an issue. I like having code that reads like: &lt;?php require('bootstrap.php'); // contains class autoloader and sets up database and variables $s3 = new S3(); $s3-&gt;getObject('bucket','file_path'); Thumbnail::generateAll($s3); $video = new Video(); $video_path = $video-&gt;make480p($s3); $s3-&gt;putObject('bucket',$video_path); ?&gt; Everything is as clear as you want to make it. Also, instead of loading a bloated functions.php file housing all your functions that may or may not be needed on execution, with a class autoloader, you could possibly reduce the amount of actual code being loaded with each page load overall. I still use procedural on small tasks, but I'm committed to any serious work being done in OOP now, even if just to improve my abilities.
To avoid that you could ask for a lock in the database (a write one) so the first who arrive is the one who writes, the second one should receive a not available 
That linked example is terrifying.
To clarify, `use Some\Class` does not autoload either. Aliasing and autoloading are completely independent functionality. Semi-recent discussion on function autoloading: https://externals.io/message/94895
The patch: Add an explicit `\` (compare with https://3v4l.org/nj7ic)
Makes sense - with the `\` you're explicitly marking that function as part of the current namespace, rather than the global function. Tricky to spot though!
If we get function autoloading, it will likely only trigger on statically resolved function calls (that is, either fully qualified or imported) due to performance considerations.
It's the other way around. `\` explicitly invokes the global namespace rather than the current one. By default, it tries local then falls back to global.
Apologies, but if you don’t have any tests, you don’t really have any working code at all. 
This was the friendliest and smoothest way to promote a book that I have met so far. Great work!
65k files doesn't build you software. It builds a house with four freaking swimming pools
Thanks for the clarification. Interesting discussion. To be honest I've known since 2013-01-28. I went with a clickable title to get the gears going again.
"We don't understand concurrency so we rewrote it in a single threaded language". 
&gt; To clarify, `use Some\Class` does not autoload either. So then how does composer authoload? And what exactly is happening when you do: `use Some\Class` ??
`use Some\Class` does nothing more than give you the ability to reference `Some\Class` using the shorthand `Class`. If you haven't `include`d that class or set it up for autoloading, you won't be able to alias it.
Also phpmetrics also encounter git log in it's statistics. So you could use it to correlate efforts and complexity
When you define `use Some\Long\Class\Object` all you're really saying is that when you refer to `Object` you're actually referring to that full name. It's just a way to shorthand potentially long class names. Composer's, or any other, autoloader doesn't kick into gear until you try to use that class in some way. For example: use Some\Long\Class\Object; // Nothing loaded $x = new Object; // Autoloader includes the class BTW, you can alias all kinds of things that aren't included or set up for autoloading. It's only when you try to use the thing you named when it has to exist in order to do something besides error out.
So, how would the autoloader know where `baz()` is? Presently, an autoloader looks for a file name that matches the class name. One file, for one class. Here, there is no such file. I guess you could have a file named `/Foo/Bar.php` which now looks a lot like a class. Now you've got more problems to figure out. Worse yet, now you have `use` statements doing actual work with the file system, rather than just declaring an alias.
&gt; So, how would the autoloader know where baz() is? It's spelled out in the `use` statement on top; `baz()` is resolved to `Foo\Bar::baz`, which means the autoloader is triggered to load class `Foo\Bar`. &gt; I guess you could have a file named /Foo/Bar.php which now looks a lot like a class. Now you've got more problems to figure out. No the whole idea is that *it is a class*. My suggestion is that static class methods can be shortened like I demonstrated. Many languages offer such aliasing. Java for example.
Do you use a framework? 
From the title I thought it was a joke about how useless all these buzzwords are. From the comments I realize it's not.
I’m only using a simple MVC template given to me
I‘ll show myself out and confess that after having made part of my money with creating applications since 30 years now and after having understood most of the OOP concepts I do see its benefits IF the objects last longer than milliseconds, let‘s say in any complex persistent application. HOWEVER web applications belong not in this spectrum IMHO. Objects are not what OOP calls objects, they are mere datasets in relational tables. A web app might even be gobbled together faster by heaping abstractions on abstractions, getters and setters and what have you not. I test a web app with its output. I found very often that web frameworks are so cluttered with bad dependencies that never get properly resolved, Code smells from day one. I would rather have an approach that if code or function sucks, I haven‘t found the best compromise yet between the many parameters I need to handle. I have over- or undergeneralised. If I additionally have to obey the convention of OOP I weave more crap in than I could by following procedural thinking will well-thought isolation of methods and data.
[removed]
Short answer: in the controller and model. However, instead of reinventing the wheel you might want to take a look at frameworks like Laravel and others that support authentication out of the box. This will significantly decrease your development time if its just this you need.
You also got `use const DIRECTORY_SEPARATOR` FYI :)
Thanks for this, i’m not sure if the use of such a framework will be allowed as this is for an assignment. This is only one part of what I need to do as I’ve been tasked with basically creating a site like eBay and have pretty much no idea where to start. Wish me luck.
https://www.patreon.com/taylorotwell - Laravel Framework https://www.patreon.com/spatie - Packages for Laravel 
&gt; 65k ought to be enough for anybody *~~smgun*
Oh, right, yes! Sorry, I got it twisted around in my head.
Thanks! I kind of figured that it was a long shot but worth a try. The original developer doesn't have the key to unlock it either. And we're not looking for a legal battle.
Where are you doing the routes matching? 
Thanks for that but like /u/wischichr stated it's closed.
Very good point and I totally understand. Thanks! I will take a look into it!
There's a file `vendor/bootstrap.php` that's supposed to be included, yet does not exist. Can't really test anything in its currently-broken state.
Is available on laravel/homestead? 
You can `use` undefined things too. It won't error until you call it.
None of what you said is true yet you got the most upvoted comment. PHP devs are deluded beyond saving.
Traditionally as much logic should be kept out of the view as possible. If you need large changes in the view based on info you use different views for each scenario in the controller, use views inside the view, or use widgets (if the framework has them). Views should be about oresentarion, logic goes in models and controllers 
This is partly why I'd like to unify the constant, function, and class/trait/interface symbol tables: every time we add some functionality that affects them we end up eventually re-implementing it 3 times, and not always with the same semantics.
:eyeroll:
This code is not documented or tested (that I could see) and the if statements could be split out to multiple function calls. This,to me, is poorly written.
If you're looking for an API platform which will connect to the database/magento's API, you ca use API Platform - https://api-platform.com/ . Or you can search for a PHP/nodeJS/GO micro framework. These are very fast.
At least it's not tagged. So far, this is 20% of the work required to release it (assuming testing won't find any bugs).
To all the comments I just want to add next. Be careful, if you use classes, objects and methods it does not mean, that you are using OOP. OOP is concept beyond language tools and I've seen plenty cases when people had written procedural code with "classes". For example, people nowadays like "service objects" and so on. With that you have objects which have data and other objects (services) which handle that objects, which is really convenient. That's called anemic domain model (https://en.wikipedia.org/wiki/Anemic_domain_model) and Martin Fowler called it's anti-pattern. Because despite the fact that there are objects which handle other objects, it's truly procedural pattern. 
**Anemic domain model** Anemic domain model is the use of a software domain model where the domain objects contain little or no business logic (validations, calculations, business rules etc.). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It's not a terrible idea as a dispatcher. Glad to see people thinking about different approaches.
OOP wont make any sense if its used for really simple and small web apps. Especially if they use examples like foo or dog classes... An object is just a copy of a class that you can call whenever you want. A class is just something with a lot of grouped functions. Example: we have a login class, with functions (methods) like login, logout, check login etc. This way you you can use that code for multiple different users easy.
You shouldn't be ashamed of saying that you don't know something.
"..the if statements could be split out to multiple function calls." How should I do it? I put them in the construct so that you can just use an array with different middlewares (middlewareinterface, closure or another stack)
No interfaces, no tests, no comments, and no releases. I'd recommend you to try to set up a continuous integration instance, like Travis (the simplest one) and start writing tests because right now I'd consider the project at the *alpha* status.
That's a shame... perhaps go on a torrent site and look for the software - undoubtledly many people must have used it and possibly share it. Hope you find a solution to your problem :/
My own example is something from recently(The reason why I thought of asking this all) I had created a page where a lot of information from several objects had to be shown. I made a switch to go through all the categories of those objects, because every category had different attributes to be shown. In the end, the whole switch was about 1200 lines long... After looking back on it, I was struck by the realization that I could just use the object to take out all the needed attributes per category and the code is now only 14 lines small. It's what you do in a rush when under pressure by a client.
Unused / dead code :)
yeah i will add the test stuff and other psr styles. it has psr-4 for now. thanks for your attention and reviews. we can say it alpha. i use it in my own projects. then i thought people can have a look at it 
i have fixed it. 
okey i will look at it
15k lines in one file, down to 2k across multiple classes / interfaces / traits. Original file was php 5.5, no test, now on 7.2 with 100% coverage. Feels so good!
Do I get that right that the `MiddlewareStack` can only process a single request and isn't capable of processing multiple requests in a row?
Maybe the project was shut down because it doesn't work any more and it's not worth the effort.
PSR-15 has been accepted so you should use the official interfaces instead of Interop ones 
I'm all about cleaning up my old basic codes. What are some references you used to learn about interfaces and traits?
You know, every time a software gets updates, another software that uses it's api does change something. This accumulates etc. Imagine now, that what took thousands lines of code years ago, can now be done in single api call? Now you still have to maintain backward compatibility, right? NOPE - not even vendor maintains, we don't sell software outside, so we can and will keep it up to date and without any backward compatibility. Feels absolutely awesome to reduce behemoth into 5-line solution.
yeah, never thought about that!
Holy fucking God are you going to start charging next for excerpts from your autobiography?
Maybe you're supposed to be doing something productive but prefer to dick around on Reddit.
That should be easy. Clone the handler before dispatching the request
There are not so many people capable of creating new stuff actually. And you can be sure they would, no matter how many times they would hear "do not reinvent the wheel". For the rest, it doesn't matter actually. To the car analogues again. Everything in this world is evolving. One day you have a lot of electronic components enthusiasts building their own radios, anf the other day they are all gone, just buying a ready made radio. The days when you had to be a skilled mechanic to own a car are also gone, you just buy a car and drive it. Still there are some enthusiasts and professionals to create new cars. But you don't have to sermon them to do so. While for the rest of the population your sermon is just out of scope. 
TL;DR: we have to distinguish the purpose - for the learning it's OK to reinvent the wheel - to solve a practical problem, use a seasoned solution
No.
GDPR is mainly a matter of organisational and policy changes. Technology can only help so much, and for the user, giving consent is only marginally different from what's best practices already (if you were using opt-out, you were years out of date with best practice). That said, if you're willingly ignoring it all, don't be surprised you're "limited liability" isn't very helpful when they come knocking. Cookies that need consent (not all do) are pointless in my view. I turn all of them off on principle, if that means the site don't work, I don't use it. 
 echo "1920"; echo "1921"; echo "1922"; echo "1923"; etc
On a second thought, the process should be a reverse one: - first learn an existing solution and find all its pros and cons - only when you feel experienced enough and don't see the existing solution salvageable, go for your own version The main problem with the folks reinventing the wheel is not reinvention itself. But the fact they actually have no idea what a wheel is. 
This is not necessarily PHP code but we used phing to build our apps in CI pipelines and overtime with all the preconditions, phingcalls etc. in the XML it became messy, large and hard to read what was going on. I took what commands were being run and created shell scripts. From hundreds of lines of XML I ended up with about 30-40 lines in bash.
Same could go for you
Don't reinvent the wheel and we wouldn't have... Lighttpd, nginx, mongoose webserver, varnish, haproxy, netdata monitoring, tokuDB, git, fossil scm, ....
404
&gt; to solve a practical problem, use a seasoned solution Like WordPress. Very, very seasoned. /s
Good point. Added another condition
"Don't reinvent the wheel" is more often a way for the lazy and incapable to feel superior to their curious colleagues, than it is a genuinely good advice when given away carelessly with little context.
This comment is a good example of your typical contribution which is not intended to add anything to the discussion but serve the sole purpose to entertain yourself. This comment is illogical in the context of the OP, and even illogical by itself, but could spawn a huge discussion, if anyone would take the bait, providing you with more lolz and more noise for everyone. 
My comment serves to demonstrate your advice is useless. And I’m using facts such as the above example to prove it. If we are in the mood for overgeneralizations, your commands are often based on superficial memes, and lack insight. When I read the thread, I already know what you would say, and so does everyone else. So if you decided to save your effort and not write anything, it wouldn’t make any difference at all.
Where would I start the session? Model, view or controller?
ALl this tools are not reinventions. 1. Lighttpd - first released in 2003. It appered due c10K problem since no other tools could handle it. So it's not the wheel, there just no tool which solved problem. 2. nginx - first released in 2004 for internal needs of large internet company (rambler) to solve the same problem - performance. lighttpd was too unstable to use in production at this time, so they implemented their own solution to their problem. So again - it's not invention of something new - just different implementation which suites needs better. 3. haproxy - the only available load balancer which could handle raw tcp. Also as for 2001 - there were no such tools. I think you got the idea. It's not about inventing the wheel, it's about solving problems. Most of devs who tries to write their own frameworks have only one problem to solve - it's just too boring to just solve buisness problem, so instead - you want to generalize problems and build a framework. From the other hands, let's say that you need to experement with some different approaches in development and you already have 10+ years of experementing with existing approaches. And you already know problems that you need to solve and there are no framework for this kind of problems. But it means that you already had some research (not few minutes googling). In this case this is not reinvention. 
I discovered that I could delete ~1000 lines (dozens of large functions) of spaghetti code with zero impact due to a bug that was &gt; 1 year old that nobody noticed.
You are the one that failed to properly identify what seasoned means. But then again, you might as well of just said to keep gagging on Symphony like Heather....
To reinvent the wheel doesn't mean to invent something new, but exactly a different implementation. Whether it suits the need better or not is a different question. So both a noob's first own framework and Nginx are such wheels, they are just coming from the different positions in my bullet list. 
Does Wordpress fit your requirements? then yes, otherwise no. Personally given how not unit-testable wordpress extension system is, i'd say no.
In my opinion reliance on a framework is not the big issue. The problem is that a lot of developers think in terms of implementation details and don't know or care about how to use abstractions in a meaningful way. Frameworks, like languages, are implementation details. They implement common abstractions in their own, principled way but typically use the same abstractions. It is valuable to learn about the abstractions and why they are necessary and learn about why a framework implemented it in a certain way.
Just deleting loads of shit that either duplicated framework functionality (I guess because they didn't want to learn it or never bothered looking at it) or refactoring a copy-pasted bit of code to be in one place. 
A hero method in a Sonata controller. I don’t recall how many indentations it went but it made me cry.
This is why I prefer micro-frameworks. They get out of your way, letting you do whatever you need to.
&gt; So both a noob's first own framework and Nginx are such wheels The difference I think is that nginx has very specific problem space, while noob will just copy something that he seen im most simple way to just "make it work". I think that you could get much experience from building small specialized solutions. Like your own programming language (to learn how all this works, how memory is managed and so on), your own simple database (which allows you to experement with different algorithms, heavy I/O work, data structures and so on) or even simple router (regex, prefix-trees, code generation, many small specific tasks). But you will have no any new skills from building yet another MVC framework. Since building full-stack framework require huge amount of work, and even more if you want to learn something. But if you just tired to wire up some ready to use components, or just tried to replace symfony/routing on your own - there would be much more profit.
I see 2 issues : * No uppercase first letters in your namespace * Your stack works only once. No way to restart, no way to perform a subrequest
Yet another rant against framework, and again, the same argument : beginners will be beginners. Can once for all somebody rephrase it as "Please learn programmation before using any framework too big for you to understand" and stop the recurring ranting ?
Wow do you know of any other sites like this? This one actually has recent high quality articles actually about PHP in proper English and so far I have only seen one article promoting the use of mySQL_ and real_escape_string. I had almost given up hope of finding such a site. Are there others?
Well, the problem is that it's not just beginners. I've seen programmers with 5y+ of experience relying way to heavily on the framework (and I mention this example in the post). Also, I don't think it's wrong for them to start using a framework early. I just think they need to be aware of what the framework does *magically* for them in the background.
&gt; I've seen programmers with 5y+ of experience relying way to heavily on the framework Because they stayed beginner. Because they never learned outside of the framework. All of these rants applies only to inexperienced developpers. I can't think of one argument applying to experienced developpers, expept, maybe, that some of them are ready to load a stack of rest client over a stack of http client to perform a single json-encoded request to a distant service.
&gt; and my personnal conclusion is that there is no other implementation than a Linked list. Thanks! but what do you mean exactly?
apache + perl cgi + flat file was fine!
They could have as well improved apache. It probably would have been less fun.
&gt; I think you can create a "sub-request" inside your middlewares if you must. You can, but your stack never rewinds it's internal middleware array. So, your sub-request will start where your current stack is, and once it will be finished, the middleware creating it would not be able to continue (as the sub-request will have moved the internal pointer to the end). &gt; Thanks! but what do you mean exactly? Instead of having a stack in an array with a moving pounter (current/next/reset), you have a "chain" of this : class MiddlewareWrapper implements RequestHandlerInterface { public function __construct(RequestHandlerInterface $next) { $this-&gt;next = $next; } public function hande(ServerRequestInterface $request) { return $this-&gt;middleware-&gt;process($request, $this-&gt;next); } }
I laughed
Watching peoples face contort when I sing the praise of Flight is one of the joys of using it IMO.
+1 to the /u/sarciszewski shoutout, super appreciative of his work.
How? You learn to build an architecture from the ground up? Can't get much more education than that, it would also help you be able to just jump into any MVC and be like ah yeah that makes sense, so I think your points are invalid, sorry friend :)
Thank you. That wording could have readily been misunderstood.
My apologies. I finally managed to let sink in what you're talking about.
At the top of index.php or in the controller would be my inclination. The model should really only deal with abstracting interactions with the database. The view should only be dealing with constructing the display (HTML output). The controller handles all the "business logic" or in this case "all the other logic".
I mean, technically yes, but practically no. Integrating fundmentally distinct implementations or related-but-tangential features into a product that wasn't meant to support it can become harder than just making something new... and despite being harder, arguably come out worse anyway because now you have an ever-increasing project scope and more and more complexitiy going around when you otherwise could have just had a distinct product that's more satisfying. To go with the wheel analogy: don't reinvent the wheel, but don't be afraid to release a new one when you realize it'd make no sense to try and make [this](http://lizquilty.com/wp-content/uploads/2010/11/roadtyre.jpg) be able to perform like [this](http://m.rgbimg.com/cache1nXUAg/users/m/mi/micromoth/600/mmykEsC.jpg).
&gt; can't think of one argument applying to experienced developpers So the article is of no use to anyone just because it doesn't tell you anything you don't already know? You wouldn't send a junior dev to read this article? There are good points here for inexperienced developers, who need advice like this to grow their careers. I wouldn't necessarily call it a rant. Besides, an experienced developer already knows that a certain framework might not be the right tool for the job. No arguments needed for such a person ;)
Composer autoloads by registering an autoload function via [spl_autoload_register](https://secure.php.net/manual/en/function.spl-autoload-register.php). This autoload function function is called when any PHP code uses a class that is not known. Before throwing an Error that the class is not known, the PHP runtime will call composer's autoload function. What exactly this function does depends on the autoloading rules in the composer.json files (Whether it's PSR-0, PSR-4 or classmap) and whether composer is told to optimize the autoloader function, but in the end, it's going to use "require" to load the file the class is (supposed to be) in. If that doesn't load the class, there will be an error that the class doesn't exist.
Or... we could break all backwards compatibility in the 8.0 release and delete all of the comments.
Can someone explain to me the how/why of a `__construct()` in a Trait, interacting with one in a class? I had some necessary logic in a Trait, and found it was incompatible with the class that was using it. Insight on how it works when it is being processed?
I worked on an old codebase where there had been multiple people working on it before me, but I was somehow the first one to put anything into version control. It had that ad-hoc kind of version control done in the file-system with multiple copies of files lying around, some with `.old`, `.orig`, and `.php2` as extensions on them. Those went straight into the trash with commit #2. The more gratifying part came later, as I started to discover that a lot of the other, more conventionally named, files simply weren't referenced by anything else. I got slightly giddy each time I discovered one, because that was another plate of moldy spaghetti that I could just toss directly into the trash and never have to untangle and sanitize. Past that, I found repetitive copy/paste blocks of code sprinkled throughout the remaining files, often with only a thing or two different between each instance. The ones whose results were actually used were quickly turned into functions. I discovered that other such blocks would simply do their work and have their results completely ignored, which meant more code to delete.
So... his argument is that majority of work is legacy systems? In a way I understand this line of thinking. In specializing in Laravel you lose the skill set to deal with a system like output buffering. But I do not agree that everyone needs to know plain PHP. If your end goal is to have a diverse skill set then it's necessary but for most people they'll be specializing in a particular industry, in a particular framework after XX years. It sounds like the author of this article has trouble finding people who had the skills to maintain a legacy system. 
Looks like I stated exactly what I wanted to state.
&gt; Does Wordpress fit your requirements? It'll never fit my personal requirements. thatsthejoke.jpg
From this article I get the impression like phrase *Don't reinvent the wheel* means *Don't reinvent the wheel, get this framework and blindly use this lib for this feature I gave you to do*. If you are that kind of dev then it means that your own implementation of wheel will be far worse to maintain and extend than blind usage of framework. And this is how *legacy-in-the-time-of-writing" code is created. If I tell someone (or I am told) *Don't reinvent the wheel* it means (or it should mean): *Find lib or extensions to the framework for this feature to be done, check if they cover your needs and if this lib/extension is maintained and use it. If not, write it. Just don't reinvent the wheel if it's not needed.* What is a purpose of knowing all the security abstraction layer (and write it on your own) when, for your basic needs it just gets the job done (and as a bonus it is tested by millions)? If my task is to make some advanced security mechanism (ignoring crypto section of course :P) then it's time for me to dig into it and learn not just to extend basic framework classes in 10 places but write it on my own and only connect it to framework. And this knowledge won't go away. After some time, when you get similar task, you will instantly know what to do. 
Are you sure they're relying on it, or do they use it *because* they have 5+ years of experience and know exactly what effort is involved if they *don't* use the framework? &gt; I just think they need to be aware of what the framework does magically for them in the background. Agreed with this. I had to go through the process of writing my own IoC container, router, DBAL, session drivers, and beginnings of an ORM before I really understood what that magic was. Because of that exercise, I have a much greater command of modern frameworks. But it also led to me to realizing that there's nothing wrong with choosing a mono framework 99.9% of the time. There has to be quite specific reasoning as to why I would eschew a mono framework in favor of piecing together a set of libraries that all have to do the same thing the mono framework was doing anyway.
The counterpoint is that when people say "micro-framework" the typical example is a small framework with an incredibly monolithic and overburdened Application god object that does everything and gets everywhere in your app, so any semblance of a decent architecture is out the window. Of course, you can get around that with discipline, but what the framework encourages you through its design and defaults, is the exact opposite.
Your example might be wrong as I assume you wanted to imply the email would end with 'com'? There seem to be more then 16 characters after that. Aside the example, it looks like the email can be followed by a new character immediately, as in, without whitespace or something else. This is an issue as you don't know when your email ends. The specification is quite wide as you can't easily know all valid TLDs, like ". com" etc. Long story short : finding an email adres is really hard. Of you have some leniency the sure, do a pregmatch on something wide like "something with an @" and count 16 chars after that. But it doesn't seem like you're looking for that. 
The email will be always .com or .pt
Took many controllers and their index actions and configured it all to be run in one. Lifted all the differences between the code into configuration tables. Many files deleted and lines of code never to think about
&gt; So the article is of no use to anyone just because it doesn't tell you anything you don't already know? No, that is not my point. Allow me to refactor. The argument you quoted is meant to elight the fact that this article is NOT targetted at experienced developpers, as it ONLY addresses issues applying to learning developpers. &gt; There are good points here for inexperienced developers That is exactly my point, as stated in my initial comment, if you would be kind enougth to read it again. This article is aimed at learning developpers, and, in my opinion, could be interpreted as "don't use frameworks" while it should be "using framework prevents you from learning many things".
I'm not sure why you wouldn't add that to the question in the first place, as it is important. Anyway, then just go nuts with a preg match, hit for a grouo, an @, the a group then your tlds. Also, don't forget the first group can contain a lot of stuff, like the infamous Gmail '+' 
It just can. It is allowed to have a + before the at, just as you could have a 's' or a '.'. Nothing special there If you need an example, these are valid emails: you@site.com me+them@site.com Now for your favorite Gmail trivia, if you are "andresousa@gmail.com", the following email adresses are the exact same ; (note that this is a Gmail thing, in all other services they could be separate things or invalid) andresousa+something@gmail.com andre.sousa@gmail.com So yeah. Long story short : don't try to be too clever in reducing what you match as a lot of things are valid. 
In this context, "instantiate" would be a better word than "use". I.e. you instantiate a class to create an object from it. 
I guess I missed that in the docs. Thanks. I agree, but in my case, it is just for some Laravel Controller typehinting. The aliasing works. Still, it feels weird doing it.
&gt; his argument is that majority of work is legacy systems? Well, no, one of my arguments is that the majority of work is not based on your favorite framework. And even when it is, you benefit greatly for not using the framework blindly, without understanding what it does under the hood. &gt; But I do not agree that everyone needs to know plain PHP. I very much think that a seasoned PHP developer has to know plain PHP, understand database calls and web requests, etc. That said, frameworks are a great tool that you should be making use of, and I never said otherwise. The point is that you should learn what the "magic" does, how it does it and why it does it. It's also fine to specialize, just don't pigeonhole yourself into any specific tool. You can still use X framework for your entire career and still know how regular PHP works (and you should, if you're decoupling your code).
The main problem obviously stems from the fact that a lot a developers seem to think of MVC as a application architecture. It's not. MVC is a user interface paradigm. Ruby on Rails got it wrong and a whole generation of developers simply copied it with the result that we're now stuck with developers writing applications "inside" web frameworks with Laravel being the latest main culprit. 
I think we're on the same page here, just imagining the quote _Don't reinvent the wheel_ in a different context. In this context, it's referring to people being pointed towards just using a framework, with all it's associated bloat, without taking the time to try and build, let's say, a site with a simple CMS or CRUD system - just for the benefit of getting a better understanding of what's involved. Yes, a novice shouldn't just go and build their own Authentication system for a paid/real project. They should do this for practice, to understand Sessions, Cookies and Caching better, and then move on and use something battle-tested for a real project.
I like this advice. Thanks for reworking your thought process. I've started out my leap into webdev frameworks by learning Laravel and Angular (separate projects, though). I ended up learning that there is a LOT of value in learning how to do what these frameworks do in raw, no-framework code, for all the reasons developers have (performance, simplicity, etc.) I have some experience designing php websites in a non-OOP framework, so I used to think PHP sucked ass, because it was a pain in the ass. Hidden dependencies everywhere. Then I tried laravel, and I was in heaven once I got past the implementation details and started to understand the differences between my own non-OOP MVC framework and Laravel's OOP framework. Now I'm designing a MVP VanillaJS framework for a CMS based on both the event-driven style I found in Angular as well as the traditional MVC-driven style I use in Laravel. I actually really like it. I'm going to definitely going to take a look at PHP micro-frameworks after I finish delving into Laravel. I'll definitely book mark Flight, too. Seems legit.
Symfony sucks 
NO, IMO, I would create a function for each if statement and either return what its returning or return this, to chain them.
True
[Looked it up](http://flightphp.com). Amazed at how awful that sit is on mobile. 
&gt; Are you sure they're relying on it, or do they use it because they have 5+ years of experience and know exactly what effort is involved if they don't use the framework? In the few specific cases I'm using as reference in the post, I'm 100% they are not just _relying_ on it but would go as far as to say that they are using it as a crutch. A few things that make me think that: * The task was explicitly to write a decoupled class, and they just go all-out with their Framework methods service-locators * They ask if this is going to be written in the controller (this shouldn't matter in something strictly-decoupled) * They use some framework class for looping over array elements * They use some framework class for writing to files If the task was to "build X" then I wouldn't mind them building in whatever makes sense. But when the task is "build X as a decoupled class for doing Y" then we have a problem. I agree with the rest of your points! I'm not against using a framework, but I'd hope that experienced devs have a handle on what goes on behind the magic.
Plus also static class references
Here's an open RFC for this issue: https://wiki.php.net/rfc/nophptags
Probably mostly for historical reasons. It's frowned upon now, but I'm pretty sure PHP was originally designed to be interwoven with HTML. I think there's a talk somewhere on youtube where Rasmus talks about the very early days of PHP and how the php tags originally came about.
&gt; But if you just tired to wire up some ready to use components, or just tried to replace symfony/routing on your own - there would be much more profit. I absolutely went this route on a toy-project a few years ago just to answer 2 main questions: When and how do you instantiate system-wide objects? How do you cleanly handle the entry-point of your application? Both are pretty tightly related, but were interesting to tackle for me.. 
Look into arrays
In .php file you can write inline js, html, css, can you write php code in .js file? :)
Don't know if this would work for your particular use case, but you could always just put your values in an array and reference them via their array index. $ary = [ 'Class01' =&gt; 'foo', 'Class02' =&gt; 'foo', 'Class03' =&gt; 'foo' ]; If your goal is to output a list of HTML options you could just iterate through the array with a foreach() // Sort the array by its keys. ksort($ary); // Loop through the array. foreach ( $ary AS $key =&gt; $val ) { // $key will equal ClassXX, and $val will equal foo. echo '&lt;option value="' . $key . '"&gt;' . $val . '&lt;/option&gt;'; } Hope this helps.
/r/phphelp
That makes sense but at the same time it seems redundant to *have* to include the &lt;?php to begin a file if that file is going to only be PHP (with maybe the exception of html in the form of strings which I believe should be treated no different than a string that says "abc"). I have no educated argument against it as much as I have some confusion. But it sounds like it's more about where PHP came from (intention and all that). 
ty 
How interesting. It feels good to know my curiosity had some merit haha. 
Technically you could... the portion between (and including) the php tags is being parsed and evaluated so you could generate JavaScript code for instance from the php code between the tags. You only need to pass the js file thru php.
&gt; You learn to build an architecture from the ground up? Nope, I failed few projects over the years and learn from both mistakes and other's people mistakes. I also wrote my own MVC framework at the beginning of my carrier and I found that I learned absolutely nothing from it. &gt; jump into any MVC There are much more simple ways to learn separation of concerns. Also MVC is not an architecture. How writing your own framework, where you the only one person who uses it, and the only one who generate changes of requirements, would help you to learn things like coupling, cohesion, testing? 
I never actually thought about it, your confusion make sense. Php gone far away from what it was intended to be, there some talk on YouTube by the creator about that... I guess i just got use to it without much questions, im more front-end oriented, so i dont mind redundancy.
Maybe, but all other depends on context. What kind of experience dev already have, is there any mentoring process involved?
Does tux's license (GNU GPL) allows to use it in proprietary product? Also Tux was kernel-space server, which slightly different thing.
I you have bad wheel then you probably change it. But if you want to change good production ready wheel to your own wheel which you made from scratch from what's on hand in your garage... you probably should think twice.
What you say is technically correct, but also it's a pointless statement. I mean it's like saying "you need to write good code. If you write bad code, you should think twice." Because nobody who sat down to reinvent a wheel, did it **despite** they liked a wheel they're using better. No, they did it because they didn't like what's available. The problem comes from becoming too nitpicky and critical of other people's work, but even the most nitpicky and critical person would technically agree with you and say "Of course! Problem is everything sucks badly out there, so I need to make something better". To reuse or reinvent. It's a problem I have on a daily basis. Is this a good train to hop on, or will it drive off a cliff, so I better build my own bike? And the answer doesn't fit in a tweet's worth of words. It takes years of experience to get there, and it's *still* never easy. In fact, if it's easy, that's a bad sign that the wheel picker is a sloppy architect. It should be a hard choice based on lots of input and careful consideration (unless it's competitive programming and you just wanna hammer out a shitty prototype in a few hours). 
Can I ask why you're using a trait for controller typehinting in the constructor? Sounds the opposite of easy.
&gt; $basket-&gt;checkout(); $basket-&gt;setGateway('paypal') Can you imagine that your basket can do checkout in Walmart? And has Cashier built in 
&gt; MVC is a user interface paradigm. Preach the Word, my brother. I have written at great length about that, and how Model 2 misappropriated MVC, [here](https://github.com/pmjones/adr/blob/master/MVC-MODEL-2.md).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pmjones/adr/.../**MVC-MODEL-2.md** (master → 92a4daf)](https://github.com/pmjones/adr/blob/92a4dafcb59d7b9c7da74a84aa74008e307c2bf5/MVC-MODEL-2.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtjkeqk.)
If you are doing TDD, test coverage will always be 100%. If you are not doing TDD, test coverage is meaningless. 
I'm gonna go ahead and first say I agree with the other dudes. What you need is likely arrays, based on the detail provided they should be a cleaner data structure. However, eventually you may have a legit use for knowing how to 'use variables in variables', or 'sequentially and dynamically naming variables' as you're calling it. From my personal experience, in the cases where that comes up as necessary...you're probably doing something wrong. Most situations shouldn't call for something that complex. If you are 100% sure you need to use them then you'll need to learn about [Complex syntax](http://php.net/manual/en/language.types.string.php#language.types.string.parsing.complex). 
&gt; If you are not doing TDD, test coverage is meaningless. That's weirdly black and white. If tests break when you refactor and inadvertently add bugs, they're meaningful no matter what your test coverage or development strategy is.
For someone who is entirely unfamiliar with threading in PHP, what are the main differences between pht and pthreads, and when would one use one over the other?
1. use DB transactions 2. check if update was made: `update tour set user = :myuser where user is null` 3. use reservation logic. like in i.e movie theatre checkout systems. DB level stuff is not really an option with distributed databases. 
All I am saying is that *test coverage* is a meaningless metric. I didn’t say anything about *tests*. Test are always useful, as long as they - assert (and document) expected behavior - shorten the feedback loop - increase confidence If I don’t know a code base and it doesn’t have documentation, if the tests help me understand what the code attempts to achieve, and if I can’t change the behavior of the code without at least a single test failing, then the tests are excellent. 
I've never actually checked it out on mobile. I'm surprised their incredibly simple layout doesn't handle it well.
What's up with everyone babbling about arrays? Without making any assumptions about why the question was asked, the simplest answer is a loop: $limit = 3; for ($i = 1; $i &lt;= $limit; $i++) { $class = 'Class' . $i; echo '&lt;option value="' . $class . '"&gt;' . $class . '&lt;/option&gt;'; } Now, naming something a class which is not a class, that's a different story altogether.
Ah sorry, misunderstood. So you're saying just because a given test runs a given method, increasing the % of lines covered, doesn't mean the test does anything useful. Totally agree. I'd say though, as someone who is trying to increase their OS project's %-covered metric*, that such measures can be a useful indicator of work that needs to get done. And it's encouraged me to approach new features in a TDD way. \* 84% and rising
Have a look at MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent You can see there that there are several characters that aren't encoded. Whether you handle this on the JS or the PHP side is up to you. The MDN page has a function which adheres closer to the RFC than JS does (fixedEncodeURIComponent).
What's going on is actually pretty simple. I'm not sure if you're familiar with Laravel, but in its application container, I can create an instance of an image processing class. If I want to call that instance, I can do so by adding a typehinted variable to a controller constructor. class FooController extends Controller { public function __constructor( ImageProcessor $processor) { $this-&gt;processor = $processor // Can do stuff in the rest of the controller } That's simple enough, but what I wanted to do was encapsulate the object that Laravel gives me, and some of the logic around it (like passing parameters to the object to get child objects) in something easier to use. As it is in the above, the dev has to do that in every controller in the system. By moving instantiation and the related logic to the trait, any controller just needs to add `use ImageProcessorTrait;` and they have the object with any settings set AND any related functions. By doing it this way, a dev can come along in a year, want to run a method from the image processing class, and just add the use statement and the function to the controller action they want. Two lines of code, my controller files are clean, and I have a separate library that is independent of the domain. The only thing that is tied to the application is the trait, and that is because it calls things from configuration. Not sure if I'm making sense though. If you know CakePHP (2.x), it does something similar since it doesn't use traits.
&gt; If you are not doing TDD, test coverage meaningless Well shit, better throw out all of my unit tests in that case
PHP is referred to as a "hypertext preprocessor", which is English means it's HTML that is preprocessed by commands embedded within. So you may have a PHP-only file, but to PHP you have a preprocessed HTML file, which starts in HTML context. Maybe in 2018 such a notion is no longer most suitable for PHP, where we use PHP-only files and have custom template engines, but there's also this: *it doesn't matter*. The tag doesn't hurt that much to have.
Legitimate and historical reasons : Originally, PHP was thought a bit like coldfusion, having a tag like format you could interwine with HTML : &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;?php foreach(['one', 'two', 'three'] as $item): ?&gt; &lt;li&gt;&lt;?=$item?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; The idea was, you write some html file, and then sprinkle a bit of custom php tags that added behaviour. To let Apache/whatever server know which is a pure html file and which is a PHP augmented one, you just change the extension. To be absolutely truthfull, you could output anything, not just HTML. ~~~~ start of file ~~~~ Here you are in the text output context, whatever you write will be outputted by the server without being interpretted. Hello from text. &lt;?php // Here you are in PHP context were you can create variables, do loops, etc. $hello = 'Hello from PHP\n'; echo $hello; ?&gt; Here you are in text output again. ~~~~ end of file ~~~~ If you create the previous file on a server and give it the extension `php`, a client asking for that file would see Here you are in the text output context, whatever you write will be outputted by the server without being interpretted. Hello from text. Hello from PHP Here you are in text output again. PHP was a serverside only language which started as a templating aid. Changing this behaviour would be such a big compatibility break, 20 years of incompatible code. Too big of a pain to change now. ---- Fun fact, the minimal hello world code in PHP is the following one ~~~~ start of file ~~~~ Hello world ~~~~ end of file ~~~~ No php at all.
Not judging the original poster’s intentions, there are variable variables in PHP. If I remember correctly, their syntax is: ${$foo} E.g.: $bar = 2; $foo = “bar”; echo ${$foo}; // prints “2”
I could make tests with 100% code coverage which doesn't test anything at all (even thought TDD). Also, TDD is not about tests and coverage, it's about design. 100% code coverage is meaningful goal. You could live with 80% coverage pretty nicely. 
The spin that this is done for security purposes is somewhat bizarre. You'd include/require a file that's from your source only, therefore trusted. "Injection" is not a situation that'd occur then. PHP has plenty of other ways to read a plain HTML (or text, or whatever) file already. If your source files are "injectable" (i.e. you embed user input in your source code, I mean... how crazy that sounds), then removing the tag won't remove that risk. People can still put *whatever* in your source files and make you run it. On the contrary, I think introducing extra modes and toggles and settings that change the default meaning of PHP source would make even experienced developers introduce security problems in their code unintentionally.
While your example seems a poor case for this, I think you're looking for variable variables. http://php.net/manual/en/language.variables.variable.php Roughly: for ($i = 0; $i &lt; 10; $i++) { $varname = "class{$i}"; $$varname = 'foo'; } ouput would be basically the same for ($i = 0; $i &lt; 10; $i++) { $varname = "class{$i}"; ?&gt;&lt;option value="&lt;?=$$varname?&gt;"&gt;&lt;?=$$varname?&gt;&lt;/option&gt;&lt;?php } 
Can you describe how it's supposed to be done?
Ah, got you! I see your point now.
It is to manipulate images and the interact with a remote server. If every controller had actions that did it, I'd do it once in a parent base class, and be done. Going the way of the trait keeps it from being in every class forever, while not requiring a developer to remember how initialize the functionality.
A quick Google search reveals a library that might be able to do what you want: https://github.com/Ne-Lexa/php-zip
well thats a bad start - composer require error: - Installing nelexa/zip (3.1.3): Downloading (100%) Failed to execute unzip -qq '/Users/me/Sites/dashboard/vendor/nelexa/zip/63a7829a088c1c52214da04b998b47ea' -d '/Users/me/Sites/dashboard/vendor/composer/2815f4c5' error: cannot create /Users/me/Sites/dashboard/vendor/composer/2815f4c5/Ne-Lexa-php-zip-171d4a8/tests/PhpZip/php-zip-ext-test-resources/bug40228?????????????????????????????????.zip Illegal byte sequence The archive may contain identical file names with different capitalization (which fails on case insensitive filesystems) Unzip with unzip command failed, falling back to ZipArchive class I've left an Issue for the contributor :(
You like to say "framework class". Are you sure that they are using framework and not library for that? I would like to see some example for that. Good frameworks are decoupled into specialized components, so you don't need to be coupled to whole framework for some simple thing.
I don't use any frameworks for anything and I honestly don't see the point. But then again I don't make very complex websites... yet.
Sorry for the misunderstanding, I definitely agree with what your saying. The best developer's I've come across always had great depth in knowledge that led them to a decision most would not have figured out. 
TL;DR: If you're a cunt to a open source maintainer, fuck off
If none of these other answers do it for you, the best hack I recommend would be to create a command-line script (batch or shell) that does what you need and call it from PHP.
Because how do you know there is only PHP in the file? In the end a PHP file is supposed to be an HTML file with PHP code embedded in it. Even today that is the most common way of using it (wordpress templates) The concept of a PHP only file is something that came in with OOP and the desire to have classes in separate files. But we just never had a strong need to change. There are two possible changes that can be made. I believe there is a proposed 'php only' mode that you can set in the php.ini. This was mentioned in a link to an RFC in this thread and is the only serious attempt to change it that I've seen. The other solution might be to have a different file extension for php class files. (.phpc or .pc) ? Either way its not really an urgent issue. 
Why target your software at people who can't install software?
Well that sucks :(
This is such a well written article and so true. Nice job by the author!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I think this comment misses the point of the article. 
Maybe the problem is "kids these days" never had to code in days without frameworks. Never had to experience the ~~awesomeness~~ that was PHP 4. But I am not sure about that, its just a thought. I agree with the author don't be a framework developer. Whenever I am talking to a recruiter and they say, but you don't have Laravel or whatever experience. I say but I have 12 years experience and have developed in 3 different MVC frameworks and a bunch of other non-framework code. I don't think I'd be in this field still if I couldn't learn something new. I also had a similar ah-ha moment on decoupled code many years back and I dislike when I see posts on stack overflow or slack chats where a developer decided not to go under the hood, but immediately to external help. On the authors point about interviews. We'll maybe the author is asking the wrong questions. I've never interviewed anyone, but here are the 4 questions I would ask. 1. What are some personal projects you are working on or have worked on? You better have some or I don't think you actually love programming. And if you don't love programming, then I am not sure I want you on my team. This question is really just designed to determine the candidates passion level for coding. If this is a junior or entry position, this a lone might be enough to hire them. If not mid to senior, read on... 2. Here is some code. Clean it up. Bonus points if they can talk about cyclomatic-complexity. The code is a single class that needs to be broken up into smaller methods. The class is small, under 100 lines. I'm just trying to determine if the engineer knows what clean code should look like. 3. Here is poorly performing application. Small code base and table foot print, with crap queries and missing indexes. I'm just trying to determine if the engineer can optimize code. 4. Small insecure application. Basic stuff like obvious SQL injection and XSS. This one might just be best covered by questions honestly, so coding exercise is optional here. That's all I really need to know about a candidate on a technical level. Do they love coding? Do they know what clean code looks like? Do they know how to optimize an application? Do they know about security. Nothing about a framework and no riddles about 3 pieces of rope burning.
As a senior dev and open source maintainer, a project without tests is a non-starter. Minimally all golden path methods/functions/execution needs to be tested. You can sprinkle tests regarding edge cases later or as bugs are found. If I don't see tests I am not using the project, nor am I recommending it.
My question got deleted because of my new account if anybody looking here, did you see this before? https://www.reddit.com/r/PHP/comments/7ugduv/is_it_just_buggy_windows_server_task_manger_or/
From my experience it’s not common. I chose to use Horde Imap instead, even though the documentation is a bit lacking(if you need examples look for imapi on packagist).
It's usually hard to read array functions one after another when it could have all been done with sql and pdo to get the data how you want it. I am also guilty of this. 
Yeah, I have to thank that man for not rolling out my own crypto when I was dumb enough to try to do so.
My understanding was its only because of historical reasons. When I started we used to write HTML, JS, CSS, and PHP in a single file and call it in a browser. The file will be named with a .php extension so it'll be parsed by PHP but PHP have to know which part is PHP and which isn't. so the &lt;?php ?&gt; made sense at that time. Now we're not doing it for the most part (templating engines, classes, objects) so I don't think this is required. But PHP considers BC as the main concern for making any decisions. so you know, you have to live with it.
Without frameworks we build nothing but a mess of mud and sticks. With a framework we build a house. So my question is this: do we build with mud or do we build with a framework? While one might make us dependant, it’s helped us move on from crumbling mud huts to more civilized dwellings. You’re rant doesn’t work. It’s just some one being angry at people who don’t understand how we came from mud huts to houses. 
Because some projects need it. We shouldn't have to port over code to Java to have threading.
Amen.
The problem was that they were not able to imagine that the class they're writing will live outside of the framework, or that it's decoupled from it. Decoupling as an issue was highlighted when they used static methods of framework classes, that were not injected into this class that they were writing. So now you have hidden dependencies due to the over-use of the ServiceLocator of this specific framework, as they don't even have a `__construct` method defined. Hope that clarifies a bit.
:o)
I'll be honest. If it's a project from ircmaxell, nikic or fabpot, a lack of tests won't stop me from exploring, using, squeezing...
I think that's just built up fake confidence. I wouldn't use my own shiz if it wasn't tested.
You want to download and try it? Cool, no tests are fine! You want to actually use it as a dependency: NO-GO.
TDD assumes that no code was written without a test scenario for it, therefore you will logically always have 100% coverage, and therefore coverage is a meaningless metric when applying TDD.
&gt; Whenever I am talking to a recruiter and they say, but you don't have Laravel or whatever experience. I try not to be _that_ kind of interviewer, and it annoys me that that is the standard "filter" on the HR end these days. We had a vague "minimum 3 years of experience in any MVC framework" as a requirement for a somewhat senior position. &gt; On the authors point about interviews. We'll maybe the author is asking the wrong questions. This is very possible as I'm a developer first, and HR is not on the top of my skillset. To your suggestions: &gt; What are some personal projects you are working on or have worked on? Yes, we do this! I also have them show me around the code, if it's not behind an NDA. &gt; 2. 3. 4. These we don't do, but I think we should. It's just pretty hard to set up good tasks like that, but I do think they're the way to go. What we did was &gt; "Here is an example Task/Feature in our project. Listed are the technical and business requirements. You have to write a standalone class that is decoupled from the framework. You have the following methods at your disposal, etc." And no, I don't ask them silly CS / puzzle questions. I don't think our approach is too bad but it could use some work. I ask them a lot more technical things during this live coding session which helps get a feel for how they plan out functionality. Thank you for the suggestions, I'll be saving this comment for later!
I know it's so wrong in every aspect. That's why I said I'll be honest, it was a confession :)
What could you possibly need threading for? Give me one good example where asynchronous code wouldn’t work?
Parsing multiple large responses at the same time, data aggregation, speeding up automation. People use PHP for more than blogs, you know.
I'm not advocating the non-use of frameworks. I'm advocating against the blind use of frameworks. For example: You're building a house. You've got machinery and tools that let you put up entire brick walls, tiled roofs and floors with little to no effort. But, you should also take time to learn how bricks should be stacked. You should learn what about the different kinds of roof tiles. You should learn how different construction designs affect the stability of the house.
While I mostly agree. There can be a need for threads in PHP, for example when making multiple database and HTTP calls asynchronously before passing data back to the view/browser for assembling. There are limited ways of doing this right now with curl multi or mysqli polling, but you cannot combine them easily with additional real async processing of the data. In general questions of the sort "i now need to query 4 data sources, wait for all the results and then re-combine them" are mostly built sequentially at the moment with lots of Waiting for I/O, leaving additional performance on the table. Your comment attempts to state an absolute truth that threading is not needed, the programming world isn't just so black and white.
&gt; Because how do you know there is only PHP in the file? Thats the real reason. The PHP interpreter could assume as much, and if that isn't the case, a parse error would simply tell you that you made a mistake. 
I second that! His efforts has been a tremendous help to me (and probably the community as whole, not to mention site owners).
A few years ago the company I was working at took over the maintenance of a Magento webshop. As we started looking into the code, we quickly realized that the developers who formerly worked on the code were both unfamiliar with the framework and basic development concepts as well. There were empty loops, several hundred lines long ifs that could only ever yield one result, redundant functions (such as a function called "false()" which simply returned bool false), entire modules that were enabled but never used, etc. I could go on, but suffice it to say that I was able to spend a day 'refactoring', when I didn't write a single character, just deleted over 4000 loc without losing any functionality.
&gt; Yes, it's not as useful for masters/seniors/rockstars directly Wow. I'll ask my boss to change my title to "Rockstar", it seems waaay better than any other title I ever had :D
Ninjas and Gurus are popular titles these days as well :)
Thank you, Marco!
notice your name wasn't on his list though xD
The kind of tests that are required depend of course on the type of project/library, so a bit more information would be helpful to answer your question. In general, 100% test coverage is not something you should aim for. I wouldn't recommend testing stuff like simple getters and setters (if you have those). Having said that, try to write tests that cover the different paths through your code. If a piece of code has two `if` statements (not nested), there are four paths through that code that you want to test individually. Also test any assumptions, unhappy paths, etc. Write unit tests for your classes, using [test doubles](https://martinfowler.com/bliki/TestDouble.html) for their dependencies. This will allow you to create isolated tests that cover just a single class, making it easy to pinpoint which piece of code is broken when one of your tests fails. This means you won't have to dive deep into the test or go through your whole codebase to find the piece of code that is making your test break. However, if those dependencies are outside of your control (i.e. an external library, database, etc.) just mocking them doesn't cut it. Your test double will be based on assumptions about the external dependency, and these assumptions may be incorrect, incomplete or they may change (for instance when you update the external library). To prevent this, you should write integration tests for classes that work with these external dependencies. However, as [this picture](https://pbs.twimg.com/media/Ci9dn7vWYAAGbuV.jpg:large) shows, writing just unit (and integration) tests is not enough to prove that your application/library as a whole works correctly. You'll want to write a couple of system / end to end tests to test the application / library as a whole. Since these tests run considerably slower than the smaller unit and integration tests, you don't want as many system tests. For writing unit and integration tests I use PHPUnit. I like Mockery for writing mocks and spies. You might also want to check out Behat for behaviour-driven testing.
Just parsers
Since it used the old behavior up to 7.0.5 and the [7.0.6](https://secure.php.net/releases/7_0_6.php) changelog just mentions security bugfixes, it's probably either an obscure security issue or just a quick bugfix because it's unlikely to cause problems.
&gt; it's unlikely to cause problems. It breaks code in my case :( "isset" behaviour has changed (an extra "isset" before the first "get") =&gt; BC ? 
I've got to ask: *Why* do you have side-effects in an `__isset` function?
You certainly aren't the only one, this was probably the largest BC breaking change in the 7.0.x cycle. This change breaks your code if you have a broken implementation of __isset or offsetExists. By lucky chance, your broken implementation did not produce adverse effects prior to PHP 7.0.6, because one bug (in PHP) cancelled out another bug (in your code). This issue was fixed (despite the BC impact) in PHP 7.0.x, because the null coalesce operator on structures using magic properties or ArrayAccess would not work as expected without it. Basically, due to the introduction of the null coalesce operator, people started (implicitly) using isset() a lot more than they used to, so this previously niche case became important.
[removed]
I take it you wish to use PayPal IPN. The best bet is to use cURL and pass in the necessary attributes, PayPal should then return a URL for you to access, in my case I implement header() to redirect me to paypal. I don't know if they still mention it on the documentation, but don't construct a HTML form, a cheeky user can inspect element and override the cost field.
Broken in the sense that the __isset implementation does not match the __get implementation, that is, it does not return true for all properties that __get supports.
ALWAYS hand over parameters to queries via prepared statements. No matter where they come from. No exception.
Fantastic, a quick visual check confirms that we don't violate that rule. Onwards with the upgrade! Thank you :)
There's also a [CLI tool](https://github.com/jonathantorres/construct) for generating PHP projects/micro-packages.
&gt; they still mention it on the documentation, but don't construct a HTML form, a cheeky user can inspect element and override the cost field. Uhhhmmm doesn't it have a signature?
Just use PDO. It’ll mostly stop you from doings bad things.
&gt;This extension was explicitly tested on Ubuntu 14.04 (32bit) what? why?
Was that ever explicitly a requirement?
Following their guides some time ago (I do add), it literally encouraged you to create a HTML form and then use their class. There was no checking to see if the cost you entered hadn't been tampered in some way. Hopefully they've corrected this..
For the sake of variety. The opcode instructions generated during compilation differ between 32bit and 64bit platforms. Since the thread creation logic performs opcode copying, I needed to test it on 32bit as well (OS X is always 64bit).
Test coverage is what you use after you've finished writing your tests to find the edge cases you missed
Did you google first? Check if this helps http://www.expertphp.in/article/laravel-5-multiple-images-uploading-with-drag-and-drop-using-dropzone-js-example
i understand you **also** would want a test on a 32bit system. but a big majority of php devs and servers run 64bit ubuntu/linux, so that would be a much more important test for me than the off chance somebody wanting to run it on 32bit.
Wise choice
Will Code Igniter dominate the web in 2018? No. Next question please.
&gt; If you do not do TDD, you probably... You've got a pretty a short sighted and arrogant conclusion there... and a LMGTFY link for resources. What a prick.
sorry now its public again
just made it private but then forgot it, now its public 
No. 
The conclusion was clear, just overshadowed by an arrogant delivery.
That is, care to explain what you even mean by that? I don't get it. 
This article looks like it was written in 2008.
I think the mot simportant thing is not to reinvent the wheel **but** understand how the wheel works and, in case you need it, have a clear concept on how to modify your wheel according to what you need
This is a terrible article, even for blogspam.
Its always the same article. Install AMP server, write hello world. Congratulations, now you know PHP. Why does this get rewritten 1000+ times? I'd love to see more personal takes on stuff like https://github.com/PatrickLouys/no-framework-tutorial or https://symfony.com/doc/current/create_framework/index.html
I must admin, this gave me a good chuckle.
Not sure if this is documented anywhere but the current semantics are the correct ones. Here's the code: &lt;?php class A { function __get($name) { echo "get\n"; return new self; } function __isset($name) { echo "isset\n"; return true; } } $o = new A; var_dump(isset($o-&gt;a-&gt;b)); When evaluating `isset($o-&gt;a-&gt;b)` it has to first check if the first property `-&gt;a` is set; this should call `__isset()`. In order to retrieve the next property `-&gt;b` we need to first get the result of `-&gt;a` which calls `__get()` and then calls `__isset()` on the result. The complete order is: $o-&gt;__isset('a'); $tmp1 = $o-&gt;__get('a'); $tmp2 = $tmp1-&gt;__isset('b'); var_dump($tmp2); 
First, thanks for sharing. I've been enjoying your recent posts, keep it up. :) Now for the article, I do agree that we should strive for complete coverage with a combination of functional &amp; unit tests... but I have to admit I'm guilty of succumbing to the "this is good enough" attitude as well; and I would make the counter argument that this is also OK. I've come to realize that for most developers, a robust test suite is a safety net. We don't need it to be in place to write some code or do a refactor, but it sure makes the task a lot less stressful when it's there! With that perspective, it's easy to see that you don't always need to maintain 100% coverage; just on the really critical/fragile areas. For this reason, I would say that coverage % is not meaningless. Like all aspects of life, there is rarely a black/white choice, it's more about choosing the shade of grey that best suits your needs. Of course you should take that with a grain of salt; if you are maintaining libraries that others depend on, business critical services, or absolutely must maintain a reliable SLA, then investing in the tests is a no-brainer... but to most of us, I would argue that there really is a value that equates to "good enough" for the purpose of providing peace of mind and sufficient safety. Did I completely miss the point, or does that make sense?
Makes sense. Thanks for the feedback!
does php have support for async? 
Awesome feedback! Thank you!
The semantics of `__isset` are the same as those for `isset`: It's exists and not null. As such, it is not necessary to do another `__get` call to check for null, as `__isset` must already check that. We *do* perform the extra `__get` if you use `empty()`, because `__isset` only guarantees that the value exists and is not null, not that it is truthy.
&gt; The property exists and is not null. ... but in order to know it is not null you need the value of the thing. What's the point of `__isset` + `__get` when in practice they will often have to do the same exact work? But yes, it's all a mess and not properly documented.
If this is because the framework of the other day then I believe the issue is the high confidence/self-steem that newbies programmers have, nobody can forbid them to share here, but they should know that there are experienced developers here(not me) and there is a standard quality expected. They should come instead looking for feedback/help/guidance not promotion as the project of the other d... 
Then you didn't code correctly :) even a beginner coder with the right path should be able to build a framework and understand what each component does.. or maybe I'm severely autistic haha but either way, I think it teaches you everything you need, CRUD concept, database design, mail, payment systems, all can be done with a custom built framework and for me that's what I love :) And if you make it then you test it along the way by building your own debugger class :) and no MVC isn't but you can use the concept (like everyone seems to do) to build your architecture. 
If your `__isset` returns `true` for a value that's `null`, your `__isset` implementation is wrong to start with.
I suppose the idea is in some cases `__get` is more expensive than merely determining whether the value is not null? E.g. `isset($object-&gt;lazyLoadedForeignObject)`: `__isset` can be implemented just based on `$object-&gt;foreignObjectId` while `__get` would have to actually do the loading.
Thank you for your feedback, I appreciate it. It makes a lot of sense that everyone choose what they see fit for themselves, their environment, and how they want to work and live in general. When it comes to the question of whether one does TDD or not, there are only two possible answers. Personally, I have decided to do TDD, but that doesn’t mean that I *always* do it. Doing it simplifies a lot of things for me: - all parts of the system I build become equally important (why build something that is not important, rather than picking a component) - discussions about what and when to test can be avoided - discussions about how much coverage is sufficient can be avoided - confidence in that the software does what it should can be increased I do not mean to require everyone to do TDD, I just found that *I* like to work this way. If I do, test coverage becomes a meaningless metric, if I don’t, it becomes a vanity metric, for the reasons pointed out in the post - either way, it’s meaningless for me. If developers (and their employers) are confident with whatever coverage they have from writing tests without TDD, that might be fine for them. Thanks again for your feedback!
The framework from the other day is a recent example, yes, but the "where are your tests?" feedback seems pretty common in this sub. Which is fine. I'm not a TDDer myself but I'm considering sharing a project and want to make sure I have at least _some_ test coverage. At the moment I'm just planning on providing unit tests for my public controller and service methods. Hopefully that'll be enough to start. As for whether a framework is considered a big project or not, I'd actually argue a framework is one of the easiest things you can write since it doesn't include any hairy business logic. Frameworks are basically just the request/response plumbing of your web app with helpers for things like database and filesystem access. Real-world business logic is usually where most of the complexity and messiness comes in, at least in my experience.
You should be banned from this sub.
I recommend searching for php interview tests. https://www.testdome.com/tests/php-online-test/30 Good luck!
Fair enough, in that context I guess I can agree for the most part. In my experience it's generally difficult to get everyone (devs/PM/stakeholders) on board with TDD, but if you can manage, that's great.
Yes. Via third party libraries though. It's not built in.
OOP is not a must. A lot of large-scale mission critical systems have been built in functional programming languages such as Clojure and Haskell. The more I learn about FP, the less I understand why OOP is widely regarded as a silver bullet for every problem that can be solved using code. In many cases, I think OOP adds unnecessary complexity and boilerplate. I've seen a lot of codebases in which there is a substantial amount of code about OOP instead of the problem itself. I'm not an expert on OOP and I'm sure there are valid use cases, but we should really think about *why* we want to use objects instead of plain data and functions.
It is for free?
So you have something that doesn't come into existence if you call `isset($foo-&gt;bar)` on it, but comes into existence if you call `$foo-&gt;bar`. That does look like a very unexpected behavior from the PoV of the user. I'd have probably written a dedicated function for checking if data is preloaded, but let `__isset()` and `__get()` follow standard PHP object semantics, rather than be burdened with leaky behavior.
exercism.io has beginner/intermediate tests for lots of languages. I use it whenever I need to pick up the syntax of a new language.
When I want to learn a language I always go with project Euler. 
&gt; and understand what each component does This doesn't require you to re-implement component to get what it does. You probably mean HOW it does what it does. For example - how is this magic dependency container automatically resolves dependencies using type hints and so on. &gt; it teaches you everything you need You could just implement projects, not frameworks. Or libraries if you like to work with infrastructure. Something more valuable, which will provide feedback from others. Which will evolve over time. Without evolution (constant changes) of projects, you most likly will not be able to analyse your architecture decisions. &gt; your own debugger class And then after few years someone told you that utils classes are bad practice. &gt; to build your architecture. This reminds me on how developers learns patterns. I like to split this into 3 phases: 1. Oh cool! Patterns! Now my architecture will be awesome since I put every pattern from GoF book it my project! 2. Screw this patterns! They just maid things worse! I don't know how to maintain all this! 3. Oh now I got it... patterns is just names for solutions, not a tool. I must understand problem so I could find correct pattern, or I could just try to increase cohesion and decrease coupling and still will get something similar to things described in books. 
/r/dailyprogrammer releases an easy, intermediate, and difficult coding exercise every MWF respectively.
Yes.
If you practice TDD strictly, as the author says, you're never supposed to introduce an edge case that a test doesn't exist for. The problem with TDD is that it relies on automated tests to scale. But you can't write an automated test for everything. Especially UI related.
You write your business logic as an independent library that you then expose to the framework. Your business logic library will obviously have dependencies on other libraries, including some form of database persistence. The configuration comes from the framework and you use dependency injection to wire everything together.
&gt; In my experience it ends up getting evaluated anyway in many cases. Not disagreeing. The interface suffers for a few edge cases.
I haven't seen much of other people's code so I'm having a hard time visualizing. Could it be something along the lines of: instead of the controller method having about 50 lines of code to create variables that are then sent to the view, the controller method only has 4 lines of code... AboutController::TeamList method creates an AboutLogic object and runs the TeamList method on that object which returns an array of team members which is passed to the view ?
Like Gordon Ramsay would put ever so elegantly: "YOU FUCKING NUMBNUTS. WHERE THE FUCK IS THE MEAT. THIS IS ALL FUCKING SEASONING! ARE YOU RETARDED?!"
You know what else is really cool. `use const false as true` yeah, that's a good one to drop in a file if you ever want to mess with someone.
That's a cool way to handle it. Thanks for the feedback!
&gt; ... but in order to know it is not null you need the value of the thing. You don't, because `__isset` is returning true. It can stop right there.
As the jerk who literally asked "where are the tests" on that particular project -- I can confirm that this was a major factor in the comment. 
Option 2 would be much faster.
Haha, please don't take it personally! It's a fair questions/critique, it's just made me overly self-conscious before I share any source repos on this sub ;)
&gt; websites using ~~Astalavista~~ AltaVista search engines!! FTFY
If you are not presenting a production product, some is probably enough, especially if it is an add-on "feature" library. When I check out a github repository, I want to see signs that the project uses best practices and common standards -- Composer, PSRs, tests with a phpunit.xml file, and a common directory structure. If you want me to use your code, show me that you took time and care in creating something that I don't have to worry about debugging. I think there is a higher expectation on tests with frameworks in particular -- nobody wants to build their project on top of a code base just to find critical bugs -- especially security bugs -- because the developer didn't take the time to test write a happy path test.
Attitude goes a long way -- just don't bill your code as modern, high-performance, or production-ready if it isn't. Ask for critiques and code review before promotion. You could even post the project without any tests at all, as long as you explain that you are currently working on tests or that you need assistance with them. Also, when posting something that looks on the surface like "reinventing the wheel", it's really helpful if you say what the project does differently than the standards.
initially PHP was designed as a template engine for html pages. So you are passing dumb text files to PHP interpreter. PHP interpreter will only kick in when it detects &lt;?php token.
&gt; It's frowned upon now, no amount of classes,OO or autoloading will change the fact that PHP is first and foremost a templating language for text content.
And this will be quite noticeable with a dataset of that size: in_array is O(n), while isset is O(1). [Further reading.](https://stackoverflow.com/questions/13483219/what-is-faster-in-array-or-isset)
Use `array_key_exists` since it doesn't care what the value is (whereas `isset` specifically doesn't requires it's not NULL) if (array_key_exists($key, $array)) { // Do something with existing data } else { $array[$key] = uncachedLoad(); }
Hash is much faster because it doesn't need to look at every item in the array like in_array does.
[Here's the same code with `$name` in the output](https://3v4l.org/Tl57n), for slightly better clarity.
I have read this 3 or 4 times over the past few days and will use it to get me started with Xdebug, which a dev I work with uses occasionally. Many many thanks for your patience and clear explanations! You've helped me get over a barrier I think! :D
a lookup table should *always* be a hash table. 
Alternative suggestion: do you _need_ to use an array with 19,000 items to check existence? Could a SQL query or similar give you the same result without need a large memory overhead? Just food for thought - I can imagine scenarios where either are the better route.
THERE IS NOTHING TO FIX.
Way overthinking it. 😋 return $str === strrev($str);
Ha! Yes I guess thatd do lol!
Hah, that's exactly the first thing I did. And you know what's fun? 3v4l.org recognized our snippets were the same and gave me your URL.
You could always get the host name in the entry app and pass it to the AppKernel or get it in the AppKernal, translate it to a better version you can use in a filename and create config yaml files for each host name? * `config_hostone_dev.yml` * `config_hostone_test.yml` * `config_hostone_prod.yml` * `config_hosttwo_dev.yml` * `config_hosttwo_test.yml` * `config_hosttwo_prod.yml` Those would extend the config yml appropriate to the environment then you would only need to put those variables you need to override in those.
.env files are used in the lower environments. They are not meant to be committed to your repo or deployed to production. 
Yes, definitely. It’s even cleaner to do it in the AppKernel, but that still leaves the main problem of console commands that don’t pass through the front controllers because they’re not HTTP requests.
It depends on what specifically you're trying to do but console commands could be left to just relying on the environment. For console commands you you create in your app, you could add parameter in the config file specifying a site identifier. **config_hostone_dev.yml:** imports: - { resource: config_dev.yml } parameters: site_id: hostone.com database_name: symfony database_user: symfony database_password: symfony Then in your command you can get the site_id parameter and process appropriately.
You are correct, but you do include them as part of your deployment.
True. What about the scripts that fire after composer install and update commands that rely on those environment variables to build the cache?
Well yeah it is, but Magento does it too and they have done a rewrite recently so its probably more common than you think.
Yes but you can still use environment variables to solve your problem.
Yes, it's a shame that we still have developers that don't understand separation of concern.
Use env variable and set them in your apache virtual hosts / nginx server blocks
What about deploying one "application" for each host? Then you wouldn't have to worry about messed up cache and config files would be a breeze 
Correct me if I'm wrong but can't you pass the environment into all post-install /post-update scripts?
Maybe that’s what I’m missing. I’m not sure how. As far as I can tell you can’t call composer install —arbitrary-environment-variable=foo as part of a deployment script.
That works fine for http requests but how do you handle console commands and composer scripts that build cache that never touch the web server?
Maybe I don’t follow. How do I use environment variables set in vhost files that work with console commands and composer scripts that never interact with those vhost files?
I haven't set up an install like this for a while now but if I remember correctly you should be able to pass a Symfony environment into the install command ('SF_ENV'?) and run all the scripts that are within your 'post-install-cmd' section of your composer.json
Yup, definitely true... 
THIS.
Score a bowling game where your only inputs are 11 to 21 quantities of pins knocked down within the constraints of the rules. Harder than it sounds. 
MY_VAR=value php bin/console my:magic:command ?
As many comments already said, the tag itself comes from a time when php was used to enhance static content (in order to make it dynamic content). Even if you as a developer only use pure php files, you may still also use html+php mixed code, even if you don't know it. What I'm referring to is **template engines which utilize html+php mixed files to cache your views**. This will make things like setting a flag in your php.ini to tell php you're only having php code in your php files more error prone. And as for your JS example this is only valid when you're using node.js and similar which are still pretty young techniques. You cannot do something like this in your html file: const greeting = 'Hello World'; &lt;p class="greeting"&gt; ${greeting} &lt;/p&gt; When injecting a JS file to your html you still have to use a *&lt;script&gt;*-tag which is similar to writing *&lt;?php ?&gt;*. And yes with modern browsers you can omit the *type="text/javascript"* attribute but it is a browser implementation.
Just use versioning. You can look at old commits to see what garbage it was before (which I do sometimes myself) and have a clean file to work with :)
I think you can use swoole as itself without php-pm.
As all other benchmarks with ab or stage i guess. It's just using react to have whole application bootstraped just once - this is where most of php applications fails in performance. On each request php needs to create whole application all the time just do handle one request, it's stupid.
"Heavy" is not a number. And 300,000 is an absolutely trivial amount of records for any database, including MySQL. Heck you can also use SQLite if you want. Don't overcomplicate everything, and keep Mongo away until you know why exactly you need it.
Will this benefit long-running efforts for PHP?
Thanks for reply but i am confused about database. I have existing site which contains records more than 300000 and fetch records from multiple tables at same time, from this db query takes long time to fetch records. I am using mysql db right now. That is why i am asking If i use mongo db or any other db for fetching records only to improve retrieve time. Thanks in advanced
I'm glad it helped. I struggle with writing, and it meant a lot to get some encouragement for my writing being helpful. Thanks!
300,000 rows is very small. If your queries are slow, your problem is almost certainly either bad indexing, or you're suffering from the n+1 query pattern. Read this site start to finish - it will be time very well spent: http://use-the-index-luke.com/ Buy the book while you're there.
Don't limit yourself to PHP books. Check the [resources](https://patricklouys.com/resources/) page here. Apart from my own book (which I put in there for obvious reasons ^^), none of the books are specific for PHP. But you will learn a lot from reading them that will directly apply to your PHP code. 
don't know about books, but it all depends on your level. Have you programmed before? What other languages do you know etc etc 
As others have told you, and will tell you, it's not the database product, it's the schema and indexes. You need to understand how to use MySQL properly before you try other products, or else you'll end up with a slow product again.
I've been programming at a hobby level for about 20 years. i am in no way an expert on anything, and my interests have moved all around the place. I am most comfortable in Lisp and C. I like playing around with Ruby, never bothered much with python. I'd say I know C best, with Lisp a very close second. I have never touched PHP.
O'Reilly has published a book entitled Modern PHP by Josh Lockhart which is a good guide to modern PHP. You'll probably need another book to take you to the point of making use of Modern PHP though, as it's aimed more at existing developers.
You should check what are the most used operations. For example, are you using heavy SQL structure to select data and are you updating the dataset a lot? Can you use both? For example you can handle the "usual" data like users, groups, heavy edited areas with SQL (with good indexing of course) and leave to Solr / noSQL database the burden for fulltext search area which needs really huge amount of work and indexing.
isset() is faster however.
What's so important that it needs to be defined globally? I avoid those things altogether as they make my code unreadable and/or error prone. 
Do you need any kind of relation? Choose MySQL. Is it important that you are 100% sure, that everything that get's saved into the db is really there? Choose MySQL. Do you need trasnactions? Choose MySQL. MongoDB, imo, has a limited use case. People often use it for the wrong use case, e.g. having the complete project in MongoDB. Normally I would recommend to have a relational database and just for special use cases use a NoSQL database like MongoDb. The thing is, for most use cases you won't need the performance boosts of MongoDb, because most of the time you don't have enough data that it will make a difference. 
Star building stuff, practice is the best way to learn! While building and a question comes up, check the php documentation (php.net). Read books about best programming practices, even if it’s not php, try to understand the concepts! Also check out “Php the right way” (http://www.phptherightway.com/), it’s a great reading for modern php. If you’re using a framework like Zend, Symfony, Laravel, make sure you check it’s documentation so you can enjoy every feature available. So I think that’s pretty much it! Don’t forget to use a versioning tool! 
[Laracasts](https://laracasts.com/)
In procedural it works quite well, in OOPhp you might get some issues with getting globals into the objects scope reliably. In procedural, I usually go for one global array that stores variables, so I have fewer variables to take care of. In oop I'd go for a singleton storing that same array. It's pretty easy to get an object into another object, so I often use that. 
buying language specific books is useless imho. read stuff like [The Pragmatic Programmer](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer), Clean Code and [Design patterns by the Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns)
You raise a good point, but I'd use a hash typed store, such as ddb or even redis.
You could call your php file .txt if you wanted. As long as your server knows that it should process it as php it will try to. Since php is executed on webservers that usually have other code in form of plaintext lying around, the compilers need some way to distinguish between different types of code, without having to wait for the compiler to throw an error. So unless it's inside of php-tags, php will not be executed, just like JS will not be executed if it's not inside a code-block. If it wasn't like that, making a page that teaches you about coding would be a pain in the butt... Just imagine every time you wrote "echo", the site would attempt to echo something.. 
Care to give an example?
+1 for this book. Because it's a book I think even the most current version is out of date but it's still a good read as a starting point for more research.
"books" and "modern" do not seem to work together that well anymore. Books take years to write. That's usually when "modern" starts becoming old-school. At least in languages that evolve that fast. Imho, you can get to "5 years ago" with books, but if you want to get to the latest you'll have to go for the same sources the people that write those books go to. The internet. /myfewcents
http://symfony.com/blog/new-in-symfony-3-2-runtime-environment-variables https://symfony.com/blog/new-in-symfony-3-3-dotenv-component 
[removed]
It's interesting. You probably didn't get a lot of comments because the output says almost nothing to PHP developers. 
The second release was February 2016 so it's at least two years out of date (probably a bit more - I'm not sure what the lead time is from completion to publication). A lot of the advice is generic though and so still relevant today.
PHP 7 Explained by from makers of PHPUnit is pretty good. I haven't bought it myself but have read a few chapters and they are pretty good. I read that the organization of topics could be improved, but if you are up to date with PHP 5.6, this book will be very useful. 
With the JavaScript example I meant I can do something like this in my html: &lt;p id="greeting"&gt;&lt;/p&gt; &lt;script src="app.js"&gt;&lt;/script&gt; Then in app.js I can do: const greeting = Document.getElementById('greeting'); greeting.style.color = "#000"; No need to add any opening or closing JS tags like `&lt;?js ?&gt;` because the browser knows it's just JS. But it makes sense that it knows it would only be JS opposed to PHP not knowing if you're doing only PHP or a .php file that is an interwoven PHP/HTML mixup. Where in JS you'd have to output all HTML as strings which would still be valid JS hence not requiring the explicit statement of telling the server when JS begins and ends. Thanks for the reply. This has been an educational post for me! 
If you know C you will find PHP a breeze. I would also suggest you look at Python and Javascript . All these languages feel like extensions/higher level scripts of C with oop thrown in.
That doesn’t apply to production environments OR composer scripts.
SOY UN BOLUDO!
If you can't write an algorithm, you will not get very far as a programmer. Unless you mean a particular sort of algorithm?
http://www.phptherightway.com/
This question makes very little sense. An algorithm is a set of rules for certain outcomes, or results. So basically, an algorithm is anything within programming. If you mean mathematical algorithms, it's pretty much enough with plus, minus, division and multiplication, for non-advanced calculation software. Basically, when you start programming, you'll learn about conditions, and later how to structure these conditions into a more complex but objective way. As a regular programmer, it's very dependent on the task. Some programmers never work with advanced math, some do it all the time. So depending on your interest and which area you want to be programming in, all you need is logical thinking and an understanding on how code is executed. TLDR, yes, you need to know how to setup rules and conditions to determine the outcome of something, but that comes naturally when you start understanding what programming is.
Yeah but an algorithm is just a piece of code that solves a problem. Most of us build that everyday...
algorithms are the bread and butter of software development. Hell, a nested for loop is an algorithm. asking "do I need to know algorithms to be a programmer?" is like asking, "do I need bricks to build a brick building?" The only correct answer is, "Of course, how the fuck are you going to do without it?"
Def check out https://patricklouys.com/professional-php/ You put together your own framework components step by step. Very practical and up to date with the latest standards!
&gt; "Modernizing Legacy PHP Applications" I don't think that is something you need when you start out fresh
I want to answer this for you, bu I guess I'm curious about some things. What is your end goal of learning PHP? If you want to build things with it, then you may be asking the wrong question. Disclaimer: I'm gonna try not to dive into too much detail and keep it kinda like an ELI5 answer. Generally speaking when someone uses the word algorithm what comes to mind might be 1337 hackers. We always hear about Google or Facebook changing their algorithms, heck it even gets news coverage when it happens. So algorithms must be super important right? It only makes sense based on these things, but not exactly. There's a meme that Algorithm is just a word programmers use when they don't want to explain what they did. It's a good meme IMO, because often times when the word is used a lot of details are skipped about how something works. Ultimately algorithms are just the logical pathways that a program can execute upon. No matter if you're dealing with OOP, functional, etc anytime you're write code that changes behavior you've just changed the "algorithm" of that app/program. So ultimately in the real world what 'learning algorithms' means in the context of PHP is being familiar with design patterns. There are [a LOT](http://www.phptherightway.com/pages/Design-Patterns.html) [of](https://www.ibm.com/developerworks/library/os-php-designptrns/) [good resources](https://github.com/kamranahmedse/design-patterns-for-humans) [out there](https://github.com/domnikl/DesignPatternsPHP) that teach programming design patterns using PHP code for examples. A lot of these focus on OOP based patterns though, so that may or may not be what you were expecting. If you're looking for more general 'algorithm' knowledge then that mostly comes down to what you're trying to accomplish and how. There are usually multiple methods (or algorithms) that you can use to accomplish something in PHP, knowing which ones to use when generally comes down to practice and experience. So go start building stuff, make mistakes, learn the hard way! It's the best way to commit these things to memory.
Yes, I currently separate the compiled containers by adding a host specific environment variable to cache and logs directory methods in the app kernel. All of this works fine for http requests, I’m struggling with console and composer related processes that don’t touch Apache.
In the console I would add a mandatory `--host` option, that way you are sure you always control what happens. I would also disable Composer scripts and run then manually, or edit the command to run as many times as there are hosts (with the `--host` option).
Set the environment in them too (I'm not sure how they can depend on domain name though)
Small correction: Peachpie doesn't transpile, it compiles PHP to MSIL.
I want to suggest you instead pick a technology like security, cryptocurrencies, video streaming, image optimization, http, marketing(?), I don't know what you can do knowing "php" or "modern php", installing a framework? update the dependencies? update the templates? Perhaps this last one and you will use more javascript,css or even js frameworks like vue.js/angular/reactjs...
The most easy way to write websocket server in PHP: [Swoole PHP web socket server!](https://www.swoole.co.uk/docs/modules/swoole-websocket-server)
&gt; technology topic
Code Complete The pragmatic programmer Clean code Higher order perl (its for perl but easily translate to php, also its available free just Google it)
I agree i don't usually require my devs to have over 80% unless it's critical biz logic. Often the returns are diminishing beyond that
I just have an example env file and include comments
Probably also want to look at http://www.phptherightway.com/
Symfony now supports [lazy loading of commands](https://symfony.com/blog/new-in-symfony-3-4-lazy-commands).
Hmm, I see... I don't quite understand how it works though, the API is still the same. How would you go about using this outside the framework?
For anyone else like me thinking "what about non-Symfony apps?!", [they have you covered](https://symfony.com/doc/current/console/lazy_commands.html).
Zend serivcemanager and Symfony console are both individual components. You are not bootstrapping an entire framework.
I meant confused as to why you can't have a file that is just PHP without the tags. It's obviously the smallest of "gripes" (if it even is a gripe). I was just curious as to why the PHP only (ie no html or anything) isn't just assumed to be all PHP unless otherwise declared. For example, I work on a product that is built on PHP and many of the files are pure PHP with zero HTML or anything else (unless it's in the form of an echoed string like `echo "&lt;h1&gt;Goodness Gracious&lt;/h1&gt;";`). It definitely makes sense that PHP came from the interwoven HTML past, but seems like it wouldn't be so necessary to specifically declare PHP unless it is going to be interwoven. It's definitely a non-issue though lol. 
so I should rewrite to "why would you need components for a console application"? I guess my idea of a console application is just a bit different - I recall my criticism
I posted a question on the article seeking clarification on what distinguishes a proper console application from an improper one. I'll update if I get a reply. And realistically speaking, even if you used the complete Symfony framework it really would not make much difference. Especially if you needed database access or similar services.
I got it. for me, php is perfect for web but that's it. I know it has some os-core-stuff but I'd never write more complex things like irc-bots, web-scraper or such stuff in php. I can see the need for components if it has to be a lot more. 
Sure, I see what you mean there. For me, I use PHP console apps to run maintenance commands on my web app, like clearing caches, sending spooled emails. I doubt I would ever use one as a standalone app.
PHP was born as a templating language. So, it was more common to have HTML with little PHP than PHP-only files. To give you an example you might be familar with, until a few years ago you'd see &lt;script type=text/javascript"&gt;, but do you know why? What else could be in a &lt;script&gt; tag? I have more, this one is interesting: do you know why all code editors wrap text at 80 columms..?
if you have LISP experience check out ["higher order perl"](https://hop.perl.plover.com/book/) PHP and Perl are similar enough it will easily transfer. it will show you how to write lisp style code in PHP 
When was the last time this was benchmarked? Maybe we should run some commands things have changed a lot since PHP7
This looks like the go to for in depth, knowledge expansion. Thanks.
I don't know. `isset()` is inherently faster right now because it's a language construct that has its own opcode, whereas `array_key_exists` requires a function call.
Just in case anyone is wondering, according the the author: &gt;&gt;&gt; By “proper”, i meant to provide an example that could be implemented in a real production project. &gt;&gt;&gt; Also, other tutorials I found just explained how to register commands. I just applied DI and provided PSRs. All the commands you create are services that you can use in other projects. I find the notion of being able to share commands between projects to be a bit far fetched but okay. Sort of like trying to share controllers.
Ah, that makes sense too.
When was it hard to do?
Haha, I actually JUST learned about the IBM punch card creating the 80 column standard we use today, a couple of days ago. It was a random fact on a developer's blog. And that makes sense. If it's more common to have the interwoven then why go through the effort to remove the required tags considering how minimally inconvenient they are. Thanks for the replies!
It just wraps the command in a proxy class that, when the command is executed, it will instantiate the actual command. You can do the same in Symfony DI wiring by marking your service as `lazy`. 
For structured and/or relational data -&gt; SQL For unstructured and/or non-relational data -&gt; Document store Your default position would be SQL unless you have a clear argument on why SQL doesn't fit and a document store would be the solution. Never use a document store as your primary database. 
I encountered similar problem recently. Since the two instances of the same app had slight changes in my case, i made one "core" app and two separate projects for each hosting/domain, i put a "core" app which contained all the bundles as a private package on bitbucket and put it as a dependency in composer for my two new projects. I manage config separately and when i update my codebase, i update composer for each one. Works fine for me.
Yes, I already do something similar. The problem is the symfony-scripts defined in composer.json call bin/console commands, which then don't the required --host option. So you could copy the relevant script files out of the vendor directory and into your project to customize the relevant methods, but that feels hacky and doesn't work well if those script files get updated in the future and you don't realize. I'm talking about these scripts: "symfony-scripts": [ "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters", "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap", "AppBundle\\Composer\\ScriptHandler::clearCache", "AppBundle\\Composer\\ScriptHandler::installAssets", "AppBundle\\Composer\\ScriptHandler::installRequirementsFile", "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::prepareDeploymentTarget" ], 
Where is the line that recomends to use python?
If you are using web interfaces to build a website sure it doesn't make sense, but if you are using Composer, building the application with framework and libraries you ought to touch the console and using another language for it would be very tedious with little values
Full disclosure: I'm one of the organizers. That also means you can ask me questions and I'll check back here periodically to see if I can answer 'em.
Works fine for http requests. Doesn’t work on the cli or composer scripts
this can be done in laravel or any other MVC framework. the fact that many people don't isn't the fault of the framework, but rather how they are taught
Do you have an example of what you are doing instead? I essentially use these defines inside something like a `config.php` or as an alternative to a `config.yml`. I suppose I could add some indirection.
it's in library code that is meant to be shared, with the goal of simple configuration (that I'm going to document at some point :-) ) But also bootstrap for a software front-end platform in PHP. It's just config data, so I suppose I could wrap it up in a config interface and just have the reference implementation use defines. It's just in-house atm, but the goal (for the past 3 years) has been to release bits as open source. The premise was that it would require less indirection than a config interface, so it helped us build fast. None of the defines are supposed to change throughout the lifetime of an account, and if they do, we'd alter a config and restart (currently a docker container). 
There are a lot more speakers than I expected. How many people are expected to attend the conference?
Would be great if, all in, we hit ~225 attendees (that number includes sponsors and speakers). which is comparable to what Lone Star PHP hit historically. We have a few tickets to sell between now and hitting that number though :)
Set the full path to the python executable in your .env file and reference it that way.
using symfony console component alone is sufficient to build console app, that not tied to symfony app
I don't think it's in the cards for this year, unfortunately. Recording at our venue (you have to use their preferred provider) for this year is quite expensive, so it would take a full complement of in-person tickets plus a bunch of sponsor money to make that happen.
&gt; irc-bots, web-scraper or such stuff in php. Would you mind further elaborating on this point? 
If you want a simpler solution for CLI applications try out Silly (https://github.com/mnapoli/silly), it’s a micro framework built on Symfony Console.
Easy... I don't know, that's relative I guess. If the IDE inserts it for you, and then folds it, it's easy. IDEs have spotty support for this. Some offer it as an option, some don't. Those that work in VIM and similar editors won't appreciate their source files being half function imports.
&gt; Those that work in VIM and similar editors won't appreciate their source files being half function imports. Be careful with that logic. I've seen people make that argument regarding docblocks, and it usually doesn't end well.
Doc blocks have a purpose more substantial than "hey, I'm using that function maybe". And I don't understand the "be careful" warning. There *will* be great resistance to such a change in PHP. How it'll be explained will vary, but if this vote passes on first try, I'll eat my hat. That said, it's interesting to see this RFC even exists. Maybe the tide is turning. Slowly.
If your stack is PHP and your team consists of PHP devs, you use PHP for these things. Typically scrapers, IRC bots, etc., aren't good examples as those are usually written as non-interactive daemons. Without getting into it deep with ncurses, urwid, etc., for a little bit of interaction, Symfony's Console stuff is good enough for PHP--especially to get something minimally viable in place.
With good code there shouldn't be a "maybe" involved. If there's a maybe, it means there are unnecessary imports where those functions are unused. It also means the developer couldn't be arsed to take the 10 seconds to run their project through PHPCS/PHPMD. If I take your point correctly, the unused imports would contribute to their problem in the first place. I would argue any resistance to that end is misplaced; bad code is still bad code. I think we're in agreement that the language cannot make up for misuse by the coder. I'd love to have this pass. When I review code, quickly browsing imports is my first stop for understanding responsibility concerns. That being said, eliminating the fallback and making function imports explicit only helps with review. I feel for the guys who are still writing out stuff procedurally though--they won't like this at all.
most fixers already have rules for this (and they integrate with editors ;-) )
I think this is a great idea, but my god, can you imagine it with WordPress or some other garbage procedural code that does everything with root scope function calls? Not going to be fun. I don't know the technical details of why this is necessary, but could a compromise be that built-in PHP functions don't need the root namespace prefix, but user-defined functions do? What about a wildcard syntax that imports every function defined in a namespace? e.g. use function \App\Helpers\*; 
If you do everything in the root scope, then no imports are needed at all...
&gt; With good code there shouldn't be a "maybe" involved. If there's a maybe, it means there are unnecessary imports where those functions are unused. It also means the developer couldn't be arsed to take the 10 seconds to run their project through PHPCS/PHPMD. If I take your point correctly, the unused imports would contribute to their problem in the first place. I'm not playing shoulda/woulda here, I'm telling you what's the actual effect of these lines of code. Your advice also has a downside - it makes code diffs much noisier than they would be if you clean-up imports slightly more conservatively. &gt; I would argue any resistance to that end is misplaced; bad code is still bad code. I think we're in agreement that the language cannot make up for misuse by the coder. I'd love to have this pass. When I review code, quickly browsing imports is my first stop for understanding responsibility concerns. Well you won't be seeing that as cleanly anymore, as 80% of imports will become functions like `count()`, `implode()` and `trim()`. What responsibility do you see here? "The responsibility of working with arrays and strings". What an insight.
Never underestimate someone's ability to make things hard.
Anyone unaware, `friendsofphp/php-cs-fixer` has got [this](https://github.com/FriendsOfPHP/PHP-CS-Fixer/blob/v2.10.2/src/Fixer/FunctionNotation/NativeFunctionInvocationFixer.php). 
Wow, you chose to call your conference *Longhorn?* The codename of the failed Microsoft Windows edition? How apt.
unless they use version control and immediately spot the difference
Here is the actual code with comments : https://i.imgur.com/BNNgzJP.png The problem is that any command that i pass to the exec function simply does not work. If i run these commands manually on a command line, it does. It's not a problem with Python and my path variable, i don't know what's the problem really. On my mac everything was working. 
How many functions other than native ones do you use? What year is it?
Very few, and mostly because function autoloading is not really possible until this is fixed.
I feel this is a larger change than a 7.2 to 7.3 version would imply, if it comes along function autoloading.
Importing static class is basically the same as importing function namespace.
Anything that makes the engine stricter and therefore presenting less surface for unexpected quirks is a good thing in my books. I wonder though, isn't the more "obvious" long term solution to this particular problem to depreciate namespace level functions entirely in favour of static class functions and treat every other function call as if it was FQ? I know it feels a bit java-ish but it would fit in well with existing autoloading. 
I've always liked the idea of a global array that you can access from everywhere. Imho it combines the benefits of define with the benefits of not having each variable be its own global. You can use array in procedural or an object in oo, so it's useable in many applications. And you can just load that config-array or object through a config-file. But I never really liked the syntax of define. I felt it was clunky and it took me too much time to write a config-file. Arrays and objects are faster imho. 
Bye bye php.
Indeed. The article that /u/ahundiak posted, though, showed an example of lazy loading using Symfony’s container. I wanted to know if lazy loading could be done outside of the framework, which it can.
Sounds horrible, having to `use` a ton of built-in functions or litter your code with slashes.
Don't knock Austin's scenic vistas 'til you've tried them. Though I'm afraid if you're looking for the authentic out-of-memory experience, merely attending the conference won't be enough. You'll also need to open Slack.
Laracast on OOP in PHP might help.
I'd rather see this as an optional `declare()` directive - as it is now with strict types. Breaks too much and I feel the gain is very little for this to be the default behaviour.
Deprecation warnings don't matter, and the RFC states that they'll most likely be removed (if ever) in the same step that introduces function autoloading. I don't see the problem.
use {your, head}
well if I need console, my stack is definetly not PHP. but yeah I got the point 
that depends on what you think is the next step in complexity. tbh I did write something more complex once - a bot to play a specific online game. just the part to crack the captcha for the login screen took way too long in php so I had to outsource that to a small C program. when I needed that all the users my bot commanded had to collaborate (unsuspiciously of course) that meant not waking up randomly some php script which runs for a few seconds but have like 30 php scripts running 24/7 and although php has indeed an ipc/shared memory it is just harder to implement such stuff as lets say in C and don't even look at that memory footprint. (ok last one could be better with php7) so that's one (very specific) case. What you'd say is more complex but a walk in the park to implement with php? 
We can't have a bunch of nice things (including std library functions with good names and sane argument ordering) until this is fixed. 
Vim user here; disagreed. There’s already enough use statements for OOP stuff that a few extra lines certainly won’t bother me. 
You misunderstand. This is simply emitting a warning which based on the mailing list discussion is likely to have as severity of `E_STRICT`. It is not proposing function autoloading but is demonstrating that if we have function autoloading *at the time we remove the feature which is not now* it can be leveraged to minimize backwards compatibility issues.
I'll just use { a, sane, version, of, PHP, that, won't, make, me, completely, hate, my, life, as, a, developer };
Thats not the point though. The path is not only environment specific, it's also dependant on the context of the process running php. By using .env to set the full path you wont have any of these problems.
That's like people who say PHP looks like shit because $variables start with $.
&gt; &gt; &gt; Each negative comment has 2 parts. The underlying criticism and the way it is transported. Always ignore the way it is transported, but never ignore the underlying criticism. ... but only if you assume good faith, which isn't always a given. See also: some of the regular trolls on this subreddit who never contribute anything of value.
The previous developer (well, he wasn't really a developer, just a manager who was drafted into doing dev because there was no one else) had spent a decade copying and pasting files for an event that occurred about twice a year. So...30ish PHP files, each about 400 lines, and the only ACTUAL difference was a date in the page title and table name. Spent about 10 minutes cleaning it up, saved about 13,000 lines of code.
you're not wrong, but that wasn't really the point of this post/thread. OP was just pointing out something they learned and I was sharing a similar feature that can cause odd behavior. despite using a VCS this is still an odd functionality and could confuse someone. i will concede that a dev's instinct should probably be to check VCS which would make it obvious and short lived.
That's good to know, thanks for sharing.
This could be an interesting way to fix the messy standard library, by using a new namespace (for example, \PHP). No more inconsistent function names or different order of parameters.
I thought the point of using environment variables was to not save config in files. 
If a troll wants to mess with you and happens to point something out that you actually did wrong and could improve on, why not acknowledge it and try to improve? Point being: The intention of the person criticising you is not important and should not matter to you. What should matter to you if it is actually a valid point or not. Unless you have a deeply rooted desire to lie to yourself and make yourself believe that you are the greatest person in the world (for example Trump), you are very likely to know when you did something you do not feel proud for. Imho, that information is all that matters. Best intentions don't make bad criticism good. Worst intentions don't make a good point invalid. 
If someone has access to your php runtime, you're screwed anyways... So I never really understood the idea of constants. It used to be a benefit when memory was expensive, but it's not really a security benefit whatsoever. if someone 'evil' has access to your server and can insert code into your work, you have a real problem that constants won't help you with. And if you coders are so unreliable, that you can't rely on them not changing a value that should not be changed, you are in a similar situation. I might be wrong on that. But personally, I just don't see any real benefit in constants. Not today, where ram and processing power do not require bit-wise planning anymore. 
&gt; If a troll wants to mess with you and happens to point something out that you actually did wrong and could improve on, why not acknowledge it and try to improve? That's not what I'm talking about. Trolls who **actually** point out something to improve can still be useful, sure, but there's not much you can learn from someone who just wants to make easily-debunked false accusations about your character.
Well, if their criticism is just wrong and stupid, there is no valuable information to gain, so you can ignore that part. And the other part you just ignore by default. You can take your curiosity a step further and investigate. But that would be an entirely different action, independent from the criticism and how you react to it. 
The point I'm getting at is, the best way to deal with haters is to ask questions. If they're truly interested in positive contribution, they'll be happy to answer them. Otherwise, you can filter the assholes out.
How?
Are "array" and "string" valid namespace names? "string" I can see but array is a keyword and I am doubtful.
Arrays or str, whatever. Also, if it's for the standard lib, I'm sure something can be figured out 
Alias them all onto objects like ArrayObject and you're half way there.
`use` statements are always referring to root scope, so the leading `\` is not needed. Same goes for symbols references in strings.
/r/drupal
can you elaborate what you mean by "oop logic"? never heard this term.
More information needed, please elaborate
+1 for netbeans, one coworker uses it and seems pretty powerful
Here goes. My whole 'common' library is available on [Github](https://github.com/c00/common). I use it for most of my new projects. It does a bunch of things, and has a quite nice query builder / database thing. But what you're looking specifically is `AbstractSettings.php` which is [here](https://github.com/c00/common/blob/master/src/common/AbstractSettings.php). An example implementation is then: &lt;?php namespace c00\someProject; use c00\common\AbstractSettings; class Settings extends AbstractSettings { public $debug; public $dbHost; public $dbUser; public $dbPass; public $dbName; public $dbPort; public $userImagePath; public function __construct($key = "some-project-settings", $path = "/etc/some/default/path/") { parent::__construct($key, $path); } public function loadDefaults() { $this-&gt;debug = false; $this-&gt;dbHost = 'localhost'; $this-&gt;dbUser = 'root'; $this-&gt;dbPass = ''; $this-&gt;dbName = 'someproject'; $this-&gt;dbPort = 3306; $this-&gt;userImagePath = "/var/www/user-images"; } } You can now do $settings = new Settings(); $settings-&gt;load(); And it will try to load from the path and key (in the example `/etc/some/default/path/some-project-settings.json`). If it can find it it will load what it can and use defaults for the rest. If it doesn't exist it'll just use all the defaults. Set what you want and save it back using `$settings-&gt;save()`. Lob this object around in your dependency container so everything that needs it can use the settings. (You can even have `AbstractSettings` object inside this object and it will save and load it correctly.) 
ok
Think of code like you are writing a novel. The classes are Roles. The objects are the actual Actors. The class methods are the *actions*. Here's the article I wrote on the subject: http://www.phpu.cc/books/phppro/advanced_topics/beautiful_code
If you're using PHP for a large part of your day PHP storm is worth it. I used to use netbeans and tried many others and PHP storm is superior in every way I've found.
Why not use docker-composer ? 
It's not really security in a 27k sense, it's a mechanism to personally know that while coding "oh I shouldn't be doing that". It is a benefit to store loaded settings in such a way that at runtime they should not be modified un-deliberately. If you were willing to throw away `const` or `define`, why not throw away classes that upon modification return a new instance with the change rather than modifying the existing instance, since it speaks to the same protections.
Riiight... The whole language is one big bolted-on hack, syntactically speaking, but suddenly we can't solve some of its biggest problems because "what if we get named arguments someday?" PHP has a major design paralysis problem. Ignoring today's concerns for fear of theoretical future hurdles is the quickest path to irrelevancy.
I've tried PhpStorm for a little while in the past. It does offer better refactoring, intellissense and Javascript support. It also supports new PHP features, specially syntax added recently, while Netbeans does not. I'm not sure I'm less productive in Netbeans though. But the main reason I don't use PhpStorm is because I find it too expensive for what it offers, considering I don't live in the US and get paid by third world standards.
Nobody can really use this with confidence right now though. * Who are `phpexpertsinc`? I feel like that should be in the readme * Why fork from https://github.com/Chekote/docker-php * As /u/yisraeldov says why not use docker-compose? * what does this provide that say laravel homestead does not? It's docker, so arguably not for beginners, I'd suggest not something it'd be wise to run in prod, but you've made choices on which specific DB versions to use, you have logs on and I think streamable. * Does it setup redis as the PHP session provider? (https://github.com/phpexpertsinc/docker-php/blob/master/base/Dockerfile seems to suggest no) * Doesn't bootstrap a dir so as well as docker PHP a user needs to have system PHP &amp; composer (pretty sure homestead provides both with selectable PHP) The last concern is one for your sanity. Do you really have time to maintain this? It hangs off of `ondrej/php` and xenial, so I'm guessing no. I don't either which is why I base most docker-images off the latest php7 tag in docker library, with a tiny amount of application setup. If you do, then great you've at least asked the question, but otherwise consider how this is going to play out 1,3,6,12,18,24 months down the line.
don't break an arm jerking yourself off
such a pity github links to a url that isn't locked to a revision, and reddit doesn't have a way for mods to edit / remove URL's from posts by bot. Thanks
If it makes you feel better using it, I do not see any harm in using it. I just feel it's more of an emotional bandaid than actually helping anything. It's still in there for a reason, but it's also used less and less for one. 
a set of namespaced `std\*` functions, strongly typed with consistent naming conventions and consistent ordering of arguments e.g. `array_filter` vs `array_map`
Because that means you have to actually do work instead of arranging tools.
Oh. I get that. I had that point of view once too. Just learned from experience that it's a waste of time. In my experience, the few who are able and willing to give you serious, thoughtful feedback do it on their own, while those who fail on the first time, won't deliver if you ask about it either. The few who just happen to use a bad phrasing, who could clarify when asked, are not worth going through the trouble of bothering with the ones who just aren't. 
A nice OOP rewrite
How is this better than phpdocker.io?
Is it difficult to explain for me. I think it is extremely difficult for me to understand and get oriented in this written code. I have been very procedurally oriented in programming for a number of years, and it is therefore difficult for me to write the code completely in a different way. I read some books, watch videos but still when i see PHP OOP code i have no idea what the class do. ..and sorry, english is not my primary language.
How exactly OOP? Scalar objects?
It's not a waste of time, in my view, to more accurately discern between people with poor communication skills that actually mean well, and people who are malicious.
The way I imagine it'd be best actually is if all functions are moved to static methods in larger-grained namespaces, i.e. \Std\String::split(). This means you need one import for all string functions (i.e. `use Std\String;`), and all functions are neatly grouped with their class without being fragmented into micro-namespaces. But I imagine not many share my opinion and would rather prefer functions. The existence of functions in PHP is a bit redundant as a whole, given PHP has been modeled after Java ever since 5.0. Note that I'm not talking about anonymous functions/closures (which Java has), but global functions (which Java doesn't have). I don't mind us having functions, I don't mind us fixing their behavior, but I feel it's the path of greater resistance. And the path of lesser resistance is gradually migrating all APIs to objects or static methods.
I wouldn't mind seeing a functional re-write as opposed to objects.
What?
I understand completely. Often difficult to make paradigm shifts. I'm currently struggling with functional programming. If at all possible find a mentor who speaks your native language and start asking questions. This article take you through the steps of converting a procedural php application into an OOP one. It may or may not help. It does use modern components so if you get through it then you will be off to a good start. https://symfony.com/doc/current/create_framework/introduction.html 
&gt; I just feel it's more of an emotional bandaid than actually helping anything. What is wrong with you? It's no more an emotional bandaid than a seatbelt is, or sides on a car are... Your point doesn't improve anything, it just changes some things, which I've said why are not an improvement, and why. /u/c00yt825 made a better point, which I'd like to discuss with them, bounce ideas around, not some abstract ramble about global arrays and security, which FYI, not interested in. It enables programmers of any level to make mistakes they shouldn't need to worry about. The only comparable improvement is to make a type-safe bunch of code and add complexity to the code which impacts maintainability, maybe speed and doesn't do a thing for security and does actually increase reliability (and as I've linked to /u/c00yt825 is an approach used in some other work). 
&gt; PHP has a major design paralysis problem. No it doesn't. The trouble is backwards compatibility. Every time we try to make progress we discover that it breaks some code somewhere because of how *awful* it is. If was as simple as design paralysis Facebook would have added features directly to PHP core instead of forking the entire language. They *had* to fork the language because every good feature broke some other thing.
do you know why array_map has this wierd ordering of arguments? because it allows you to pass multiple arrays, which allows you to do very interesting stuff: $arr1 = [1, 2, 3]; $arr2 = [4, 5, 6]; array_map(null, $arr1, $arr2); // [[1,4], [2,5], [3,6]] But I would rather have separate function for such things.
Why is `array_map`'s order wrong and `array_filter`'s correct?
it's not wrong, just in most languages context is first argument. Anyway, I don't think that this is something that PHP team should spent time since all this could be done in userland as composer library.
this is bad idea, pipe operator is much more flexible solution. Consider adding new method for string and make it not conflict with some other library code.
Isn't that mostly a matter of the community embracing the paradigm? PHP seems reasonable suited for functional programming and there are a lot of useful third-party libraries. A well-designed and approachable FP web-framework for people without prior FP experience (or programming experience in general) could really boost the adoption of functional programming in PHP. Like [Elm](http://elm-lang.org/), but for PHP, essentially. :-) If the community would shift towards a more functional approach, the language might change to become more suitable, just like recent versions of JavaScript (arrow functions, etc.).
Couldn’t someone just implement this in straight PHP? There would be a bit of a performance hit but seems straight forward. 
&gt; moved to static methods You probably will not need all functions from string namespace in a single file. Most of the time you will need only few of them: use function std\string\{join,split,match,tolowerCase}; And IDE could do that for you. If you don't have IDE (i.e. vim or emacs) and you still need to use this functions: string\join($clue, $arr); is not a bad idea. The main point is that your module system should allow you to import only stuff that used, not more than that. &gt; given PHP has been modeled after Java ever since 5.0 And languages as kotlint introduced functions as fist-class citizens of language. Maybe it's static classes are redundant in PHP? &gt; APIs to objects and static methods. This will introduce much more problems that it solves. &gt; I feel it's the path of greater resistance There are much more solutions around instead of just copying what Java had 20 years ago.
why?
How does that even happen? `namespace MyLib; class String extends \String {}`? You can't monkey-patch the base class at runtime without doing some fantastically dumb (and unreliable) things, so normal method dispatching rules for subclasses would apply - and they're extremely well-defined and understood.
What helped me a great deal is to not see it as "prodecural or object oriented". There is no clear cut, you'll always have a little bit of procedural in your code, even if just as an entry point. When thinking about a problem, think about what objects you have. Are you working with users? Those are nicely represented as objects! Invoices? Objects! A chair? Maybe an object, maybe just a local state - depends on your case! Objects are nice to bundle functionality together with a local state. Focus on that instead of OOP vs prodecural. Use OOP as a tool and not as a paradigm.
Ok, so we will not introduce monkey pathching, this is good. Now imagine this situation. You will have `AString` from A library and you will also have BString from B library. Both has some additional methods which they depend on. And in our code we need to call both A and B methods: $string = "Foo" // has type \String; $a-&gt;doStuff($string); // Expected AString $b-&gt;doStuff($string); // Expected BString We can't pass `\String` type since this will break code of our dependencies. The only workaround is that library in each method will have methods to convert `\String` to `AString`. Which will add complexity. And again - why you even need scalars as objects? What kind of benifits it gives to you?
&gt; procedural functions Could you share of your definition on this? Is `strlen` is procedural function? Is it just pure function? 
also, what do you think OO is? 
It does use docker-compose. Look inside `bin/containers`.
FP (when done right) equates to less, [simpler](https://www.infoq.com/presentations/Simple-Made-Easy) and more reliable code. It's just data and (mostly pure) functions.
The main difference is that you can put String:: inside a \php namespace and polyfill it with autoloading for backwards compatibility.
Well, first, I didn't know about phpdocker.io when I created this. Second, it seems that phpdocker.io requires the user to fill out a web GUI first. With this project, you can simply do: ``` wget https://github.com/phpexpertsinc/docker-php/releases/download/v1.0%2Bphp-7.2.2/phppro-dockerized_php-v1.0.0.tar.gz tar xzvf phppro-dockerized_php-v1.0.0.tar.gz cp -rvf phppro-dockerized_php-v1.0.0/postgres/* . bin/containers up ``` Seems to be a lot easier and quicker to me. And it can be fully automated by CIs.
The question was what would a redesign of the standard library look like, and what scalar objects provides is a way of having to reference fewer procedural functions in said library in day to day coding. 
The train has already left. PHP had a golden opportunity to have a new modern stdlib when PHP got namespaces. But the core devs chose to keep the old crap and did nothing about it. Now its kind of too late without having major BC breaks. They would literally haveto reserve some namespace, and this would also imply that there would be two incompatible std libs. 
PHP Experts, Inc., is my consultation company. It's a small company of a half dozen highly skilled Full Stack PHP devs, including myself, whom I place at 1099 positions at other corporations. We fill both long-term positions and, for crazy devs like me, short-term. If you ever wanted to work on a different project/company every few months or even weeks, anywhere in the continental U.S., Europe, or South East Asia, it's fantastic. Since 2015, I have set up branches in Las Vegas, Houston, the UK, Dublin, Costa Rica, Colombia, India, and the Philippines. If someone has a work auth in any of those places, we can place you almost anywhere you want. I travel 50% of the time out of choice. All over the world.
That sounds like a library design issue to me, not one with scalar objects. If they're requiring you to pass an internal type, you would indeed have to convert into it; presumably `$a-&gt;doStuff(new AString($string));` There's no magic solution to this - it's just the nature of single inheritance. A good library would encapsulate this conversion so you don't have to do this kind of thing when interacting with its public API. Scalar objects give one approach for non-awful syntax of long operation chains. As does a pipe operator, if done well. If introduced, the former also makes a less-bc-breaky way of cleaning up names since it acts as a pseudo-namespace without dozens of tedious imports.
&gt; But why would any library have an AString or BString type? Because both libraries want's to extend `String` type. Or you suggest that library authors should not extend scalar types? Or maybe it's just better to dissalow extension of scalar types? 
But functions cannot be autoloaded (see other discussions on externals), so for an effective polyfill you'd want something that worked with it.
&gt; acts as a pseudo-namespace without dozens of tedious imports. Do you really have such problem? Try to count all functions call in your files, consider amount of imports and... you will find out that you will have not much of them.
Oh so you're a big deal. Might make sense to have this then. Apologies. What about testing other versions of PHP, setting up Redis or Memcached as a shared state server? Why is your reddit username 2012-09-04 &amp; not PHPExpertsInc?
&gt; procedural functions So the probem is that procedural programming for you is when you don't have classes...
OO (done right) equates to less, simpler and more reliable code. The problem is that we are stuck in C++ interpretation of OO...
&gt; OO (done right) equates to less, simpler and more reliable code. As opposed to what?
It's not a huge problem, but one approach makes the problem not exist at all. So all else being equal, that's the approach I'd prefer.
To good old imperative procedural stuff.
&gt; I would rather have separate function It's commonly called `zip`. Here's an implementation I wrote. The `to_iterator` function takes an `iterable` and returns an `Iterator`: function zip(iterable ... $xss): \Iterator { $iter = new \MultipleIterator(); foreach ($xss as $xs) { $iter-&gt;attachIterator(to_iterator($xs)); } return $iter; } $arr1 = [1, 2, 3]; $arr2 = [4, 5, 6]; iterator_to_array(zip($arr1, $arr2)); // [[1,4], [2,5], [3,6]] But if you pass it to map you'll be passing *an array of size two* instead of *two parameters*. That's why `map` takes a variable number of arrays.
&gt; not exist at all. And will introduce another problem: customFunction(range(1, 5)-&gt;map(function ($i) { return $i ** 2; }))-&gt;filter($filter);
You can make anything look messy if you cram it on to one line like that. At this point I feel like you're just arguing for the sake of doing so, so I'm out. Enjoy your Sunday!
&gt; But functions cannot be autoloaded So fix the issue. Don't push things into static methods *simply because we can autoload them*.
Ok, here is formatted version: customFunction( range(1, 5)-&gt;map(function ($i) { return $i ** 2; }) )-&gt;filter($filter); So the order in which functions will be executed: - range - map - customFunction - filter You could place any function, static method or real method instead of `customFunction`. This is just an example that scalar objects are partial solution to the problem and in reallity it will not solve any problems but will make things even worth. Especially since implementing and maintaining such feature, handling boxing/unboxing of vaeiables... It's just too mane efforts for feature which doesn't brings any value.
and hot it is related to scalar objects? why do you need them? what problems it solves?
I have answered these questions and more in [**the FAQ**](https://github.com/phpexpertsinc/docker-php/blob/master/FAQ.md) I just created. Thank you for your part in my inspiration!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [phpexpertsinc/docker-php/.../**FAQ.md** (master → 549043e)](https://github.com/phpexpertsinc/docker-php/blob/549043ebaf87c9da2d50061c442bdbb1f16e7b85/FAQ.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtqeun1.)
I guess I don't understand your reasoning on why scalar types need extending.
&gt; Why is your reddit username 2012-09-04 &amp; not PHPExpertsInc? That's a pretty good question. I guess I never got around to creating it. The corporation was formed in April 2012 lol. Been using this nick ever since. 
I don't see how a static method is useful with backwards compatibility either. What's your point?
That if future versions cleaned up the root namespace, those functions would need to go somewhere. As those functions are grouped by their owning module, say, mysql or arrays, a class would serve as an effective namespace. Those same classes could easily be created in userland for backwards compatibility and reference the root namespace.
I don't understand why anyone would like to have scaral types and standard library as methods of this types if it doesn't allows you to extend (add your own functions). The main reason why people may want to have scalar types is to have method chaining. If you don't allow to extend it - then you will have mix of chaining and regular function calls which eliminates benifits of scalar types. p.s. I don't like the idea of extendable scalar types, also I don't see any reason why we need scalar objects. I don't see any real value in it. As for long operation chains - even with temporal variables it's not a big dial. 
Somehow I only got part of that in my inbox. &gt; I'd suggest not something it'd be wise to run in prod &gt; &gt; I completely disagree! Get a Digital Ocean Docker App Droplet for $5, clone your repo on the droplet, and then just run containers up. You have a live site in 5 minutes! In that case we have a massive rift in opinion. a 1GB server is not appropriate for a PHP application with no caching, no firewall, no other setup. I'm pretty sure DO would be very upset if just this was deployed. &gt; I personally run this on all of my production sites. Before noticing this, I actually messaged you about this. I won't go into it here, but give pause for thought. Btw the release doesn't currently come with a `bin` dir. I'm assuming this is a problem with the release system and as-per your other comments I'm sure you'll get it ironed out.
I'm sure you already know it but just in case you have https://github.com/nikic/iter which is pretty sweet
FYI phpStorm can already do it: `Editor &gt; General &gt; Auto Import`
This project makes it super simple to learn Docker. By analyzing the parent repo, that's how I learned how to create docker images, docker-compose, etc. I encourage you to fork this project and try to add something audacious, like a gearmand daemon. You will learn -so- much!
What BC would we be breaking by namespacing the standard library? The odd project or two currently using a `php` top-level namespace? I don't think so.
&gt; See, I'd never use this yet because I've got nowhere near enough Docker experience, and if I did use it I'd never learn, which to me is super important. This might be more your style then: https://github.com/DHager/docker-php-library-demo
There is a database-specific `bin` dir inside each database subdirectory. E.g., `postgres/bin`. There is not a global bin folder.
So how would that look?
you seem unable to accept other peoples opinions differing from yours. I do not see how my personal opinions affect you. If you disagree, you disagree. That's life. No reason to get personal. That's just bad communication skills... 
Thank you very much! See what gets me about all this stuff is its all config-driven, which is of course awesome, but it all feels kinda... Magic? What I wanna see is a full list of all the things I can set up, and (if I needed to) see how that's working under the hood. Otherwise I'm putting a lot of trust in something and never seeing what it's doing. How do I know how MySQL is optimised by default? Are there configuration options for everything I wanna set? What happens if not? Just stuff like that that put me off a little. I'll take a look at the link though. 
Quite a many places, including here, I see projects adding dockerized containers for *particular PHP utilities*, particularly composer and phpunit. This is *completely* unnecessary and overkill. Just dockerize PHP itself and stick it in your PATH. Done and done. See https://github.com/phpexpertsinc/docker-php/blob/master/dist/mariadb/bin/php
&gt; you seem unable to accept other peoples opinions differing from yours. followed by &gt; That's life. No reason to get personal. That's just bad communication skills... 😂😂😂😂 Irony-level ***Trans-galactic*** 
&gt; Well, first, I didn't know about phpdocker.io when I created this. how does that make it better? &gt; Second, it seems that phpdocker.io requires the user to fill out a web GUI first. They are called options, instead of assuming things, some people prefer to ask the user. It seems like if I were to use your solution I'd end up with 2 DB services while probably only using one.
&gt; You probably will not need all functions from string namespace in a single file. Most of the time you will need only few of them The question is what's the benefit of being so explicit in import statements, and so unspecific in function names. A free-floating "match" function isn't very good for code readability. This isn't OOP where you invoke a contextual method (from a dozen methods) on a variable of a known type. &gt; And languages as kotlint introduced functions as fist-class citizens of language. Maybe it's static classes are redundant in PHP? If the design of functions in namespaces and autoloading wasn't butchered in PHP, I'd agree. But as it is, you'd need a bunch of B.C. breaks (this RFC and *others*) just to get where classes already are. Since the goal of what I said is "least resistance", i.e. achieving the most by changing the least, I'd rather go static methods. BTW Kotlin's singletons and functions are not exactly very well-regarded features among language designers. They do many smart things, but sometimes they carried away with the syntax sugar, so it's not a good example to imitate. K.I.S.S. &gt; This will introduce much more problems that it solves. Give me one. Or do you just like how dramatic that sentence sounds. 
If you are using postfix you can use MySQL to store and handle bounces. This way you can create aliases and when an email is sent to your server you can relay it to the real address. In /etc/postfix/mysql-aliases.cf add following query: query = SELECT email FROM clients WHERE email_alias='%s' The '%s' part is the invalid (proxy) email address, e.g. guest92436y@ourcompany.com so if there is a record for the real email it will forward the email to the real address. The @ourcompany.com address should be what is defined as the server email (postmaster) as defined in /etc/postfix/main.cf myhostname = ourcompany.com alias_maps = mysql:/etc/postfix/mysql-aliases.cf alias_database = hash:/etc/aliases Important gotcha: in /etc/postfix/mysql-aliases.cf you will also need to add hosts = 127.0.0.1 below the user and password. It took me ages to figure this out, I found it somewhere online but can't find where.
How long for the second time though? I can be up and running with the official base images in 5-10 minutes now that I understand things 
Yep 5-10 is pretty close and after the initial pain I have a much better understanding of what I need to do when I have an extra condition to meet or something doesn’t work quite as expected
You’re the only one to attempt to give an answer and get down-voted 6 times. 🙄 Reddit, you’re crazy sometimes.
Seems like something you could do with Elasticemail, which has a really generous free tier. https://elasticemail.com/api-documentation/inbound-notification/
Use Mailgun or Sendgrid.
Code reminds me of stuff I used to write 10 years ago.
No, you choose which docker files you want to copy so you end up with only 1. They make you go through a gui, I make you cp one directory instead of another. The key difference is that DockerPHP is much more scriptable for rapid deployments and continuous integration testing of different platforms. 
The Hack standard library is basically Facebook’s answer to this question: https://docs.hhvm.com/hsl/reference/ - still needs a lot of expansion though. Even though we don’t support using it with PHP code or the PHP interpreter, it is still based on what we learned from the PHP standard library, influenced by a few others (ocaml and Scala have influenced Hack a fair bit).
When I contributed to the old (now abandoned) PHP 5.5 fork that merged all those then-pending PRs, in the DARK DARK days before HHVM and Hack Lang spurred Zend Internals into action, we implemented this in a backwards compatible way, for sure. Having `Array::split($array, ',');` doesn't mean you have to get rid of `explode(',', $array);`. Hell, I started adding support for `"1, 2, 3"-&gt;split(',');` before the core maintainer just up and disappeared after a few weeks.
Simply placing it in a namespace does not help the language, and I'd argue it makes it worse because we'd then have two names for everything. It needs to be *redesigned* which is an enormous undertaking. Building more building on top of a weak foundation will leave it weak. We need to root out and fix the language first. I'm not saying it should be perfect first; rather that currently it is a disaster and any stdlib redesign should wait for fixed language deficiencies and errors. Consider if we had a new stdlib in 7.3 with the same featureset that exists in PHP 7.2. Then in PHP 8.0 we get generics. Wouldn't it be odd if our stdlib doesn't work with them?
This has sort of been proposed in the [Consistent Function Names](https://wiki.php.net/rfc/consistent_function_names) RFC.
any chance the php version is still there to play with? 
*We don't even have generics.* Would it be odd? Maybe. You know what's even more odd, though? The current standard library. And guess which problem is actively causing real-life loss of productivity and QoL for the community *right now*? This is the epitome of design paralysis. I'm somewhat taken aback that you don't recognize it.
ಠ_ಠ &gt; Quite a many places, including here, I see projects adding dockerized containers for particular PHP utilities, particularly composer and phpunit. Uh, noooo, there's a reason the container isn't tagged `something:phpunit`. It's an container for testing the particular app/library, and it's there so that people can add things (like PHP extensions or PEAR stuff) that their application expects in its runtime. &gt; This is completely unnecessary and overkill. Just dockerize PHP itself and stick it in your PATH. Done and done. See [My project] Uh, that project is **ALSO** using a customized container. What's your point? I sure hope you aren't suggesting people should be doing `docker run phpexperts/php:7` in their projects! That's unacceptable for three big reasons: 1. No debugger when running unit tests. Instant disqualification. 2. Hard dependency on dubious third-party image. 3. You don't want to do `docker run` for frequent short tool invocations, because it means initializing and tearing down a container over and over. 
My first reaction is to parse and store all the data in a in-memory sqlite database and query that... If your files have metadata (titles, post dates, tags, etc) it would give you a really simple interface for searching it.
I started out in the days before sql, so we did flat file and flat files &amp; indexes all the time, in pascal and ansi C
http://sphinxsearch.com/ PHP bindings: http://php.net/manual/en/book.sphinx.php Feed its index with your texts and enjoy the power of the full lexical search. It may be an overkill for your simple project but it's also an invaluable learning opportunity.
I'm aware.
I had seen that one too and I had hoped for something with oop.
Thank you for this. I had looked at sphinx and as you rightly put it my project is small and I thought it'd be an overkill but your emphasis on learning opportunity will make me go over it again. 
Thank you. I do not (sadly) have in place anything that well categorized with metadata other than the mere content of the file. Because of that simplicity, I had been resisting getting a database involved but I should learn to do that sooner or later anyways. 
Well PHP is probably the most not-well-suited language for async. This boils down to the execution model. In other languages that are non async from the core like ruby and python (python is moving fast towards async though) the model is you START your app, it runs and does its thing. In PHP your app starts and stops on every request, and there is no eventloop behind the scenes. Imagine all the frameworks, and how they work. Async code would mean you would have to rewrite all of PHP to work in a non blocking fashion, making literally a new language. This is why people say use node or whatever else when you need async. 
I'd rather the opposite. In particular, converting everything that returns an error into throwing exceptions instead (without needing to use ErrorException in an error handler) would be a fantastic step towards making PHP error handling pleasant to use.
Exactly. OP's entire argument for trying to add asynchronous functionality to your PHP application is that someone made a library for it and it is in a stable state. Never mind how it works, just use it in production.
In other languages that are non async from the core like ruby and python (python is moving fast towards async though) the model is you START your app, it runs and does its thing. That's pretty much how PHP works too from what I can tell. It's just that we all got used to the idea that a PHP app's sole purpose was to give a response to Apache and then die untill the next request, but nothing in the language itself dictates that the app should die as soon as it has processed a request. Laravel queue workers or example run 24/7, same as php-pm. Doing long running process and async with PHP might seem like a strange idea, but so was using JavaScript server side. 
Sure, in git history. Not the greatest piece of code :)
Modern applications have a need for, or at least can benefit from, async operations. If you have an existing PHP codebase, it’s a nice option to have these libraries available. If you’re starting a new project, yeah, maybe it shouldn’t be your first choice. To be fair though, a major point of any library is to not have to worry about the “how” so you can focus on the actual task at hand. 
But why? You cannot use any of the blocking stuff when using a non core async lib like reactphp. If it does not work with eg. a standard DB wrapper like PDO, it does not work with any orm. It does not work with 99% of PHP so why bother? I get zero benefits from using it. Why would i not then use python or node instead?
My point is, that here's a guy who writes a blog post whose message is "all those people who point to PHP not being designed for asynchrony, and point to languages that are, just ignore them and install this package in production, just trust me" and I do not subscribe to that point of view. The blog post has pictures but they make no sense, it uses Apache versus Nginx as an example - if OP understands the difference between Apache/FPM and Nginx/FPM then he certainly isn't describing it very well. The entire thing that the blog post is about, namely how do you do parallelism in PHP, nothing on that. He says the people who say you should do parallelism in another language are wrong, and then goes on to put a bunch of nonsensical diagrams of cogwheels and odd descriptions of web servers, and that's it. Nothing to mention *why* those people are wrong, *why* you can do parallelism in PHP other than "somebody made something", *how* this works, *who* wrote this stuff he's such a fanboy of. Well I say those people who point to other languages (there are a few in this comment thread already) make great points and OP is not countering them, and instead is telling me I can just use some library in production, literally without explaining anything about it.
No. PHP has a share nothing model. This means you cannot have PHP state and increment a counter on each request. It all resets when the process finishes. This is trivial in any other language. I have not used Laravel in many many years, but afaic a worker process is separate, and most likely uses redis are some other container for state.
I don't know why you're arguing with me, seems to me like we're in complete agreement unless I'm misunderstanding you. :)
I think you're missing the long-running process part of the discussion. If PHP is run as a daemon and maintains its own HTTP server, then the shared state is server wide and spans multiple requests.
These libraries have their own database drivers which execute asynchronously. They have their own filesystem libraries. Many common use-cases have their own asynchronous implementations and for everything else there are child process/threaded alternatives to perform the blocking work out of the main request/response thread. The main benefit, as far as HTTP is concerned, is to be able to handle far more concurrent requests than the run-of-the-mill Apache or Nginx setup. There are other benefits which can be exploited even in a "traditional framework" setting, but those are less of an all-or-nothing scenario.
Would need profiling to check this doesn't kill performance by loading hundreds of functions for every app (or app that makes your library a dependency)
I agree this blog post did little to explain anything useful, and could have been a single sentence saying "hey by the way, you can do async in PHP with React or Amp". A follow-up sentence saying "see, now you don't have to rewrite your entire application in {x} to get the benefits of async!" also may have been valuable, as would a couple of examples.
You forgot to use slashes in your reply.
Good luck finding one
Actual autoloading follows two steps process. First step is performed by PHP itself, when it tries to match actual Classes, Interfaces, Traits, Functions to names it find. For Classes, Interfaces, Traits PHP will after failing to find their definitions, pass such name (and only name, that is info weather it was class or trait is lost!), to autoload handlers. There is nothing special about those. Composer implement one for your convenience. It uses PSR-4 scheme (and other you defined in your composer.json) to find missing definitions. For functions PHP is somehow retarded and refuses to pass their names to autoload handlers but instead fails with appropriate error. So functions unfortunately require either `require` or putting them inside a class as static functions and using class as autoload name.
10GB "codebase" to 1,4GB by removing logs somebody kept hidden in the jungle of it's folders. Then 700mb off, by prunning executables of it's dependencies, and redundant libraries, and docs of any dependency, and... Does it count as lines of code removal? Dunno.
Why don't you guys just do c
You make broad statement. To show it's invalid it's enough to point single usage for async in PHP, and here it is: When PHP code have to make multiple requests across network, async code is more performant, even when it does not need to be totally asynchronous from "parent" code. Is it Async? Yes. Does it require total rewrite? No. Is your statement thus false oversimplification? Yes.
You could actually use Jigsaw http://jigsaw.tighten.co
I really hope they will do something with this...
In PHP `Null` is valid value for any class member. So `isset` can not relay on `Null` meaning `non-existing`. So there need to be something **besides** all possible values for a member of a class to signal that member itself do not exist. In PHP that's boolean result of `isset`. `__isset` -&gt; Boolean -- weather member exists `__get` -&gt; Mixed (including `Null`) -- value returned by member (Null means value unknown - like user did not share it with system)
From docs: ` __get() is utilized for reading data from inaccessible properties. __isset() is triggered by calling isset() or empty() on inaccessible properties. `
I use RatchetPHP on a production project for very fast search (hitting Redis or Elastic), I find it quite fun and a lot faster than REST API when I want things like auto-complete and auto-results. Tested a $5 Digital Ocean with 500 concurrency users doing 4 hits/second and it was a breeze
&gt; functions aren't They are, in fact it's more polymorphic than methods since they don't have any context and can be easly composed. function foo(\Closure $formatter): string { return $formatter($this-&gt;data); } There we are expecting any function which will receive string and return string for us. The problem is that we don't have function interfaces - but this could be solved. As for polymorphism, you don't receive concrete function, so no problems with switching implementation whenever you want. If you mean that methods could have different implementations within same interface, please remember about LSP. Since we are talking about scalar objects, there are tons of ways how you could break LSP. And also, previously we talked about making scalar objects final, so you will not have "different" implementation of them. So no, in this case methods will not be polymorphic. &gt; In OOP you can have two pad() methods on two different objects which is basicly the same as two namespaces. &gt; With functions you can't have both If we are talking about javascript... import {pad as arrPad} from 'array'; import {pad as strPad} from 'array'; And again, chanses that you will have both of this functions within single file are pretty much low. You could basicly take 1000 most popular repositories on github and calculate all needed statistics on how many this cases exists in reality. &gt; If the design of functions in namespaces and autoloading wasn't butchered in PHP 1. we are talking about standard library, so there no need for autoloading. 2. Instead of trying fit everything into existing autoloaded entities, maybe we just need to allow function autoloading? 3. composer file autoload + opcache pretty much solves all this problems for userland. &gt; But as it is, you'd need a bunch of B.C. breaks (this RFC and others) just to get where static methods already are. Functions already are there, and we don't need them to be auto-loaded since it standard library. No BC breaks. &gt; Remember how cool Scala was and Java was so old-school compared to it? Scala still hot thing. It's not much hype around it anymore but still it heavily used. Take a look at akka + scala. &gt; BTW Kotlin's singletons and functions are not exactly very well-regarded features among language designers. Like who? &gt; Lesson is K.I.S.S. What you proposing is opposite to KISS. This principle is about user experience (or developer experience in our context). It's not about "been stupid". Like USB A vs USB Type-C. Which is more user friendly? which was simpler to implement? &gt; Give me one. Or do you just like how dramatic that sentence sounds? I already gave example above: https://www.reddit.com/r/PHP/comments/7v7lu5/how_could_a_redesign_of_the_std_library_look_like/dtqe8rk/ &gt; I've been writing my "function" libraries as static methods to take advantage of autoloading and sane name resolution for many years now I'v used composer's file autoloading for functions for about 3 years now and I'm perfectly find with this.
And moving that stuff to "just configuration files so no code so no OCP applies" do not help either ;)
Use curl?
curl is leaky C abstraction It's fine for this particular task, even awesome. But extensibility of curls is meager at most. "Just learn C" is equivalent to "Just learn JS", whereas good async code will be better at compos-ability without leaving PHP.
&gt; Well PHP is probably the most not-well-suited language for async. This boils down to the execution model. &gt; In PHP your app starts and stops on every request, and there is no eventloop behind the scenes. Imagine all the frameworks, and how they work. Async code would mean you would have to rewrite all of PHP to work in a non blocking fashion, making literally a new language. This is why people say use node or whatever else when you need async. That's just a very elaborate way to make a circular chicken-egg argument. "PHP is not suited for async, so we should not make it suitable for async". Truth is in your PHP request modern apps need to make more and more remote calls and receive more and more remote results. Doing this asynchronously will always have a major edge on performance compared to stupidly blocking during every operation. The "everything is synchronous" vs. "everything is asynchronous" dichotomy is a false dichotomy. Most applications are hybrids. It's possible to gradually add more and more async APIs until all major I/O blocking is gone and replaced with async. But as long as we have apologists for the status quo, this won't happen. 
a.k.a. Design Patterns
Ability to understand text, not existent? holy crap you're shallow... anyways, have a nice day. 
Maybe, still back to my point. This would a) be done in userland, making all of core php stuff unusable (making it very easy to block the main thread, unlinke node where its hard to block, because all of js is nonblocking by nature) or b) php core would be rewritten, making it a new language.
Im talking about async as in how a program is written. Im not talking about some new hotness PHP async http client. Some random http lib beeing async dont make any diffrence in the grand scheme of things. Next you want to make something custom async. Sorry! That kind of async is not served here. If thats your main use of async, go for it, those libs already have you covered. 
Except you use the wrong names.
Yep. This is why micro services is ideal for more complicated website. You can involve different languages for their specific built.
What exactly is your question? If you want to get one movie then do a query like `SELECT * FROM movies WHERE id=?` then you’ll have access to `$movie['title']` TBH I’d suggest using PDO instead of mysqli as the API is nicer: https://phpdelusions.net/pdo
You have argued vanilla vs async performance, which I supplied a possible fix for. Now you say that it is just better.
I think you're looking for an ORM such as Eloquent.
I think we both talk about the same thing. Only I point out that async is as still useful if only part of program is asynchronous with specific task being run in parallel/concurently with known synchronization point at the end. You on the other hand, from what I see state that async is only useful if whole program is designed around it, but because of php flaws whole programs would have to be rewritten to use that new paradigm. So my argument points some exceptions from your claim about async, and conclude that you make too broad a statement about "async". Maybe adding adjectives to your "async" would help disambiguate?
See, fetch_assoc is superfluous here, as you have all your data in a regular PHP array already. Your class should return the exact info you need, without the need to fetch anything (and so it does by the way). Therefore you have to use just regular PHP routines to access an array. given you want to loop over all movies returned by getAllMovies(), then just loop over it: $data = $movie-&gt;getAllMovies(); foreach ($data as $row) { echo $row['title']; } that's it. What is important, you should never do anything like get_the_title the way you are doing it right now. tis function should run a distinct query to a database and return only one row like public function get_the_title($id) { $stmt = $this-&gt;connect()-&gt;prepare("SELECT * FROM movie WHERE id=?"); $stmt-&gt;bind_param("i", $id); $stmt-&gt;execute(); $res = $stmt-&gt;get_result(); return $red-&gt;fetch_assoc(); } What is also important, your script must create only one connection to a database, but judging by the function name, connect() creates a new connection every time. It shouldn't be. Actually, your Movie class should not extend a database class, because a movie is not a database. A database connection should be created elsewhere and then passed to the Movie class instance as a constructor parameter, as shown here, [The true OOP way](https://phpdelusions.net/pdo/pdo_wrapper#dependency_injection) 
&gt; unlinke node where its hard to block, because all of js is nonblocking by nature ``` while (true); ```
&gt; This is the epitome of design paralysis. I'm somewhat taken aback that you don't recognize it. I can see how you think that but I am actively working on a generics implementation. I'm not paralyzed; I'm writing code.
Don't really know what's the problem. Instead of `while(fetch assoc)` use `foreach($movies-&gt;getAllMovies() as $movie)`, where movies is instance of `Movie` class. &gt; if (statement is true) { &gt; foreach($movies-&gt;getAllMovies() as $movie) { &gt; // show the movie card &gt; } &gt; } `get_the_title` will potentially fetch hundreds of megabytes of data, to discard vast majority soon after. I would propose making `getMovies` more flexible, and `getAllMovies` and `getAllMoviesTitles` just call it with appropriate parameters.
**on a current project** may rule out Eloquent, while minor improvement may speed up development and help poor fellow keep his/her sanity ;)
which did he misuse?
This talk made me so hungry!
Not him, but Laravel.
Almost every software in the world is used primarily by people who do not know how to install PHP extensions or compile PHP.. 
thank you!
This is good advice, but I'd be tempted to take it a bit further and take the responsibility of loading data from the database away from the Movie class and put that in something like a MovieRepository. Then the MovieRepository has the reference to the DB injected, which it uses to load data and populate movie objects.
I think you're on the wrong subreddit. /r/jokes is a better fit
That was my point. Generally speaking forcing some kind of obejcts into SOLID causes more harm than good. Factories and data structure objects are first im mind when it comes to these "not really" objects.
&gt; Hospital Management System &gt; XAMPP Server Congrats. Everyone is dead.
Such as?
&gt;When you already have a solid background in PHP, it will be much easier for you just to dig in some libraries and tools for your use-case, instead of learning a new language and a new ecosystem you can bang a nail in with a screwdriver if you really want to but a hammer will work much better and land you with a better result. right tool for the right job
this should be top comment, i picture the author of this post has a giant tool chest in his garage and when you open it just got 1 screw driver inside...
there are use cases for async backend stuff, like external API requests and certain type of DB queries that may churn for an unpredictable amount of time. that said i would deal with those in a different a way 
You can get the project for the low low price of 200 rupees. For that low price you will get: - sql injection - xss vulnerabilities - csrf vulnerabilities - sql queries inside templates - passwords hashed with md5 - and more! 
My solution for Hack was to add `use type` and `use namespace`; `use Foo;` is pretty much equivalent to `use type Foo; use namespace Foo;`; you can then do `use namespace SomeVendor\SomeStdLib\String;`, and use `String\foo()` without it conflicting with the `string` type. That could also be appropriate for PHP. The main downside is that it can be potentially confusing if you do something like this, but this seems to be theoretical and hasn't come up in practice: use type SomeNS\Foo; use namespace SomeOtherNS\Foo; Foo\map(new Foo()); // \SomeOtherNS\Foo(new \SomeNS\Foo()); Though, this is also potentially an advantage: it allows you to separate the implementations of your types from the standard library that operates on them, and users could choose another one if they prefer.
There's also an undocumented feature in HHVM and Hack where you can configure it to effectively implicitly add `use namespace` lines to every file; it's undocumented as it's only really useful for monorepos with no dependencies: in other situations, you need every recursive dependency to agree on what certain namespaces mean.
Those comments holy shit
For a custom project, I needed a library able to compute N-Grams (from any size) of a string. I just released this small library using a very low memory footprint to generate those N-Grams. Your feedback is very welcome!
Then you should upgrade on php 7
The title is a bit more generic than it probably should have been. They are talking about the multibyte string overloads and how they are likely to be removed in PHP 8 so you should quit using them now before 8.0 is upon us. Based on the title I thought they had some major proposal for PHP 8.
Exactly. PHP has threading capabilities, but not in a web server environment. AJAX for anything that requires asynchronous and server communication. Handle UI while waiting for response accordingly. I rarely write php that returns html anymore. Instead typically I write my own APIs that return JSON and interact with those APIs via XMLHttpRequest
* subject to taste
Hmm, I will have a look into PDO! Thank you
What/who is preventing you from upgrading?
Host, distro, sysadmin policy, etc.
That's a pretty horrifying sysadmin policy that forces you to use outdated software that's subject to security issues which won't get patched. *Run*
Oh, come now. Debian, for example, provides PHP 5.6 in version 8/jessie, which has primary support through June 2018 and LTS support through June 2020. They will continue to apply and backport security fixes throughout that period. Many mature organizations do not fly to the latest release of everything as soon as it comes out. As long as they continue to receive security updates, they stay with a known stable version track until they have had time - which may be a year or longer - to thoroughly test the newer one and resolve any regressions that come up in their local code base.
Some decent discussions on unicode support or lack thereof: https://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible Language comparison: https://stackoverflow.com/questions/1036585/unicode-support-in-various-programming-languages Personally, I wouldn't start a new project in a language that didn't support unicode.
That "encryption" code is a goddamn sin. I know it's meant as a shitty example, but... yikes.
Although I agree it's not the easiest thing on earth and that functions like strlen() don't work correctly with unicode, It's been a long while since it was a problem for me in PHP, and as long as you follow http://www.phptherightway.com/#php_and_utf8 you will be fine. Did you have any problem with it recently?
I think the majority of people doing async programming in nodejs (or any language) are not using web sockets for everything but just returning request responses like usual. Based on what I've seen in node projects, what moreokk described is pretty spot on. A snappier UI is usually achieved just by using standard ajax. Sending multiple requests to the server instead of one full page request so no single component of the UI is waiting for another. And tbh PHP is just as suitable for this.
Agreed. Even in async languages the standard way of handling such queries at scale is with a message queue.
I am not a full time dev, just curious what the advantage is to going from strlen() to &gt; you run your String::strlen() method instead (you would have to write a String wrapper class and have it check for you, however). Am I missing something here?
You check to see if you need to use multibyte string functions. Rather then wrapping all your code in if statements like suggested, you call the wrapper function to do the check for you. Granted, I haven't done much code optimization yet, but I am sure there are ways to optimize the checking of the call as well to see if you should use multibyte string functions.
ok what you are really wanting is a *two-way* email anonymizer which obfuscates the email addresses of *both* senders. I know it can be done but I don't know how, you might be better to include in the email "Click here to reply to this email" and have a web-based admin/job ticketing system. 
&gt; Many mature organizations do not fly to the latest release of everything as soon as it comes out. PHP 7 came out in 2015. This is not about a "mature organization" making a reasonable choice, that's just incompetence and indifference at this point.
I don’t expect companies to be rolling out the latest version on day one. I do expect them to not only support versions that are declared as unmaintained by the upstream. I have no faith in manually backported patches, especially across a major version identifier which rewrote half the internals. 
It's not "borderline incompetence" to use working software with active security update service if it's getting the job done and they're not ready to upgrade yet. Anyway, your beef isn't with me, it's with just about everyone else, since while a lot of developers have installed PHP 7 to play with, its usage on actual public web sites is in the single digit percentages by most estimates I've seen.
Your data is wrong. 
Fun game. Your data is wrong.
Fun game. https://seld.be/notes/php-versions-stats-2017-2-edition Your turn. 
&gt; In particular, it's Composer users, which is more likely to be individuals and smaller organizations You think Composer is for "individuals and smaller organizations"? How backwards are you really. Do you also think OOP is just some B.S. kids do, and not for real programmers? BTW, you're failing at the game, because you're not providing your data reference. Even w3tech which rolls up all those millions half-abandoned WordPress and Drupal sites into its reports shows PHP 7 usage is over 12%, so what's the source of your "single digits" claim?
That’s not how things work in the real world. In the real world, large applications have to go through months, or even years of development, testing, regression, etc. before they can see the light of day. Now imagine having to accelerate that cycle so that you can upgrade to the latest and greatest every single time, and add in additional time for research and testing since you are developing on what is technically a different platform. This is why no company actually does what you are suggesting.
we are a small company with a quite a few amount of projects. Most of them are on php7. Some of them are php 5.5 (yes 5.5) and would require a lot of effort to get it running in php7. Most of the 5.5 aren't consumer facing, they are internal sites only that require VPN to access, so security issues are minimal. The couple public facing sites we have running in an isolated docker with read only access to most of the database, and write access to the required tables. We moved authentication out of it to PHP7 to migrate against that risk. Im not actually sure why we arent running 5.6 at least. I think an oversite and I am going to ask to get it upraded to 56 so we at least get security updates for a bit
I think that I am definitely shadowbanned for some unknown reason...
&gt; How long have you actually worked in software development? Yes, that's a serious question. 21 years. &gt; You do realize that daily deployment straight to production is not a standard practice by any stretch of the imagination? Amazon deploys new software to production every 11.6 seconds: https://www.youtube.com/watch?v=dxk8b9rSKOo http://assets.en.oreilly.com/1/event/60/Velocity%20Culture%20Presentation.pdf You may not be able to stretch your imagination that far, but countless other companies do. &gt; Building a large scale enterprise application that supports billions of dollars of financials from conception [...] Imagine having to do regression on a code base that large because you want to migrate to a newer version of PHP. "A code base"? If an entire enterprise is one monolithic code base, the architect has utterly failed at the one thing that job requires, and should be fired.
1. parse markdown. 2. striptags. 3. grep.
"Why?" is exactly right. PHP isn't designed to be asynchronous and just because you can hack it in doesn't make it a reasonably good idea. There are a *plethora* of languages out there designed for this kind of use. Branch out, use another tech stack. It wont kill you - on the contrary, it'll probably make you a better developer for your next PHP project. 
&gt;Amazon deploys new software to production every 11.6 seconds Yes, and their code goes through a robust QA process just like everybody else. As I said before, developers do not target production directly. Also, "countless other companies" do not deploy new code to production every 11 seconds. Amazon is a very distinct outlier in that respect. &gt;"A code base"? Yeah, a code base. You know, those files with all those weird high-tech computer words and curly braces that come up when you pull a project from source control? What have you been writing for the last 21 years that you've supposedly been in software development? You're arguing semantics now at this point. And at no point did I ever mention a single monolithic code base.
Um what? As someone who's done quite a few PHP upgrades for large organizations, you're statements are pretty much all wrong and suggest you've never really done it before. If you've got a large application PHP7 is hardly a strait forward upgrade. Lots of things compiled against PHP5 don't even compile against PHP7 if you've got binaries (and nearly everyone does). Some have new API's (PECL HTTP for example... sigh). Not to mention larger applications have lots of 3rd party libraries all of which need to be updated/replaced as necessary. Not to mention expensive and time consuming regression testing of the entire codebase. Plus you need a distro shipping PHP 7 and with a support policy that matches your orgs needs. If you need LTS, that took quite a while. Need to do all your audits/infosec sign-offs all over again. Then need to come up with a migration strategy for getting engineers to keep them working while you float between versions, and how to upgrade live infrastructure without having downtime impacting business objectives and revenue. If you're "development" is just some wordpress themes, yea it was a smooth upgrade form php4-&gt;php7. Odds are your web host had a radio button in their control panel to select what you wanted. If you've got lots of complex applications and business requirements, even PHP 5.5 to PHP 5.6 is a pain. I've done that as well.
Doubt it
I'm developing a PHP application for reselling. Most of the users we sell the app to don't have enough technical skill to install PHP and then install the app, configure it etc. So looking for a compiler to convert it to .exe installer. PS: the application can be used offline for personal uses only. Check https://www.exeoutput.com/, what they do is what i need. But not sure how good is that software.
I'm developing a PHP application for reselling. Most of the users we sell the app to don't have enough technical skill to install PHP and then install the app, configure it etc. So looking for a compiler to convert it to .exe installer. PS: the application can be used offline for personal uses only. Check https://www.exeoutput.com/, what they do is what i need. But not sure how good is that software.
Recently I had to create an Excel report. For reasons unknown I have decided to do it like this. Firstly I have fetched the data from the DB, then I have prepared the data (managed the string and converted the currency values), after that I used that data to create a CSV file that I saved and then converted it to an Excel file. After I done this, I have realized that there was need to create a CSV file and use it to create an Excel file, but rather I could have used the PHPExcels fromArray() method. 
Yeah, exactly. 
Like /u/LakseMinstreel said, your design decisions are peculiar to say the least. There are A LOT of possible problems with installing such services as a database and a web-server. The possibility that some of them already installed alone. For the offline application you simply choose the wrong tool. Let alone the fact it's 2018 today and you scarcely find a PC that is offline. you should consider either putting your application online the usual way, or choosing another platform. Or it will be a support nightmare 
Have you considered that your approach might be wrong for whatever it is you actually want to do. Maybe hosting the code on VMs such as those from Digital Ocean or similar would be better? If you somehow manage to package a PHP project into an `.exe` file that can run standalone, you have just bought a nightmare of an update deployment strategy. It would also limit the usage to Windows, and possibly specific version. I'd advise you to rethink your deployment strategy and consider if an .EXE file is the best course of action.
A while ago I bundled XAMPP installation with this installer: http://nsis.sourceforge.net/Main_Page
From a mods perspective, we can see your posts fine. Although this isn't exactly on topic ... 
When you only have a hammer everything looks like a nail. PHP is a hammer and you need a screwdriver. Find a proper language to build your application. Know your customer and pick a language that fits. If you are building for multi-os then Java or Python might be a better option. If you are developing for Microsoft OSes then go with .NET. If you must use PHP than you're likely better off building software a as a service application.
I have done exactly this recently. There are a few drawbacks but this is what I did. Created a lightweight C# wrapper that bundles PHP, MySQL and Apache. The App starts, shows a loading screen, during this time it starts Apache and MySQL and attaches eventhandlers to the exited event, so if they crash or stop you can log it and try and restart them or kill the whole application with an error. Once they're started the loading screen disappears, and I open a new screen that is just a browser window with no tabs and hardcoded to open the application. I use [CEFSharp](https://github.com/cefsharp/CefSharp/) to achieve this. For me Apache and MySQL were fixed requirements. This was installed on Laptops with an i5 Processor and 8gb of RAM, so not low-lowend machines. I can't speak to how it might perform on other machines. I would suggest using a much lighter weight HTTP Daemon. And for database usage SQLite proved to be much faster in my benchmarks.
You may deleted your question so you probally don't want to talk about it anymore, but from my experience from the past I would love to share some of them with you. Since the way you commented other questions it seems like you have a big dependency on a local webserver. One way would be to offer your code as SaaS (Software as a Service). That means that you have one copy (or multiple) of your code and give your customer a login for that to use. You can do it by a P2P or B2P (Pay to play = 10$/month or something | Buy to play = pay 200$ and use it as often you want) The other way would be to also offering (GOD DAMN I have a big Dejavue right now! No sarcasm.) an extra service where, if they don't have the ressources or knowledge how to install/configure it, that you will do it for them. Like go visit them, configure everything and in the end recalculate your invoice. 
yes, so instead of having a function you require people to create a class with a static method. Cool.
No you're not.
Run a web based company with multiple websites running php 7.1. I don't know who you are, but you represent a flawed view. The only reason that I can imagine a company sticking with an old version is because it's easier. Easier, because it is included in the standard repos. Easier doesn't mean it's wise, better, or advisable.
What is this piece of shit of an article? Literraly every single fucking feature listed in framework 101 and available in any competitor. You want a reason to not use CakePHP? Even the name sounds stupid. You should hire new commercials because yours fucking suck.
this is called a spam. don't waste your breath commenting, just move on It should have been deleted on the spot but sadly mods here don't give a shit
I had a chat with Bobby after PHPBNL18 - he should have fixed the slides by now, but the talk indeed had huge mistakes :-\
The thing to consider is that you don't need a framework to do FP in PHP http://www.phptherightway.com/pages/Functional-Programming.html I tried writing a teaching document here towards that end: https://github.com/slifin/signal but I'm no where near complete and writing code this way can become at odds with modern PHP which requires classes everywhere even if they're not required, thanks to Laravel/Symfomy's dominance It's hard to do anything that's counter to a class based system, I suspect because Java developers came to our language and gave us Symfony, and Rails developers came to our language and gave us Laravel, but we never had a FP developers come to our language and give us a framework I think because FP developers are smaller in number demographically which means there's less demand If any one is interested in writing a framework that does all the singing and dancing that Laravel does in a functional way let me know I'll try and contribute time towards that, but what is hard is that the eco system as it is geared up for classes, I think the main blocker may be autoloading for functions not working in PHP
Report it, and then move on
&gt; in case he deleted his tweet to try to convince you Not deleted. &gt; I don't care. You cared enough to bring it up here and keep responding about it. You're overwrought on this topic.
Thanks for the mention. :-)
I used Laravel as my middlewear framework to communicate between Magento and Ionic (Angular) and It works quite well. However, the Magento SOAP API is absolutely horrible.
Seems like a package to solve a problem nobody really has :/
Thanks! PhPspec is so amazing for tests :)
Thank you for your reply, So your set-up works like this? Ionic -&gt; REST -&gt; Laravel API -&gt; SOAP &gt; Magento API I've saw also the following set-up [here](https://github.com/Wildhoney/Magento-on-Angular) AngularJS -&gt; REST -&gt; Laravel API -&gt; Magento Code
&gt; Lots of things compiled against PHP5 don't even compile against PHP7 if you've got binaries (and nearly everyone does) IONCube or some other crapware? PECL Http for example might just be knowing where to look * OpenWRT uses PECL HTTP, so I went there and sure enough, PHP7 https://github.com/openwrt/packages/tree/master/lang/php7-pecl-http for PHP7 &gt; Not to mention expensive and time-consuming regression testing of the entire codebase. What is the most expensive part? What is the most time-consuming part? &gt; If you've got lots of complex applications and business requirements, even PHP 5.5 to PHP 5.6 is a pain. I'm assuming you have a list of these "blocking" issues as part of such a large and esteemed endeavour? Maybe see if the company can pay someone else to migrate parts of the application in chunks. Hold dependencies at arms length in future. Very little has changed about HTTP itself, so you should have been able to run side-by-side implementations in a single codebase to evaluate other HTTP libraries.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openwrt/packages/.../**php7-pecl-http** (master → faa8ce7)](https://github.com/openwrt/packages/tree/faa8ce76907390256476079c2dfa49bbd4f83cf3/lang/php7-pecl-http) ---- 
I'm not sure I understand which one you're refering to. Autoloader won't fire up if the FQ name is already loaded (included, hardcoded or loaded with higher priority "test-autoloader") - so the static class namespace from different file is not a problem. Non namespaced functions can be overriden with namespaced ones, because namespace takes prcedence before fallback.
&gt; if you're just assembling plugins in a CMS, then it can't matter less. ... :eyeroll: Don't defend yourself by throwing WP under the bus. It's one of the largest most successful PHP projects there is.
The amazon thing was a bit jank. Amazon, Facebook, Ebay all have gargantuan size and are unicorns in their own right. Nobody should be copying them because their success has very little to do with engineering. They also do not have massive monolithic piles of shit, but that's less on you. You should be ***Able*** to deploy to production at least once per-day (I'd probably kick off if I had to wait a day). How else are you building new cases from anything discovered in production (don't be telling me there is shit you're not having to use APM or logging to discover from people not using as intended or doing things you couldn't predict without a live audience). 
Is there some reason why people insist on using 1/3
twitter to form complex ideas when 2/3
linking to a blog post is just so much easier? 3/3
How does God 
Taste like? 
If you're on something like RHEL which maintains LTS for years and years then it's a fine policy from a security standpoint.
So... when are they fixing their stupid BC fixation?
http://www.bbc.co.uk/guides/z3whpv4
I'm not kidding I can barely understand the sentences your words are trying to form... Maybe tone down on the "shit" mentions and focus on clarity :P Amazon is a great example for the concept of modular service-oriented approach. Naturally, the "deploys every 11.6 seconds" number doesn't apply to most organizations, but the principle of resilient independent services and apps should, in most cases.
First thing could be https://twitter.com/CiPHPerCoder/status/960760569740570624
&gt; Don't defend yourself by throwing WP under the bus. I didn't insert WordPress into this conversation, /u/pixel_of_moral_decay did, direct your criticism there. &gt; It's one of the largest most successful PHP projects there is. I don't give a damn what it is, this is irrelevant to this discussion. 
So it’ll be even faster to backdoor? 
/r/bingingwithbabish appears to be leaking
please please please...ive been dreaming of namepsaces since php4
 You can use mb_strlen($string, '8bit') If you need a function that counts bytes and not code points, no matter if func overloading is enabled or not. By the way, Symfony provides a a [Library](https://github.com/symfony/polyfill-util) that provides a binary safe wrapper just like that, so you don't have to write it yourself.
By "Write it yourself", I don't mean you actually have to write it yourself, I meant a library (written by you or someone else), not something that is done natively.
&gt; WordPress's automatic update feature can be a boon for security: It stops 1day vulnerabilities from being massively exploited by skiddies. &gt; However, as implemented today, it's far too dangerous to ignore. And ignore is exactly what WordPress has been doing. Whats even worse is that when this came out, every theme, plugin and their mothers dog implemented this and you had a SHIT TON of security issues.
&gt; So your set-up works like this? &gt; Ionic -&gt; REST -&gt; Laravel API -&gt; SOAP &gt; Magento API Yes. &gt; I've saw also the following set-up [here](https://github.com/Wildhoney/Magento-on-Angular) I've tried a few of these before and non of them are even close to being good enough. 
In fairness, I don't get it. If people cared about this person's opinion, they would click on the link and get a nice article to read. This nonsense of splitting up content worthy of being an article into 10+ discreet tweets is an asinine way of abusing Twitter. Right tool for the job people! Twitter was never designed to present articles.
Sounds like a good opportunity to learn and grow. Think of it this way, a lot of people have to pay for their education. With this new project, you'll be getting paid to learn. Not a bad deal if you ask me.
This is cool and all, but I rather not have all my code depend on this if I don't need to.
Assuming you're full time, that gives you 40 hours a week to read tutorials, watch tutorials on youtube, browse stackoverflow threads, post questions on reddit. It sounds like you should start with Angular 1 (AngularJS), Postgres, and Heroku tutorials ;)
People don't follow links, they will follow a twitter thread though
You said in your original post your boss knows you don’t have the knowledge. Surely he expects you to learn as you go and it will affect delivery time. Do the best you can and give realistic updates when your asked. Sounds like a chance to learn a lot at work!
I work full time indeed but none of those 40 hours are meant to be used on learning, as I said I'm expected to deliver
My boss literally said he isn't giving me time to learn, as I told him I have 0 knowledge of anything needed for the project, he said I'll figure it out as I go along but in the same sentence he said x, y and z should be done by the end of the week
No.
Sounds like you should go work for someone who has a clue what software development looks like :).
&gt; I really like the idea of code being strict because it prevents errors in the application. E.g. strpos usually returns int, but it returns false when the $needle was not found. It would be much better to throw SubstringNotFoundException in that case. I think this library is not for me. In my opinion not finding the substring is a common case that is not worthy of an exception. I agree that `false` is bad; it should have been `null`.
Thankfully I'm not involved with maintining Magento! It's currently 1.9 and I expect we'll be moving to v2 sometime soon. It would have samed a lot of trouble if we migrated before trying to make a mobile app.
I don't get what was the problem with rabbitmq using consuming acks... 
Sounds like you have no choice but to learn. For the record: Fuck angular.
Part of figure it out means learn on that. Look at what packages was he using, if there was any kind of testing... Take a look at how it works... 
Let me guess, out of the box AMP you can't disable? The twenty-18 theme will now only render correctly in Chrome? Rewrite it all in JS? 
How does something like this for unnoticed in something like Joomla? That's pretty easy to spot
If I was writing anything "official", it wouldn't end up on Twitter. It would end up on https://paragonie.com/blog instead. What's the problem?
**If I were**
Maybe if you spent less time on reddit and more time working then you could it out. Just kidding. Out of the x,y,z requirements, pick one and focus completely on it. You got three days to do something. And the thing is, if the boss is the owner then okay he can fire you. But if not then just make sure you document what is going on. Get the boss to put his requirements and schedule in writing. Human resources might be interested if this goes badly for you. At the very least it would make a good post-employment social media post.
You have a couple of choices. Figure it out as you go, or quit. None of this is brain surgery, and no one dies if you mess it up. Unless this is a brain surgery app, then you may want to reconsider. I would think a junior dev should understand what a database is, how hosting works, and what a js framework is. Just because you haven't used X database, Y hosting, or Z framework shouldn't prevent you from digging in and figuring it all out. Why are you hesitant to give it a shot? If you only stick to what you know, you'll never learn anything.
Just keep him updated on your status, and make it abundantly clear where you think you are in terms of whats outstanding, and whether or not you are going to complete it by his deadline. He can want whatever he wants, but at the end of the day that shit isn't magically going to happen. All you gan do is keep it in his face that the project is "in the red" until it changes to "yellow" or "green". Sounds like this is going to be a learning experience for him as well.
PHP usually provides the line number of the error. Based on the line number, which method is it failing to reference?
You can't learn it in the way you're used to, like in modules, everything in one go, you'll have to do it bit by bit, being efficient searching for the answers to problems
This is my plan so far, but I want to find some way to make it clear to him that I can't just make stuff whilst not knowing anything about the stack that is used for that project. When he says I won't get any time to learn when I tell him I need time, I wonder how I can make it clear to him that shit isn't just gonna build itself
this is the error: invalid argument supplied for foreach() in /Users/jonathanhendry/OneDrive/Uni/Year 2/Client Server Systems/Assignment/Interactive data driven website - part 1/Views/index.phtml on line 17
It looks like you're calling your view before you've created your itemset, move the index.phtml require to the last line and you should be good to go.
I've been job hunting for a while now, sadly without any luck. I started working there after I graduated and learned a lot, but after a couple of months I started noticing some stuff like, we're still using cake 2, no biggy but the reason we're not upgrading is because the senior dev doesn't feel like it, still using php 5.5 cause once again the senior dev doesn't want to upgrade, we're forced to use windows + wamp + phpmyadmin because our senior dev doesn't want anyone to use anything else, I've used heidisql for example and I got berated for it... no testing because writing tests is a waste of time, according to the senior dev it's unnecessary if u write flawless code... and the list keeps on giving. As a junior I don't feel I can judge if this is normal but when decisions are made because one person doesn't feel like it, it seems off
Wow that fixed it, it’s always something so small haha. Thank you so much!
After reading through all the comments, you do seem like you don't have any effort to learn, try, or do anything but stay a 'junior php back end dev'... This is obviously a test your boss is giving you to test your dedication, effort, and willingness and I completely understand why he's doing this. 
I've been coding php for 20 years, at least five years of that has been hunting missing semicolons.
I was all excited that I knew the issue but came to find out the answer was already stated. :( lol
It's 2018. Why does ANYONE still use SQL queries without just using prepared statements? This problem is so stupidly easy to avoid. Who makes these frameworks?
It's possible that's the way he works, and expects you to do the same? I had a project once where I needed to use the FedEx API. Their SDK choices were slim, and using the Java SDK was my best option. I've never used Java before. It didn't take too long to cobble together a hello world Java app, learn ANT, and create a horribly coded abstraction to deal with the FedEx SDK. I would say I learned it all as I went. How do you compile Java? Google "compile java", cut and paste, run it a few times, move on. I would expect any junior dev could do that in 20 minutes. I probably do this 10 times a day for various things I either don't know how to do, forget the syntax, etc... I'm sure I could have spent a lot more time learning, and honestly, I wish I had the time to do that. Java seems cool, but I needed to finish the project and move on. In general, I try not to say no to anything. If I don't know something, someone out there does, and has probably written about it on the internet. FedEx didn't have a PHP SDK when I needed it, I could have said no, but I didn't. It slowed me down a little, but didn't stop me. Maybe he thinks by give you time to learn, you're gonna buy some books and read them for a few weeks?
Hopefully the project zero team helps make it a bit more resilient to attack. As a host of about 200 sites, it seems every week I need to suspend someone's account because their WordPress site got compromised and is sending spam email or is trying to brute force other sites. 
I'm not the type of person to pat people on the back and say it's going to be ok, but look at it like this; Remember in school when your professor would give you an exam and said "Do your best" but you didn't even get close to completing the test before class was over? This is the same situation I feel like. I would imagine he's testing your dedications, willingness, and see if you're worth keeping around. As far as the pay goes, in this field, you can never request a pay increase if your boss can afford to lose you. Strive hard to be the best of the best and get in a position that if you were to quit, it would hurt the company. Takes years to do this, but with enough effort, it will happen and when you're in that position, you can request as much as you want. 
Have you asked your boss if there is someone there to mentor you? I.e. someone you can discuss things with, help you get up and running. As you've stated, you explained that you're in over your head. If you you also explain to your boss that you're willing to take this one providing there that will be some understanding on his behalf. Start with fixing small issues and deploying it to production. 
I usually browse open source projects I've used in the past and see if there is anything in their issues list that I can tackle. Sometimes its low hanging fruit, sometimes it turns into big things that take waaay longer than expected, but always a great way to learn and give back. So whatever libraries/projects/frameworks you've used in the past and you are familiar with, give those a shot :)
&gt; In my opinion not finding the substring is a common case that is not worthy of an exception. I agree that false is bad; it should have been null. This is not actually something that is in the library, it is just an example of how interfaces in PHP are convoluted. Also the fact if something should throw an exception or just return null depends purely on the usecase, thats why Consistence adopts the `find...`/`get... ` convention mentioned in the article. &gt; I decided to read the rest of the article anyway. ObjectPrototype should probably be named "MagicMethodDisabler" or something and should have been a trait. The naming of methods seems suspect too: ArrayType::containsValueByValueCallback. There actually is trait - `ObjectMixinTrait` mentioned in the article, also in the article is elaborated on the fact why the recommended way is inheritance (in this particular case). Agree that the trait could be named better though :( 
Don't worry there's many more to come ;)
Some outdated clients still only allow 140 chars
If I wanted to write a formal blog post (i.e. something I intended to share on this subreddit or elsewhere), I would have simply done so, as you can see in the link I provided in my previous comment. If you look carefully, you can see that this was kind of a vent/rant tweet thread rather than a collected, well-worded argument against WordPress. The point of it all wasn't even WordPress, it was about the role of infosec in general (and appsec in particular) to society, especially in the face of apathy and devoid of ethics or accountability.
What does BC mean in this context?
There was another person who posted he is in over his head. Give him a call and solve two bugs with one solution! 
I hope PHP hurries up with implementing Enums into the language. I refuse to make my code depend on faux enum implementations. I'd even be okay with it just becoming a feature in PHPdoc. Then at least static analysis tools would be able to identify invalid values and IDEs could automplete the class constants.
Backwards compatibility
you'll notice the fact that u/sarciszewski is not in fact the OP of this Reddit post, while they are the OP of the original twitter posts. It's almost as if they meant to communicate these personal ideas casually to their twitter following. Devs are humans to you know, just sayin. 
For those that don't want a long Twitter screed: &gt; I've drafted several blog posts in the past week and scrapped them all. None of them feel important enough to write about, let alone publish. &gt; &gt; &gt; &gt; This isn't coming from a position of writer's block. This is coming from a position of empathy. Time is precious, and I hate to waste anyone's. &gt; &gt; ‏ &gt; &gt; Application security: I don't know whether it's better classified as "poorly understood" or "underappreciated". &gt; &gt; ‏ &gt; &gt; But when you look at information security as a whole, it's woefully underappreciated, even if you count all the vendor bullshit and cold sales calls. &gt; &gt; ‏ &gt; &gt; There wouldn't be a need for sales/marketing to cling to buzzwords and manufacture hype if the world at large already appreciated what we do for them. &gt; &gt; ‏ &gt; &gt; And then when you encounter situations like @Equifax, the insult compounds atop the injury. &gt; &gt; "Nothing we do matters, egregious acts of negligence that harmed millions of us are met with no real consequences." &gt; &gt; ‏ &gt; &gt; So if that's true: What does matter? This isn't a rhetorical question. &gt; &gt; ‏ &gt; &gt; In application security land, I've been fighting for years to improve the PHP ecosystem. I even rewrote most of libsodium in PHP (as insane as that sounds) just so WordPress (which pathologically refuses to bump their min PHP version) could sign their updates. &gt; &gt; ‏ &gt; &gt; I probably still would've written sodium_compat regardless, however, I wouldn't have included PHP 5.2 support if it weren't for WordPress. &gt; &gt; ‏ &gt; &gt; Why? Because it's a huge fucking threat to the stability of the Internet. &gt; &gt; You try blocking a DDoS that consist of ~27% of the websites on the Internet. &gt; &gt; ‏ &gt; &gt; Imagine circa-2012 Anonymous getting their hands on enough 0days (or getting lucky and discovering enough misconfigurations) to get into the update server for WordPress and poisoning the update file with their malware. &gt; &gt; That's a very basic supply-chain attack. &gt; &gt; ‏ &gt; &gt; I don't particularly care about WordPress as a product. I do care about all of the people that depend on it directly, and the fact that they're a single popped server away from being a source of disaster for the Internet. &gt; &gt; ‏ &gt; &gt; WordPress's automatic update feature can be a boon for security: It stops 1day vulnerabilities from being massively exploited by skiddies. &gt; &gt; However, as implemented today, it's far too dangerous to ignore. And ignore is exactly what WordPress has been doing. &gt; &gt; ‏ &gt; &gt; Not only did I rewrite a cryptography library to help solve this problem, I also wrote the patches to the WordPress core that would use this library to add code-signing (the first step in making their infrastructure not a single point of failure). &gt; &gt; Proof: https://core.trac.wordpress.org/ticket/39309 &gt; &gt; ‏ &gt; &gt; I did all of that, and was met with silence. Others have come forward with suggestions for stoking a fire under the butts of the people who have the power to make decisions, I point to instances where I did what they suggest months/years ago with no positive outcome. &gt; &gt; ‏ &gt; &gt; The reason WordPress hasn't solved this problem isn't because it would be a huge time/personnel demand on their end. The solution is on their public issue tracker, ffs! &gt; &gt; ‏ &gt; &gt; The reason is simple: They don't give a shit. &gt; &gt; And we can't afford to not give a shit about WordPress in return. They're too big to fail, and I don't envy anyone who ever has to clean a botnet of that magnitude. &gt; &gt; ‏ &gt; &gt; What can we do? &gt; &gt; Other than apply economic pressure to Automattic (the company that employs most of the WP org core committers, paid for by WP com, and has the lion's share of the political power over the WP org community), I'm fresh out of ideas. &gt; &gt; ‏ &gt; &gt; It bears repeating and emphasizing: &gt; &gt; The work was done for them. &gt; &gt; The fucking work was done for them. &gt; &gt; The work was fucking done for them. &gt; &gt; ‏ &gt; &gt; There are other options, of course, but those are criminal, so don't even think about doing any of them. Just, NO. &gt; &gt; ‏ &gt; &gt; It's really hard to write about topics as banal as "how type-safety relates to software security, with examples in PHP" when this Sword of Damocles hangs over us all, and the fools propping it up remain silent. &gt; &gt; ‏ &gt; &gt; #39309 remains unfixed. As long as this is true, but Automattic's revenue continues to grow, every network on the Internet should consider itself at risk. &gt; &gt; ‏ &gt; &gt; I think I've done everything I can do. &gt; &gt; I'm going to stop trying and caring so much about what happens to WordPress, even if a disaster is impending due to a sleeping conductor. &gt; &gt; ‏ &gt; &gt; Instead, I'm going to focus more of my time and energy on getting CMS Airship v2 ready to release. If anyone wants to help make this into a viable and seamless replacement for WordPress, let's knock their market share down a few pegs. &gt; &gt; ‏ &gt; &gt; I'm not an artist, nor am I skilled at UI/UX. If you know much about these subjects, chances are you're far better than myself. &gt; &gt; Please consider making Airship less ugly. &gt; &gt; ‏ &gt; &gt; On the milestone for version 2: &gt; &gt; - MySQL/MariaDB support &gt; &gt; - Seamless migration and data imports from existing blog platforms (including WordPress) &gt; &gt; ‏ &gt; &gt; I've suspended any notions of a set "release date" in favor of making sure it's ready for production when the time comes. &gt; &gt; ‏ &gt; &gt; CMS Airship might not be able to make a large dent into WordPress's terrifying market share, but for anyone who migrates, your safety and privacy will always be priority #1, and not take a backseat to a shiny WYSIWYG editor. &gt; &gt; ‏ &gt; &gt; If you've read this entire thread, thank you for bearing with me. I have a lot of work before me, but I'd like to think that at the very least my effort won't be wasted (as it is with WordPress). &gt; 
&gt; the reason we're not upgrading is because the senior dev doesn't feel like it Was in your same situation. As soon as I saw that the people in my workplace didn't even consider improving the tech stack upon my proposal, I flew away really quickly and changed company.
It's funny when you see a news about Joomla, it's almost always about security issues. It's like Joomla and security problems goes hand in hand...
&gt; you can request as much as you want Well, unless the company makes an unlimited amount of money... Relax, I'm just kidding.
You ever tried migrating a multi-database non-PDO backed database API (originally modeled around ext/mysql because of the project's PHP 4 legacy) to one that supports prepared statements? That's why it's 2018 and Joomla core isn't using prepared statements. Well, that and the count of people smart enough to figure out how to solve that problem is quite low because there are very few truly skilled developers contributing to the project, and trying to fix architecture problems goes absolutely nowhere because the majority of active contributor skillsets is limited to things they can do from the UI.
I agree. Tight timelines would change things. It's also unclear on what they need to do with this application. Add an extra field to the DB, or rework an entire workflow. If it's a huge project with a close deadline, it's not going to happen.
I know facts are frowned upon in these sorts of discussions but namespaces were actually introduced in 5.3. http://php.net/manual/en/language.namespaces.rationale.php
as I said, I find this format annoying regardless of content or author. While I don't expect you or anyone else to change (even if I wish people would stop it), it also means I won't read it. I'll happily check out your blog though. 
I think u/Pesthuf meant 5.2. that's the officially minimal supported version IIRC. 
Nope. 5.3 as the link indicates. And yes I originally thought he simply typed 7 instead of 5 but when you get both digits wrong then it's probably a secret society thing.
Wordpress can't be fixed. Drop it and create a nice one from scratch!
Seriously. This is the kind of product where you put two poor engineers on rotation as minimal support while you use the rest of the team to write one from scratch.
*angularJS
wow ur so gud
&gt; I agree that false is bad; it should have been null. While null is better philosophically, in practice it's just as error-prone in the hands of a beginner: ... == null This is something that other languages have long discovered and we should just use it: return -1 on no match.
If you're making it fine without knowing WP, it's my opinion that you'll be fine without learning it. Out of all the "bad" clients I've had, 100% of them used WP. This isn't to say all clients who use it are bad, just that it naturally attracts those who want things as cheap as possible.
Amazing didn't knew that Google liked php
?int exists in the type system and with analysers you can find the error without teaching it about specific semantics of the function. The same cannot be said for -1.
&gt; Google dedicates engineering team to accelerate development of WordPress That's quite amazing, considering they hate the entire PHP landscape at Google.
I quit Wordpress.com (and usage of Wordpress with it) when I noticed they do not support DNSSEC - which also shows they don't care about security in general. They are actually the only service I used which does not support it.
Scarily enough, all plausible options.
Time for all three Joomla sites to upgrade.
Then you need to go to your boss and make that expectation clear that you need time to learn.
You can just tell him that this is like somebody gives him an unfinished plane. If he wants to fly with that plane, you first have to learn about it in order to be able to finish it. 
Well, my post on the new [Laravel QuickStart project](https://github.com/phpexpertsinc/laravel_quickstart) is definitely shadowbanned, and when I wrote that comment, it was shadowbanned, too... Couldn't view it in incognito.
He probably meant the officially minimal supported version for Wordpress. https://wordpress.org/about/requirements/
Alcohol.
When is the best time to purchase my ticket for this year’s event?
Every week? Sounds like somebody is dropping the ball on the management side.
There's is no one to mentor me no, the person that resigned was a senior dev/team leader where we junior's could go to with questions. Since he resigned our boss told us that he'll be looking for replacement but in the meantime we should help each other out. I've asked everyone else and no one knows anything about this stack
Well so far hes given me extra time to learn, first time I had to use soap or curl by the top off my head I had received ample time + I had a senior dev where I could direct my questions to, now I have neither. I know I can do this eventually but with no time + no one to "mentor" me and a tight deadline I know it isn't possible, the project is a massive one, as we only make fairly simple websites, this is a globally used chat application where the company outsourced some work to us. For example I got a couple of hours of explanation on the app, with 0 knowledge of the stack, the senior dev received a full 2 weeks from a senior dev of the project just to get him started, while he had ample knowledge of the entire stack. 
I see the difference, but you're confusing the language. We're talking about PHP here. Static analysis only works reliably if you have everything strictly typed through and through. Put this result in an array and what happens? You can't specify the array type. So don't pretend as if static analysis in PHP is the ultimate solution to everything here.
Jump to PHP 7 turn off 75% of your servers and still get latency and throughput better then PHP 5. PS. Your company looks like somewhat sane. Is there budget alloted for making code PHP 7 ready too?
Only **if** RHEL take upon itself to backport security patches from newer versions of PHP, as PHP devs **will not do it**.
You mean why we had to rely on Exchange to Exchange pattern ?
Try https://boreddeveloper.io/ lol
Yes... Why do you need that instead of a single rabbitmq queue? 
Did you miss a word?
I'm still looking for the easiest way to run Gitlab+Kubernetes CI pipeline on VMs with failover. :/
Testing..
Utilizing more javascript than php, while retaining all the favorite hook and class functions, would be interesting.
^ what that dude says I've never had one single WordPress project I honestly enjoyed.
When you have users managing their own sites, installing crappy plugins for basic functionality left and right, that kind of thing is inevitable with WP :(
You could almost say he ignored it
Stated goals from the Google Developer Advocate's blog: 
&gt; PHP has a lot of array-manipulation functions, but using them is difficult What
Cool project, it would be nice to have a popup/modal showing some info on the package before deciding to open it. ;) 
Nice project, I found some interesting packages, thanks. But you are loading packages for every request? What about caching it? The order on first let's say 100 places will not change that often. You can download new data like one per x hours.
It's not clear what your question is. For Apache, make sure both Apache and PHP are built on same VC version. For newer PHP versions, you'll need VC15 Apache builds and VC15 installed on your computer as well. 
With +1 buttons for every post and comment. 
Source for this? Seems hard to believe. 
WordPress talent pool is over saturated and WP uses next to none modern PHP practices that you can transfer. Once you get onboard, you'll be stuck in the island forever. 
yea i noticed him in an instant, laracasts forums are a treasure though, at least for beginners 
ah so i have 2-3 more years :)
Just use xampp or wampp for viewing PHP code in real time (also HTML JS CSS etc) and you favorite editor?
I've noticed that many packages are missing from search results.
Atom is a good editor but you'll need xampp or wampp like the other guy said.
Atom need a lot of setup to be a functioning php editor, imho.
First off: This isn't really a PHP specific question, and PHP is probably not a good choice for writing the core of your project in. :) As for your actual questions, your example is a bit general for me to really come to grips with, I'm afraid. One thing you could do is look at how simcraft (https://github.com/simulationcraft/simc) works; it's an open source project for answering this sort of thing for the game World of Warcraft, written mostly in C++. (They do it by simulating a fight over and over, since WoW combat has a lot of randomness and gear, legendaries, talents, trinkets, etc., interact in a number of complicated feedback loops.) If your specific requirement is simpler, that may be overkill, but it's probably the gold standard as far as this type of project goes. More generally, one way to do this is find a way to turn a given gear set into a "score", then do the same with 5 more crit, 5 less crit, 5 more speed, 5 less speed, etc., for everything. That gives you, more-or-less, the "weight" of each stat, and then you can compare that to upgrade costs. And you can repeat that at many different starting places to chart a graph, if that makes sense for your game. The key is, I suspect, going to be finding a way of turning a set of gear into a score. Again, simcraft does it via a fairly elaborate simulation of the game, every spell, every ability, etc., which is a requirement to get even somewhat correct answer for a game like WoW. If your game is similarly complex, you'll likely need to do the same. if it's simpler, maybe you can find simplifying assumptions. Eg, you say: &gt; if [...] accuracy &lt; 50, adjust the accuracy weight accordingly My experience is that it's actually quite hard to estimate the results of accuracy in these types of situations, and there's often surprising exponential effects, diminishing returns, feedback loops, etc. For example, the value of 1% dodge chance, in terms of its impact on incoming damage, varies hugely as you got from 10% to 11% versus 90% to 91%. The value of crit chance varies hugely if there's any skills or effects that depend upon it (ie, if crits cause a bleed effect, and additional cause it to stack and resets the duration, crit will have increasing returns. If it causes a bleed effect but it doesn't trigger if one already exists, it has diminishing returns. But in either care, the value of crit will be non-obviously influenced by attack speed, etc.) Then again, if it's simple enough, maybe you *can* just come up with some simple formulas. :) In any case, hopefully that gives you some food for thought.
Good one but it doesn't make sense to have it separately from packagist. I'd try pinging @Seldaek and getting it merged into packagist.
VScode/Atom/notepad++ with XAMPP or WAMPP installed, nothing beats that :)
Although technically you can, a variable variable cannot offer you anything an array can do, the latter being a multitude more reliable. So there is a little point in this feature even in PHP. So your code simply should be $array = ['bar' =&gt; 'baz']; $foo = 'baz'; echo $array[$foo]; //baz
Hey thanks for the amazing in-depth reply! The game in question is much, much simpler in terms of gearing than WoW is... I'd say probably .1%, if that even, of the actual gear combos and options. Each class has a pretty defined road map for gearing up, but a ton of players don't know exactly how to go about it, which is why I am doing this project. I figured it'd be small-scale enough to not require an external program and could fully be done in a web app platform, since it's not going to be doing millions of iterations to test average damage or anything, it's literally a "do they have x attack, x defense, and below x accuracy? go attack + accuracy", with no actual DPS sim needed.
And it’s much easier on the brain to read.
Not really? All I use is one of their packages for linting and it works perfectly fine. 
All that's left is for them to create their own version of Jav-- Oh no, Microsoft from the 90s is back.
Something tells me a huge amount of developers here would disagree... :-) But the best for you obviously is the one that works best for you. 
Your comments are interesting so let me know your tools too! I bought pinegrow years ago and it's good but not suite my taste
Brackets but u need to connect bracket to local host via xampp but it works fine 
In Javascript you can use window["variable_name"], but only for global variables. For scoped variables you'd have to use eval('variable_name'). 
Xampp is nice for small projects, but when you go into multi-domain and other more complex systems, it's getting to its limits fast. I have it running, when I want to try something out quick or for smaller single-page-projects that I'm working on. For everything else, I rent a server for about 5 bucks a month. When it comes to editors I've tried a lot, but I'm currently working with Brackets and I love it. I think Atom isn in the same ballpark though. you could use phpstorm. I think it runs with a xampp server internally so you can debug php and html locally, but I'm currently not willing to pay $200/year for a "glorified text-editor". When it comes to servers, xampp &lt; virtual machine &lt; real server. Xampp is great to start out with. It does what it is supposed to do for most projects, but you will find it's limits one day and that's when it just won't cut it anymore. 
What a great domain name! Cool project, good luck.
It kind of sounds like y’all overcomplicated the rabbitmq setup that y’all became frustrated with it and convinced that it just wouldn’t work and needed a whole new solution.
Imo, having to learn on the job is part of the job. As I see it, your boss has given you the task to test how you would respond to it. If you completely fail it, he'll probably only give you mediocre boring tasks in the future. If you solve it anyways, you'll get more complex, more interesting projects. There are two types of programmers. Those who know a little bit and do only that and those who know a little bit, but always try to push their limits. One will always be the junior, the other is on a fast track to senior. So my suggestion is, get the Angular Documentation. get the postgress documentation and get the heroku documenation and start reading like you've never read before. 
Which, as far as I know, is literally what RHEL does regularly. That's one of their major selling points. The PHP devs don't support the versions of PHP that RHEL ships with/has repos for. RHEL 7.1 comes with 5.4 which was EoL'd 3 years ago.
Why not use just github? https://github.com/search?l=PHP&amp;o=desc&amp;q=php&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93
Good job! Keeping an eye on this...
Now. We purchased "Blind Bird" tickets in December which is the only option cheaper than early bird tickets.
I'm going with a couple other programmers from our company. Are there any good options for stuff to do Thursday and Friday nights?
This is simply an example implementation of a Slim application. No explicit code helping to ease the pain of setting up an API. Some interesting things are: e2e examples are written in Python; the documentation refers to a script to install composer, which does not appear to exist but instead a complete composer phar is committed along with the rest of the code. The lock file is committed, which is debatable in the context of this repository. The composer package is defined in a subdirectory of the repo, so no package hosting would accept it. The code is inconsistent in using typing. To me it has not become clear why OP is sharing this repository
We had the need for 2 things: * Being able to guarranty that each and every messages sent by the source was consumed * Each and every message had to be consumed on all clients We ended up doing Exchange to Exchange because other options we found didn't work: * Messages were lost when client didn't connect at least once * Messages were distributed amongts clients (not delivered to each) * ...
There are *tons* of things to do in the mall, The upper level has a bar / bowling / gaming area. There's tons and tons of restaurants as well.
It did work and worked well. The implementation might have been more complex than needed I agree but our switched was guided by more than this: * Having to deploy &amp; administrate a RabbitMQ server is more complex than Redis. If you come on tuleap-devel or tuleap chat you will see that installation questions of something basic like a DB, fpm and nginx already triggers at lot of questions. Adding RabbitMQ to that vs Redis, the choice goes to Redis * We found "by chance" the Redis Persistent queues that are simple and fit exactly our needs while we only found the E-2-E pattern when we actually looked for sth on RabbitMQ. It might shows that we are bad at googling or bad at RabbitMQ. I don't say RabbitMQ is bad, it's far from that. But our needs are better suited by Redis so far.
Thank you for your review. This is exactly why i share this repository.
With the Radisson Blu attached to Mall of America, there are **tons** of things to do. * Go to Sea Life Minnesota Aquarium under the mall and walk through tunnels looking at tons of different types of fish * Head to the fourth floor and go to either Game Works for Smaaash to play some games and eat some food * See if there are any shows going on at the House of Comedy on the fourth floor * Ride some rides at Nickelodeon Universe in the middle of the Mall * Play a game of mini golf at Mouse Mountain near the third floor north food court. * Speaking of food, go check out one of the many resturants along the south food court. (On of my favorites is Cantina Laredo) * Don't feel like staying at the Mall both nights, catch the Blue Line light rail to downtown Minneapolis (about a 45 minute ride) and checkout all the sights and sounds they have to offer as well.
It’s a link to the GitHub project
If you look at https://github.com/MeteHanC/Basic-REST-API/blob/master/API/src/Class/StudentController.php, the constructor correctly types your repository, yet the methods below don't force types on your parameters or return values and there is no documentation to make up for the lack of them, in case you're supporting an old version of PHP.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [MeteHanC/Basic-REST-API/.../**StudentController.php** (master → e18ed83)](https://github.com/MeteHanC/Basic-REST-API/blob/e18ed83fe1759e4d323a8c9ca707bffc40b97dd8/API/src/Class/StudentController.php) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtvltq8.)
My bad 
Thus confirming their statement
It's all good. We all have those moments we overlook something.
 public static function query($query, $bindValues = null) { // Connect to the database $connection = self::getConnection(); // Query the database $PDOStatement = $connection -&gt; query($query); if(is_array($bindValues)) return $PDOStatement -&gt; execute($bindValues) ? $PDOStatement : false; else return $PDOStatement -&gt; execute() ? $PDOStatement : false; } This is a straw plane that never flies. This function doesn't support any binding actually.
Oh, I see, I used query() not prepare(), I'll fix this now, I didn't actually use these functions inside the project that's why such a mistake slipped off. 
&gt; However, some research revealed that Postgres has a constraint type named REFERENCES that supports the feature natively: I don't follow - a `references` clause is just an ANSI compliant foreign key constraint?
you can make it unconditional though, execute is fine with null. $PDOStatement = $connection -&gt; prepare($query); return $PDOStatement -&gt; execute($bindValues) ? $PDOStatement : false;
I'm sorry. I have a project to build a website, I use PHP in local xampp server. Last week, I started and used xampp ver. 7.2.1. Yesterday, I tried to use another version of xampp, it is 7.1.13 and 7.0.27. when I tried the ver. 7.2.1 and 7.0.27, the program worked, but when I tried the ver. 7.1.13, my program didn't work. I have checked VC++15 but it is installed in x86. in my Programs and Features there are VC15 x86, VC12 x86 and VC12 x64. should I install VC15 x64 first?
Ah so! I misunderstood the PG docs to mean that "refcolumn" was on the native table, not the foreign one. I'll update the post. Thanks!
At that scale, you should have a hardened web server with passive and active monitoring systems on every single touch point. People sell hosting for $2 a month and then get mad they have to put in work. I have been in the industry for over ten years, and I make sure my companies have a clause that covers our basis (from liability and compensation standpoint) if somebody is negligent. If your account gets hacked it will be limited to your account; we will charge you to wipe everything clean, do an audit for you, and help you restore services.
Surely many already knew this? and the title is just clickbait really, the content has nothing to do with "Putting PHP 8 on the map".
About https://wiki.php.net/rfc/fallback-to-root-scope-deprecation. When you call str_replace() inside a namespaced file, it will search first for Namespace\str_replace and then fallback to the global str_replace function. The question: * Is it done at runtime or can it be done at compile time (it is, optimizable by opcache)? * How slow is this? * Is it a good idea to call the global function explicitly \str_replace, even though your code will be way less readable this way? Thanks!
&gt; Static analysis only works reliably if you have everything strongly typed through and through. There is a degree of efficacy that increases as type strength does, I agree. However, you do not appear to actually be using the existing static analysis tools with PHP. Psalm, Phan, and PHPStan are the three I have some direct experience with and they all support checking `?int` in some fashion.
Sorting by packagist download count might be better.
I have a question regarding Doctrine configuration. Using Doctrine 2.5. I have two entities, Customer and Location. A Customer has a OneToMany relation ship to Location (one customer can have multiple locations). However, one of these locations can be marked as the billing location. Right now, I have an isBilling field on my Location entity, and a Customer can loop through a list of Locations to find the one where isBilling = true. This seems hacky and error prone (complex validation or database level validation/triggers to ensure there's only ever one isBilling = true location). What I would like to do is have a billingLocationId field on my Customer entity, and just point that to the correct Location.locationId value. Doctrine is not letting me do this. Here's my configuration. **Customer.orm.yml** manyToOne: billingLocation: targetEntity: Location joinColumn: name: billing_location_id referencedColumnName: location_id When I attempt to construct a new Customer object, hydrate it, a new Location object, hydrate it, and then call Customer.setBillingLocation($location), the database complains that the location.customer_id value is null because Doctrine is trying to insert the Location entity before the Customer entity. The only way I've been able to see around this is to create a new Location entity, persist it, then create a new Customer entity, persist it, and then set the Customer to the Location. Is there any better way to go about doing this? Thank you.
I personally think that it's a great learning experience to try and develop your own framework - it helps you understand how to properly structure your code. But existing frameworks are very mature because their authors have probably made every mistake in the book during their development experience. Especially in security, as it's somehow overseen by non-senior developers. For example, here you have a Cross-Site Scripting vulnerability which will allow an attacker to steal a user's credentials: https://github.com/SherifAbdlNaby/Ciro-PHP-Framework/blob/3f926d65397d7c4756054a6b3b317ad9a5a33e25/Views/Web/Account/Login.html#L7 &lt;form method="post" autocomplete="on" action="/Account/Login?returnUrl=&lt;?= isset($_GET['returnUrl']) ? $_GET['returnUrl'] : '' ?&gt;"&gt; If I set returnUrl to: "&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; if will display an alert box with the document's domain name. I'm not saying any of this to discourage you, but to be more mindful of all the things existing frameworks support.
Where have you been all my life? This is awesome!
Rounding issues. I suggest always using integers (once you have fixed the number of decimal digits you want) for doing this calculations. If you are dealing with USD you should then consider amounts in cents.
Congratulations on your first CMS! Many PHP programmers have been down this path, including myself. A gave your application a swift look and I have a few comments. - Your application is not modular. It's very hard to extend upon or doing anything beyond serving HTTP content. Especially since your root namespace is "App". This is a boilerplate, but it cannot be used as a library like Zend Framework, Symfony, Laravel, etc. - Autoloading "." is dirty. At least put your service-side logic in a "lib" or "src" folder. Here's a decent template - https://blog.nikolaposa.in.rs/2017/01/16/on-structuring-php-projects/ - but a [Google search](https://www.google.dk/search?q=basic+php+application+folder+structure&amp;oq=basic+php+application+folder+structure&amp;aqs=chrome..69i57j0.6310j0j7&amp;sourceid=chrome&amp;ie=UTF-8) on the matter will get you much further. - Your PHP code could use a [PSR-1](https://www.php-fig.org/psr/psr-1/) and [PSR-2](https://www.php-fig.org/psr/psr-2/) brush-up. - You'd get so much handed to you by implementing more PSR features, notably [PSR-3 Logger Interface](https://www.php-fig.org/psr/psr-3/), [PSR-7 HTTP message interfaces](https://www.php-fig.org/psr/psr-7/), and particularly [PSR-15 HTTP Server Request Handlers](https://www.php-fig.org/psr/psr-15/), although the latter is relatively recent. - There is little to no parameter validation. - Your API (how you as a foreign programmer actually code in your application) is not entirely clear or solid. E.g. `$this-&gt;meta['title'] = 'About · Ciro';`. - There are artifacts in your code base. E.g. `.disabled.mongo.userrepository.class.php`. - Capitalizing the first letter of your folder gets really annoying if you work in a terminal. All that extra [Shift] massage for no reason. - In MVC, "Views" are not HTML. This is a common mistake, so don't worry. Views are the means of rendering data, which is usually provided by a Controller, which grabs it from one or more Models. HTML, Twig, Handlebars, etc. are templates. This is not to say controllers should get bloated by any means; I rather like the "[Thin controller, fat model](https://stackoverflow.com/questions/14044681/fat-models-and-skinny-controllers-sounds-like-creating-god-models)" mantra. Keep it up! There's definitely potential. :)
Also project activity. One of the main things I look for before using a lib.
I agree. It is really as simple as "don't install non-trusted plugins and keep everything up to date." We cant have nice things though. In these cases the client can either pay someone to fix their site or take their $5/month elsewhere, because its simply not worth my time to fix a site they obviously don't care about. Besides, if keeping up with updates isn't the clients thing then I try to push them to platforms like SquareSpace where that sort of thing is managed.
Thanks!, This is definitely a vulnerability, I was thinking about touching the views part more, though this is definitely a mistake, it is not actually a part of the framework itself but the sample example built on it. I will fix it !, I heard that popular frameworks has render engines that helps avoid such mistakes, I will check those and see how they approached the views part.
Correct, with an exception that it should not happen every week with only 200 accounts. Unless he is severely overestimating that figure by 6-12 months. 
What if I only have the float numbers available as string (initially)? What I'm trying to do is to get a separate display of the number and its percentiles, but I don't want to use explode or any other hack'ish method.
Thank you so much! There is definitely a lot to learn and read about in your reply! I didn't know about all these PSR-'x' standards. I didn't even use PSR-4 at the beginning and actually had my own autoloader, I only knew about it when I wanted to use Mongo and had to use Composer which forced me to not use my own autoloader and taught me about PSR-4 and Namespaces in php. About the directory naming, at the beginning they were lower-case, but when I implemented PSR-4 I changed them, PSR-4 naming uses CamelCase, and by debugging I found that the paths created by the autoloader matches the CamelCase-d names, so i thought having lowercase directories/files might introduces problems in case-sensitive environments. Once again, thank you for taking the time to review my work and write this awesome reply, I will study and learn about everything you mentioned and try to include that in my project.
&gt; The reason for this is because semantic versioning is a "reductionist" way of determining if two pieces of code are compatible I would love to know what made you come to this conclusion as Semantic versioning is one of the most popular ways, to my knowledge, to version something.
While this is a cool project the issue I have with the focus on github stars is that the projects that are just as good, but less known, thus less github stars, never get known. The focus on stars is a false way to measure some ones project IMO.
Yes build a better less magical laravel. Just kidding. Oh and its due by tomorrow at midnight.
There's this thing called casting. If you have these values as strings just cast them to float and then multiply the float by 10 times the number of decimals you want. After that you just cast to integers. This is not a hack. Finance software work with integers, not floats
you forgot to mention that there is no such thing as restful api. This is just marketing term which basically means http api. Since you don't have HATEOAS and you overate with json instead of hypertext, since you have your app consuming this JSONs and not smart client (browser + human + code on demand), this can't be called REST. You could call it resty if you like, but it's not rest. And you don't need rest for your mobile app or SPA.
You *do* sound fun at parties.
Thank you, which kind of information are you thinking about?
meh. Barely any tests.
For the moment, PHPkg is a glorified version of what you posted, with a near-instant search, a friendly UI and a cross-check to packagist to provide `composer require` commands, but I've got a few features in mind that should really set it apart in the next iterations. 
I agree, see [my other comment](https://www.reddit.com/r/PHP/comments/7vv0sg/i_made_a_new_search_engine_for_php_packages/dtvy3a3/).
I guess he just feels that Laravel 15.30 should not sound as good as Laravel 5.6.
Why provide a drop in replacement for WordPress? That's a dumb idea, if you want to cut into their market share you need to convince the normies, not the developers. Normies don't give a shit about security until it affects them, you need a tangible benefit to business before anyone will switch. Also wordpress is shit and needs to die. It's almost entirely leaning on its eco system, I sincerely hope the central web service does get compromised do we can finally put this old dog out of its misery.
My car doesn't work. What's wrong with it?
Actually the project was born out of frustration from the way packagist sorts its search results, my first intent was to create a PR, but I quickly found out that the issue was reported frequently and never solved because they are using algolia, which makes it pretty difficult to solve apparently. Rather than having to learn how algolia works, and how it is used for packagist specifically, I decided to tackle the problem on my own.
Thanks a lot!
This is a very valid point and I will add several metrics in the near future to make great projects with few stars stand out from the big guys.
It does become rather frustrating having to keep up with double point (*.*.X) releases as they can contain not just bug fixes but new features as well under his numbering system.
Yeah, the tests are a priority issue. I used symfony and mpdf packages for a testing.
Rounding issues happen because the base 2 binary storage can't accurately represent the concept of recurring numbers. Use integers or the [BC Math functions](http://php.net/manual/en/function.bcsub.php).
Do you know how the performance compares to basic arithmetic operations? I need to split a large amount of numbers, in a lot of different requests.
No idea. Best to profile.
I see. Result is quite good. It responds well to queries like "framework" or "cache".
Alright. Thanks for your reply
Sounds cool - do be public about the formula when you do!
Just round them to the needed decimal... It's the only way I know
I’d rather 15.30 then the “epic sounding” 5.6
That would be awesome
You're going to hate being a software developer when you realize that'll you spend most of your career learning on the job
&gt; Why provide a drop in replacement for WordPress? For pretty much the reason you just outlined. &gt; That's a dumb idea, if you want to cut into their market share you need to convince the normies, not the developers. First of all, "normies"? Who says that? Second of all, that's *why* you need a drop-in replacement. Because if you want to convince business people and end users to switch over, you need to make it a seamless transition &gt; don't give a shit about security until it affects them, you need a tangible benefit to business before anyone will switch. Maybe, but saying "This solution is drop-in, almost no effort, and provides us with higher security" is an easier sell to business than "We need to swap away from Wordpress, but migrating us away is going to take us x weeks".
Is the next version going to be Laravel 7.0?
Am I the only PHP developer that don't use Laravel?
Don't touch the stuff myself. Symfony fits my use cases better thus far.
Nope! Some people also use CraftCMS ;)
There are dozens of us! 
Just try it for the fun on a boring day :) 
You are very welcome. Of course, if you move your PHP logic to e.g. a "src" folder, you should maintain the camelcase approach in said folder per PSR-4 definition. But most other folders - at root level particularly - are usually preferred in lowercase letters. A heads-up if you are renaming or moving things, use "git mv". If you're on Windows, use it with the "--force" argument.
Thanks!
I remember around the time Laravel 4 was getting really popular around 2014, the dependency on Symfony and use of semver was specifically being used to promote the framework as stable and backwards compatible for the future. How times have changed... Or maybe not. As a package maintainer that jumped ship before version 5, I know that Laravel has never followed semver, with massive breaking changes every single minor version, sometimes even in bugfix versions, and regressions only had a 50% chance of being acknowledged as bugs. Laravel's authors could have been open about this from the start, but chose not to. Now, instead of just saying "semver is too much effort, sorry", they're trying to discredit the benefits of semver entirely. Even when I'm not using the framework, it finds ways to annoy me.
I don't feel this is a great metric either. Scoped projects don't need to change a lot over time, especially when they're an implementation of a well-defined spec. Recent activity may be a good thing, but not having any isn't necessarily a bad thing.
Depends on how you approach it. If a project has 20 issues and 0 commits in X then I would take this as a indicator that the project is dead. To some extend commits in itself are a metric of a project's health. Realistically even with a solid scope there will be always bugs, especially in larger projects.
What makes you say this? The same `redis` and `Memcache` are used for queues, and their atomic locks is what prevents the same queue job being run on multiple servers/workers simulatenously
it's sad to see them have to do a "upgrade guide for .b and .c releases instead of just a. releases. It, to me at least, shows an ignorance to semver and a lack of education around it's whole concept. 
Whatever the excuse, I think it's 100% because of marketing. The "reductionist" claim creeping into the docs a few versions ago looks like it's using [this](https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e) as a post facto justification for the stance. I mean, semver is entirely optional and it's completely ok to not follow it. A justification of "We don't feel it is a good fit for this project" would at least be honest.. Now I'll wait for the inevitable downvotes and tantrums...