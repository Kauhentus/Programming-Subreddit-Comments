&gt; all the new stuff like namespaces Dude, PHP 5.3 was released ~7 years ago.
Many languages don't even have an 'isset' or 'empty' function. I tend to prefer writing as if I were in those languages.
Your tools are enough for you now, you already have some momentum. You can probably live confortably without learning a framework for more 3 to 5 years, but... Shouldn't you think about the future? Learning a framework is an investment, you will be more productive when you are used to it. Why? Because you will have people fixing bugs for you for free. Creating packages to solve problems you didn't even knew you had. Preparing screencasts and tutorials that might save countless hours of research. Because you should focus in code that matters and let someone else create frameworks. Also in the future you might be required to learn a framework, and honestly, Laravel is pretty easy when compared to others. If you learn it now you will be closer to learning other frameworks. You don't have to switch everything to Laravel, a side project will probably be enough for you to learn and evaluate it.
I know a framework -- Codeigniter. I'm just trying to evaluate whether Laravel provides enough advantage to switch. I don't want to switch frameworks just because its the hot thing, only if it provides real value to me.
&gt; Shouldn't you think about the future? Every framework is the future, until it becomes the past.
&gt; The idea behind this would be to help reduce those downtimes, even though it may last a few seconds, and a lot can happen in those few seconds Those are some nice lines you got up there in that diagram.. would be a shame if a network partition were to happen to it. eh eh? If you're worried about downtime microservices wont help, you should look at blue green deployments.
There's a lot of misinformation and stupid statements in this amateur blog.
isset() set can be good for validation of input when you're not sure exactly what you're going to be receiving from the user and you might need to make decisions based on the data you are receiving. I validate my data on the client side and on the server side before that data is inserted into the database. Data probably shouldn't have to be verified before being displayed. It only needs to be parsed and displayed correctly.
This is exactly what I decided to do, though I appreciate everyone's opinion on this. Thanks.
check out Simple CMS http://get-simple.info/ Looks like it says 5.2+ for PHP version, and it is supposed to be easy to work with.. But I agree with /u/tonyrq switch hosts if they are still back on 5.2..
By the way, H(k || m || k) is perfectly secure; more precisely, it's secure in the same sense that HMAC is secure -- we have a proof of security, and the statement of the security theorem is the same for both. The proof is at https://eprint.iacr.org/2013/248.pdf
Do you have an example? I don't quite see a huge need for isset() and empty() on the create-update side either. try { $repository-&gt;addArticle( new Article( $request-&gt;post-&gt;get('title'), $request-&gt;post-&gt;get('author'), new \DateTime(), $request-&gt;post-&gt;get('content') ); ); // redirect success } catch (ArticleException $e) { // redirect with error }
Such as...?
&gt;PHP is an interpreted language that lacks a compilation step separate from the actual runtime. [...] PHP code is simply executed straight from the source This is patently false. The whole segment on *Function Return Values* doesn't make any fucking sense. &gt;Something that may cause some irritation is the fact that you can't use isset and empty with functions: &gt;isset(myFunction()) &gt;empty(myFunction()) No, that doesn't cause irritation because a function cannot possibly return an unset value. You simply compare the return value using an expression. I could go on but the Redditards are already downvoting in anger because they love blogs.
An extension that's unmaintained is different from a maintained feature that's existed for a long time.
&gt; The changes in Python were widespread and things like: &gt; &gt; &gt; print is now a function, not a statement, and using it as statement will result in an error, &gt; &gt; So in other words, they broke BC for one of the most widely used statements in the language and this massive change is only scratching the surface of what they broke. Yes, Python 3 contained a lot of unnecessary changes which broke lots and lots of code and required enormous effort to upgrade, resulting in 3 seeing slow adoption and 2.7, despite being in a dead branch of the language, remaining popular. &gt; It's so frustrating, you are sitting there acting like it would cause some sort of great schism. I'm not saying it would cause a great schism. I'm saying there's no benefit to removing it, and every backwards-compatibility break makes people more reluctant to upgrade.
I was talking about mcrypt.
&gt; Strict mode on your database. &gt; Strict mode for your JavaScript. And strict mode for your PHP in PHP 7, perhaps? It's caught a few bugs I've made.
\*claps hands together regally\* Summon the unit-tests!
If you've installed PHP on your machine, make sure you're using a `php.ini` file based on the `php.ini-development` example, not the `php.ini-production` example... and make sure you actually have a `php.ini` file. If you have none, PHP defaults to production-style settings (not E_ALL D:).
what happens if you kill your offset? $myData=file_get_contents($file); 
Huh? That code doesn't even work? You set `$id` and then check to see if it's set (it is) and then `die()`.
`$id` will always be set. Try this: &lt;?php if (!isset($_GET['id']) || !ctype_digit($_GET['id'])) { die(); } $id = intval($_GET['id']) + 1;
Can you clarify on what your use case question is? If you're setting defaults, the values won't be null, they'll be the default values you specify.
Here, okey, no, misunderstood my question. Is there a way to exploit the code I posted ? And how would it be exploitable ? 
&gt;&gt; PHP is an interpreted language that lacks a compilation step separate from the actual runtime. [...] PHP code is simply executed straight from the source &gt;This is patently false. It skips over some details, but the point of the distinction was to separate it as an interpreted language from compiled languages, which is a valid distinction, and the point the author was making - that there are no compile-time errors in PHP - is accurate. &gt;a function cannot possibly return an unset value Again, while technically true, your criticism is a pedantic one, and tangential to the valid point the author is making. Most functions will simply take the value returned by a function as a parameter. Functions can return `null`, so it seems reasonable that isset/empty would work with them. The author does a good job of explaining why that isn't the case. 
Security fears aside, - you have to understand that this code will die only if $_GET["id"] will be `-1`. I doubt that it is really your intention. - besides, this code will throw an error if no id variable is set in the query string. - finally, adding +1 to a get variable arises suspicions for the premises on which an application is based.
The requirement that the project be "PSR Compliant" is irksome. I know a lot of very good projects that use tabs over spaces.
The downvotes you got, mine included, were because your initial comment didn't actually contribute anything to the discussion, not because /r/php is oppressing you.
I think that's more intended to be PSR0/4 than PSR2, like the library has to be namespaced and autoloadable by Composer but I've seen a bunch in the lot that didn't use PSR2
I've been a big fan of Laravel for the longest time. Of all the frameworks I've used is by far the easiest to spin up a new project. But, having said that I rarely use more than 20-25% of the included functionality, even for much larger projects. The same problem exists with all the mega-frameworks, and even with smaller versions like lumen there is still a ton of other stuff that never gets used and just adds weight to the application. You say you have packages you've developed and trust for functionality you use regularly, have you thought about putting together your own mini framework using those? If you test it properly there's no reason not to trust that any more than Laravel or another framework, but you have full ownership of the code and know that you're not including mountains of code that's just sitting there unused.
I've hit this in both PHP and Ruby. You build a MySQL database. You think you're talking UTF8. Suddenly a user pastes an emoticon in somewhere and your app crashes.
&gt; Update: As of PHP 5.5 expressions are valid arguments for empty and asset. Partially wrong. isset() cannot be used with expressions (not in Zend's runtime, at least: https://3v4l.org/rpDJc) &gt; Something that may cause some irritation is the fact that you can't use isset and empty with functions: Partially wrong. Since empty can be used with arbitrary expressions, a function call is perfectly valid: https://3v4l.org/s8QbT
Lists like this just go to show that too much choice is sometimes bad. Say I wanted a testing tool - this list is useless. Instead, I would just google "php testing library comparison" and get a comparison for being able to choose an individual one. Appreciate the effort put into the list, but I can't actually think of a scenario to use it.
&gt; ...and the point the author was making - that there are no compile-time errors in PHP - is accurate. There are compile-time errors in PHP. You just don't generally notice them being compile-time errors since compilation is frequently done on-the-fly at runtime. http://lxr.php.net/search?q=E_COMPILE_ERROR&amp;project=PHP_7_0
Sounds like I just need to hack the email account with this scheme.
&gt; worth switching to Laravel? What from?
Note that the data is pulled from a slightly older article I posted a month or two ago: http://www.jeffgeerling.com/blogs/jeff-geerling/benchmarking-drupal-8-php-7-vs-hhvm#d8c10 That was running on 8.0.0, and things have been improving quite a bit over time. I'm planning on doing another set of benchmarks soon. It's still slower than 7 (kind of like a rice rocket can often be faster than a large muscle car), but the devil's in the details. Drupal has been evolving into a more flexible/featureful system, and one trade off is a performance regression, especially resulting from the much more modern OOP style code base. I'm not saying D8 is not without its warts... But to say D7 was better just because 'performance' (or the same for Backdrop) is not the logical conclusion.
I'm so so sick of drupal. It's nice way to get a pretty configurable crm but every damn deployment is just prayer and hope that it works and reverts. Is so hard to justify writing interfaces and going with django/laravel for smaller projects.
Building an appropriate runtime index right away should be faster. ;)
&gt;There might be people that don't know about it yet Not in this Laravel centric subreddit
Drupal 8 uses an entirely YAML [file-based configuration system](https://www.drupal.org/documentation/administer/config), so configuration changes can be tracked and deployed. I'm not aware of any other CMS/CMF that provides this by default.
[Bolt](http://bolt.cm) does.
Yes, it does. I should have said *mainstream CMS/CMFs, as I was referring to the biggest PHP CMSs (Drupal, Joomla, WordPress, TYPO3, concrete5, etc.). There are obviously lots of newer lightweight PHP frameworks that can more easily adapt (or be designed from scratch) to use modern practices, however these are unlikely to be chosen for larger or enterprise-size projects, which is a better comparison for Drupal.
Same time working with Drupal and I never had that problem. If you don't like drupal you can use wordpress, joomla, etc... or avoid small project ;)
No I am not a bot, seriously Mods reinstate it please. -_-
Kills me dead inside.
This will always be 'disabled'.
Oh god what is it?
Really interesting book, thanks for passing that along, that may just be the next book I read.
Read the book. Can really recommend it as well.
For my tests I generate Dockerfiles and then build containers on the fly: https://github.com/tarantool-php/client#tests. And that Dockerfile generator is smart enough to decide which extension/composer package to install: https://github.com/tarantool-php/client/blob/master/dockerfile.py 
I've just been writing my own, but I guess composer is the best way to go. spl_autoload_register(function ($class) { //my autoloader... });
Generally I agree with most of this. But for writing methods they say first curly brace on new line like this: final public test() { // method body } Then if you're writing javascript/jQuery, the consensus is first curly brace on same line like this: function test() { } $(document).click(function() { } Two different types of syntax in the same project isn't always the best
Is the main rule then to convert it to an int or a float when anything is added to it or any calculation done ? For example; Should I do it if the $id variable were set to $id = 0 + $_GET['id']; But thanks for the information. 
Drupal 8 performance here seems on par with the performance of frameworks like Symfony 2 and Zend 2 (not surprisingly since it uses Symfony components). Rather atrocious, I might add, for all of these frameworks to be unable to push even 50 requests per second without heavy caching. 
TIL
I see your point, that's why we have style guides and standards, to avoid two different styles in the same project. But, JavaScript and php are different languages, with different syntaxes, and generally shouldn't even be in the same file.
[Don't use mcrypt](https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong). [Use something from this list instead](https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide). Encrypting the base32 secrets for 2FA isn't a bad idea. Just make sure you protect the encryption key. Also paging /u/sarciszewski here, as he'll have good answers too.
90% of the work people end up having to do with Drupal is code around the problems it creates. There is a reason companies like development seed abandoned the thing. It peaked with 6 and immediately began a decline with 7.
going all out for the link karma?
Despite /u/phpguy2 being a cunt, he's not wrong. Part of being a good developer is not just being proficient in a given language. Learning other languages and - most importantly - knowing when to use them will make you an invaluable asset.
It's not a fair benchmark unless you follow the install guides for each to the letter and run the systems as they are meant to be run. Magento2, without caching is hell-a slower than WP or a .html file, but that doesn't mean SFA because they are different things and with caching it's like 10x faster
Depends on how long do work on a single project. If it's just a one or two day project/bugfix/feature/whatever, then just uploading the old fashioned way might be fine. For saving client projects I'd recommend using BitBucket, because you will probably want them to be hidden from public view, and BitBucket offers unlimited repositories. GitHub has more feature, but the private repos are paid. Once you have your repos set up, I can recommend using DeployBot. It deploys your code automatically to production/test/dev servers on every change that you push to Git. It has some cool options too. Good if you want something simple.
&gt;90% of the work people end up having to do with Drupal is code around the problems it creates. I like this. I really sums up the problem. CMSs are great until you need to do something it wasn't made to.
&gt; That said the !$id check will pretty much always cause the script to die. ! will cause $id to be cast to a boolean and pretty much the only integer that'll be cast to false (so that !$id is true) is 0. So $_GET["id"] would need to be -1 for the script to not actually die. I think you overthought this piece of code or something, because that's definitely not what will happen.
It's called OAuth2, not OATH. I suppose you could hash the client secret like a password. No need to store it. 
`0 + $_GET['id']` would be cast to an int as well. This kinda gets to the heart of why PHP uses the `.` operator for string concatenation and not the `+` operator. If `+` did both then what would `1 + '01'` be? Would it be `'101'` or `2`? Using `.` for string concatenation avoids this ambiguity.
Well let's try it out and find out, shall we? &lt;?php $_GET["id"] = 'zzz'; $id = 1 + $_GET["id"]; var_dump(!$id); ?&gt; That outputs `bool(false)`. &lt;?php $_GET["id"] = '-1'; $id = 1 + $_GET["id"]; var_dump(!$id); ?&gt; That outputs `bool(true)`. &lt;?php $_GET["id"] = '-2'; $id = 1 + $_GET["id"]; var_dump(!$id); ?&gt; That outputs `bool(false)`. &lt;?php $_GET["id"] = '0'; $id = 1 + $_GET["id"]; var_dump(!$id); ?&gt; That outputs `bool(false)`. &lt;?php $_GET["id"] = '1'; $id = 1 + $_GET["id"]; var_dump(!$id); ?&gt; That outputs `bool(false)`. Are you getting the idea? Sure, there are some additional values, above and beyond just -1, that'll give `bool(true)`. eg. `-1zzzz` will be cast to `-1`. But there is no numeric value aside from -1 that'll set `$id` to 0. But, hey, since you're telling me I'm wrong, why don't you tell me what'll happen. The proof is in the pudding, as they say. If I'm wrong, produce some code to demonstrate my error.
So make a PR and help curate it.
&gt; It's called OAuth2, not OATH. No, they [really mean OATH](https://en.wikipedia.org/wiki/Initiative_For_Open_Authentication). This is the standards set up to allow 2FA via HOTP/TOPT tokens (and even OCRA tokens, but I've honestly never seen those myself).
Sorry if I'm misunderstanding, but it seems like your php script should be able to call the python script with cmd line args using exec("python /var/www/html/full/path/script.py 'arg1' 'arg2' 'arg3'"); &lt;-- mind the single quotes around the command line args.
On the contrary, how will you get better at what you're doing unless you're doing the best you can?
SilverStripe does, but it probably doesn't map in features 1-1
That's pretty much the two things I would recommend. require "vendor/autoload.php"; $key = Crypto::createNewRandomKey(); // Store this + $encrypted = Crypto::encrypt($yourOATHSecret, $key); // Store $encrypted, then to retrieve its contents: $decrypted = Crypto::decrypt($encrypted, $key);
Something like this? https://github.com/paragonie/constant_time_encoding/blob/master/tests/EncodingTest.php
If you mainly want to land a job: Frameworks, like Symfony, Laravel, etc. API integrations, like Xero, Campaign monitor, Mailchimp, Google Apps, Facebook, etc. Ecommerce, like Magento, Prestashop etc. Devops, like AWS scaling, Docker, etc.
Take out magento and prestashop. It wont make anyones php better
Read zend php certification study guide. That will cover all major topics. For practicing, try to implement patterns/best practices in your code. Try to write MVC from scratch using using packages from packagist.org . Try to write a testable class and tests. 
I'm currently working on a [wrapper of the Microsoft translation API.](https://github.com/badams/microsoft-translator) I feel like the documentation is lacking quite a bit, can anyone point me to a good example of an extensively documented API wrapper package? Should I host the documentation on readthedocs, or simply cram it all into the README.md file? Also I'd greatly appreciate any constructive feedback regarding the code/structure/tests. 
Learn about queues &amp; pub-sub models. For large workloads, this is invaluable, as well as for building internal messaging systems. Research websockets w/ php. Look into rabbitmq/zeromq/gearman. Look into common interfaces php Interface {} which help you architect plugin architectures.
Find one of your favorite projects on Github and look at the tests. All the big frameworks have boatloads of tests. That's a practical, and very "real world" start.
- Design patterns - Compositional coding - SOLID Principles - Test Driven Development Probably need to go through that list twice as they are all interlinked and you need to know them all fairly well before you start to really see the benefits. Takes your architecture up a notch. This stuff helps you program in any language too, I switched from web/php to gamedev/c# really easily. 
People are going to say a whole bunch of stuff that will sound good on a resume but will actually have nothing to do with your ability to write good PHP. Also it really depends what sort of job you want to have. If you want to work in a digital agency envoirment then learning Magento, WordPress and Drupal will be beneficial. However it's important to know that pretty much you won't be developing PHP applications but developing plugins for other applications. The code you will write and the knowledge you need to have is completely different from someone who writes code for your average start up. Being a good developer there doesn't mean you're a good PHP developer, it means your good at developing those. You could also learn Laravel as most digital agencies that actually build stuff for people instead of using a CMS use Laravel. If you want to work at a small-medium company, then getting to know frameworks is more beneficial. Symfony is what I would suggest, Laravel is more for digital agencies from what I can see. If you want to work in more high end work, then you just want to work on your SOLID, data modeling (scale your database, scale your web site), code design, etc. One way of improving here is learning other programming languages, each community does things differently and you'll learn from how they do things and bring it back to your PHP.
I've been wanting to learn another language, particularly something compiled, for quite some time now. The issue is that I have no idea what language to start with. Is there any language you would recommend for me to learn?
[removed]
Given this sub is essentially /r/laravel's bitch these days, I'm pretty sure everyone here is fully aware of Lumen. 
&gt; Kinda makes me wonder if Ioncube is a one-man shop Last I checked it was not. Given the complexity of what they do, and how long they've been around I highly doubt it's a one man band. For context: https://companycheck.co.uk/company/04562963/IONCUBE-LIMITED/summary
&gt; Is there any language you would recommend for me to learn? The language really doesn't matter, as long as it's different. Any of the following would be suitable: Go Rust C C++ C# Java Go &amp; Rust both have very different Syntaxes from PHP which may help you in adapting in future. C &amp; C++ are both 'unsafe' languages which live very close to hardware and may teach you important things about lower level details. Java and C# are probably the 'easier' languages to pick up and you will probably learn more fundamentals about algorithms and general practices with those languages.
Unit testing is a huge argument. I think I never came to these question because I almost only use Singleton for "manager" classes, to connect and retrieve my database connection for exemple. The link provided by @mjrpes states that Singleton impose a restriction that is not required, and well... that's true. Thanks for you point of view, I'll keep reading a few articles about anti-pattern. 
The next language doesn't matter ... You know what the best thing to do is after you know two languages ? You want to be in the position that when a new language comes along, you can spend a couple of hours with a manual and you know what it's about. It's not enough to know that language X is good for Y ... - *Why* is language X good for Y ? - What problems are there with Y that X is trying to solve ? - What patterns or strategies does X deploy in order to excel at Y ? - What other ways you could do it ? - What other languages do it in one of those other ways ? - Why aren't you using those other languages ? The thing never ends ... for as long as we are paying attention ... it starts with just learning one more language, then comparative study of the strengths and weaknesses of those languages, which will tell you where to look next ... and so on ...
This was definitely a sub-par response from us and not up to usual form, but as you allude to, context is everything and nuances cannot be conveyed in text in contrast to a phone conversation for example. When told "[I have] found the tools to decode your encoder.", we pointed out in an earlier email that no system can ever be 100% secure indefinitely but also that there are no tools as suggested currently. Future emails from us were blocked per request. We're always keen to learn from where people find misinformation and to assist in better understanding our software, particularly as the latest protection techniques take a bit of work to use effectively, and of course to backup our counter claims. The OP's response was just an empty reply. There's one site claiming v9 decoding, and the attachment was output from said service of a vanilla version 9 file with a new default protection feature disabled and without any other optional protection techniques enabled. The output, mostly of bytecode disassembly and not PHP, was not even close to valid. Here's a snippet. function first5() { if (x()) { if (5 &lt; y()) { 6 JMPZ 43 1:#2:5 &lt; y() 2:U:19 &gt;U:0 ;0 &lt;&lt;13 7 SUB 2 1:$y 2:10 &gt;#3 ;0 &lt;&lt;19 8 IS_SMALLER 19 1:#3:$y - 10 2:$x &gt;#4 ;0 9 JMPZ 43 1:#4:($y - 10) &lt; $x 2:U:20 &gt;U:0 ;0 &gt;&gt;20 10 RETURN 62 1:NULL 2:U:0 &gt;U:0 ;0 11 INIT_FCALL_BY_NAME 59 1:'p' 2:'p' &gt;U:0 ;5863605 12 DO_FCALL_BY_NAME 61 1:U:0 2:U:0 &gt;$5 ;0 13 JMPZ 43 1:$5:p() 2:U:6 &gt;U:0 ;0 &gt;&gt;6 14 INIT_FCALL_BY_NAME 59 1:'k' 2:'k' &gt;U:0 ;5863440 15 DO_FCALL_BY_NAME 61 1:U:0 2:U:0 &gt;$6 ;0 16 JMPZ 43 1:$6:k() 2:U:24 &gt;U:0 ;0 &gt;&gt;24 &lt;&lt;23 17 INIT_FCALL_BY_NAME 59 1:'x' 2:'x' &gt;U:0 ;5863869 18 DO_FCALL_BY_NAME 61 1:U:0 2:U:0 &gt;$7 ;0 == Security is ever changing, and along with death and taxes, what's certain is that whatever is secure today will be less so in the future. A non-updated virus checker from 5 years ago will no longer be useful, and providers of code protection similarly need to innovate because their systems will be less effective over time as well. Prior and similar PHP protection systems rely on embedded keys, and is an approach that has become a weakness over time. We've addressed that by optional encryption with non-stored keys that can be tricky to use well but highly effective for now. It's a shame that the OP either made an error in testing or simply believed what they read without challenge.
learn something you can use: dive deep into javascript, it may seem similar to php at first, but it's very different. learn shell scripting, automate stuff you do regularly on your computer like creating vhosts en updating the hosts file, create aliases to ssh to servers etc... in short, learn something that's not only giving you additional insights, but find something that'll also be useful short and long term.
So, as a general question why are you wanting to compile it yourself? [There's a very nice repo for PHP on CentOS](https://webtatic.com), [which includes PHP7](https://webtatic.com/packages/php70/).
Because many don't use Docker because a) they're not aware it exists or b) they disagree with [vendor lock in](http://www.boycottdocker.org/) c) w/e. I've only recently started blogging, and my aim is to provide posts based on problems other people are having on SO, IRC, IRL. Maximize traffic from Google/SEO by blogging about common problems. It's also to show potential future employers that I know my shit and can adapt - when I can find time to blog. Finally, it's useful for server provisioning. The same tutorial can be used on Ubuntu/Debian and most *nix operating systems. I put El Capitan in the title so readers are aware this was done on OSX and don't complain "The PHP directory you listed doesn't exist on my *nix OS".
Wow, that seems quite trivial and utterly useless.
Should I put my own classes in the vendor folder as well? Composer makes these folders so neatly. Should I add my own classes there as well? Following psr 4 of course. Or is it OK to put your own stuff outside of it? 
Any recommended books for learning these would be much appreciated :)
I was considering paid github 1 private repo to swap out for clients and the rest for personal projects but after reading about all of the free resources i am going to do some additional research but will most likely work with bitbucket or the other solutions provided below. I will be looking into Packtpub as well thank you.
I started landing jobs as a PHP developer out of high school, particularly because I built a number of applications in PHP / MySQL, and provided a resume that primarily listed projects I worked on. Among them, I listed a Facebook application (back in '07), a personal website, a friend's eCommerce site, and a few others. What others mentioned - good design patterns, test-driven development, DRY - is critical stuff, but if you want a job as a developer, I recommend that you show you've built full applications already. Oh, and I followed a book pretty heavily that, at the time, covered a lot of the more intermediate to advanced development practices: [PHP5 Advanced](http://www.larryullman.com/books/php-5-advanced-visual-quickpro-guide-2nd-edition/). It's far too old and outdated to be useful now, but if you find a quality book that illustrates all of the more advanced concepts, it's a good pairing to developing your own applications.
I think every programmer should read Clean Code at least once.
Check out git-flow, it's a plugin for Git, there are some awesome GUIs that include git-flow. What it does is set you up with some commands that automagically best-practise your commits for you. You just tell git you're working on a feature, a fix, or what have you and it'll go ahead and branch appropriately. Tell it you're done with the feature/fix, it'll merge nice for ya. Re: Docker - https://github.com/veggiemonk/awesome-docker kablamo! Have some cool resources. On-site CI servers may help later down the line when you're pulling in the huge projects. For that, check out https://github.com/Kickball/awesome-selfhosted#software-development (also includes some fancy bug trackers too!)
Check out the PHP-themed series of [laracast](https://laracasts.com/series)
Oh yes! done those! they're really good!
Thank you! Meanwhile I've tried fiddling with `replace` didn't seem to do anything for me, but this is what I was looking for. However, I'm wondering... In general, when does a package fulfill the version constraint in general? Is it only the `version` property in the package's composer.json? Because typo3/cms is missing that completely. Or is it about git/svn tags? If so, are only numeric version numbers allowed (as in "7.6.5", without suffixes, as "7.6.4custom")?
Define serious advanced? Where are you at now?
Definitely read clean code for SOLID (which also ties into compositional coding imo. [this tutorial](https://github.com/PatrickLouys/no-framework-tutorial) covers some of the compositional coding and SOLID. I would recommend you wait with design patterns until you understand SOLID. After that head first or any of the other books would be good. Or just read up on them online. Can't recommend anything on TDD yet, sorry.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
The versions should always be determined by VCS tags. Allowed versions are described here: https://getcomposer.org/doc/04-schema.md#version
While learning OO in C++ is possible, an absolute beginner will spend more time understanding the concept of (and dealing with) header files, how to compile with cmake, how to include external dependencies, how to deal with circular dependencies... OO patterns is the last thing someone will be thinking of. If the plan is just to learn OO, Java/C# is more suitable as these languages are completely based around the paradigm. Learn C++ to learn C++, not to learn OO. &gt;There is no concept of a long lived object in web programming. Actually there is, just not in PHP. Virtually every other web framework is not ephemeral and allows you to do this just fine. Even so, you can serialize objects if you *really* need to, and quite a few frameworks in other languages work this way. Regardless, having an object instance last for a long time is not a requisite for OO. It's just a paradigm that at the simplest case lets you replace do(thing) with thing-&gt;do().
In phpMyAdmin it says I can filter (search) my tables by name or regex... I can't get this regex to work. [http://i.imgur.com/noftHHu.png](http://i.imgur.com/noftHHu.png) `[A-Z]` should return pretty much all my tables. Also escaping with backslash doesn't work `/[A-Z]/`. I'm running phpMyAdmin 4.4.8.
[Not a problem](https://packagist.org/packages/watson/fizzbuzz).
I started learning PHP by watching phpacademy's YouTube videos (Nowadays known as Codecourse). I recommend you to watch videos from this playlist: https://www.youtube.com/watch?v=iCUV3iv9xOs&amp;list=PL4EA8063603E83E5C You might want to skip a few videos but these videos have helped me alot, will help you too :)
I find after working for a few companies over a few years, they seem to want to get something out the door like right now. Or "the business doesn't have time" or "we write tests only for the models, never the controllers or views" - little things like that. I also find that getting that 100% code coverage, that perfect, well written no mess any where (1950's house wife clean home) code style is near impossible with teams larger then one ... maybe two. 
How does this differ from active record (laravel) or doctrine (symfony/zend) and what are the benefits of switching?
EVERY ONE AND THERE MOTHERS DOG who works with laravel knows about lumen. This whole post should be down voted to hell and back since this seems like nothing more then "I need karma so lets post useless links".
Do you mean to do [A-Za-z]+
&gt;Find one of your favorite projects on Github and look at the tests. Yea. Totally. When you start, you totally will have a favourite project on github.
&gt;Now, how to handle the case of form that embeds a collection of many other forms ? &gt;Like task and tags : e.g. http://symfony.com/doc/current/cookbook/form/form_collections.html I'm not very familiar with the Symfony Forms feature and how it combines things, but I'd caution that it is not legal HTML to have nested `&lt;form&gt;` tags.
This is very useful. I've been programming PHP for quite a while (ans using symfony), but only recently have been worrying about project structures and the associated PSRs. If something comes up, I might take you up on the offer!
It's not like a nested &lt;form&gt; tags, it's more like an array of dynamic fields/group of fields added/deleted by js. Like this : http://jsfiddle.net/847Kf/4/ 
Building your own ORM is a hard game. Congrats on the stable release. Looking at https://github.com/phpthinktank/blast-orm/tree/5a4a9f54951be9e0d143723acdaaf08b7c8aaec6#table-name I wonder do we keep table name in an Entity? Recently I was also playing with another orm probably not heard much [Atlas.Orm](https://github.com/atlasphp/Atlas.Orm/tree/801f73b6b6ec378c83dccaa6ea8ebc42cefb1c82/tests/DataSource) , you may be interested to see how it tries not to keep the table name in Entity and move it to table data gateway. Thanks once again for your hard work.
But if we name everything ala `LocatorStaticProxyToSharedInstance` then we become Java. ^(/s)
Yes, every single MySQL error check is commented out. MySQL never prompts error on the code. Like I stated somewhere here, this code is filled with bad practice coding. However, I managed to find one vulnerability which resulted in a permanent xss vulnerability. The torrent name wasn't properly cleansed while outputting in two places. Been fixed now.. And yeah, I'm looking for vulnerabilities so they can be fixed. 
Good job pushing the envelope and helping iron out all the issues so we don't have to. 
It looks really good indeed! But I can't seem to find a latest version. Last one is rev4 from 2013
Largely impractical? 100% is not only an achievable goal, it's hardly enough. 100% code coverage is the BEGINNING of a test suite, not the end. With test driven development, it's the DEFAULT. 100% is the LEAST coverage you can obtain with TDD.
Keep on trollin' bro. You really are a shining star.
thats what im saying, you can stick with the well tested, reliable and not finding yourself in sticky situations all the time 'porsche', or you can turn it in for the tricycle.. at the same time i think its great that people still try to reinvent the wheel, or reinvent things for the sake of learning new patterns. but when you start promoting it every 2 weeks, coming up with lame excuses for all solid feedback you get, and still try to push it down someones throat(with probably some success on the unsuspecting beginner, finding himself in a nasty situation after a few days of trying to implement it), i tend to get annoyed
My repo is hosted by github, so attackers are only one password away to get in. Same for the dev laptops, where you can login with only a password. Even if you don't have it, it is a 10min procedure to get it unlocked. 
For those running any website without SSL, LetsEncrypt is a very real and solid solution if you're not running a business. The only drawbacks of LetsEncrypt is that you cannot get wildcard certificates, and of course web servers don't handle multiple SSL dubdomains well without SNI routing.
I think a major problem that people always run into, including some commenters here, is that people tend to feel that technical debt is always something that ought to be fought against. I think this perspective is flawed. Debt is something you deliberately take on, by borrowing from the future. Because what you borrow (money or time) is worth more now than it will be in the future + interest. Technical debt is a resource that must be harnessed in an early start up. Instead of resisting it, which is pretty much impossible, be deliberate in where you take on the debt. Yes. this might include not writing tests, or not taking the time to teach every member of your team the SOLID principles.
&gt; An MVP is supposed to be the basis for testing, not the foundation of your business and its entire software infrastructure. Go ahead and write a shitty MVP, make it full of tons of technical debt. This is true, until it *becomes* the foundation of your business. "Why should we rewrite it? People are paying for it!"
[Built-in web server ](http://php.net/manual/en/features.commandline.webserver.php) (PHP 5.4+)
That's the latest one, it covered up to 5.5 and looked ahead to "PHP 6" a bit, there doesn't seem to be much in the way of class changes for 5.6 so it covers almost everything. I sent a note to the author to see if there are plans for a 5th ed.
Look up the inheritance chain a little, to the abstract parent class, and around from there. AFAICT it's a static proxy to a shared instance.
OOP isn't just a PHP thing, so you can find a lot of value in books for other languages. Practical Object-Oriented Design in Ruby is a good one to read. Really simple and accesible.
Up the tree looks like a facade to me...
&gt; It is still worth it in some cases, to be sure. I'd say that unless your startup has lots and lots of disposable money and time, it's not just worth it, it's completely unavoidable.
For a bare minimum development setup, you can try: yum install httpd yum install php (or install the repo for 7.0 and do php 7.0) yum install mariadb (if you need mysql server) yum install php-* (* is any php packages you need) yum install npm npm install composer The above is basically the XAMPP stack that you get in windows, plus npm and composer. Your default root www directory will most likely be in var/www/html. You can change that by editing your /etc/httpd/conf/httpd.conf file and setting it to a different directory. Or if you don't wan to mess with command lines, install cpanel or virtualmin. Or pay for web hosting and get developing immediately (although you might not have root and/or install access with this option).
SSL is so cheap right now there's no excuse to not have it if a site requires any amount of secure data.
So I actually took a look at this. Couple things: - Please stop creating laravel facades: [https://github.com/phpthinktank/blast-orm/tree/master/src/Facades](https://github.com/phpthinktank/blast-orm/tree/master/src/Facades) Unless you really know what you are doing, you are just adding more complexity and hiding the core logic of what you are trying to do behind static classes. If the whole issue is: I don't wanna call my class: `SomeServiceInjectorClass` class then tough, I would rather see that then `SomeServiceFacade` - the second one isn't as descriptive. - Also, Laravel Facades Do not need factories. They use a provider. If you want a factory then create one, but you don't need a Facade Factory. -You're Interfaces have no documentation. While you could argue that they should be straight forward, allowing your code to document its self is a horrific idea. I would add docs to allow people to understand: Ok this interface is responsible for x, y and/or z. - [What is the point of this](https://github.com/phpthinktank/blast-orm/blob/master/src/Relations/RelationTrait.php#L37)?? I would just remove it. If you want to do x before you do y then create something like a "before query" (or something similar) concept, kind of like how Rails does before action. You have an interesting concept going on here. I still would rather stick with Active Record or Doctrine until this thing matures. But you are on the right path. Things I didn't see, and maybe they are there - for give me, is the ability to do x-&gt;where-&gt;where-&gt;orderBy-&gt;limit and then get a collection or array or what ever you return. But again, you are off to an interesting start. 
Vagrant really does simplify this entire process. You can go to PuHPeT and [configure a box](https://puphpet.com/#vagrantfile-local) very easily or look for one from [hashicorp](https://atlas.hashicorp.com/boxes/search?utf8=%E2%9C%93&amp;sort=&amp;provider=virtualbox&amp;q=php), then a quick sudo apt-get install virtualbox vagrant virtualbox-dkms and you're ready: pick a folder you want to work out of, stick your Vagrant file in it, and vagrant up Then you can develop away. Much simpler than individually installing all the servers you need locally.
I always see your posts as "oh look, the troll's starting up again", but this actually hits true with me a bit. I used to do a bit of c++ years ago, and did a few physics-modelling related programs. Objects in my code very much related to real world objects, and would hold useful state as the program ran for extended periods of time. I still struggle to get my head around oop in php, and whenever I look to "real world examples" the objects seem so utterly abstract, and un-related to what the website actually does. I run a niche sports results website, and as such my gut is that my classes should be Person, Event, Venue, Organiser, Competitor, etc. But when I try to do that it just doesn't fit right. What happens in one cleverly crafted SQL query in my legacy procedural code ends up becoming 7 separate SQL queries to set the objects up, and for what? I've not got very far down this route as I feel like I'm doing it all wrong, and just making life harder for no good reason.
What's ACME?
A bunch of php files on the server. Its a codeigniter-fired webapp. Uses MySQL/MariaDB
I'm just trying to watch the world burn. There's obviously some naming shenanigans going on, but I don't really care about them. ;)
You might be confusing HHVM which is a JIT compliler for PHP.
You might want to look at various frameworks, quite a few provide similar tools as you might have been using with nodejs 
Bumpty-bumpty-bump. https://youtu.be/LA25LcbWbHc?t=120
Laracasts?
https://en.reddit.com/user/mbunge/submitted/ This is the 3rd time he's submitted it to /r/php in the past 30 days.....which is pushing it.
&gt;Application Error &gt;An error occurred in the application and your page could not be served. Please try again in a few moments. &gt;If you are the application owner, check your logs for details. How Ironic
How would we use this on a shared server without SSH access?
SNI is supported by all major browsers on all supported platforms. Only IE 6/7/8 on XP, Android 2.x, and Safari on iOS &lt; 4.0 lack support for it. In other words, unless you're uncomfortable locking out users that are unable or unwilling to move off of years-obsolete technology, you're fine with SNI.
the one I use a lot, and especially when working with lower php versions is ``` function x($x) { return $x; } ``` then you can do stuff like ``` $obj = x(new yourClass())-&gt;doSomething(); instead of $obj = new yourClass(); $obj-&gt;doSomething(); ```
I've run LE with older versions of python on CentOS 6 fine. I just had to add the --debug switch to the command line. I have since upgraded to CentOS 7 though, which doesn't require it anymore.
I used IonCube several years ago, mostly in order to have an additional layer of security against VBulletin zero day exploits. Thing is, your security chain is only as secure as your least secure link. If you have IonCube, and ro filesystem, and chroot jail, and a low memory limit to crash on any attempt of dumping large amounts of data, etc, you just need a forum admin to install a badly crafted extension or plugin to become absolutely open. In particular, VB 3.6 plugins were just PHP code stored as a text field in the DB and eval'd blindly. Good times.
I didn't mean to say that SNI is bad, it is the preferred method, however you can't shut off SSL connections to specific domains and subdomains without an SNI Router that specifically directs traffic based upon host header information. This is not natively supported in apache or nginx as far as I know, and requires the front-end of your website to be the router.
SSL Support is not perfect for most web servers still. All SSL connections are implicit, if you enable for one domain or subdomain, they're enabled for all on that web server. unless each vhost has a seperate IP or Port. However, the only way you can route traffic to them is with an SNI router, which requires the public face of your server to route the requests. This of course causes problems when you have a bunch of little services and websites for your server and haven't done the ridiculous amount of testing to get it running properly.
Closely related, **array_key_exists** is faster than **in_array**. This isn't noticeable at small scale, and declaring every array as a hash might be overkill for most cases.
Easy mode: Pressure your host to install [Caddy](https://caddyserver.com).
The problem here is defining "secure data". You've got forums with email addresses and passwords, and they'll argue they don't ever store "personal data" and thus your claim doesn't apply. Then you've got the ecommerce store that takes nearly everything over plaintext but passes the actual credit card number to a third party over SSL, and suddenly they are auditing for "secure data" and confirming they aren't leaking anything (look at /r/ecommerce.. it's a common thought train). I think we're past the days of giving people this excuse by specifying SSL only applies to "secure data".
CloudWays just added it along with Debian 8 and Apache 2.4
If you're a developer you should be used to reading long and dry documents. This post is far from both. 
um....What? Do you even know php? or basic programming or anything like that? doing: `SomeStaticClass:someMethod` in which `someMethod` is apart of some other class that is registered as a "facade" is retarded. Just do: `TheActualClassYouMeanToCall-&gt;someMethod()` ... Enough of this "facade" crap thats going around and keep the code clean and elegant so that when I want to know what is going on in `someMethod` I can go STRAIGHT to the source instead of going through x, y, z and then jumping over 0,1,2,3 ..... 
Brings fn_get_products to mind. Plus everything is a global function just prepend fn_. They modify $_REQUEST to pass messages around. Documentation is also no better than having to read the source code. 
No, I just cut and paste stuff from stackoverflow until shit works. Stack. Overflow. Attention span. Lol. 
This is the best tl;dr I could make, [original](https://techblog.badoo.com/blog/2016/03/14/how-badoo-saved-one-million-dollars-switching-to-php7/) reduced by 97%. (I'm a bot) ***** &gt; You can imagine the sheer volume of code that&amp;#039;s not written &amp;quot;By the rules&amp;quot;, and results in testing being delayed &amp;quot;For a better time&amp;quot; or experimenters trying to satisfy themselves by running small tests that only cover what can be covered. &gt; Badoo has several PHP code repositories, the biggest of which contains more than 2 million lines of code. &gt; Before we even started fixing the code, we were worried that as some developers were making the necessary compatibility changes, others would continue to write code that was incompatible with PHP7. To solve this issue, we put a pre-receive hook in every git-repository that executes php7 -l on changed files. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4ah4d0/how_badoo_saved_1m_switching_to_php7/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.6, ~44492 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PMs and comment replies are read by the bot admin, constructive feedback is welcome.") | *Top* *keywords*: **code**^#1 **PHP7**^#2 **test**^#3 **PHP**^#4 **extension**^#5 
According to me Use of PHP Framework which improves your design, makes your code much easier to read and maintain and Stop Repeating your Code or Reuse your code through Functions.
You'll have to search for it, but I've heard about people generating keys on a different server and uploading through ftp or something. Makes it a bit more of a hassle though, but it's possible. 
You can't. But if you don't have SSH access, you probably also don't have a way to configure your webserver and upload certificates automatically. Shared hosts either have to wait for their provider to integrate support directly or have to fiddle around with a custom automation script, that uploads the certificate after issuance to their form (if they provide one).
How cheap?
Kewl nickname. I wish you luck with your crusade. You'll need a lot.
I dunno though, objects are indeed to encapsulate and manage state; but Object Orientation is a way of arranging &amp; organising your code.
&gt;Object Orientation is a way of arranging &amp; organising your code... This right here is a good example of Php teaching the concepts wrong. Modules, are way of arranging &amp; organising your code, not classes. Php does not have a useful module system, so instead it forces users to organise your code as classes. So it is in Php only that classes are mainly used to organize code. It is a poor workaround sold as a feature to the poor programmers who gets caught in this web of ignorance...What is worse is that when these people see languages with a sane module system, they are instantly turned off by lack of Php style autoloading system. Which prevents them from moving to better things and casts them to this hell hole for eternity..
That's a limitation of the protocol. The client itself doesn't open any port for serving challenges, it uses your already running server. However, you can always redirect `/.well-known/acme-challenge/*` to another port or host.
&gt; which is written by someone who actually worked with the ACME spec With or on the spec? &gt; has been around for a while The base library has been around [since the very beginning](https://community.letsencrypt.org/t/list-of-client-implementations/2103/3?u=kelunik). The first version of the CLI client about a month later, but I added some features now that were previously not present, like the check mechanism. &gt; has more than 1 contributor listed on github There are a few other contributors to the base library: https://github.com/kelunik/acme
Processing supports both Java and Python and is really easy to draw stuff on screen...
- https://www.digitalocean.com/community/tutorials/how-to-set-up-multiple-ssl-certificates-on-one-ip-with-nginx-on-ubuntu-12-04 - https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI
Hmm we're probably talking past eachother using the same words for different things. I have got a computer science degree, though, and read plenty of non-language-specific books; It's not like I've just gone "ah yeah classes that sounds cool here we go"
What would be an example of a good module system? What features should a module system have that can't be achieved with classes alone?
Python, Haskell, Go, Rust..almost every other modern language have some kind of module system. As for a good example, I am not sure I can pick one. But Go's seem to be at a nice balance of being useful without having to remember a lot of rules.. &gt;What features should a module system have that can't be achieved with classes alone? I am not sure that is a very good question. Because they are different tools for different purposes. Any way, to answer your question, a module can be a combination of multiple functions, classes, constants and what ever abstractions the language provides. Most module systems provide ways to expose a subset of these entities to other modules. Most modules systems provide dependencies to selectively import entities from a module to it's own namespaces. Etc etc.. So to state simple, if a module has a single responsibility (people here are big on SRP and stuff like that, so can probably relate to that), that responsibility or functionality can be implemented as a combination of functions, classes or what ever is at your disposal. Instead of using classes for everything... 
This is actually possible. I documented my process installing it on my shared hosting here: [Install Lets Encrypt Certificate on Shared Hosting](https://www.kosinix.com/install-lets-encrypt-certificate-on-shared-hosting/). You'll need 3 things: * An OS to install and run the Let's Encrypt client. * A cPanel that allow SSL certificates to be installed manually. * File upload access to the server. No need for SSH. 
Thank you for your feedback. ~~I did remove the facade and the locator becomes a dependency to query, mapper and provider. I was not happy about this "facade" thing, and I still not contendend with the locator. I want to reduce the dependencies to the locator as much as possible, but mind is go aroind in circles at the moment. The facade hide these dependecies. Due to removing the facade I see the massive locator dependencies. My next todo is to remove container and locator and instantiate class instead of determining and finding them by locator or container. This fuzzy lazy loading thing is not usefull since container is creating new instances as well, I'll use aware traits instead of locator or container.~~ Container and locator are expensive dependecies and I removed them. I also reduce the dependencies, to get more clean code. [Current dev](https://github.com/phpthinktank/blast-orm/tree/develop) &gt; Things I didn't see, and maybe they are there - for give me, is the ability to do x-&gt;where-&gt;where-&gt;orderBy-&gt;limit and then get a collection or array or what ever you return. Query returns a `\ArrayObject` (Fallback if no entity class could be determined), `SplStack` (probably missues as collection) a array if `Blast\Orm\Hydrator\HydratorInterface::HYDRATION_RAW` has been set as hydration option or at least the entity class itself. I'm still happy about feedback and to get another point of view.
&gt; The normal php interpreter has a sort of, depending on who you ask, JIT JIT to opcodes which are then interpreted, yes, but that's not what is meant by "JIT" normally (where we mean compiling to machine code). The PHP interpreter doesn't do machine code compilation.
&gt; I am not sure that is a very good question. Because they are different tools for different purposes. Well most of my coding experience is with languages that pigeonhole you in to class-based programming.
So I wanted to create a small demo on how to use PHPixie authorization and validation and ended up creating a skeleton starting ptoject for an auth-powered app. Basically this is a project with a frontpage, login/signup page and a protected dashboard page built with Bootstrap. It should be trivial to modify it to fit your needs (like maybe additional user fields, etc). And it can also serve as a hands-on reference on how to work with common components and design a project. If you never saw how working with PHPixie 'feels' in real life take a look at the code in this project to get the general idea ( the interesting stuff is in the 'bundles/app' folder)
Awesome. This will save me so much time reading the docs every time. Are there going to be more sketon apps for the common usecases? I could really use one with a frontend/backoffice application split, with separate logins.
I tend to set both, if you want to &gt; distinguish the objects that have been created but never been updated. you can check for rows where created_at = updated_at
Well, depends on the definition of "lightweight". Compared to NetBeans, it's lightweight...
Any links to resources, or advice in general, on the best practices for using Exceptions within PHP? I found [this article](http://ralphschindler.com/2010/09/15/exception-best-practices-in-php-5-3) but that is back for PHP 5.3. Have things changed since then much? Is this still a good guide for the best practices despite being over 5 years old?
I remove all face, locator and container dependencies. They are to expensive to implement and hide dependencies. The code base is reduced. [Current dev](https://github.com/phpthinktank/blast-orm/tree/develop) is published. If you test with relations, please keep in mind, the relations currently are using the active database connection instead of the connection of mapper or query! Relations will be configurable via mapper instead of stand alone classes. Thanks for constructive feedback /r/SavishSalacious, /r/pmjones and /r/harikt and others. This is helping a lot to improve this package. Regards
A little late. But I really don't get why my reaction get's so many downvotes. What's wrong with creating your own framework? There are plenty explicit components, use that to create something that fits your needs. Off course You need to look at the use case. But why so many downvotes? Just from a curiosity standpoint.
came to say the same thing. "lightweight" probably is too much, but it is the most responsive PHP IDE that I've used.
I dunno, man, it's pretty snappy compared to a lot of other shit I've used. If you want quick and have a shitty MacBook or something just use a text editor with plugins.
Well, I don't want lo look too picky, but in theory there could be a case when a separate update occurred at the same second with create. Quite imaginary case, but in highload environments quite possible. 
Then use a higher resolution data type.
I've never heard of (and certainly never worked for) *any* company where tech debt was completely avoidable. I would be highly skeptical of anyone who said otherwise. It's just a fact of software development, and the only thing a team can do is learn how to manage it effectively.
It's definitely better than Eclipse which is a bloated hot mess.
Would you consider separating these configurations from the Entity? The README suggests that this was intended to be a Data Mapper ORM like Doctrine.
I mean, if you want to be a professional, you read shit like this and enjoy it. If you want to be a script kiddie that's easily replaceable, just use twitter as all of your sources.
I've never had any problems with PhpStorm, in fact it's the most enjoyable IDE I've ever worked with. From Borland in my C++ days to Visual Studio in my C# days to Netbeans in more recent php days, I have no complaints whatsoever. I used to be able to start Visual Studio and go make coffee and come back and it wasn't quite ready to go.
Metrowerks codewarrior. Xcode. VisualStudio with all of the add-ons needed to make it productive. Please use those products and then come back and tell us whether PHPStorm is lightweight or not.
It is lightweight as long as you are doing php development. The second you open up a js or css file your computer is going to sound like a hovercraft.
**[The RFC](https://wiki.php.net/rfc/mcrypt-viking-funeral)** ---- [Why mcrypt is terrible for security](https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong). (Hint: It's hard to get right, and with cryptography, simply secure-by-default alternatives are what you want.) ---- [Remi's response](http://news.php.net/php.internals/91670) captures the trade-off for voting no here: &gt; Probably you miss keeping mcrypt extension means: &gt; &gt; "PHP becomes upstream for libmcrypt" &gt; &gt; So, to all people who wote "no", &gt; please make clear you want to maintain this library. Libmcrypt: * [Latest release was in 2007](https://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/) * [Unmerged patches](https://sourceforge.net/p/mcrypt/patches/) * [Known bugs](https://sourceforge.net/p/mcrypt/bugs/)
I have seen that....but it went away after clearing the cache of PHPStorm, and it hasn't come back yet.
I would t plunk this into anything by the garbage
Well PHPStorm is actually very resource intensive out of the box. And when you start to add more functionality it can hit 1GB of memory.
&gt; The need for apache or nginx for the actual server instead of php interpreter confuses me a bit PHP itself is a script language that comes with an interpreter written in C, or rather PHP's source code is in C. Since PHP 4.2.0, it also supports CLI mode which allows you to run PHP scripts from the command line. Unlike node.js, PHP (pre 5.4.0) could not act as a web server and listen to HTTP requests. Thats where Apache/nginx or other web servers come into play. They listen to HTTP requests and redirect them to PHP. In order to that, a web server needs to be running which is usually done with the help of daemons. Apache comes with "httpd", which stands for HTTP daemon. &gt; putting the project files in /var/www Apache by default redirects requests to /var/www/html. This is the default "request root". You will find an index.html there after installation. If you enter localhost/example it redirects to /var/www/html/example. This is not always true though, because depending on what stack you install (XAMPP, LAMP, WAMP) and what OS you use, Apache's default behaviour changes (this is probably a settings thing that gets configured during installation and can be changed later). With WAMP on Windows, localhost redirects by default to wamp/www, where you will also find a pre-installed index.php. You can, however, change the working directories of you projects in Apache's virtual host settings. Change the DocumentRoot of your project to anywhere you like. You can look up how to do that, there are plenty of resources available online. Today, PHP comes with a built-in web server, though in practice you won't see this being implemented in real web applications.
&gt; http://www.hagander.net/talks/tardis_orm.pdf I use [Revisionable](https://github.com/VentureCraft/revisionable) for Laravel's Eloquent - works really well.
I use vendor/autoload.php, every time. It simplifies adding external libraries, it supports auto-loading in various formats (PSR-0, PSR-4 or even defining your own file locations), it's **the** standard for dependency installation and distribution and if you're going to use it for autoloading all of your dependencies, you may as well use it to autoload your application classes as well
&gt; March 22th Eh, Scott? :-p
Definitely an interface. Having a fetcher and renderer signs good to me
Um what? MVC is built into a lot of languages and frameworks like Java and rails and ember js to name a few so this article doesn't make sense when it targets only php
I'm not a fan of ADR personally. I think it absolutely makes sense to push the entire response into one layer, rather than just the body, but I don't find that iterative improvement on web MVC worthy of a new acronym.
Use Composer. To eliminate the overhead you can run: ```$ composer dump-autoload --optimize``` in your production deployment to generate a static class map. This will boost the autoloading performance a little bit.
You can use composer and still define your own autoloader. That's one of the super-cool things about composer, it supports a [bunch of different autoloading methods](https://getcomposer.org/doc/04-schema.md#autoload).
(/me nods) I had a note in an earlier version saying that the article applied to server-side developers in all languages, but I thought it interrupted the flow.
Both. If you need to see if a record was never updated, compare the timestamps I guess
Yes, I understand completely. Though the whole Android ecosystem shows it can get quite confusing. They switched from JIT to AOT (when you install that is, not deployment to the Play store), but now it gets slightly confusing with "additional" "JIT" to optimize for hot paths.
Says someone who was born yesterday.
PHP does not have a JIT. PHP has a Virtual Machine. Source is tokenized, parsed to an AST, compiled to Bytecode, then that bytecode is stepped through at runtime by the VM. It's impressive as hell that PHP's VM is roughly on par with HHVM (faster on some workloads, slower on others) considering that HHVM does have a JIT. I look forward to PHP seeing another bump in performance when we figure out the right sort of JIT to build into it. Though a more significant gain will likely come from improving parallelization which may come in the form of async/await, may come in the form of threads, may come from simply moving our ecosystem as a whole to better abstractions at the userspace level.
Uh I wasn't born yesterday.
/u/phpguy2 sprang into action, though the springs in his ergonomic basement office chair were worn and strained by years of occupation. Haphazardly tossing aside his family-size bag of Cool Ranch Doritos, his heart raced as he typed out his exceptionally high-quality response. &gt; With that logic, the whole of php should be deprecated... But something...something was missing. Somehow, the comment didn't quite convey the depth of his disdain. It needed something else. Ah HAH! &gt; With that logic, the whole of php should be deprecated...lol. His comment completed, he leaned back in his chair, heart slowly returning to it's rest rate of 97BPM. Surely this victory would resound through the ages.
ignorance is bliss
You should add facebook/google/etc login options, I'd be VERY interested in this if you did that.
&gt; Some of that guide is almost copied from the PHP manual's own migration guide Author here. **I did not plagarize the PHP manual**, so I'd appreciate if you could avoid implying that. I began writing in April and [was just over 55% complete](https://twitter.com/colinodell/status/630058247572062208) when [the PHP manual pages arrived in August](https://twitter.com/colinodell/status/631997677912375296). My primary sources were [the RFCs](https://wiki.php.net/rfc), [php-src repository](https://github.com/php/php-src), and my own experience. Unless you're referencing [the IntlChar documentation](https://svn.php.net/viewvc?view=revision&amp;revision=337779) which I wrote for both the PHP manual and my book. I suppose those might look similar. 
&gt;Interested to know if there are any drawbacks to using Composer's autoloader as opposed to creating your own. No not really, just so little learning curve for starters. &gt;Is there any unnecessary overhead to using vendor/autoload.php? Just the little speed problem if you have lots of classes but you can `$ composer dump-autoload -o` to speed things up. &gt;What is the best practice? Use composer. Why recreate when there is already one well tested and used by many? There are lots of benefits using composer than just its autoloading feature :) 
That sounds awesome!
Ignorance is not bliss. If you are not using the proper tools to to do the job then don't do the job at all.
Good luck in your future career because it obviously hasn't started yet.
I think you are confusing hashing and encryption. mcrypt is used for encryption.
you are right, i realized later that i am using bcrypt for passwords and not mcrypt 
But how do you reap that sweet, delicious karma if you don't rip on PHP or it's developers?
Oh ok. So working for the last 6 years a s a web developer in both front and back end means it hasn't started yet .... interesting. Downvote for being an idiot troll
Hi guys, I wrote an article on how I started out as a developer and part of my journey leading up to the present. If you like, give it a read and some feedback, I'm still trying to find my way as a blogger, so your feedback is really helpful :)
In general I think that a lot more web *applications* are better built in the client / server model. The client application is the entire chunk of js / css / html and logic necessary for that client. Mixing PHP code (or template files riddled with pseudo-code) into the client is generally a bad idea. This fits in with what you're saying about the interface being at the HTTP boundary. 
can you explain why you think drupal API is a good example, i will for sure look at them but they feel more like WP search or WP code base ... 
Yeah the php bashing is getting tiresome. 
Thank you! Mcrypt is one of those things that 's cited by PHP critics when they claim PHP is fundamentally insecure. Can people actually vote for a Viking funeral? Cuz I'd actually pay to see that. Oh - any chance we get libsodium part of core as a replacement?
isn't exactly people like Scott suppose to do things like that? what do you mean by "extremely hard to get your own crypto library"
He's pushing very hard for libsodium being introduced into core when his citations for why it's so great all link back to articles he wrote. It's suspect at best. We should be using a widely adopted open standard like OpenSSL.
Yeah, agreed. For the OP, more than just try and understand why they did what they did, try to do it a different way and then learn what the difficulties were along the way. Just reading about architecture is not enough to learn architecture. You have to practice making architectural decisions, making mistakes, and then living with the horrible penalties afterward. Then learning and trying it again.
I wouldn't worry about it. tantamounter's post history is full of vitriolic shit like this.
&gt; He's pushing very hard for libsodium being introduced Which is very well respected and not his library. &gt;We should be using a widely adopted open standard like OpenSSL. Oh hell no. Aside from the "unmaintained" angle, it's got exactly the same isssues as mcrypt - it assumes the developer will make good choices (they won't). Let's look at the [man page](http://php.net/manual/en/function.openssl-encrypt.php). That even refers to it as largely undocumented. So let's look at the most upvoted answers. You won't have to look far to find a recommendation for unauthenticated CBC mode. If you can't see what's wrong with that - that is exactly what's wrong with using OpenSSL in this scenario.
&gt; I'm having a hard time trusting your motives here. Skepticism is healthy, but please explain how my employer could possibly benefit from this maneuver? If we keep mcrypt, I can keep exploiting peoples' mistakes when they misuse it for years to come. The most I'll get out of removing it is another blog post that hypes up PHP 7.1+. If you don't trust my opinion, refer to [this post by Thomas Ptacek](https://gist.github.com/tqbf/be58d2d39690c3b366ad), a founder of Matasano Security (now part of NCC Group which offers [cryptography services](https://cryptoservices.github.io/)). Or ask an unbiased selection of cryptography experts here: https://crypto.stackexchange.com Or ask [JP Aumasson](https://twitter.com/veorq), [Solar Designer](https://twitter.com/solardiz), /u/ircmaxell, or any of the other cryptography/security experts not affiliated with my company for their opinion on libsodium. &gt; You run a security consulting company and you're pushing extremely hard to get your own crypto library into PHP core? I didn't write libsodium. I've only contributed patches to the PHP extension; [most of them were trivial](https://github.com/jedisct1/libsodium-php/commits?author=paragonie-scott). I'm pushing "extremely hard" because, as something of a relative expert on these topics, I believe it's the best and safest choice for PHP developers.
I don't see the relevance of his motives. Either his argument is good or it isn't. The fact that it's sarciszewski making that argument as opposed to someone else is kinda irrelevant. I mean, I can empathize with your sentiments. Scott definitely has a history and I have had issues with the way he does things from time to time myself. But ya gotta evaluate things on their own merits.
Gods help us. Someone digs security and found a way to make a living doing that. More than that, he tries to improve other peoples knowledge with well written articles that contain liberal amounts of links to further information from other sources and takes the time to try and push for positive change in the PHP language (frequently not an easy thing to do, even when the benefits of the proposal being made seem blindingly obvious, as anyone who regularly reads internals will know). We're lucky to have people like Scott in the community.
&gt; Skepticism is healthy, but please explain how my employer could possibly benefit from this maneuver? Your employer, through your articles, blog posts, social media commentary, etc effectively own the organic search market when it comes to anything related to PHP and libsodium. Therefore if libsodium becomes the only security library in PHP, then your company stands to benefit substantially **by being the defacto authority on the topic.** That means your target market just increased to every single company that utilizes PHP. &gt; The rest of your post This is what you need to provide. Thank you. You come across as incredibly spammy and aggressive with your constant posts belaboring how libsodium is the end-all solution to the world's crypto problems and every one of these messages is sponsored by PIE and your consulting services.
In theory it should be secure, but in practice you would be better of using an oauth implementation with a (one time) password grant and a refresh token grant. In the worst case that someone finds out the token of a user, he will only be able to use it for a limited time. You could look into the "league" oauth server libraries.. Also, if using just a username password, I would use a basic auth (authorization header) but I guess that is just a matter of preference Good luck!
Care to provide an alternative, something that you found works well?
Your current solution is technically secure. HTTPS will encrypt the entire HTTP request, including the two POST variables. But I do agree with /u/bKSTEENN - using a token would be more secure. If the token were compromised (for whatever reason), it would (ideally) only be valid for a limited time and can easily be revoked if needed.
this
Look into JWT tokens, they're super easy to use and a bit safer then having to send/store the username and password. They're also completely stateless which is nice. edit: Typo
Wow how in the world is your comment down voted? Anyone claiming there is and always is only one answer to a problem is an idiot. 
 // All these parameters to avoid calling the constructor $mock = $this-&gt;getMock('My\Class', array(), array(), '', false); There's your problem: $this-&gt;getMockBuilder('My\Class') -&gt;disableOriginalConstructor() -&gt;getMock(); Use `getMockBuilder()`, not `getMock()`.
Assuming you mean JWT (JSON Web Tokens), but yes, this is what I would recommend as well. It's also simpler than going full OAuth.
As others have said you can do this programmaticly with some sort of authentication (like an api) but if the data is not super secret what you can do is put a unique string in the user-agent of your application (something long and complex like a hash) and then put rewrite rules in the web server to disallow any user-agent without that string. This is not really secure but its a quick and dirty way to protect a URL if its not super important.
My only beef with this is that PHP's OpenSSL extension still doesn't support streaming/incremental encryption, meaning we lose the ability to encrypt or decrypt data bigger than PHP's `memory_limit`.
That could be it. Most of my clients only send me documents up to a couple hundred or thousand words, so I'm not used to reading things like that. :P
You don't need to read articles this long to be a professional.
Ferrari runs on wordpress? *tears*
These are being implemented in userland. Several libraries which support this: * The upcoming version 2 of https://github.com/defuse/php-encryption * https://github.com/paragonie/halite * https://github.com/zendframework/zend-crypt Why not write an RFC to add this functionality to PHP for OpenSSL?
Hah. My advise is to just be a little humble. Us old fucks all know what stupid know it alls we thought we were at your age. Also that never ends. You're pretty much always going to be an idiot.
What about https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition ? :)
This seems a bit odd. Why are you trying to do exactly? I mean, you can lock down your API to your app to some extend, but if the app is public then people will find a way to use the API if they really wanted to. There seem to be deeper questions to ask here than just "can we lock down the API?". If your worried about people doing things they shouldn't through the API then simply put, they shouldn't be able to.
I don't see where the implementations you linked to do streaming/incremental encryption. The idea with streaming/incremental encryption is this: `encrypt($a) . encrypt($a) == encrypt($a . $a)`. In that scenario successive calls of `encrypt($a)` won't equal one another unless you're using ECB mode. The only userland library I know of that does this is phpseclib, which calls it continuous mode. phpseclib is actually able to make continuous mode work even with PHP's bindings to OpenSSL through a number of clever tricks. That said, I do agree that an RFC for PHP to add this feature would be nice.
I *would* write an RFC if I had more experience working with the PHP internals and/or raw OpenSSL. Without someone who has the right domain knowledge, and who is willing to champion it, I feel like an RFC is doomed to fail.
And oAuth really isn't necessary unless you have multiple services sharing a single login. 
Thanks, that was what I was meaning :D
&gt; Oh, unauthenticated encryption that's vulnerable to chosen-ciphertext attacks? That's why you do authentication. You do realize that you *can* in fact use OpenSSL to do encryption and PHP's hash extension to do authentication don't you? You might as well be criticizing `echo` because it introduces XSS vulnerabilities, ignoring the fact that you can do `htmlspecialchars()` on the data or that you might be using it on the CLI where XSS isn't an issue. I don't have a problem with libsodium and the like being the recommended solution for encryption but don't go pretending that it's the only solution because in some (admittedly uncommon) cases it's not a solution at all.
&gt; You do realize that you can in fact use OpenSSL to do encryption and PHP's hash extension to do authentication don't you? [Of course](https://github.com/defuse/php-encryption/graphs/contributors). But such a feature still puts a burden on the user to: * Know that they need authentication * Actually implement authentication (rather than, say, a checksum) * Avoid the cryptographic doom principle * Avoid side-channel attacks That's why none of the libraries have implemented that yet. To clarify: I'm not saying there aren't valid use-cases for the solution you're looking for. You can probably reference any/all of them to write a userland "streaming unauthenticated crypto" class (and sternly remind your users they're responsible for their own authentication layer atop it).
I agree with Scott. Too many would-be open source contributors don't contribute because they have sentiments like yours. But sometimes you just gotta put yourself out there. Maybe you'll fail but that's how you learn and then, even if you do fail, you'll have a better idea of what you'll need to do to get your next RFC passed!
It wouldn't be hard to implement it in userland. I'm not aware of any existing implementations like that in particular.
Lack of any knowledge hurts your opportunities. Ultimately knowing all of LAMP/LEMP will give you a decent standing for PHP jobs.
How come packagist's search functionality seem biased with its results? I've attempted to type in a full package name w/ low downloads/stars and it doesn't even show up on the first page lol? Why would a package system not search based on relevancy? 
I think the biggest problem is that companies tend to assume that the alpha/beta/0.1/mvp/proof of concept etc etc is going to last them for decades to come. If car companies acted as web companies, Volkswagen would still be selling the original Beetle and not the production version but the first mock-up. With thousands of bolted on features but no actual design taking place anymore. Let alone redesign. A warning sign is when people talk about investing in software. A real investment means you spend a 1000 and get 2000. That is not how paying for software works. One example, company had outsourced development of web application, that company screwed it up for a bill of 500k. Then the project was insourced and they spend a lot more. Now the idea is that web application is worth 1 million. NO! It isn't right now not even worth a 100k. This can be quite shocking, I deal with startups and companies that have startup code that has to be refactored for the business to survive and sometimes the companies fail and when you then see what software/databases go for, it can be shocking. 2 million spend, the software, customers and database sold for less then 10k (and that was mostly for a list of pissed off customers, not as valuable as you might think), the furniture sold for more. But company owners can get really attached to original software and keep dreaming that another 100k for another quick win will turn things around. There are a lot of bad developers, one way or another but the decent ones give their employer two options, I can do it good and expensive or bad and cheap. Cheap still cost money but it really means that you a lowering the value of the software, not adding to it. Managers don't understand this. I have temporarily saved a few projects with some really dirty hacks so they could at least continue only to then find out the planned refactoring to truly put things back on the rails was cancelled because everything was running perfectly now, thank you very much... okay but it a botch job. It will fall apart. An emergency tire (space-saver) will get you home. It is not the idea you thinking "oh, the car goes again, I can keep using it forever and ever". As the author says, technical debt is perfectly acceptable but for god sakes, sooner or later you got to get rid of it. That is the real problem, not MVP but when the MVP is never replaced.
Yes, if users are sending passwords directly to you, it's OK in terms of security. The reason people shied away from it in desktop apps is that the password was often handled by a third party developer (eg Twitter clients) and that is NOT ok for security. First party apps? Have at it. But do keep in mind that if the user changes their password, it will log them out of the app. This is probably not desirable. I'd suggest a one-time post to a login endpoint that generates a token, and use that token to authenticate. Basically oauth without the login and grant flow. No matter what you do, the locally-saved password or token must be stored secretly. It's somewhat worse to leak the password, but nearly as bad to leak the token. 
It's very important to know how to set up or at least how configure basic lamp/lemp stack. It will help you a long way. It may a litlle challenging in the beginning, it took me a long time to figure out all the nuances. I recommend that you play with it using vagrant: * install ubuntu 14.04 * try to install apache + php * try to replace mod_php with php-fpm * set up a common group for www-data and your user * change the group of www folder using sticky permissions * change umask of Apache * learn about common apache directive and the difference between 2.2 and 2.4 directives That's pretty much what I needed to learn to have a workable LAMP stack 
Freelancing gigs tend to be given by clients who don't have much technical background and need someone to handle everything. In that sort of environment, you need to be wide and shallow in your knowledge. The more people working on a product, the more specialized they can be, so you should find a company that's sized appropriately for your desired depth/breadth trade-off.
Yes I know about this one, but looking at both snippet is one really shorter than the other? Compare it to: $this-&gt;easyMock('My\Class'); I don't have specific numbers but at least half of my mocks don't call the constructor, this is a major pain point (all things relative ofc) when using PHPUnit for me.
Isn't [prophecy](https://github.com/sebastianbergmann/phpunit/blob/6572c14ed74aa0eb2879fea073b62dd17a7b62d0/composer.json#L32) out of box supported in phpunit? I am not sure what may be the reason you made this though.
What happens if you don't? I don't mean something bad here, but what if life happens in any way and we end up with no replacement? I fully support what you do and thank you for that, it's just the process of removing something before an alternative is ready that I find a bit unusual.
you don't need to, but if you don't, you'll be ignorant and bad at your job
This looks very similar to Mockery.. Just us mockery? :)
&gt; behaviour of the equality operators and the weak/silly typing and Unicode "Fixing" those would make it into a completely different language, and if you are fine with another language why not switch now?
Yes, I realize that :-/ I guess I wouldn't really care if I had better choice at what tools I may use.
The curse of "all the same faces and generic talks" strikes again. Just look at the "Step into Debugging" talk, it's really something everybody shoould know by now. People just come to see Gary and others and network. When I ask people why they went to a particular conference I often hear: "It's about the people you meet, the important part is what happens between the talks". And that makes me said. Sure, meeting people is an important part, but the talks themselves should be the meat of the event. Otherwise why have them at all? Let's just have unconferences (which are great by the way) and all go biking to some mountains? In my opinion the talks should be showing you something new, something you haven't heard before and center more aroundpersonal experiences. Tell people how you company dealt with a unique problem, tell them how you recovered form being hacked, how you patch PHP source to add some extra functionality you needed. Stop these "tutorial talks" please 
It requires re-learning a whole mocking framework (not just for me but also my colleagues and/or open source contributors). PHPUnit's API is not bad except in a few key places, that's why one helper or 2 really helps. However thanks to you I gave it another look and just discovered that you can do this: $mock = \Mockery::mock('foo', ['foo'=&gt;1,'bar'=&gt;2]); Which is indeed quite similar to what I did. However it doesn't look like it's possible to do this: $mock = \Mockery::mock('foo', [ 'foo'=&gt;function ($a) { return $a ? 'hello' : 'world'; } ]);
I have written a Wordpress plugin in PHP and I want to output plain JSON without any wordpress theme information. But I do need to interact with other plugins and the WP-Settings information. What is the best way to do this? I currently have a theme file called JSON outputter that just calls a method of a class that wants to output the JSON, is there a better way?
Search is hard. There's a reason Google has 90% market share: they got it right while everyone else didn't. I guess they need to prioritize project titles in their search? As opposed to just matching everything and ordering by stars.
What has "born yesterday" got to do with anything? Do either of you know what the phrase actually means?
oauth is an option but it can be a pain to set up.
As if I'm not a PHP developer. ;-)
I saw a talk by Rasmus at Confoo this year, and he said that the JIT just wasn't ready in time for 7.0. There was a lot of the necessary background work done which is what motivated PHP7 and is why it was so much faster, but the JIT itself will be in 7.1.
Symfony 3.0 is largely backward compatible with 2.x, the default composer.json for silex 1.3 allows for symfony 3 components. 
You may as well save yourself £300+ &amp; wait a month.. you'll get the videos for free.. so basically it's a £300+ networking event :D
This means i can use version 1.3 and in case of version 2.0 it's not a big effort, because that symfony3 have a large backward compatibility and i use also symfony3 components in my app
Joomla made lot of its users cry too. Whenever I got a call by someone that their site was defaced their websites were always joomla based and setup by their nephews. 
New error: Fatal error: Call to undefined function mysql_connect() in D:\XAMPP\htdocs\process.php on line 9 line 9: mysql_connect("localhost", "root", ""); 
Well unless your (or another of your dependencies) composer.json says use 2.x components the silex will use 3.x. I wouldn't worry about it. 
I'd recommend [PHP Must Watch](https://github.com/phptodayorg/php-must-watch). Personally I really like the Clean Code Talks on that list, but there are many others that are worth your time.
You can't use any mysql_* functions, including that one. See documentation here: http://php.net/manual/en/mysqli.quickstart.dual-interface.php
Quickly: $mysqli = new MySQLi('localhost', 'root', '', 'login'); $username = mysqli_real_escape_string($mysqli, $username); $password = mysqli_real_escape_string($mysqli, $password); Since the functions with mysql_ are going away, make sure you use the mysqli_ functions.
You'll need to do it manually, as many mysqli_ functions require the first argument to be your DB connection - aka the ($mysqli, you see in the string escape function. Check php.net for what each function requires. It seems like a bit of work, but it'll get easier.
You can. The top is objective way to do it. :)
&gt; In PHP 7.1+1 (be it 7.2 or 8.0), the mcrypt extension will be moved out of core and into PECL, where people who *really* want to install it may still do so if they can install PHP extensions from PECL. I think that's fine. Does PECL work with PHP 7 yet? Last I heard the CLI tool `pecl` was never going to work because it depended on PEAR which will never support PHP 7 because they're too busy supporting PHP 4. But that could have been hearsay.
Could you elaborate how that will help?
I have a question about the example code: class Foo { public int $bar = "turtle"; } var_dump((new Foo)-&gt;bar); // Fatal error: Typed property Foo::$bar must be integer, string used Does this error happen when you try to access the property or when the object is instantiated?
[PHP Internals Thread](http://marc.info/?l=php-internals&amp;m=145814626622161)
With autoloader, you don't need to write an include for each file, you just create a function that defines where the files are and PHP includes them for you when you reference a class. From example #1 on the PHP page: &lt;?php spl_autoload_register(function ($class_name) { include $class_name . '.php'; }); $obj = new MyClass1(); $obj2 = new MyClass2(); ?&gt; There's no include() statements, but both class files will be included automatically.
Very interesting article. I've been recently trying to write an interpreter in PHP, but it never occurred to me (stupidly) that there is a standardized way of parsing syntax. I have created something similar to a lexer though.
Personally I think that this should adhere to the per-file strict declare that methods do, if only because it would make it more consistent likewise, it should behave in the same manner as type hinted methods and parameters in terms of value acceptance and conversion. Having two different behaviors for Typing seems undesirable to me
Yeah I need to read on all this now x) but yeah very new to php so "or die" is good enough atm :D
Nice article, /u/krakjoe :)
There is an union types RFC in draft, the author (Levi Morrison) is planning to continue on it when he gets time and wants to have it voted for 7.1. It will solve the nullable issues.
Not quite, there are some differences. There are guides. [Pick one](https://www.google.com/search?q=php+mysql+to+mysqli).
Dats pretty swag, meng.
But you can't use variables for object property default values. Although with the scalar constant expressions addition of PHP 5.6 might make class-definition time error handling slightly trickier unless you make sure to restrict the type of each constant in the expression.
Here is a scratch for Laravel: https://github.com/exfriend/restrict-wordlist-passwords
Which PHP version are you using? If you're using PHP 7, then the `mysql_` functions no longer exist, and you have to switch to MySQLi or PDO. If you're using PHP 5.x, then the `mysql_` functions should exist, though you still ought to switch to MySQLi or PDO since they are deprecated and have been removed in 7. I'm guessing you're on 5.x. In that case, if the functions are missing, you probably need to install and enable the necessary PHP extension. If you're on Windows, you need to edit your `php.ini` file, for example.
It wouldn't really be an issue to me if it weren't a thing, and well used. But I'd rather not get in to the mindset of "Well, if we use this variable in this context (string, int, float), it will convert, and if we use it as a type in a function it will if we don't use strict types, but if we use it as a property it just won't at all". Just pick one way and stick with it. PHP needs to be *more* consistent, not less
Defaults are a different code path to assignments, I think. I don't know if Joe's patch currently checks the types of default values, but it ought to. It would probably be a compile-time error, like for parameters: $ php -r 'function foo(int $i = "foo") {}' PHP Fatal error: Default value for parameters with a integer type can only be integer or NULL in Command line code on line 1 
It would probably be possible to do that, but it might not be a good idea. You should be aware of what types you are storing in your object's internal state; you probably don't want PHP to silently mangle your data.
Install a newsreader. Personally I use Thunderbird for it.
PHP doesn't even have static typing or ahead-of-time compilation.
Ah. In that case, don't use the `mysql_` functions and learn PDO or MySQLi. If you're using tutorials that tell you to use `mysql_`, they are most likely old or of poor quality.
yeeeaaah and my assignment is due to tomorrow so its gonna be a looooooong night 8)
why would it matter that you use php for your application? *can't you simply import a database dump? is it not possible to take the application offline for this migration? http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/MySQL.Procedural.Importing.html 
I don't understand why it would be strict instead of following the same pattern as function parameter hints. Guess I'll have to wait for "Explain here..." to be filled out.
FWIW I've been using PHP for ETL since about 2008 and it's always worked like a charm. Some of the ETL jobs have had to do much more than simply importing a database dump like onwuka had mentioned, and it was still all pretty painless.
I love when things get deprecated :)
If you're using a PHP framework it probably has a Mail library built-in. If you're writing PHP from scratch then you're correct the mail() function is what you want. You're also correct that the server will need to have an MTA (mail transfer agent) installed, though it might be possible to use a 3rd party. If I were you I'd spin up a Linux VM, install the LAMP stack, and then install an MTA like Sendmail or Postfix. Good luck!
Here's the problem: it's really tempting to nuke the site from orbit ("it's the only way to be sure!") but it will end up being very costly in time and effort. And if you could extract the pieces as-they-are to a framework, you probably wouldn't need a framework; the app would already have well-separated layers. Instead of a rewrite, I suggest refactoring as-you-go. I have a book about this, [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp), so if you do decide to refactor instead of rewrite, it will serve as a very good step-by-step guide for you. (You don't have to take my word for it; check the reviews and testimonials.) Good luck!
I will take a look, thank you!
Well it's not the migration, it's the ETL that's a challenge. We have some deep tables with millions of rows that need to be processed, aggregated, and joined.
It may be a trivial question for some of you. I am developing my own mini framework for self learning and better understranding of MVC Pattern. Now, I ask myself, should I use static method to instantiate model object? e.g.: $obj = App::getModel('Model'); Maybe at the beggining it was ok, but later on I changed structure to use namespaces, so maybe its better to create instance just by "new Foo()" ? Well, "getModel()" method was useful, when I wanted to directly load data to object, but in this case I can just use: $foo = (new Foo())-&gt;bar() Are there any pros for "getModel()" method? Should I stay with it, or drop this idea as a bad behaviour?
In that case I would say pass the data in the constructor and assign it there. You don't need a translation layer for a few fields in a database. Besides isn't the type of data you fetch based on the type of field it is in the table?
Yeah it's usually a combination of cron and a collection of MySQL database tables. cron is used to kickoff the process(es), and then the process reads and writes from a few DB tables to keep track of what it's done and what it's supposed to be doing. You can also move the schedule itself into the DB. In this case you'd probably have cron run a process every minute, and then at runtime have the process read from the schedule table(s) in the DB to determine if it should in fact do something, or just exit out because nothing is scheduled.
This is the good shit.
Question: what's the overhead of checking return/param/property types?
[yes it is possible](https://github.com/PatrickLouys/no-framework-tutorial) Do as pmjones suggested and change it part by part, not all at once. Just add the new code in front of the old one and if no new route matches, go to the old code. 
you know how school is ;) and I think I have it working "almost" it just need to connect to the database (dont ask me how) to store the data and im good to go :) 
Someone who does not understand the mail function is not going to understand this answer...
That would only mean the error would not be lintable, but would still be catchable on class definition, because the constant is resolved when the class is defined.
You need to run a local server, like mamp or xamp, run the server on the folder where your html is and access it via localhost in your browser. Then you need to rename your html files from '.html' to '.php'. Then you can write PHP code in there, the server will run it and it will work in your browser. Then you just need a html form that posts to the same page and just check in the php for the posted form values and use PHP's mail function to send it. This is the simplest way. You need to know about html forms, variables ($_POST), arrays and functions. It really is very basic so don't worry. Should only need like 50 lines in one index.php file for the html and PHP.
As much as I dislike having to declare(strict_types=1), it really makes no sense that this wouldn't follow the same standard as scalar type hinting. Seems like an unnecessary inconsistency to add the language.
Php is slightly beginner friendly. But for doing stuff that is not extremely trivial, Php is a lot harder (Because of poorly designed interface for various libraries, libraries that don't fit with the rest of the language, a million weird behaviors and quirks, absence of various built in data types like sets).. So it might be a good idea to learn Python in the long term. Library support for data processing in Python is great. Python also has got a great and helpful community. I also suggest using Python3 if you decide to use Python. Cons of using Python is the initial learning curve. It might be harder for your people if they already know Php, because Php actively prevents learning of good practices. For example, your programmers might be initially turned off by lack of something like the Php array (which is an poor amalgamation of a number of datatypes) in python, and instead will have to learn about different data structures and their behaviors. If your devs can overcome things like that, they will thank you for giving them a chance to learn Python. 
I am enjoying taking a very naked MVC framework (panique/mini) and customising it heavily to my own needs. It's still pretty much naked PHP so there is no fear of having any dependencies. 
I'm really hoping for both (no competition). A nullable type could just be shorthand for a union with null, since this would probably be the most commonly used case.
Probably completely negligible considering people's applications read stuff from disk or database.
What's the point of saying "kidding obviously" when it's not funny or obviously untrue? Mimicry of the java type strictness, scoping, style...is neither good nor bad, but intended. 
The suggestions here are pretty good. I will just add one more, if your code is a bit complex, you could try using experiments. There is a good library for PHP called [Scientist](https://github.com/daylerees/scientist). With this, you should be able to run at the same time the results from the old code and the new code. Then you can compare them and see if they diverge. This has helped me in the past to iron out critical code like money calculations, permission calculations, etc. Even if you don't use it right now, keep it in mind.
&gt; Is there a resource/book that provides this practical wisdom anywhere? There is a fine manual: Top result for "php with-gd" - http://php.net/manual/en/image.installation.php "To enable GD-support configure PHP --with-gd[=DIR] , where DIR is the GD base install directory." Introduction to that extension - http://php.net/manual/en/intro.image.php
&gt; The VB syntax is annoying, Are you reading the part: "The authors of this RFC considered other syntax possibilities, however they were considered to be inferior for the following reasons." ? Because the code you quoted isn't the syntax proposed.
Fair enough, how about: - Install VirtualBox. - Download an Ubuntu ISO. - Spin up a VirtualBox Ubuntu VM with the ISO. - Login to the VM. - Run: sudo apt-get install php5 - Run: sudo apt-get install postfix - Create a file called testmail.php in /var/www/html, and away you go... 
I help build [equip](https://github.com/equip) and think it's really good. Other stuff I like: - https://github.com/thephpleague/fractal - https://github.com/nikic/iter - https://github.com/auraphp/Aura.Sql - https://github.com/auraphp/Aura.SqlQuery - https://github.com/thephpleague/oauth2-client
I agree with Paul here. You should never, ever try to rebuild a project that is in production from the ground up. A rebuild will almost always become a death march. Instead, focus on separating small bits a time, working towards a clearly defined (and small!) end goal.
 &gt;If you need a framework to hold your hand, and unless the original code is crap as opposed to too complex for you, then you might want to rethink your abilities to program PHP. Utter crap. Despite your narrow-minded and short-sighted view in frameworks, using one is not a sign of poor programming skills. A decision on whether to use a framework or not is just that: a decision. Besides, any structured codebase is officially a framework. Whether it's community-based or proprietary makes little difference at the end of the day. &gt;I am not saying framerworks are for sissies, but come on, do you honestly think that any of the programmers working on something more than a blog use much of a framework. CNN, New York Times, etc. Again, utter crap. Unless you've worked at said companies or know people that do/have, then to say big companies like CNN and NYT don't use frameworks highlights your ignorance. I will grant you I have never worked at either of those sites, so I can't guarantee one way or the other that they do or don't use frameworks. The point is, don't make assertions you can't back up. What I can guarantee you is that Bizjournals, while not as big as CNN or NYT, but definitely not a blog, does use a framework. When I left there they were using ZF1 and Doctrine. Why? Because it reduced the amount of time and effort by freeing everyone up to work on business logic and not having to worry about the basic nuts and bolts for things like routing and database access. And believe me when I say, they were able to rewrite their entire site away from Perl (nothing against Perl) in less than 6 months because of the frameworks. &gt;So if someone has handcrafted something awesome, I suspect that a framework will not be able to replicate it. Where do you get this stuff? I mean seriously, you can't be serious. This is so odd that I can't even. &gt;If it is some dumb simple site then maybe. But in this case the working code should be, well working. See previous comment. 
[Chronos](https://github.com/cakephp/chronos) is a drop-in replacement for Carbon with a few improvments that I like a lot.
 The thing about frameworks that should be high on your list of considerations is the time and effort it'll take you to learn how to use said framework. Not every framework is created equal either. It helps to have things like the PSRs to help frameworks be interoperable, but there are still significant differences that you should take into consideration. The biggest of which is going to be the community. No matter how fast or stable a framework is, if the community isn't there then eventually you'll be back at square one. The second thing to consider, if it's even a consideration is performance. Frameworks are notoriously slow compared to raw PHP—by the way, let me put my pedantic hat in for a second and correct your statement about frameworks versus "pure PHP": those are one in the same, with the exception of Phalcon, which is a C extension that exposes it's API to PHP. It does make a little difference, especially when comparing performance. Phalcon is much faster than other frameworks because its core is C, which uses less overhead. Okay, I'm done being pedantic now. :-) Back to the topic at hand. It sounds like to me either way you go you're in the right track. Don't scrap the existing codebase. Unless you know every single possible in and out, scrapping it could cause you a lot of unnecessary headaches when you realize certain features are broken and/or missing. Keep refactoring the code bit by bit, introducing DRY and SOLID principles as you go. I'd start with separating the presentation from the business logic first. It's a lot easier in some respects because you're not throwing away logic, but simply moving it around. Fight the temptation to rewrite logic while you do this. Take notes for later when you do rewrite the business logic. Try to position logic changes to introduce modules from frameworks. For example, both Zend and Sumfony—to name two—follow the loose coupling philosophy, so switching from mysql/mysqli to their respective ORM implementations would be a lot easier than using a tightly-coupled framework's ORM. But I'm getting ahead of myself. Before you start rewriting your business logic, it would behoove you to start working on unit tests for the existing code. This way when you start making major changes you have tests to back up the results to help ensure you're not breaking things. Scientist sounds really interesting too, but I can't comment on it as I have zero experience with it. I'm not even sure if unit tests and Scientist go hand in hand, but that may be worth looking into. Also, unit tests will come in handy for continuous integration, which will help make sure your tests are always run and any subtle breakage won't go unnoticed. Anyway, whether you go the "nuke t from orbit" route, or the under the radar way, you're in for a lot of effort. Don't get discouraged. In a couple of months when you start seeing those positive gains, it'll all be worth it. 
&gt;our back end is built on PHP, and our server developers know PHP, not Python Then stay with PHP because you have the expertise.
[phalcon](https://phalconphp.com)
Here's some nice libraries: * [Assert](https://github.com/beberlei/assert): allows you to do some basic validation * [Porpaginas](https://github.com/beberlei/porpaginas): allows you to abstract results from their pagination * [Phinx](https://phinx.org/): allows you to create database migrations * [phpspec](http://www.phpspec.net/en/latest/): allows you to write ultra fast "unit" tests * [UUID](https://github.com/ramsey/uuid): allows you to generate UUIDs * [PHP CS Fixer](http://cs.sensiolabs.org/): allows you to detect coding standard issues and to fix them I'm also fond of [Symfony](http://symfony.com/). Those have already been mentioned, but worth repeating: Composer, iter, Monolog and PHPUnit
My current toolkit primarily consists of: Composer Yii Framework v2.0.x Twig I use Composer as needed, but I try not to rely too much on code that is doesn't have a long term support strategy. If absolutely necessary, I fork the repo, keep it in sync with upstream and use that copy.
Sure, if it's internal then you can `declare(strict_types=1)` yourself and you have your strict typing. But even though it's not considered good practice, properties can still be public. And the rules for whether or not assigning a type to a variable should throw an error should be consistent
I think having one rule for assigning and passing variables is better than having three, even if it's one stupid rule
No, just put your code into an src folder and then add the following to your composer.json "autoload": { "psr-4": { "YourRootNamespace\\": "src/" } }
[removed]
Then it should probably have been called `declare(strict_parameter_types=1)` :p
One less thing to fix on the way to full strictness :P
php tutorial 1st class
symfony/validator symfony/console
I didn't know about these "language constructs"*, thanks!
Fucking hell, these bloody Indians spreading their programming 'skills' all over the web. What a load of rubbish
&gt; How to **not** use html tags in Php (php tutorial) There, FTFY
There are some max connect error settings and max connections per user and max error user settings that I forget the name of. They may toss the "too many conmections" error when really it is another type of error.
Composer SilverStripe (CMS + Framework) My IDE of choice (phpStorm) helps a lot with validation as-you-code.
&gt; do you honestly think that any of the programmers working on something more than a blog use much of a framework. CNN, New York Times, etc. Yes. Django is quite popular in publishing (WaPo for example). The Guardian are big users of the Play framework (Scala). Spring and other Java-based frameworks are big in enterprise. 
It's what [composer](https://getcomposer.org/doc/01-basic-usage.md) recommends and what a lot of people follow.
I know, I was lending support with my own example of why I think it would be bad.
I can't see why that would be a good thing.
They're not wrong.
I hope it's not out of place for a little self promotion, but I am quite fond of [Lavacharts] (http://lavacharts.com) I actively work on it and am happy to help resolve issues whenever they arise. 
Composer for the obvious Symfony Console for writing command line tools Symfony Process for running system commands Whoops for handling errors in development
Nothing to say. This is very sad (
I don't mean to say I avoid all code not written by me. I just do not chase after every shiny new tool in the shed. I learn new things, and use them on my hobby projects... then apply them in production when the tools and my knowledge of them have matured.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm a bit confused about the MVC pattern. As I understand MVC works like this (very basic of course): User interaction &gt; Controller &gt; Model &gt; View. This is also how Tom Butler explains it in a very understandable way (https://r.je/mvc-in-php.html). But why are almost all the most common frameworks use MVC like this: User interaction &gt; Controller &gt; Model &gt; Controller &gt; View For me as a beginner this is a bit confusing not really logical. Or is this the correct way to implement MVC in the world of PHP?
Same here. Multiple rules increase [astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment). One rule, even if it is a stupid one, means you won’t accidentally mess up which one is being used at a given time.
It seems like the PHP Internals overwhelmingly agrees. It looks like that'll be changed before it goes to vote. And the RFC at the moment doesn't allow referenced variables to be set to typed properties, which looks like it'll have to change
All i know is that there are no any mentions of unicode support in PHP's core string functions on RFC page. https://wiki.php.net/rfc
You can run php codesniffer or php-cs-fixer first. You will have cleaner code to work with
I used it in a project back in 2007 and it was mostly a single file. The reason it was that way was because autoloading and namespacing was not used as widely yet. So most libraries like redbean and swiftmailer all had you include a single file and it would do the rest. Rb.php was a large single file with 5 or 6 classes at the time, but today it isn't needed for it to be in a single file.
PHP 7.0 [included](http://php.net/manual/en/migration70.new-features.php) it as far as I'm aware. If you're talking about `echo "\u{202E}This is backwards"; // displays: sdrawkcab si sihT` For example. If not, what do you mean?
As a maintainer of many legacy applications written by computer science students that book was solid gold for me. The techniques outlined, especially dependency injection, make my job so much more enjoyable these days. When it comes time to add features nothing is more satisfying than moving code out of spaghetti land and into namespaced small classes while adding test coverage.
&gt; PHP's core string functions I think he means making substr behave like mb_substr, and so on...
`\u{}` gives you another way to specify UTF-8 characters in source code, but it's a far cry from "native" Unicode support. PHP has no Unicode string type, only byte strings.
My framework of choice is [CakePHP 3](http://cakephp.org). It has a fantastic ORM that is fully object based, and gives you all the power of SQL. Plus, there is a datasource for [ElasticSearch](https://github.com/cakephp/elastic-search), and a number of other plugins for treating various webservices as datasources ([Github API](https://github.com/cvo-technologies/cakephp-github) and [Twitter API](https://github.com/CVO-Technologies/cakephp-twitter) are two examples). CakePHP 3 also makes use of some other popular projects (Like [Phinx](https://phinx.org/) in the [Migrations](https://github.com/cakephp/migrations) plugin). Another nice thing that I like about CakePHP 3 is that a number of core components have been decoupled from the rest of the framework, so you can use the [ORM](https://github.com/cakephp/ORM) with other frameworks, or even with no framework.
Then turn on `mbstring.func_overload` and watch any poorly implemented cryptography code *break*.
I use all of these regularly with the exception of Dingo, which I've not heard of. Having just had a look at it though, I think I'll be using it in future. TY roobler.
PHP probably never will given the culture that dictates its development. In Python they had the same deal where the native string type was really just a byte string that was only a good idea for representing ASCII characters. When they wanted to go full default UTF-8 they simply found it couldn't really be done without breaking a few things. So they broke it. Python3 made a big break and said that `"string"` will be UTF-8, and you can use `b"string"` to get a byte string. Since they were already breaking some things they went and cleaned up some other things while they were at it. PHP has consistently chosen not to break compatibility like that. On one hand that's bad; the PHP stdlib is still a horrific mess in many respects, you have warts like the fact the native `array` isn't really an object nor can it be mocked effectively by an object, etc. On the other hand Python 3 is over 8 years old and only now is Python 3 really starting to gain the traction needed to take over. But given PHP has gone this long with trying to not break compatibility at all costs - even to the point of having the infamous `real` function variants - you can reasonably assume the PHP line will always be 'use mbstring on byte strings'
Anyone using sparkpost? It looks very nice at first glance. What it's like to actually use?
SparkPost looks interesting. I would be interested to hear others feedback who have used it. For those of you interested, here is a PHP script that leverages both Sendgrid and MailGun API's https://github.com/gosmartsolutions/email-newsletters
It's really easy to use. Working on a SitePoint tutorial about it...
Again? I've only been using it since about version 8, but this is the first new version format I can recall..
&gt;It might be for the best not to go this route anyway, though. Python 3's approach doesn't work well if the outside world (the OS, the terminal, etc.) is not Unicode-friendly. How often is that true in PHP's domain, though? And given that UTF-8 guarantees any valid ASCII is the exact same as the valid UTF-8 string for the glyphs you can blindly pass off a UTF-8 string to an ASCII-only system if you want to. If you need to ensure you're about to pass an ASCII only string it's pretty easy and readable to show you need to do that: str1 = "foo" str2 = "/╲/\╭(˵◕╭ ͟ʖ╮◕˵)╮/\╱ \" assert str1.encode('ascii') # Assertion passes; 'foo' is ASCIIable assert str2.encode('ascii') # This throws a UnicodeEncodeError Or just use the byte-strings from the start str = b"foo"
Can we not as a community create an Object Oriented wrapper that does all this?
We're currently switching over. So far so good! 
Why don't you test it out and report back?
Well, before they had the very long number format with no clear major version, then they made the 8 9 and 10, now it's jear numbers.
Whatever happened to [Property get/set syntax](https://wiki.php.net/rfc/propertygetsetsyntax)? I would rather have something like this which completely avoids the strict versus coercion debate. This would throw the tools at us developers to decide how we want to deal with that, and put whatever other logic might be needed. Looks like 2011 was the last time this was visited. Seems to be just as valid an RFC today, if not more so with the changes PHP 7 brought forward.
Thank you so fucking much for posting this. I instantly just archive Mandrill emails as they usually just tell me my balance. You just saved my scrotum big time. 
Personally I use the shorthand notation when declaring a non-empty array, the explicit, full notation when declaring an empty one. $a = [1, 2, 3, 4]; $b = array(); It strikes a good balance of readability for me.
You're welcome. That was me too! I'd missed the email last month but randomly opened the reminder they sent me yesterday for some reason and was pretty shocked. 2 months is such a tiny window for a change this big. Luckily I just use the SMTP integration so it's not a huge deal to switch but if I'd been using the APIs and hooks I'd be really irritated. It'd really be tough to trust mailchimp for anything again after such a dev hostile move.
That looks like the only way to keep BC. Golang for instance has a concept of "[runes](https://blog.golang.org/strings)" that coexist with strings.
Totally go for it. No significant drawbacks except php5.4 and higher. If you're not into wordpress development , then you shouldn't care. 
It's a new version format most likely due to the new licensing. There's a build number if you're looking for a more canonical, traditional version. (And yes I know you're just trying to make dumb, pedantic complaints.) 
&gt; How often is that true in PHP's domain, though? I don't think it'd be a huge problem on the web, but it might be on the command-line. &gt; And given that UTF-8 guarantees any valid ASCII is the exact same as the valid UTF-8 string for the glyphs you can blindly pass off a UTF-8 string to an ASCII-only system if you want to. Yes, but there are few ASCII-only systems. Systems which are ASCII-compatible but extend ASCII in a different way to UTF-8 are a problem. The fact you can't reliably output Unicode to the console in Python 3 is an pain.
The community has, there are userland Unicode string classes out there. Take your pick.
It comes down to preference, if your goal is simply to keep it readable/standardized pick one and use it throughout the code base is all you should be doing. At work we use short-hand as we find it more concise and the applications that we develop don't support 5.3 so we don't have to concern with backwards compatibility. For personal projects I use short-hand out of personal preference. Edit: hopefully clearer.
Yep. Broke the hell out of the Symfony plugin. 
Not sure if that was the case before but I found the auto completion to be better, like I don't need to write stuff like /** @var Thingie $thingie */ as much as I used to before ? Especially for Doctrine entities Maybe it's just me though... Anyway, I love PHPStorm, the only thing that bugs me and that has never been fixed is that sometimes copy / pastes from one window to PHPStorm will stop working and I have to restart PHPStorm for it to work, same happens to coworkers. I hope they'll fix it someday
&gt; Yes, but it's hardly the programmer's fault for not knowing that the string functions can be overridden, given the manual doesn't tell you this "feature" even exists unless you read about how to configure `mbstring`. Once again: If you are not sufficiently informed about all the pitfalls of the language you are writing in, you should specifically not be writing cryptography in that language. It's not about blame, but if it were, it would definitely lie with PHP itself. &gt; It probably creates some kinds of security issues. Specifically: https://github.com/facebook/facebook-php-sdk-v4/pull/552#issuecomment-182123879
I initially didn't like it because it didn't "feel" explicit enough. Also I bounce back and forth between 5.2 and 7. However, after using it more in 7 it looks and "feels" cleaner to me. Finally, as far as a "standard" goes, most modern libraries I've used use the shorthand notation. 
AES also still has a free tier, I believe.
It's certainly the most tempting approach for any significantly-sized codebase. Fortunately this only had about eight places that needed updating. The best part is that because you can't change the value at runtime (or so it seems), it's practically impossible to write any sort of meaningful tests. Even phpunit.xml doesn't seem capable of changing it. My awful approach is if (ini_get('mbstring.func_overload') != 7) { $this-&gt;markTestSkipped('rerun with php -d mbstring.func_overload=7 blah blah blah'); } I died a little bit inside writing that one.
Nice, that let's me remove my custom spl_autoload_register function that I'd written :)
https://github.com/paragonie/halite/blob/master/test/phpunit.sh#L56-L61
As others have pointed out, it's mostly a matter of preference. One caveat is the intended PHP version. But one could easily argue that the versions of PHO that do not support it are all EOL. My main point I wanted to make is if it's your project, then it's your choice of coding standards. A developer who wants to waste time arguing about something as superficial as array notion is not worth a second look. Yes that's a bit harsh, but at the same time, there are always bigger problems to solve. As long as everything is consistent and works, then it doesn't matter whether you use long or short versions of constructs. 
`&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;` is the pyramid operator.
Thanks?
Just stop.
&gt;Python has two string types, one for bytes and one for Unicode strings. The era where there was only byte strings was a long, long time ago. Yeah, sorry for using a weird wording but that is basically what I meant. In Python 2 the 'obvious' string is just a byte string, but you have to use `u"foo"` to get it unicode. &gt;When they wanted to go full Unicode. UTF-8 is one way of encoding Unicode, it's not the only one. In fact, Python often used (uses?) UTF-16 internally. Granted, but UTF-8 is the most used as a rule in many domains including Python. &gt;It did, but Python 2 also had Unicode strings. The difference was that Python 3 made Unicode strings the default syntactically and in many libraries. See point 1, but yeah that's what I mean. Python made the 'obvious' string Unicode, and makes you specify you want a byte string when that is what you want.
In hindsight this sounded more awkward than intended. Maybe a simple "thanks for the read" would have been more appropriate...
Darn you Garethp! Why didn't you tell me about this plugin sooner? That thing is hyper awesome! Well, I guess I can let it go this time. [NOTE: Sorry. Poor attempt at humor. Thank you very much for pointing this one out.]
That's exactly how I felt when I first found out. Enjoy =D
I just thought you REALLY wanted to draw people's attention to this, lol.
yep, quite annoying..is there a way to change this?
It is partially due to new licensing but also for consistency and easily knowing what has what. A few things: * With this `year.month` release they can push a release every month consistently if they need to without hitting a `10.12` scenario which looks fugly. * First point also allows them to do smaller releases adding features and fixing bugs throughout the year instead of having one major sit with only a few patches for a year. * It is super easy for developers to tell what their base is. PHPStorm is WebStorm plus a PHP module basically. With this version system, you know `PHPStorm 2016.1` is based on `WebStorm 2016.1` since they are kept in sync. Instead of the old "Which version of WebStorm is under the hood?" since they used to lag a bit. This way when you see a new WebStorm version, you know what version PHPStorm will have so you know what features are added on that front. * Developers can easily tell if they are on the latest version or not. They also know the *exact* year + month version they have a fallback license to instead of needing to remember the major + minor version or whatever the build was at the time it triggers.
Does this answer change when audit logging is involved? I.E., not just the changes, but WHO made them. I assume you'd be forced to cook that into application code, unless you've seen some interesting DB level versions of that.
In a nutshell: 1. Take every single `class` (or `interface`, or `trait`) and put it in a unique file. 1. Name those files and (and folders, if using namespaces) in a systematic way which relates to the class-name. Strongly consider following a convention called PSR-4, or at least PSR-0. 1. Ensure those class-files have **no procedural code**. They should be safe to `require_once()` without any side-effects beyond defining the class... No `define()` calls, no global variables, etc. 1. All procedural code, like `index.php`, should live in a clearly-separate location. 1. Use an existing autoloading system (like Composer) or create your own, which tells PHP to automatically do a `require_once($someFooPath)` the first time it needs a class named `Foo`. You'll almost never need to write require/include statements ever again, except to start up the autoloader.
&gt; however you do have to confirm your domains with DNS records You have to do this with Mandrill too.
There are times when I like the extra clarity that I am defining an empty array here, or when I am building up a very nested array and [[[][][][][[]]]] is illegible, and it just really makes sense to break it out. 
That's **definitely** the answer I was secretely hoping for! So the "new" notation is not just some weird quirk like php's countless alias functions (*join* vs *implode* confuses me every time), but meant to stay and widely accepted. Hooray! 
Oh, So we had weak typing for return types .. ?? didnt knew that.. And we had *declare(strict_type)* for function/method arguments because, by that way we could apply strict typing for stdlib functions, I am not quite sure whether that reasoning applies here.
It is now. https://gist.github.com/shssoichiro/96281dc5b32e2d7be1c8
I feel like the alternative is installing PHP on Windows with IIS; not sure why you'd prefer to learn that over Linux/Apache/Nginx
That depends heavily on what you're building. Some sites require users to be logged in all day as part of their normal workflow. Hell, I don't think Reddit ever expires logged in users. 
always nice
DKIM records are a good thing for you and your customers. Proves that you sent it, improves your deliverability &amp; helps send spammers posing as you to the spam folder.
Switched to MG as well and brought along our customers (they had their own mandrill accounts). Been good so far and in the past week they have sent upwards of 300,000 emails without issue.
Keep in mind that PHP 5.3 stopped receiving security updates in 2014. That should be a deal breaker for any hosting you're looking at.
Yeah I quite like this format because it has some meaning aside from "it's after the one before". The only downside I see isn't a technical one... if you're selling commercial software and haven't updated recently, that looks bad marketing wise. I also actually like how Ubuntu adds the zero to year.**0**4 - even though it's non-standard and kind of redundant, it avoids confusion for the n00bs that think version numbering is the same a fractions, i.e. they make the mistake of thinking 1.2 is newer than 1.19. Some people like to keep the first number to signify major changes, so in this case I've also seen this retained as the prefix, i.e. v**2**.2016.03 
The Symfony plugin http://www.espend.de/projekte/phpstorm-symfony2-plugin.html
It depends on where you end up working. But in small teams people tend to need to be all rounders or at least one person on the team will need to be to deal with everything that is involved in running a website besides coding it. The more you know, the more you are able to deal with any problems that come your way even if you end up having to say "this is beyond me" at least that is an answer that better then going "wha?". Say for instance that the answer to upscale MySQL is cluster it and then you have to say "to setup a cluster is to advanced for me, we can hire these guys to do it for us" that is a lot more professional then saying "I don't know how to make the database thingy go faster". Experiment with Laravel and Vagrant to start getting a taste for things. 
@michalv8 będzie z tego jakieś nagranie? 
Nikita, may I ask you to review the updated version? https://phpdelusions.net/pdo#mysqlnd
Yes, I totally agree with you. I have shared this article because most of the new developers are still using a deprecated function like mysql_. And they should also know what other deprecated functions they should stop using them which can affect them in the future.
Nie jestem organizatorem więc nie wiem na pewno ale sądząc po tym, że z zeszłorocznego spotkania są filmiki na YT to możliwe, że i z tegorocznego będą.
All good. Easy to miss :) 
Yeah I really like Mailgun too, although I've never tried any alternatives. But haven't seen a need to. I'd assume all of them would require you confirm your domain, it would be crazy for them to send mail on your behalf without doing so. And the MX thing doesn't really have anything to do with Mailgun, but it was worthwhile you mentioning the tip. Make sure you also have SPF records for the sub-domains.
Wouldn't bother me. I more frown upon naming an array $a but I know this is an example in this case ;)
Maybe I've misunderstood something? But all three of those packages linked above support Facebook, Twitter and 20+ other websites. Otherwise what's the point of these packages? Are they missing something in relation to the standard register/login with Facebook/etc? 
The advantage of using the SDK is that if you need to actually make requests to Facebook's API you can now go straight ahead and do that. If you're only looking to authenticate users, then these oauth2 libs should do the trick
I meant that wp still supports PHP 5.2.4+ , so if you plan to develop and distribute wordpress themes/plugins, then you should take into account that some users using old php versions might have fatal errors due to using the short array notation. Use array(), if you want your script to run on PHP &lt;5.4. In the end, just choose either one and use it consistently. 
100% agree, but it's not as simple to get up and running as something like mailgun. Additional verification in this case meant that Amazon had to approve me to send emails to anything other than test addresses.
Ratchet which is one of the most known Libraries for Websocket Servers only supports the WAMP v1 Protocoll. If you want to use it with a JavaScript frontend with autobahn.js, you will face some problems, since autobahn.js has allready dropped WAMP v1 support, and "only" works with WAMP v2. The most advanced Websocket Library in PHP is Thruway (https://github.com/voryx/Thruway). Its developer has made a Symfony bundle as well. Although i cannot recommend working with Thruway if you are running PHP under Windows, since your Websocket Server will not be able to accept clients correctly, no problems under linux though.
Git flow Integration Symfony Plugin PHP Annotations Php Inspections
"i totally agree with you, but i deliberately chose a misleading title anyway"
Another way is to use node.js + socket.io and make pub/sub between it and your symfony app (you anyway should do that event if your websocket server is written in php). p.s. I had an expirience with ratchet and [amphp/ayres](http://amphp.org/docs/aerys/). The last one is solution which i like the most, but... socket-io just easier to use.
I have used this library[1] for a long time and it works quite well. It supports many common providers based on both oAuth 1.x and oAuth 2.x, it's easy to extend it to add support for new providers too. [1] https://github.com/Lusitanian/PHPoAuthLib
Also not supported in IE nor Edge: http://caniuse.com/#feat=eventsource
I prefer packages from the League. Well maintained, good community around them.
any plans for tests?
Thanks for pointing that out. Looks like this provides a solution: https://github.com/remy/polyfills/blob/master/EventSource.js
I really don't see a problem with it. Python and JavaScript use the exact same style for arrays (but not dictionaries/objects). array() is the blasphemy for being a faux-function.
&gt; Uh Socket.IO runs on Node.js. [Socket.IO is a protocol](https://github.com/socketio/socket.io-protocol), first and foremost, which lives on top of websockets, among other transports. I'm well aware that the original Socket.IO server implementation was done with node.js, I even said as much. I'm saying it's not great either, but still better than trying to do it in PHP. I also explicitly stated the fact that there are indeed other backends for Socket.IO, for example, [this one in python](https://github.com/miguelgrinberg/python-socketio), or [this one in go](https://github.com/googollee/go-socket.io). Sorry if that wasn't clear.
If you haven't heard about Hoa\Websocket, you must give a look at : http://hoa-project.net/En/Literature/Hack/Websocket.html and https://github.com/hoaproject/Websocket It's a powerful and simple WebSocket client/server implementation. It has been made by a lovely community :) The recent updates make this lib relatively light compared to the others on the market! The documentation is clean and the wrappers around high level protocol (ws, wss) simplify a lot usage.
Not very scientific, but they can stay up for days/weeks if left to their own devices. However, I find I restart them fairly 'regularly' for code updates. Whenever I deploy it does a soft shutdown and then restarts (soft shutdown = finish what your doing them turn off) I find the biggest issues my logs indicate for shutting down (always gracefully mind you) are usually system level signals that I didn't anticipate. I would try setting one up to test true uptime, but then I couldn't have it in production... ie. It wouldn't have real tasks so it wouldn't be a good test =/ But even still I think I would still set these to do a nice restart once a week or something, if anything at least for a log rotate, yum update, etc
Now that you pointed it out it's bothering me. Thanks for that.
As I am not working on a Symfony project now, I guess I could wait until a patch comes through. It's funny how this is so much like went I went through as more and more plugins came out for Eclipse. I'd expect this type of quality from a free open source IDE, but not for one that I pay. Not a big deal right now, but I'm a little bummed.
It's Friday today and hope I will be excused for posting an article that is not on the technology's cutting edge. Nonetheless, you may find it curious that nearly every PHP user, while creating their first DB wrapper, is following exactly the same pattern. You can find examples nearly everywhere. So I thought it would be a good idea to compile all the issues in a single article. Traditionally, I am asking this great community for the feedback. As I already learned, sometimes I am not that good with getting straight to the point - so if you find some statement unconvincing or lacking clarification, please share your thoughts or questions. I also hope that the title won't be taken too personally :) 
&gt; PHP is a suicidal language PHP is Mr. Meeseeks!
it does.
 I'm a senior systems engineer, I've been using PHP for 10+ years in massive production environments. Websockets in PHP is a big hack. PHP is a suicidal language. -- did you mean websockets in the default implementation of php language is a hack?.. if the implementation is a problem .. did you try hhvm... and regarding the hacky part.. I think it will be better if someone familier with internals confirm this.. fyi php the language and pho the implementation should be considered different... just my 2 ps
- Apache config (.htaccess) support from JetBrains - Git Flow integration - Dash (Because Dash rocks)
I've always felt the same way about long running background tasks or batch processing scripts written in PHP. I will say this though, I think the problem has more to do with the way PHP developers write code than the language itself. As a PHP developer, you don't have to learn good habits like cleaning up after yourself, e.g. closing files, closing network connections, etc. Which means long running PHP scripts leak like a sieve. You have to think differently when writing long running scripts. It also probably doesn't help that PHP doesn't include convenience features like Go's `defer` keyword. There isn't much baked into the language that makes it easier to clean up after yourself.
&gt;Many people talk about how a bad idea this is, without the gory details of it :-) I've never seen anyone with negative things to say about it have any substantial realistic data on why.
Socket.io is rad and feels too easy when using it to whip up a game or chat. It feels like I did something wrong because it shouldn't work so easily. Why do you feel it isn't great? 
Well, you do need a composer.json on the root dir of the repository.
That's awesome! Could you share how you were able to accomplish that? Did you use a framework, or did you interact with the socket directly?
Getting forking and master/child processes right is hard in PHP and most other languages - the C primitives they wrap are not exactly the nicest set of APIs to work with, and have much harder to diagnose (and fix) results when you get them wrong. You've got to go pretty deep down the rabbit hole for that stuff (source: wrote a library for it) The actual WebSocket piece is fairly easy in comparison, although not nearly as clean as HTTP. 
I used Ratchet for the sockets, and Doctrine to interact with MySQL. Everything else was home baked. The way the system worked was basically sending/receiving information about processes that were running on behalf of clients, basically just passing around JSON objects - so the server would grab all the current status information from a database table, where it was updated at different frequencies from different products, and hold it in memory, then would receive requests from clients, format the appropriate data and send it out. The sharding wasn't really anything complicated. We had, I think 6 instances running behind a round-robin load balancer, and they just sent a special message to eachother once every 5 seconds to share authenticated client info.
Title makes no sense. 'Diseases' maybe?
Thank you! Lots to think about.
&gt; is following exactly the same pattern I followed it too, long these many years ago. "Bah, all that stuff is too much. I just need something simple!" (writes yet another DB wrapper)
Oh thanks. It's a really stupid mistake. Fixed on the site but here the post is already locked
&gt; As a PHP developer, you don't have to learn good habits like cleaning up after yourself, e.g. closing files, closing network connections, etc Just want to second this. We have a project we're working on right now that's starting to involve some small long running processes, and it's been a learning experience. Never having to do garbage collection or closing connections before, it's been simple. So it's not a fault of PHP that I wasn't closing the Doctrine connection at the end of every operation, and it just kept opening new connections to the DB and letting old ones time out. Since we got some of those kinks ironed out, the long running tasks have been just fine, although admittedly very simple.
The "comprehensive list" of PHP errors does not iterate all error levels. (See http://php.net/errorfunc.constants for an up-to-date list)
Personally, I wouldn't use separate PHP frameworks for this. Perhaps a PHP framework for the REST API and something like AngularJS for the HTML is what I'd do. I think it's becoming more common, and it's the way I prefer to develop. It also makes things like mobile apps easy to develop when your website is already utilizing an API.
I'm working on splitting administrative and API portions of a major application I've spent the past 2 developing and maintaining. Reasons being that the API is read-only, so as long as I keep the database structure properly synced between applications I can run the admin through Laravel and then use a microframework like Slim (which, based on local VM testing, is 4-6x as fast as Laravel) for the API.
If the rendering framework makes api calls to the RESTful API, I'd say it's pretty standard. If both code bases, html and rest, had their own connections to the database, I'd concerned about doing code releases and database migrations.
Right! That's a good idea :) Honestly, last time I worked with legacy php apps was before I knew how to work with (or that they even exsist) VMs. 
Not exactly sure the purpose of TypeAObjectsDBRepository and TypeAObjectsObject1Repository. I don't think it has to be abstract. I would define an interface for those two classes. interface TypeAObjectRepository { } class TypeAObjectDBRepository extends AbstractDBRepository implements TypeAObjectRepository { }
Of course. You need to control the code, but there's no requirement to be the user or organization in the composer.json file. Go create a repo with a composer manifest saying the project name is `"facebook/backdoor"` (I'll wait). Push the repo online, then add it to Packagist. Despite not being an owner of the GitHub Facebook organization, it will publish under that name just fine. I could then `composer require facebook/backdoor` and get your code. This, of course, would imply to most people that the package is built, maintained, and endorsed by Facebook, but it is nothing of the sort.
💋
Maybe you could elaborate on why it would seem logical?
aha... I want to see this project with only squiggly lines =) 
Not the Drupal API directly. The Search API is an addon community module abstracts out a search index from it's implementation and the website. https://www.youtube.com/watch?v=rArRwp_1h8Q&amp;t=4m18s The Search API module is here: https://www.drupal.org/project/search_api
Ok, since you haven't really mentioned anything to do with the overhead of running a framework that can do both, imma go ahead and suggest that you just look a single framework, Symphony, Laravel, doesn't really matter. The problem you're describing there can be handled by the way you structure the files inside your framework. The overhead on maintaining things like database changes in multiple frameworks accessing a single database backend would be more drama than segregating your application properly. Have a look at https://github.com/rappasoft/laravel-5-boilerplate to get an idea of what I mean. Check the Controllers directory and routes.php. (disclaimer: everyone does this differently and it's not worth trying to agree on the single best way of doing this, it's personal preference)
If you even need to ask this, you're bad.
I don't really see a problem with this per-se, but just speaking from experience, the deeper your hierarchy gets, the harder it is to reason about the code. "Which parent class did this method come from again?" is a question you'll frequently find yourself asking if you go too crazy with your hierarchy. The other thing to be mindful of is that you can't do this: `Where as Users just needs the basic abstract class of AbstractDBRepository` An abstract class is not concrete, by definition, so you WILL have to extend it with an empty non-abstract class in order to access those basic methods. It's a tiny bit smelly to have a bunch of empty classes that derive 100% of their functionality from a parent. What are the abstract methods that your abstract classes will have? If all your parent classes are doing are providing actual implementations of methods and don't need to be extended to implement the abstract methods, then they probably shouldn't be abstract.
I use 2 frameworks, but one is PHP and the other is javascript. My workflow is to run a Laravel/Lumen/Whatever backend, which does nothing but provide a REST API (and some other small pieces, like queue workers, command line tools and the like)... Then the front end is an ember app - separate repository, separate deployment that consumes that API. Beauty of Ember in this case is that it handles everything that is front end related. The HTML, css, javascript components all live in the same repository and there is no crossover with the the backend at all. Separation of concerns at it's best, imo :)
Who is phpguy1? 
If you are on PHP 5.4+ you may want to look at [traits](http://php.net/manual/en/language.oop5.traits.php). You can keep your base repo class and have everything extend that, then have TypeAObject, TypeBObject as traits you use wherever necessary.
I have definitely considered traits, but I still think I'm looking at the problem space wrong. I appreciate the comment all the same and that route is not ruled out. In the end I will do it wrong and then learn why it's wrong.. I guess :)
Honestly I don't think it makes much of a difference. Any method that reduces duplication (DRY) and isn't overly complex will work perfectly. Don't overthink it! The best strategy is to pick whatever seems fine now, then re-evaluate it further down the line if you run into problems.
This was a fabulous read and now makes me want to write my own DB wrapper and I am not a novice at PHP .
A lot of very good advice on this article. I wrote my third or fourth database wrapper this week and still managed to pick up something useful from it
Sauber uses a TYPO3 Version that has not been updated with security fixes for years *shudders*
See sidebar: ----------&gt; &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, 
We used it in a project about two years ago. It was really nice and easy to work with, and not that expensive. Using [named transformations](http://cloudinary.com/documentation/image_transformations#named_transformations) was nice.
And I use MultiMarkdown which is asking me to pay for it. I will remove that plugin and use gfm 😁
That's not really the case. Hybridauth allows you access to their API too. You don't get all those nice PHP classes, but you can still access their REST APIs. Check this for an example http://hybridauth.sourceforge.net/userguide/tuts/advanced-access-google-api.html I'm doing this to read and write google calendar entries, wasn't difficult at all, it's just not super well documented. I don't have any experience with the package from the league, but hybridauth worked well for me so far.
In my case, it's the opposite. All the DBALs out there were too simple (while also having a lot of unnecessary cruft like insert/select/delete methods on the DBAL itself). Nothing had support for transient SQL sessions (with pooling: automatic sharing when sessions are used sequentially, and distinct connections when sessions are used simultaneously), and nested transactions (not just virtual like in Doctrine's DBAL, but also SAVEPOINT based ones). I also have to wonder why the author said "you don't need debug mode". I sure do need debug mode, which logs the queries I run and shows them in an easily readable manner in a debug panel (or at least a file). Xdebug is great, but it's not the most productive solution for absolutely every debugging need. Xdebug can't syntax highlight all my queries and run EXPLAIN on them automatically, for ex.
I use it for powering the images across about 400 sites that use a custom CMS we have built in house. Approx 2TB a month of bandwidth across a couple hundred thousand images. Yes I know we could do it cheaper with some custom code and serving via S3/Cloudfront buuuut. Using cloudinary gives us amazing flexibility in continually pushing forward with changes to our templates and designs. Long story short. I would recommend. There's better things to spend your time worrying about then processing, transforming, storing and serving images.
I read the article and it says: &gt;Running long living PHP processes remains a curiosity, but results offer a promise of significantly improved performance when time spent bootstrapping the application is relatively long compared to the total length of the processing. and more important: &gt;Unfortunately PHP-PM is not yet a practical solution for running production services as both PHP 7 and HHVM end up crashing from time to time. So, it cannot be used yet, as it crashes ~~constantly~~ from time to time.
I have some PHP daemons with more than 1 year uptime. I play a lots with stream_select or fork in it and i don't have any memory issue.
Ah, of course. I didn't think of that. Thanks for the heads up.
Memory leakage over time probably. Seems to have gotten better with PHP7.
The individual threads get killed after a certain number of executions so it's not actually an issue.
Have been using them for 2 years with 6.5M images over 242Gb storage with 200Gb bandwidth a month. Never once had a problem with them. It's quite expensive with my usage profile which is heavy on storage but low on bandwidth, but still worthwhile IMO - I never need worry about this part of the business again. Would definitely recommend in themselves, but have no comparison with imgIX or cloudimage.io. 
This is more a problem in the application: your code needs to use nothing global or static. The whole application should be stateless because it will be handling several requests in the same process.
If you can use PHP 7, you can use [Aerys WebSockets](http://amphp.org/docs/aerys/websocket/intro.html). [Just be careful about blocking I/O](http://amphp.org/docs/aerys/io/blocking.html).
Yes, very useful and thought-provoking. Question though, your general-purpose wrapper, could it be used to prepare a statement and loop through execution with different param sets? For that I would normally do something like:- prepare; foreach{bind; execute}
How about a DB connection, SMTP connection, Amazon S3 client?
That's pretty cool. I wonder why this sort of tool hasn't been written as a PHP extension in C, though.
Why not use a tool to convert the entire codebase to short syntax in a single commit? There is no chance of it breaking anything beyond backwards compatibility which is obviously not an issue if you've started using it on new changes.
Heck no. The new syntax is *so* much nicer.
I should have clarified it better. Going to fix the phrasing. What I meant is an excuse that can be heard too often when I ask people why do they echo the error right away. "It's just for debug mode" they say. But a real debug mode is a sure cool thing. 
Anybody using this in production?
Seriously, it's date('Y') and php doesn't even shard.
hows this difference from the built-in php server?
Good work on the parser; but honestly I'd just use YAML.
&gt; https://www.techempower.com/benchmarks/#section=data-r12&amp;hw=peak&amp;test=fortune Hello, your account has been shadowbanned: https://www.reddit.com/user/maus80 You should probably contact the reddit admins to unban you. Note: the mods of /r/php had nothing to do with this - we cannot shadowban accounts, nor can we unshadowban accounts. Good luck!
It depends. Like it said in the article, if your code mostly procedural then it's convenient to make it like $DB::run While if it's OOP, then it's supposed to be $this-&gt;db-&gt;run
The JSON spec prohibits comments in order to make it easier to build compliant parsers, so I'm uncomfortable with the idea of something that named to *sound* mutually-compatible yet isn't.
I hate twig. Its so gross looking IMO
the only one I know of that comes close is Guzzle
The solution to that problem is to stop pretending JSON is suitable for that use-case.
Good. Always Good. Never Bad.
&gt; I'm not a real programmer. I throw together things until it works then I move on. The real programmers will say "Yeah it works but you're leaking memory everywhere. Perhaps we should fix that." I’ll just restart Apache every 10 requests. – Rasmus Lerdorf
The built-in webserver in PHP is designed for debugging only.
With Hjson fully utilized I really do feel it is a great choice for the use-case :) JSON is such well distilled format for defining objects. There is no learning curve if you understand JSON... you just get to start omitting all the extra bits that make it hard to type. It's pretty much as easy to write as YAML without the whitespace requirements. Which I think could be a bit foreign to a lot PHP devs. But alas... I know... "stop adding more stuff to the technical landscape"
Cool! Is it whitespace sensitive?
It's good to see some people are trying out moving away from PHP's shared-nothing model. While it makes writing scalable apps easier, it's a significant performance issue. I suspect that PHP's “kill the chef” approach is the main reason why PHP alternatives can be faster. That said, I don't think shared-nothing will go away any time soon, nor should it. It's not a bad approach.
Yup! Well JSX is sort of another paradigm compared to templates :P
As long as those are the same across requests, that's where there's a big gain: you can reuse the objects. In a standard PHP request those connections (and objects) are recreated from scratch. What I meant by stateless is not sharing anything between requests related to the request itself (e.g. auth, user or session data, language of the page, …).
&gt; I don't think shared-nothing will go away any time soon, nor should it. It's not a bad approach. Agreed, this is immensely useful and simple. However do you think there would ever be a way to keep that architecture (shared-nothing) but have an init phase for a PHP process where it can boot its autoloader, DI container/application? The gain would be that we would remove the booting phase of a PHP application from the response time. E.g. something like this: require 'vendor/autoload.php'; $app = new App(); $app-&gt;boot(); php_fpm_ready(); $app-&gt;run(); The idea here is that when the PHP script starts PHP-FPM *knows* that it's not ready to handle a request yet, and it will wait until something (in the example `php_fpm_read()`) to consider the process as ready to process a request (at which point it would add it to the pool of available processes). It could even fork the process at that point to keep a template process initialized to populate the pool. Is that stupid because of something obvious I'm missing? (assuming of course we find a BC solution)
Yep, and I don't see anything wrong with that. This is very easy and cheap way to solve problem. Programmers are not so good in handing side effects of their code... p.s. I had a projects on reactphp and php-pm, and it worked. More problems were not memory leakage, but stupid developers which makes stateful services.
This approach seems cool to me, but ideally it would be copying it's "state" to start as child fork in my opinion (clone memory). Seems like there is no "real" performace boost since you still have to init app for each request, but it will look like a boost for clients. 
I have been working on this all week and am going crazy, haha! &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Enter a non-negative integer N (range 0 to 20):&lt;/p&gt; &lt;form id="form1" name="form1" method="post" action=""&gt; &lt;label for="input"&gt;&lt;/label&gt; &lt;input type="text" name="input" id="input" /&gt; &lt;input type="submit" name="submit" id="submit" value="Submit" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;?php array range ( mixed $start , mixed $end [, number $step = 1 ] ) array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20) foreach (range(0, 20) as $number) { echo $number; } ?&gt; &lt;/html&gt;
I for one don't care about the JSON spec. I just like using `json_encode()` better than INI for structured configuration in flat files. I don't like YAML. (I use a preprocessor to eliminate comments so they can be stored in the actual file.)
I like the built in unit testing tools mostly for the easy ability to put a breakpoint in a test or function, then just right click the function name and run just that test in debug
&gt; does a PHP process handle several requests at the same time? Nah, not PHP FPM or mod_php. I have no idea how PHP PM works, but it seems like it's a pre-fork worker system where each worker handles more than one request, but maybe not concurrently? Similar to [gunicorn](http://gunicorn.org/).
* Windows 95/98 - Named after Release Year * Windows ME - Turn of the centuary naming? * Windows XP - Named because XP sounds cool I guess? Or they got a young person to use an emoticon * Windows Vista - Uh... yeah, I dunno * Windows 7 - I guess this was the 7th major change, if you group ME with XP? * Windows 8 - Comes after 7 * Windows 10 - Because seven ate nine, so they couldn't use nine any more? Kind of hard to steal Windows versioning when there's nothing to steal
A lot of newer and smaller companies are using Lavarel, but a lot of enterprise and larger companies appear to be using Symfony and Zend from what I've seen. Generally, as long as you're proficient in PHP and can pick up things rather easily, then there is no massive point in specialising in a framework. What is the best framework? Each has their own benefits and drawbacks - there is no best framework, it really depends on the use case. 
That's not valid PHP. You should be getting a syntax error in your browser to help you determine the cause of the problem. If you're not seeing the error in your browser, you probably need to review your error reporting settings and make sure you have [`display_errors`](http://php.net/manual/en/errorfunc.configuration.php#ini.display-errors) on with a suitable [error reporting level](http://php.net/manual/en/function.error-reporting.php), such as `-1`.
I think JSX is sexy. Its clean and the logic is right there, and if you do it right you dont have the mess that some of these "wannabe react developer" create
Well, there *is* something to be said for shipping code quickly. Although the 4000-line switch statement I had to maintain that Rasmus wrote... I was not a fan. 
It is a great concept for sure :) No point in separating things when you don't need to! I certainly think that one way data + virtualdom can "untangle" a lot of things as well. Templates have their place though.... I work with designers who write html + css. So it's much more simple to use logic to pre-format data into a state where a template engine can take it and in the most complicated setting it is just preforming simple array based loops and boolean based toggling of elements and css classes. Nunjucks/Twig offer a sandbox that makes that quite nice I find.
I'm doing it anyway! Hehe ;) No but this tool is a practical/pragmatic solution to situations that arise when using JSON as a manually edited configuration file. In no means is it meant to be used as a replacement to JSON as an interchange format. You can just give the file an extension of "hjson" to avoid confusion. I see what you mean in a very absolute sense. But in that way a Python developer would look at PHP and think... "Why are you doing all this with a template engine????" You know? Maybe I'm just wacky! haha.
$y = Your Integer input (lets say 6) if ($y &gt; 20) {}//Error you said between 0 to 20 if ($y &lt; 0) {}//Error you said between 0 to 20 -cleaner to do in one statement, but if you are learning... //You might not have to validate but you should for ($x = 0; $x &lt;= $y; $x++) { //Our loop starts at 0, and goes to your input (lets say 6) echo "2^$x = " . pow(2, $x) . "&lt;br /&gt;"; //For each time we go through, say the math we are doing and get the result, and drop it down a line. } Whatever witchcraft you were trying to do confuses me
I'm not sure JSON's a good fit for configuration files. Not only does it lack comments, its mandatory key name quoting is annoying.
This is similar to how Python/WSGI servers work, and it is pretty nice. Being able to open connections to external services before a request begins can really cut down on the execution time. I imagine one problem could be that PHP-FPM can't know ahead of time which script will be requested by the web server. In Python/WSGI, there's one function configured to receive the request, whereas with PHP-FPM I could give it any SCRIPT_FILENAME (I think that's the right FCGI param) I want.
Weird, I would have assumed it required the first part of the name to match your Packagist name. Maybe this is a bug?
&gt; What will make it valid PHP? If you fix the syntax errors, it will be valid PHP. &gt; What is invalid about it? The syntax errors.
Using JSON as a config file makes sense at first, but there are by far better solutions made for that purpose, like YAML.
Totally! The primary issue with YAML that I have run into is that it is whitespace sensitive. So anyone not used to whitespace sensitive coding can introduce issues without understanding so. Conflicting tab settings and things like that can also cause issues. It's really about offering an easy to type and human friendly variation of JSON with no learning curve.
Check out the link if you want to use comments :)
That comes down to preference. I like the explicitness that you call verbosity. Either way, not-really-but-mostly-JSON is fine for reasons that pure-JSON is not.
One worker handles several requests. If one worker hangs in i/o (reactphp way, like streaming) this worker may handle more than one request concurrently.
When you use OPcache the interpreted PHP code gets saved as machine code artifacts, so it really makes very little difference in performance if it's compiled before execution, as long as you're using bytecode caching or a JIT such as HHVM.
Very few PHP frameworks and libraries are thread-safe because they weren't written with this paradigm in mind. Also there is a few, more mature, technology options out there which allow you to develop rapidly and are all around superior options for this particular type of tool. I would only use this if I wanted to take advantage of this with an application that I didn't want to re-write from scratch, or if there were a lot of pre-existing PHP libraries specific to my business. For new applications I would use something like Go, for instance. 
It uses various adapters to *plugin* to different code. For example there is an that plugs into Symfony's HttpKernelInterface allowing apps and frameworks using that interface to work. Symfony, Laravel and Drupal for instance. It also seems Drupal &amp; Zend adapters have been added. I assume the Drupal adapter adds more Drupal specific stuff to the bootstrap process compared with using the HttpKernelInterface adapter, but I'm not real sure.
Frameworks come and go. Being able to learn these frameworks quickly and understand their core concepts is more important. I would take the time to learn a framework in depth, which it sounds like you already have, and then start trying other notorious frameworks, that are in peak development. Stay away from defunct frameworks like Codeigniter for example. Which ones you chose really makes very little difference. It's about the journey, not the destination. If you can show an employer that you have strong opinions about a number of different frameworks then that will be the most impressive to a good employer. I would stay away from employers who are close minded about the specific frameworks they want candidates to be versed in. This is usually the sign of a very naive person in a leadership role.
I've used Postmark (http://postmarkapp.com) in the past with great success. May be another one to consider. They offer 50,000 free credits to bootstrapped companies getting started. 
It doesn't matter if you use separate frameworks but there may be reasons why it makes sense. It may not even be the best choice to use PHP for both apps, unless you have shared libraries. If you have shared libraries just be sure that you don't couple them to the frameworks. 
Unfortunately yes. Do you know a good alternative or have time to write on this http server library? :)
Here's a recap:http://phpfastcgi.github.io/general/2015/08/21/things-to-consider-using-phpfastcgi.html Most of those issues would only impact each process individually though, the whole purpose of PHP-PM being to kill and restart those... So it's kind of a safe guard. Still, with or without a safeguard you want to keep an eye on: * statefullness (sessions, static properties, global variable and properties on objects kept) * memory leaks (caused by keeping objects around for no reasons, the main culprit would be ORMs)
&gt; The minimum requirement by Yii is that your Web server supports PHP 5.4. BC Break with 5.4 or I really don't want to touch your framework.
Previous discussions: [original discussion](https://www.reddit.com/r/PHP/comments/3zyd4c/rfc_warn_about_invalid_strings_in_arithmetic/), [v1.1 discussion](https://www.reddit.com/r/PHP/comments/42trun/rfc_warn_about_invalid_strings_in_arithmetic_v11/?ref=search_posts).
good work Andrea! err.. i mean The Alias of Andrea PHP keeps getting better and better
What about $array1 = array(0 =&gt; 'zero_a', 2 =&gt; 'two_a', 3 =&gt; 'three_a'); $array2 = array(1 =&gt; 'one_b', 3 =&gt; 'three_b', 4 =&gt; 'four_b'); $result = $array1 + $array2; Will this also generate a notice?
Who said we're using `eval`? We don't need to maintain the property of being a JS subset.
PHP TUTORIAL IF ELSE IF STATEMENT
Addition of maps adds the key value pairs of the second operand to the first ignoring duplicate keys? Rather cool behaviour
HTTP Server on ReactPHP is not that complex, a couple of hours and you get it prob. But the real question is why is there some PRs with 2 years old
PHP is webscale: https://github.com/amphp/aerys
[PHPFastCGI](http://phpfastcgi.github.io/) seems to be a good alternative to ReactPHP. On a higher level (reactor + process manager) you have [Aerys](https://github.com/amphp/aerys) (supports HTTP 2.0, websockets ,etc) and [appserver](http://appserver.io/) (works with concurrent threads).
Please!
Yep, but what if the "template" PHP process was forked just after init? That would avoid the boot time entirely?
I guess all processes should have the same init, so it doesn't matter (at init time) if we don't know which PHP script will be requested at PHP-FPM level right?
I can't remember myself ever using "string" → 0 or "12 string" → 12; not even considering the option. Anything other than octals and such implies to me wrong data leaked somewhere into the numeric variable. Or if someone is pulling data from a database and it's coming up like "10 minutes" or "15 dollars" I don't trust that's not manual input and needs to be validated/processed before doing arithmetics. On top of that people are always going to be tempted to expect "string" to not be zero in arithmetics, since evaluating zero as boolean returns false, but evaluating "string" returns true. 
**PEPIPOST :** Pepipost is the speedy transactional email delivery service that provides reliable Inboxing in less than a second — all with a very disruptive pricing model. Only pay for unopened emails. &amp;nbsp; **- Website:** https://www.pepipost.com/ &amp;nbsp; **-** Unlimited Plan for Mandrill Customers ( Use below invitation code) &amp;nbsp; **-** Invitation code: **MANDRILL-TO-PEPI** &amp;nbsp; **- 25,000 Emails free per month for lifetime** &amp;nbsp; **-** $1 for every 5,000 emails &amp;nbsp; **- Pay only for emails that are not opened by your customers.** &amp;nbsp; **-** Free dedicated IP &amp;nbsp; **-** Reliable SMTP and HTTP APIs &amp;nbsp; **-** Real-time measurable analytics &amp;nbsp; **-** Powerful Triggerware rule engine &amp;nbsp; **-** Highly optimized inbox delivery &amp;nbsp; **-** Easy integration in the blink of an eye &amp;nbsp; **- 24/7 Live Chat Support** &amp;nbsp; **- How to Migrate From Mandrill to Pepipost :** http://www.pepipost.com/index.php/2016/03/10/how-to-migrate-from-mandrill-to-pepipost/ &amp;nbsp; **- Explainer Video:** https://youtu.be/4tSEn6BUO3Q &amp;nbsp; **- Pepipost Review:** https://www.g2crowd.com/products/pepipost/reviews &amp;nbsp; 
So is this a warning when casting a non-sensical string to a number, but *only* when the casting happens implicitly as part of an algebraic expression? What error would `echo (int)"xyz";` issue, if any? What about `echo 1 + "xyz";` vs `echo 1 + (int)"xyz";`? Just curious as to whether this is about casting in general, or casting in certain situations, or even casting in certain ways in certain situations.
Uhm, the validations done seem odd to me, also: composer update shouldn't be run by a validation. This command will pull new code, which should be tested and audited by a developer - concious vs automatic. A validation should just tell you that there are newer dependency versions available. Then I'm not a big fan of global installed composer packages. Such tools are better provided as a phar file (phar-composer or pharckager are great tools to create phars from composer based projects) Personally I'm using a tool called RMT https://github.com/liip/RMT which is similar, but can be customized in its validations, could have the ones done by producer easy added, and comes with a few pre-release validations that producer doesn't provide.
BUT ITS THE MOST DISRUPTIVE PRICING EVER
&gt; The JSON spec prohibits comments in order to make it easier to build compliant parsers, No....it doesn't. It prohibits comments to stop people from using them as annotations. This difference is one partly of semantics, but it means that a very useful thing was removed to stop people from using the technology 'wrong'. I strongly disagree with this philosophy for designing technology. Tech designers should be focused on "can this feature be useful", and ignore the question of "Can this feature be used for stupid stuff, that I don't think people should be doing". I absolutely hate the fact that I can't comment my composer.json files for why certain versions of libraries can't be used due to bug incompatibilities. Yeah, other people who would use comments to 'extend' the JSON format through annotations are blocked from doing that, but why should I have to suffer just because they want to do something Doug Crockford considered dumb? 
While it doesn't solve your problem, it's also important to note that SELF is the script file that is running, not necessarily the URL the use had visited. A very key distinction.
IMHO `echo (int)"xyz";` should not produce a warning, since that is an explicit cast, which could be useful when sanitizing user input.
&gt; not a big fan of global installed composer packages Why's that? How are phars better?
Don't use `$_SERVER['PHP_SELF']` as value for the action attribute on forms. Instead, use an empty string, as this will protect your users against certain attacks.
LOL, good point. I wonder how the visually impaired worked that one out..
Not to mention people who's Facebook accounts are mostly for keeping up with people they haven't seen since highschool. Which is a big portion of their userbase I imagine. Honestly, anything other than email and password is either trading security or making it harder to use the service. 
I think I must have been quite tired when I wrote that. I'll fix it.
I like client side certificates.
GIRLS https://www.youtube.com/watch?v=VBmMU_iwe6U (Sorry couldn't resist)
Why not use a VM, and replace your bash scripts with Puppet? I wrote something for you: https://puphpet.com
a phar is self contained, i can add it to a bin directory that i have in my path anyways, rather than adding yet another path to search in. then there is the thing where global installed packages share a vendor directory basically your global install will create a composer.json in ~/.composer/, and this one is used for all global installed packages, which means they share their dependencies, which means the more you use the more conflict. "Producer" installs 70 (!) packages. And because some of those are commonly used tools, such as phpdoc &amp; phpunit, that might interfere (depending on the path setup) with the installations of those tools. (as the symlinks for those are created in ~/.composer/vendor/bin as well) 
It is becoming more common to decouple tasks and use a platform / framework that is suitable for that task. You may find rather than different frameworks in one language, it'll be different languages altogether. Alternatively rather than using totally different frameworks it might be better to use seperate installs to separate your concerns but allow sharing of logic a lot easier. 
[removed]
In case you didn't know, there's a solution to this called Vagrant. It does the same thing using virtual machine. It will keep your local clean from dev environment. If you work on several project you can have multiple Vagrant. There's also Docker which basically the does the same thing. But, it's a virtual machine and of course it uses more RAM. So the benefit of your script is it uses less ram and runs natively (sometime it's faster)
One problem with these cooky login systems is that they are normally much less secure than a simple password. A couple I've seen are things like picking an image you uploaded compared to some similar ones. Basically this is the same as a one character password in a 9 or so character alphabet since the actual uploaded images will always appear as one of the options. I saw a forum once that had you upload a file to login, that was kind of cool and a little easier than remembering a password tbh, the only problem was keeping it in a safe place and not just on the desktop. So yeah, probably just stick with usernames and passwords
It depends on what you mean by "init". All PHP processes have the same init step for the interpreter, and PHP-FPM does perform that before blocking on FCGI input. Unfortunately, while that does help, it isn't the primary benefit of a setup like what Python/WSGI has, where your script gets a chance to run before accepting requests. (That style also obviates the need for a global OP-code cache, because each process can perform the compilation before client requests start.) It's a tough problem to fix if the language doesn't have a nice module system. In Python, you can say "import this module, then call this function for each request". In PHP, I think the solution would have to be something like "include this autoloader, then instantiate this object (which would presumably initialize the app) and call this method for each request". Which I could definitely see working, as long as the PHP interpreter could handle it. An issue with that approach would be some of the assumptions scripts can make right now about their execution environment might be completely false. And, of course, all major applications would likely need to be heavily modified, if not rewritten (I'm looking at you, Wordpress). Anyway, sorry that got a bit ramble-y. This is the kind of tech I'm really interested in. :)
wow that looks amazing.
There's [a lot](http://www.sitepoint.com/tag/vagrant/) of [solutions](http://www.sitepoint.com/quick-tip-get-homestead-vagrant-vm-running/) to this already, arguably simpler and more versatile. But kudos for the effort!
Or just don't use it. One less potential issue.
hrmmm... can't believe i got multiple down votes for that. OK, fine... "don't use it". But... if you look for different ways to avoid escaping data, you'll eventually forget something. There's nothing wrong with using PHP_SELF if it fits the use case, and is more explicit about your intentions (vs not having any action in a form tag at all). And if you're trying to use the PHP_SELF var for an AJAX call, you'll need to escape it there anyway (or do some other sanitization before outputting it). 
Another one here reinventing the wheel during the last month. Are you trying to replicate how Symfony/Laravel/Any other framework works or are you trying to create one that works for you? In my case I have been developing mine trying to follow best practices and implemented most of the things you mentioned here. I have no fully finished every single part but generally speaking each part is doing its job. I know that feeling of thinking "this is too simple", but I wouldn't say that's necessarily bad it's simple and it works, that's cool! I think a good option is creating a project, lets say a blog, and work with your framework making sure that everything covers the needs. Then trying to implement new changes or things that are missing on the next one. I'm probably not solving any of your issue but I like someone that is wanting to learn more by reinventing the wheel. I have read so many times "don't do that, it's already done by people that know a lot more than you!" that sometimes you can feel a bit stupid trying to learn this way (or even using it if you have a nice thing at the end). Enjoy learning how to create a wheel and adapting it to your needs.
Indeed! The Android swiping pattern feature is about as secure as a 4 letter password, no capitals, or slightly stronger than a 3 character alphanumeric password, with capitals.
I can see why you see it as ass backwards, but the reasoning is practical if looked at from a certain point of view. This is more for the case where you use JSON as a config and the contents would always be going from human to machine. It's more about leveraging an understanding of JSON that is very likely to prexsist. JSON is also a very distilled object definition format. The idea is that Hjson is easy to write and allows comments on top of that. So people can learn by seeing what Hjson let's them get away with as they separate from JSON. It's really nice because the variation is largely based in a common sense sort of direction. In terms of requiring the parser... certainly would need that, but that would be a part of the codebase. With stuff like YAML etc... they tend to be whitespace sensitive, which this is not. I have just found that whitespace sensitive solutions can cause issues when a wide range of developers are editing them. A good case is when one developer uses spaces for tabs and another uses tab characters.
Drop the X and keep the parenthesis and it works without your function. (new Thing())-&gt;met(); Though this usually means you have a class that should have been a function instead. 
Not really trying to recreate a specific framework, just creating one following best practices and one that works for me. Trying to understand the design decisions different frameworks made and what the impact of these decisions are :) cool that u are also making a framework! You can always contact me if you want to discuss things about your framework. maybe we can compare our frameworks and improve each others framework!
Facial recognition through webcam. 
Well it's not brute forceable if you delay and limit attempts. 
VMs are great, and puphpet looks awesome! (My very personal job-related) problem is, my day job has me working on a computer run by draconian IT (read: can't install Vagrant), this gets around that restriction as the only requirement is git for windows.
Big fan of VMs, but... copy-pasted from my reply to u/jtreminio: (My very personal job-related) problem is, my day job has me working on a computer run by draconian IT (read: can't install Vagrant), this gets around that restriction as the only requirement is git for windows.
I'd imagine that each plugin would be a package in it's own right, so yes, would have it's own composer.json (this is typically how libraries work). The only thing which would make a plugin different to a "vanilla" composer package would be that there would be some sort of contract that made it a plugin... some sort of service provider which allowed it to be hooked into your framework. The user would "composer require some/magical-plugin" and then modify some sort of config to make the framework aware of it. If you want auto-detection you'd need to inspect the installed packages and go looking for that thing which makes a plugin a plugin, and load it into your framework at runtime. When you composer require, composer will install any and dependencies the required library has, so there wouldn't be a further step for the end user.
What's your preferred linux OS for running PHP webapp?
Based on a bunch of back-and-forth on Github that you can dig up from the page, it seems to be... well, not intentional, but I guess laziness? It's certainly known by the Packagist maintainer(s)
Well if you are protecting data that has enough incentive for an attacker to DDoS you, or continuously try for a month, then you should probably use a username/password. If however you are simply protecting your favorite color, the attacker would like spend time somewhere else.
&gt; The next time you start solving a problem - consider if ExpressionLanguage could work for you. I don't understand this attitude. Do we owe ExpressionLanguage any money or favors that we have to consider it for solving a problem? How is ExpressionLanguage better than just using PHP? It seems to me the only value of this component is for Symfony to fix a problem they created by themselves by shoving everything in XML/YAML config files (instead of sticking to PHP) and then needing expressions in their config files (something PHP already does better). There's a place and time for DSLs in modern apps, but I don't see any such examples put forward here.
Thanks.
MailGun use to be about 50% more than Mandrill. Then they have changed all their tiers and free plans to match Mandrill. Mark my words, with Mandrill changing their costing and business plan, MailGun will put up their prices. And you will now be looking for a 3rd provider that is cheaper. 
ubuntu 14.04 or Debian 
I too, love seeing this. PHP is made better by a wider ecosystem, but looking at the implementation... I don't see anything to get excited by...YET. Perhaps some folks will want to jump in early in the design phase, but it's a long way from being a viable implementation of syntax, let alone runtime library.
Its a webapp wrapped in chrome container. How much memory is the browser version using on you? 
Windows ME was Millenium Edition, the last of the DOS era 
DOS era? I'm not really sure what this means. Sorry, my first computer was a '98, and I didn't really understand them till XP. What was the DOS era? I thought computers had GUI's since at least '98, maybe before?
Well, there is still one *amp which not dead and is up to date - xampp.
Interesting, but I get the impression I would soon hate working on a codebase which used macros ~~for anything of any complexity~~.
You could read this tutorial to get some inspiration: "How to create your own PHP framework with Symfony components" (http://symfony.com/doc/current/create_framework/index.html)
Ubuntu
Umm.. what?
Watch out, this is for the active record pattern only (as you mentioned eloquent for example). The data mapper pattern (the most popular project using it being doctrine in php) does not work like that at all.
Sure. This is the standard I am using. Each time a RFC is voted (https://wiki.php.net/rfc/), then the documentation is updated accordingly.
That link is in Turkish, so I guess OP is new to reddit and got very confused :)
2.1 will require at least 5.6. We aren't breaking 2.0 significantly. Ever.
Very interesting. I tried something similar years ago with Mongrel2 + Zf1 adapted to work in a request-response loop and it worked great. the downside is that like every long-running environment in PHP, you have to face with memory leaks, sometimes even nasty ones (eg. with libxml)
Don't know how I feel about them yet. I like the challenge of trying to get complex, new syntax to work, but it's the same kind of thing as macros in other languages, like C. Totally going to be abused most of the time.
Great to see that they chose an easy number of right arrows for that. *silently laughs inside*
Where is the existing answer?
It looks like the website jarves.io uses it: http://jarves.io/. At least according to: https://mobile.twitter.com/MarcJSchmidt/status/710753291932704770
&gt; I don't remember where this is from, but a dev once said: "Anybody can build crypto they themselves can't break, building crypto nobody else can break is the hard part." It's a variation of the [Schneier's Law](https://www.schneier.com/blog/archives/2011/04/schneiers_law.html)
man is that his real name? `Dries Vints`, god I read that 3 times being confused.
Array() or []? And why? 
Ubuntu 
Problem is that sometimes sourcecode is not enough. You might want to hear the thought proces behind it. Or develop your own code with your own though proces but just need a bit of guidance. Plus some frameworks are made so complicated to the beginning programmer that it's really hard to dive into and understand it.
Actually, you pronounce it as "Reese" in English. But starting with a "D".
Doctrine at least can be very easily made to work like that, by having a base class for models that stores its own copy of the `ObjectManager` instance and duplicates some of its methods using `get_called_class()`. They have a [PersistentObject class](http://www.doctrine-project.org/2011/11/21/a-doctrine-orm-odm-base-class.html) that does some of this kind of stuff.
I meant no offense btw, a few commas in the title would have cleared any confusion.
I think quite a few of us may have gotten confused by the title there :)
No worries! Non taken :)
off topic: you heard hearts of iron 4 is coming june 4th? :)
I'll be writing more about this tomorrow. The "what" (that it, the things getting validated) is on the page; to wit: - Sync with the remote origin (i.e., pull from the remote origin, then push any local changes, then check the local status to make sure everything is committed and pushed) - Validate the composer.json file - Check for informational files and for a phpunit.xml.dist file - Check that the LICENSE file has the current year in it - Call composer update, run the unit tests, and make sure they cleaned up after - Check that the PHP docblocks in the src/ directory are valid - Check that the CHANGES file is in the most-recent commit to the repository The "why" is something I'll get into later. :-)
It does have its place, especially when the expressions are whitelisted and auto-completed in a front-end, allowing small changes to be done by marketing/a PO without having to go through the developer. Some business have a narrow enough focus in their products or require small tweaks to numbers that make expressions incredibly powerful and flexible.
It would require and additional Oauth login provider which I'm thinking of adding soon. I'm torn between rolling out my own vs using the PHP oauth one. But if you really need smth like that you could easily hack something in minutes. 
Yes, bit of a silly title 😅
@ /u/r-e-m-o You could found a turbine with plates example here: https://github.com/phpthinktank/blast-skeleton
[Key promoter](https://plugins.jetbrains.com/plugin/4455) Useful to learn shortcuts. Unfortunately the last release date - 22.05.2012.
Everybody uses MySQL. Why not postgresql?
Last summer I wanted to learn React (JS) and experiment with websockets so I did a small side project which ended up using Ratchet + React (PHP) + redis pub/sub. https://github.com/conradfr/IsItYet I don't have that much traffic and I don't really monitor the ws long-running process but the websocket part was mostly straightforward (good job on Ratchet docs). So thanks for your work.
Because they're constrained by PHP coding standards which are 5 years old.
[] obvious choice
PSR-7? This was only accepted last year afaik, and I was more focused on getting Aye Aye finished than I was worried about those features at the time. However, you are right and it is definitely something I'd like to add in the future, though there are other things I want to tackle first (interfaces, Behat feature context and a proper tutorial). I'm also not yet sure if making the Request and Response objects PSR 7 compliant will break BC compatibility, so I want to do it very carefully. If you think it's doable, I would welcome a pull request. ;)
If you can control the entire environment in which your application will run, then Postgres is an awesome solution. If your application is intended to be run by mere mortals on shared hosting, picking anything other than MySQL is a horrible idea.
I'm sorry, but it kinda feels like you didn't really read what I wrote in my comment and in my reply to the ops question on that, but maybe I didn't explain it well enough. Frankly, I didn't look who was behind producer, I looked at what it did, and I gave my feedback to that. I'm maintainer of quite some packages myself, both open and closed source, so no, this is not someone "managing only a few" saying something random, and I'm not interested in random pissing contests either. In the solution which I mentioned (phars of the tools in question), you also have them globally available, but without the danger of having one tool interfere with the other - or blocking updates of other tools by having older dependencies, for that matter. I did not suggest, and i wouldn't suggest to make 'em dev-dependencies for each project (which is also something I've seen a lot of people do). I'm using a ton of tools in my daily work, some of the code quality related, some code metrics related, some release related, some just to automate boilerplate away, and some just because one of the projects which I help out is using it for their stuff. Almost all of those tools have some dependencies, the most common one being the "big" frameworks", just as some tools that Producer depends on have. Now would install all of 'em as global composer installs, then just one of the tools that Producer is pulling in (again: 70 packages) having its dependencies not depend on the latest majors at any given time, will conflict and prevent me from using the latest version of that tool - thus one slow maintainer can block the whole global-installed-composer-toolbox. (And I don't even want to get started about the possibility of one of those packages installing composer-plugins, just because its a dependency, thus bloating up composer more than necessary). The suggestion I managed before is simple and elegant - I see each tool that I'm using as an own application, with its own dependencies (and composers global doesn't allow this), so I install them as I need 'em - and since phars allow me to have tools in one (executable) file, phars make it easy, especially (as i mentioned) by using tools such as phar-composer (https://github.com/clue/phar-composer), which can create run-able applications from composer packages. If I was you I'd rethink the approach of forcing the user (be it yourself or people who want to use your tool) into one monolithic dependency tree, opposed to seeing tools as independent applications. 
Yeah, if you don't need to support &lt;5.4 :) We do support it, so I cannot just drop the x and parenthesis. This is for method chaining, so it's not supposed to be function.
I don't want to send you in one direction or the other here but I'm primarily a php developer and use both node and php for my application. I'm using the Laravel framework and it was pretty simple to get both to interact with each other
I've never gotten confused before and definitely read your name before, but I read Dries this time as a verb =)
From the readme: &gt; Rust stops checking when encountering an unsafe block. This isn't really accurate, Rust still has most of its safety checks turned on when in unsafe blocks. Being in an unsafe block just lets you do three things: dereference unsafe pointers, call functions marked unsafe, and mutate global variables. In practice this is sufficient to let Rust do everything that C can do (and really it's more than sufficient, the latter two are mostly conveniences for the former).
Perhaps documentation and inline comments can address this, in much can the same way as they should help with the magic we do already. I don't see that many complaints about macros in languages that have them...
Ill let you know what direction I head and keep you updated on my experiences. May be a while though.
&gt; In my experience PHP is not super great for writing services/daemons. It does less out of the box, but all of the primitives are there to handle it just fine. Use a library that does all of that correctly and it will handle both with just as little or much complexity as any other service (e.g. you can't ignore memory leaks anymore). Yeah, if you roll your own daemonization logic, you're probably going to get it wrong. Granted, it still may be the wrong choice for the job, just not for that particular reason. Source: production PHP processes that only get restarted for code changes, years of effective uptime.
Docker only uses a virtual machine of you're not on Linux. I created a basic set of containers to let me use a few variations of servers locally at the same time... Combinations of Nginx, Apache, PHP 5, PHP 7, MySQL, MariaDB... https://github.com/Hambrook/Docker-Local-Web-Server
The "why" I'd also really love to hear. Even after this explanation, I'm still at a loss as to why I'd want to use this. Mostly because I push changes all the time without a problem. Also, I very much would not want composer update run automatically, although there's plenty of value in knowing *if* something is out of date. A publishing tool shouldn't be changing what the maintainer considers the "complete" release.
You should really take a look at Go(lang). It's not too difficult to learn it and mock up some testing applications to see whether it's a good fit for you or not. Oh and Go will beat both PHP and Node for intensive stuff. Whatever you throw at it. It does well as a service/daemon. IOW it's a perfect fit :)
Just because it *can* work doesn't mean that's suited for that task or particularly good at it. There's other choices that are.
I know. I even said that. &gt;Granted, it still may be the wrong choice for the job, just not for that particular reason. 
&gt; Using tools outside of their 'intended' fashion is how you spur innovation and creativity. It's also how you get php-gtk...
I don't think there's anything wrong with combining both into one framework, but if you're building a large scale app and have a larger team, I think you're much better off separating into two frameworks. I manage a team of 10 devs and have separated out the API and Web into two separate frameworks (the web is primarily emberJS). It's VERY comforting knowing that know matter how badly my web team may fuck up (they don't really, just exaggerating), they can NEVER break the API (which is also used by third parties). You'll never have that comfort with a single framework. Your deployments also become less risky. For critical, API based apps, it would be silly to have a deployment fail because of changes not related to the API. Of course, if you're just working on a small or personal project, none of the above helps and you're better off combining into one. edit: added bit about deployments
Thanks for your answer :) I am definitely going to look at ORM and Composer! PS. you are the author of the (only proper) PDO tutorial right? Awesome tutorial!
The answer is simple: node is designed to handle a shit ton of connections while php isn't.
Never thought of making the plugins composer packages :) Sounds like a great idea! Is there a way to store my plugins in a different directory and the normal composer packages in the regular vendor directory? Would really like to keep my plugins and other external libraries seperated.
great tutorial, thanks!
Yeah, this sounds like a reasonable way to do it. Use Node for the data pushing, and PHP for the number crunching. 
This is really interesting.
Erm... I answered first...
This is just silly. The problems with the current trust model are fairly obvious, and just because many people rely on it doesn't make it a good model.
What would the effect of having hundreds or thousands of long running php-fpm processes running to supply EventSource server-sent events? It looks good and easy but I can't find a lot of information on a pattern to make it run efficiently.
&gt; The "why" I'd also really love to hear. Even after this explanation, I'm still at a loss as to why I'd want to use this. Mostly because I push changes all the time without a problem. (/me nods) It's not so much about "pushing a change" as "making a release." Pushing changes is not that big a deal; tagging a release that can't be changed afterwards, well, I want some final checking to make sure everything is OK. &gt; I very much would not want composer update run automatically I very much want it running, to make sure that all its tests pass with the various requirements. This is part of the "final checking to make sure everything is OK." Of course, that presumes `vendor/` and `composer.lock` have been `.gitignore`d. Producer checks `git status` after the tests run to make sure everything has been cleaned up, and if not, it will fail to validate. More tomorrow!
&gt; it's by far the most popular PHP framework out there Nice source.
http://www.sitepoint.com/best-php-framework-2015-sitepoint-survey-results/ Not the only one. Google it.
err that website still alive?
OK, Roman.
Pho is actually my goto when I want spaghetti-like code but with rice noodles instead.
This. Can make it a service, run concurrently as much as you like, and will beat everything else in terms of performance. No need for Node or PHP unless you're relying upon other major functionalities that GO isn't meant for.
I've never used it, it looks useful. How's it's performance? I see it hasn't been touched for years... Is there a reason for that? I think I would rather use Node-WebKit though, I think I'd be able to make a much better UI with HTML/JS, powered with php rather then node... Haven't had a need to make a non web based UI though...
youre reply is uneducated
Correct. That was a little bit too popularized. Thanks for noticing!
Separate user/admin areas is a great feature. I wish Laravel had something similar out of the box. You always want your admin auth to be strict and timeout after inactivity, while normal user auth can be left up to the user if they want long-term auth cookies or tokens.
Instead of using the locale, just use the billing address. I've had to implement multiple payment gateways before, and this solved so many issues.
Wouldn't it make sense to use Omnipay and add in support for the other gateways (and share that back with the community)? Also, have you searched GitHub to see if there are third-party gateway code for the other gateways you need to support? Someone might have already written one, and its just not listed on the omnipay website. 
I think people complaining about PHP not being suitable for WS are just not using good enough library. In my previous company we had rather big project involving mobile devices &amp; desktop computers and app running 24x7 connected via WebSocket. This project after 1.5y still runs constantly w/o any performance issues. I don't wanna make an ad here, but due to lack of good PHP-only, fast and secure WS library I developed my own implementation that time: https://github.com/kiler129/TinyWs p.s. The only thing you need to take care of is maintaining TCP connection. Unfortunately it tend to drop silently if no data were transferred after several hours w/o any notice. I not sure if it was a Chrome or our network problem, but it was also a case with standard TCP socket (not just WS). The solution for that is to manually send some ping packets (but not the RFC PING since it's not supported by browsers) every minute or so. 
It's possible, but I would not recommend it. I think it's best to try to ignore the `vendor/` directory structure and completely rely on the php autoloader.
It makes more sense when you think of the computer in a confidential or secured sector where IT isn't slow but it has to investigate what's really going on.
[] - It's just faster to write
Prototype against something like [Firebase](http://firebase.com) which takes care of websockets, maintaining connection, authentication and has both js and php client libraries. Once the application is implemented, you will know enough to implement your choice of final backend technology (or stick with Firebase or whatever you picked initially)
&gt; Absolutely, however the trade off for us is that as a php shop I can support/extend/improve the entire thing better then in other languages. I think this is a bit of a fallacy. I mean, if it were true, then everyone would be a JS shop using node + mongo, cause js is an absolute requirement but PHP isn't. But they aren't. JS has hit the server for the same reason PHP has something like reactphp: people are unwilling to step back and select the appropriate tool for the job. I can understand you see utility in being a php shop and using a php tool, however I'd imagine that the problem space is complex enough that you hardly leverage anything of the average php developer. By that I mean e.g. that MVC is a solution for my web back ends, not PHP, and if PHP had no decent MVC framework I would swithc to .net because it's far easier to learn the differences between c# and php than it would be to reimplement and maintain a symfony equivalent. 
Nice work, well done. I tried to figure out if this affects tests for equalities like: if (10 == "10 apples") // true but I did not see, or missed..., that part in the RFC. Hmm, I read it again... found the answer to my own question. &gt; It also does not impact the behaviour of type juggling for comparisons. Anyway, great work, it will remove one odd behaviour for PHP newcomers.
Thing is, most documentation and examples I see are still in array(). I also am very much of the [] school. 
Hah, C macros are exactly what I was thinking when I wrote that post; an awesome tool when used correctly, but when they're not used correctly they can lead to code that looks a tad obfuscated. As /u/williamgbuckley has mentioned though - for configuration and route definitions this could be *really* useful. I may try and experiment with them a little bit today on a personal project for that very scenario.
Keen to see what you settle on. Would you mind posting a link back here? :)
yes it is still live..
&gt; Ideally I would like to develop a single gateway interface Yes, definitely do this. &gt; and use the customer's locale (en_US, fr_CA, en_AU, etc.) to determine which payment gateway to use by default Debatable. I'd suggest using the billing address instead, unless you're describing a situation where the gateway is hosting the payment form. And possibly the payment method, if you're supporting stuff other than payment cards. The reason for this is that it allows you to optimize interchange and currency conversions based on your back-end business rules in a way that should be completely transparent to the customer. Granted within EU you'll mostly be on the Euro, but given that you're also discussing NA customers, currencies are something you need to consider. As a huge bonus, it's not in any way tied to HTTP, which will make doing asynchronous stuff down the road much easier (this may or may not be important for you, but as a general rule, having fewer dependencies is better) &gt; I'm thinking of using a factory pattern to build my payment services More or less, yes. Some sort of `GatewaySelector` class that takes information about the payment and returns an appropriate gateway to use for said payment. &gt; Obviously there will need to be [...] ability for the customer to override the default in certain situations This is really interesting to me - why should a customer be selecting your back-end payment gateway? I can't imagine what the use-case for this, and I've been doing payments professionally for about seven years now. Also as a general thing, be very cautious when it comes to PCI stuff. Based on what I read, I'm getting the impression that card numbers will probably touch your server, which immediately puts a compliance burden on you. That's getting deep into where I normally do paid consulting, but at the very least have it on your radar, and **don't store credit card numbers**.
Good advice, but it's difficult to assess how much that debt actually is without good documentation and/or previous experience with it unfortunately.
Hahaha, I knew there could not have been another actual user of this framework. Who in their right mind is going to tell anyone they use a framework named pixie?! 
You could have said something instead of throwing some links up. 
I'm pretty sure it's pronounced fuhpixie.
Great job OP!. I'm sure 20% of everything ever posted here was about that framework. 
well, /u/dracony must have used some sockpuppet accounts, but thats not a big deal IMO. He tries to put some lights on his work and I think he doesn't get enough credit for it. I dont use phpixie (more into symfony) but it looks like a quality framework to me
I'd go with nodejs with socket.io
Does someone tried it?
[removed]
I talked to him right now in the [chatroom](https://gitter.im/reddit-php/chat), he is banned for 3 days for using alt accounts - upvoting, but NOT posting from multiple accounts. I am not going to be a judge or whatever, but maybe we could wait for those 3 days until he can at least defend himself, or something? Reddit is pretty fast to jump on a hatewagon to circlejerkville, so let's not go that route. From what I've seen /u/dracony is really trying hard to create something good for the community and spends lots of his personal time to create stuff for everyone else to use. No matter whether you like or hate his work, at least you should appreciate it. So maybe take a quick step back and let the emotions cool down a little, shall we? :&gt;
Because I want it to be easy to see which plugins are installed and easy for people to find plugins, as they might need to adapt the plugin or setup some config or something. Don't really like to mix the plugins with other external libraries
You can also use the `is_finite()` function instead of that `in_array()`, which is currently missing `-INF`. Note however that a division can result in an infinite result even if it's not a division by zero. So if you want to detect a division by zero you should just ... check if you're diving by zero beforehand :)
Mods don't suspend accounts and you can't just ask admins to suspend someone. Admins examine the evidence themselves and decide whether the accounts are sockpuppets, which probably involves checking IP logs and timings and referrers.
Huge coincidence how the mods looked into my account on the same exact day this got posted here, lol
PhpmyAdmin is totally secure and reliable said no one ever.
He [already has responded](https://www.reddit.com/r/PHP/comments/4bgoou/multiple_sockpuppet_accounts_used_in_rphp_by/d18zc4m) with two more sockpuppets. Even after being called out he's continuing the act and treating this forum like a bunch of idiots - I have no sympathy.
However This works for me and gives me Division by Zero error try { var_dump(intdiv(1,0)); } catch(DivisionByZeroError $e){ echo $e-&gt;getMessage(); echo "&lt;br&gt;".$e-&gt;getTraceAsString(); } 
What's the actual evidence here? That two people host sites on the same server? That's just evidence that they probably know each other.
I reported the accounts to the admins first, they responded and said they were investigating the accounts. When I woke up this morning I could see that /u/phpgeek and two more accounts that I was suspicious of (but didn't report) were permanently suspended and I believe /u/dracony has been suspended for a few days. As has been mentioned, admins don't just issue a site wide ban without some investigation and they picked up on accounts that hadn't even been reported.
I never reported this sockpuppet, the admins picked up on this one during their investigation.
Yeah, well, you know, that's just like, your opinion, man. I am not saying he didn't do what you accuse him of doing. Quite possibly he did, alright. You should have given your proof to mods/admins and let them deal with it. What you should NOT have done is accusing him publicly of stuff and not even give him a chance to defend himself. That is a pretty low blow, man.
Mods might have asked the admins to look in to it, and the admins might have run your account through an automated tool. But no, mods don't have the power to suspend and admins don't just take requests from random people
Already posted this below, but it's relevant here too: I reported the accounts to the admins first, they responded and said they were investigating the accounts. When I woke up this morning I could see that /u/phpgeek and two more accounts that I was suspicious of (but didn't report) were permanently suspended and I believe /u/dracony has been suspended for a few days. As has been mentioned, admins don't just issue a site wide ban without some investigation and they picked up on accounts that hadn't even been reported.
Maybe you are right, I just don't like public witchhunts, especially when victims can't even defend themselves. I have seen innocents hurt this way. Let mods/admins deal with it (which they did) and that's it.
This is the reason.
&gt; if I make 2 accounts &gt; and praise something on /r/php that will make the guy receiving the praise a puppeteer &gt; and get him banned (Dracony in the chatroom). &gt; What, can I now just go and register 2 accounts, comment positively on somebody and than get him banned for puppeteering Keeping up the charade might just cost you your main account too, Dracony. Since posting under alts while banned is not allowed as I'm sure you noticed in your ban message.
Yeah.... even ignoring the sock-puppetry it's slightly annoying that this rule isn't enforced: &gt; Please do not frequently submit links to your own content, exclusively. It's likely to get spam-filtered. Posting links to your own stuff more than once a month is just too pushy. It should be at least possible to find one of your users or friends to post a link for you...
I feel it should have just been left to the admins to deal with abuse of the system. Creating witch hunt threads on reddit doesn't really seem helpful. Especially since the "horrible thing" he did was just to promote his pet open source project.
hahaha hi Sherlock :) edit: i get downvotes for what?
Just FYI, using a second account to circumvent an admin action is a pretty big offense.
So in a 12 minute interval both your totally-not-sockpuppets created "&lt;former-username-here&gt;2" to comment in this thread. Don't go digging up the dead body the second someone accuses you of murder... 
Standards? No. Language limitations? Perhaps. It's not a huge deal, and your own code can simply follow PHP7. You probably won't touch the framework code yourself anyway.
&gt; I reported the accounts to the admins first, they responded and said they were investigating the accounts. At which point your job was done, you didn't need to say anything to anyone else (because no-one else could actually do anything) and this whole thread became entirely unnecessary, surely? Either dracony and phpgeek are the same person and have been banned for sockpuppeting, in which case this drama is entirely unnecessary because the situation is dealt with, or they're different people, banned for entirely different reasons, and this drama has just hurt their reputation with unsubstantiated rumours and claims. In neither case would there be a reason to post this thread, especially when you've made it clear that the accounts have already been suspended.
Which they only looked into because somebody actually made a report. They probably looked through phpgeeks' history, saw pixie stuff there, and decided to "eeeehh, why not" and suspened him. Tbh why not also just suspend them for a limited amount of time? Like a week or a month? Banning a user with 900 karma sucks
yes and no, yes that could be a summary of what I was writing, but if it is, then I might have failed in getting across what I mean. no, as in thats not what I would do. What I would do is have a close look at which packages are hard dependencies (because code is and has to be called directly from there), and which isn't (but can be run as an own tool). I'd add those which code I need to the phar package of producer, and have the others called externally (by looking them up in that order: producers config file, vendor/bin/&lt;tool&gt;, path), as that should cover most use cases. putting everything in one phar seems excessive (but could be offered as an alternative "producer.phar" and "producer-bundled.phar"?)
There's a report on PHP's Bug Tracker for this issue: https://bugs.php.net/bug.php?id=71306
The account /u/eneusnoster was created 4 hours ago (an hour after this thread), immediately made one pointless comment on a /r/aww post and then waited a few hours before posting here. I'm not saying anything... I'm just saying...
I'm still very much alive :D
Hi dracony, how are you today?
hell, I thought this was an SRD thread summarizing the drama for about half the post.
&gt; From what I've seen /u/dracony is really trying hard to create something good for the community and spends lots of his personal time to create stuff for everyone else to use. No matter whether you like or hate his work, at least you should appreciate it. So maybe take a quick step back and let the emotions cool down a little, shall we? :&gt; In my mind it all boils down to how he's promoting his library. If someone creates a PHP library to do a task that no current library does and then someone asks how to do that particular task and you post your PHP library as a solution... that's not spam in my book - that's a real answer. And similarly, if you wrote a library and want to get feedback and post about it... sure, that's kinda promotion, but it's legit enough too. As long as you only solicit feedback once or twice or something. But that's not what /u/dracony is doing. His method of promotion is a lot more spammy than other methods available to him. It may be more effective but it's also more spammy. And because of that I think it's safe to say that /u/dracony isn't promoting his product out of benevolence but out of a desire to bolster his own ego. For example, consider https://www.reddit.com/r/PHP/comments/4bclfe/updated_phpixie_auth_project_this_time_with/ . If every project made a /r/php post every time they made a change /r/php would be flooded with posts that 99% of people weren't interested in. If /u/dracony wants to post about changes he should create a new subreddit - /r/phpixie or something. But he isn't. So long as he's posting on /r/php stuff like that it's just another opportunity for him to plug his product to the PHP community at large.
&gt; you are not allowed to use multiple accounts to engage in voting manipulation. Some very popular users like /u/Unidan have been banned for using multiple accounts to upvote their own things. It's really good at detecting it now. A little while back I posted something here with an alt and made the mistake of upvoting something I'd posted on my main account (and that was a genuine mistake - when you use reddit a lot, clicking upvote arrows is almost instinctive). Instant 3-day suspension.
I also have used Ratchet and had no problems with it at all. However you probably should look at simply using supervisor to make sure your server is always running vs using a cron job.
To everyone defending /u/dracony Stop it. He needs to grow up and stop with the constant attention-whoring of his projects. If they were any good would they need him to promote them? Look at Laravel, you can't get two steps into a discussion before a Laravelite comes to ask you about their Lord and Savior, Taylor Otwell. . . /u/dracony take this opportunity to reassess why you program in the first place. Like anything else in life, doing it for the attention of others will lead you nowhere. Do the hard work of making PHPixie great, and the rest will follow.
Just started using Laravel and man it's awesome, I'm not deep into it but in little to no time I was able to route GET and POST requests to display / insert users into the DB, really cool :)
[removed]
/me nods I think I get where you're coming from. So the Composer `require` lines for PHPUnit and PHPDoc would become `suggest` lines, and the Producer would look for them itself, and balk if not findable. Am I getting closer?
I will agree about the Laravel circlejerk. It's rather strong for something that doesn't really need it.
It's actually pretty useful to the community to know who is trying to manipulate content that is shown. This thread is rather useful for that. Beyond that, some of the comments in this thread are a tad bit drama-bait, but so far, /r/php has done a better job of keeping it drama-free. While it sucks that someone is banned when they are trying to help out a community, the rules are there for a reason.
Eh, there will be users for everything. Hell, there are users of my broken ass framework I created three years ago (and haven't updated). Fuck, NASA still uses QCodo ... ugh. But, Laravel users scare me cause, in their opinion, there is no other framework, and they don't want to go out of their comfort zone to learn other ones. In the beginning, Symfony was close to that as well, in my opinion, but at least that framework is modular, so you were free to use other packages with the framework.
For what it's worth, I have /u/dracony tagged as "Annoying Self-Promotion Monkey" through RES. He has nothing of value to say, so it's helped me immensely in ignoring him. That said, I think his behavior is just sad, not necessarily wrong. Vote manipulation? I don't know enough to say with any degree of certainty that he's been giving himself all the upboats, but in all honesty I just don't care. Let the admins figure it out. His hobby framework is mediocre, and his posts are just noise. Not any worse than every other child that walks in screaming "LOOK GUYZ". It's not worth a separate post, and it's not worth getting bent out of shape over. Fuck it. Move on.
Can anyone describe the exact reasons why (not how, but why) people should be using the PCNTL signal detection stuff through pcntl_signal_dispatch() or the ticks version of it? In particular - I have a PHP script running as a background process through SupervisorD. This background script does not have any locks open on databases, or have any other resources that need to be cleaned up on exit. All of it's operations are done via atomic file operations or at least effectively atomic e.g.: * Open tmp file * write data to tmp file * rename() tmp file to actual If I don't have anything to clear up in the application and so I don't mind the default behaviour of CTRL-C exiting the application immediate, is there any reason to listen for PCNTL signals?
But... you can use other packages with Laravel?
Centos is really stable and reasonably free from bug....and all of the libraries available from the default repos are stable and reasonably free from bug. It's not possible to test the Imagick extension with valgrind memory checking enabled on Ubuntu.....it just throws up loads of errors due to bugs in the underlying libraries. The other benefit is that if you have a client who needs to be able to know that someone will support their servers for years to come, you can change to RedHat very easily, and offer the client full paid support through them. I'm not sure I actually recommend Centos though - it's just so slow on getting new versions of stuff. When I next have a good reason to be playing around with OS's, I'll definitely be checking Fedora first....most of the stability, without so much of the downsides. 
^ this guy is next. 
Check out MySQL Workbench or SQL Pro. Far more reliable. Doesn't need to be on websever. Doesn't hang when processing large amounts of data, and it also provides data migration tools.
[removed]
Yes, you can. But the issue is with the users of Laravel, not the framework itself. In my experience, Users of other frameworks (I cited symfony, but Slim and Zend users are the same) tend to be open to using another package in place of a core framework package. However, the inverse seems to be true about Laravel users, where they will defend the core packages, even if you can swap them per PSR standards. In my 17+ years of programming with PHP, I haven't seen so many diehards for a specific framework.
He doesn't just post his own stuff, he comments quite heavily. 
Sorry to be That Guy, but this is anecdotal. Perhaps a survey (of people actually using all these frameworks) would give your argument statistical backing.
congrats! 
I did not admit to anything in the chat. I said that there was no point of having bots to manipulate the votes by 2. Can you people stop making things up?
Great news! This would be a good time to add Libsodium to the core extensions for php 7.1 :)
It is definitely helpful for the /r/PHP mods to know what's going on, and if it becomes clear that the sockpuppeting is hurting the community, it would probably be wise for them (as the people in a position of stewardship over /r/PHP) to make a single thread outlining what's going on, what has been done about it, and giving a clear direction for the moderation team to take in the future. That isn't what's happened, though. /u/AndrewCarterUK has created a thread full of accusations during a time when the people he's accusing will not be able to resond, he's using the fact that admins don't reveal the reasons for bans to further speculation, and he's doing this all in a manner which only drives witchhunting and drama, rather than in a civilised manner.
Classic reddit "drama for the sake of drama". This whole thing just feels completely negative and shitty.
This is great to see. More forward looking security from here on out. Also, this is one of those times that I'm **really** glad that I made [encryption and IV generation an interface](https://github.com/robinpowered/php-ntlm/pull/1) in a project.
This question isn't directly related to PHP but I think you guys would be a good place to ask: How do you guys manage multiple sites on a web server? Currently I have a user (on a debian OS) for each site and the site is in the user's public_html folder and I simply have a nginx site file (I forget the technical name) pointing to that folder. Is there a "standardized" way or is my setup okay? I've seen people have a site stored in `/var/www/somesite.com/` and another in `/var/www/cutekitties.com/`
If it all possible you should NOT be writing signal handling code. While you can listen for SIGINT signals and similar you cannot wait and listen for the user unplugging your machine. You should have a plans and a means for recovering from catastrophic situations like that and not just paper over the problem with badly written signal handlers (even if the solution is just keeping daily backups or similar on a separate partition with a more robust filesystem.)
I'd actually recommend reversing the names of the sites like com.somesite and com.cutekittes so that you can have subdomains like com.cutekitties.test sort nicely in a folder view. One think you can do is set the group permission of the folder to apache (or nginx or whatever), set the setgid bit and then have contents of the folder readable (but not writable) by the group and not readable or writable by other users on the system for a bit of extra security.
I would guess that sockpuppeting is against reddiquette, but you're allowed multiple accounts, so unlike vote manipulation the system can't automatically ban you for it.
It's really a breath of fresh air.
Phixie?
If that's the biggest complaint, I'll consider Producer a gigantic success. ;-) Also, FWIW, it's not "everywhere", it's "in the LICENSE file."
&gt; You can also use the is_finite() function instead of that `in_array()`, which is currently missing `-INF` Also: $ php -r 'var_dump(in_array(NAN, [NAN]));' bool(false) (NAN ≠ NAN in IEEE 754 floating-point arithmetic)
Yes, native extensions are superior to userland "libs".
Sure, but people working in user-land don't care about that. The whole point of a high-level language is that it abstracts away those weird semantics. The [documentation](http://php.net/manual/en/class.divisionbyzeroerror.php) even says "DivisionByZeroError is thrown when an attempt is made to divide a number by zero", which is completely unambiguous. If we're discussing what happens when some float we thought was zero actually floating point errored to not actually be zero, I could see where you're coming from. But the behavior simply doesn't match the documentation for integer math: php &gt; 5/0; PHP Warning: Division by zero in php shell code on line 1 PHP Stack trace: PHP 1. {main}() php shell code:0 Warning: Division by zero in php shell code on line 1 Call Stack: 38.6759 352136 1. {main}() php shell code:0 php &gt; try { 5/0; } catch (DivisionByZeroError $e) { echo 'ex'; } PHP Warning: Division by zero in php shell code on line 1 PHP Stack trace: PHP 1. {main}() php shell code:0 Warning: Division by zero in php shell code on line 1 Call Stack: 118.3590 352432 1. {main}() php shell code:0 vs php &gt; 5%0; PHP Warning: Uncaught DivisionByZeroError: Modulo by zero in php shell code:1 Stack trace: #0 {main} thrown in php shell code on line 1 Warning: Uncaught DivisionByZeroError: Modulo by zero in php shell code:1 Stack trace: #0 {main} thrown in php shell code on line 1 php &gt; try { 5%0; } catch (DivisionByZeroError $e) { echo 'ex'; } ex 
It was running with pm set to dynamic. I changed it to static with pm.max_children=110, now I see 111 php-fpm processes immediately after start, but I don't notice a difference in response time or req/s.
&gt; Sure, but people working in user-land don't care about that. The whole point of a high-level language is that it abstracts away those weird semantics. Maybe if PHP had a single number type. But it doesn't. It has two, and they work quite differently. We shouldn't hide this from our users when the difference matters. &gt; But the behavior simply doesn't match the documentation for integer math: `/` is really a float operator, not an integer one. It gives you `float(1.5)` for `3/2`, not `int(1)`.
Do you have OPcache turned on?
Okay, fair enough. The daemons I have written are typically bridged in some way to my application.
I don't see how being able to explicitly select the algorithm (which should definitely be allowed) should require you to select the backend implementation of the algorithm. The FIPS thing is an interesting point, but I don't think that use-case should force *all* users to explicitly say which backend to use: it's just another thing to get wrong. IMO the APIs should implicitly use whatever is best-practices preferred *unless otherwise specified*. e.g. $crypto = new Crypto\Symmetric(); // $encryptor-&gt;setBackend(Crypto\BACKEND_OPENSSL); &lt;-- optional $cypher = $crypto-&gt;encrypt($plaintext, $key); // or $alg = Crypto\Symmetric\ALGORITHM_AES256GCM; $cypher = $crypto-&gt;encrypt($plaintext, $key, $alg); (excuse the random choices and names, just to get a point across) If that's already the plan and it *is* optional, then disregard everything I've said. As a corollary, consider the fact that you need to explicitly pass `PASSWORD_DEFAULT` to `password_hash($password, $alg);`. It's a default, and should be implicit - or should be named something else. As an end-user, it's just weird - and that's coming from someone that prefers being explicit over implicit in code.
&gt; Except when it's not: Yeah, it gives you an integer result in a few cases. It's a bit like the other number operators that way. It prefers floats, though. &gt; I get where you're coming from, but I think you're maybe somewhat blinded by your deep history with and knowledge of PHP's internals. In terms of pure semantics, you're absolutely correct, but that's just not what the vast majority of users will expect. It is somewhat unintuitive. Unfortunately there's not a lot that can be done about the mess that is PHP's division operations now, though.
[removed]
The way he has responded to this post (yet more sockpuppets and dishonesty) is pretty telling. I have zero doubt that when his ban is up he's going to continue spamming posts about his framework and manipulating the votes (probably less subtly this time, but you never know). At least now people will be wise to it. He's also not a baby, he's a voting FIG member that should hold himself to higher standards.
Can you post both versions of your configurations? There shouldn't be that much of a difference.
For an empty array, or array where both keys and values are specified, or an array that spans several lines, I would suggest using array(). For a simple list, the shorthand notation is good enough. $a = [1, 2, 3, 4]; $b = array(); $c = array( 'foobar' =&gt; 'baz', 'fizz' =&gt; 'buzz', );
[removed]
keep chugging, and don't stop!
Benchmarking any language for web use is more complicated than how many requests you can fulfill with a single user. The problem becomes how much memory and CPU you're using to get that 10,000, compared to the 5,000. Apache by itself is all over the place in resource usage. Lookup some configs with PHP-FPM set to 'ondemand'. PHP7.0-FPM is a suggested option, too. ^nginx ^is ^cool
I currently use Chase Orbital with Omnipay. I'm using a private fork of this repo: https://github.com/twg/omnipay-paymentech-orbital Be warned, that repo has a bug (check the Issues tab). It will say a payment was successful when it actually failed. It's fairly basic in what it supports though, but was sufficient for my needs.
&gt;The whole point of a high-level language is that it abstracts away those weird semantics. PHP is not a high-level language. It's a layer around C, with varying levels of thickness. 
Please post both apache, nginx and php configs for each test...
Then why didn't you?
I added the configs.
Wow, glad to see you're still working on this project. Hope it grows to be big!
Nice package!
It's definately something to add. Thanks for the feedback. :) https://github.com/AyeAyeApi/Api/issues/30
pretty much yes. I'm running a $30 android hdmi stick with lamp on it. So I can confirm it works. 
Well, it seems you have only a hello world application, thus the high req/s. What you then basically benchmark is the communication nginx-&gt;php-fpm (tcp or unix sockets). Since apache held the interpreter in their context they don't need tcp connections and thus faster. I made the same experiences that mod_php, correctly configured outperforms PHP-FPM for small/already-fast applications. So I don't think PHP-FPM is generally faster than mod_php - wouldn't make sense since mod_php has less overhead, which results almost always in faster applications.
Thank you! There's much still to do, but getting there.
It's currently *intended* for "library" packages. I have not tried it on "project" packages, and while I expect it might be fine for at least some of them, I can't say one way or or the other.
I've figured it out. Your problem is that you're using a tiny test script. Look at those timings: 9ms, 12ms, 17ms. That difference is too small to matter in practice, and it's probably a fixed cost. I would guess that if you had a script that took 100ms, FPM might still take 8ms longer to execute it. But that's a much smaller percentage difference.
What's your favorite cloud coding environment? [EDITED for formatting;\] I'm thinking like Codeanywhere. I would like to have an environment where I can quickly create test/throw away code to experiment with. My code quickly gets polluted with trials, tests, experiments, etc. which makes it really difficult to commit consistent code for production. Some specifics I would like: * php aware * Zend_Framework (1 and 2) aware (in the IDE) * MySQL ready Does anybody have any advice on what they like to use? Thanks! Blue 
This is not a LAMP server, just LP
All that you say is correct, however, OP may still have something not configured optimally. My usually testing usually shows a smaller difference. Usually close to ~9-10% slowdown (there might be a few outliers showing 20%). OP's FPM is only running at 52.4% the speed of mod_php. That's 48% slower, isn't it? 8ms is a pretty big difference for a request that takes 17ms total.
Good read. I'm actually using a self-built database wrapper in an application I'm building, and this made me realize a security flaw regarding named placeholders (which is now fixed, I automatically generate named placeholders now).
Which one? I'm kinda curious to mess with one.
The website overlaid a huge blue overlay almost right away, severely hampering user experience. The button to dismiss it, was a *tiny* little text link, arrogantly saying "No thanks, I'd rather not hire the best". Yeah, go fuck yourself toptotal.
which Android HDMI stick
1. Authenticating a JWT token requires access to the secret key. 2. Using JWT tokens frees you from having to use sessions. You submit the bearer token in a HTTP header. I would revise you authorization and authentication flows with someone who knows your business requirements so that you can map your user flows correctly. With that, you can validate your assumptions versus Firebase API.
I'm working on a project that doesn't use MySQL (yet). Will eventually support both. But we're starting with PostgreSQL.
&gt; i cannot say i would want to run composer update on any of my project packages I am genuinely surprised by this. Of curiosity, for a *library* package, why would you not want to run `composer install` or `composer update` prior to running the tests?
I think this gets on sale a few times a year: https://play.google.com/store/apps/details?id=com.icecoldapps.serversultimatepro&amp;hl=en Hmm doesn't seem to have Apache.
&gt; My code quickly gets polluted with trials, tests, experiments, etc. which makes it really difficult to commit consistent code for production. Do you mean you're making test standalone apps or you doing test/experiments in an existing app? If it's the former, I make a "sandbox" project for small experiments. If it's the latter, you could use branches for those types of experiments within a project.
I added a usleep(100000) to the script and the results are interesting: Apache + Mod_php: * Requests per second: 981.56 [#/sec] (mean) * Time per request: 101.879 [ms] (mean) Nginx + PHP-FPM: * Requests per second: 969.83 [#/sec] (mean) * Time per request: 103.111 [ms] (mean) So a 8 ms (17 vs 9 ms) difference became a 2 ms (103 vs 101) difference. So the difference is smaller, relative and absolute.
I think you are correct.
You are right, check the results in https://www.reddit.com/r/PHP/comments/4bi9a4/why_is_mod_php_faster_than_phpfpm/d1as9n4 when I added a 100ms delay.
This repository has a Todo list in Django and Laravel, so maybe you can compare them: https://github.com/komarserjio/notejam?files=1
To practice anything in programming you have to make projects. Build a website that uses OOP and ask for reviews so people can help you get better 
This doesn't answer my question though. These articles say nothing on why they couldn't just upgrade the mysql extension...
Hi there, Two things: - PHP the right way is an awesome resource. http://www.phptherightway.com/ - Some people _love_ Laravel, while some other people think it's a pile over over-rated `::static` poo, that promotes bad coding standards, and is basically a one-man show. I'm going to let you make up your mind yourself, but please also take a look at other frameworks, like [Symfony](http://symfony.com).
non-library projects. They should not run `composer update` during validation/release
You can also read http://taylorotwell.com/response-dont-use-facades/ as the response to those who find the static classes are bad. But it's always a good idea to try out a couple frameworks and see what is available!
Looking at ext/mysql and ext/mysqli, it would not have been sensibly possible to simply replace ext/mysql with ext/mysqli due to the backwards compatibility breaks introduced or compromising the design of ext/mysqli. If memory serves, ext/mysqli was also written to take advantage of changes and new features made available in MySQL 4.1+ and may not have ever worked against MySQL 3.x versions, which were quite possibly still in widespread use at the time. The PHP language developers also try to balance backwards compatibility breaks against changes to the language. Instead of breaking existing code with the release of 5.0, they chose to allow PHP 4 code written against ext/mysql to run with minimal (if any) changes and users ended up with the entire 5.x series to upgrade their code.
Both? I suspect there will be some crazies that want an inbetween solution. The former would solve my problem, but configuration would add some niceties to the project (disabling/enable other validations and the like)
Why do you think?
That looks like a great resource for very specific/individual code snippets. Can you recommend a place that would review a complete project hosted on github? I have a PHP ecommerce project hosted on github. I'm looking for both positive and negative feedback. That would be incredibly helpful to make sure I'm on the right path following the SOLID principles, OOP practices, and appropriate design patterns. https://github.com/inklabs/kommerce-core
php.ini changes won't take effect until restarting. You should probably contact your web host with this issue.
i did seven days ago...
Get a new web host, then.
I really like [cloud 9](c9.io). It doesn't have PHP intellisense so it isn't going to be Zend framework aware. It is possible to write plugins for the editor so you could theoretically make it happen. I don't know of any cloud IDEs with PHP intellisense.
I would except a link for the talk
No video unfortunately! :( Anyway here's a post I wrote few months before that has a lot more details and links: http://loige.co/6-rules-of-thumb-to-build-blazing-fast-web-applications/
You can also run a full version of Linux. 
&gt; Should I work on upgrading PHP just to get the password_* function? No need! The guy who wrote the `password_*` functions provides this library for prior PHP versions: https://github.com/ircmaxell/password_compat
I'm working on a new application and this is basically how I organized things. Simple separation of concerns: one code base for the interface, another for the API. What frameworks are used for either are entirely preferential since one should not have any bearing on the other.
To clarify, just in case, you need to restart the web server process, not the physical machine. That means restart apache, or whatever your web server is. You may have the ability to do this in your control panel. 
I'm a thinking person.
A lot of devs set up a portable local wiki. Dokuwiki is a great platform for that.
[removed]
Are there any frameworks being built strictly with PHP7 in mind right now?
PHPeeps!
I've checked all the settings and see panel and could not find a way to do that. I is there a way I could command line in and do that? It's a red hat distro of Lenix.
Probably unlikely you'll have the permissions, but if you have root access, the command is probably /etc/init.d/httpd restart Or apache2 instead of httpd 
GitHub interprets markdown by default, so I just create a `docs/` directory in the repo and create `.md` files within, then link to them from the `README.md`
+1 to homebrew and NOT macports
Interesting. Any benefits to this that anyone can think of?
We mainly use Git with Gitlab (a local installation). For every project we use `Readme.md` as the main documentation. If for any reason if we need more support files, assets or even secondary `.md` files explaining things - they all go in a `/documents` folder inside the project and with hyperlinks in main read me file.
You have to figure out where you are before you can find a path out of the forest. Do a code inventory even if you just get a list of classes and their features, it's a starting point. From there you can determine the refactor approach. 
Add the Dyn app to the stack and you can have a domain pointed to your phone. Them you can access it from anywhere.
I'm a big fan of including documentation with the code; otherwise it doesn't get updated when the code changes. A very lightweight solution with GitHub is to just have markdown files, since it will render them nicely. Other than that, sphinx through Read the Docs is pretty standard.
That's how PHP development works. They just another complexity layer instead of replacing the current ones.
"A configuration option was deployed 11 hours ago enforcing HTTPS connections to remote repositories by default, as HTTP repositories are sensitive to MITM attacks injecting malicious code."
[removed]
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Yup - looks very much like Wikipedia with "vector template". Can only recommend it..
&gt;I hate both a) having to run phpdoc myself to have any useful documentation Why do you need to do this? Your ide should provide phpdoc or better documentation on the fly. If you're meaning non api documentation then readme.md is by far the easiest. Aim for minimal too as it's hard to keep your code in sync if actively developing.
I see the templates don't include cron in all of this. Doesn't php rely on cronjobs in order to clean the old sessions? Also, setting cronjobs is really a common practice for many php-based solutions.
Not everyone uses an IDE, so doing nothing other than docblocks and assuuming it will magically show up somewhere isn't exactly user-friendly.
JPEGmini described their technology here: http://www.jpegmini.com/main/technology and someone did a comparisom using them and Google photo service here: http://petapixel.com/2015/05/30/jpeg-compression-test-google-photos-vs-jpegmini/ Seems like JPEGmini is a sound product, there are many out there. I hadn't seen it before. The DYI of this is to use imagejpeg() and apply post processing tools for *lossless compression* and *lossy compression* of the images. There are several tools to use. I use jpegtran for lossless compression. You will then end up in comparable files sizes and qualities. Here is [mos/cimage](https://github.com/mosbth/cimage) doing it using PHP and jpegtran and here is another way [using bash command line](https://github.com/cimage/optimize-images/blob/master/optimg.bash) tools.
In my code. I do good doc-blocks.
You can always argue that "but xx is yy's responsibility". But as long as the job is aware of your skill set (e.g things will take longer if you do it), why not do it? It's a great way to branch out and learn new things.
I clicked with rather a skeptical feeling, due to all these awful articles "25 stupid things to speed up", but was hugely surprised to find such a sane set of tips. Only fifth one is slightly off the line to my taste (obviously useful but too localized compared to others), but the rest is just superior. 
Why not just have a local git repo matching production and use FTP with a simple sync function based on file time? FTP can preserve the timestamp.
cause apparently people like you still visit that page :p
Thanks for the recommendation :)
And they used [`preg_split`](http://php.net/preg_split) which I imagine is a lot slower than just using [`str_word_count`](http://php.net/str_word_count) edit: ah they're actually keeping count of all occurences of each word, so that wouldn't work. edit2: I did get 20% better performance by using `isset()` instead of `array_key_exists()`, made a PR for it.
Btw while you are of course right about microbenchmarks not being representative of the performance of entire applications, Peachpie's architecture is designed in such a way that it will be very easy to optimize everything over time, including entire applications like WP. This wasn't possible with Phalanger, but is now possible thanks to the implementation of Roslyn. This is not to say that all aspects will perform as well as the Pi calculation compared to PHP, but the same way that we optimized the Leibniz computation will apply for the entire program. In theory this would suggest that Peachpie can yield quite significant performance benefits across entire applications.
Well from what I have seen progression is usually this. 1) Junior: You are new and don't know much about the ecosystem, you are eager to produce so you end up writing all the code you need. 2) Mid: You are a bit jaded by realizing that you wrote a lot of code when you could have used a package manager. You are really good at finding the base code you need via a package manager and you are good at evaluating the health of that package. 3) Senior: You write small packages that solve problems for others. You connect pieces together easily and you understand the best practices of creating large solutions. You can weigh the pro's and cons on design decisions. 4) Super Star: You have written a widely used package, you are likely under the #3 category, but people idolize you for producing something that did not exist before. You are likely managing other people's code. You may or may not still contribute to your golden egg, but more than likely you manage other people's contributions. 
No cron, but nothing stops you from adding it on top of the container itself. If I were to make a recommendation, your app should be completely stateless and not rely on local storage for anything other than containing your code, plus the runtime to make it work. Storing sessions elsewhere, like Redis or Memcached is probably a much better choice which also takes care of not requiring sticky sessions when you're load balancing. Have a look at http://12factor.net/
It would be awesome if you could realize these kinds of improvements (or, really, 1.5x better instead of 5x would already be impressive) on real application code, but I'm somewhat skeptical. One data point is HHVM, which is something like 30% faster than PHP7 in their most aggressive optimization mode (precompiled repo) and likely already performs at least some of the optimization approaches you have in mind (if you have anything written down about what you're planning to do, would be very interesting to see :) Your Leibniz Pi computation example is a real treasure trove for optimization (thank you for that btw, I think it's a great example for illustration). Type inference is able to determine all variable types statically. Constant propagation will eliminate `$top` and reassociation will eliminate the negation (assuming round-to-nearest floating point mode). If you unroll the loop to any power of two, constant propagation (at least any optimistic algorithm) will eliminate the `$minus` variable, thus removing all inner-loop branches. Add a JIT to that and it's pretty much all one can dream for. Real PHP code doesn't tend to be so friendly for compilers. Static type inference is not very effective, though presumably you plan to use runtime type information. Integer and double operations, which are the ones that benefit most from unboxing, are only of secondary importance. There do not tend to be tight loops which can multiply optimization effects. And of course a non-trivial chunk of the runtime will be unoptimizable IO operations. I do hope you'll be able to make it work though. A ground-up design of a new architecture will allow you to escape some of the trappings others have imposed on themselves. E.g. probably the most important problem in the Zend PHP implementation is that compilation happens strictly per-file due to the way the opcode cache works. Dropping that restriction alone is worth so much (otherwise you don't even know function signatures and have to assume references all over the place).
I find myself in the same boat. New greenfield systems come along more quickly these days, and are a flurry of new code. The most actual code I've written comes from a library, [`garethp/php-ews`](https://github.com/Garethp/php-ews) I wrote solely because there were no existing decent alternatives. It started off as a fork, but ended up being a complete rewrite because of the quality of the original package... Most of my problems these days are either * Hard to track bugs - These take a long time in the tracking stage and are usually only a few lines to fix * Easy to track bugs - Quick to find, quick to fix * New features - These tend to require a fair bit of planning and research to make sure that we implement them properly and aren't simply adding to technical debt. There's some architecture, some designing, some future planning and so on. It doesn't take too long, but it's generally much longer than the actual coding part * New projects - These are fun. Start thinking, continue thinking as you start prototyping and then start with the first version. But you end up rewriting your code a lot as you get a better idea of how the project is coming along So in short, in all of the tasks to be done, most of it comes down to careful planning and consideration. And, on top of that, you just get faster at coding. You become more comfortable with your tools, your set up, your libraries and any components you might use. You've done most things before in one way or another. As you move on in your career, you find that the same code takes much less time to actually do. But in turn, you've seen much more bad code after it's built, when you're maintaining, so you focus more on making sure your code doesn't become someone elses nightmare.
Some improvements: * `isset()` instead of `array_key_exists()` (as mentioned by /u/mythix_dnb) * Use `PREG_SPLIT_NO_EMPTY` in `preg_split()` to remove a branch in the subsequent `foreach` * Remove explicit `(string)` cast, since the data will always be strings anyway * And most importantly, use output buffering (with `ob_start()`) before the final `foreach` loop
Referring to [this](http://stackoverflow.com/questions/8506070/is-curlopt-userpwd-data-is-safe-while-transmitted-over-ssl) SO answer, BASIC Auth is over all not secure protocol, as it transmits the password in plaintext. **However**, since all data will be going via HTTPS, the request should be encrypted and secure. I would recommend anything but Basic Auth quite frankly, but it shouldn't be too bad as long as you disallow any non-ssl traffic
&gt; I think suggesting that the keyword be reused is probably harmful to the chances of the RFC passing ... I think, I would vote against it's reuse in future ... Why? There are some reasonable uses of `var` that have no potential for confusion with the existing feature. For example, using a `var` prefix for the declaration of local variables with certain additional semantics (e.g. being block local or being statically inferred-type or whatever). Not saying that we should do something like that, but it seems like a reasonable application that would otherwise require us to reserve a new keyword, instead of just reusing something that is already reserved.
I've always wanted to enforce this at work. Being able to see if the docs are updated in a pull request is awesome.
Why reserve this keyword for future use if it is removed as a keyword? I dont understand, and as Joe Watkins is suggesting, this may be the downfall of RFC as more people will likely to vote no. 
I've gone a week - more than once - where I've only written 50 lines of code. Granted, I was learning a new platform written in a new framework, but it was still very frustrating. What exactly is the problem you're asking about? Is it not better to plan more and write code better the first time? I say, if you're company is happy with your performance you're doing fine.
phpfiles can be included and read by php without actually making the file accessable, you can lock it with .htaccess
I think you mistake what "breaking backwards compatibility" means. Backwards compatibility means that you can use an updated version and it'll work with your older code (in essence). That's to say, they *did maintain backwards compatibility* and simply maintained the MySQL interface until it was deprecated. MySQLi is simply a totally different tool. Don't like it? Use MySQL interface instead (to your own peril ;).
Well tbh im looking at ways to improve on that area, with tools, techniques or other methods.. F.e. i can sometimes re-draw a certain scheme multiple times, and still not be happy about the plan.. And the main reason for that is not even because its a vague subject, but because i feel like im not doing it right
I'm having a very similar experiences with scrum in my current team at the moment. We've got that one person who fortunately pushes the team to stick to the rules/philosophy. We often see ourselves doing other urgent support/fixing aside the current sprint and often have to explain why certain stories weren't finished at times. Even though there's a bunch of organizing and research overhead it still beats the lone-warriors we had before. Yeah I guess side-projects would be the best alternative to do some decent coding, although it can require some discipline putting in an hour or two after/before work.
Well, maybe by the time 2019 comes, I won't care ... but today ... In 1999 (or 2015, if you like) ```var``` meant ... In 2019 ```var``` meant ... I just, can't cope with that ... has it ever happened before ? Even if it has, I see no good reason for us to do that ... Sure, there are reasonable uses for it, but other words would also be suitable, arguably more suitable. ```local``` is more suitable, and ```let``` is more recognizably standard, for block [or] local variables, ```auto``` is more suitable for automatic type inference ... what about ```let auto``` ? Using ```var``` can only happen one time ... and I think, it already happened. We could use it again, but it would only be once ... you just came up with two uses for it off the top of your head. Adding reserved words is probably unavoidable (while we have that limitation), we don't need to use leftovers from history ...
link?
It sounds to me the whole "slowness" is only down to Drupal 8 being a few ms slower then 7. Theres no need for people who ACTUALLY use this software to worry. If it was down to seconds to load a page I would be like "drupal you have some shit to fix"
I've been recently investigating the generically-named [Vault](https://www.vaultproject.io/) for a secrets management system; it seems pretty slick. It's got Shamir's Shared Secrets support for the initial decryption process, a variety of storage backends (several of which offer HA), support for temporary credentials for AWS and several popular databases, and a sane API that should be easy to integrate into everything. It might be a bit overkill if you're running a one-machine type of site, though.
&gt; but an IT guy that works for one of my clients showed me an image sharing service where you upload an image and have to scan a QR code to see that image online You just described an image sharing service which uses QR codes to decode the urls. Propably because manually typing the overly-complicated urls could be frustrating for mobile users. https://github.com/endroid/QrCode
Fair enough. My company has somewhat standardized it and it comes with alot of our boilerplates now. Most of the markdown never gets more complicated than headers, lists, and code.
The best answer would be to have a review with your team (even after the project is done) but that's not always available either because of time or culture. I think it's we all have to deal with. 
&gt; In 1999 (or 2015, if you like) var meant ... In 2019 var meant ... &gt; &gt; I just, can't cope with that ... has it ever happened before ? Of course it has happened before. Keywords are being reused all the time. You don't introduce a new keyword if you can conceivably reuse an existing one. Example in PHP: `use` is used for namespace alias handling, it is used for importing traits and it is used for binding closure variables. `as` similarly is used during namespace alias handling, but also for trait conflict resolution and for foreach. Are these confusing? I don't think so. And these are cases where the keyword is used in different places at the same time! The scoping was an example. I'm not saying that's the best way to do it, but it's a *reasonable* way that should not unnecessarily be complicated by unreserving a keyword without any other incentive to do so. Using `let`+`var` as a combination for immutable and mutable lexically scoped variables is a reasonable choice that has precedent in various other languages (e.g. Swift). Using `const`+`let` instead or `let` and `let mut` are also possibilities and at this point I would not assign any of them a preference. However I absolutely do not see why we should unreserve the var keyword if we may conceivably use it in the future, it costs us nothing to keep it reserved, but it *would* cost us something (BC breakage, at least formally) to reserve it again in the future.
Another one to add might be https://github.com/ICanBoogie/Inflector
Great summary, thanks for that! You are right. The new architecture allows us to integrate additional analysis cleanly and our experience with Phalanger helps with avoiding common mistakes. .NET JIT besides other things provides constant propagation and inlining out of the box. (and Mono Jitter provides even more hardcore optimizations) The script inclusion and classes and functions declarations were redesigned to avoid looking into tables in runtime. The idea is to call a function statically even if it is in another file and only check the containing file was marked as included. Together with type analysis, we expect 75% of function/method calls will be direct. In beginnings there will be limitations (like hhvm had) but they all can be solved in future.
It's exactly what the RFC to remove PHP4-style constructors is doing: https://wiki.php.net/rfc/remove_php4_constructors
[Here's an article using travis ci](https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example). It will vary a bit depending on your CI provider and your build steps.
It's always been like that. The big names in programming before I was (and possibly you were) ever born were saying good programming is mostly not just churning out code. Things like high-level design, considering naming and testing are all places you can quite easily end up spending more time than writing fresh code. A programmer types characters out into a source file, sure, but that's just formally recording the real work you did, which is conceptualizing the whole system and each part of it. If you write a function and couldn't rewrite it from scratch faster (and preferably better) odds are you don't exactly understand what you did, you just sort of blindly felt your way through to a (hopefully) correct solution.
Thank you guys for your feedback!
The author somewhat forgot that composer can dump the autoloader and optimize it. https://getcomposer.org/doc/03-cli.md#dump-autoload
I just commented here: https://www.reddit.com/r/PHP/comments/4bre0k/rfcvote_var_deprecation/d1c2cvr
You can also do stuff you are technically not supposed to do like name your variables with numbers and simple expressions using curly braces like this: https://3v4l.org/hV3sV
Looks like voting has been closed to address a few issues: http://news.php.net/php.internals/91914
Well, it's always a risk to depend on 3rd party software. Not so much for huge community driven projects but using packages from almost unknown maintainers is always a risk. What you can do is to fork repositories and require your fork to be safe but that would require manual updates as new versions appear.
Deleting popular repositories is intentionally disabled - see this comment from 2014: https://github.com/composer/packagist/issues/115#issuecomment-37274264 &gt; It is possible to delete a package when it has only a few downloads (I don't remember the threshold). For packages with a lot of downloads, there is no button to delete it to avoid mistakes affecting lots of people Instead, maintainers would use the "abandon" button to mark the package as deprecated. Now it could be possible for the maintainer to delete their repository from Github, but the Composer cache and Toran Proxy can mitigate that damage. Because repositories cannot be deleted, they therefore cannot be hijacked in the same way. Additionally, Packagist will reserve namespaces, preventing other people from releasing packages under a name/organization they really aren't.
I usually create a file called `config.sample.php` where use `define()` to set constants for dummy credentials. After that I create a copy it as `config.php` with the real credentials in it, different on dev, staging and production environments. I always add `config.php` to `.gitignore` so I don't store sensitive data in version control.
If you want a real performance boost, just replace the algorithm with a sane approach. They build an array and then turn around and copy it, item by item, into another array.
14/9 looking good 
As /u/colinodell already mentioned, deleting packages from Packagist is disabled after a package hits a certain threshold of downloads ([100 according to the source](https://github.com/composer/packagist/blob/3ba5d93e1bfa625702e0bcf75e56e5269449eb6b/src/Packagist/WebBundle/Controller/PackageController.php#L1062-L1064)), which allows for the removal of mistakenly published packages without allowing for the removal of packages that are depended on in mass. Unfortunately, Packagist is just a package registry, and therefore it relies on the VCS or distribution URLs to exist in order for a tool (like Composer) to actually fetch and install the package. So, if a user were to delete their GitHub repo, there would be a problem. Thankfully, /u/seldaek has designed Composer very well, and has thought of this problem already, so he's created a tool called ["Satis"](https://github.com/composer/satis) to circumvent this and other related issues (private package hosting, etc). Satis is wonderful, but it's not necessarily the most user-friendly tool to host for larger organizations, so he's done one better and even created a "Satis as a Service" called ["Toran Proxy"](https://toranproxy.com/). What Satis/Toran-Proxy allow you to do, though, is create a mirror/proxy to the GitHub repositories that you depend on, while also allowing you to list packages in a private manner without having to publish them on Packagist (great for private, internal, but often shared packages). Creating a mirror in this way allows you to prevent installing malicious packages due to hijacking, along with improving the speed and reliability of your builds as you won't have to worry about GitHub rate limiting (or uptime) and the like. Finally, Composer's `composer.json` schema-file allow you to define alternative repositories so that you can re-point your package download resolving to another location. All-in-all, Composer has the abilities to prevent the issues you mention quite well. Unfortunately, however, Composer can only give you the ability to prevent these issues, it can't do it for you. So, if these recent NPM happenings scare/bother you, I suggest setting up Satis in your company/organization or using the aforementioned Toran Proxy service. Toran Proxy costs money, but I like to think that the money goes to supporting Composer and the open source PHP community. :) For more information on Satis and Toran Proxy, see Jordi's blog post: https://seld.be/notes/toran-proxy-and-the-future-of-composer Edit: Added link to Jordi's Toran Proxy blog post.
actually, That gives errors on HHVM and unsopported PHP versions. the emojis seem to work everywhere. 
That's very kind of you.
/u/SavishSalacious here it is Http://ottoproject.io 😉 Edit: fix url
Good to know! Any problems you've had with it, anything strange or unexpected?
We've been trying to standardise the language for years. I'm in favour of one, canonical way of declaring a public variable. And because of people like yourself, the only way I can see that happening is deprecation and removal.
You could setup Toran Proxy to pre-cache all new tags of a package - that way you'd have all versions of a package in case the original went down or if Github was unavailable
i second that... i have been building full zip files with the vendor folder for each of my releases and keep those in a separate repo
I thought pear is now a [1.5 man show](http://blog.pear.php.net/2015/12/11/server-fully-restored/).
&gt; ... as you won't have to worry about GitHub rate limiting (or uptime) and the like. As an aside, the rate limiting has been disabled two weeks ago: https://github.com/composer/composer/issues/4884#issuecomment-195229989
Damn, that may be the first time I've seen voting go one way in favor of something.
It depends on where you are in your career. Young developers are very much busy learning the "craft" which means that they constantly want to reinvent the wheel. Which in a way is a good thing, this is not only shows you how things are build but every once in a while something better is actually built. However, junior developers without good mentors can also destroy businesses in that they are primarily focused on solving "programming problems", not "business problems" through programming. A good example, a not so experienced developer is asked for a solution to a problem and they will suggest such and such framework would be really good. Often this is not true and the only reason for suggesting it is that the developer really would like to tinker with such and such framework. As you get older and wiser you will (hopefully) get more interested in solving business problems through the use of technology. Most developers mellow out and become less militant about technologies and tabs vs spaces. You will begin to focus more on architecture, software design and maintainability. You will learn that the code that's written is only an expression of the problem you're trying to solve and, most importantly, that failing to plan is planning to fail. 
you are right ... the thing is my senior only do php and refuse to do other parts he will ask fortend guys to do it and my boss ok with that ! so am i doing the wrong thing or he is doing the wrong thing I'm confused !!
Edit: Since the link explicitly said what I typed, basically the appeal is so when say you're writing form validation for a config manager and you're dealing with say 20 items in a form which need default values before saving to the config file if they don't exist, etc... it's quicker than retyping the same array variable when doing the check. It can get a little tedious when dealing w/ tons of array data so a shortcut operator is a nice solution for a simple problem.
I would store the passwords in environment variables in the vhost config, then unset them in PHP as soon as they're no longer needed. It feels safer than storing them in a PHP readable file.
Yeah. I hadn't looked at the original diff. I have a new version up https://github.com/php/php-src/compare/master...sgolemon:short-ternary.coalesce which should cover the bases. Assuming things look good, voting should be able to reopen in a couple weeks. (There's no rush)
explode and implode
oh I'm going to commit soooooo many poop emojis at work tomorrow. they won't know what hit them.
Yup. 𝄞 [_Do you want to build a snowman?_](https://github.com/borkweb/snowman-builder) �
If performance is very important, Drupal was never the right option anyway. 
Good thing I don't use it
http://ottoproject.com/ resolves to a _for-sale_ domain currently owned by GoDaddy; you probably meant to link to the official website hosted at https://www.ottoproject.io/
Thanks for the detailed info! I will look into those. Good to know that it is a quality product! :)
I've always liked the idea of using SSS for this stuff, but it seems like a huge amount of overhead unless you're supporting single-person decryption. Makes sense for PCI compliance and such, but a huge headache operationally. 
I feel like there isn't much reason not to add it.
I know that, but its contradictory with the official solution in debian php environments, which introduces a cronjob in order to not leak the default server sessions. Maybe that should be clearly and explicitly documented on that page, that users should rely on Redis or Memcached for storing sessions, if they don't want to get some unexpected memory leak. Anyway, the problem of wanting to have running cronjobs in this kind of setup is a very legit concern. Precisely at this very moment, in my company we are exploring a solution to this requirement by introducing another container only for cronjobs, and the issue there is that the Vixie Cron is really coupled with syslog/mailer services when it comes to give some system level feedback, so containers have to be "fat", or alternatively, we are exploring other more sophisticated cron-like tools like fcron, but we just started the research about this yesterday.