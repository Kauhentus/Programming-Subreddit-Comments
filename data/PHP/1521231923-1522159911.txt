We are approaching a small to medium sized ecommerce project and we are planning to use Sylius in cooperation with Kunstmaan Bundles CMS. Both are symfony based and we have a decent experience with the latter -- you can basically code it like any other symfony application and replce any part of the system on various levels (via the container, plugins, events, etc)
"Modern PHP" by Josh Lockhart is a great starting point into the world of modern PHP development, I've also enjoyed reading through "PHP Objects, patterns and practices". Also check out Laracast.com and CodeCourse.com 
&gt; 1. what features sets one apart from the other? They were all created in different environments, and a number of the decisions their creators took reflect particular goals. Phan [requires a PHP extension](https://github.com/phan/phan/blob/ca7ac2f29951d7b4b2afa7c0b2f45dd36561d592/composer.json#L26) `php-ast` to run. That also limits its analysis, since `php-ast` doesn't recognise docblocks on regular statements, and stores less ancillary information than PHP Parser (a pure-PHP AST generator written by the same author). Nevertheless its current maintainer (https://github.com/TysonAndre) has done great work to improve it, and it has support for the Language Server Protocol so as to provide better IDE integration. Also, when Phan was created it wouldn't warn when calling a method on an object of type `A|B` if the method existed just on `A`. This may have since changed. PhpStan is by far the most popular of the three. It has support for explicit docblock intersection types (Psalm can infer intersection types but doesn't suppport them in docblocks yet). It's greatest weakness currently is an over-reliance on reflection - if any file in your project has an issue which causes a fatal error when autoloading it, the analyse step crashes. It also has a few architectural problems (for example it cannot correctly analyse assertions made in `if` statement conditionals, nor does it analyse loops well). Psalm is my creation, so obviously I'm terribly biased. It has a deeper understanding of arrays, keeping track of array keys where possible. It can be configured to warn whenever it cannot safely infer a type, which leads to much more tightly-controlled codebases. It's better at inferring types than either of the two packages, and it's more strict, so it catches more issues (which you can choose to suppress). It catches a bunch of logical issues with your code that neither package will find. 2. Absolutely complementary. You can use all of them together and see which fits your development style the most, then discard whichever ones don't fit. 3. Have a look at the self-check configs for [Phan](https://github.com/phan/phan/blob/master/.phan/config.php), [PhpStan](https://github.com/phpstan/phpstan/blob/master/conf/config.neon) and [Psalm](https://github.com/vimeo/psalm/blob/master/psalm.xml). They each take very different approaches to configuration – you may favour one, but you probably shouldn't let that sway you.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [phan/phan/.../**config.php** (master → ca7ac2f)](https://github.com/phan/phan/blob/ca7ac2f29951d7b4b2afa7c0b2f45dd36561d592/.phan/config.php) * [phpstan/phpstan/.../**config.neon** (master → 3485d8c)](https://github.com/phpstan/phpstan/blob/3485d8ce8c64a6becf6cc60f268d051af6ff7ceb/conf/config.neon) * [vimeo/psalm/.../**psalm.xml** (master → f806e16)](https://github.com/vimeo/psalm/blob/f806e16c10351fe05ca1181107ebcb88f7d0ed1c/psalm.xml) ---- 
Container should stay away from high level code with application functionality (including common controller-factory mix), but it's pretty harmless in composition root or "main partition" as Uncle Bob called it. That's where you decide on concretions within object's body anyway (factories) - adding some container flexibility there shouldn't be a problem untill your definitions remain explicit and easy to follow (as in example given by u/meandthebean) There's a danger of overloading main container with use-case specific constructs - making it too big to comprehend. Stay with container aware use-case factories unless you need it for runtime flexibility (some plug-in system). In that case I suggest splitting containers into use-case specific ones that decorate main container right after routing phase.
I'm just repeating what the creator of PHP-PM himself said.
I just want to say thank you for this post. I am junior full stack dev who uses mostly Magento and Laravel. About two weeks ago, my boss dropped on me a Drupal project, which was a work in progress. The colleague who worked on it gave up and quit. In the last couple of days, I've been contemplating the same idea. It feels clogged with too much stuff out of the box. Bonus: the documentation on their website is ****** incomplete and I'm stuck. It's nice to see that I'm not the only one who sees this platfrom as a ancient, bulky, and weird system. Thanks guys, you made me feel better.
Hello! Thank you for stepping in! That page is a Google Group, you probably have to log in with a Google account to reply from the web interface. Otherwise, you can reach the PHP-FIG in many other ways, like Twitter: https://twitter.com/phpfig
Full disclosure: I'm the author of the OP and a PHP-FIG secretary. I disagree, especially in correspondence with this specific post. Sure, PHP-FIG has never been "fast", but I think that's normal for something akin to a standard body: writing down a spec is pretty hard, normally harder than it seems from the outside. Main point tough is that this post reflects the opposite: many PSR are currently being recovered from abandonment (5 9 10 and 14), and we just published a new one (PSR-15), which unlocked the work for two other ones (PSR-17 and PSR-18). All this stuff happened in a matter of months; it seems a lot of stuff to me.
https://github.com/xobotyi/beansclient BeansClient is a pure 7.1+ dependency-free client for beanstalkd work queue with thorough unit-testing. Library uses PSR-4 autoloader standard and always has 100% tests coverage. Library gives you a simple way to provide your own Connection implementation, in cases when you need to log requests and responses or to proxy traffic to non-standard transport. BeansClient supports whole bunch of commands and responses specified in protocol for version 1.10
That's really far from the truth. See this comparation: https://packagist-trends.firebaseapp.com/?q[]=symfony%2Fsymfony&amp;q[]=laravel%2Fframework Yes, Laravel is more popular, but you have to consider that Symfony is now transitioning away from the full stack approach: in v4, the `symfony/symfony` package doesn't even exist, it's just components glued together with Flex.
If it seems a lot to you, keep going I guess. To the rest of the world, this is so slow, it's worthless. PHPDoc existed before PHP-FIG. How many years did the PHPDoc PSR linger abandoned? And I've had companies like JetStream use PHP-FIGs indecision to explain why they don't implement this or that in PHPStorm. "We're waiting for the PHPDoc PSR to be finalized, before we invest effort into this feature". Well they waited like 10-20 months more and then moved to using other references. PHP-FIG is so slow, I'll *literally* retire and probably die before some of those basic proposals get finalized. Maybe many of the PHP-FIG members will themselves retire and die before this happens. You keep talking how complicated writing a spec is. The DI container interface demonstrates that one person can write a standard like this in days. Publish it. Have people pick it up and use it in projects. And then when it had to become part of PSR-FIG's PSR, it took **years**, the original author came out saying this has been one of the most stressful and frustrating experiences in his life, and you geniuses *made the spec worse*?! How the fuck did that happen? Writing good standards isn't easy, but that's not PHP-FIG's problem. The problem is you're all so myred in power games and writing your little bureaucratic structures, you've rendered yourselves unable to perform your core purpose. It's pathetic to watch this. PHP-FIG is completely irrelevant at this point. Just my opinion and the opinion of many people I talk and work with.
If what you need is fairly custom, you are better off doing that. When I have to build a site these days I stand up a frontend that's built in JS, then populate it with an API. I've done that with several languages, but php is a good choice that's available on essentially every host out there.
Maybe I'm not helping you, but I wish you and everyone else who is enthusiastic take a big step back and ponder if the standard framework components we see in every framework are really the only way to do things. For example, I've only used a regex/pattern based router on 3-4 projects, and that's because I had to match existing URLs, which were quite weird and I needed absolutely flexibility in matching weird URLs. For everything else I've been using a tree based router, which tends to be faster than anything regex can do. For DI I've always built my containers by hand as simple classes, and I believe it leads not just to faster performance, but much cleaner and better thought out architecture throughout. Regarding the database, I've an adapter which takes a radically different approach than PDO/mysqli, and it is represented as a "DB session factory". When you want to work with a DB, you start a session you do your job, you close the session. Separate components may open sessions in parallel (this will open parallel connections) so you don't get conflicts with both leaving result sets open, or both trying to start a transaction. This is excellent for modular development, and without it, I can't do anything. Anyway, those are just some examples of things you listed, and I do differently than basically 100% of mainstream frameworks. And so when I see people aspiring to build something, I wish they'd challenge preconceived notions too. Nothing that is, is like it is because it's the best way to do it. It's just the current status quo. So dare challenge it.
On the second point, I'd disagree somewhat. Yes, if the store is brick and mortars, by all means sell on Amazon and Ebay. But if you're an online presence, you're trusting all of your business to a company that doesn't place any particular value on you succeeding rather than your competitor. Amazon's happy if their customer buys their socks from Vendor A or Vendor B. There's plenty of tools out there to enable people to sell under their own brand, they just need to pay for little expertise to make it happen. Where as content only - blogs, that's where i don't see a discernible difference between a wordpress.com subdomain, Medium, or your own blog... All that said, my CMS side project is one that would have clear goals and a focus. Having pages and posts intermixed on Medium would certainly not be appropriate. But, again, from what I'm reading on Drupal, I might be happier investing a little extra dev time and turn it into a Laravel site rather than Drupal. Laravel's where I want to be eventually anyways, just thought more exposure to Drupal wouldn't hurt
Their lists of rules/features are chock full of examples that prove code correctness and prevent bugs. You seem to have pulled your conclusion straight out of the ether.
&gt; they focus on code formatting and various things I can assure you that Psalm doesn't care a whit about formatting. You can put everything on one line for all Psalm cares. &gt; We need something like Hack, something like TypeScript I agree! In the meantime, Psalm supports a number of features from Hack, like property initialisation checks, generic arrays &amp; iterables (via docblock types), array shapes within functions (and optionally via docblock types), a system of constraints to make by-ref vars more reliable. &gt; they encourage everyone to focus their energy on the trees and completely miss the forest I can also assure you that the developers at Vimeo, aside from me, are very focussed on the forest. Psalm just prevents them from getting lost in it.
I did go through the article. Be specific what you're referring to because I don't know what you're talking about. I don't need a tool to tell me to put a typehint on a method. I'm already aware of what typehints I can put on it while I'm defining it. In some cases I *intentionally* don't put typehints, because PHP is simply incapable of express that in its limited type system (instead, type checks are made through code "manually"). So then given this imperfect reality, which is entirely not due to my fault, what does Psalm do in that case? Bug me about shit that I already know better than Psalm does. Of if you mean some of the other rules... again be specific.
This has nothing to do with PHP. What you've posted is a Vue template.
I get where you are coming from, but I mostly make my second point around the idea that nobody is going to go to your site to buy a product. You need to be on social media and advertise your ebay/etsy/amazon storefront through that and provide relevant content. Your site can provide support information, info about returning a defective product, or some customer service stuff but if you don't have to set up your own software you can get your site stood up far faster and people are far more comfortable using well-known sites for doing their online purchases. This, of course, is my intuition and opinion, and it changes a bit based on circumstance. If you are a business with a proven model and the money to hire a team of developers, that is one thing. If you are two or three people doing bespoke furniture/art/clothing and handling custom orders, then there are fantastic already existing places to market those things that are far more discoverable than your site.
i wanted to see if you can do something in php to help me out i dont know a lot about php only the basics
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vimeo/psalm/.../**supported_annotations.md** (master → f806e16)](https://github.com/vimeo/psalm/blob/f806e16c10351fe05ca1181107ebcb88f7d0ed1c/docs/supported_annotations.md) ---- 
When you want to repeat something that someone else, quote them and source it so we can judge the context. Regardless of what he said, what I said is also objectively true. When you run app persistently, you can architect it in a completely different way. It won't be just saving yourself the bootstrap. You've most likely written bigger Node.JS app, you know what I'm talking about. Also on the front page of the PHP-PM project, the top Feature listed is this: &gt; Performance boost up to 15x (compared to PHP-FPM, Symfony applications). If the creator really thought the real-world results are humble, and they don't mind saying this in public, they probably wouldn't at the same time create this project and plaster "up to x15" as the top feature.
&gt; Is there a type that you cannot express in a phpdoc-compatible way, or via Psalm's list of supported annotations? As one example: callback parameter (callable object, or Closure, but not array or string) with a specific set of typed parameters and result type.
It warns you about code that _will_ break. Phpstan have helped my many times when I change the signature of a public method for instance, alerting me that some class is now using this method in a way that will break at runtime.
something like @param callable-object&lt;ReturnType, Param1, Param2&gt; $foo ?
I'd be glad to explain how these tools prove code correctness and prevent bugs beyond "telling you to put a typehint on a method". Which features/rules of which tool(s) would you like me to elaborate on?
I've ticketed here: https://github.com/vimeo/psalm/issues/580 Feel free to add suggestions if you think the syntax should be different!
Reddit is written in python :)
Ideally the return type won't be listed as param 1, it's very confusing this way to read; but otherwise I'm impressed by your willingness to improve the project :)
It always feels nice to be able to point to a company using PHP like Vimeo when people claim nobody is using it!
Well, given you mentioned Hack and TypeScript, I'd say: Neither of them guarantee types at runtime (though Hack/FB has a library that allow you to perform checks against a given type). 
That could be doable, probably, after some juggling with the type parser. But `$foo` and `$bar` there are extraneous.
They are extraneous to Psalm, but not to the documentation, and PHPDoc is for documentation. It's for people. Which is more clear: @param Closure(int, int, int, int, resource): void Callback to render the image at the given coordinates. @param Closure(int $x, int $y, int $width, int $height, resource $image): void Callback to render the image at the given coordinates. The param names can be optional, but they should be permitted IMHO.
Absolutely. I'm not saying Psalm is inferior to other static analyzers - it's a static analyzer, it can't do anything at runtime. But in the bigger picture, a static analyzer has some overlap with a runtime type check. And I've had this argument before "debug assertions are useless because they do checks that don't run in production". The same could be said of static analyzers. You trust the analysis, but actually at runtime you may get something else entirely.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vimeo/psalm/.../**supported_annotations.md#psalm-ignore-nullable-return** (master → f806e16)](https://github.com/vimeo/psalm/blob/f806e16c10351fe05ca1181107ebcb88f7d0ed1c/docs/supported_annotations.md#psalm-ignore-nullable-return) ---- 
Drupal 7 was released in 2011. Composer was released in 2012. It was a clean and somewhat modern software back then. Of course it wasn't using many classes, and didn't use visibility modifiers, but it was pretty modern back then. 
Very well said. PHP-FIG has lost its agility for the sake of power consolidation for a few.
Ahh in comparison to phpstan, levels are REVERSED. I was trying Psalm in past and discarded it almost immediately when I found it reported thousands of false positives even at level 1. I thought it's severely immature. This time I gave it more chance and found levels are reversed. You should give users big fat warning about this, I believe you will scare right away majority of potential phpstan convertibles. Anyway, even given least strict level (6, right?), it's way too strict to my liking. - Screams when accessing character in string via array offset (InvalidArrayOffset) - Tells me my PHPDoc block is lying when I narrowed method argument type down from parent's mixed (MoreSpecificImplementedParamType) - come on, I **know** that class will never receive another instance - Doesn't respect User[]|Collection return type for specifying what kind of collection is returned, instead forces unoffical &lt;&gt; syntax, unsupported in IDEs and basically in whole PHP world (MismatchingDocblockReturnType, MismatchingDocblockParamType) - come on, how are you working with codebase in vimeo? You don't use PHPStorm? You aint gonna get autocompletion with that. - Doesn't believe me when I specified type of property in doctrine entity via docblock and access it (RawObjectIteration) - Once again doesn't believe my docblock saying I'm returning string[], instead listens to typehint which says it returns array, from which it infers it returns mixed[] and complains it's less specific than underlying call returns mixed[] (LessSpecificReturnStatement) - Complains if method with non-nullable return type can return nullable object. In PHPStan, this is done only in highest level, 7. Don't make me throw exception in each of such case manually by hand, that's what is PHP return types for - if it happens during runtime, program will crash with nice error stack - similar result if I thrown exception there by hand, but with no extra effort. This is just for least strict mode!
Thank you for this comparison, it's very useful! One thing you did not mention though is that PHPStan supports extensions. There are already quite few extensions for it, like symfony/doctrine/nette etc support. Is something like that planned for Psalm?
First, thanks for the tool :) I admit so far I've only used PhpStan which seemed more popular but you convinced me to give a go to Psalm. Maybe I'll simply use both together... &gt;PhpStan [...] greatest weakness currently is an over-reliance on reflection That should be fixed by switching to https://github.com/Roave/BetterReflection. But I'm curious how is Psalm tackling this issue?
So, for which use cases is Drupal good fit? I'm asking because you suggest it's bad idea to use it for very simple sites. So, very complicated ones then? Not trying to be snarky. I don't have much experience with CMS, but thought it might be nice to build system on CMS because there are plenty plug-n-play modules out there for common functionality, so only few customizations are needed. I'm sure it's naive, but would like to hear why is it so anyway.
&gt; Screams when accessing character in string via array offset Could you give an example? &gt; Tells me my PHPDoc block is lying when I narrowed method argument type down from parent's mixed That's a violation of the Liskov substitution principle, but you're right - that should be allowed in level 6. Fixed [here](https://github.com/vimeo/psalm/commit/bf45ef04ea54cd6f8d27832d9adb7fbed5295eb6) &gt; Doesn't respect User[]|Collection Make sure you have `allowPhpStormGenerics="true"` in your config. &gt; You don't use PHPStorm? Nope. &gt; Doesn't believe me when I specified type of property in doctrine entity via docblock and access it I've just suppressed that for levels 3 and up [here](https://github.com/vimeo/psalm/commit/8da762d97d35e9c2a6604f3164d7a343e29187f8) but also if you think it shouldn't be emitted paste the code and I'll fix &gt; Once again doesn't believe my docblock saying I'm returning string[] Is your docblock valid? Could you paste here or in a ticket? &gt; Complains if method with non-nullable return type can return nullable object That should have been suppressed at level 6 - fixed [here](https://github.com/vimeo/psalm/commit/7f4e234def23e3a539fa27bdfca9db34094a5354)
Psalm has plugin support, so yes, but you'd still have to specify the plugin PHP files in your config.
Two ways: - on a full run every file in the target directories is scanned, producing a map of classname to file path - for classes not picked up in its initial scanning step, it uses composer's autoloader to find the file for a given class before resorting to reflection. Psalm also has a number of issues that correspond to PHP fatal errors when autoloading (e.g. `UndefinedClass`, `MethodSignatureMismatch`) 
Secure the server. Run autoupdate. Run script to backup everything every day/week. Check logs in wordpress, woocommerce &amp; server. 
Don't get me started on Drupalise.me. Why do they have people in videos telling you how to do things like they're reading a nursery rhyme? I don't need your cutesy star wars jokes, I want to know how to use the migrate api ffs.
Yeah the config management is a great idea, but feels so heavy handed that half the time I'm just fighting against it. 
They're really not on an equivalent level in terms of flexibility and extensibility.
Yes, OctoberCMS has a very robust and easy to use permissions system: https://octobercms.com/docs/backend/users
I second OctoberCMS. So many great things that I wish WP had. Even for just a brochure site plus blog, October is better. Theme development is painless and fast (same for plugins), unlike WP. If you install the Pages plugin it has great features for updating content on pages with complex layouts (ya know, like every modern brochure site has). It also has a feature called snippets where you can turn template partials into blocks that users can add to static pages, so you can give your theme a backend page builder with just a few extra keystrokes. Absolutely everything is easier and faster from a developer perspective, without sacrificing any usability for clients. I wish more clients would be willing to use it. So many insist on WP, even though it's a pretty lousy choice for any site that's not a blog.
There's already a variety of CMS packages for Laravel. You can take a look at what's available [here](https://laravel-news.com/laravel-cms-packages). I personally use OctoberCMS. Install the Pages and Blog plugins and you're good to go for managing content. You can also purchase plugins and themes. Less selection than WP, but you can build a content based site without touching any code. &amp;nbsp; Can't comment on Drupal, never used it. And if you need your site to actually have dynamic content, don't go with WP. The page load times are horrendous if you don't cache the whole page.
Etsy uses it as well, they even have the [creator of PHP working for them](https://en.m.wikipedia.org/wiki/Rasmus_Lerdorf)
**Rasmus Lerdorf** Rasmus Lerdorf (born 22 November 1968) is a Danish-Canadian programmer. He created the PHP scripting language, authoring the first two versions of the language and participated in the development of later versions led by a group of developers including Jim Winstead (who later created blo.gs), Stig Bakken, Shane Caraveo, Andi Gutmans, and Zeev Suraski. He continues to contribute to the project. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
That's awesome, especially the `Array&lt;T&gt;` stuff. ~~It'd be great if it would be speced as `@psalm-return` or something instead, though, since it breaks IDE autocompletion.~~ ~~Would it be possible to develop some form of generics support? `@param Foo&lt;T, U&gt;` matching `@class Foo&lt;T, U&gt;` and its methods using `T` or `U` etc?~~ [Found the docs](https://github.com/vimeo/psalm/blob/1f3ed0f7b90f82f33857c5ab2260a1f5e31455e6/docs/supported_annotations.md)
Is there a possibility to have it installed separately from project sourcode? (It's complaining about missing a src directory when I run --init) I like to do something like this: ./vendor/bin/psalm \myprojectdir then check a second project ./vendor/bin/psalm \myprojectdirtoo with one ./vendor/bin/psalm --init (but I don't know what is inside the init, since it isn't created right now) I tried: --init D:\data\git\myprojectdir and when I run psalm, it complains: Could not resolve config path to d:\data\Git\QualityReport\\D:\data\git\myprojectdir 
File extends Text. But I also find it tedious to constantly pass a Text instance to Editor methods. It would be easy to implement the same functions in Text class and pass them there to the Editor. 
Awstats / webanalyzer / piwik (there should be some Kind of script to Import data from acesslogs) Probably goaccess is enough too 🙂
I am a coder major in php,and I hope that I could get knowledge from here 
Is praticable to integrate one of them in a Yii2 app ? I should do it Edit: they seems a complete soluzione/service but I am searching for library. Probably a server-side library to easy aggregate data for highcharts.js is better... I edited the first post to make the question clear.
Just for your info, Reddit is not a forum and this kind of posts are off topic. Informative posts are welcome. Note that help requests are going in /r/phphelp 
I posted in both, but the one in the monthly is not visible. Both comments are visible in my profile page though.
Reddit isn’t a forum? I’ve always thought of it as one. I get what you’re saying though. 
Those things are all good things to check, but for code quality, readability, code style, etc, you can also leverage other tools such as Sonarqube or Scrutinizer, phpstan, etc. I actually created an automated pipeline for a few different projects at a company I worked for which ultimately helped me land a job at one of the big tech companies. I can provide an example of the tools I used to make that happen (including automated code reviews). Went from being a software architect to an sre-swe which gave me insight into this type of process. 
Better make sure to disable E_DEPRECATED in production, when using negative start_index on purpose, on PHP &gt;= 7.3 &lt; 8.0.
Your final question is difficult to answer without thorough review. Don't take a lack of response as discouragement. Evaluate if the effort is benefiting you, and continue if it is. Perhaps break down the feedback you seek into smaller questions that passers by on reddit can answer without spending hours evaluating your components.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Thank you, I have created some issues and trying it out more. I am starting to really like it! I love how it's configurable
The deprecation notice has not been accepted. The behavior will change silently in PHP 8.0.
Great start! It's going to be hard to code review anything that took longer than a day, so you're probably going to be managing a big mental stack at the beginning. My general process would be: * Look at the structure of the app. Use best practices for the framework. * Look for unstructured reusable code, e.g. are there a tonne of disassociated helpers, or could they be better sorted into a model, as middleware etc.? * Look at file and method sizes. Can you clearly tell what a file and method do by their names? Could the methods be generally shorter? * Finally I'd get into specific implementation. Looking at his DB queries to see if there are any red flags, e.g. unescaped queries or abusing having clauses, etc. Poke into various files and see if there are any bad code smells or patterns that raise a flag with you. Your plate is going to be very full if you're vetting a whole project at once. I'd probably try to offload anything that could be assisted with tool to your friend. I would recommend s/he installs either XHProf (&lt; 7) or Tideways (&gt;= 7) for profiling, which would narrow down long-running functions. In terms of code style, I personally use PhpStorm + .editorconfig, so my team's code is auto-formatted and looks like a single developer wrote it. Good luck!
"We should fix it" != "I'm going to write a patch and RFC for this right now". It should be patently obvious that this is not the first time that someone realized that this is an issue, it's just the first time that someone decided to put in the necessary time to actually go through the process.
Please do provide examples. I am also always interested to hear about ways to make the code base better and improve our CI pipeline at the company I work for. Would really appreciate knowing about the experiences of others, thank you. 
https://github.com/psecio/canary The origin of the term "canary" (as a method of detection) was originally used by those that worked deep in mines and would take a canary (the bird) with them to detect gas or other reasons they needed to leave. If the bird started behaving oddly they knew something was amiss. This same concept is applied in the security world and is similarly called a "canary". Similarly, the **Canary** library allows you to define key/value combinations that can be used to detect when certain data is used and notify you using a variety of methods It currently supports notification via: the PHP error_log, Monolog logging, Slack channels, PagerDuty and a callback option for creating custom notifiers.
[removed]
More less and something extra but the thing is that it interferes with composer flow and that becomes a problem when you are not using any public repositories like packagist or when you are behind a corporate firewall.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Yes we already had this thread.
Which is really nice ☺ 
For me, Magento was easier to pick up than Drupal. Magento has enough Zend Framework and MVC, that it wasn't too challenging to see what was added in between the layers; lots of XML, basically.
&gt; made trivial by the fact that the PHP project provides official Docker images &gt; trivial &gt; official Docker images lmao. There is nothing less trivial than official PHP images. The way they suggest to install extensions is such a clusterfuck that most folks avoid the bother altogether by simply using the base image of their choice and installing PHP from apt repo and the like. I even see devops guys doing it these days.
I don't understand why your first example is about testing. And I don't understand what's being tested.
he created 5 classes in callbacks its dope!
Hello! (Just woke up). I'll be glad to post a high-level overview of a decent automated pipeline :D You're already using some of the tools I'm using as well but for clarity, I'll go ahead and post them anyways. Fair warning, this is rather opinionated: On top of phpunit / behat / mockery, etc. dependencies you can leverage: - consolidation/robo (https://robo.li it is to PHP what Gulp is to JS) - phploc/phploc (Gives you general statistics about your LOC) - dephpend/dephpend (Lets you enforce architectural constraints, coupling metrics [afferent/efferent complexity]) - sebastian/phpcpd (php copy paste detection) - jakub-onderka/php-parallel-lint (quick fast php linter) - phpmd/phpmd AND mi-schi/phpmd-extension (PHP Mess Detection and extensions) - seld/jsonlint (Lints your composer files, or any other json files your project has, like box) - rskuipers/php-assumptions (PHP Assumptions vs Assertions... e.g. BAD: if ($user !== null) { $user-&gt;... } | GOOD: if ($user instanceof User) { $user-&gt;... }) - povils/phpmnd (php magic number detection) - friendsofphp/php-cs-fixer (Fixes your code TO a given standard) - squizlabs/php_codesniffer (Checks your code AGAINST a given standard) - escapestudios/symfony2-coding-standard (My favorite standard, it's a super set of PSR 2) - sensiolabs/security-checker (Checks dependencies against exploit/advisory DB) This takes care of giving you some small pieces that you can use alongside robo (or another task runner) to build the basis of a pipeline. To actually create a pipeline, you'll need CI. Jenkins/Hudson, Bamboo or Travis are all different things you could leverage. With just CI and the above you have the capability to do the following: - Fail the PR if ANY of the above tests fail (assuming someone used --no-verify to skip some pre-commit checks) The CI server can be used in conjunction with other tools such as SonarQube (which would have to be installed on PREM) along with different plugins (such as BuildBreaker) to track the following types of metrics AND to comment directly on the PR itself: - Code Coverage - Code Smells - Bugs - CS Violations - LOC Violations (e.g. methods too big, classes to big) - Complexity issues (e.g. too many dependencies which generally means many responsibilities which breaks SOLID OOP) - etc You can use the BuildBreaker plugin for Jenkins with Sonar to make this happen. Sonar can also be configured to directly post to your SCM on the specified pull request and comment directly on the code to provide feedback to the developer (effectively acting as a first line lead developer so that you don't have to ;) ) This workflow takes care of the small problems you'll encounter with most PRs. However, to enforce specific patterns or logic issues, you will / should still review the code AFTER all the above checks pass. (E.g. I like CQRS as a pattern sitting below the MVC layer so enforcement of that would be my responsibility) To actually wire all this stuff up I should probably blog about it or create a tutorial somewhere but with all the stuff I have going on right now, I'll have to wait a couple of days before I have the time. Hopefully, this at least gives you a starting point.
Sometimes it can be useful to show how easy testing can be in specific systems. In this case, I'm biased since I've seen this kind of thing before and could pretty easily follow what was being done. I thought it was clever and it is one of the first things I mentioned to him. That I loved the example code. If someone hasn't seen something like this, or hasn't worked with events like this, it probably isn't easy to grok. So the marketing works well for someone like me, but maybe not for someone who hasn't had much experience at all with other event sourcing projects? Also, I just realized there were no links to the docs. Not sure this would help with understanding the example any, but you can find the docs on the testing here: https://eventsauce.io/docs/testing/
&gt; Sometimes it can be useful to show how easy testing can be in specific systems. In this case, I'm biased since I've seen this kind of thing before and could pretty easily follow what was being done. That's good, but I just don't understand what's the test assertion supposed to test here. If these events exist.... when those events are added (?)... then those events... will also exist? I don't follow, sorry. &gt; If someone hasn't seen something like this, or hasn't worked with events like this, it probably isn't easy to grok. A lot of my work involves event sourced domain state, but I still don't get this.
It only makes sense if you consider the entire state of the object under test being sourced by a stream of events. Given a Developer likes Event Sourcing and discovers EventSauce (starting state of the developer), when they start using EventSauce (some external factor is causing change on the state of the developer; think $developer-&gt;startUsingEventSauce()), then they will discover EventSauce to be effective and learn a new skill (changes applied to the developer as a result of the external factor). The trick is in understanding what $developer-&gt;startUsingEventSauce() does. With this example, we can assume something like this: public function startUsingEventSauce() { $this-&gt;recordThat(new UsingEventSauceWasVeryEffective()); $this-&gt;recordThat(new DeveloperAquiredNewSkill( AquiredSkill::eventSourcing() )); } If for some reason we have more events (or less events, or events of different types and values than we expect) the test will fail. For some closer-to-real-world examples of how this might work, you can check this out: https://github.com/dflydev/es-cqrs-broadway-workshop/blob/master/tests/SuperAwesome/Blog/Domain/Model/Post/Adapter/SuperAwesome/PostTest.php This test in particular (it_uncategorizes_when_publishing_with_a_different_category) shows setting up state and ensuring the correct rules are applied to generate the correct events based on the change requested on the previously recorded state: https://github.com/dflydev/es-cqrs-broadway-workshop/blob/master/tests/SuperAwesome/Blog/Domain/Model/Post/Adapter/SuperAwesome/PostTest.php#L67 [edit] Disclaimer: these examples are from one of my workshops on learning about event sourcing (and CQRS) and are not in any way related to EventSauce so there might not be an exact 1:1 match with EventSauce's ideas, though I believe they are super close on the testing side of things.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dflydev/es-cqrs-broadway-workshop/.../**PostTest.php** (master → aa35fc4)](https://github.com/dflydev/es-cqrs-broadway-workshop/blob/aa35fc4a2206d061b3632901a83dfd84b7b54eef/tests/SuperAwesome/Blog/Domain/Model/Post/Adapter/SuperAwesome/PostTest.php) * [dflydev/es-cqrs-broadway-workshop/.../**PostTest.php#L67** (master → aa35fc4)](https://github.com/dflydev/es-cqrs-broadway-workshop/blob/aa35fc4a2206d061b3632901a83dfd84b7b54eef/tests/SuperAwesome/Blog/Domain/Model/Post/Adapter/SuperAwesome/PostTest.php#L67) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvv7srg.)
couple gripes with this: - Your interfaces should, at least from what I have seen start with `IInterfacename`, So like `IEvents` or something, because what you have now is hard to understand what is, and what isn't an interface. - Your tests should all go into a `tests/` folder, and not be mixed among the source code like they are now. Helps in readability and general conformity. Also, other pointed this out but the whole example on your home page makes 0 sense. It doesn't help me better understand what this library is even for or who it's targeted at.
&gt; It only makes sense if you consider the entire state of the object under test being sourced by a stream of events. &gt; Given a Developer likes Event Sourcing and discovers EventSauce (starting state of the developer), when they start using EventSauce (some external factor is causing change on the state of the developer; think $developer-&gt;startUsingEventSauce()), then they will discover EventSauce to be effective and learn a new skill The state of the object is being sourced by events. But the events are themselves not sourced by events. This is taking things a step too far. It suggests that if you know the past events in a system you can predict the next, and therefore all future events. That obviously isn't the case a lot of the time, and event sourcing doesn't mandate it be so. Maybe the example event names are too hindered by an attempt to be cute and that causes the confusion about what's what and who's who in this example. It makes it seem as if a developer interacting with this event system has no choice but to like EventSauce once he starts using it. It's like saying an e-shop customer has no choice but to finish an order he's started (I wish it were so, then I'd be rich). What I don't understand is where's the distinction here between *event* and *behavior* in this system. In `given()` we're mixing present tense and past tense. The first object is named in present tense, the second in past tense. So many questions... - Is the first one a command/behavior and the latter an event? - Why are we mixing those in `given()`, shouldn't what's given be just the pre-existing event stream? - If both are events, then why is the naming inconsistent? - If both are events, does that mean the object constructed and passed to `when()` is also an event? - If the object constructed and passed to `when()` is also an event, why does it have side-effects (it causes new events to be added to the stream). An event is a value free of side-effects. There are more problems here. This test has the expectation that as a command is issued, it has an immediate synchronous effect on the event stream. That's a big assumption to make, because in the real world a lot of this happens asynchronously. Third party services may be contacted, workflows may be operating outside the process, some events may rely on cron jobs or whatever, some consumers may be operating out-of-band and also end up generating events, etc. etc.
Also, to avoid wasting time installing/configuring stuff, [a lot of the above suggested tools](https://docs.codeclimate.com/docs/list-of-engines) are already set up and automated in the [Code Climate Docker image](https://hub.docker.com/r/codeclimate/codeclimate/). All you have to do is generate a config and run a single command.
Bionic Beaver? Maybe it's just my dirty mind but that sounds like a sex toy.
&gt; I think you added this after I started to respond. :) The 2 minutes after I post can be quite turbulent. &gt; I hope my response doesn't sound too patronizing. No problem. &gt; Are you using off-the-shelf PHP solutions (Broadway, Prooph, etc?) or are you using something else or something homegrown? [...] I'd love to see how they handle testing! My solutions are highly-specific, as my projects are multilingual (not just PHP). Testing is typically done by feeding in serialized input and inspecting the serialized output (in a format that's essentially JSON) and typically at the microservice API boundary. A lot of the tests we write are literally just text files of JSON, no code at all. If a projection is complex, it may be tested individually. Commands are rarely tested individually, as they're trivial, and you get coverage by testing the microservice unit the command is part of. Anyway, the thing that makes the example of EventSauce confusing is that the commands/events have very similar names and the `given()` section mixes both. It kind of throws you away from the logic of the system. I suspect once we clarify this, it'd look much more boring than I made it out to be.
Grump php as well. https://github.com/phpro/grumphp
Thanks for that suggestion! I didn't know GrumPHP existed, will definitely check it out. I learned about Code Climate from GitLab's [Auto DevOps announcement](https://about.gitlab.com/2017/09/22/gitlab-10-0-released/#auto-devops). I've been trying to up my CI/CD game.
&gt; Your interfaces should, at least from what I have seen start with IInterfacename, So like IEvents or something That's very much a Microsoft eco-system convention. Although PSR 1 and 2 don't specifically mention this, in the PHP eco-system, the most common convention is to use something like `FooInterface`, `AbstractSomething` or `CanDoThisTrait`. But yes, your point is valid and not sure why you're being down voted... 
I'm not going to disagree with you on any of this. :) The example is cute and contrived and intended to be clever. Very much agree with your other comment that it would be boring (and far more verbose) if it were "right." In reality, we'd probably need to be passing at least the aggregate root ID into each of the events. I'm happy to gloss over that with the understanding that it would have just added visual noise. Did it get the point across to me that EventSauce had support for bootstrapping aggregate root tests? Yes. Correct? No. It sounds to me the naming and tense of the events and commands is the main problem you had with the example. With a healthy does of, "this model doesn't actually make sense." Does that sound accurate? &gt; This test has the expectation that as a command is issued, it has an immediate synchronous effect on the event stream. Ah! I think this is a fair assumption, though. The test is on the aggregate root itself. The aggregate root *should* be expected to have known outcomes (then events) based on previous state (given events) when new actions are taken (in this case, commands are being used to manipulate the aggregate root). The exception would be if you have some non-deterministic behavior in the aggregate root. I've not run into that very often, though. And in that case, I'd probably have to take special care to test it and probably would not be able to use a generalized testing solution. &gt; Third party services may be contacted, workflows may be operating outside the process, some events may rely on cron jobs or whatever, some consumers may be operating out-of-band and also end up generating events, etc. etc. Indeed. Those other components could be tested on their own, though. If you have something that generates an email after UserWasRegistered, I'd build a test that provides any needed state, and configure when(new UserWasRegistered($this-&gt;userAggregateRootId)) to test how that component acts on the UserWasRegistered event. Yes, this means consumer-based tests would have a when(EVENT) instead of when(COMMAND). It also means then() could be something other than a list of resulting events. Here is an example of a read model test that would react to multiple instances of the same type of event. In this case, the then() is specifying a list of read models that should result as a result of the given state of events + when a specific event is added. https://github.com/dflydev/es-cqrs-broadway-workshop/blob/master/tests/SuperAwesome/Blog/Domain/ReadModel/PostCategoryCount/Adapter/Broadway/PostCategoryCountProjectorTest.php#L52-L66 This has worked out well in my experience. The aggregate root has its own "channel" in an event stream. Doing something that actually changes state for that aggregate root will always generate at least one event that gets appended to the aggregate root's channel in the event stream. No other events (or outcomes) are associated directly with that transaction. Anything else that reacts to those events are tested on their own. Process managers, read model projections, etc. If more events are triggered as a result of UserWasRegistered, that is fine. But the User aggregate root test doesn't need to know about those. You can still *relate* the events using things like causation and correlation on the event envelopes. I'm sure this is not the only way, though. I've never personally tried to test a whole process end-to-end within one test method. Even if I were to do so, I'd probably still do some finer grained tests like, "When user is registered, an email should be sent..." vs, "When user is registered, an email should be sent, and the admin of the team they belong to is emailed, and we add them to intercom via api, and we ..." because this could go on forever and it would be difficult to maintain a monolithic test as features change. And FWIW, it doesn't look like there are any test helpers for testing anything but aggregate roots in EventSauce. This sorta makes sense given the library nature that EventSauce is going for. Process managers, sagas, projections, etc are all just consumers. You can do whatever you want with them, but you would have to build the tests yourself. I may be totally wrong on this. A quick scan of the repo doesn't show any code generation or base classes / test helpers for consumers, much less specialized types of consumers. In any event, I'd love to see examples of how you're testing this stuff. I suspect that might make it more clear how your approach would differ.
Given the overhead apt has in docker images, I don't mind the clusterfuck. I just write my own images and let Docker Hub build them for me.
Nice, thanks for the background. :)
Because not everybody with this. Naming interfaces `I*` is as you said very Microsofty and it's more common in PHP to name it `*Interface`. However even that is still controversial: one can argue that you declare the interface with the `interface` keyword so you really don't need the redundancy in the name. When as a consumer you need a container, you consume the `Container`. Having `ContainerInterface` brings nothing: you actually don't care that it's an interface. Another benefit is if you have an interface `Container` as opposed to `ContainerInterface`, you're forcing the classes implementing it to find a more suitable name. An actual advantage to have the `*Interface` suffix however is to be able to be able to determine the type from the filename. &gt;Your tests should all go into a tests/ folder, and not be mixed among the source code like they are now. Why not? I find nice to have your test next to your code: they go together. An example is this is actually recommended in TypeScript for Angular 2 and above for the specs (not e2e tests). As long as the tests are out of the classmap when importing the package (and this is the case here cf. the `.gitattributes` file), this matters little.
I would write it again from scratch. I mean, usually I'm a big friend of incremental improvements and refactoring instead of rewriting from a business perspective, but seriously, PHP 4.3.8? If this is a long-term project that brings in money, writing it again from scratch is most probably cheaper than refactoring it.
I strongly disagree with that pattern, and I can sum up why as: 1. **Axiom:** Developers ought to code against interfaces. 2. **Therefore:** People will use the interface names far more frequently than the concrete class names 3. **Therefore:** The commonly-used interfaces should have the "good names" which are readable and clear. * Such as `Request` * *Not* `IRequest` * *Not* `RequestInterface` 4. **Therefore:** The concrete classes need other names. * One that describes what makes them special, ex: `JsonRequest` * Ones that fit a convention when you can't think of anything better. Ex: `RequestImpl`, `DefaultRequest` **TLDR:** I'd rather read a codebase full of `File`, `StockPicker`, and `Formatter` than a codebase full of `IFile`, `IStockPicker`, and `IFormatter`.
Honestly this app does not aspire much confidence. First thing off the bat is the landing page. The English is not great and a lot of the sentences make no sense. Plus it doesn't really explain much. I've had to do quite a bit of digging to figure out what this does. This is the same for the documentation. This app scares me. Your app basically asks to get access to my source code and production server and then magically deploy one onto the other. This is super critical and sensitive information. I have to trust you not to do anything shady with this and I have to trust you not to leak that information. If someone dumps your database, they'll get access to the source code and production servers of all your users. You're painting a pretty big target on your backs. Your app looks like a pretty low hanging fruit. I've also read the code for the frontend app and played a bit with the API. It doesn't looking very promising. I don't think that I can use or recommend this app in good conscience.
Thanks for your constructive feedback. You don't need to be scared to use the app because everything the app does is done via SSH protocol. We promise that none of the critical and sensitive info will be exposed. We try to make it harder for hackers to hack into the system. The product is in the early stage we are constantly improving based on user feedback. Thanks again.
&gt; You don't need to be scared to use the app because everything the app does is done via SSH protocol. This has nothing to do with the SSH protocol. You're storing SSH private keys that give access to production servers and you're storing tokens that give access to code repositories. Using the SSH protocol (assuming that you're doing so properly) will protect you against man in the middle attacks but they'll do nothing to protect you or your users if your database gets leaked. &gt; We promise that none of the critical and sensitive info will be exposed. Promising that you won't get hacked is just naive a ridiculous. You can't guarantee that you won't be hacked. &gt; We try to make it harder for hackers to hack into the system. How exactly? I'm not just going to take you at your word. This is the kind of stuff that you should be promoting on your site.
The fact that you are even storing such critical information from your users seems like an inherent design flaw to me. A lot, probably most companies out there, couldn't even use your service because of this. ISO certified companies, companies dealing with credit cards in the US and companies in the EU that have to deal with laws surrounding the protection of personally identifiable information. I'm not sure about other regions, but those sound like key regions you'd want to support for the most basic of reasons. You should keep access control in the hands of your clients and don't assume it. If your software must intervene, use some form of a broker that you can give under the control of the user. 
Step number one: set up _any kind of test_ for a single _page_. The best kind of test here is honestly to just diff the output for that particular page before and after. This is called a "golden master" test. Step number two: refactor _only things on that page_. Your golden master test will tell you when you break something, so you can safely refactor. You can add pages as needed to your "golden master" test to refactor across pages, too.
I've thought about doing that, but am a bit unsure on how to set up a test like that? Is it as simple as save page and do a diff? Or is there a better automated way to do it. Right now, views will sometimes have one line including another view in another folder. It's not uncommon to be including 6 different views with different logic, as well as global variables that come from the router.
You can set it up with tools like selenium (open source) or the paid service https://ghostinspector.com. We use ghost inspector at work because it’s so damn easy to use and saves us a lot of time. Ghost inspector can run multiple actions on your pages and takes screenshots of the result. When there are too big differences in the results between tests it triggers an alert. 
Your test should not be concerned about how many includes you do. Just store the output in a file. If it's a webpage, store it in an HTML file. Make the test so it creates that same output, every time you run it and then compares it to your stored version. If there's any difference in output, you broke something. If the change is intentional (e.g.: optimized use of whitespace), then store the new output and use that as master for your tests. I would suggest, though, to not set this up for a single page, but for your entire application. It's good to focus on changing functions for a single page at a time, but no doubt are you affecting multiple pages at once with shared logic.
Will the video on this page be helpful? Paul Jones — Steps Toward Modernizing a Legacy Codebase — php[world] 2014 https://leanpub.com/mlaphp 
Use deployer.org
I agree with most of what you said except the last bit: any shared logic should be broken apart by leaving the existing copy and making a new version (for now). You don't know enough about the system to know if things are accidentally or intentionally similar at this point to accurately affect multiple pages at once. Save yourself some pain down the road and, temporarily, pretend that everything is unique. Once you've got enouh of the puzzle solved, then you can refactor the new, cleaner code into shared logic.
What do you mean by the overhead? I remember doing the casual comparison a year or so ago and for me the compressed size of Ubuntu image with PHP and all extensions installed was only like 10 megabytes bigger than official PHP image based on Debian. I don't quite agree with the argument unless you're talking about something other than disk size.
Ghost inspector looks amazing! Thanks!
The summary / intro on the site pretty much reads like this post. I'll look into getting the book. Thanks!
You have a version control, haven't you?
&gt; is now super slow This suggest it wasn't always slow. What happened? If speed is the only issue, track down the bottleneck, and fix that. Do you have the business documentation for the application? Does it generally work? Do your people know what it should do? Use them for testing. Refactoring is cool when you have a big team, but when it's 2 people on thousand line functions, it's maybe not an option. You don't say what the app does, but from your words 90% of it is useless code, when a library already exists. Separate aspects of it into new apps, that are actually maintainable. Add new functionality there. I would say you fix burning issues, but start redeveloping it into something more sane. But it's just a suggestion, you know better what you have, what resources, timeline, etc. Good luck with it!
I was in a similar situation and I searched and found a book about this: Michael c. Feathers - how to work effectively with legacy code. I recommend that.
This is inspired by laravel/socialite, you can easily use it without Laravel! https://github.com/socialite-manager/socialite
Hi everybody, Frank here, I'm the author of EventSauce. Feel free to reply with your questions or comments.
Step one is to break it into logical components and refactor one at a time, with each small refactor adding tests and merging/working with production. Entire refactors all at once nearly always fail, so do it incrementally as much as is possible. This can even mean multiple phases of refactoring certain core parts... which takes longer but it's much less prone to failure. 
&gt; aspire 
Looking good! - A Help Scout Engineer
This is the classic definitive work on refactoring. Great book.
This seems to be the real-world approach. I have been in this situation multiple times and OP should listen to this. However, I always wonder how coders of a startup even have time for huge refactorings. As the comment states this can only be done step by step after a breakdown of all components. Also listen to the last sentences - don't be THAT dev that only points out flaws in a big system. Anyone can refactor existing code, it is much harder to come up with a working solution in the first place. Get shit done an running, refactoring can be done by any intern (which is only needed when the planning of the requirements were not clear enough in the first place). 
I'd push for the slowest but probably best long term solution: to recreate the application instead of refactoring it. Plan ahead, model and properly document all business processes, define and take into consideration any future needs, plan the new architecture, scrap useless use cases, and only then begin coding it from scratch. 
I’ve never used Drupal but at least Drupal developers seem to have a choice. ShapePoint is top because nobody chooses SharePoint :D. It’s forced upon you because an organisation is so deeply embedded in Microsoft and there’s little/no alternative that works within the eco-system.
While the "rebuild from scratch" path is easily the most enticing, but it's also often the most impracticable due to a number of concerns: * Getting the time from management - rebuilding from scratch severely limits the time available for fixes and features on the existing application; * If you do get time for it, it will take longer than you expect - which will cause further friction with management; * You're now working on 2 code bases at the same time; * Defining the requirements is frequently problematic - it's often the case that no one can tell you everything the existing application can do and why, but you WILL find out all the stuff you miss that people forgot about that is actually used; * Data usually has to be migrated from one code base to the next - which first means you need to understand everything the existing application does with that data and why (see above) Refactoring the existing code is, in my opinion, generally a much better path to follow in most cases. It's something you can even do without requesting explicit time for it by incorporating it into your ongoing work, and when you do request time, you can request it in smaller, more specific chunks which are much easier for the business to digest. There are cases where rebuilding from scratch is pretty much the only sensible option, but I believe you should always consider refactoring first.
There is plenty of advice already, so I'm going to ask you a question instead: what are these global variables? I'm always fascinated to what people put in global variables.
I've never been in such a situation, but I would want to start breaking down the functions piece by piece, adding documentation as I'm going through it from things that are obvious, taking notes and make a UML diagram by going over the whole code base. The "slow" part of the situation may not even be software related. Have the severs running the application been thoroughly tested yet? Then look at the UML layout to start assessing where slow functions could be. The original dev probably intentionally made his own framework to avoid the "weight" of a common framework and also to have better control over updates. He could manually implement good ideas from a frame work into his custom MVC over time instead of hoping that there's nothing breaking his system or creating vulnerabilities in the latest popular distributed framework.
I'm not sure you're given good advice here. No one here can give you good advice without spending some time with the code and what it does. I personally wouldn't set up *ANY* tests on "pages". The page is the human interface, it's the least missions critical and most fungible part of the app. The most critical part is the domain (i.e. models, business logic, services). You want that to be isolated from the rest, well encapsulates, secure and intact. I'd move to isolate and build tests for that probably. But let's take a step back. You said this: &gt; Because the application is now super slow, we need to optimize. But in order to optimize we need to refactor. To optimize, your first step is to *profile the code and find bottlenecks*. You don't need to start refactoring arbitrarily just so you can optimize. It may turn out the changes needed to the code are very minimal, if performance is your only goal. I'm gonna give you one of those things: you should cache GET request everywhere you can. If you content changes once an hour, and you get 4-5 requests per second, say, then caching this content for half an hour and serving the cache by skipping the entire rest of the app can be up to an 8000x increase in performance. See? Plenty of easy wins to score if you approach this smartly.
Regarding the first one can't it be deprecated in favour of the Symfony Lock? (https://symfony.com/doc/current/components/lock.html)
Hey, I've been there, the app had some classes, the rest was procedural. You can two approaches in my opinion: 1. Refactor the existing code How do you do this? You start reading, find patterns, what functions belong to the same domain, ie what code calculates the basket, or handles promotions. Then you write your own classes. P.S. at this point you cannot integrate any framework in this mess. What happens when you want to deploy that code? You don't trust it won't brake, business is scared and for good reason. So you use what's called scientists to see where that code would break https://github.com/daylerees/scientist. This is a save(r) way to integrate things, it will be very slow, but in a couple of months you will exponentially reduce the code base, it might take a year to have everything done by your new code. 2. Use the wonderful buzzword of micro-services Them business people love buzzwords, make sure you use them a couple of time when presenting this proposal and mention that your competitors are also doing this. You should be right since everyone is doing this ( with no good plan really ). Shelve the current codebase and only do the bare minimum on it. Talk to business and see what projects they want to do this year, with every project do a new service, a clients service, a email service, a promotions service, a delivery service. You could integrate that into the current codebase, but the easiest thing is to bypass and call your new service from the view. You need solid automation to do any of this, now since you don't have any qa engineers, I'll give you a tip, use codeception.com, it's a open source php automation framework, it's really easy to use and I've used it on a couple of projects. I think option 2 is easier and faster, you can use never technologies and tools, just do the proper planning in advance. Let me know how it works out for you! 
Not as a drop in replacement. Alone the stores are not the same. Users would have to rewrite their code and the idea was to avoid that.
Run away. "Startup" is an often overused term and I find established companies use this term when they dont adequately fund investment in their codebase and jump from one "great idea" to the next. I say get another job, not to be snarky and avoid your question regarding refactoring, but because you should really look at what this company is offering you as a developer in your career. If this codebase as 5 years of development work on it with sub standard design processes, then my guess is that your continued work is following the same paradigms and you will constantly be challenged by the company's culture in the belief that "bad code" is just fine as theyve been operating and making money with it. You will find yourself constantly battling this culture as you try to improve it. I'm the meantime, developers at businesses that value their codebase will be introduced to new design patterns, refining good workflows and your next interview will make it apparent you haven't been learning how to do "good" development. In short, the market is highly favorable to developers and there's no reason to stay with a company that doesn't value your work. Find another company that does and your career will be much more rewarding. 
Rewrite from zero. It'll be cheaper. Also. You can use use But to navigate the codebase and see what's happening. It'll give you a better idea about the codebase
Write an adapter bridge that uses the same interface as your previous project? 
&gt; you should cache GET requests everywhere you can. In general: yes. In a legacy app of questionable quality where you can’t say for sure that the devs before you knew which http verb was the correct one to use: probably not a great idea.
Geez you're really painting a dark picture here. But anyway when I said "GET requests where you can" implies I don't mean blindly all GET requests, but where it's deemed suitable for the particular app. It shouldn't be too much to set-up an opt-in cache up front, and then start opting page types and responses in that are safe for caching. Say based on the URL pattern.
It has been several days and no moderator has approved it ;( I even PMed one of them.
My personal guess is that the pending list is flooded with records. Mine wasn't approved either
In the Symfony component you can specify an expiry in case something unexpected happens.
But for that, you actually have to read the documentation very far to realize why the very first example is a bad idea. I'm not saying you can't write correct code, but the design is provoking a certain class of bugs.
An excellent idea, for the new maintainer.
&gt; Edit: Also I wouldn't recommend the Symfony API, as It encourages bugs by having a seperate release call. I agree with you, I've made such a proposal but it was unfortunately rejected (I just discover the closed status) https://github.com/symfony/symfony/pull/24146
when I do d:/installDir/vendor/bin/psalm --init d:\myprojectdir it creates the psalm.xml in the installDir. I copied that one into the d:\myprojectdir editted the &lt;directory name="d:\myprojectdir" /&gt; into &lt;directory name="" /&gt; and when I now run psalm with --root=d:\myprojectdir it starts scanning. Can this be done simpler? 
Would you mind creating an issue at https://github.com/vimeo/psalm/issues?
of course (done)
The fact that you share the same server for your [other business](https://putforshare.com) as well as [your personal site](https://neps.in) while handling server credentials for other people does not make me feel all too happy tbh. Also the notion that ssh somehow makes everything secure is outright scary if that is the thought that went into securing the application. 
Can confirm the book is really good, well worth the money and it is like it is tailor-written for your scenario.
Sorry to hear that. Thank you for your contribution to Open Source space!
I used to work support for a large SaaS company at uni. Plenty of consultants that didn't know a thing about the software, or how to implement it, that would be charging $300 an hour to their clients. And what did the consultants do for the majority of their cases? Email our free support. Made me crazy mad.
We pretty much only use Chrome, so that will work. Is there any way you suggest structuring it in the project? Should it go under its own test folder or be visible in the `js` folder under `public`
&gt; But in order to optimize we need to refactor. no, in order to optimize you need to benchmark first. Adding DB indexes or a caching layer can go a long way before even touching the code. &gt; The amount of code that has to get refactored is so large, Well the first question you need to ask yourself is can you do that as a single developer and under which time frame? don't invest yourself in something you'll never be able to accomplish. What kind of application is this? a CMS? a CRM? sometimes just slapping an existing project with some custom templates is a better strategy than a full rewrite.
Yea, I agree. But rollout app is completely put on a different server with firewall enabled. Doesn't mean that promo page is on one machine, the actual app also should be on the same machine. It's a general practice to keep separate. I have done that.
1) I use Apache+modphp in development as i find XDebug works better. In every other environment i use Nginx+PHPFPM. In production we have a small fleet of small nginx servers that serve static assets (js, css, etc) and anything dynamic gets handed off to the PHPFPM fleet in our load balanced back end. We're currently using an AWS ELB for load balancing but have used HAproxy before. Either will work. 2) Any language you know is good. If you're asking are there PHP jobs out there that you can jump onto freelance then yes. SOmeone else will have to speak to what to learn to have the best chance there though, I freelanced as a project lead and architect which gave me the power to make the decisions. 3) Sure can! I use PHPStorm as my IDE which runs in windows. The Visual Studio IDEs are also good but i can't speak to them. The power of PHPStorm means I haven't looked at anything else. Using Vagrant / VirtualBox / Docker you can easily have a linux based PHP server hosting your development instances. I _believe_ with the linux subsystem now you can install all the necessary linux based servers like Apahce and the linux modules. OR you can IIS + PHP if you really want to go that route.. Good luck and welcome to the club!
No tests, not OOP and using regex which makes this pretty slow. 
[removed]
Can also confirm the book is great :)
&gt; which server is better for php? If you're a beginner you don't need a server just use a simple hosting (PHP 7.1 minimum) &gt; is php good language for freelance? You're on the sub of PHP... so... &gt; can i develope php on windows ? Yes you can, take wamp or laragon (simplier). After if you need to have more control on the environement you can try a VM. 
[@phpfig's latest tweet](https://i.imgur.com/JLhY2HY.jpg) [@phpfig on Twitter](https://twitter.com/phpfig) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
So, to criticize someone that aims to *inspire* confidence ultimately means they have to be perfect too? As an example; I'm in no way a god when using English, but sometimes I leave suggestions to help others with their English - to help. Are you saying that I should stop helping others, because I cannot possibly be qualified to help them? I can totally say that the website does not *inspire* any sort of confidence at all, rather the opposite.
All the php tools are great. However nothing comes close to the WTF meter if you want to know if the code is maintainable or not.
If you know enough how to build a site with it (you don't need to be a 5-year expert for that), any editorial site is a very good fit. Once it's in production, everything goes to cache when you deal with no logged in users so it's very fast. My own threshold, once again, my own, not a generalized one, is that once you enabled more than 30 to 50 modules, you probably chose the wrong tool (don't be afraid with the number, with a generic install you will have at least 20 of them only with core, lots of module are small enough).
An untested stack calls for a full rewrite. You can reuse some little parts of business logic if they still make sense. Use a framework this time to make sure it's maintainable.
You can find this interesting: https://github.com/nikic/iter
Java is a good intro to statically typed OO language. If you've written object oriented PHP, you'll find Java's OO structures familiar. It doesn't have nearly as much "magic" as PHP, which I consider to be a good thing especially when starting out. Job prospect wise, you'll be able to find jobs doing backend projects or you can jump into mobile development and work on Android apps (I am an Android developer).
To be fair "slow" is even part of the url ;-)
About the freelance part. I've been investing all of my time in to php developing for the past 7+ years and I get about 3-4 offers a week on LinkedIn and about 3-4 offers a day if I change my status to actively looking. So yes, a lot of opportunities. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Interesting, I've somehow never heard of this. I can't quite tell from reading the description what advantages this would have over phpspec, Behat, or even phpunit. Just another, slightly different syntax. I'm just got seeing "A lot a additionnal features" like it says. 
TL;DR anyone?
Here's a transcript of the talk: https://michaelheap.com/how-to-ruin-a-career-in-10-easy-minutes/
Not sure why this is news. "New version of software ships with newest version of package".
Thank you, looks very sensible. I've learned some of those chapters the hard way.
On the first one, I've only worked with one person who was like that. He thought that he should only ever be judged on his technical merit and his technical merit alone. His interpersonal skills were... more than lacking and his "contribution" to the team in terms of teamwork definitely outweighed his technical skills, as good as they were. He was talked to about it multiple times, but I think he was of the opinion that it shouldn't matter. That there was nothing wrong with how he was acting, because his code was good. He ended up getting fired, too late in my opinion, and the workplace became an immensely better place to work at. That being said, I am definitely guilty of pitching my favorite thing in conversation too much. And by favorite thing, I mean Jetbrains. For a couple of months it was Upsource. I still swear by Upsource, but I accepted defeat in that my coworkers didn't want to use it. There was a running gag that I was getting paid by Jetbrains. And if they had offices in my location, I would definitely apply
As someone new to Drupal with experience in OOP PHP I'm going to have to strongly disagree. The only times using Drupal is tolerable is when I'm working with the Symfony parts D8 is built on. The biggest frustration I see on my team is Drupal's outdated choice of "configuration over code" as we're wading through YAML files just trying to figure out what the variables are and how to make simple changes.
The second article on topic of "Fast Web Scraping With ReactPHP" is about making the scraper nicer by throttling concurrent requests with a simple in-memory queue: http://sergeyzhuk.me/2018/03/19/fast-webscraping-with-reactphp-limiting-requests/
Tsss, nah, Eclipse is way better ! More seriously, we all have this kind of behavior, at some point, the hardest thing is to know when to shut up and really start working with others, because no matter what you think, the best tool is the one that gets the job done, and as a developer, you're not always the one in charge for this kind of decision, and you have to accept it. One in the company I work for was this exact guy who can't shut up, and was telling to everyone about how great is this tool, how bad is the admin because the X tool in the infra was not in the latest bleeding edge version, etc... He eventually left the company very quickly.
&gt;Programming is about communicating ideas to PEOPLE I'm not sure I understand this point. Aren't I using a particular language to communicate ideas to a COMPUTER (or interpreter/compiler/however you want to say that)? I'm commenting and documenting my code so PEOPLE can understand it better than just reading the source after all. If it were an effective communication method for PEOPLE, none of this other stuff would be necessary.
I was logged in and don't use Twitter. Isn't there like GitHub issue? Google groups are prehistoric doesn't make sense for open source projects
a better place has been suggested in the very form where you were posting: https://imgur.com/a/M9Tjb
Glad you like it!
Machine language is for computers. Everything else is for people.
IMO, PHP-FIG was never agile. Every standard took a long time to go out, it was never fast nor easy, because it had to always consider all the options and opinions. But it's normal for something like it.
Just remember who is supposed to use a program.
There is an ongoing discussion about changing the media, but the ML is still largely preferred due to the underlying email medium. Still, the Group is used just as the main channel, but for this kind of work you can use any mean that you prefer. I'll try to attract the attention of someone in the WG to get back to you ASAP.
That kind of build doesn't give you full control on which PHP version you can use. Also, using the alpine variant makes a huge difference: my images slimmed down from 1gb to ~200mb
You might want to apply some of them to your answers on /r/PHPhelp See here for example: https://www.reddit.com/r/PHPhelp/comments/844ady/php_if_else/dvmqsyd/ 
Again, I don't follow. Because a person successfully uses a program, does that mean the author of the program has effectively communicated how to perform the actions of the program to that person? I don't think it does. In fact, I'd say it makes them less likely to understand the concepts. It shows they've understood how to use your program.
Most developers, most of the time, work as a team. We may all try to write solid, robust programs but most of the time we can only do so much alone. In order for large projects to run smoothly, you need a whole team to communicate effectively. You need them all to be on the same page. To work together well. You really do need to have a decent level of inter personal communication skills. Even when working solo, you need to communicate well with the people who design the specs, with the people who are going to be deciding if the end result is acceptable, with the stakeholders and so on. Programming is part of the job, yes, but if you want to build a large project and have it built well, communicating ideas to people is key.
&gt;Eclipse is way better [Inarticulate screeching]
From what I can see from php.net, [PHP was PHP/FI for *most* of the time up until PHP 3.0](http://php.net/manual/en/history.php.php)
What are your other questions? I don't know too much about it, but I'm curious what information you could need about it
There are old tar.gz for download in museum.php.net Maybe you can dig some stuff from readme and changelog files.
I would ask for a book about PHP/FI... but there wasn't any, right? Other question is about documentation for PHP/FI in form of books/blogs/tutorials/Api docs/etc.
thanks for your comment! I just downloaded laragon and it blew my mind! Mind to share how to start an Express JS project? I successfully able to quick create CodeIgniter project using laragon
I work only with laravel on laragon so I can't help. But there's a forum you can always ask for help : https://forum.laragon.org/topic/561/nodejs-expressjs
Eclipse?? Don’t you mean NetBeans, you filthy heathen? ^/s ^^&lt;3
&gt; I would ask for a book about PHP/FI... but there wasn't any, right? Referring to php.net, it looks like the [first PHP books were written for 3.0](http://php.net/manual/en/history.php.books.php), so you're right in that regard. &gt; Other question is about documentation for PHP/FI in form of books/blogs/tutorials/Api docs/etc. I feel doubtful that blogs and tutorials would be much of a thing to be honest. PHP 1 lasted all of 2 years, and PHP 2 didn't even last a whole year. Your best bet would probably be http://php.net. Even looking at the documentation for PHP2 using the wayback machine for 1998, [the documentation is basically the exact same as the page you already found](https://web.archive.org/web/19980701122601/http://www.php.net:80/manual/phpfi2.html). Even the news group that they've posted for their mailing list doesn't appear to date back far enough (though I've only looked in a couple of groups, so you can always check it out yourself). *However*, download the PHP2.0 tar file. It's got an examples folder. You can probably use those as tutorials and documentation.
That's a strange way of spelling vim
What did he get fired for?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Why’d you put an “m” on vi?
Just generally being a toxic influence. There was a specific occasion that broke the camels back, but I won't go in to that. It was coming, mostly as a consequence of how he acted in the team. How he made other people feel and how he talked to other developers. One of the things that typified him was posting in our chat "Here's a piece of code, who can tell me what's wrong with it" which was his way of saying "Here's some code, who's smart enough to see what I see with it". There were a lot of individual things that were small enough not to be much of an issue. Sometimes it was just being extremely picky in pull request reviews. But the way that he communicated and how constant it was turned the small little things from something that's not a big deal at all in to a pervasive toxic influence.
But JetBrians **is** better than everything else....
how to ruin a good point in 4 minutes, bring up politics. some fucking people just cant leave their bullshit political opinions out of ANYTHING
Oh, we used Jetbrains for our IDE's all the time. It was when I started preaching about Upsource that I went outside everyone's comfort zone. But man, Upsource is just so amazing...
advice for the participation trophy generation
I love it to bits. Especially with Plugins. And then I discovered Upsource which provides static analysis inside code reviews. And integrated code reviews in to the IDE. And then I discovered you could (unofficially) install plugins in to Upsource, so you could still have PHP Inspections EA reported automatically in the code reviews that I went all fanboy...
Unless you're a solo or siloed developer, you're communicating with your team and other co-workers to create that machine interpreted/compiled code. That back channel communication is really important for making a quality end product. The team needs to work together, compromise, and at very least be on the same page. If half the team is working toward a different gosl than the other half due to communication breakdown, then the end product will suffer, regardless of how well written the code is.
&gt; Me: I wonder what Upsource is.... Great. Now I have to explain this erection to the office.
I once volunteered years ago to do a Drupal upgrade. If I remember correctly -- at the time -- Drupal wasn't very backwards compatible by design and all of the content had to be manually migrated to the new system. (This might have been because the old one was very out of date though, maybe at end of life). I wound up handing it off to someone who had lots of Drupal experience. I bought lots of good food and expensive beer and did the testing while they did the upgrade.
A lot of the replies here are pointing to the same thing: that communication is important. I don't disagree with that at all. In fact, I think in a lot of ways good communication is more important that good developers. ...but I don't think that's what the original statement implies. Programming is an action that programmers do (among other things like communicate). I think it's been defined ambiguously in this scenario and it could be problematic.
I think it depends upon the set up of your shop. Some shops have business analysts that provide a layer between the programmer and the user, some don't. I know that this is absolutely necessary in certain cases (for instance when the programmers are on the other side of the world/timezone or don't speak English or a dialect of it that is mutually understandable).
Does Upsource not look amazing? Have you seen how it integrates in to PHPStorm? It integrates *quite well*. Not an advertised fact but... you can install plugins for Upsource as well. They don't support it officially, and they clearly didn't try it at any point, but they were really surprised to learn that I was able to install a plugin that actually enabled inspections for languages that Upsource doesn't support out of the box, like Clojure. 
This video doesn't make a lick of sense. It's about PHP personality tropes within social media that he doesn't like; has nothing to do with careers, unless this guy was the boss of everyone.
I think he is talking in a general context. You have to communicate to the users who use your software, you have to communicate with your clients to understand the requirements, communicate with QA, and finally be a good team member. I am not saying you have to agree with everything, but to know how to handle different situations, not only technical ones.
https://twitter.com/Dymaxion/status/464645883100139521
&gt; I don't know where you're from but here it's normal to substantiate gross misconduct before firing someone. Yeah, that's generally the way it is where I'm from as well. And this guy was a big enough asshole to those around him, with no desire to change after multiple talks from people on multiple levels, that he deserved to be fired. &gt; I'm guessing you fired him yourself, based on your feelings, or at least contributed to it Not really. He got fired by the head of development. His boss' boss. I didn't mention him to the head of development, neither did his team leader. I'd had conversations with him as a coworker trying to see if we could communicate better as coworkers, his team leader had had previous discussions about him and even the head of development had had previous discussions. This guy was an obvious toxic influence enough so that he independently caught the attention of the head of development who oversaw some five or six teams. &gt; because it doesn't sound like you had firm grounds for dismissal Like I said, I don't want to go in to the specifics of the exact day he was fired, it's not my story to tell. But there was reason enough &gt; Firing someone because they ask what's wrong with a piece of code is especially odd As I tried to explain, it wasn't *what* he did, it was *how* he did it. When no one wants to work with someone, and their name has become associated with just being an asshole, the little things stop being so little. &gt; there's entire subreddits and other websites dedicated to that, but I'm guessing you're not a big fan. Code reviews were mandatory, and I'm very much a fan of that. I love code reviews. That's separate from him being an asshole.
This guy sounds like a pompous ass and his entire point should have taken far less than 4 minutes to communicate.
Dont be a robot. He isn't trying to re-define what programming is/means. The point is that you don't just magically shit a program for the sake of doing it. You are solving a problem, doing a job, working a project, fixing a bug. You need to communicate with people to do this effectively. 
em·pa·thy `empəTHē` *noun* the ability to understand and share the feelings of another.
No. I've never actually seen it in action. But I'm a sucker for tooling and automation. 
I'd like to suggest it, but it's one of those things where having the whole team work with it makes all the difference. By itself it's grand, and being able to comment and respond to review comments inside your IDE was wonderful for me, as was having the static analysis inside the web interface. But it's Github integration isn't perfect, and having one or two people working with Upsource for reviews and having the rest work with Github does have some issues now and then. Still, it's free for 10 users or less. If you want to take a look, pull it down, run it locally (though it chews through RAM) and sync it with your Github repo just to see what existing reviews look like in Upsource. It's fun just to play around with it anyway
&gt; free for 10 users or less Ah, thank you. I didn't see that in their pricing. I could totally install that on my dev server just for my team. 
I think we've gone too deep.
Enjoy, and good luck
Or to his comments in this subreddit.
It's not really about PHP or its community at all. It can apply to any community. I'd say it pervades the JS community more than PHP but it's not even specific to programming. Don't be a zealot, don't belittle people that are just learning for not knowing everything you do, etc. The title is a bit hyperbolic IMO. For example one of the "career ruining" points is "suggesting unrelated material in response to a twitter thread."
Can confirm, however some portions of the process can be updated since the book was written. Specifically, the book doesn’t use composer autoloader, but you can and probably should modify your process to incorporate composer.
Good luck! I like how you called it mem**e**cached. ;)
Experian promised that no critical and sensitive info would be exposed, and here we are.
Right. As if all developers could even give a single shit about Twitter.
&gt; Memecached I need some of that in my life
Guys really? Lol
At least he wasn't playing video games all day ;). Also, reddit during business hours sir, somebody should tell your Head Of Development.
That is super interesting! I'm kind of bummed I didn't know about that before writing this. I've added a mention of the library to the article so hopefully other people can see it too. Thanks for letting me know!
he claims the last election's "problem" was triablism, well a lot of people obviously dont feel there was any "problem" with last election, also it insults people by implying those who voted didnt make any kind of rational choice. he then continues to talk shit about capitalism and makes a few other left wing talking points.
its advice from the "participation trophy" generation.
I see, you're looking at programming itself, the act of writing code, rather than programming as the whole the process to make an end product. Individually, once we know what we're working toward, what our part of the big picture is, you're right, programming itself doesn't really require a lot of communication. It still might require some, like when you're integrating a feature with code from other devs, or run into a conflict with someone else's code. But the main point being made is that as programmers we need to be good commubicators. Because coding itself is only a small part of what we do.
&gt; We're talking about tribalism. We've seen the impact of tribalism for American folks who saw what happened in the election last year; a very good example. Elections come down to tribalism, and people like to group together with other people who are like them. But at the same time, tribalism turns nasty when you insist that only the things that your tribe enjoys are worth anything. He didn't use the word "problem". If anything, it sounds like he's putting the blame on both sides. In the 2016 election, there was undeniably a lot of mudslinging and negative tribalism, and he's commenting on *that*, not the outcome of the election. &gt; he then continues to talk shit about capitalism and makes a few other left wing talking points. He says he's not a big fan of some startup cultures, but I don't remember anything particularly anti-capitalism or pro left wing.
So you invented a time machine, you need to travel to the late 90s but you need a job there, hence PHP 2. At least that's what I choose to believe.
If you’re there, just buy some Apple and Google stock. If you insist on getting a PHP job, at least wait until whatever year Composer comes out.
Also - Bitcoin.
You have a good 15 years to wait then
I haven't been too long into the business yet but analyst usually fixades the problem and gives you an overview of things. If you want a good result you need to talk with the people who are gonna use the stuff whatever you are working on and you need to understand what you are doing well. Again I am no veteran yet at programming but so far it seems that good communication is a must, it minimizes the dangers of messing up and you can add your own input on the project you are working on. 
[@Dymaxion's latest tweet](https://i.imgur.com/VsAQpYx.jpg) [@Dymaxion on Twitter](https://twitter.com/Dymaxion) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Instead of trying to fight with PHP on Windows I truly recommend you install WSL (bash on windows) and and run Apache/PHP in there.
Kinda concerning as a Drupal dev, but I suppose makes sense for all of the reasons that have been mentioned. There are areas where things need significant change to improve. Documentation is a big one. I needed to do an incredible amount of learning and re-learning to be even somewhat adequate at producing custom functionality, there are no great examples to work from and there is no clear learning path. I can understand the frustration and the dread. Anecdotally speaking though, I'm encouraged by the enthusiasm and energy I see in the D8 community, and working with Symfony, Composer, PHP7+ is really a breath of fresh air. Drush 9 and composer-managed Drupal is slick AF. There are still things to be optimistic about. 
+1 for having $iterable argument last. Soonest to know value first, really make partial application easy.
We got on fine with butterflies. Now get off my lawn.
&gt; the "participation trophy" generation. He sounds too young to be a boomer
I thought the "participation trophy" generation were the same as millennials.
Boomers invented participation trophies because they were upset their kids werent getting awards, millennials were just toddlers at the time.
create composer.
My bad. Thanks.
After the Google and Apple stock pays off, make sure you take some profits and go into Amazon, Netflix, and Facebook pretty early.
You're _really_ trying to make what he said into what you want it to be rather than what it actually is.
I've experienced this myself. My background was totally different than my colleagues. I was a blue-collar worker who still is studying something different than computer science at a distance university. I did a vocational training in computer science afterward. I have worked with people who couldn't accept my advice because I had less work experience than them, even though I was more capable of doing so (in the eyes of the seniors). (Knowledge !== Work experience) Nowadays where I am working, there is barely communication between the coworkers, and I have been experiencing for several months a toxic environment. Harsh critiques, non-constructive/sarcastic comments, not complementing workers for their good work but only seeking the negative aspects. I myself reached a point where I didn't want to keep on working as a programmer and do something more labor intensive. I wished every day that my boss would fire me so that I could leave the company during my probation. They all recognize that I am very knowledgeable but every once in a while, it seems for me that I am at a playground, where if I can prove you that you are wrong, then I'll obliterate you. Nowadays after several discussions with them, at least they are opening themselves towards self-critique and being more empathic. 
&gt; I myself reached a point where I didn't want to keep on working as a programmer and do something more labor intensive I found myself in the exact position 2 years back. If you're able - and I know this might not be the case - start searching for another job. Searching and exploring your options doesn't mean a new commitment. I've had a passion for programming since I was 13 years old (23 now), and wanted to leave it all behind because of the work environment. I'm so happy that I took a step in faith and just applied at another company. I didn't know what to expect, but I figured that I could still completely switch after a few months or a year. Best decision ever. I love programming again, not only during the work hours, but also at home.
&gt; I recently tried to figure out how to get Xdebug to work from Docker (using phpdocker.io) for IntelliJ and still haven't figured it out. Try it with this "hello world"-y project, there are PHPStorm instructions: https://github.com/DHager/docker-php-library-demo 
The format was a 10 minute video.... yeah fuck that dude.
I don't know what phpdocker.io is, but you may need to set an environment variable through to `docker-compose exec` or equivalent that tells Xdebug where to route to. [I set up an alias in my shell like explained here](https://github.com/dailyinfo/symfony-flex-docker-compose/blob/master/README.md#xdebug) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dailyinfo/symfony-flex-docker-compose/.../**README.md#xdebug** (master → c0b5e0d)](https://github.com/dailyinfo/symfony-flex-docker-compose/blob/c0b5e0d2c95baf91253e169cd2ab298367566326/README.md#xdebug) ---- 
Don't forget bitcoins.. Sell them a 20k...
Go deeper. Create bitcoin and the blockchain.
Behat. Make it click all your links and forms, make sure the code works. Then start unit testing. By doing that you will by necessity rip the code apart. Does the unit test pass? Great! Does the behavior one still passes? Perfect, keep refactoring !
Thanks for your help I was already contacted by Sam from the group. All settled!
For when you want to build a *Personal Home Page*!
Downvote all laravel posters. Report all laravel posts.
Thank you for voicing your opinion, ScottBaiosPenis.
I'm interested to read this, but it's a bit hard to take anything by the WordPress people seriously. That's the worst codebase of any PHP project I've ever seen. They don't seem to have a clue about modern development practices or design paradigms. It's like working on procedural code from 1998. So it totally makes sense that a highly opinionated tool like Phpspec wouldn't work well for them! Still, it will be interesting to see what they have to say.
The changelogs are informative, I've looked at them before.
Want to add asynchronous MySQL queries to your project without needing to convert to a full fledged asynchronous library? MySQL has this built in and my new project will help you use it! Check it out! https://github.com/johncurt/async-mysql Would also love to get your input on possible improvements!
Agree and suggest that if using Windows for php dev that you look into a simple vagrant box and test/run your code there. Vagrant is free! PHP is definitely a good choice for freelance work. It’s easy to learn, free, there are tons of free tutorials and articles to get good information. It also powers 80% of the web, so there is always work to be found. If you have a local php user group I highly suggest you go to some meet ups! If they are large enough (30 people) they might even be raffling off free yearly subscriptions to PHP Storm (an excellent IDE for php!)
thanks everyone for replays! currently i am already using vagrant and i am impressed with its powers. like i can do literally anything with that linux shell + i can use windows gui so that vm does not hurt my toster pc so thanks all of you! currently i got job opportunity as node dev,so i will have less time learning php since rn i am high school student + i will start working in two months as node dev and i have to work on node more! so yeah thanks all of you ❤
Somebody pays for your code. Unless you're the person in the sales cycle pitching work, there's going to be another person/team with whom you will have to convey your work so as to convince the product team they can instruct billing to get dat money. As another said, after machine code, it's people all the way up. 
Remember when you came across a piece of code written a few months prior and had no idea what it was doing? That's because it wasn't communicating well to people (namely, future you). Getting the computer to do what you want is usually easy, but code is rarely written and forgotten. Someone will have to come back to your code in the future and figure out how to modify it to fit new needs. Writing code with the goal of it being easily readable and understandable by others is what makes a code base easy and pleasant to work on.
I compiled a [list of resources here](https://patricklouys.com/resources/) for intermediate/advanced topics that are PHP related. The books aren't free, but the rest is. For frontend resources, this is probably the wrong subreddit...
Awesome thanks :) 
Hey, recursive code can be confusing and frustrating at first, so instead of using simple functional recursion, let's use some references and make it even more confusing, frustrating and error prone! This is a terrible article. The example used is unclear and hard to follow - examples in articles like this should be simple to understand what the code is doing and what the code wants to achieve. Additionally the article fails to discuss what references actually are, how they work, the dangers of using them and how to mitigate them. It would also be nice to see some discussion of alternatives and a comparison with details of trade-offs.
Not OP but I've had to refactor legacy code from a company who began during PHP4. There was a settings.php file which contained every single setting that could ever be used on any page. Apparently this file started small, and every developer they had before me would just keep adding to this monstrous file. Every setting was accessed either directly through `&lt;?php $templating ?&gt;` or through calling the global keyword in a function that took no arguments. There were hundreds of variables by the time I got there, and each chunk of variables had their own style depending on which developer was doing them. There was a small chunk that was keeping things stored in the DB, but to retrieve them they did a for loop which connected to the DB and retrieved 1 result each time for `n` variables. The worst part about all this is it was part of their bootstrapping (no caching) so it would have to go through this for each and every request. I can sorta understand had they used a global bag object or array, but these things were just littering global space and was very annoying if I decided to use a variable name that (I didn't know) was used somewhere else. Cleaning that shit up was a nightmare. 
I have found out that PHP3 have attached CHANGES file explaining major differences between PHPFI/PHP2 and PHP3. It can be found in tar in museum.php
I would create Reddit, and made sure 0.000001 of each upvote is redirected to my karma.
A programmer translates HUMAN to COMPUTER and back. So the real answer is you need to understand both. 
this is one of the best laravel packages out there, it is simply amazing
Can I get something useful from this library if I'm not using Laravel/Eloquent/Blade? 
Well, it's difficult to give you a feedback without looking through a lot of code or without using it, but I think it's not the case of re-inventing the wheel. Sometimes, developing a framework (even knowing that you're not going to become the next Laravel or something), helps you understand most of the complex tasks a framework should do. I think that "re-inventing the wheel" is the most important way to know how things works and from that knowledge, you'll be able to figure out how to make something different and even better than everything we have already, so IMHO, it's not waste of time.
Inspiration to create the same functionality for your favourite framework
You are basically confirming what you are denying. "a lot of people obviously don#t feel there was any "problem"". Exactly. Because "their side" won. Because of tribalism. There are more people who are happy trump won over hillary, than there are people happy with trumps actions as a president. People are not happy with the situation because Trump is such a good president, but because it was their choice and "the other one" lost. Politics have turned into what used to exist only in the stadium at sports events. Now the rest of our society turns into the same thing. No logic arguments, just "we win, you lose". Tribalism does not allow for everyone to win. Winning is only if others lose. That's not a civilised way to live together. That's why we don't live in tribes anymore.
3) save yourself some hassle and start using a free operating system like GNU/Linux! If you're gonna do real work on your computer and if your works is programming, come on, use GNU/Linux, everything will be much much easier…
http://www.nusphere.com/kb/phpmanual/migration.htm
Fair enough :-) 
Sounds like a solution to people’s griefs would be to roll it into an appliance that people could run and secure themselves. Of course if you went that route you’d have to come up with a brand new revenue model. But an unknown player asking for server credentials, thats a tough hill to climb. 
I'd also add Exakat to to the list of static analyzers. By experience, such tools are usually complementary : list of rules are different, and searching methods are also different, leading to various results. Just pick the one your like the most. 
Have you run update for the packages?
I wonder if PHP is actually reading environment variables or if that is information compiled in.
Yessir, 0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded Nothing to update.
Try cat /path/to/php.ini |grep .ini and see what loads, see if you can pinpoint the system information sounding one 
Until WordPress itself stops supporting ridiculously outdated software, that's not going to happen.
No worries it happens :) 
Hey guys so we are using a database where we upload a showcase of a house. Uploading images on the database puts the images on a images folder in xampp. I was wondering if there is way to make a unique folder every id so that the images uploaded in each id goes to the corresponding new folder. Thanks in advance!
This. People ask me about plugins that aren't even listed as compatible for the last four years of WP, they WILL try to run them on the old PHP versions that WP runs on.
"Not Gutenberg or REST API, don't care" - Mullenweg's response to everything I feel like the last 18 months
Apart of the main message: do not support outdated and already "dead" php versions it is open source. I mean if you get triggered soooooo hard about the fact of old versions of plugins which are not compatible - why not simply modify the part of compability check in wordpress or just simply start by removing old code from wordpress? Nobody has the right to simply expect the devs to fulfill your requirements because there are a shitload of hosters which do only support legacy php versions or wordpress installations and also will support only those versions no matter how insecure these installations are. I guess eventually you would help the community and yourself
And the plugin developers won't until WordPress does. It's on WordPress to pull the trigger. But they like to hold on to their "80% of the internet runs horrendously unsecured code from 6 years ago" statistics.
&gt; And the plugin developers won't until WordPress does. We stand a much better chance getting something to change by convincing plugin developers to require PHP 7.2 than we do expecting WordPress to do it themselves.
The people making money from plugins aren't going to reduce their market share on morality alone. If they make their plugins only run on 7.2, then I now have a significant market opportunity for making my plugins run all the way back to 5.2. It makes no sense for this to start with the plugin developers.
Start with the free-as-in-beer plugins, then.
They already exist, but they're not a driving force by any means. Consider that a large percentage of popular WP plugins are already coded by monkeys and are full of dumpster fires. If they don't care enough to write good code to start with, why would they care that it runs on legacy PHP?
Sorry but I think that's a stupid idea. For starters, I don't want my repo full of half a dozen configuration files for whatever editor the user chooses to use. Secondly, I don't want other people's configuration to override my configuration. I've spent years personalizing my IDE and I continually make changes to improve things. And furthermore, I don't want to work in a place that forces me to setup my development environment to *their* standards. They are *my* tools. They are customized to *my* preferences to maximize *my* productivity. Each team member should have this freedom.
Yep. Their stuff is super solid, and I mainly use their stuff in every language that I work in. I'm so glad that Rider is maturing, so that I don't ever have to use VS again.
&gt; How much of this is driven by apathy, and how much of this is driven by ignorance? I think the question is, "how much of this is driven by money", and the answer is all of it.
Bringing up something beautiful and good as a knockout argument doesn't help conveying a certain point either. The points brought up such as for example that posting "that's why you should look into X" on social media would lead to broken careers is still a non sequitur. The chain of reasoning is non-existent. Just saying "but EMPATHY bruh" doesn't change that.
This issue might be bigger than most people realise. At this point, even PHP core development is being hold back because they don't want to break compatibility with WordPress. With WordPress holding back to break compatibility with ancient PHP versions, the vicious cycle is complete. The responsibility to fix this is really by the end-users. As long as they keep running ancient versions of any package, nobody will drop support because it would just have too much of a security impact. The problem is that end-users in this case are probably the hardest group to get moving because 1. The sheer size of it, 2. Most of them aren't that tech-savvy, and 3. there's no benefit for them. I had hoped PHP7 would change this because you get literally twice the speed for no extra cost, but seeing the stats even that's not enough to push people to update their shit.
That oversimplified worldview would be useful if only it wasn't [so wrong](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-01).
Legacy support is a good thing for the most part. 
It might not be for everyone, I agree. Not everything *needs* to be shared, not everything is shareable. For example keymaps, themes, the way windows are arranged and etc. There's plenty of space for customisation. I assumed that if I have a way of raising *my productivity* - it would be beneficial to raise my teams productivity too :)
WordPress is the platform, WordPress is the one that defines which PHP should be supported. 
I used to maintain a WordPress plugin which was reasonably large. I didn't support old versions of PHP. No one really ever complained after I told them how to get it working.
No, it's not. It's stagnating innovation and making your product worse on purpose.
We always commit file templates. Everyone is recommended to use jetbrains ide's, but free to use whatever tool they prefer. Deviate from the file templates though and the work is not accepted until it conforms. I too appreciate when I can work freely, but if a company wants you to use their standard and they pay you for that service, you should. Might be a deal breaker for you, but not for me.
It needs to drop its insane backwards compatibility also. To give an example I was looking at the other day, consider [wp_login](https://developer.wordpress.org/reference/functions/wp_login/). It was added in 1.2.2 (released December 15th 2004) and deprecated in 2.5.0 (released March 29th 2008). That means it was alive for 3 years and 3 months, and has been deprecated for almost 10 years now. 
It is not. PHP 5.2 is insecure garbage, and supporting it (whether or not it's still being used) comes with the cost of your code also being less secure and significantly less performant than it should be on PHP 7. On a large enough scale, it's a significant waste of resources - the operators' money (for needing to pay more for hosting), the users' time (for waiting longer for pages to load), and ultimately energy.
Legacy support for people that offer active maintenance is great. (Redhat, for example, will ship you software past its EOL but will, as long as they ship it, also provide support for it and backport security fixes.) Legacy support that allows people to get away with running unmaintained shit is bad.
&gt; or warnings when assigning variables in conditions. What's wrong with that?
As a plugin developer, I don't want to support legacy PHP versions. Users running older php are still going to install my plugin and complain that I crashed their website. I have two options: 1) support older PHP or 2) have conditionals at every point to handle unsupported methods. If I am going to put in the effort, I would rather go with option 1. WordPress can solve this problem very easily. They should add a minimum PHP parameter to the plugin fields. Only allow installing plugins which are compatible. That will also prompt the users to upgrade their PHP and we will all be happy.
&gt; he claims the last election's "problem" was triablism, well a lot of people obviously dont feel there was any "problem" with last election There's tribalism on both sides, and there's tribalism everywhere, not just politics. And it's a problem. Look at you - someone expressed an opinion that could vaguely be interpreted against your tribe, and you're **pissed off as all hell**. That's what tribalism does. &gt; implying those who voted didnt make any kind of rational choice. Do you find your behavior is rational right now?
Company rules, but I do agree with that one. Assigning variables inside condition statements isn't to my personal preference and there is literally nothing to gain from not assigning a variable before checking it's contents. If anything it's easier to read separate declarations.
 $entity = $repository-&gt;findOne(1); if (!$entity) { // 404 } &amp;nbsp; if (!$entity = $repository-&gt;findOne(1)) { // 404 } These are both perfectly easy to read, but one of them has unnecessary extra lines.
Legacy support is a mixed bag. On the one hand, aggressively dropping old version support like Doctrine has started doing (and a fair number of developers in the ecosystem in general) using the argument of "upgrade your shit" doesn't win over a lot of folks. On the other hand, never dropping support for legacy things (removing deprecated APIs, raising minimum versions, etc.) is what is driving some people crazy because at that point you're holding on to legacy support at the expense of something else in a not-so-good way.
&gt; That will also prompt the users to upgrade their PHP and we will all be happy. Probably like 98% of WordPress sites are on shared hosting, so the users have no control over it. I'm not really sure who is more to blame here: shitty hosts that run outdated PHP, or WordPress for supporting and encouraging them. Either way, they both suck, and they both need to get out of the dark ages.
https://github.com/phpsci/phpsci PHPSci is a PHP Library for scientific computing powered by C. Although still in the initial phase, the fork with partial implementations of PHPSci with PHP-ML demonstrated a gain of up to 98 times in performance for the calculation of square matrices. PHPSci: https://github.com/phpsci/phpsci PHPSci-Extension (mandatory): https://github.com/phpsci/phpsci-ext PHP-ML Fork: https://github.com/phpsci/php-ml 
To a child most adults look evil.
A PHP application can easily choose to make new folders for images based on certain criteria (house ID, image name, etc.). That's in your application logic, something that we can't answer without you sharing more about your app. Check out /r/phphelp and post some details if you continue having any trouble. :)
Here's a sneak peek of /r/PHPhelp using the [top posts](https://np.reddit.com/r/PHPhelp/top/?sort=top&amp;t=year) of the year! \#1: [Join the battle for Net Neutrality! The FCC plans to kill Net Neutrality and it will affect everyone unless YOU fight for it!](https://www.battleforthenet.com/) | [4 comments](https://np.reddit.com/r/PHPhelp/comments/7eoq2o/join_the_battle_for_net_neutrality_the_fcc_plans/) \#2: [First time writing OOP can anyone check im on the right track.](https://np.reddit.com/r/PHPhelp/comments/65qzgl/first_time_writing_oop_can_anyone_check_im_on_the/) \#3: [Tutorial on getting xdebug to work with phpstorm?](https://np.reddit.com/r/PHPhelp/comments/70ho0c/tutorial_on_getting_xdebug_to_work_with_phpstorm/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
And so much worse if the control structure is a `while` rather than an `if`. What's the alternative there - `while(true)...assign...test...break`? More lines and hides the control flow by splitting the conditional from the flow control statement. Or how about `assign...while(test)....assign again`? At least the control statement is responsible for flow now, but you've had to duplicate the assignment, and the input for all but the first iteration's test is now at the bottom of the loop. And all to avoid writing `while(test assign)`.
I've started to do this recently, here's what I found: What you must not commit: - workspace.xml What you shouldn't commit: - {project}.iml What you can't commit but wish to: - remote path mappings for debugger - dev database settings - excluded folders setting - "initialize composer" settings - automatically mark some plugins enabled (.editorconfig, symfony2...)
Inspections aren't just for style. :)
FWIW I'd recommend just using https://plugins.jetbrains.com/plugin/7566-settings-repository
It stores list of installed composer packages. So it changes each time packages are updated and is another potential source of conflicts and noise.
Yeah, but the way he presented it seems to be more like my example, which is neither valid nor invalid. Your example isn't controversial and shouldn't be a "company rule", it's just plain wrong.
Does this allow somehow select what is shared and what is not? I thought this is more for personal IDE settings, like themes/keymaps and etc., that have nothing to do with the project
https://github.com/nkkollaw/zubr-php? Though it's not a PHP namespace.
Thanks, that might just be it.
&gt; I've got a challenge for you. The next time you start a new project, try not using a PHP framework. [Uhhhhh](https://paragonie.com/software) ^^^(Most of this is framework agnotic)
I have a design draft somewhere called Criterion but I can't recall if that was ever open sourced. It sure as hell wasn't finished.
Quick note, the plugin is bundled directly into PhpStorm. For reference, see https://www.jetbrains.com/help/phpstorm/settings-repository.html. 
Added Paragon's software to the post! Thanks for all the work you've done trying to push the PHP community forward on security, btw. I've benefitted tremendously from Paragon's blog.
Aww thanks! We're always happy to hear that we're able to help others. :D
DigitalOcean tutorials are usually good. here is one for LEMP stack https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-in-ubuntu-16-04
not sure if people said this or not, but if the app is too old and hard to refactor, one way of dealing with this is by, having dual stack, create new app for the front-end and re-create the components one by one and if the page does not exists yet in the new app proxy it to the old one. I personally found this to be the best way to deal with old untested legacy code, and have 0 risk of breaking something unaccounted for in the old app.
You know what would do this job for free. Naming the input as an array. Then there would be no need to convert it to an array. &lt;input type="hidden" name="namespace[buttons][0][name]" value="Test 1"&gt; What's happening in the article is iterative programming, not recursive.
The article says "try not to use a framework" and then goes through all the cliches of a modern framework: the over-designed DI container, the pointless middleware chain... I mean... why? If you want to grow as a developer, as the article suggests, maybe you should stop reaching for all the comfortable components that every framework has and start putting some thought in what's the actual value provided here and is this the only way to do what this component does.
Thanks for the constructive criticism! I might edit the article and add some information about why that didn’t work in my case, as well as how to do it that way as well. The article was more of an exercise of logic and thinking than anything else, and, as stated toward the end, purely opinion as to what is more readable to me. In my case certain elements of the array were actually left out and inferred in the final implementation. My code didn’t have anything to do with buttons but subcomponents of nested rules, specifically a special rule that allowed for logical application of other rules (using and/or). For example, anything with a number got another level shimmed in - (to keep with the buttons example) leaving out the “buttons” level in the form, but adding it in for the final object that’s created. Each rule had its own set of inputs, the advanced rule having unlimited ones (and even nesting with additional advanced rules to allow for things like ((a &amp;&amp; b) || (c &amp;&amp; d)). Lastly, I wanted this to work off the shelf for singular, non-namespaced form names. Thanks for pointing out the fact that iterative is a better term since this is using a loop as opposed to a function. I still find it to be a somewhat grey area because of the use of the referential variable, but agree that iterative is a better concept here. I appreciate that you took the time to actually read and consider my work and commented! Thanks for helping me develop as both a blogger and a coder!
This sort of thing could be beneficial to someone who only knows PHP from inside a framework, but I imagine those people who have only ever coded inside a framework are pretty scant. Perhaps if a developer came over from another language into a PHP shop then this would be more likely, but even in that scenario they are likely a well-rounded developer. I think this is a fun sounding exercise, but in practice, having worked on PHP 4 framework-less garbage code, Code Igniter 2 (still supporting one of these), Cake 1-3, Wordpress, Magento, SlimPHP, and several others I can't recall at the moment I do believe I will be fine without this practice.
Never liked it and in my early days I always felt inferior for not really understanding why you would do this. Vindicated years later by deprecation. Damn deprecation feels good sometimes.
Definitely it, I remember seeing this too a handful of months back.
I feel it's WP + Web Hosts responsibility. Most of time end user of WordPress use Shared Hosting (mostly cPanel like kind of stuff). It's dumb to expect end user of WP to ask web hosts to upgrade PHP. If they were this much technical, they would be using at least a VPS (not some random cPanel). Same with plugin developer. You don't want to write a plugin that doesn't work on 90% installations. If WP (platform here) support old versions, why shouldn't plugin developers target that version? The best way is for WP organization to deprecate old releases (while asking users to ask their web hosts to upgrade PHP as a big notice everywhere, and until they upgrade PHP, don't let me upgrade to a major WP release. Not wanting to lose customer and avoiding customer tickets is the best incentive for Web hosts to upgrade their PHP. 
&gt; I imagine those people who have only ever coded inside a framework are pretty scant. Oh, my sweet summer child.
I had the same thought earlier today. Would it be useful? Absolutely. I guess the only way to find out is to find someone willing to create a patch and author a RFC.
Challenge for you: write a framework smaller than your post that does all that.
why?
Ha, I was *just* about to comment to say that the whole point was to encourage devs who have never worked without a framework (which is a rather sizable audience) to just go one level closer "to the metal". The point was to elucidate, not prescribe. Glad to see someone actually read past the 3rd paragraph!
If people want to "grow as a developer" then the best exercise it to go use other languages, go learn functional programming with Elixir, go try Golang for a different take on OOP, etc. For those that never venture outside of PHP trying other languages might also broaden their horizons beyond simply experiencing new languages. Take frameworks as we are on that, this may come as a shock, but there are other languages where the mainstream culture is either to use very lightweight frameworks (Node.js for example) or no framework at all (Golang) and then do rather as this article describes - go get the packages you need from NPM, Github, etc, as opposed to PHP where the two most popular frameworks (by far) are both rather monolithic (yes Symfony is improving in this respect). 
Why not test the version yourself as your plugin loads and self aborting if the version isn’t what you want? You could throw out an admin notice stating why your plugin isn’t active and it wouldn’t bring down their site.
No, that's called the Elvis operator, which is generally used to check for truthiness. `empty()` is essentially falsy plus `!isset()`.
Definitely talk to Taylor. I've never once missed an email for billing with Forge. Taylor should be able to see that your account didn't get used. 
It works, https://3v4l.org/tPdU4
I think the point is kind of the opposite of the title, really. I recently read a very similar guide and I think what you learn from this is how to build an (air quotes) “MVC” style framework from standard tools like a router, request/response objects, DI, etc. Once you know how to make a basic framework I think the next step is what you’re talking about.
Is redpill a composer package? I can’t find it. Is it Laravel compatible?
Ok so the proposed empty coalescing operator would replace `$username = empty($variable) ? $alternative : $variable;` right? Like `$username = $variable ?: $alternative;` . But it's possible I still don't understand.
to be frank, nowadays you don't have to mess with the whole stack. the built in PHP server is good enough for development. it works everywhere. the database is interchangeable if you're using any kind of abstraction layer (which I highly recommend). you can use SQLite, so you don't have to mess with sockets and users and alike; it's all file based. also: pick a framework. any big framework. this way you can absorb some good practices before going on your own. :) 
?: works for all values considered empty except undefined ones. I don't think you can justify more syntax just for that.
Come on, are you trolling me? I literally said in the [initial post](https://www.reddit.com/r/PHP/comments/85xor7/empty_coalescing_operator/dw110nu/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=PHP) you responded to that `isset()` and `empty()` don't throw errors if the variable doesn't exist. You then bizarrely proceeded to post a test. Then you claimed "it's possible I still don't understand". And now you finally understand the difference, but are saying that I can't justify wanting a shorthand for my desired result. You're right, I can't justify it. **Oh wait, there's this thing called the null coalescing, which does exactly that, but for `isset()`**. I know I use empty a ton, and I'm sure many do as well. Seems like a feature a lot of people would find useful. 
But it's soo easy!! 😭
In the beginning I thought this was going to be a really good article to link to a friend of mine to get him on the framework bandwagon but when the author started slapping a bunch of libraries together I changed my mind. Literally everything that's valuable about making your own framework has been outsourced to a bunch of different libraries and only the completely trivial parts we do ourselves. We're essentially still using a framework but without all the benefits of a framework.
[removed]
I'd say that is a perfect world example. Generally speaking sooner or later some new guy end up with the following, which to me is not easy to read. if (!$entity = $repository-&gt;findOne($entityId) &amp;&amp; is_array(($items = $repository-&gt;findMany('field', $entity-&gt;getId())) &amp;&amp; count($items) &gt; 0) { foreach ($items as $item) { I think the rule is very good. It's not like it's more code, especially in your example, more lines should not determine if something is an OK practice or not. Personally, I would never use the exclamation operator either unless I'm inverting something I'm testing against. So `if ($entity === false)` would be my preference, which also is type-safe. In that scenario you'd have to work with yoda conditions, which is even less to my personal liking, and usually not allowed or frown upon by many projects. `if (false !== $entity = $repository-&gt;findOne($enittyId) {` I guess it comes down to personal preference, as far as coding goes - but if the company has a specific set of standards, I'd say it's best to follow them.
Great work, great features. What are your plans with v6? (We're happy users, but have to postpone upgrading a bit ... ;) )
Who wrote this is so full of shit, God... An application without a framework, then he goes and write his own framework. How is that better? If you use a framework the code has been tested by thousands of people, and you have less chance of ending up with bugs... Reinventing the wheel is never the answer, only pretentious developers do that. I can understand to use this approach as a way of learning how things work under the hood, but otherwise you are just reinventing the wheel, and rule number one on programming is "never reinvent the wheel". 
Can you provide table of truth for "empty coalescing" operator and "just coalescing operator" ?
I'm sorry I don't understand your question, you're running a while loop while something is true, but you don't want to assign it? while ($iterator-&gt;hasNextRow()) { $row = $iterator-&gt;getNextRow(); } Are you saying you would rather; while ($iterator-&gt;hasNextRow() &amp;&amp; $row = $iterator-&gt;getNextRow()) { // Do something? } I can't say I see the difference, other than that the first one is easier to read. Just running `while (null !== $row = $iterator-&gt;getNextItem()) {` means you're potentially trying to retrieve a row that doesn't even exist, and what if one API throws an exception in such case?
This is on WordPress to at least put in the ability for a plugin to declare its php version. Then WordPress can decide whether to install it or not. Composer has been doing that for half a decade now. WordPress could have been doing that too.
There was something else I saw that did have a php namespace as one of multiple solutions.
&gt; even PHP core development is being hold back because they don't want to break compatibility with WordPress How so? Do you have an example?
Why there isn't some enforced means of specifying a minimum version of PHP on a per plugin basis seems a bit odd. Just having it display on the plugin download page is really soft.
So...basically the same business model as LaraJobs, give or take the point at which the poster pays for the applicants? I mean good luck to you, but I don't see how this can compete with the reach of the Helpspot and their alumni.
So...basically the same business model as LaraJobs, give or take the point at which the poster pays for the applicants? I mean good luck to you, but I don't see how this can compete with the reach of the Helpspot and their alumni.
It's a pity that moderators here are lazy asses who don't give a fuck to clear spam. 
Wait so I pay to receive applications? What if the applications are shit? I routinely get 100+ proposals on Upwork, are you telling me I wuld pay you $700 to get the same from you?
I think you missed the point :) Laralance focus on freelancers and freelance-hiring, where Larajobs target anyone looking for a permanent contract in a laravel-related job / company. Laralance wants to connect more freelancers so they can work with each other without having to pay a full price to post a job somewhere. I think it's pretty interesting. As for the Userscape and the laravel alumnis-gurus with their "uncompetable" apps.. well.. I guess you're right, but if the people of the Laravel community can provide a good platform that anwser to a specific need, I don't see why it won't fit in the Laravel Ecosystem. It's good that other people create other stuff
&gt; It's good that other people create other stuff I entirely agree. I think competition is healthy. I just don't see how this is different enough to give you a competitive edge. What stops me from posting a freelance opportunity to larajobs and having it syndicated through laracon online and laravel news?
Nothing stops you to do that, the goal is not really to "compete" but to offer something else that can be a better option for some people.
Yeah you know what, I think I'm mixing the RFC and the library up.
&gt;He didn't write everything himself therefore it's bad This is how retarded you're being. Not to mention the fact that the article *clearly stated from the start* that it is not another NIH article.
No you define your own limit, like 10 applies max or less, or more. We're thinking of a blacklist system so you won't get spam with the same candidates, or candidates that are badly rated
Why do you have yet another account? And why did you give it the same name? It wasn't even a good name the first time around.
Good job missing the point. The point is that building your own framework can help understand the internals of existing frameworks better which will help you become a better developer. I thought that this article was going to teach us how to get started with building your own DI/routing components. If I could show my friend how to build his own DI component that would be a good way to get him started with using exiting ones. It's hard to start using frameworks if you don't understand the problems that they aim to solve. I thought that this article would help new developers understand these problems but instead it just tells you to pull in a couple of sub optimal components and throw them together to make essentially your own framework.
Yesterday, I wrote a production ready app with authentication and my business logic in less than two hours. The only reason I was able to do this was because of the framework I'm used to working with. If I had to manually tie strings together it would have taken maybe 2 days to have the same result. Another example: before my current job, I worked 2 years and half for a company believing in the mindset that our own custom re-usable code (framework) was better than using an existing one. Here are the results: - Angry clients because projects only got half-finished and contained a lot of bugs - Spending more than double the amount of time needed on trivial things. - Worn-out, unhappy developers, to the point of me considering quitting programming altogether. I figured I'd become a train driver or something. Promoting a non-framework mindset in a commercial environment is one of the most dangerous suggestions to make, especially for younger developers who don't know better. By all means: mess around with your own code for you own projects. But don't do it when there's paying clients involved.
Edited: 100 per seconds and talking rough numbers. Good to see your numbers
Why? If there is not a feature that only PHP7+ has, there is no point in dropping support for PHP 5.x. Dropping support just because "dropping support" is totally pointless, and will only cause your plugin to have less users.
Yeah ok, so it's good to have a feel for how some of the lower-level components function otherwise there's not much to take away from this article except what a joke the immutable PSR-7 responses are: ``` $response = $this-&gt;response-&gt;withHeader('Content-Type', 'text/html'); $response-&gt;getBody() -&gt;write("&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hello, {$this-&gt;foo} world!&lt;/body&gt;&lt;/html&gt;"); return $response; ``` Ughhh ... we couldn't possibly new up a `Response` object we would violate the sacred rules of SOLI*D*. Make sure your DateTime objects are dependency-injected too kids! &gt;&gt;&gt; A brief aside: Autowiring can be a nice feature as you start building your app, but it generally makes maintenance tougher down the road because dependencies are still relatively hidden. How does auto-wiring hide dependencies? Your dependencies are still declared and explicit, but the dependency tree can be invoked with less cruft. Opinion as gospel. &gt;&gt;&gt; So there you have it. With just 44 lines and the help of several widely-used, thoroughly-tested, reliably interoperable components, we have the bootstrap for a modern PHP application You have &gt;only&lt; the bootstrap, and while the components _may_ be thoroughly-tested your bootstrapping isn't, but why spend time writing business logic or solving problems when you could be stringing together another framework. 
Loved your talk on empathy.
Some of it is principle. Personally I won't start on a new project today and make it PHP 5 compatible because aside from PHP 5.6 only receiving security fixes all PHP 5 versions are EOL (and no, I really don't care about the various Linux distros and their "LTS" support, sorry Ubuntu 14.04 users but PHP 5.5 is dead). Yes, I can write code that supports PHP 5.3+ without using some of the cool new things in newer PHP versions, but I honestly don't want to and I'm not going to encourage people to get started with new projects on dead platforms.
But if it doesn't cost the applicant, only the employer am I not going to get spammed with candidates that will cost me money to sort through? This is why upwork and every other freelancer site works in the opposite manner. With the applicant paying to submit a proposal 
The point is that the article teaches nothing of value to an audience that doesn't exist. It doesn't help advanced programmers and it doesn't help beginners either. 
It just doesn't help you.
I don't have any view of Fruitdealer's comment, but please consider that your response is far more toxic than the one you are responding to. I can't imagine the community wants to read this sort of abusiveness. You're now on my blocklist. 
Why are you shouting? 
I haven't given a talk on empathy. Maybe you're thinking of Matt Stauffer or someone else equally cool. And, in case this is sarcasm; I don't see this as a lack of empathy. I'm just asking "how is this different". I really do hope it works. I just want to understand _how_.
Ok, I see. Look, I hope it works out. Just trying to understand how. :)
For an iterator or similar that has a `hasNextItem()` then of course there's no problem. But consider for example: while (($chunk = fgets($file)) !== false){ ... }
To expand on this: my experience building long-term apps in a framework has been that, before very long, the framework version goes out of date. You have a window of time where you can do an upgrade (which will require updating your code to be compatible) before the old version is no longer supported and doesn't receive security updates. Any dependencies/plugins you used may not be so kind; their maintainers might just decide not to support their old versions that are compatible with the framework version you used. By rolling your own, the nature of this cycle changes. You primarily keep your dependencies up to date, which could require rewriting some code but these become smaller, more isolated stories rather than a monolithic project of "updating to Symfony 4". One of the downsides, of course, is that you are responsible for implementing best practices yourself. This is a tall order when you're busy at work with actual work, and a very tall order for whoever eventually replaces you.
 while (feof($file)) { $chunk = fgets($file); }
I’d just look at MS excel for reference. One thing to consider will be how expansive you want your language/country support to be. Numbers, for example use a comma separator for thousands in some country and a period in other parts of the world. I think you’re on the right track with abstracting the types under Field. If you’re storing this information I’d definitely look at a NoSQL database option like MongoDB instead of a more traditional relational database. Good luck!
How about a one-file 60-line framework: https://github.com/dexygen/jackrabbitmvc
Don't use a framework! Create a framework instead!
Thanks! There is a way to extend this further, but I want to have a good "base" set. As for storage - it already supports multiple persistence types.
Jquery writers beware!
Sure, if there is no api to get around the in-condition declaration of variables, there isn't. But, it doesn't change the fact that I think it should be avoided to the greatest extent, because someone will find a way to mess it up. It's better to prevent things that can be prevented, and known to be an issue down the line, than to accept it only to come back later.
You're right, he updated the namespace: https://github.com/nkkollaw/zubr-php/commit/b5e2416a3f7138199bdce46c7d563e36ad227f8d
Personally i wont start a new project today in PHP at all. Still there is lots a legacy PHP code that wont be ported to ”php7 only”. Theres lots of PHP code in maintenance only mode. There is no upgrading, only fixing bugs and adding very few if none new festures. I have zero enthusiasm about touching old PHP codebases, but sometimes i just have no choise, and then its nice if the old plugin/composer etc package still has support for older versions.
They used the [ATK framework](https://github.com/atk4/ui). Appear to 40 minute lessons, 5 total lessons (or rather, at least 5 lessons, was unclear if there were more), taught once per week.
Point 3 states &gt; Count() is undoubtedly a fast function but, if used in the looping condition, it calculates the size of the array on each iteration of the loop. Is this statement correct? Somewhere some long time ago I've read that internally PHP arrays contain `count` value, and this function does not actually count elements in array but simply returns the value of that "internal count". 
Awesome, thanks for the article! Super healthy exercise for any developer, engineer, architect.. etc to do. It also can be quite fun to try different design patterns out.
It's an on-going club.
I think the performance impact is less than it used to be in PHP4 but you're still calling a function which adds *some* overhead. Though, premature optimization and all that... This seems to be the best source on this subject: https://blog.josephscott.org/2010/01/12/php-count-performance/
Well it's the truth table for `empty()`, like [here](http://php.net/manual/en/types.comparisons.php). Though `!empty()` would be better imho.
&gt; I imagine those people who have only ever coded inside a framework are pretty scant. My unit doesn't use Drupal, but the vast majority of the other units within my employer do. Their developers are taught PHP on-site, and only within Drupal (6/7, not 8). If they had any experience with PHP prior to being employed, it's typically only from their college courses.
Nobody is saying "drop PHP 5 just because" - there's good reasons: 1) PHP 5.2 - 5.5 have all long past their end-of-lite date and anybody using them is relying on third-party packagers to provide **all** security updates to problems that may be found (which isn't guaranteed as the PHP core people won't care about issues that only affect &lt; 5.6) 2) Every version of PHP has added new features for developers (as the article mentions..). I would **absolutely love** to use namespaces in my code but because it was introduced in 5.3 I can't.
I actually don't know of any languages that have this, but for years I've thought it would be useful. I think `??:` would be pretty intuitive, and I think that's a good name, as it indicates it's a combination of the two.
I agree that would be nice too. But why not both? `empty()` is extremely common to use, and I think should be preferred on user-inputted values if falsy values are not allowed in the database column.
Just a quick one: &gt; We deliberately explanation of POST/SESSION until later time Missing a word in there :D Also, what are you teaching them about security?
you can already use something like this ($var ?? null) ?: 'var is empty'; I know, not one single operator, but at least without the need to duplicate the lhs
Yes, just what we need... another site dedicated to laravel and dividing the community cause life is hard out there for Laravel developers. This is getting old. Larastream, Laralance and more. I cant roll my eyes hard enough.
&gt; Is this statement correct? It's not.
That's a fantastic list that I will definetely will look into. Big thanks for your time and that you were willing to share your experience. If you'll ever manage to blog anything more about it - I'd love to read this. Thanks!
I'll post a link when I get to it! You're most welcome! I'm always happy to share/trade knowledge, and help those seeking to become better engineers!
Welp, my ignorance has been shattered.
Thanks for the article. It seems to have ruffled some feathers, but not sure why - it looks like a good ead to me. I'm a pretty confident PHP developer, but there's some stuff in there (autowiring) that I am not familiar with. I'll have a read through! 
It'd be weird if it were curated by Fortran developers
I have a tutorial that walks beginners through the development of a whole PHP/SQLite application, [here](http://ilovephp.jondh.me.uk/). It's intended for complete beginners, so may be too basic for you, but take a look - it's free and doesn't require sign-up. It's one of the sidebar resources for r/PHPhelp. As a side note, it is generally good to use a framework for production. However, from a teaching perspective, I like to use raw PHP, in order to give learners a chance to grok the language on its own. 
What about devops? Aye Aye!
That could work too. I also like the suggestion from u/johmanx10 of doing `??:`.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I really don't think we need more syntax to achieve this. ?: isn't used much at all so I'd rather be alter its behaviour than introduce new syntax. In most cases it will behave exactly the same, only difference is that it'll suppress exceptions, ie. empty() 
Doesn't seem that nice to me, lots of repetition. I'd rather see something like clojure's threading functions like: (some-&gt; o .myFail1 .mayFail2 .mayFail3)
Seems there are issues with it installing maybe fix those before advertising?
Ah, Magento. The WordPress of ecommerce applications.
Content security needs diagrams with all the actors in. I (personally) just cannot visualise who is trying to do what to who and which rule is supplied by what and enacted by which thing to protect whoever from something. I've never seen this clearly shown yet. Code is great, bit only after the concept is fully grasped. But it could just be me.
I would especially be in favor of have the Elvis operator become a `!empty()` check, like you said, if PHP adds support for short circuit variable assignment, like JavaScript: `$var = 'some value' || ''`.
Found this a while back: https://markjaquith.wordpress.com/2018/02/19/handling-old-wordpress-and-php-versions-in-your-plugin/. It shows admin notices in the case that WordPress or PHP are older than configured values. Been thinking to set PHP 5.2 as the baseline, and over time bring it up, at least in existing code. For new code, I'm more likely to require PHP 5.6+.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Every computer science professor I had either could not program or taught outdated practices. In fact the advanced HTML 5/CSS class I took as an easy elective was 50% dreamweaver (this class was in 2015). Not only did we have to work in dreamweaver but not one lecture covered HTML 5. The lectures were just reused every year and some of the code examples had HTML 3 in the DOCTYPE declaration. 🤦‍♂️ I nearly got expelled from the computer science program at my university when the professor who taught that HTML class failed me on my midterm because I refused to build my project in dreamweaver and had a heated argument in her office (she was the department chair). I already knew HTML and have been doing web development for years. I was stupid to think I would even learn something new and get an easy A at the same time. To clarify dreamweaver was not mentioned once as a requirement in the course syllabus or course description. That was my saving grace with the dean on appeal. So don’t get triggered by these idiots. I’ve found people who can’t program teach. Keep on doing you. PHP 7 is a beautiful language to work with IMO.
It definitely is. Try it yourself: &lt;?php class Counter { private $iterations = 0; public function __invoke(array $array): int { ++$this-&gt;iterations; return count($array); } public function getIterations(): int { return $this-&gt;iterations; } } $array = range(1, 10); // Count During Loop Conditional $counter = new Counter(); for ($i = 0; $i &lt; $counter($array); $i++) { // } echo 'Total mycount() calls inside conditional: '.$counter-&gt;getIterations().PHP_EOL; // Count outside conditional $counter = new Counter(); for ($i = 0, $count = $counter($array); $i &lt; $count; $i++) { // } echo 'Total mycount() calls inside conditional: '.$counter-&gt;getIterations().PHP_EOL; 
There's only one scenario where `empty()` is the best tool for the job, and that's for arrays. For every other scenario, you're better off using strict comparisons.
If you were to insert `$_POST['full_name']` into your database, why would you simply do `isset()`? You wouldn't want an empty string to be an acceptable value.
Thx, never thought of visualizing it, but I see your point. I graphic showing which resources are being loaded in the end and which policy takes care of it would be a great addition; just difficult to do when you're not a designer :-) But I will give it a shot.
Have you tried stackoverflow.com ?
PHP codebases qualities vary a lot. This article is good enough to be useful for quite a lot of developers.
Why not to guard against XSS the good ols way, using a template with auto-escaping feature?
Business domain have nothing do do with "Framework", right? Persistance is not tightly coupled to business domian, right? HTTP infrastructure for all PHP apps will use similar patterns (not to be confused with design patterns), right? (Or else picking something else then PHP will be of greater benefit anyway)
You probably need to check the error as shown here: http://php.net/manual/en/function.sqlsrv-connect.php if( $conn ) { echo "Connection established.&lt;br /&gt;"; }else{ echo "Connection could not be established.&lt;br /&gt;"; die( print_r( sqlsrv_errors(), true)); }
Please use `$this-&gt;call('other:command');` instead of `Artisan::call('other:command');` , it's best to avoid using Facades if they are not needed. 
You definitely should do that as well. CSP is also great because you need to think of all your dependencies and if they need to load any resources. Sometimes you just pull stuff in and have no idea. With CSP you control every aspect of loading resources. But as you mentioned, taking care of user input properly is something you everybody should do if using CSP or not.
&gt; I am not even sure if this is the right subreddit Nope. Check out /r/PHPhelp/ instead
you are right this is wrong subreddit. you've beent told that in the very form where you typed this question: https://imgur.com/a/tIzIf
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/DK1ckG8.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dw3k9bo) 
Auto-escaping by itself is not sufficient to protect against all XSS, same way as CSP is not enough to protect against all XSS. But if used together, it can provide protection against a bigger set of vulnerabilities. Also let's not forget there are applications out there that never had any security process in all their centuries of existence. Throwing a CSP header is still better than nothing, even if it adds a cost of extra bytes per HTTP response. And much cheaper than rewriting all their templates (which obviously should still happen at some point). On the other hand, even if the application is the most secure in the world, a CSP header can still have value as documentation.
DOWNVOTE ALL LARAVEL POSTS; REPORT ALL LARAVEL POSTERS.
...why?
Whys that?
I'm going to go ahead and say "no" to most of that. On one hand, congrats on being oriented in most of the default architectural decisions considered correct these days. I'm not bashing you or anything. On the other hand, that's precisely what I'm saying in my previous comment: if we want to grow as developers we need to step back and stop making "default" architectural decisions without even taking into account what app we're building. - You assume there's a big relatively monolithic/integrated set of components in every app, called the "Framework" which takes care of typical HTTP infrastructure concerns. There's no need for us to think like this. A framework can sit anywhere in the architecture, and cover any concern at all. One application may make use of multiple frameworks, or none. Hence we can't say "business domain has nothing to do with Framework", because it might be a framework for programming business logic. - In practice, with complex parallel access to the persistence method, and sophisticated persistence layers like SQL you're always doomed to have some of your business logic in your repository (for example avoiding dead-locks, maintaining a unique value in a list of values, triggers and cascade rules on the SQL side, in some cases stored procedures). How much separation there is and where you draw the line depends on what you're doing that for. You want to swap persistance backends? That's the "default" cited goal on blogs and videos. Thing is, while some apps need that, most apps don't. And with a microservice-style architecture, a service may be so simple, the entire separation only ends up introducing extra complexity and lowers performance, compared to thinking of SQL as part of your business logic layer, and keeping the overall unit of business logic (service) simple, instead (i.e. isolate concerns vertically first, and only then horizontally if you still need it). Anyway all of this is very abstract above, but I'll give you one example. I have a totally different approach to building HTTP APIs (machine-consumable) and building HTTP sites (user-facing content pages and apps). Building a site looks a bit more like a classic "framework" if you will, with a router (except in my case tree-based, not pattern based) invoking a controller (in my case called "page") which interacts with models/services and then rendering a response. But for APIs, there's no router. I implement a series of classes called "endpoints" that connect into a tree of APIs. Then dispatch the root endpoint at a URL prefix, typically `/api/` and this entire tree of endpoints is exposed automatically at that URL. There's no explicit router, there's no explicit management of HTTP responses or headers. The endpoint dispatcher takes standard input types (JSON request, form requests) deserializes them to a standard neutral format (a tree of arrays and value objects), passes them to the relevant endpoint action. The endpoint action returns a neutral response format (a tree of arrays and value object; or an exception in case of errors) which is automatically serialized by the endpoint dispatcher to a media object or a JSON response and converted to an HTTP response. The result? My APIs save me a ton of repetitive work as I define no routes or controllers for them, I just write the business logic and the rest is standardized. This not only saves work, but eliminates whole classes of bugs and opportunities for API inconsistencies throughout. But if I went through the series of default architectural choices, this would never occur to me as a solution. 
&gt; This query parameter is the route itself (how meta!) that is encrypted using SHA-256 with the app's encryption key. No, it's *hashed* using SHA-256. There's a huge difference. (The article gets this right further down, mind) &gt; This is the APP_KEY you set in your environment that is private to your app and used for all internal encryption. You shouldn't ever *set* this yourself, you should use __php artisan key:generate__ to make one for you. If you set one yourself, and it's not a high entropy source, then your HMAC is weak. If you're unsure if the one you set yourself has high enough entropy then it possibly doesn't.
TL:DR; Article doesn't go into any detail as to what AMP is (i.e. https://www.ampproject.org/ ), and doesn't present any pros/cons regarding AMP, or advantages specific to PHP/PHP Frameworks. &gt; Some significant features of PHP are discussed here, that are enough reasons to understand that PHP is fully suitable for AMP development- *raises eyebrow with suspicion* &gt; As PHP is well-known open-source web developing language that works with good efficiency with all emerging platforms, it reduces the cost of implementation and so recommended as the best reasonable solution for developing AMP. Given that AMP regards HTML output, the open source nature of the language appears to be irrelevant to recommending AMP. &gt; To get the required results from the AMP, the developers want a platform that can balance the aspects being stable on the implementation cost. So, whenever you want to create something innovative for the static content on your website, you will demand something worth. Whut? Again, this is about spitting out HTML. &gt; That’s why it is the best programming language for developing AMP framework and no other better idea exists than implementing PHP to develop AMP. Aside from perhaps just writing HTML files. &gt; When AMP is designed using PHP, it has the capability to load on different mobile devices because PHP language has the great compatibility with multiple servers and platforms and this is the excellent way to enhance the user searching. Again, we're dealing with HTML output- PHP in this context is nothing special. &gt; It is also beneficial for e-commerce web development as it cut down the costs and time for mobile pages. Compare to what? &gt; As AMP is going to find its way in web development field, it could get a fistful space in IT businesses, but PHP has come a long way in web development and delivering the needed requirements in developing a highly efficient AMP framework. However, the language has made the AMP a perfect choice for various enterprises and businesses. Also reads like meaningless buzzword soup.
Ah yeah, good catch about hashing. I'll fix that now. Didn't think I needed to mention key generation - it was assumed knowledge as that's generally done as soon as an app is setup - but fair point. Thanks
Facades are a laravel specific implementation of a `Service Locator` which is generally regarded as an anti-pattern. So it's a good habit to avoid them altogether. 
PHP5 tutorial in the top 5. &gt;As of today, the current version of PHP is version 5, with version 6 in the making. What year was this curated?
Can't wait to see Scott's take on this.
Could have done with this a few weeks ago. I had to implement some CSP headers so a 3rd party Vulnerability website scan would pass. Spatie's library definitely makes it more tidier. Good post.
Production-Grade Async programming Framework for PHP：https://www.swoole.co.uk/
Ready here: https://github.com/Symplify/Symplify/pull/706 Thanks @samdark for reaching out!
Well, the slogan can use some polishing: 'without too much knowledge about non-blocking I/O programming and low-level Linux kernel' Isn't ever 'high-level' language supposed to wrap this? I don't think I need to know alot about low-level Linux kernel if i'm going to program async/threading anyway, now imagine it's on windows.. ;)
First time I hear about that and it has 8000 stars on GitHub, is anyone here using it?
From the tester... &gt; I did more tests that involved more complicated PHP functionality and PHP fell on its face compared to Crystal and Go. Unless i limited the test to pure single function calls ( that directly call the C code ) &gt; If you want real speed, i simply advice going for Go or Crystal. If you are looking for a simple webserver setup with the easy of PHP code ( if your used to it ) you can use Swoole. &gt; Note: Do NOT run Swoole in production. I ran into several issues ( crashes ) during my extended tests that made me dump PHP / Swoole.
This sub isn't really for cross-posting Stack Overflow issues. It'll get plenty of exposure over there anyway. 
&gt;Do NOT run Swoole in production
Never heard of it. But I think it's chinese, as their official website is unreadable for me ;)
Hmm I don't know, but that sounds more like a configuration choice from your team / company, rather than how you'd have to work with Drupal. I hardly ever touch a yaml file, and I do code a lot. A lot of configuration ofcourse happens in the UI itself, but I see that as a pro, since a lot of work can be done by the cheaper and less experienced employees, without having to dive deep into code. Anyway: I'm not at all saying that Drupal is now a beautifull OOP heaven - actually far from it. But Drupal has a lot of improvement on that, where in my opinion most WordPress code is still a big heap of horseshit. My point was that I believe that the fact that Drupal thrives to push forward to better and better tested code is what drives away the less experienced programmers.
That's coming from a comment on a GitHub issue from a user not a maintainer of the framework.
I'm not a crypto expert by any means, but I think that because it is a completely private key, the amount of entropy required for high security is very low. Even just mashing on the keyboard for a bit, let's say up to 40 characters, will generate something unpredictable and not susceptible to any type of attacks. However, that said, for the purpose of an auto-login, my approach would be to generate and store a new random token for each link, exactly what this package mentions it's trying to do away with by using signed URLs. It's so easy to use a database for this, even if you have none other set up for your app and really don't want to set up and run a db server then just use SQLite. There's no reason not to.
There's no reason why `empty()` should be used sparingly. If you were to insert a variable into your database, it would make more sense to check `empty()`, rather than `isset()`, as you typically don't want to insert falsy values. In fact, I believe `isset()` should actually be the one used sparingly.
Given that everything works based on a gigantic C extension and what the extension is for I wouldn't dare to run that on anything remotely important/critical.
Try running this code instead of their helloworld example: &lt;?php system('cat /etc/passwd'); ?&gt; :P 
Looks interesting! An bigger documentation might help though.
I like the FAQ: &gt; Why use this library when I could simply copy-paste the snippet from the RFC? &gt; ¯\\\(ツ)/¯
I had to giggle at roundcube :')
PHP is also a gigantic C program, isn't it?
Indeed, looks like it’s become more stable but the point about the results for non hello world benchmarking is still relevant.
&gt; because it is a completely private key, the amount of entropy required for high security is very low. No. The "required entropy" for any key should be a minimum of 128. No ifs ands or buts. You want to aim for 256 for symmetric cryptography. &gt; Even just mashing on the keyboard for a bit, let's say up to 40 characters, will generate something unpredictable and not susceptible to any type of attacks. http://people.ischool.berkeley.edu/~nick/aaronson-oracle/ &gt; However, that said, for the purpose of an auto-login, my approach would be to generate and store a new random token for each link, exactly what this package mentions it's trying to do away with by using signed URLs. Also: https://paragonie.com/blog/2017/02/split-tokens-token-based-authentication-protocols-without-side-channels
How do you count tokens in a php repository?
Read all php files and call for each token_get_all()
Yea, i used it. I am also the guy that did the silly tests. Its a interesting tool but it has several issues. You need to be darn careful what you program in PHP. Even unexpected things like setting a custom error handler leaks memory. Forget about running most 3th party code. The change that they are using some code that will leak memory under Swoole is very large. So have fun customizing 3th party code. Swoole works if all your code takes in account that PHP is a long running process and you do not rely upon 3th party libraries or frameworks. Its great for benchmarking and seeing what PHP can becomes if the PHP devs actually bothered going down a more long running PHP process route ( and fix all the memory leak issues ). And also introduce coroutines / fibers and fix all the code. Try running Sqlite with Swoole and enjoy corrupting your database on large bench tests. But from what i see PHP is not going to evolve. A JIT engine is not going to fix issues like IO blocking. Coroutines, fibers, async is becoming the norm for any web language and PHP is really late to the game. The 3th party solutions are not very popular and PHP its language change DIP is still not progressing ( https://wiki.php.net/rfc/fiber ). In my personal opinion if PHP wants to stay relevant, their is a need for PHP to gain a compiler setup like Go, Crystal, ... But that will hurt its web presents as it not simple a interpreter anymore that can be run on any webhost. Swoole, ReactPHP, ... are all like a bandage on a gaping hole. Personally i stand by my call to not run Swoole in a production setup. **Unless** you have run a thousand stress tests, have your own custom framework that does not leak memory and want to train any developers you hire to also learn to program in PHP without introducing memory leakage. Or you force your swoole services to constantly restart to clear the memory. Let alone async issues you can run into. Or message sharing issues between running processes. Or memory sharing between processes. Like i said, its a nice bandage but still a bandage to fix issues that PHP in its core needed to have solved years ago. I see more future into Crystal because its more close to a interpreter language its ease of writing code ( in this case ruby like syntax ) and does not require writing dozens lines of code to get simple things done ( looking at you Go ).
What a *darn* shame.. *** ^^Darn ^^Counter: ^^489365 ^^| ^^DM ^^me ^^with: ^^'*blacklist-me*' ^^to ^^be ^^*ignored*
Another article from Zend: https://framework.zend.com/blog/2018-03-21-expressive-swoole.html
https://github.com/OndraM/ci-detector - **CI Detector ** - Detect continuous integration server and provide unified access to properties of current build Every CI server (Jenkins, Travis, AppVeyor, CircleCI, GitLab) provides set of environment variables to access build properties (build name, ID, git commit being built etc.) However these variables differs on every CI server so if you need one, it may be hard to make your build CI-server agnostic. This library provides unified access to this variables and also provides simple detection if current environment is CI server or not. $ciDetector = new \OndraM\CiDetector\CiDetector(); if ($ciDetector-&gt;isCiDetected()) { // Returns true if this is CI server environment $ci = $ciDetector-&gt;detect(); echo $ci-&gt;getCiName(); // "Travis CI" echo $ci-&gt;getBuildNumber(); // "35.1" echo $ci-&gt;getGitBranch(); // "feature/foo-bar" // ... } There is also [standalone PHAR](https://github.com/OndraM/ci-detector#standalone-cli-version) build, usable eg. inside bash scripts.
That website is very missing a lot of information. The issues like memory leaking like a fish tank with a bullet hole, are not even mention on it. Do not use global's = leaks memory. Do not use set_error_handler = leaks memory. Do not use set_exception_handler = leaks memory. ... Stuff that is mentioned in the Chinese website... https://translate.google.de/translate?hl=en&amp;sl=zh-CN&amp;u=https://wiki.swoole.com/wiki/page/p-instruction.html&amp;prev=search Nice to know is it not.
&gt; I have a way of raising my productivity - it would be beneficial to raise my teams productivity too :) Can you imagine the same in reverse? i.e. Other people in your team making IDE customisations (likely without your prior knowledge or discussion), and those coming through to your IDE automatically as they change them at various random times? Including inconsistent behaviour/settings between different projects? Not saying you would be against that. I guess there could be some balance. It makes plenty of sense if they're your own settings being sent to others. But personally I wouldn't want to be on the receiving end. Especially if it means I'm going to see different IDE behaviour on different projects. That would be confusing, especially to newcomers that aren't overly familiar with all these settings. The way jetbrains already merged the separate global vs project settings into all the same settings screens now is confusing enough. They used to be more clearly separated a number of years ago. This was about 18 years ago... but I remember "helping" someone out by changing a bunch of editor settings on his computer to the "awesome" way I usually had things set up on my own. He wasn't very happy with me, and of course reverted them all back to his way.
You should compare it tho phalcon, too. https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=update&amp;l=hm9udb&amp;f=1ekg-141w-141jc4-27wss0-11zm-iv8e0w-1dy0ht-sg
LOL no it's not. But it doesn't necessarily have to be PHPMailer. The `mail()` function is awful, however.
You kind of answered your own question. If phalcon is slower then default IO blocking PHP in those tests, there is little hope it will be faster :)
I understand the advice, but I would really like to know the answer here... suppose my laravel key is zawe4'ti90koaw3';raw3tp'oa4igjkop23p;'4eikq23W#JK$(w34uj3, ' that I just generated by mashing the keyboard and somebody elses is *d\fk/y5RVr'p`j{-6p;E8Ff1G&amp;)}V'-G*OK.yKx))tl806jj!BKoTmoMFnz Copy/pasted from https://www.grc.com/passwords.htm. Let's ignore the implications of copy/pasting something that was transmitted over the internet and pretend it was securely generated on the same machine it's going to be used on. What plausible attacks are there against my key that there aren't against the other one?
There's an argument here for also calling this a list of applications to stay away from. I'm saying this tongue in cheek, but I'm kind of serious. 
To be frank, it's like asking why not build guzzle into the core when curl is so primitive and tedious to use. I believe PHP didn't get it replaced because it's native, using system sendmail, to do an extremely simple stuff. If you need more control, use libraries. Besides, why PHPMailer, why not SwiftMailer? :)
phpdocker.io is very similar to springboot.io in that it will let you create a basic customized (Docker in this case) environment that you want even before downloading it and customizing it further. It can combine php, apache, nginx, xdebug, mysql, etc... writing docker and docker composer files for you (and then you can further customize it). It's a real time saver for Docker environments. Thanks for your tip, I'll try applying it.
Well which is it so we can argue with you either way? 
I was incredibly vague so as to avoid arguments. I'm going to maintain that position.
To be frank, I think Guzzle should be included too. I honestly can't think of scenario where anyone would use `mail()`. PHP has a lot of great things built-in, but this obvious isn't one of them. I'd be be fine with anything that's actually usable. Didn't mean specifically PHPMailer
I disagree. As a lead programmer, I can set up basic/minimum customizations that I want my group to follow (and any outside contractors as well), such as coding rules (in our case PSR-0/1/2), debug server configurations, etc... have new people start with that and then they can customize it whatever way they like afterwards. They won't be committing/pushing their changes back to the repository (best if it's read-only for everyone but the lead). It can save them and myself a ton of time. We use IntelliJ both for PHP and Java and this could potentially save us a lot of time.
I didn't ask anything. Especially not what is faster.
Why would you not save 0 to database if user submitted that?
What is the future of PHP then? :/
If you want a language that isn't afraid to deprecate and remove things quickly, you might not want to use PHP. PHP is infamous for backwards compatibility choices like maintaining known bugs in the name of not breaking existing code.
No generics, no type inference, no proper closures, no async await What php is left new is spaceship operator and question array_sort vs rsort or what "az"++ would return.
Would you say its worth starting new projects in PHP now, currently, even with something like Swoole?
Cool, that sounds useful, thanks for the explanation. No worries. I've got many projects set up using xdebug through Docker in PHPStorm, so do feel free to PM if you have any problem getting it working. 
That's the basic idea, yeah. Also, comments, whitespaces and delimiters are removed. We only keep the meat of the script. 
I prefer SwiftMailer. I think the main reason why is because it's just too easy to do a composer require. Things that should be included in php are things that it doesn't make sense to write in PHP.
... PHP isn't for you. If you want a language that'll run your old code just the same for a long time, PHP has your back. Only exceptionally egregiously bad things tend to get deprecated/removed, other things tend to stick around. Look at the ever-infamous `mysql_escape_string` and `mysql_real_escape_string` for example - it took until the whole `mysql` library was removed to get rid of that whole deal, and evne then it only got removed because it was bundled into a bigger library with bigger issues.
&gt; I cant roll my eyes hard enough. Why roll your eyes when Lararoll can do it for you!
Yes, it's acceptable to save falsy value into database if user submitted that. Null should be saved if user did not submit it at all.
I have been doing PHP for 20 years and you can feel the air change. PHP has grown over the years because its easy to get going and has several popular platforms ( most notably WordPress ). The advantage but also the issue with PHP is its stuck in the web. Python its growth has come not from being focused solely as a web solution. Languages like Go are making a more strong impression and have shown the world that you do not need interpreter languages to have a easy programming language. And it provides high performance not just for that one task. The fast compiling with easy of cross platform development and deployment. The added security of NOT having your source code on the webserver. The coroutines support. Do i think Go is the future forward. No ... Its too verbose but that is my opinion. Many people complained about PHP and llook where we are 20 years on. Go has many limits and repetitive code. The Go core developers are to focused on providing features that Google needs and not what the community needs. Sorry but when i can do a DB call and get results in 7 lines with PHP and it takes almost 30 with the struct, error handling, manual assigning, you know there is a issue. Even simple webserver with a database call is 69 lines vs 19 in Crystal. It simply slows down productivity when you code base grows. But PHP had the same issues and it evolved over the years to still dominate the market. So who am i to say no to Go. In my point of view, we are in a gray period where we will see even more new languages and the language that can tap in the whole easy of development with easy cross-deployment is going to becomes the next dominant language for the web and potentially beyond. PHP is just too darn slow to evolve. Most web hosts are still stuck on PHP 5.x range. Its a issue you do not have with the compiled languages. You want to use Go 1.0 or 1.10? Nothing prevents you from compiling and running that code. But anybody who wants to use PHP 7.0 or later ( what has been on the market almost 3 years ) still faces many hosts that are stuck on the old 5.x range. It took Facebook and hhvm to push PHP to finally make work of increasing it speed. It helped a lot that PHP developers had Facebook's its work on hhvm to *uch* have a look at. From my point of view, PHP is very, VERY slowly going to be pushed back more and more in the future. Less project will start with PHP and they may pick Go or other languages to start major project with. This will drive more developers into this direction. The whole webassembly is also a dark horse that PHP simply can not tap into. This decline will take years and years. Part of it coming from PHP its own core limits to evolve beyond being a interpreter language. I see PHP going to way of COBOL, Pascal and other languages. Still used, loved by a core group of people, maintained forever but not a dominant language on the web. All it takes is that one "wordpress" like platform to gain ( inexplicable ) popularity and it will push whatever language with it. So yes, this is my personal opinion. Many will have different ones as we all do. It never hurts to learn a few languages like Rust, Crystal, Go on the side to be better positioned to ride the next wave. :)
As I said, I'm not saying it specifically has to be PHPMailer; I'm indifferent. But it's pretty odd to have such an important and commonly feature be unusable by pretty much everyone.
Which is why they should remove mail and anybody can send mail with whichever library they prefer. Plus it frees php from maintaining it and whomever is using it can easily make changes if needed, since it's written in php
PHP is definitely for me, and is my favorite language. They made both MySQLi and PDO. Perhaps I wasn't clear, but I'm not saying I want them to deprecate or remove features quickly. I'm just saying a feature that is used exceedingly often should at least be useable. Core PHP should either update `mail()` or introduce something better.
Nope, that's only acceptable for optional fields. For instance, in a social network application, a full name would likely be required
Why?
Go away
&gt; https://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html But sure, let's blame PHP.
PHP had the choice to abstract that away, but for long time in PHP's past PHP preferred to more or less be a simple glue over C/other APIs which meant choosing to import all the same issues of those APIs. Something like letting an issue in how MySQL's apis worked leak into PHP is a result of that. Incidentally that's exactly why `mail` exists and is now largely useless - PHP just wanted to expose the system's local mail facilities in a transparent way. (So transparently the docs even talk about some of the flags for sendmail) Now that a local sendmail or similar actually being the way to send mail isfairly dead so too is `mail` fairly dead. When PHP came into its own as a full programming language rather than essentially a beefy templating language and started trying to offer more of its own facilities in its own way (like PDO) things got immensely better, but PHP has for the most part elected to continue having all the old wrappers kept around for backwards compatibility and choosing not even to deprecate their usage. PHP is a language that puts backwards compatibility over cleanliness. That's not necessarily a bad thing - it's a good thing in plenty of contexts - but if you really want PHP to drop `mail` (a function that, although useless to many, isn't particularly problematic in the way something like `register_globals` was) because it's confusing to have this extra function around that's mostly useless and mostly not the way you'd want to do mail then you're probably having a cultural break with the way PHP tends to operate.
For form validations, you should use more robust solutions. Please, do yourself favor and use mature library for that. You are using empty way too much if this is your use case for that. You hide errors in your application and make form validation unreliable. In your example, I guess you also wouldn't want when user submits just empty space, would you? Or null byte terminator, or any other invisible character. Hence, simple empty won't cut it. It needs to be replaced with isset &amp;&amp; normal validation.
Drupal surprised me. Not sure whether that's a good thing or bad thing.
I completely agree that that obviously just `empty()` alone is not sufficient. More sanitization and validation is needed often times. I also tend to combine that with `ctype_space()`.
If you are in the USA then generally I would advise against it. If you already have a team of PHP developers then it might make sense. There are a few other legitimate reasons as well. However, for reasons I do not understand and can't really comment on since I'm a US citizen PHP seems to maintain it's popularity outside of the US. Maybe it's because we have manual translations; maybe it's economics. I don't know. The end result is that it makes more sense to learn PHP in this situation.
That's an entire framework. I'm simply talking about fixing one specific function no one uses, other than novices who don't know any better. I don't care what route it goes, whether it be improving the existing function or adding a better mail library. I think one of PHP strengths is having a lot of useful features out of the box, why not fix this one?
I'm guessing because it's super old
&gt; http://people.ischool.berkeley.edu/~nick/aaronson-oracle/ this blows my mind and enrages me at the same time
I know that I'm late to the game here. However rather than the suggestion that you were confused by the RFC, is it possible you did mean a library? (And nod zubr-php) The library I remember seeing on reddit that sounds like this was: https://github.com/consistence/consistence
The solution is to put beginner-friendly information on the mail documentation page telling them why the mail function probably isn't going to work for them and linKing 2 a list of mail related composer packages
&gt; Sorry but when i can do a DB call and get results in 7 lines with PHP and it takes almost 30 with the struct, error handling, manual assigning, you know there is a issue. Even simple webserver with a database call is 69 lines vs 19 in Crystal. It simply slows down productivity when you code base grows. But isn't that a framework's job? Isn't it beneficial to have lower level granularity in the base language and build on top of frameworks when you don't need it? You can even combine the two and just extend the framework if you don't like the way something is done. I don't claim to have much experience or something, but that sounds like a nice plus to me. Somewhat akin to dropping from C into assembly when you need it. &gt; The whole webassembly is also a dark horse that PHP simply can not tap into. How so? I'm not questioning, just genuinely curious. Could you elaborate please? 
&gt;There are several repository collecting PHP backdoors. Cool...
then why post at all?
It doesn't feel old. 
While functionally identical, `Artisan::call()` needs to go through the whole proxy process of resolving Artisan from the container and forwarding the call. `$this` already _is_ Artisan.
Because reddit. And I can neither confirm or deny that I agree with him.
&gt; These are the largest "open-source* PHP applications FTFY
`Jiro Dreams of Go`
Licensing is confusing. If you're willing to use MIT, why offer or couple it to GPL?
&gt; But isn't that a framework's job? Framework split communities. Notice how jobs do not ask for "PHP developer" but its always X framework or Y framework. Frameworks get introduced into companies and a lot of companies simply want to hire people that already know X or Y. The reality is most job can be done with basic PHP and some slim scaffolding and that is it. But the moment people go down the framework route, it becomes less about the language and more about the framework. Very few people drop from C into Assembly because the compiler in most cases is better at optimizing than people. &gt; webassembly Its easy getting C / C++ to Webassembly because first of all webassembly has no Garbage collector unlike PHP. So you need to implement your own GC that needs to be downloaded with your webassembly code. But its also the way PHP works. PHP is a intepretor language, so the PHP devs needs to write a entire new software stack that can translate PHP to C or PHP directly to webassembly. Add to this that PHP is not a Strictly typed language. How do you translate PHP its default "array", what can be a array or a dictionary or a slice in other languages. They are not the same and webassembly is a strictly typed. If we look at: C/C++ = Direct. Rust, Crystal, D ( LDC ), ... they can use there LLVM backends to generate webassembly. So most of the work is already done. But again some of those languages need a GC implantation. In the future webassembly is supposed to get its own GC. They all have strictly typed in the design. Its a very complex subject that i am probably butchering :) But its a LOT of work to even expect PHP to have a Webassembly output ability. Think in years of development terminology. Where as other strictly typed languages have a "natural" ability or can fall back on work by others like LLVM. Given how slow PHP itself moves, expecting to see webassembly in PHP is really expecting too much. We do not even have any coroutines in PHP. Its like asking to see PHP being able to compile down to a binary file or have a LLVM backend. :) Its a complex subject but in short: PHP is really not equipped to get a working web assembly output. **Solution?** Unless you want people who spend years putting something together. A bit like the PHP to C# compiler ( www.peachpie.io ). Well, technically that is a "solution". PHP -&gt; .Net -&gt; WebAssembly ( we know Microsoft is working on Webassembly output using CoreRT for .Net ). PHP -&gt; .Net -&gt; CoreRT can also output to a binary executable
And I'm on holiday :) But it looks like it is a +10 year old vulnerability as it also affects Drupal 6, so I'm quite curious of what it is
Are they done with all the sex shaming now? can we go back to programming? or is Drupal still a community were people are hunted and kicked out for their fetish?
Step one: don't use Wordpress. Done.
Sending email is not the problem that PHP solves, i.e. it's outside the scope of PHP. the `mail()` function also don't send email, it uses what ever is configured in the system to do that.
Wow. I thought I was quite familiar with the magento2 codebase, but i didn't realize it was \*that\* big. Makes me want to go code spelunking.
I've always wondered: why not keep 1 HTTP request = 1 process (which is the secret sauce of PHP's success), but the process would be booted before being put in the FPM worker pool **and** the PHP script would be allowed to "init". The "init" phase would allow frameworks to load the autoloader, preload frequently used classes, init the DB connection, build the application and the DI container, etc. Basically the same as PHP-PM/Swoole, except processes are not reused hence avoiding the issue of memory leaks and collisions between requests. The effort for PHP frameworks and developers would be minimal, and all PHP packages would be immediately compatible.
What's the merit in saying "there is a zero day out there and we'll patch it in a week" now every bored kid with a free afternoon is going to be looking for 10 year old eval code in Drupal. Never used Drupal but this seems super counter productive practice just in general, keep it VERY quite until you have a fix. I remember getting heartbleed embargoed and we had like 6 hours!! before release. 7 days seems stupid. 
I find it very usable! Old but mature IMHO. Email is a chaos, no one can solve it.
&gt; What's the merit in saying "there is a zero day out there and we'll patch it in a week" now every bored kid with a free afternoon is going to be looking for 10 year old eval code in Drupal. It gives companies a week to get their sites ready for update. Likely appreciated by folks who need to line a freelance dev, or who have a dev on vacation. &gt; I remember getting heartbleed embargoed and we had like 6 hours!! before release. You were supposed to have more, but it leaked. https://www.smh.com.au/technology/heartbleed-disclosure-timeline-who-knew-what-and-when-20140414-zqurk.html
Not sure why you're being downvoted. While it's off topic, it happened and opened a very bad precedent. I believe drupal community is dying, mostly because there're better products out there, but also because those kind of incidents break communities apart. Maybe it was meant to break the community apart in order to leverage Acquia and Drupal for the enterprise? And, as others have said, it's plain stupid to announce a vulnerability and what it does without a fix.
I'm super new to the community, what are you referring to?
https://www.garfieldtech.com/blog/tmi-outing
&gt; You want to use Go 1.0 or 1.10? Nothing prevents you from compiling and running that code. But anybody who wants to use PHP 7.0 or later ( what has been on the market almost 3 years ) still faces many hosts that are stuck on the old 5.x range. It's still much easier to find a host supporting PHP 7 than it is finding one that supports Go and if you're compiling it yourself then you could just as easily install the latest PHP. 
&gt; Not sure why you're being downvoted. While it's off topic... Got it in one, I suspect.
Thanks for the detailed response, what you're saying certainly makes sense. I definitely agree that frameworks split the community and this seems to be especially true for PHP. I'm not sure how flexible companies are with seniors, but they aren't flexible at all with us intermediates. When I say I worked with the TYPO3 CMS, which is built on top of its own fully fledged framework, I've had the other person look at me like I have no idea what ORM is even though I've obviously made use of if before. I think I understand what you're saying about PHP, but I didn't catch something: you're talking about bringing PHP code in the frontend, right? 
Drupal PHP is a beast on its own. Specially before 8.
&gt; I think I understand what you're saying about PHP, but I didn't catch something: you're talking about bringing PHP code in the frontend, right? Webassembly is a new tool in the browsers their tool belt that allows technically any languages( with the right effort ) to output a binary file, that the browser can run. So its can replace javascript in the browser but with the advantage of being faster and language neutral. Its more or less the future as it means you do not need to rely on two languages ( Front + Back ) to make any browser based website or app ( not counting nodeJS ). PHP has a lot of issues that make it hard to solve this puzzle. I mentioned the Peachpie project because technically they are compiling PHP code, to .Net intermediate language. Aka, think of it like writing in PHP and getting a .Net Binary executable. Because MS is already developing a lot of tooling for there .Net Core setup, it means that the PeachPie project then can tap into .Net and use those same tools. Aka, indirectly transform PHP code into .Net / WebAssembly / Stand alone binary. Check out their website https://www.peachpie.io/ and see the examples. Its not really hard to figure out. They gotten to the point that there own website that runs Wordpress PHP code transcompiled to .Net. So that is a "solution" to go from PHP to Webassembly or a stand alone binary file. Its not a "official" PHP solution just like the whole Swoole issue. But it technically has more potential then anything we will see from PHP officially in the next few years. PeachPie is now also part of the .NET Foundation ...
I quite like roundcube. Simple and does the job. I use it on my personal email server so I can access my email from anywhere.
Adding something to the language makes it very difficult to update because there are so many users. If it’s difficult to update then it’s difficult to innovate and so libraries will spring to fill the gaps. Instead, since you know libraries will fill the gaps, just leave it out and let them do so. That makes the language smaller and easier to understand and maintain.
Yes, Drupal is still a community where witch hunts, bullying, and public shaming for consensual, legal, and ethical private behaviour is encouraged, rewarded, and conducted by the highest leadership. And I will be continuing to avoid using or contributing to Drupal, and I will continue to encourage my colleagues, clients, and employers to do the same. ...however, that's not really relevant to the current issue. However terrible a person Dries Buytaert may be, this is still major news in the PHP world.
&gt; What's the merit in saying "there is a zero day out there and we'll patch it in a week" now every bored kid with a free afternoon is going to be looking for 10 year old eval code in Drupal. Honestly, the ones with the aptitude and motivation to find it already would have, and the ones that lack one or the either will have a much easier time reverse engineering the patch into an exploit than finding the vulnerability itself. $10 says this was a RIPS finding.
PHP has multiple uses of the word `static`, but I think you mean stuff like `static::$foo` instead of `self::$foo`? In simple terms `static::` refers to the current class, even if it extends a parent class. I think in every situation `static::class` and `get_called_class()` will be the same thing. Simple example: abstract class Thing { const SHAPE = 'amorphous'; public static function getShape() { return static::SHAPE; } } class Circle extends Thing { const SHAPE = 'round'; } class Rectangle extends Thing { const SHAPE = 'long square'; } Circle::getShape(); // "round" Rectangle::getShape(); // "long square" Even though Circle and Rectangle don't define "getShape", they do define the "SHAPE" constant and the result of "getShape" reflects *their* constant. If instead of `static::` I had used `self::` they would all return `"amorphous"`. Also, the `static` annotation in the function signature means that these methods can be called directly on the class without creating an instance of it. In PHP you can call a static method on a class instance without any problems: $circle = new Circle(); $circle::getShape(); // "round" $circle-&gt;getShape(); // "round" However you can't call an instance method (any method lacking `static`in its function signature) on a non-object: class Triangle { public function getShape() { return "pointy"; } } Triangle::getShape(); // Deprecated: Non-static method Triangle::getShape() should not be called statically 
Upvote for escaping the \\
There are a lot of things involved with sending mail. It's fair to say PHP should not include it at all, since it's a language, not a framework. Yet that's only halfway true because it began its life and spent its first many years as a language/framework hybrid that does many web and HTTP related tasks by default. Since then it's kind of pivoted towards being a general-purpose language but retains this legacy through functions like `mail()` built right in to the core language. But because it's been very popular and widely used, and because of the policies of the PHP internals team, features that should, in retrospect, not be part of a programming language's standard library will not be removed. But at the same time extending the language to do more of what it was originally intended for (making web dev easier) also face a lot of opposition from those who support its new direction and prefer that these things be part of library packages. There's a mostly-forgotten part of PHP called [SPL](http://php.net/manual/en/book.spl.php) - "The Standard PHP Library (SPL) is a collection of interfaces and classes that are meant to solve common problems." This was maybe intended to be equivalent to .NET the framework versus C# the language. But that hasn't really happened so PHP remains a mishmash.
Very fair points made, and I pretty much completely agree with you. I, too, can see both sides.
I can respect that
Or try ASP.NET Core. It's similar to PHP in syntax and concepts, but in my (admittedly small) experience it's quite a joy to work with. It's a framework, not a language, but overwhelmingly the language of choice is C#. It feels like PHP with a really thorough and well-thought-out framework and without the legacy cruft. It's kind of the polar opposite of cherry-picking libraries to do various web/http related things, but you get everything you need for making websites and APIs in a well maintained, well documented, well supported framework right out of the box, and much higher consistency than using separate libraries.
&gt; which is going to be in the middle of the night for some Dutchman here: it's going to be at 8PM over here. It's going to be half past midnight in Mumbai and 6AM in Sydney.
&gt; There are several things this switch enabled us to do: &gt; - We can now write plugins and themes for WordPress in C# DREAM COME TRUE
*Was that a sarcastic lol?!*
&gt; however toxic Acquia's leadership of the project may be, This one thing is what holds it back. 
Yah, I find pigeons more reliable these days
A lot of the apps in there are installed in cPanel by default and through installers that I bet a lot of people just install and never use.
that's the kind of comment you'll never know if it's serious or sarcastic
"the WordPress way".... say it again... slowly ... to any other developer... yeah, it doesn't mean what you thought it did, right?
The resulting behavior when using empty may be desired many situations. I sort-of agree that in many situations inserting falsy values is not desired. But the problem with empty is that it's behavior is dependent on the type of the variable. Basically my issue boils down to the fact that using empty makes your code harder to read. In any situation I would recommend being explicit about your validation rules. So instead always use type safe checks and preferably use positive assertions instead of negative ones. If mb_strlen((string) $name &gt;= 1) is much more explicit and communicates the intention of the programmer much better then a simple !empty($name)
I tried using amphp/parallel for something recently, nope, can't handle exceptions inside the parallel running code and would occasionally just stay pegged at 100% causing me to call the process. I ended up converting all my API classes (4 separate APIs) to just return Guzzle promises instead so I can run them at the same time. The lack of really threading/parallel executing in PHP is a bummer. I"m def going to be looking at Go for performance intensive stuff.
For the lowest common denominator yes, but getting an AWS or even Linode VPS is pretty easy and cheap these days.
There is tons of PHP logic out there that assumes a fresh scope for every request. It would take significant refactoring to make things work that way. The root of PHP's success IMO was timing and the lack of an architecture like you describe making it possible to run cheap shared hosts for low-traffic websites.
 I think all the tutorials here submitted by the community members.
My pint was if you're using those it's just as easy to use the latest PHP version as it is to use Go.
Because, it's old, and can probably be build with alot less code nowadays :-)
Don't get me wrong, but I don't get companies &amp; teams that don't discuss global changes prior commiting them. That's just a toxic environment. If it's forced - I agree that it shouldn't happen. Nowadays we have pull requests and slack to communicate it clearly. I find automated tools important, but a tad too late for this. I'm in an opinion that the earlier feedback you'll get - the less effort will be wasted by other people and waiting for automated tools to finish. But if they're fast then it's great 👌
Why would you compile PHP to .Net instead of writing C#? Except for ongoing PHP projects maybe.. but new ones?
Yeah if you're clearly communicating every change to everyone before it happens, I can imagine it actually going pretty well. And especially if you're giving them the choice. Sounds like you guys have it pretty good in that case. Wish the rest of us were that lucky. :) But after 19 years of work as both an employee + contractor, "clear communication" has been but a fantastical dream in most situations much of the time. Some have been good communicators, maybe like 10%. And for me it's mostly been in the area of webdev agencies, where everything is a poorly managed panic of client deadlines... rather than internal projects that are properly taken care of. [Even quite a few of the "project mangers" (whose job is pretty much 100% about communication) have been pretty useless in my experience.](https://www.youtube.com/watch?v=hNuu9CpdjIo) And yeah, agree with what you say about slack... so much better than IRC/email etc in terms of pasting chunks of code and showing inline screenshots etc.
What about woocommerce then? 
Given the real domain name is disguised, I consider this link SPAM.
There's a lot of details in dealing with email sending these days. The core PHP devs have much more important lower stuff to be working on. They shouldn't be working on this high-level stuff that is perfectly suited to packages. I'm guessing you don't have much experience in other languages, because compared to almost all of them, PHP already has a huge amount of high-level functionality built-in that would otherwise always be done in 3rd party packages. This stuff doesn't need to be written in C. Which is what you're suggesting. This is like expecting your car mechanic to wash your car too. Also in general, these days if you want email sending to be reliable, you shouldn't be sending the emails directly from your own web servers. Use something like Mailgun, which has its own PHP package to communicate with their API. https://packagist.org/packages/mailgun/mailgun-php - might seem like a complex thing to bother with before you've tried it... but it's actually much much simpler than dealing with mail sending reputation shit yourself. Which I gave up on altogether about 5 years ago. And I've been running mail servers since I was ending sendmail.cf files in the 90s.
Thanks :)
Not affiliated my a**. &gt; Reasons to migrate &gt; We frequently mention the benefits of running PHP applications on the secure, managed .NET platform How can someone believe this statement? These are just SEO words with no meaning.
https://twitter.com/drupalsecurity/status/976828727048003585
@mjcov thanks a lot! it was really helpful!
I think this is based on the mistaken idea that *you, as the website operator* are in a position to determine what is "important and private". But you're not. This is the user's decision to make, because *only they* can decide how much their data matters to them. That means that you should default to providing secure authentication mechanisms without compromises, and *at most* provide an opt-in method that's less safe but more convenient for users who have decided that they don't really care. (Also, this post seems to be about 'engagement', ie. marketing goals, not about user convenience.)
I have nothing to do with PeachPie ... i only remembered then from the past when conversing in the above mentioned topic regarding web assembly. And the only way i see PHP getting Web Assembly support is by going over this project, into .Net its back-end and outputting Web Assembly from there. After reading up on the project again, i noticed in their last post that they are running the website on a PHP/Wordpress/Transcompiled. And it looked interesting, so i decided to post the link to the blog post. You know, as it may actually be of interest to the PHP community. What part of not affiliated is hard to understand? No need to look for conspiracy theories when they do not exist. **lol** Why do i even need to justify myself to you? Reasons to migrate &gt; We frequently mention the benefits of running PHP applications on the secure, managed .NET platform &gt; How can someone believe this statement? These are just SEO words with no meaning. That is their statement. &gt; EDIT &gt; If .NET is so secure, why don't you build a new Blogging Platform based on it? Exactly.. Heuuu, i do not care whatever you do. Why even ask me about that. Person sees something interesting, posts it, gets rude comments by some troll.
I expected like 1. Facebook 2. Pornhub ..
The article is about PHPUnit to atoum, not PHPSpec to atoum :-).
Most of you guys are talking without any knowledge. Saying things based in just your opinion makes no sense, you guys should use facts instead. I am building an application with Swoole + Zend Expressive and we have done plenty of stress tests to the application without any minor memory leak.... In fact ReactPhp way worst regarding memory leaks/performance. 
&gt; PHP is definitely for me, and is my favorite language. A bit off topic, but how many other programming languages do you know? That's an opinion I rarely hear, and nearly always it's from people who know only PHP and JavaScript.
Yeah, I've got heaps of reddit posts that probably look like ads for phpstorm... aside from the fact that I've told a few people who can't afford it to just run a cracked version until they can pay for it. I regularly bring up the fact that I've been super against paying for software my whole life, even ran a warez BBS back in the 90s... yet I happily pay for phpstorm (and nothing else). 
I like the idea of sharing your PHPStorm config between team mates, but storing it in with the repo is not ideal 'cos 1. not all of us in the team use or want to use PHPStorm 2. it's not code and we want to keep as much not-code as possible out of the repo 3. stops team members from their own preferences etc
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [laravel/framework/.../**ConvertEmptyStringsToNull.php** (5.6 → c99911f)](https://github.com/laravel/framework/blob/c99911f45432440beee2a9b6d7b5a19ef8d50997/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dw5nx9w.)
That can't be right. College professors everywhere know no legit companies use PHP....
Hi OP (@lacrossefan32) What you mean by "core" is that it's in ext/standard (mail.c, array.c, string.c ..etc). Your comments about "nobody using mail()" or "mail() being awful" aren't true. PHPMailer and SwiftMailer are using mail() under the hood in many cases, because it does work with the correct inputs. Your looking for better DX in this case, which is where community libraries come in. mail() will never leave PHP and fancy mailing library abstractions will always be community maintained. TIP: Put your energy into contributing to OSS than ranting on a forum site. Peace out. 
Dayum, I wouldn't have noticed this. Thanks!
What about it 😂 
PHP/DS will help you. https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd http://docs.php.net/manual/en/book.ds.php https://github.com/php-ds/extension Good luck 
You're not wrong, Walter, you're just an asshole.
You're not going to attract any serious people by exclaiming you can and are using wordpress...
But I was told... &gt; Everything I cover is up-to-date and relevant to today's developer industry. No PHP or other dated technologies. This course does not cut any corners.
This could come in handy
You could just write a simple shell script - oh wait..
Other dated technologies: SSH: 12 years old REST: 18 years old Java: 22 years old HTTP: 29 years old X.509: 30 years old RSA: 41 years old
&gt; there're better products out there While I believe you (got dang I'd love to switch my company over to Wagtail) do you have any you could list off?
Then get on it. Too many people regards themselves as a customer of a product they are entitled to. Open source is a gift given to you, the developers don't owe you anything. 
I didn't rant, though you clearly did. Just wanted to see people's opinions on a function no one should be using. No respected developer uses `mail()` by itself, and you knew exactly what I meant, so not sure why you're being disingenuous. Most people who do use it are beginners who don't know any better. But you're right, what a crazy idea to fix such an important function... peace out
Wordpress now has an API baked into it now so you could use frontend tech with the API and have Wordpress handle the admin part. I used OctoberCMS for a while and although it is a great CMS, there aren't a lot of choices when it comes to themes and plugins. I recently moved away from OctoberCMS to Wordpress and I'm happy about my choice.
I think you misunderstood my reaction. I'm not using roundcube, and I have no intend in using an opensource mail client. Hell I'm not even saying it's bad. What I meant is that it's an old product, and that it suprises me that a mail client is in the top 100 largest open source software products.
I'm guessing you don't understand that one of PHP's strength is having nice built-in things out of the box, like [this](https://dev.to/paragonie/php-72-the-first-programming-language-to-add-modern-cryptography-to-its-standard-library) for instance. And by the way, I do have experience in several different languages. This is like me expecting an important function to actually be useable. Crazy, right? Mailgun looks interesting, and I'll take a look at it, thanks.
Like he says PHPMailer and SwiftMailer are using mail() under the hood. Also, you sating no respected developer uses mail is completely wrong. Take a look at WordPress as an example... https://github.com/WordPress/WordPress/blob/0895f04705442bba10f9f4afd3b4dce36aa8f6a7/wp-includes/class-phpmailer.php#L697
&gt; Like he says PHPMailer and SwiftMailer are using mail() under the hood Reread my comment &gt; Take a look at WordPress as an example... WordPress is respected? This is news to me.
In general looks pretty good and useful for anybody using mysql, but some questions/comments: -p, --pass MySQL Password (If empty, auto-generated) You really should discourage (or at least allow not) putting a password in as a command argument - it means that you're probably going to end up with a use that has their password advertised in their shell history and in the process metadata. if [ "$(whoami)" != 'root' ]; then It's generally better check the euid of the user with `id -u` because it's not guaranteed that a root user is necessarily named root, but it *is* guaranteed their euid will be 0. read rootPassword do `read -s rootPassword` and it won't echo the user's password back to them. (Showing a password on screen should be avoided where possible.) export LC_CTYPE=C export LANG=C Why are you clobbering the user's locale? 
Hi there. Just wanted to confirm that the OP has absolutely no affiliation with PeachPie. We don't know who posted this, believe it or not.
We appreciate your posts, and surely someone found it useful. People are very critical on this forum.
Well...if all the Microsoft blogs run on WordPress, surely it can't be that bad, right?
https://en.m.wikipedia.org/wiki/Timeline_of_programming_languages I'm curious what counts as a modern language? The only mainstream language that's "newer" than Java, JavaScript, Python, Ruby and PHP is C# or VB.net and that's only by 5-6 years.
Good call, thanks bot.
Go leans heavily towards static compilation - A compiled go program tends to have very few and very forgiving dynamic links that will likely work on most any system. Compile go -&gt; copy paste to host is all but guaranteed to work because Linux very rarely (if ever?) breaks backwards compatibility and unless you're a hipster using musl the libc dependency should be fine. The average PHP binary you'll get from building PHP from source on your system, however, is not really copy-pastable except to very similar systems, and if you want PHP extensions you now need a whole big build system to build your PHP+modules that's fairly non-trivial. Compare to go where you do the default thing and your build system is largely worked out for you, then you just copy paste one file or maybe one directory and that's it.
I've also been using php for almost 20yrs.. The objectives of php have changed periodically, honestly, all they need to do since it's matuered in some very huge ways is to spend some community development time on putting in place a better garbage collection process.. Python does garbage collection too and you don't see people talking Sh1t about it on a regular basis, atleast in the circles I frequent. Ruby also has garbage collection. Honestly, I think php language is very descriptive and concise and I rarely find it difficult to understand what "modern" php is doing. When it comes to understanding php w/ annonymous functions, that I think is slightly more complex issue. Anyways, also look at javascript, talk about dynamic, if they can improve garbage collection with javascript and it's garbage collection routines, the only direction for php i is up &amp; better.
Woah. Magento 2 is twice the size. Woah.
If it's a collection (which it is) that implements Countable then you're not just looking at the underlying struct in every case. You may be making queries or doing any number of wonky things.
SSH was invented in 1995 which is when I started using it at age 14 as a replacement for telnet and FTP. That makes it 23 years old, almost two times older than your claim! 
I feel like there is something I missed with this comment ...
If it's a content/editorial site, I'd recommend Wordpress. Not that the code is better, I'm not sure about that, but it is easier to code for and to the client to use. If it's a site with a lot of custom models or business logic, roll your own or go to something like OctoberCMS. It'll be easier to do your customization. I feel like Drupal get's in the way in those cases. I see some use cases for Drupal though but for me it's hard to learn and maintain.
It's from this really popular course that everyone always links in /r/webdev and /r/web_design https://www.udemy.com/the-web-developer-bootcamp/
Here's a sneak peek of /r/webdev using the [top posts](https://np.reddit.com/r/webdev/top/?sort=top&amp;t=year) of the year! \#1: [Have you ever felt this??](https://i.redd.it/apcs1kvrpy4z.jpg) | [279 comments](https://np.reddit.com/r/webdev/comments/6iklbl/have_you_ever_felt_this/) \#2: [Animated login avatar](https://v.redd.it/38jmec4zrlh01) | [92 comments](https://np.reddit.com/r/webdev/comments/7zanzv/animated_login_avatar/) \#3: [The FCC is killing Net Neutrality - Help spread the word in your own websites](https://np.reddit.com/r/webdev/comments/7emfo5/the_fcc_is_killing_net_neutrality_help_spread_the/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
As the founder of the PHPU, which has always been heavily ridiculed and lambasted by trolls on this channel, and spawned a dozen sockpuppet accounts that just harass every post I ever made (and /r/PHP admins response was to ban *my* account), I did the following: 1. Learn about variables, Classes, methods, and properties, in that order, using my very useful Novel analogies. 2. Learn about the operators (+, -, ., etc.) and how to manipulate variables. 3. Learn flow control (if / switch, function calling and nesting). 4. Learn the loop statements (foreach, while, do while, and finally for). 5. Design patterns, starting with MVC then Factory, and on down. 6. Composition 7. A strong mentoring on when to use Composition vs Inheritance. 8. Then Docker and how to deploy to production. 9. Then automated testing, first PHPUnit then Behat. 10. FINALLY basic HTML and CSS. I have trained over 100 people over the last 10 years using this model. Their average salary goes from $40k junior to $80,000. Lots of them frequent /r/PHP, but they've all seen how hostile this community is to us, so we keep a very low profile (this is my first post here on PHPU, I believe, in 3 or 4 years). There hasn't been anyone, whether mid-level, senior or complete neophyte who completed the full course (takes about 2 years at 4 hours a week) who isn't making at least $100,000 a year. I'm currently, for instance, pulling in several times that.
That's pretty cool :) What do you think about my article?
I actually didn't notice that. But yeah 12 years would've been like 2004 which was way off the mark. IIRC it was definitely a thing back then and on the way to being a standard feature but for a lot of the areas I was in it was kind of like running your browser in Firejail or using MFA for your login. Kind of atypical but something popular with security-minded folks. 2004 would be kind of pushing it though.
[removed]
We can if we keep people's sex lives out of every security news thread.
I don't think id ever really want something as robust as Swift or PHPMailer written as an extension, but a low level SMTP extension would be nice for when you don't want to deal with sockets yourself but really don't need something as full featured as Swift/PHPMailer/etc.
Random thoughts ... * It's a shell script to add 'set -u' (explode on undefined variables) and perhaps 'set -e' (explode on error). * why not use bash's getopt support? ( see e.g. http://wiki.bash-hackers.org/howto/getopts_tutorial ) * Check for /etc/mysql/debian.cnf - if that exists, and is readable as it should be on Debian/Ubuntu, use it instead of checking for e.g a /root/.my.cnf file (e.g. mysql --defaults-extra-file=/etc/mysql/debian.cnf -e ' ..... ' 
I agree. Something bare minimum as you described would be ideal. This way, it's at least usable, while still allowing you to choose a different library to suit your needs. I just feel like it's such an important function that should be improved, but apparently that's an unpopular opinion on r/php
I know of a few .net shops that offload their marketing departments to Wordpress and Concrete5 so they do not have to support it. This could actually be useful for the stubborn MCSE that does not want to deal with a rogue Linux server.
I explained why. Its semantics are broken, and you _will_ end up with bugs in your code by using it. Luckily, for every scenario you might want to use it, there exists a better alternative.
I guess I don't understand the problem, because that's what I would think its intended result should be. That's just something I might do in the beginning of a page as a quick check; validation/sanitation needed additionally, obviously. If it were `$_POST['full_name']`, I think `empty()` would be appropriate for this initial check, while `isset()` would be better for `$_POST['price']`. I also tend to combine `empty()` with `ctype_space()`.
TLDR: In current PHP you can specify a negative index keys when inserting an element into an array, like A[-2]=“elm1”; But if you then do A[]=“elm2”; then elm2 will get index key 0. That will change in PHP 8.0 so it gets index -1.
This is indeed a well known weakness of self-typed "random" codes. In WWII it was very common to produce random codebooks (used to encrypt military messages) by having typists randomly smashing their typewriter. It was at that time the best way they had to produce randomness, but later analysis of those codebooks revealed that there were indeed a lot of recurring patterns and some letters were barely used while others were used frequently. This all made the entropy much lower than originally thought (although good enough for WWII technology). Can't find a source for this story right now but iirc I have it from a documentary or something...
I guess we'll have to agree to disagree. Each programmer is different, and has his own preferences on how to perform a task.
Will it be backwards compatible with my PHP4 code?
Nop. But a warning will be emitted (at least in PHP 7)
Not sure if sarcasm
Can I still use mysql_connect? /s
5:30AM here, still not sure whether to get up early or stay up late
We just about finished upgrading to 7.2 from 5.x. Hope this is a ways off, so I don't have to upgrade soon again 
I don't think this usage is incredibly common so this change shouldn't be too disruptive to most legacy code.
That vote was declined. The behavior will change but the notice won't be emitted
It's still a ways off. However, I really didn't have much issues upgrading from 5.6 to 7.2. If you don't use deprecated functions or bad practices now, it'll save you later. 
Our code base is very very old, so there were tons of that in the legacy code. 
How about Python's slice notation sweetness for php8? `$var[int]` already works for arrays and strings - something like `$var[int, int]` could replace couple of `array_*`/`str_*` functions.
&gt; infested by SJW's &gt; Lets try and keep it civil in the comments. Ha! Anyway, from what I've seen of comments here, people don’t hate Wordpress. They hate that it’s what everyone thinks of when they think of PHP, as its codebase is not reflective of best practices of modern PHP development. It's popular and it gets the job done. But I think anyone who subscribes to a language-specific subreddit is not going to be particularly interested in a piece of software that was written for a version of that lanugage that's almost two decades old. 
Ahh thanks, I thought it passed too.
Absolutely. But the package was designed to work in PHP 4, so even though it now requires later versions, its architecture is largely bounded by that earlier environment (e.g no namespaces)
As an intermediate developer I have the position to deny Wordpress jobs but it seems to flood the work place no matter where I go like a disease you can’t cure
I wish I could do that, I’d get fired. Teach me your ways senior developer 
They don’t even sign updates... one guy which IIRC is an author of PHPs implementation of libsodium wrote pure PHP-based implementation with 5.2 support and offered full solution for Wordpress to be secure - they were ignoring him for a year since security is not their priority.
&gt;It has a huge user base, if it was so "bad" people would be running from it What makes you say that? Plenty of people make bad choices all the freaking time, and sometimes a 'bad' thing is still the best choice for other reasons even compared to technically superior options. If people always flocked to the technically superior option then why would OSX and Windows both have non-trivial market share for personal use? Surely people will find the superior one (I'm not claiming anything about which is better here, calm down) and always go for it? But of course that hasn't happened and there are a few good reasons that have nothing to do with the inherent superiority of Windows or OSX on a technical level as an operating system. The fact MS managed to make Windows 'standard' has had a huge influence through marketing well means a lot of people don't even look at alternatives. A lot of software is Windows or OSX only and locks certain people in because the vendor can't/won't release for other platforms. Users tend to only see the surface (the UI) and often have no real capacity to understand the underlying structures because that's not what they're studied in, so many users will prefer a decent UI and UX over a technically inferior product rather than an amazing product that's more stable/more featureful/whatever that takes more effort to interface with. All this sort of stuff and more is why plenty of markets haven't resolved the 'best' even in very specific categories where it's hard to argue that 'a is better at x while b is better at y'. 
Generally the rule for choosing your own work is you have to have work which only you can effectively do. For example in one of the places I was working in only I knew details of DIC architecture or I was an author of templating engine integration. It’s not like it was a black magic, but since I wrote something most of the related tasks were assigned to me just because it was easier for me to do them (= faster). Second thing is find your niche which you’re good at and business needs it - they will leave you alone :p Third when there are junior devs (especially new ones) teach them. Seriously, it’s a great team building exercise and additionally it let you give them smaller tasks which you don’t want to do (because seriously, if something requires just a simple controller and a model I can assign it to a junior). And very last thing: it’s an employee market. You can always change and they will loose more than you will on such change (and employers know that). I’m very sound in a team and I’m not afraid of saying “this solution is a complete garbage, we need to start from the beginning and design it better without ugly hacks”, I’m not afraid of saying someone’s else code is a crap (but I also accept criticism about line of course!), I’m not afraid to argue with other developers and I wasn’t even when they were technically outranking me. These (and many other small things) let me say “I’m not touching this shit unless I can refactor it”. 
Woe is the programmer who chooses their preferences over code correctness, however.
Yeah, I was pretty good at PHP 4.3 back in like 2004 or something, then after 3 weeks at my new job (which was initially doing statistical Python) my boss was like “you gotta learn PHP 7.0, be ready to work on a project in 2 weeks”
&gt; Furthermore, I don't want to work in a place that forces me to setup my development environment to their standards. They are my tools. They are customized to my preferences to maximize my productivity. Each team member should have this freedom. It's not all black and white. Yes, your tools. Your prefs. Your productivity. But no, Code Style guidelines is not your preference, it's the teams decision. `.idea/codeStyle/codeStyleConfig.xml` and `.idea/codeStyle/codeStyleSettings.xml` are almost the only files we commit. I've also seen `.vscode/settings.json` but I'm not a user of it. In our team I don't always agree 150% to all code guidelines decisions. But at the end of the day, consistency is what matters and not my ego. If I think there's a better alternative to something, I write up an internal RFC and get the teams feedback. Democracy wins except for the cases where high powers (CTO, …) veto. In an environment of mutual respect this is not really an issue. Actually, even if I request of mine is ultimately vetoed, in the end what I value more is consistency (and, truth to be told, I haven't yet had the case where I thought the final decision was ultimately BS or a real productivity issue, etc.). However I also realized that it was rather "easy" to agree on a CodeStyle guideline (just take the PSR2 as a base and fine tune it), with the PhpStorm Inspections (especially with "EA Inpsections") it's more complicated: - not everyone has an opinion on all rules - so some just want to go with the defaults - but some defaults are (sorry for the blunt-ness!) stupid _or_ outright don't make sense for us So, no project-wide Inpsections technically to share. Just recommendations of the most important stuff. And if you forget this/don't have it, it will be discovered in reviews. After a while (3 months?) the review process for new developers usually "just works ™. I'm happy with this approach.
Honest feedback about being a better blogger. Don't lead with a headline "Recursive Code to Parse Recursive Form Data" then at the end of the article write "Technically this is not a recursive function as it is not a function at all and doesn’t call itself for each level down." The read just invested 10 mins of their time into reading the article based on the headline, and now at the end you are telling them you didn't deliver. No one is going to be happy about that. At a bare minimum your article should be making a point or presenting an idea and then providing evidence or examples to support the point or idea in a coherent manner.
None of the packagist/composer packages aren't signed either. 
&gt; It has a huge user base, if it was so "bad" people would be running from it, they're not. It's easy to use, easy to install, easy to get hacked and easy to hack. Most people I know who make WordPress sites chooses WordPress because that's what they are capable to work with. "Easy" in terms of one-click install, point and click themes and plugins, little to none coding ability required. The term "WordPress developer" could mean anything from "I know how the mouse works" to "I've worked with PHP for 9 years". Yes, getting started with WordPress is easy, but easy doesn't imply good, stable or secure. &gt; It has a thousand and one million billion themes. Obviously that's not a number, but you get the idea, you want a eCommerce web site, here's 15 trillion plugins and 5000000000000000 themes that can do that. The point is, it's easy to get started with to build up your company brand. It's easy to drop-in themes and plugins that third-party have written which most "WordPress developers" have no idea of (or interest in) the code quality, security vulnerabilities or strengths or how it's maintained. Not all themes/plugins are bad, but as you yourself is pointing out, the amount of available themes and plugins is also a risk - they're not all high quality, tested and maintained the same way. In fact, most exploits you can find for defacing a WordPress site is actually exploiting vulnerable plugins. &gt; It's easy to learn. In what sense? To use their interface or to develop themes and plugins? Or just hacking some styles and changing a headline here and there? &gt; What I dont understand is if it's so bad why are people using it? Because it's easy to work with for people who'd might not know how to setup CraftCMS/Drupal/Joomla or something similar (I'm not asserting that these are great/better/superior options). Easy doesn't mean right. &gt; Is the code clean? No. Is it maintainable? yes (somehow). Does it follow modern practices and all the things we wish we could do, blog about and pray to do - no. It gets the job done, its cheap (free) and most of all it's easy. Actually, I'm fine with others using and working with WordPress as long as I don't have to. It's all great that users find working with the interface easy (and cheap), but actually developing on a WordPress site is a nightmare (IMHO). &gt; So why (aside from smashing magazines latest article of hilariousness.) do we hate wordpress. Because there are better options now. &gt; Don't throw: "It's insecure" at me, because we know that. But millions of people still use it, even for their company and to build engaging communities around it. With that kind of argumentation, why would we even be interested in progress of the technologies that we use? Do we need to actually work on making things better? &gt; Doesn't half the blogs you go to that arn't medium, use it in some context? What kind of argument is this? Are you saying that because other people use insecure solutions you'd might as well do so? 
[Yes](https://github.com/dshafik/php7-mysql-shim)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/dshafik/php7-mysql-shim) - Previous text "Yes" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Seems a bit desperate... Your "test" is basically an asynchronous set up designed to get performance out of PHP being compared to the default synchronous setup in Golang and show that you can marginally outperform it in certain conditions, in a Hello World comparison... So all the things wrong with this... Firstly you are comparing an async request setup vs a sync one, which is well.. Go setup an async server with Golang and watch is murder Swoole. Secondly even if you run Goland synchronously there are plenty of HTTP packages that perform better than the default and would therefore outperform Swoole quit easily, despite the fact they run synchronously. Thirdly it is Hello World, which is generally pretty useless in any benchmark, but in this one it is even more dishonest, because the more you add to Golang, Crystal, etc then the more they will outperfom PHP as you add to that (not just in request per second, but response times, memory usage, etc) Which is why in the real world to take Elixir and Ruby-on-Rails as an example of the difference between these newer high performance languages and old school like Ruby, PHP, etc, that the Bleacher Report was able to go from 150 servers on rails down to 5 with Elixir, and still have more spare capacity...
&gt; It has a huge user base, if it was so "bad" people would be running from it Yeah, because all of those self centered teenagers and bloggers all know what PHP is.
write an rfc
I also learned php from WordPress (kinda), but then for me WordPress was so awesome because I had no collage about php coding. When I learned php then I realize WordPress is so bad and so slow/hackable. 
They are not being automatically updated onto systems maintained by non-technical people either.
First step would be to use a recent version of PHP. :)
It might not be software. What's your ping to the box? If it's short you could explore hardware improvements like SSD, or more ram.
There are tools like PHP code sniffer where you can enforce those rules, regardless of the IDE. 
Try and do a traceroute. How long does it take?
Good point. Scott tried his best, but unless you wrap this feature as a Gutenberg plugin or as part of a REST API, there's no way the execs paying attention. 
At my company we are actually separating the model of the MVC pattern into the actual data model and the data access object (DAO). The DAO does just handles CRUD calls to the database whereas the model contains all the functions and especially the attributes of the business logic object. :-) Therefore you would do something like this to retrieve an object from the database. $carDao = new CarDao(new DB()); $car = $carDao-&gt;getCar($carID); $car-&gt;doSomething();
Try to change all instances of `localhost` to `127.0.0.1` instead.
I actually use it on production since upgrading 20 years old application which was written mostly in PHP4 times takes a lot of time...
You should start by timing how long it takes to serve a static blank page, ie. is the delay due to the PHP stack or IIS configuration. If the delay is gone, then yes, something is wrong with your IIS Setup and it's time to start debugging your configuration. Disable all unnecessary extensions, check Window's Event Viewer and install something like Process Monitor for Window to identify the culprit. It the delay persist, try to install Nginx or Lighttpd for Windows. If the delay is still there you can now start troubleshooting Windows and your network configuration. My Raspberry Pi can serve up php pages in a few ms. - so no. I highlt doubt your Windows hardware is any slower than a Raspberry Pi so it's definitely a configuration problem you are dealing with.
&gt; If you don't use deprecated functions or bad practices now, it'll save you later. Years of old CodeIgniter 2.1.x code base. I've now ran into multiple companies that fell into this trap. It's a headache upgrading/getting off CI2.x CodeIgniter did a _huge_ disservice to the community. :/
Exactly this. Repository pattern is similar. Doctrine is also a good example.
LOL "correct"
While this is good maintenance advice, it shouldn't be the first thought here. Network, DNS, and timing with static pages would all be more helpful in finding the actual problem than changing the PHP version.
Don't want to be rude. But one of the Reddit rules says that: **Please do not frequently submit links to your own content, exclusively. It's likely to get spam-filtered.** I am not a critic, but the same rules should apply to all users. Thanks for understanding me.
It's not Codeiginter. Codiginter was great in his time. You and other developers weren't able to migrate to a different Framework and now you blame CI. This is wrong. You should at least use Codeiginter 3. But now with so many tutorials and courses, you should be able to switch to Symfony/Laravel/Yii/Cake or any other modern PHP framework.
Upgrade to PHP 7.x if you can first and then check your result.. unless of course there's a reason you're stuck on 5.6.3
Use SSD, start using NginX, start using PHP7.2, start using PHP-FPM; Sorry for ignorance, but is there any reason to use IIS for PHP? 
I'll trade you I'll do your job if you do on my Ruby work
https://en.wikipedia.org/wiki/Data_access_object
That's a very broad question. Do you have any specific problems?
i have some clients who use MSSQL on Windows Server and wanted IIS as a server; IIS -&gt; PHP-FPM runs pretty well, although I'd stay the fuck away from IIS whenever possible
With a great help of our OSS supporters (https://www.patreon.com/kalessil) a major release of our Static Code Analyzer is out: better types resolving sub-system and bunch things related to stabilization and newer PHP versions migration are the scope.
PHP is a higher level language that is built using C. Wrapper would indicate that it provides all of the base functionality but is more convenient / easier to use. It doesn't since it's designed solely (well, almost) for web development, hence it's not a wrapper.
Yii is using latest PHP features. It's at least 5 years before CodeInginter at this moment. But I agree with your other statements.
Thank you for your work on this plugin. It's awesome.
Thank you so much!
Drupal, as a PHP project, seems to be lacking leadership and that's the biggest problem for it imo. The community is a thing I love, I went to several Drupal events and everyone is really friendly :)
I90% of everything it does is Magic
It pays back pretty fast + licenses of commercial one covering the development of EA Extended as well. It's a fair deal for a project of this complexity and with obvious time-saving.
Np, it took me a while to understand nested arrays at first, just think of each sub array as the list of columns and the main array as rows in a table and it should be easier. You could also assign keys to the array and reference everything via key, statically coding, but that loop should work for many situations.
I only found it from googling "php7 mysql shim" to see if anyone had even made one, but now I'm thinking of doing the same. I've got a 15 year old application that is very slowly getting updated and still on 5.6, this would at least help get it on 7 sooner before 5 becomes completely unsupported.
If you think $50 is too much for a plugin that helps you find problems in your code base, then you are probably charging to little for the work you do. Maybe it’s because you have a lot of problems in your code base? 
Thought was a linter for Coding style my bad, I find it really helps, this could worth for a company for sure!
Sure i got a tons of problems, currently at school so only side project for now :)
Ha, then definitely check out the Extended version. Apologies for assuming you were using PHP in a professional context. Can highly recommend the plugin! Over the years it has helped me find and fix thousands of issues. If you do start using PhpStorm in a commercial context, and can afford to pay for software, then you can still upgrade to the Ultimate version. Compared to the cost of not knowing, and consequently not fixing these issues, $50 a year is definitely a bargain. When I heard that there would be a paid option, I immediately subscribed. I like getting paid for software, too. 
Honestly I would even say that I have 0 sympathy for anyone if this breaks your code. I can't image what the hell you'd be doing if your code relies on this madness 
Are there any?
I still use NetBeans. Kind of a standard in our office where we have Java and PHP-based systems talking to each other. Tried PHPStorm &amp; liked it for the most part (uncanny valley of trying to find where stuff was didn't go away in time before the trial ran out), just still not 100% sold on the "renting software" model... especially when, y'know, free.
I use Vim, so, yes :D
I don't think it's hated that much at all. Sure there a few militant and vocal dev's out there who are always seeking perfection, what ever that is. WordPress is popular because it's simplistic, just like Laravel. It isn't good, but good enough for the majority of developers to wrap their heads around. 
How is it any different than VS.Code with plugins? I think VS.Code works great.
This is independent of any text editor. A text editor can write a plugin that interfaces with this, that's the beauty of it. Much in the same vein as the various LSP plugins that are kicking around recently. 
I feel the pain. But I'm not sure how it relates to WordPress. Do you honestly think that these two "developers" would have done a better job without WordPress, magically becoming better at their job ? The first one ran from a fairly complex pricing model with an ugly shortcut The second one is just piss poor front end integration. Not even related to WordPress. On the other hand, I saw a script last week, coded around FuelPHP ; 50 functions chained on top of a data query, barely displayable in a code editor, let alone understandable without spending a day on it. Good news is, it's relatively simple to remove these kind of nonsense from WordPress thanks to hooks 
This. Full disclosure. I am a WordPress consultant and Linux SysAdmin. I’ve worked with PHP since 2002. Seen a lot of crap and still do. For starters, a good WordPress developer has a boilerplate stack, properly hosted, WAF secured and can configure W3 Total cache. If you’re serious about speed, put a content caching service like Varnish in front of any WP site and it will fly. If you’re looking for a CMS, WP is a good option. There’s a reason [60% of all CMS sites run WP](https://w3techs.com/technologies/details/cm-wordpress/all/all/) , or 30% of all websites. I’ve worked with Drupal and Joomla. Still prefer WP because it’s user friendly and I don’t have to spend too much time teaching my clients how to use it. There’s a lot of work out there if you’re a good WP developer. Not every client wants a custom solution. They just want something that’s quick, cheap and solves their problem. They are not trying to send a rocket into space. My biggest beef with WP is how the plugin market is being “maintained”. It’s so easy for a newbie to install a plugin that’s either dead, vulnerable or poorly coded. What I’m hoping will become more popular as the WP REST API matures is the [Decoupled CMS](https://css-tricks.com/what-is-a-headless-cms/) idea, or a headless Wordpress. 
Wish more people used php for command line
Atom and Brackets are excellent general purpose editors
Thanks! I had an idea to implement this exact feature for a database I was designing for a while, but I never knew what to call it. 
Emacs checkin in boi
&gt; Do you honestly think that these two "developers" would have done a better job without WordPress, magically becoming better at their job ? Not at all. I think without WordPress, they would have left the job for someone else who is qualified.
Me too. I have a few projects that are just CLI tools, but I really wish there were more tools to aid CLI interface. For example one of my biggest gripes is you cannot print output while listening for input. Say you had a live twitter feed, but at any time you could hit a key to like something. You can't do that in PHP. One of the woes in a mostly single threaded language I guess. 
What the fuck. [Our lord and savior is Laravel](https://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/).
Well there is [this](https://github.com/krakjoe/pthreads) but I haven't used it, so dunno how it'd work for what you want
This is a great plugin. I just spent 6 hours (7 with the daylight saving…) removing most of the errors in my codebase :D Thanks a lot for all the work! It's impressive. 
This is exactly why Wordpress is a steaming pile of crap. It’s the environment it has created and the shitty web designers it has enabled to now call themselves programmers or developers that is the huge problem with WordPress. 
I am thinking of paying for the commercial one, but what are the benefits over the free one? It's not too clear from the site.
Many do actually.
Agree. Thanks for the tip! 
Oh, I see =) Yes, it's a not a linter: we are more focusing on bugs, security, control flow, performance and etc.
https://github.com/clue/php-stdio-react You're welcome. 
Have you heard of [Stack Overflow](https://stackoverflow.com)? This question has been asked multiple times there. 
So buy a perpetual license and sleep better, work better.
Again - the user who submitted this has no affiliation with PeachPie. 
beautifully put
Xdebug will allow you to step through every line of your code as it executes... https://xdebug.org/
# NO HELP POSTS
&gt; currently at school Get off the Internet.
I used vim, but moved to phpstorm, this looks promising, will give it a go
Lol dude are you always this salty? Chill the fuck out. 
Why the hate?
Good bot
I know about SO. I'm new to programming and could not understand where the code is going wrong. 
+1 Sublime text
Thanks
Thanks
Thanks
because you’re not allowed to like Laravel here
Yes, "correct". Unlike, say, whitespace structure, brace style, naming conventions, and the like, where preference has no effect on code correctness, your preference in this situation produces demonstrably inferior code by objective measures. It's akin to preferring to parse XML with regular expressions. It may seem (on the surface) to work for you, and you may truly prefer to do things that particular way, but it's genuinely incorrect.
No, it's literally akin to `!isset($var)` || !$var, as stated previously.
Can you please point me to good php plugins for vs code?
Good bot
If it’s new, why didn’t it *actually implement* LSP?
Well my problem is I'm more backend/systems admin. Looking for jobs or work where "php" is relevant is useless to me since really is only associated w/ front end web development. I guess I should have worded, I wish more people in my domain used it for commandline scripting. 
http://phpactor.github.io/phpactor/history.html#why-not-php-language-server
Such a common mistake make Drupal devs make still :(
It comes with instructions to install it as a plugin for VIM... Come here /u/professorlamp you big bear. I wanna kiss you right on the mouth!
I've built with WordPress for 10 years (on&amp;off) I think that WordPress is really no more frustrating than PHP itself can be. Yes, there are other platforms we can use. I love Laravel to bits. I work with many Drupal devs. Frankly, I think WordPress is really simple to use. And that most nay-sayers just don't have the experience with it to know how to handle any given situation. I'm not saying WordPress is the best solution, just that I personally don't mind (and in-fact enjoy) working with it. The WordPress eco-system is the problem more than anything else. There are so many loose-ends which have been integrated into builds in the wrong-ways. There's more than one way to do things, and I think that due to WordPress' availability it attracts novice developers who do things the wrong way &amp; give WordPress a bad name. Kinda like PHP (not saying that PHP is a good programming language, just that it's not as bad as the code people make with it).
True, but that's kind-of the point of WordPress, "to democratize-publishing". We don't scratch-code an OS every-time we install it, why should a website be that different? I'm a "purist" as much as anyone, and don't like seeing the "bolt-on" strategegy used... But it's part of what's out there. The people making little tweaks to woocommerce and buying plugins to get the job-done aren't developers. We've just gotta work around their BS &amp; it's frustrating. This may seem odd, but that's one of the things that keeps development interesting for me as a developer, when you get a new project you don't know what's been done before-hand or how. In terms of front-end, we have WordPress' rest-api, &amp; there's the wp-admin ajax hooks: https://codex.wordpress.org/Plugin_API/Action_Reference/wp_ajax_(action) which you can extend to return a json-response instead of an html-one.
Just use the Stripe-api &amp; make a curl request with it. Build a form, then point the action of the form at a php-file which sanitizes it &amp; sends the relevant info to: WordPress to create the user-account Stripe to make the payment &amp; when complete activate the user-account. you might need to import the wp-load.php file
You are welcome =)
Once your PHPStorm license "expires" you still have a perpetual license of the current version you are on, you just don't have access to major version updates. https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-a-perpetual-fallback-license-
Bad bot
No; they *recommend* using PHP 7.2 but there's absolutely nothing stopping you from using it with PHP 5.2.
Here's a simple flowchart for things on reddit: 1. Is it popular? * YES! -- Hate it * NO! -- Love it
You aren't renting. When you buy it you keep it. You just don't get newer versions after a year. 
Check out his name. 
Lol
Awww shucks! I've started working on a [deoplete source](https://github.com/joereynolds/deoplete-phpactor) for it too!
Maybe I'm missing something but I feel like it'd be easier to just write the json and throw it in a linter to validate
A linter would not validate specific JSON API rules.
Wouldn't it just require a valid JSON object though? Sorry if I'm misunderstanding. Not too sure what JSON API rules are
For me it's simple. Most of the time it's not the right platform for the customer. If the customer needs a blog and a few pages. It's pretty hard to beat WP. If the customer needs eCommerce, wrong tool. Members subscription, wrong tool. The client will inevitably be dissatisfied when you use WP for anything other than it's intended purpose, which is blogging. Side note: Bolt CMS beats WP in pretty much every way *except* the customers familiarity with it IMO.
Are you familiar with role based access control (RBAC)? Look it up. Before you worry about implementation details, I suggest you look up and understand the access control models to see what suits your requirements. Build a conceptual model, that'll make it easier to ask the relevant questions. A simple way to differentiate the users would be to flag them in the database i.e. user_type column in users table could be admin, moderator, user Default user type for all non registered would be guest. Then in your code you could check if the user is guest or user and allow/deny functionality as needed. Hope this helps you.
Ah that's interesting, nothing I've ever come across before, you learn something new every day!
Here's the spec http://jsonapi.org/format/
Never seen that before but I guess it really makes sense to have that otherwise json apis would become the wild west of developer preference 
My experiences of it so far was that it's not okay, because tests take a lot longer to run. However if you instead do automated rsync, or PhpStorm's automatic SSH deployment to your VM (works pretty great), then that won't be a problem either. I know someone who actually uses their IDE within their VM, and are happy with it. So consider that too if you don't want to be switching away from your VM.
I'd recommend checking out [puphpet.com](http://puphpet.com/). "Custom" assembled vagrant files that help streamline sharing out file directories to do exactly what you're trying to do, as well as a bunch more stuff.
The idea is for the files and everything else always reside inside the VM and the share only be used to modify files (with my IDE), so no deployment process except the save delay from the network share itself. I don't understand why tests would run slower except maybe for the SSH connection since they would be running inside the VM. &gt; I know someone who actually uses their IDE within their VM, and are happy with it. So consider that too if you don't want to be switching away from your VM. That's what I'm doing right now and it's pretty cumbersome because I have a lot of things to look at the Windows side (like Office documents, some proprietary software, other stuff). I tried the setup I'm asking (quite) a few years ago and it was full of bugs like gulp, webpack or other daemons not noticing that the files were updated (I had to use some stupid hacks). I wonder if it's fixed now.
I do this and it works great for me. I use the built-in virtualbox shared folders because nfs was too complicated to set up. Performance-wise it will be a bit slower and vary depending on what framework you use. Specifically the bottleneck will be the number of files php has to include - the more filesit accesses, the slower it is. For reference, I mainly use yii2 so each page takes about 100-250ms to load. When I worked with laravel it would typically take 200-750ms to load. For node it's the same thing - the more packages you include the slower it will be. Regarding your problems: 1) Deep nested folders - no longer an issue with the latest npm versions 2) File monitoring - it can't pick up instant file changes, so you *must* use polling 3) Permissions - this is annoying. It's generally when a node packages tries to install and symlink a binary. I solve this by running `npm install` in a non-shared folder, eg, */home/user/tmp_node*, then `cp -rfp` it
Ah, I get you. What languages do you see requested in jobs instead?
&gt; It's easy to use, easy to install, **easy to get hacked and easy to hack**. But the key word here is easy. Are you taking the piss, or something?
Very helpful. Thank you so much. I've got a lot of learning to do! 
This is just a simple pipeline implementation I wrote for my Ice Cream Framework I am slowly working on. Would love feedback. The packagist badge seems to be "invalid" even through the links work, so Im confused there, but aside from that - feedback is wanted.
&gt; I use the built-in virtualbox shared folders because nfs was too complicated to set up. Me too, but I've had quite a few bugs which seem to be uniquely tied to vboxsf mapping from a Windows host. 
You can clone you're environment in docker. For me is the best environment so far. The second would be vagrant and you would have your GUI too if needed... 
Yes. If you can use php 5.4.0 or over. Sadly, this is not always the case as you work with legacy code.
I feel sorry for you having to worry about that... Can't imagine what it's like. 5.3 has been EOL for close to 5 years now - even 5.4 has been for almost 2.5 years. We're already trying to get ready for 5.6 going EOL at the end of the year.
Some clients still use 5.3.6. 
Wordpress is respected? is that a sarcastic comment
PHPActor is simply one of the best plugins for PHP I use in Vim... It provides you a solid autocompletion and a lot of refactoring tools. For the Vim users out there: I wrote an article how to make a PHP IDE out of Vim here --&gt; http://web-techno.net/vim-php-ide/ I update it often with my last findings. PHPActor is of course definitely advised there!
Damn shame. Sorry for you :/
I found the new command overused. Static classes could come useful to provide syntactic sugar. J::attribute(...) Instead of new JsonAttribute(...) Behind the scenes, the current importation should still exist. Important for testing purposes.
"Copy Reference" was changed to "Copy Relative Path" at some point in the last year or two.
The article says that they don't use PHP Storm any more, how come? Doesn't it have most of these tools built it? :) 
Whoever downvoted this comment is a selfish pig leeching on the other people's hard work, using a free language, a free database, a multitude of free tools but showing a middle finger when another free tool maintainer asks for a little help.
//TODO: Update my IDE to not use these because it's bad...
See kids. Shit like this is why I quit university. Best career choice so far.
I think the main argument is that if you are in 2003 and writing stuff like this in notepad ``` // ?&gt;&lt;html&gt; &lt;?=$title;?&gt;``` nobody knows what's going on
&gt; It's more the structure and code style that reminds me heavily of CI. That's true
I'll just quote the top comment from Twitter: &gt; A communist version of doctrine’s logo? Lol
Copy Reference is still there for classes etc. And copy relative path is for files. Copy Reference is still super useful for making Symfony service definitions 'n stuff.
It's bullshit, OP. 
I believe they are confusing it with docblocks. You should not use // for describing the method arguments
When teachers teach their personal opinions... A good strategy that has worked well for me over the years is to use `/* .. */` for docblocks and "official" comments and to use `//` inside methods and functions to annotate a behaviour. 
&gt; Symfony has Zend as a dependency Do you mean that they use the zend engine? Yeah, pretty much all PHP scripts use the zend engine.
I wrote another article about my switch from PhpStorm to Vim -&gt; http://web-techno.net/phpstorm-vs-vim/ And no, as far as I know PhpStorm doesn't have most of the tools built in. 
Nothing impressive here. What is really mind-blowing is the fact that despite all these marvels, most PHP-ers are still tinkering with "while mysqli feches me an array, echo the user name and some HTML tags" stuff.
I believe you're already aware of this, but this is because your second example lacks awareness of DST. If you want to really fuck with your head, have a read of [https://derickrethans.nl/storing\-date\-time\-in\-database.html](https://derickrethans.nl/storing-date-time-in-database.html).
How about you ask your teacher why it is bad? why do you ask the internet about the opinion of your teacher? 
Word of warning if using this, on several occasions it's been left without updates for long periods of time, and the installed images occasionally install older versions of things.
On work we are not using any frameworks...I am still trying to convince my colleagues to use Symfony
I legit didn't know it used Zend at all...I didn't think about it
Does anyone know if PHP AST will bundle consecutive `//` into single docblock for an element? That may be only reason why `//` could be discouraged, that I can think of.
That's a shitty teacher if they're telling you something is good or bad but won't say why.
Laravel uses Symfony components, Symfony uses Zend components. Do not add the common confusion between components and frameworks. Zend and Symfony both are built as a set of decoupled components, then glued together forming the framework. It's legit for one to use another's few components.
+1, but OP didn't ask a question, technically. :)
Interesting list of tools. May I suggest reviewing Exakat : https://www.exakat.io/ It audits code for security, performances and migration. It also provides in-depth documentation and inventories. 
/u/saltub : I know very well it's written `PhpStorm` instead of `PHPStorm`.
The first link to your reference list returns a 404.
The "Find Action" command is one the most useful ones, because you can use it to find all the other commands you might have forgotten. And it shows you the shortcut in the overlay. What I still can't figure out (after years of working with PhpStorm) is how I can enable `ide://path/to/file.php:12` links to work. I want to click a link with an `ide://` link in chrome, and it should open the file in PhpStorm at the line specified. Anyone know how to enable this on Ubuntu/OSX/Win?
https://github.com/alrik11es/object-dot-notation My main problem was when accessing API data. { "hits":{ "products": [ { "name": "Shoe" } ] } } Imagine this is the result from an API. Usually to be sure that the data is what I want I'm gonna need to do: &lt;?php $result = r(); // imagine this is the result from an API with the json message abobe if(is_object($result) &amp;&amp; property_exists($result, 'hits')){ if(is_object($result-&gt;hits) &amp;&amp; property_exists($result-&gt;hits, 'products')){ $whatiwant = $result-&gt;hits-&gt;products; } } This is really time consuming. I just needed a way to do something like: &lt;?php $d = \Alr\ObjectDotNotation\Data::load(r()); $whatiwant = $d-&gt;get('hits.products');
Then what the fuck are you doing?
Boom. You got me... :) 
That's a real problem. I've found that in my career sometimes.
Part of the problem imho is that PHP conflates timezones and UTC offsets when creating a DateTimeZone objects. What's interesting to me is that if you want to model this in a pure fashion then UTC offsets are the only way to go. This is because timezones are really global mutable variables that change their values over time. The linked article was very interesting but I'm not sure I agree with Derick in that storing UTC offsets are inadequate in general. What he tried to do, if I understand it correctly, is to add 2 different types together, one being a product of a timestamp and an UTC offset the other being just a timestamp. This does not type check. What is missing when calculating with UTC offsets is the mapping between them and timezones. At any point in time when you want to do a datetime related calculation you would need to involve this impure mapping from timezones to UTC offsets. 
There is a nice plugin which always reminds you if an action could have been done with a shortcut. https://plugins.jetbrains.com/plugin/9792-key-promoter-x
I fixed it. Thanks a lot!
The only technical use case I can think of is you can code more after the /* */ style comments whereas // style is to the end of the line. So I think the teacher is talking bs, however it does come down to personal preference. Maybe they think its better to comment with /* */ and keep coding after it? But then its not really recommended to have long lines which affects readability.
There is nothing wrong with using this for single line comments. I often use these inside methods especially
Oh interesting! Thanks :)
&gt; You can go directly to php.net with a keystroke when you are on a method / function / whatever to see its definition. Very handy. It's SHIFT+F1 in PhpStorm :) There is also CTRL+Q to display the docblock definition in a popup, which works also for user functions.
We have the opposite problem. My coworkers started using Symfony for a project that.. does not need a framework. I tried to convince them to not use Symfony but just use the components...
Look into InfiniteWP. Will save you a lot of time. 
Meanwhile, simply queries take 10x the time to execute when using laravel's shitty ORM. That's why some of us prefer to do our own thing
&gt; No, it's literally akin to !isset($var) || !$var, as stated previously. That would also be incorrect for the same reasons (and less readable, to boot). So, on this being a good metaphor, we can agree. &gt; I completely respect the fact that you view programming as either correct or incorrect. I don't believe this, however. I've already demonstrated ways in which the code you prefer in this instance _will_ lead to bugs. That much is not a matter of opinion. If you don't see how code that will produce bugs is classifiable as incorrect, then I'm not sure we have much left to debate about. If it's simply a matter of verbiage used, then I'll be happy to switch to "inferior", "flawed", "broken", or whatever other equivalent is more palatable to you. Don't miss the forest for the trees here.
The NFS option on folder mounting is ignored by Vagrant on Windows: https://www.vagrantup.com/docs/synced-folders/nfs.html &gt; Windows users: NFS folders do not work on Windows hosts. Vagrant will ignore your request for NFS synced folders on Windows.
This is the story of my career they want to make it “closer source” and I’m like ok but you can still use open source and what do you mean “closed source?” Lol 😂 
Out of the box, the basic Symfony 4 skeleton installation does not have any dependencies on Zend. In fact, it's only non-symfony dependency is psr (cache,container,log and simple-cache). A more robust installation (the website skeleton) is indeed dependent on ZendCode and ZendEventManager. As well as a half-dozen or so other vendors. ZendCode is basically a code generator used for some of the optional utility maker commands. It in turn requires the zend event manager. There are other potential Zend dependencies. For example, the Symfony psr7 bridge uses a Zend psr7 implementation of the request/response objects. All perfectible reasonable.
Why doesn't the article, or even the linked website, have any name, or impress etc? That is not very professional. And often times not even legal. You should at least have some personal reference to who published this. That helps to resolve the question of credibility. These days, with more and more "fake data" out there, having an entity behind something being posted is crucial IMO.
Uhm... no revisiting being done: just fan-art.
Docblocks aren't single line.
Every project tends to grow. Today you need users, the next day ACL, the other day API. Symfony is nothing but a good structure, a skeleton, a *framework*. A chassis. Your servers are mounted to chassis instead of laying in a heap in the corner. What's wrong with having a chassis for the program well? I myself recently started two projects that don't require a framework, nevertheless using Symfony without a doubt. So when I get stuck I can ask on Stack Overflow, and if someone would have to take over, they would have a clear idea of the application's architecture. Gosh, it's almost 3rd decade of XXI century but I am still to repeat these arguments. That *is* the shame 
That's nuts. Especially if you're working on code that you know others will or may need to maintain someday, single line comments are useful for pointing out what you're doing and will help with debugging.. //if this number is greater than zero this is an update; else its an insert or $x = 'somecode'; // This is a quick workaround to fix the date for whatever. 
Kids prefer Reddit upvotes to validate them.
Unfortunately I have only so much free time :(
 class Foo { /** @var string $f */ protected $f; // ... }
Along the same vein of "Code Templates", I just ended up using custom project templates the last week. Doing lots of small projects (Like technical tests)? Have a standard quick start (Standard composer.json, couple of files, a phpunit.xml, maybe .htaccess and what have you), then just create a custom template. Every time you start a new project, you have all those things already provided
Single line comments on a line with code is ******* terrible though. Don't do that. 
Was it really necessary to provide those details :-/? It looks obvious this is a fan-art :-(.
Op, here, since i am playing around php bash scripts since a while, in combination with unix tools. Best for learning and quintessence is to avoid libraries.. This is full power, where peoples claims security concerns, i see freedom! Php 7 SPEED is on the top level, beating node and python... Maybe anyone will finds interesting stuffs on my github: https://github.com/webdev23?tab=repositories 
I used to use the VB shared folders, but it was slow as hell. I was getting 1.5-2 second response times on my pages. When I switched to NFS I went down to 200-300ms. Now after switching to local files I am down to 50-100ms. 
Eh, I think you're getting into personal preferences there. It depends on the use and intent. I dislike hard and fast rules as there are exceptions for (almost) everything.
Well it might be preference but I still have good reasons. I often end up doing things like selecting a full line with something like "Home" &gt; Shift + "End", but if I want to remove the comment this way, I cant. I need to actually move the cursor to the start of the comment. It could also add problems with indentation, multi-selection, or just reformatting/copy-pasting. Call me silly, but it's just wasting time for me. Example : If I want to copy the line with the comment along with the line below it, but don't need the comment because I'll edit them slightly and it's no longer relevant, then I need to either copy paste two times or once and then remove the comment. In the end you lose nothing from putting it on it's own line and you may (or not) save time, so the choice is obvious for me.
There is no problems if used àlone in a whole line. Just don't do this: `myfunc(){ //comment` in the same line. Because php will lose time to parse it. Myself using it a lot for temporary comments [ctrl+e on geany] when testings, to make the difference with «hard» comments designed to stay in place, to those i use `/**/` Also, depending your editor, they may highlight differently, this is good stuff.
That and the framework is just tremendously bad.
No, not talking about AJAX. I'm referring to command line utilities. Say you are printing text to a terminal, you don't have the option to both listen to input and print output at the same time.
Hello, I started learning PHP not too long ago and started off by going through the PHP Practitioner on Laracasts. I have a NodeJS background so I have some experience with the back-end already. I was wondering if experienced PHP devs actually make their own custom frameworks more often than using a framework? I was able to go through the videos and follow along pretty well, so I have a general understanding of what we had to do to make a custom framework, but using something like Laravel, Symfony, Zend, etc. seems like the way to go. Certainly, it wouldn't hurt for me to make a couple projects using a custom framework to reinforce my knowledge, but it is something I need to invest a lot of time in? Or am I pretty much going to be using an established framework if I were to apply for a job?
Thanks for that. This seems to match javadoc, interesting reading: https://en.wikipedia.org/wiki/Javadoc 
deptrac https://github.com/sensiolabs-de/deptrac is missing
Building a custom Framework will definitely help you understand the basic of how a framework would function, and it might be a good tool for some personal projects. But unless you are a REALLY specific need, you will always use an existing framework. I don't know any developer or company that uses a custom framework (and doesn't regret making that decision).
You found out! I need to go into hiding...
That's right, there is no easy way to handle keyboard keys in real time. The closest would be `readline()` in a loop. Do you know a way to do this in other shell compatible langs? 
&gt; And often times not even legal. wat.
Yeah, I've seen it work with plugins and other hacks. If it works for you, fantastic.
This is typically the way it works. An added benefit of using an existing framework is the documentation around it. There are standards in place that are readily available, if someone else were to jump in and help you on your project or take over, they most likely have a working knowledge of the framework. If you roll your own, you start to make up your own conventions, without documenting them carefully, it's goin to add time and strain on someone else to learn what you did and how things work. 
Instead of giving them a `user_type`, it would be better to add other tables and have one to link users and types. This also allows you to have multiple types for one user and a types table which can have more information than just a "type", like, I don't know, allowed actions, login limits, action priority, etc. So not only can you have more than one type per user but also more than one setting for each type.
You've got to back up a bit -- before you try and make users into groups, make users. This will involve making a database table for holding user data. It will hold their internal user_id, their username, email, all that good stuff. One of the things it will also hold is their group_id (ie 1, 2, 3 or 4). Then you allow/deny access to stuff based on their user_group_id
Agreed. That's why I opened the comment pointing towards RBAC which does exactly what you described. The user_type was a simplistic implementation example for the simplistic scenario in the question. 
Probably because ?&gt; on the same line as the comment is a confusing case. &lt;?php //echo $test; ?&gt; 
https://github.com/lxrco/omnifraud I have been working this last few days on open sourcing this library we built internally. The goal is to have an common interface for fraud prevention services. We used it internally to compare the result of two services and eventually decide on which one we were gonna use on the long run, and also added our own service base on our customers historical data.
You're misunderstanding my reaction. He's asking "why is wordpress hated" and then he says twice "it's easy to hack, the keyword here is easy". It's like it's a parody question that answers itself.
Yikes, it would be sad if this was the only context to consider when/why to use the different commenting styles.
yes, works great, even for large projects.
why do people make up these arbitrary style rules and try to teach anyone that it's "a thing"? this isn't a thing. your teacher is pulling shit out of his/her ass. here's _my opinion_ on when line comments are useful: use line comments when you are making a short, simple notation for another programmer (or more likely your future self) to explain why a particular line of code is written the way it is if it isn't obvious without some context. use the comment to add the minimum amount of context needed to understand why you wrote the code like that. 
I can't believe I never thought to look for something like this. Thanks!
I more or less agree with your sentiment generally, but it stands to reason that many of the best-in-class projects we now use ubiquitously were started, if not completely developed, from scratch by single developers with alternatives already in the scene.
I think simplest would be to make an ajax-call or call a php-function directly at page-load.
Gotcha. Thank you for the reply!
Yeah, node is the same way haha. Just wanted to make sure. Thanks for the reply!
its api is a fucking disaster. 
Hello, can someone suggest me some php telegram chats in English? I'm wondering is there any +- popular chats about modern php, I would like to discuss design patterns, rest/graphql APIs, SOLID, KISS and other principes and so on, but can't find single English chat in telegram, can you help me?
Hey im working on a web server. i have two files in html/ folder. 1.html 1.php when i load 127.0.0.1 ... the php script gets executed. Shouldnt it only execute when i go to 127.0.0.1/1.php it gets executed.
Throw us 2.7 already! 
I think you need to escape some asterisks in your comment.
Are you sure about that? How did you know about "execution"? Maybe you have .htaccess file inside your folder?
we're still not at Perl's CPAN level of nested dependencies but we are certainly heading in that direction. I really waffle on whether composer was really that good of an idea.
I’ll agree with that. It’s much easier to delete a line with a keystroke then go to live code, go to the end, and delete the comment. Give it some room, make it easier to read (and edit and delete).
Cmd + X Ctrl + X dd (for Vim) Much easier to delete then going to the end of live code and removing the comment. Put it above the code.
But you’re not supposed to end code (unless you’re talking about inline code that’s mixed with HTML and stuff. 
would really love to hear why you think that
What do you do? 
Lots of personal opinions being tossed around as law around here.
thanks! I forgot to go back and check it looked right
I’m going to bin the work I’ve started and contribute to this 
I suck off dudes for cash
No, he means Zend framework dependencies, not Zend Engine, which is entirely different.
PSR-2 standard. Not a personal opinion. There’s a reason why a pure PHP file doesn’t end with `?&gt;` and also ends in a new line.
It's both loved and hated for the same reason : Wordpress doesn't force OOP onto the developer.
Hourly rate is prob pretty solid
It's your personal opinion to follow a non-enforced standard. But what do I know, 20 years ago I was hanging out with Rasmus and Monty at a San Jose conference talking about his daughter My. I wrote the Hashtag Framework to support the Hashtag Markup Language on top of PHP, and know the PHP internals inside and out... I also understand how users of programming languages don't always do things the way you'd like them to, and if you don't address the problems they create, they quickly become your problems.
Did he recommended `#` for it? Maybe you misunderstood, because single line comments are not bad themselves, but usually indicate there's a problem with the code readability when it needs to be commented. These comments might be removed by extracting part of the code into separate method/variable (or better naming for existing ones).
&gt; What is really mind-blowing is the fact that despite all these marvels' existence. Oh yes, the endless dependencies - so marvel, very amaze, much mind-blown. 
There are few things I'm not sure are great to see in an actor system like this: - It's extension-based, instead of an independent PHP library that can run on any host + optional extension to improve performance for those who need it. - The Actor metaphor is not implemented cleanly: you're calling static methods to control actors, and instead of implementing a clean minimal Actor interface, you're extending an Actor class with bunch of methods on it, thus creating the possibility for future method name conflicts etc. - Actors should have no string name, but opaque addresses, which can be passed around, but not constructed by hand as bunch of letters, thus creating the opportunity for collisions and conflicts. - Instead of constructing an actor and passing it to the system, we pass a static class reference to the system and arguments. Many opportunities for custom actor factories and code reuse are lost when a library locks you out of object creation in this way. Thoughts?
It’s a pretty heavily enforced standard actually. Zend, Symfony, Laravel, etc. enforce it. It’s built into linters and everything else. It’s realistically the only standard we have in PHP. You’re free not to use it, of course, but it sure makes thinks easier for contributors, other developers, onboarding, documenting, and training.
Yeah, so heavily enforced that [the very first page of the PHP getting started documentation includes 2 samples of code, and they both break that "standard"](http://php.net/manual/en/tutorial.firstpage.php). The last example is even "pure PHP", and still includes the closing token.
PHP.net is your counter, seriously? Yes, let’s browse the comments and examples there for the epitome of code execution. I bring up packages, you bring up core. That’s not what their documentation is for. 
Ooh we’re going to the Laravel remarks. Sweet. I’m glad your one example of your framework being used by a Fortune 100 company makes it somehow relevant to anything or anyone besides you. Let me know when it’s a Fortune 10...hell, I’ll give you 50. Good luck in 1998. I’ll leave the cgi-bin open. Don’t let it hit you on the way out.
Um, you brought up PHP.net. I didn’t. They provide documentation on their functions and methods and implementations, not code styling. That’s what PSR-2 does. Let’s all comment code with hashtags though...
Commenting with a hashtag has the exact same problem where someone will comment out a line that includes the PHP close token ?&gt;, and confusing things will happen. I brought up PHP.net because they are the authoritative source... the "core" as you put it.
Definitely followed that rule in college. It’s not 2002 anymore though, I’m not a kid living in my parent’s basement, and neither are you.
All of the PHP files included in the Hashtag Framework don't end with a close PHP token... I know why. I also know why it isn't generally enforced by PHP, and why millions of PHP software projects don't follow the guideline, and yet they still do exactly what they were created to do. You still use Google? You must be stuck in 2006 in your haze induced time traveling.
Holy shit. If you don’t end them in closing tags why did you even comment?! I specifically said you don’t end PHP files with closing tags, you argued, and now you agree. And yes, I use Google (or Bing or whatever else I need to to get the answer to a question or find the result I need). You’re just going around and around and ultimately agreeing with me.
How is that somehow relevant to anything or anyone besides you? My new theory is that the teacher doesn't recommend using // comments in PHP because they don't recommend using PHP at all, as it would include dealing with people like you.
Put down the pipe and read the original question and my original answer again. ?&gt; is widely used, whether you like it or not.
You just talked about BIG and his song, specifically about not getting high on your own supply. I said I’m aware of that, I know the song, I grew up with it, and I loved it in college. What it has to do with PHP, I don’t know. Do you even read what you comment on?!
Any teacher who says not to use a popular language is silly. There’s plenty of companies looking for PHP and full stack developers with a focus on PHP who are certainly paying more than some professor teaching outdated methods and giving ridiculous opinions on something they know nothing about (or know about, but only knew about it to the extent of possibly PHP 5.1.x and below). 
It seems you don't know a lot.
You're silly.
Yes, use PhpStorm on mac, with nfs client. Have code stored on VM and run nfs server.
Generally I try to learn keyboard shortcuts for everything. But one place mouse shortcuts can be nice is debugging. Try binding ctrl-mousewheeldown to step into, ctrl-mwheelup to step out, etc. Let's you scroll through execution.
If your university was like this I don't blame you. If you are going to go to a university for programming (or computer science) you really, really need to do your research so you don't get programs like OP's and Itsochev's; I promise that there are universities teaching programming at a much better level than this.
It's great for when you are putting code with comments on a slide and you generally have more horizontal space than vertical space but generally I support avoiding them. I wouldn't say "terrible", though.
&gt; just (quite nice) Reminiscing about the deaths of tens of millions at the hands of Communists is "quite nice" -- greaaaaat.
It is nothing until you dig into npm dep :D
Rather than nfs, why not mount the directory as a virtual box shared folder? Then you can work with your IDE on your preferred platform and get immediate feedback in your VM. That’s how I have it. Same exact server config in the web and in virtualbox, except VB also has virtualbox guest additions installed. Everything, including errors, is reproducible. 
It's too slow, I work on some heavy projects and most of the time you aren't using cache in the development process so even bootstrapping takes forever.
You should really try some other editors if you think that vs.code works great.
Thus the question.
I've been toying with PHPStorm which is plagued by the same issues NetBeans/Eclipse has. It's slow and clunky AF. I've also tried Sublime Text 2 and 3 and albeit being very fast, it still lacks something for me. VS.Code's debug capabilities are unparalleled in comparison. So yeah, what else do you have in mind, because the list is getting short. I've also tried Atom and I find no real differences between Atom and VS.Code, infact the latter seems like a story of the clone being better than the original. With Atom being a large download, slow install and slow bootup. I work at a company that has uncompressed styles.css file that has 22k lines of code. Most "great editors" choke themselves to death on that file. VS.Code and Sublime Text do not.
When one knows your mindset, your comments can be even amusing. Snarl at some minor and unimportant issue as though it's some big deal :) *Pretending I took your bait:* no technology is a silver bullet that costs you nothing. Surely any improvement has its drawbacks. But those don't make a *marvel* at whole less marvellous.
I live in Plovdiv, Bulgaria so I'm a little bit screwed. Sofia has great universities but somehow I don't want to start over in a new city. Rather pay a subscription to some lector and watch actual programming classes &gt;.&gt;
Well yeah PHPdocs were based on Javadocs back in the day. https://en.wikipedia.org/wiki/PHPDoc *from the wiki* &gt; PHPDoc is an adaptation of Javadoc for the PHP programming language.
The rules are actually very simple, just hard because of lack of education and past mistakes. ## Theory 1. For past times (e.g. log entries) what you store doesn't matter as long as you know what format it is -- you can always translate it to any other timezone with 100% accuracy, by virtue of offset rules not changing retroactively. 1. For future times, the *correct* solution is to store wall-clock time, which is a timestamp fixed with a timezone *region*. This concept represents the time a clock, hanging on the wall at the location of the event, would show at the time of the event. 1. You should *probably* leave your server running in UTC, or at least some other region without DST, so that server times are stable. Many services rely on a stable system time and don't handle DST well; cron is one example off the top of my head. ##Practice Unfortunately there is no standard serialization format for true wall-clock time. You can get *very* close with a tuple of `(timestamp, timezone region)`, suffering only a little bit of inaccuracy in the hour of DST transition (heuristics for rounding up or down; I don't know what PHP does here), and it's a very simple, easy, and platform-independent storage format, making it a very *pragmatic* solution. You can't use Unix timestamps for future times for the same reason you can't use anything other than wall-clock time for future times: offset rules change (absurdly often!) and Unix timestamps have no timezone region, only an offset (which should be `+00:00` but isn't in all implementations). More concretely, you *could* use Unix timestamps *if* you were interested in storing future times fixed to the "UTC region" but 1) that's nonsensical, and 2) it's just a corner-case of wall-clock time, i.e. future time fixed to a specific region. This is also what Derick Rethans arrives at but I *think* he makes a mistake: `setTimezone` does not affect the underlying value, only the view onto it, but I *think* setting the timezone at construction is absolutely essential. I admit to having some trouble understanding his examples even though I know where he starts and where he wants to end up (by using Unix timestamps, half his examples end up implicitly violating rule \#2). Then, finally, you also need to be aware of database implementations. Derick mostly covers this but: 1. in accordance with the SQL standard, an appropriate data type is `TIMESTAMP [WITHOUT TIME ZONE]`. 1. MySQL unfortunately implemented `TIMESTAMP` incorrectly so that 1) it always has a time zone, and 2) you can't affect that time zone, so in MySQL you should avoid `TIMESTAMP`. Instead, `DATETIME` is equivalent to the SQL standard's `TIMESTAMP`, and the standard does not define `DATETIME` so things will either work correctly or not at all (that's a good thing). 1. If you need to support *both* MySQL and PostgreSQL you can break the tuple into `(DATE, TIME, VARCHAR(100))` -- that works in all mainstream RDBMS except Oracle which doesn't understand `TIME` (aaargh!). 1. You never want to use the `... WITH TIME ZONE` variants because they carry out a bunch of implicit conversions that are both wrong in theory and unwieldy in practice. By correlation, it doesn't matter *which* time zone MySQL wrongly implements `TIMESTAMP` with, the problem is there is *any* time zone *at all*.
Also the main benefits of university is to give you the time, environment, and guidance to do your own learning. Generally you are not going to be 'taught'. Except to be taught how to teach yourself. My professors said a lot of things which were wrong or don't make sense but I still learned a lot.
Great, totally relevant to the php community...
&gt;if it was so "bad" people would be running from it, they're not Nope, most of the wordpress users have no clue how ugly its codebase is, and from experience, many of its plugin developers dont get modern coding practices at all and are happy being mediocre.
What does this post add on top of the existing Laravel docs?
&gt; It's extension-based It *has* to be extension-based. PHP does not have stackful context switching (of the C or VM stack). There's also the issue of running actors over multiple threads, handling of global configuration state in the actor system, etc. &gt; you're calling static methods to control actors, and instead of implementing a clean minimal Actor interface, you're extending an Actor class, thus creating the possibility for future method name conflicts if the Actor API expands etc. What static methods are being called to control actors? There are only two static methods you will interact (neither of which control actors - see the [API](https://github.com/tpunt/phactor#api)). Extending the actor class is necessary to invoking the built-in `Actor::receiveBlock()` and `Actor::send()` methods. This may change in future, though, where these two methods are changed into utility functions. If this happens, then the Actor class may turn into an interface, where only the `Actor::receive()` method needs to be implemented. I'm not quite sure how I'm suppose to predict and prevent future naming conflicts... Also worth noting that inheritance is used by the Akka project when implementing actors too. &gt; An Actor should be runnable outside the system as a simple object that takes messages and returns messages. Makes testing much easier. And makes abstraction much easier, i.e. running some actors on another system transparently without your app having to be aware of this. Admittedly, I haven't thought a great deal about testing yet. But to have actors created outside of the actor system sounds off to me. Regarding your second point, `ActorRef` objects provides the necessary abstraction that will be reused later for remote actors. &gt; Actors should have no string name, but opaque addresses, which can be passed around, but not constructed by hand as bunch of letters, thus creating the opportunity for collisions and conflicts. Actors already do have opaque addresses. They are held in the `ActorRef` objects, where a message can be sent to an actor using either an `ActorRef` object (which will use its internal ref), or to a string (the actor's name). They are held in separate hash tables, so there are no conflicts. The ability to name actors is a nice convenience that is also provided by BEAM's implementation of actors. &gt; Instead of constructing an actor and passing it to the system, we pass a static class reference to the system and arguments. This is a necessary evil when creating actors across multiple threads. Otherwise, we'd have to serialise the property tables of actors (similar to what `Threaded` objects in pthreads have to do). The ability to have the actor system scale vertically by allowing it to exploit multicore systems (as well as scale horizontally later on when remote actors are introduced) is quite important, I feel. In particular, there's a lot of blocking operations currently in PHP, so saturating the cores with more threads is necessary in order to better utilise a machine's resources.
Contributions are very welcome (and much needed)! Feel free to ask me any questions :)
Laravel docs are undoubtedly excellent and love it. But sometimes, for newcomers or those who don't go thru entire documentation, such blog posts with examples, simpler language are useful. Also, I love to post on whatever new things I keep learning, in a simpler easy-to-understand post with examples.
&gt; It has to be extension-based. PHP does not have stackful context switching (of the C or VM stack). There's also the issue of running actors over multiple threads, handling of global configuration state in the actor system, etc. Cooperative threads is an interesting and useful feature, but not a requirement in the Actor model. I get around it by simply doing a small piece of work in a specific receive(). If I have a larger job to do, I send myself a message to do the next piece later. As for multithreading in order to improve performance, one could go a long way with forking. As to global configuration state, not sure what that refers so but an actor system needs no global state in general. It needs messages and actors, neither of which is global. &gt; What static methods are being called to control actors? Just from the sample alone these make an impression: &gt; ActorSystem::shutdown(); &gt; new ActorRef(Test::class, ['arg 1'], 'actor name'); These imply there's just one actor system, I add actors by just creating them and assigning them to... nothing, and I shut down the actor system via a static call. That's not flexible. I've used multiple systems in order to isolate and prioritize different types of work, also it eliminates this global state which causes problems later. &gt; Extending the actor class is necessary to invoking the built-in Actor::receiveBlock() and Actor::send() methods. This may change in future, though, where these two methods are changed into utility functions. I'd propose something like the following design for you: interface Actor { function receive(ActorApi $api); } interface ActorApi { function receiveBlock(); function send(...); } &gt; I'm not quite sure how I'm suppose to predict and prevent future naming conflicts... You can prevent them by separating the concerns like above. The API you want the actor to use is one concern. The methods you want the actor to implement is another. No need to fuse both together. &gt; Also worth noting that inheritance is used by the Akka project when implementing actors too. Akka is a very robust and popular Actor system implementation, but it has made a number of poor design decisions which are recognized in the community. They have this baggage to support for B.C., but if your project still has the chance to do better, rather than copy what I, at least, see as old mistakes Akka is stuck with. &gt; Admittedly, I haven't thought a great deal about testing yet. But to have actors created outside of the actor system sounds off to me. It may be off if you have concerns like cooperative threading and so on. To be fair, I don't have these concerns when I work with actors. I follow these simply definitions: - An actor is a simple object that receives and sends messages (including a type of message that adds/creates an actor to the system). - The actor system routes messages between actors. In that context the actor is not part of the actor system to begin with, it participates in order to receive and sends messages. This makes it easy to test an actor in isolation, or have it participate in different systems that follow the same interface. &gt; Regarding your second point, ActorRef objects provides the necessary abstraction that will be reused later for remote actors. [...] or to a string (the actor's name). They are held in separate hash tables, so there are no conflicts. The ability to name actors is a nice convenience that is also provided by BEAM's implementation of actors. Noted. There are still actor names, though. I get it - Akka etc. have names as well, but it's a mistake, IMHO. An explicitly created name represents a piece of global shared state that's introduced for minor inconvenience, but philosophically fights with the very purpose of actors as objects that are not aware and have no access to global state. It introduced the opportunity for name collisions, and "back channels" where actors reach to one another without another actor explicitly putting them in contact (by sending a message with a reference in it). You say there are no opportunities for name collisions, but I'm not sure how that'd work. If two actors name themselves accidentally "foo" and I send to "foo" what happens? One of those happens: - Both get the message (most likely). - One or the other gets the message (depending on creation order, random, or whatever). - Neither does. Neither of these three options is correct, as when I sent to "foo" I mean one particular "foo" but the system can't know which one I meant, because it permits collisions, but the sender is not aware of the collision. Actors should learn about one another through references, and names basically allow developers to be lazy and write actor spaghetti where it's unclear from the message flow which actor depends on which other actor. I'm not a big fan. It's like singletons, or global variables in that regard. &gt; This is a necessary evil when creating actors across multiple threads. [...] The ability to have the actor system scale vertically by allowing it to exploit multicore systems (as well as scale horizontally later on when remote actors are introduced) is quite important, I feel. I understand how with your way of scheduling you might need this. But probably there's still a way to specify factories instead of classes. A factory would always be more flexible than a class. Let's say you normally initialize an actor like this when given a class: $actor = new Test($a, $b, $c); Now we move this to a factory: $actor = $factory($a, $b, $c); And here are two separate factories: function ($a, $b, $c) { return new Test($a, $b, $c, 'additional config here', new BehaviorTypeA(), ...); } function ($a, $b, $c) { return new Test($a, $b, $c, 'different additional config here', new BehaviorTypeB(), ...); } Instead of having two classes `Test1` and `Test2` with *hardcoded* additional parameters into them, I can have a more generic `Test` class with additional parameters, and differentiate their state and behavior through the factories I define. This would significantly promote code reuse and eliminate pointless boilerplate classes just for statically configuring reusable actor classes.
This is art. You can dislike communism (social/politics), but this is just about art here.
Yeah, the older I got the more I understood when people said don't recreate the wheel. Sure recreating the wheel is great for understanding how the wheel works and turns, but in the end I want to make sure my wheel never falls off going down a gravel road ;)
Traffic to his website?
Are people still using cake? I've never used it but always considered it the equivelant to codeigniter which is long dead, has it progressed and modernised?
PHP development began in 1995 when Rasmus Lerdorf wrote several Common Gateway Interface (CGI) programs in C, which he used to maintain his personal homepage. He extended them to work with web forms and to communicate with databases, and called this implementation "Personal Home Page/Forms Interpreter" or PHP/FI.
CakePHP is a free, open-source, rapid development framework for PHP. It’s a foundational structure for programmers to create web applications. CakePHP goal is to enable developers to work in a structured and rapid manner–without loss of flexibility. CakePHP takes the monotony out of web development.
&gt; and I don't want to use Docker It seems the standard setup for dev machines is rapidly moving towards Docker. You might want to look into it.
Rasmus Lerdorf is known as the father of PHP. PHP development began in 1995 when Rasmus Lerdorf wrote several Common Gateway Interface (CGI) programs in C, which he used to maintain his personal homepage. He extended them to work with web forms and to communicate with databases, and called this implementation "Personal Home Page/Forms Interpreter" or PHP/FI. PHP/FI could help to build simple, dynamic web applications. To accelerate bug reporting and to improve the code, Lerdorf initially announced the release of PHP/FI as "Personal Home Page Tools (PHP Tools) version 1.0" on the Usenet discussion group comp.infosystems.www.authoring.cgi on June 8, 1995.[13][14] This release already had the basic functionality that PHP has as of 2013. This included Perl-like variables, form handling, and the ability to embed HTML. The syntax resembled that of Perl but was simpler, more limited and less consistent. Lerdorf did not intend the early PHP to become a new programming language, but it grew organically, with Lerdorf noting in retrospect: "I don’t know how to stop it, there was never any intent to write a programming language. I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way." A development team began to form and, after months of work and beta testing, officially released PHP/FI 2 in November 1997.
Your `setPasswordAttribute` is not a good example as many people implement the auth password reset that is included in Laravel which already takes care of hashing. In effect, your password will be hashed twice and nobody would eve be able to log in. You need to have something like the following: public function setPasswordAttribute($password) { if (app('hash')-&gt;needsRehash($password)) { $this-&gt;attributes['password'] = app('hash')-&gt;make($password); } }
That's interesting in a way as I know of so many universities using Moodle for ages. Maybe your university does not have one - if it has one point them to it!
I’m using it on some legacy projects and I’m not sure why someone would choose it over Laravel for a new project these days. The lack of a framework-level IoC container is a major pain point for me. 
omg thanks dude ! . im new to php .... so i was ignorant of .htaccess. It works now !. 
PHP guide
"It's aaaaaaart!" Sure -- if there was a swastika on it, or if it had Hillary on it, it would just be aaaaart and not have any greater meaning at all.
Yes, it's awesome
&gt; I get around it by simply doing a small piece of work in a specific receive(). If I have a larger job to do, I send myself a message to do the next piece later. Do you mean [something like this](https://gist.github.com/tpunt/2969ff020135bcefa19f93c9617ee4d2)? &gt; As for multithreading in order to improve performance, one could go a long way with forking. Why would multiprocessing be any simpler than multithreading? &gt; As to global configuration state, not sure what that refers so but an actor system needs no global state in general. &gt; [...] &gt; These imply there's just one actor system, I add actors by just creating them and assigning them to... nothing, and I shut down the actor system via a static call. That's not flexible. I've used multiple systems in order to isolate and prioritize different types of work, also it eliminates this global state which causes problems later. You seem to have had quite different experiences with the Actor model to me. My experience comes mostly from the BEAM VM (specifically, from Elixir). This means we have one actor system per OS process where that process is multithreaded to utilise all of the machine's cores, and registering actors is done in the background (an actor simply needs to be spawned, not registered to the actor system). I'm curious to know more about what you think the advantages are of enabling any number of actor systems to be created. You mentioned isolation, but why not just create a separate supervision tree (not technically part of the actor model, I know), instead of a whole new actor system? You also mentioned prioritising different work types by creating different actor systems. Does this mean that an actor system will map directly to one (or possibly more?) processes? Is this really a good thing that the potential for parallelism of the application (read: the number of OS processes on which it runs) is being based upon the number of actor systems running in the application? Or am I misunderstanding you? Because if an application has 5 actor systems, mapping to 5 processes, then that won't scale vertically when you add more cores to the machine. &gt; I'd propose something like the following design for you: &gt; [...] That API won't really work, since the `receiveBlock` and `send` methods need to be implemented internally. For example, the former needs to perform a context switch (though, I realise above you have mentioned that you don't think this is necessary). &gt; I follow these simple definitions: &gt; [...] I see. The fundamental reason why it didn't make sense to me to have actors outside of the system is that I have followed the way BEAM has done things (as mentioned above), where everything is a process and is managed whether you like it or not. This is something that is definitely subject to change, though. &gt; There are still actor names, though. I do agree with you here. It seemed strange to me when I first learnt about the ability to name actors, since it seemed to go against one of the axioms of the Actor model itself. I believe this topic comes down to pragmatism vs puritism, though. Having the ability to name an actor enables you to forgo all of the work of setting up complex actor dependencies between one-another, where various actor refs would need to be passed around to other actors in order to make them "known" to those actors. I am definitely open to removing actor naming (it would certainly simplify the extension internals, too), but naming actors can make things a lot easier for the developer. &gt; If two actors name themselves accidentally "foo" and I send to "foo" what happens? Whilst actors are officially created asynchronously, internally, they are partially created synchronously (this involves updating the actor ref and name hash tables). An upfront check sees whether the actor can be created with the given name - if it cannot, then an exception is thrown. This, again, comes down the the automatic registering of an actor in a single actor system (which is probably why it didn't make much sense to you). &gt; Actors should learn about one another through references As said above, I do agree here, and I know this is one of the axioms of the Actor model. It just seems to be ignored by all major implementations out there (likely due to ergonomics). &gt; But probably there's still a way to specify factories instead of classes. &gt; [...] The only problematic thing I see in your factory example is the dependency injection, since the dependency will need to be serialised. I don't really see a way around this.
I don't understand why people are so focused on frameworks. My experience: * Every year there's the new \*hot\* framework. * It's such a pain to learn all the ins and outs of yet another framework. * Every framework is continuously changing. You need to constantly stay updated with new features. * Often new versions aren't backwards compatible. * The painful situation where you're developing on an older version. Knowing everything will need to be rewritten. * Finishing a project knowing very well your customer will be running on outdated software. * That situation where the framework simply wasn't designed to do what you want. * How code purists love to code with ORM's. Only to discover that it has no support for the SQL statement that would greatly improve performance. * When you follow all the conventions. Only to find out your code is executing 5 subqueries with every record in the simple table you're trying to display using your marvel's existence. * To have a complete templating language written in PHP while PHP already did that for you written in C. * To have a complex router written in PHP while nginx already perfectly routes requests to folders and php files. * Needing to come up with complex cashing solutions to solve the performance problems. * Repeat for your front-end Javascript framework. It's because of this I did some projects in vanilla PHP. It's been a surprising experience how easy it is. I ended up writing my own "framework". But I can hardly call it a framework. Just a way to nicely organize files and easily cherry-pick some components where needed. I didn't write an ORM. But rather a flexible SQL string builder that allows for any exotic SQL you can imagine. My database could nicely cache and optimize for the complex queries. Blazing fast speeds. Hello, AWS micro instance. Sorry. Just needed to throw that out there. :)
&gt; Even if you can disable everything you don't need in PHPStorm, in that case I don't see the point to use PHPStorm. For the auto completion maybe? It's a strong feature but to me not strong enough. Well... Yea :P If you don't need what PhpStorm provides then I suppose you don't need PhpStorm. &gt; For the performances I have an I7-2670QM CPU @ 2.20GHz and 16Gb of DDR3. I'm on an i7-7820HQ CPU @ 2.90GHz and 16GB RAM. I do have an SSD which likely adds to the perceived performance when loading new projects/files. But general coding related performance(autocompletion, loading new files and highlighting them, etc.) don't see any slowdown.
No worries it must be reliable, they are gone to the moon 30 years before php², with 4kb of ram. 
&gt; Every year there's the new *hot* framework. there are no new names for at least 5 years. New versions - yes, but that's different. Everything evolves. &gt; It's such a pain to learn all the ins and outs of yet another framework. Life's a pain as a rule. Any learning is a pain and when ypo stop learn you lose. &gt; Every framework is continuously changing. You need to constantly stay updated with new features. Come on, that's what you WANT! "every tool constantly upgraded. why should I constantly stay updated with new features? I like my stone axe". If everyone were like you, we'd were talking in a cave now. &gt; Often new versions aren't backwards compatible. That's the price for keeping up with the technology. PHP can be blamed for that as well. However if you keep with recommended practices, it'sn ot that painful. Last year we changed from Symfonly 2.8 to 3.2 and it went quite smooth &gt; Finishing a project knowing very well your customer will be running on outdated software. Buying a car knowing very well your will be riding an outdated design. EVERYTHING evolves in tis world and everything gets deprecated. Your self included. &gt; To have a complete templating language written in PHP while PHP already did that for you written in C. PHP overgrew these child clothes a decade ago. In a nutshell, in some of your whining are just denying the reality and some are objective drawbacks - the price you have to pay for the better performance and support. The rest are just subjective complaints that of no practice value. Brace yourself. 
If PHPFI was used....
So the program is exactly that: A silly sketch of SQL queries mixed with HTML (or XML) output. There's just many roads to Rome. Frameworks have a tendency to lead to monolithic solutions. It's a bad idea if you're managing all the things you just listed with it. A better architecture has its concerns separated. Who knows you might want to make a certain component in Node.js. You might want to run it through Apigee. You're overall architecture should be able to deal with that. I know all the arguments in favor of frameworks. I'm speaking from personal experience. Having had too much headache from frameworks. And finally experiencing how PHP itself is already a beautiful framework in its own right. A true feeling of relief having not to deal with all the headaches. How fast it can be if you can maximize leverage on the C code (and minimize on PHP code). 
You are take it upside down. It's your sketch monolithic, whereas framework offers you decoupling and code reuse. You are yet to learn this lesson.