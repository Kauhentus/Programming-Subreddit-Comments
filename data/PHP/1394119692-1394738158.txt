I'm confused. Are you talking about nginx proxies?
Agree with James here, and Taylor for all the good you've done the PHP community you do come across as such an ass-hat, try to tone it down.
Now, now, don't be a smartass. That's MY job description.
To some. To others "the other side" comes across as ass-hats. I just don't have much patience for people who seem to make it their sole job to pontificate to others how to run their open source projects while peddling their e-books. In the end, I don't really think any of us are "ass-hats". I choose to believe we're all pretty decent people trying to do our jobs. I think Brandon, Paul, and whoever else are good programmers.
Wow, you just put so many words in Taylor's mouth.
Keep it classy, my friend... :)
I don't think anyone here is criticizing "programming skill." The criticism, such as it is, is on "word choice." Calling them "facades" when they are more like "proxies" was a poor choice of words, and that is all. Changing the word choice means few or zero changes to code, and that particular criticism vanishes. (For the record, I've backpedaled on more than one issue myself to correct mistakes, and there's no shame in doing so.)
I use MAMP at work and WAMP at home, and robotevil is correct: the UI on MAMP is *far* superior. 
The server world is a different domain completely. We're talking about two terms sharing the same space, programming patterns/concepts. You're just teaching your users the wrong terminology. By calling them proxies you benefit them two fold 1) They correctly learn what proxies are 2) They don't incorrectly use the term facade outside of Laravel. It doesn't matter what I say anyway, you won't change them as you come across pretty stubborn and childish from what I've seen on twitter/reddit.
I devote three years of **free time** to changing PHP development for 10s of thousands of developers and their businesses while you simply get mad that "Facades" aren't called "Proxies" - and _I'm_ the childish one.
When someone says there is chance of confusing a proxy class with a proxy server, because both of them contain word proxy, and say that with such arrogance, I don't know what else to say. 
I think so; you can either bind it with a name `$app['roles.users']` or a class alias. I *think* that just doing `App::instance('MyAliasName', $instance)` should do the `class_alias()` stuff automatically but I haven't tried it. In this case however, I'm not sure why the OP is injecting a User class.
My article also mentioned having tests to everything before attempting this =)
 You say decline which is true but still much higher some others http://www.google.com/trends/explore#q=php%2C%20%2Fm%2F0505cl%2C%20python%2C%20django&amp;cmpt=q
I truly hope that your life improves to the point where you don't feel the need to say these types of things about another person. I really do like most of people in this thread who disagree with me, it's just that we disagree on this issue, and I have bigger priorities than renaming something in Laravel because a few people who don't even use the framework say so. I just have bigger projects to work on.
How so?
Right, but in PHP land functions are snake_case and methods are generally camelCase (with the exception of two non-core extensions).
Right.
You're not a nice person.
you're really bad at trolling
You know what? I could have considered giving a try to your framework. This kind of comments makes me doubt it has any value other than helping get new dev into shitty habits like 90% of php tutorials. The GoF coined terms to widely used patterns as to help people explain why they do things easily. Instead of telling your colleagues that you created these interfaces this way as to achieve this result you can just tell them you implemented whatever pattern you did. And they can know exactly what you did just with this term. That is, unless you start using one in the place of another.
Who fucking cares? PHP community is so bad. It's like the PHP-FIG bikeshedding has leaked into the community. Next thing we will have a full blog post on spaces vs tabs and a reddit thread abusing Taylor once again because he doesn't care about such irrelevant shit.
&gt; Laravel is hardly the first time a IOC container has been implemented in PHP. Please cite your proof.
&gt; I have bigger priorities than renaming something in Laravel because a few people who don't even use the framework say so. Dude, seriously, I totally get that. But you are training developers to use at least one significant term incorrectly. The CodeIgniter guys did that with "Active Record" and it damaged those developers' understanding and hindered their progress as programmers. I cannot count the number of times I've had to re-teach devs who cut their teeth on CI on what "Active Record" actually means. Now I and others are going to have to do the same thing with the developers that graduate out of Laravel, with the term "Facade." Is it really that big a deal? Maybe, maybe not. Laravel certainly improves the *productivity* of many programmers, but your continued willful misuse of the term "Facade" hinders their *professional development.* Maybe you don't care about that so much. I do, because I'm going to have to deal with re-training these guys for the next 10-20 years. (The same way I had to get re-trained out of my own misconceptions over the past two decades. ;-) I see a chance here to nip that particular bit of trouble in the bud and I encourage you to help do so.
No. It's not a priority for us right now. We might consider it in the future. Your talk of people "graduating" out of Laravel to bigger and better things (I assume Aura) is also extremely insulting. It reduces my body of work to basically a tool for programming toddlers. I'm not going to engage it with a snarky response but just pointing out why I often have issues with your comments.
I've only used MAMP free, and I haven't used that for a while. I've heard there's a one-click virtual host creation thing on MAMP pro. I can imagine it would be worth the money just for that.
So are you using phing and ant? or does phing use xml too?
This is exactly why I use MAMP pro. So much easier. 
this really reminds me of my java days -- community "gurus" arguing about semantics, architecture, and (over) engineering of things. so nostalgic.
They sorta lucked out on that M 
why would you use this? over say just using iis with php ? is it just because its easy? or are there any advantages ?
Look now you can stop your crying over a word. https://github.com/laravel/framework/pull/3809
In reality though, developers who are busy getting stuff done don't really care about what some pattern is called. It only gets mentioned once, or twice, then never uttered again. They don't waste time discussing correctness of terms because they're busy trying to get shit done. Even during dev discussions about the problem, they don't mention the pattern, they mention the classname. The concept has already been digested and implemented. What it's called doesn't matter. What matters is that it solves the problem correctly and it works.
Because it uses Apache and MySQL, it more closely matches the environment that you're most likely using on the actual live website.
the link above is to a comment posted in 2011, the article itself isn't interesting
&gt;So the Blog class would own a repository object.. No. That would be really bad thing to do. &gt;or it is the repository object that is responsible for Blog object creation Yes. Repository objects have only one responsibility. Bring entities from database into memory and back. &gt;that would act as "factory" of Blog objects Please note that a factory object is used to create new instances of entities. Not to load them from database. &gt;so you'd never call the Blog constructor unless you want to create a brand new blog right Yes. That should be done in repository classes methods or via a factory object that is held by the repository object. &gt;So only the repository would have a db connection object right ? Yes. exactly. The rest of the application should not be (ideally) even be aware that there is a database. 
I opened up my local copy of MAMP Free (MAMP Pro lives on our server, which is where I use it) because it'd been so long since I'd used the Free version, I wasn't sure what you were talking about. Yes, MAMP Pro is worth the money. :)
I'd like to ask that commentors on this thread please keep it civil. Direct personal attacks and vulgar language will be removed. I've already handed out one ban (to a throwaway troll account). Please don't make me hand out more.
&gt; It's not a priority for us right now. We might consider it in the future. (/me nods) &gt; Your talk of people "graduating" out of Laravel to bigger and better things (I assume Aura) is also extremely insulting. When you make an assumption, it makes an ass out of you, and umption. ;-) &gt; It reduces my body of work to basically a tool for programming toddlers. Not at all. One needs a certain level of sophistication to get to Laravel in the first place. Some of the developers who use Laravel are going to grow beyond it, and teaching them the wrong terms in the mean time does them a disservice. People move on. You may find it insulting, but it is true. Laravel is not going to be the final stop for everyone who uses it. Some of them may find they want to dive into Symfony, or move into Python or Erlang, or (one flatters oneself ;-) build stuff with [Aura](http://auraphp.com). And in 2-3 years there is likely to be a "new" new kid on the block, the way Cake and CI used to be, the way Laravel is now. That's just the way of the world. Training developers in Laravel may help them to be productive, but making sure they get good training in the profession along the way helps them be better programmers overall. 
Your model is not your database, and your database is not your model (there are times when they are close, or even exactly the same, but those are coincidences and you should not ever consider them to be the same thing). What you're missing is the layer that handles the difference between the two--the adapter that translates your model into persistent storage, and actualizes your model from persistent storage.
Nice! I thought "Fitcol" would be better ("Facade In The Context Of Laravel" ;-) but whatever floats your boat.
WTF people. Debate the topic to death - that's great! I don't care. But it's beyond the pale to start throwing insults around just because you disagree with something. This is free community-driven open-source software. Don't overlook all the awesome just because you perceive one flaw. Be a human being and remember to show *at least a little* respect.
True, but I kinda designed this for OOP code, so the "function name()" usually denotes a method declaration. It will not convert function calls that aren't prefixed with the '-&gt;' so if your code calls PHP functions you should be fine. Again this is more of a helper tool, then a suit. You'll obviously have to double check everything is fine and do some updates. But it will save you some time doing trivial replacements.
Just remove them in the next major release. Advocate the new injector instead.
One new feature I'd love to see is an easy way to upgrade individual components via the MAMP GUI (e.g., latest version of PHP, updated phpMyAdmin, etc). Upgrading them manually tends to be dicey.
&gt; the adapter that translates your model into persistent storage, and actualizes your model from persistent storage. Could you talk more about this? I'm not sure I get it.
"People move on" is not the same as "graduate from" or "grow beyond". Laravel's *is* very welcoming to newcomers but there's no cap on the skill level it can accommodate and there's no reason to imply that this makes it somehow limiting for experienced devs.
I'll give you some advice I wish I had had: a model is not a single class. A model is whatever number of classes are needed *TO* model a system. Model View Controller has essentially been blindly adopted as a way of following separation of concerns, but then it pigeonholes peoples' thinking that their application can only be made up of models, views, and controllers. Instead, I would structure your domain like this: **1. Entities** Entities are your plain old domain objects. They don't need to inherit or extend any classes that aren't immediately relevant to them. A User is just that: a User. Sure, you can extend some Entity class if you want magic getters/setters. But this plain old domain object knows nothing about any databases, storage, collections etc. It's a bag of very strongly related behaviors and properties. **2. Repositories** Repositories are responsible for managing your existing entities. Those entities MAY be stored in a database, or in memory, or in a cache. This is up to your repository, and often times, the repository will initially retrieve an object or a collection from the database, and then add it to a registry after. That way subsequent calls to the same object in the same request cycle don't hit the database. But the idea behind a repository is that the retrieval / modification of your entities is 100% insulated from how they are in fact persisted. The repositories themselves also don't have explicit knowledge of the database. Do NOT pass a database connection into your repository (more on that in a bit). **3. Factories** Factories are responsible for making new entities that don't yet exist. This includes instantiating the entity, instantiating any of the entity's dependencies (e.g. use factories within factories, or use a dependency injection container as a service locator in factories - one of the few times service location is not really an anti-pattern). **4. Data Mappers** Data Mappers are responsible for taking data from persistence, and mapping it to the plain old object. For example, if you have a user stored in the database with a field called `user_name`, and your plain old domain entity/object's equivalent field is `userName`, you will do that mapping here (both directions). Generally a data mapper also doesn't use SQL or persistence language directly, and instead will depend on a low level DBAL (database abstraction layer, which in turn would use something like a PDOConnection). If you wish, you can use a factory in a data mapper as a means of handling the mapping for you. E.g. $User = $Factory-&gt;make( [ 'userName' =&gt; $result['user_name'] ] ); and persisting: $UserMapper-&gt;save($User); **5. Decorators** Say you have a lot of different ways you want to dress up and present data from your Entities. Maybe you want to concatenate their first and last names, or wrap their first/last name in a link. Rather than doing something like `$User-&gt;getLink();` and cluttering your domain object with presentation logic, you should create a Decorator that does that: class UserDecorator { protected $User; public function __construct(User $User) { $this-&gt;User = $User; } public function getLink() { return '&lt;a href="..."&gt;' . $this-&gt;getName() . '&lt;/a&gt;'; } public function getName() { return $this-&gt;User-&gt;firstName . ' ' . $this-&gt;User-&gt;lastName; } public function __call($method, $args) { return $this-&gt;User-&gt;$method($args); // This allows the decorator to behave exactly like the User... it WRAPS the User and sideloads additional functionality into it. } } **6. Validators** Where do you handle validation? In the User object? The User controller? The Repository? None of these. There are even two basic types of validators: form validators, and entity validators. Generally a form validator will validate ONLY a form, while an entity validator will make sure any properties being assigned to it are kosher. Entity validators may be superfluous, but form validators are not. A validator for a single form might be able to utilize multiple entity validators. But the goal is to keep focus tight and narrow. **7. Collections** Collections are glorified arrays of objects. Repositories may return a single object, or a collection of objects. Data mappers may construct a single object, or a collection of objects. Either way, you'll want to use collection objects to provide simplified sorting, filtering, and locating. Those are the general classes of objects that should represent what you would normally consider "**A** model". Of course, that's just the minimum. The User object might have several dependencies, which should be their own classes. But generally, I would drop the concept of "model" as a noun from your vocabulary. It's easier to think of **modeling** as the thing you do with as many highly focused, single-responsibility classes as needed. 
&gt; "People move on" is not the same as "graduate from" or "grow beyond". /me nods I appreciate the attention to nuance. Please take the comment in the charitable spirit in which it was intended. Laravel (indeed, any framework) is going to be one stop of many in a programming career. Learning the wrong terms at that stop will make the later stops a bit more difficult. It's easy to correct this by using the proper terms.
&gt; but there's no cap on the skill level it can accommodate While that is true, there may be a point when the framework / language has nothing more to teach the programmer. So one can imagine that moving to a different framework/language can tech them something new, or an alternate way to do things. But I am not sure that /u/pmjones meant this, from what I have seen from his posts, he probably didn't.
I am waiting on their next sale. Bought Webstorm when they had a sale and it worked out very well. 
Phing uses XML very similar to ant. 
I just bought a license for 7, anyone know when 8 might be released? 
Me too, I missed the last one.
You're setting the error level, to the current error level? Doesn't make sense.
Sometimes your code just needs to go Inception.
No, it doesn't. this bit was found in a Joomla plugin, and was confused by it.
Yes, but you can mix the two ideas. For example, you can use the tokenizer to isolate the function/method/class/variable names and then use regex to perform matching/replacement on the isolated elements. The key here is that regex doesn't understand context - but if you take that part of the job away from regex it's perfectly suited to the rest. It really bothers me that people try to demonize Regex in every single case without first considering what the good use cases for it are. Newbies see this, think there is never a right time for Regex, then never bother to learn it when they absolutely should.
You would use an *adapter* to handle the bit between your models and the database - in other words, you pass your models to the adapter, the adapter sticks them in the database. This not only separates functionality, but allows a further level of abstraction, so that if you change database software, you just have to switch adapters - you shouldn't have to change your model code whatsoever. Take a look at [Doctrine](http://www.doctrine-project.org/). It's the best DBAL/ORM software for PHP I've used and integrates nicely with a lot of frameworks. ---- A bit more, so let's say you want to write an abstraction layer, you would create a class that can take instances of models and write them to the database and it can take queries and return model objects. You can abstract this a bit further and have an entity manager and adapters. This makes it even easier. The entity manager will take models and prepare them for database entry (handling all the different sorts of relationships that can happen) and fetch the right things, building queries dynamically, when you want to find a persisted model. This means you never actually have to interact directly with the database at all in your code. Your code after you've written it might go something like this: $user = new Entity\User($username, $password); $em = new EntityManager($options); $em-&gt;persist($user); \\ prepares $user for database entry $em-&gt;flush(); \\ actually writes to database $anotherUser = $em-&gt;find("User", 1); \\ Find user with id 1, returned object is user Entity echo $anotherUser-&gt;getId(); \\ 1 Note this is just pseudocode, but Doctrine syntax is similar. Generally, there will only be one entity manager object and one adapter object that will be used for each request.
Since I didn't make a self-post (though I guess I should've): Article: http://habrahabr.ru/company/vkontakte/blog/214877/ Google translation: http://translate.google.com/translate?js=n&amp;sl=auto&amp;tl=en&amp;u=http%3A%2F%2Fhabrahabr.ru%2Fcompany%2Fvkontakte%2Fblog%2F214877%2F No OOP is...interesting.
FINALLY!! Multiple cursors is the biggest thing I miss from ST2/3
I do something in between the two. I return a special lazy evaluated data structure, which: 1. Implements ArrayAccess, Iterator and Countable so that it is almost identical to an array. 2. Contains only the ids, but... 3. ...Accessing any of the items will give back the final object. I do this because: 1. Object are more useful, but... 2. Objects are slow to fetch from the database. With this structure, it does not cost much to return 10000 items, but actually use only some 100 of them. 
So to be clear, what you're worried about is this? App::bind('UserInterface', 'User'); App::bind('RoleInterface, 'User'); App::bind('RoleInterface, 'Group'); It's perfectly fine for User to be bound to two different interfaces. The problem arises in binding two different implementations to one interface. In that situation, I'm pretty sure you can't rely on global bindings for this. You will have to bind the parent object in the IoC, and manually assemble it with the appropriate implementation. App::bind('SomeParentClassThatWantsARoleObject', function($app) { return new SomeParentClassThatWantsARoleObject( $app-&gt;make['User'] ); // or new User, depends on if User has dependencies too... } App::bind('OtherParentClassThatWantsARoleObject', function($app) { return new OtherParentClassThatWantsARoleObject( $app-&gt;make['Group'] ); // or new Group, depends on if Group has dependencies too... } If you're in a situation where you have only ONE class that might be taking in multiple Role interfaced objects, then you will need to inject this via a setter or via new construction at call time. There may be more advanced ways of using the IoC in Laravel to handle this, but I'm not quite familiar enough with it to say for sure. You have me curious though!
FYI, it's made it way to WebStorm too. Although, I would generally assume if PHPStorm has it, WebStorm does too. 
I appreciate your comment, but there's no point sitting down to learn both thoroughly, just to realize that they're basically interchangeable. I know Behat is a BDD tool, but like I said, I'm interested only in the testing part. And especially if there's something significant that Behat offers in that area that Symfony does not. 
I've had good luck with http://adldap.sourceforge.net/
&gt; Model View Controller has essentially been blindly adopted as a way of following separation of concerns, but then it pigeonholes peoples' thinking that their application can only be made up of models, views, and controllers. I get you on this. However, if I recall correctly, Fowler says that the "model" in Model View Controller is a stand-in for "the domain model system" (I do not have POEAA in front of me right now). That model layer can be built in different ways. So the setup you describe, which I strive toward myself, is the "model" portion of Model View Controller. As you state, it's not a single class, but a cohesive system that models the domain.
I saw that, but I'm using Windows as my server. I don't think it would work(?)
I think their usual schedule is at the end of each year. I may be wrong though.
As long as you have the ldap php extension it shouldn't matter.
I have to agree navicat is great and supports more than just MySQL
Get fast computer. No speed problem.
No - they have not. I have been checking pretty regularly. The last sale was in April 2013.
&gt; PhpStorm is still a little slower that Sublime Text Full-fledged IDE $X is always going to be a little bit slower than text editor $Y.
All of them. Really. Sublime is a text editor while PHPStorm is an IDE. It's got integration with so many things. The biggest being xdebug. Version control, Vagratn, Composer, Phing, and just tons of stuff. Personally, I could never go back to a text editor. It feels like programming with lead boots on.
Ummm... a lot. Proper debugging, SCM, profiling, static code analysis, database management, terminal integration and support for a bunch of frameworks and third party tools. Of course, you're not going to use all of that (for instance I use a separate terminal) and you can hack it into ST as well but I've said it before and I'll say it again: ST is designed to be excellent at editing text, PHPStorm is designed to give you a single place to work and automate a lot of your work for you. I generally find that ST is a faster at getting stuff out there but PHPStorm is a lot better at getting it right first time. Finally, PHPStorm has fuzzy search, for [files, classes and symbols](https://www.jetbrains.com/phpstorm/webhelp/navigating-to-class-file-or-symbol-by-name.html) and now that we have proper multiple selection support the speed difference is going to be nominal.
You don't even need to (manually) check the credentials. If the bind succeeds the supplied credentials are correct. &lt;?php $ad_server = "directory.foo.bar"; $ad_basedn = "dc=directory,dc=foo,dc=bar"; $username = "username from login"; $password = "password from login"; $ad = ldap_connect($ad_server); ldap_set_option($ad, LDAP_OPT_PROTOCOL_VERSION, 3); if(@ldap_bind($ad, $username, $password)) { // successful login // you can query AD using this bind to get the users information // or verify what groups they are part of $sr = @ldap_search($ad, "user's dn", "(cn=$username)"); $info = ldap_get_entries($ad, $sr); $email = strtolower($info[0]["mail"][0]); } else { // failed login } ?&gt; Binding with the user's actual username and password should be the ONLY way you verify credentials against active directory. Any queries against active directory after the bind will use whatever permissions that user is setup for. There will be no way for someone to inject a query to get data they don't have access to.
Yea, I use the fuzzy search, it's just not as good as Sublime Text's. I think I'm forever going to be torn between the two. I think I'll just use both. Sublime Text just looks better as well. I'm happier when using it. But PhpStorm does have more functionality, which when you get used to it is hard to go back to anything else.
WAMP is easy as fuck also. The best is still to just run Linux. It's not like it's difficult to set up LAMP. You can literally do it with one line in the terminal.
I'd feel a little sleazy doing something like that. These guys make a good product, and they deserved to get paid.
Thank you for doing this and bringing back balance in the universe. &gt; A typehint is a RESTRICTION, not a REQUEST. Very good summary.
Vim users are a little special.
As I've stated before, at no point do the Laravel docs conflate the term "facade" and "facade pattern". A simple conversation (or indeed a tweet as it turns out) can set the record straight. This is beating a dead horse if ever I saw it. This is completely and utterly a non-issue, and frankly I hope Taylor continues to call them facades if for no other reason than the bile spewed from people who seem to be unable to find any real reason to complain about Laravel is hilarious. There is **no central authority** which reserves names of patterns. There is also **no mention** at all that Laravel uses the facade pattern. The use of the term Facade in the context of the framework is entirely legitimate and justifiable. If the docs said "Facade Pattern" you might have a point. But it doesn't. So you don't.
For precision: https://github.com/laravel/laravel/commit/348ff778edc9216f6195c3bf12f2b52b40802bea Or if you want to go back to 2010: http://ellislab.com/forums/viewthread/176057/#884583
GoF refers to programming patterns. Taylor doesn't refer to those patterns with respect to facades. English. Great language. You can use the same words to describe many different concepts. 
+1 we have been using adldap with codeIgniter in production for years now. Works on linux and windows servers just fine. Just adldap-&gt;user_ingroup('username','groupname') and your golden. Plenty of other commands available for any thing you want to do with AD
ehm no, this wont be very close. use vagrant and this will be close or the same asyour server
I'm afraid some people will abuse this and violate the DRY principle
You should be covered. They do a major version every year, usually in the first half. Last year they released 7.1 within 6 months of 7 which had nice new features like proper Terminal integration 
So does this mean if I buy a license for 7.1.3 now, will I have to pay for a brand new license for 8, or an upgrade fee?
What do you miss? I use it daily and am very happy with it.
I am pretty sure that you get all of the updates for the next year.
Which Joomla plugin? I could probably get in touch with the author to find out.
I have worked on a lot of football-related software. Every coach has various terms for the same plays, and they usually give some sort of logical indication of what situation the play is meant to be used in, e.g. "jumbo" or "goliath" or "heavy" or "power" for short yardage situations. How does that relate here? A lot of programming terminology isn't settled in dictionary terms. Some concepts aren't available in the same form in every language; some languages are designed to be used functionally or utilize prototype inheritance or have no concept of memory management. While it would be nice if we could nail down absolute definitions so everyone could understand exactly what was meant when they read dependency injection, the reality is that language is far more fluid. And that's fine: that's the real world. So, are they facades? Not really. But a programmer isn't going to be irreparably harmed calling them that, just like a football player can go through dozens of playbooks in his career without losing the ability to play the game.
The only reason for this is that functional tests of Symfony require boilerplate code, and the code of functional tests are really hard to understand and maintain. Tests should be easy to work with. They should be easy to write and when test is failing you don't want to spend a lot of time to figure out what went wrong. Here is the functional test of Symfony $crawler = $client-&gt;request('GET', '/demo/hello/Fabien'); $this-&gt;assertGreaterThan( 0, $crawler-&gt;filter('html:contains("Hello Fabien")')-&gt;count() ); I can't provide comparison with Behat, but I can show you the same test in Codeception: $I = new TestGuy($scenario); $I-&gt;amOnPage( '/demo/hello/Fabien'); $I-&gt;see("Hello Fabien"); In pretty similar manner, but in Gherkin language the same can be done using Behat. As you see the second example is much more clean, and readable. And much easier to write. You don't need to work with the ugly syntax of DomCrawler. Codeception and Behat provide you with better high-level APIs. 
As a recent convert from ST to php storm this is great news!
Don't forget about Arrays either!
haven't used phpstorm, but I rely on multiple select just about every day. glad I hadn't switched yet.
Hate to be that guy but the proposed solution is a hack, a bad one. Something ugly you DON'T write an article about, proudly. Either use an extensible serverside template engine, Twig or Smarty for example, or shift templating to the client with Angular or React. These are so much cleaner ways than parsing, traversing and manipulating XML nodes.
Cant agree more, every update has made it more awesome. I am happy to pay for a personal license. 
Don't mind him. He trolling or doesn't understand what DI is. He thinks constructor typehints "affect" the actual injected instances.
This literally just made me giddy like a 12 year old school girl.
Can't wait for the moment Docker runs on Mac hosts.
Please, this occurs in programming everyday as a normal consequence of there being &gt;1 programmers. People talk to each other. I know it's hard to understand, but they really do!
"No central authority" should book a session with Martin Fowler so he can spank it. POEAA and GOF are standard references for pattern names and descriptions.
If you don't mind, could you elaborate on where you're using it? I think it's neat, especially "Select next occurrence" but I can't see myself using it often. I feel like I'm missing the awesome use case that will make me faster.
For those focused on blogging, creating slides for talks to sell themselves, maybe.
I can't think of anything too specific, but anywhere you find yourself using find + replace or entering the same information repeatedly. renaming stuff, adding information on multiple lines, etc
The ability to remap things. I use "jk" to enter normal mode for instance. 
lol, /r/PHP downvotes, ignorance is bliss
Cool. Where do they derive their authority from? I mean, they OWN the word "facade" now do they? Or is it simply what they chose to refer to patterns that they have documented? Really, learn to English. Words get used for many things. And Laravel doesn't even REFERENCE the facade pattern even a little bit. Its not even the same thing and frankly only an idiot would think that it is, and a bigger idiot would think that it is a problem. The word facade predates the pattern. Do construction engineers get their panties in a bunch because the GoF facade pattern isn't the front of a building? No they don't, because it is clear that they are not talking about the same thing. And neither is Laravel when it mentions its facades. for the record, I am aware of Martin Fowler, and have read POEAA and GoF. And again, if Taylor was refering to the FACADE DESIGN PATTERN you would have a point. He doesn't, the explaination of what a facade is in laravel is simple enough it fits in a tweet, any developer worth listening to would work it out themselves in a few minutes, and you still don't have anywhere near a point.
http://hotframeworks.com/languages/php
Well, technically. you can't use the open-source license to develop anything other than open-source content.
Most licenses are valid for ever, and entitle you to any update released within a year of your purchase date. I just hope it's released before december.
Could have done it without introducing an extra word. "Wonderful" or "Lovely".
It'll be fine. It works now! :D
I'd be nice if I didn't have to right click and choose to split the editor view... I do like how in eclipse, you can just drag an editor to wherever you want it. But I still use phpstorm! Great stuff!
Does anybody have problems with PHPStorm being really slow? I tried to use it for a mid-big size project and it took like 6 hours to create indexes and stuff, and each time I opened the thing just sit there like doing nothing, I could not navigate between files without the system coming to almost a halt. I mean, it is nice that it has many features, but if it behaves like a behemot that needs a gaming computer to run then it's not for me.
http://blog.jetbrains.com/phpstorm/files/2014/03/Multiple-Carets-Simple-PHP.gif
The simple example shows how it works but not why. That sequence can be done just as quickly with Find/Replace.
serious question... can I get things from webstorm like 'advanced angularjs support' in phpstorm?
Especially if you make money using it. 
I really like beanstalkd overall, and it's ability to schedule a job for later is an absolutely killer feature. That said, I still veer towards Gearmand because of it's ability to run foreground jobs which I find intensely useful.
Question: How is this different than https://github.com/phpenv/phpenv or https://github.com/CHH/phpenv? Is it specifically targeting PECL/PEAR?
It's an interesting idea if you think of it from the perspective of: frontend is the hot thing, it's growing, and more and more there are "developers" who understand programming through the lense of CSS selectors. Offering a backend templating system that speaks the same language helps front end guys look at template files that actually read like HTML templates and do not require learning new syntax.
&gt;Throw away tests that haven't failed in a year Don't see the point there. The rest of the article is generally saying not to overdo tests, do test for areas that are important. Another point raised by this article is that you wont be able to test a vast majority of test cases. &gt;Unit tests are unlikely to test more than one trillionth of the functionality of any given method in a reasonable testing cycle. Suppose you have implemented code to support 10 use cases for a function. So when you are adding code to support code for the 11th use case, there is a chance that it will break one or more of the previously supported use cases. If you don't have automated tests, then you will have to test all the previous testcases previously implemented, EACH TIME YOU ADD CODE TO SUPPORT A NEW USE CASE. So the total number of tests you have to do when you are implementing code for 5 use cases will be 1 + 2 + 3 + 4 + 5 = 15, where as with automated testing you only have to write a test for the new functionality. This is the best case. If you are adding the code for 6th use case after 2 or 3 days, you wont even remember the previously implemented use cases to manually test those. In that way unit tests also can act as a kind of documentation. Not sure why there is a &gt;=0 instead if &gt;0 ? change it to &gt;0 and run tests. One of them will probably break. Look into that one and you will see the use case that made &gt;=0 required. With experience you will improve your ability to write tests. Which result in less but more effective tests. As with anything else, keep looking for ways to test more effectively. I think that is what this article is try to say at the end. 
Yes. Everything in WebStorm is in PHPStorm.
&gt; The repositories themselves also don't have explicit knowledge of the database. Do NOT pass a database connection into your repository (more on that in a bit). This is not correct. Repositories may or may not use further abstraction layers. And any such abstraction layer used inside the repository is part of the repository itself. see this section from [this msdn article](http://msdn.microsoft.com/en-us/library/ff649690.aspx) &gt;The repository mediates between the data source layer and the business layers of the application. It queries the data source for the data, maps the data from the data source to a business entity, and persists changes in the business entity to the data source. So it is repositories job to query the database. It can use a dbal or a direct database connection. Not having explicit knowledge of database is not a requirement for repositories. 
How large of a project are we talking? I've used it on two projects with 6k+ files in them and "Invalidate Cache + Restart" only takes about two minutes.
If you implement the same algorithm in both, then C will be faster. FastRoute is faster because it removes some functionalities (like optional pattern, multiple dispatching conditions, and you can't define http host, http method, secure conditions together), which is to achieve grouped pattern matching approach. Most PHP router supports combined conditions (which FastRoute doesn't support), so the limitation is to looping the routes and find the correct one, for example, symfony router, aura router or Pux.
Im surprised no one has mentioned installing PHP via homebrew? You get the newest PHP and its easy as 'brew update' to update it. Need sqlite? Or mongodb? Easy, 'brew install sqlite' and your all set. Need PHP extensions? 'brew install php55-mcrypt' boom, its done! You can pick your database according to what you need, and your not tied to MAMP mysql. For local development I find the PHP builtin server to be very good, never had any issues with it. Vagrant is also fine, but I have had alot of problems with it in the past. Specially with CMS software.
There's no real way to tell. It depends a lot what you mean. Symfony is used by a huge amount of people and projects, as is Code Igniter. Laravel probably has the most vocal and active "community", though. 
Tried in two projects from work: +GB and ~3GB. Right now I tested a 27M project (laravel based) and it took a while to load as well. Maybe is a tool not suited for the size of the projects at work.
...and ensures you really have no idea what it is you're actually doing.
Cool story, bro. How about you do what you want, and I'll do what I want? Personally, I find the process of managing and configuring apache and vhosts a pain in the ass. I don't know what I'm doing. I'm not a server admin. I don't want to be a server admin. I want an environment up easily, working and configured. &gt; If you paid for MAMP at any point, you're a sucker. Easily paid for itself. Best money I ever spent. Couldn't be happier with my purchase. Over the last few months it's probably saved me a few hours. Conservatively maybe three hours on "why isn't this working" issues. That's $15 an hour. I wouldn't work for that. I'm sure as hell not going to configure stuff for that rate.
Don't need to. I need a working environment, that's it.
Really shaping up to be another solid release in the 5.X series. Forget the haters, really loving PHP development over the last 12-18 months.
Well it's an extremely limited subset of PHP, and is pretty useless for anyone expect vk.com. They've never shown any intent for running "real" PHP.
?
Your license is valid for all updates within a year. It's been the same for me, bought the last 6.x release and then 2 months later was able to go onto 7. 
 Remember, though, that automated crap is still crap. And those of you who have a coroporate Lean program might note that the foundations of the Toyota Production System, which were the foundations of Scrum, were very much against the automation of intellectual tasks Testing is not an "intelectual" task; creating tests is. I think this guy is fighting a strawman.
ehm no, most websites introduce bugs because mamp behaves differently than the environment, as long as your dev pc isnt your prod server you should use a vm
Yup, it was for me. Not really one click, though. Simple interface. "what's it called? Where's it live? Done."
More closely. Which may or may not be "close enough". 
这个真好。
another implementation of php to cpp translator :-)
Try excluding directories that you don't want/need to index, if that's an option? For example, app/cache and app/logs if it's a Symfony project. It's under **File &gt; Settings &gt; Project Settings &gt; Directories**.
The thing is, that Behat has Gherkin but after that you still have to write the PHP code, which looks somewhat similar to Symfony's test. For instance, after writing "I should see a h1" you have to go and get the contents of the page and assert that the tag is actually there. 
Do you have an example of this code organistion in an application you can share?
Adding \r\n on those three lines at the beginning of this gif shows the why. 
Laravel * :-) *
That's ... colourful.
&gt;really loving PHP development over the last 12-18 months Yeah now if only we could get rid of the years and years that came before that.
I'm not a huge Vim user, but I find it a lot quicker to type `:14,51s/\$username/$user-&gt;name/g` than using the Replace dialog.
Which one are you? You seem to be doing pretty well conversing with other programmers on reddit.
This is so disappointing!
&gt; There is no central authority which reserves names of patterns You should assign my response to the correct topic and not shift it to an unrelated topic which I already stated was a waste of time. You referred to patterns, dude.
Try it for a week. It's one of those things that once you get it into your workflow you'll be wondering how you ever lived without it.
&gt; We will eventually stop making releases of PHPUnit available via PEAR altogether. Welp. I think we can officially say PEAR is in it's death throes now.
I only recently learned you can use composer to get whatever version of PHPUnit you require, on a per project basis. No more waiting on your distro to deem it stable and such. Aside from that, support for the @before, @after, @beforeClass and @afterClass annotations will definitely come in handy for me. And time to read up on those new test doubles! 
I was simply pointing out that your argument that they are wrongly named is completely off base, given they are not named for the Facade design pattern anywhere in the Laravel documentation and the Framework's creator himself has stated that they are not implementations of the Facade design pattern, dude. Given that there is no special establishment which reserves the use of words for specific uses, even within a specific context the argument that it is in anyway an incorrect usage is patently false.
Is this a troll article? Why can't "POPO"s coexist with a framework?
Have you considered that maybe this problems fall in a templating module for your CMS?
He's disappointed because his boss is now going to make him write unit tests.
Your database connection seems to be down "Error establishing a database connection"
My understanding is that for a small dataset on tables that are properly indexed, the join should be faster than a similar subquery. 
This is disappointing because it is by no mean a new major release. There are almost no new features, and definitely no new major features. There is also just a tiny BC break. I don't see how it is a new major release. PHPUnit 3.8 would have been a good version number… I mean it's PHPUnit. The project is so old, and it has been sort of dead for so long, it's still not using namespaces, there are still no phpdoc on most methods, creating mocks is so clumsy (to prove my point just see how many other test and mock frameworks there are), the architecture is still so locked down (try using a container with PHPUnit?), contributing to the code is still painful (no PSR-0, 1, 2 or 4 compliance)…
There's a few other interesting outputs from phpMD: * update - 61 lines of code, NPath: 721, Cyclomatic Complexity: 16 * getTxInput - 79 LoC, NPath: 25950, CC: 21 * getAddrWithOptions - 65 LoC, NPath: 640, CC: 14 * sendAmount - 42 LoC, NPath: 320, CC: 10 * _Route_getStats - 153 LoC, CC: 29 * checkNodes - 104 LoC, NPath: 960, CC: 13 * runAddrTriggers - 111 LoC, NPath: 22657, CC: 24 * broadcastTransactions - 53 LoC, NPath: 500, CC: 14 * _Route_handleTx - 77 LoC, NPath: 1024, CC: 17 Also to note that insertMisingAvailableOutputs has a wonderful typo.
It's a useless line of code, not invalid, just useless.
They did a lot of great job in last 1-1,5 years as it was said above. PHP developers are just afraid of breaking backward compatibility and I think that we have to wait for PHP6 until they i.e. clean userland API.
Semantic versioning dictates bumping the first number in the release number when there is a BC break. 
never seen it take that long - sometimes 5+ minutes on a new project. I've got ssd which helps, but that doesn't explain 6 hours. Netbeans used to get hung up all the time on 'indexing' - never stopped (I let it go once for 30+ hours and it didn't stop - bugs inside I'm sure, but didn't help me). That's why I switched to IntelliJ/Jetbrains stuff.
There is some disagreement about whether to bump the major or the minor version, but definitely one of them should be. Anyway, though I understand the disappointment I agree with the decision. Bumping the major version can also be a statement that the model is changing, which appears to be the case here -- especially with the promise to abandon PEAR -- even if the code doesn't change much.
Tangent: this is good news for PHPUnit and I don't mind using it, but out of curiosity, are there viable "modern" alternatives to it? The only one I could find is Atoum, but [the GitHub readme](https://github.com/atoum/atoum) didn't inspire confidence -- specifically I object to step 3 -- and [the official documentation site](http://docs.atoum.org/) even less so.
I havent had issues with slowness, just it freezing completely and needing to kill the process. Its odd, it only happens on my VM's not my physical computers.
Or you could use a distribution whose packages aren't permanently several years out of date.
Lots of folks are stuck on RHEL for corporate reasons.
I'd rather a slow march then all at once. If userland gets wiped then large code bases will never make it to 6.
I just checked and my current project is ~205mb and indexes in two minutes. I don't have any real advice though, other than maybe contacting support?
If client-side rendering is of concern you can use templates that work both server-side and client-side like http://mustache.github.io/ Also, it seems that implementing such a solution would require testing your templates file. With regular templates you have a variable `$username` and a `&lt;?php echo $username?&gt;` instruction for the parser which is placed exactly where you want that text. With this solution you have the variable, the place where it needs to be placed and the command for the parser. One can easily imagine writting the following line; $template-&gt;setValue ('//html:titles', $titles); where both the variable and placement are written incorrectly.
on about 60 projects my company worked on we had like 40 IIS, comapnies like labaratories or gov are mostly on microsoft servers atleast in switzerland
Yes, so much this. We've seen time and time again that major API overhauls stifle adoption (in this and other languages).
Your company does not reflect the typical standard for PHP. LAMP is by far the most common platform.
There are few scenarios discussed. One is to create whole bunch of aliases or provide methods for scalar types ($string-&gt;length()) so switch to new major version should be rather painless. I really believe that PHP devs are not stupid and they don't want to ruin trust of programmers due to large BC break.
I'd say go for it. :) I don't see any reason why not, as you love to learn and enjoy screencasts. It seems you certainly have the passion for this product and that's always a good thing.
Fixed link: http://phptownhall.com/blog/2014/03/06/episode-20-a-nice-friendly-chat-about-sculpin-guzzle-and-psr-7/
Hey, let me explain something about this article. I do not say you need use POPO to develop software, instead of it, I say you need to know POPO exist. Again, did you read something like: Stop using framework!! I recommend you read the article again, please, and be sure about what you talk about. thanks. and please, use framework to enterprise software development but know the behind the scene details. And why you think its a exclusive "PHP developer thought"?
This thread contains some good answers http://stackoverflow.com/questions/2577174/join-vs-sub-query Generally the best way is to fill your tables with some data and try both queries and see which one works/scales better. Use EXPLAIN to see if your indexes are actually being used. Also note that the mysql query execution plan will vary according to the size of your data. So for if you try explaining a query with a small data set, you may be confused to find that none of your indexes are being used. This may happen because mysql decides that a full table scan is faster than going through indexes and using them to get the actual rows. https://dev.mysql.com/doc/refman/5.0/en/how-to-avoid-table-scan.html EDIT: added citation 
Faster, yes, but only relatively. On a small dataset, the difference will be virtually nonexistent.
Hello, I do no say that. I just point to the fact some developers dont know how to do things without a framework and it is a problem. I really need use a framework, I dont say nothing against it. I just say you need to know POPO exist and you need to understand what frameworks do. thats the main problem here, some developers are not capable thinking a problem without a framework to handle with it. 
Can you ELI5 what multiple cursors is such a big deal? I assume it's a feature that I'll someday wonder how I ever did without it, but currently it just looks novelty, so I'm sure I'm overlooking something.
They released a major version just for this tiny BC break instead of either: - deprecating the feature - doing much more BC breaks for the occasion There are so many things that would profit from breaking BC, starting by namespaces which I'm sure they already had a lot of pull request of people volunteering to do it. Heck I'd volunteer to do it! If feels just like if Symfony released Symfony 3 just because they renamed a parameter of a method somewhere in the internal code. It doesn't feel justified.
Atoum doesn't follow semver, they don't even provide tags so you can't install it with composer unless you set your minimum stability to dev. And they do it on purpose, regardless most of its users requested tags (the discussions on github about this are pretty ridiculous). I suggest to stay away from it.
Valid, though with small datasets that's pretty much a given with any improvements. This might be a premature optimisation. Myself, I prefer joins. I just understand them better. 
Thank you!!
this one is pretty decent http://www.amazon.com/Objects-Patterns-Practice-Matt-Zandstra/dp/1430260319/ref=sr_1_8?ie=UTF8&amp;qid=1394211010&amp;sr=8-8&amp;keywords=php+object+oriented 
&gt; LAMP is by far the most common platform. for non big companies yes, but if you test the big dogs against "built with" you will see IIS is often represented. also it were the companies clients, we recommend apache.
Their bar-graph comparing kphp, hhvm and php seems really silly when viewed while knowing how limited a subset of the language they've implemented. I could compile PHP to powerpc-assembly, support only the minimum amount to make a fibonacci sequence calculator I wrote run really fast, then boast about my amazing benchmarks. HHVM is great specifically because they're at or near 100% parity, based on approved test suites, with so many of the popular frameworks. Any benchmarks need to be taken with a grain of salt, and you're just looking to see if your new runtime is ~10% shorter or so, or a fraction of the original.
Downloaded, ran, but it still says 3.7.32 even though --version says 4.0.2 What's required to "upgrade" to 4.0? [root@gizmo track]# phpunit PHPUnit 3.7.32 by Sebastian Bergmann. Configuration read from /var/www/track/phpunit.xml //... [root@gizmo track]# phpunit --version PHPUnit 4.0.2 by Sebastian Bergmann. 
To me, PHP books tend to be one of two things: out of date or speculative. I've quit bothering with books on programming languages in the past five years or so. I can get more relevant, more up-to-date, and more interactive answers/tutorials/APIs/etc. from the Internet.
O'Reilly books have always looked nice on the shelf. 
Interesting. I'm wondering why the Currency class has that MASSIVE static array of all of the currency values and properties though. Wouldn't it make more sense to include that information in each specific country's currency object in /currencies? That way when you want to use this thing, you load only the currency you want and keep the memory footprint down?
Muchas gracias! But please let's not derail into the question of whether "facade" is an appropriate name. Zero interest in resuming that conversation. In terms of the right amount of dependencies for a Controller - I still wonder, does this actually matter? If one purpose of the SRP is to promote decoupling, is there a point to creating a Laravel controller that's decoupled from the Laravel framework?
Thanks for the info, I'll try it this weekend.
Doesn't surprise me in the LEAST that this was found in a Joomla plugin. Here's another example of the quality of Joomla's dev community: http://www.bluestonejobs.nl/ That uses the Tabs GK4 module for Joomla. Look at the source code and tell me if you think 17 layers of nested containers is a necessity to accomplish what is being done on that page... Also, Joomla itself isn't exactly a user-friendly CMS, and it throws warnings all over the place if you use Xdebug, since it relies heavily on the @ suppression operator which effectively gets ignored by Xdebug. Joomla's entire ecosystem ( at least Joomla 2.5) is a bit of a pain to work with. I don't know why. I feel it's a far more "grown up" CMS than Wordpress is, yet everything I've used in it is just either poorly written, not intuitive, or offers a terrible UX.
That does look interesting, though a quick scan at the table of contents / introduction / appendix indicates to me that it's not covering up to PHP 5.5 or even 5.4., maybe even 5.3? OP asked for "modern" so this is just a warning that that book, while it looks like it covers lots of great stuff, doesn't talk about things like traits and closures which are getting pretty important nowadays. 
Start by reducing the coupling to Laravel itself. With Symfony, I would [declare my controllers as services](http://symfony.com/doc/current/cookbook/controller/service.html). That way I can inject the dependencies and unit test them as simple php objects. In the Laravel context, I'm not sure if that's doable, though.
I feel like controllers are somewhat of an exception to this thought process. Because controllers are (usually) designed to interact with the web state, they're going to need to use different types of resources such as views, redirects, etc. I suppose you could alleviate this in a way by utilizing base controllers. A default base controller could include the view/redirect dependencies that may be common to many controllers. Specific controllers then could include repositories, creators/forms, etc. where needed. I personally continue to use those facades without worrying about dependency injection. I also have extremely small controllers that contain no logic other than "if success do this, if fail do that".
In my opinion, no. In my applications, the controllers are kept separate from my domain namespace/logic, because the controllers are specific to Laravel.
&gt; A default base controller could include the view/redirect dependencies that may be common to many controllers Those are technically still dependencies though. A dependency through extension is still a dependency. You won't be able to use ControllerA without the existence of ControllerB, and in turn, without the presence of View, Redirect, Input etc. That said, you are correct that controllers are a bit of exception to this rule. They're NOT really meant to be reusable, portable libraries. They are integration points, and exist at the application level of your project, not the domain level. Thus heavy-ish dependencies on other application-level logic (Inputs, views, responses) is OK in my book. Heavy dependency on domain-level logic though? That's not good. For example, imagine if you have a delete method in a controller that deletes a root domain object, which in turn has a lot of dependencies. It would be bad if that controller needed the repositories for 10 different domain entities just to delete the entire dependency graph. Instead, just a single manager class that does that for you should be passed in, and THAT class should be responsible for deleting the entire dependency graph. Its logic should ideally allow for some kind of abstract location rather than explicitly relying on a bunch of repositories, but at least then the controller doesn't have to worry about anything more than using just the one class needed to accomplish the task the controller method intended to do.
This is pretty much in line with what I've been thinking, too. &gt;Instead, just a single manager class that does that for you should be passed in, and THAT class should be responsible for deleting the entire dependency graph. This is something I'm really going to work on in this next refactor step. Maybe try to avoid passing in, say, more than one repository to a controller *unless* those repositories are there for completely separate purposes. 
Subscribe to www.phpweekly.com.
No, it doesn't mean your controllers are structured in a shit way. View, Redirect, and Input are application-level dependencies, and thus should NOT leak down into your domain level. So keeping those dependencies isolated to the controller (also an application-level object) is fine. What would be a problem is if your controllers relied on too many domain-level dependencies. Take for example an AccountController which might have the following actions: - login - register - logout - requestPassword - resetPassword Each of those functions should rely on some domain-level class such as LoginHandler, RegistrationHandler, LogoutHandler etc. So immediately you can see that your AccountController is filling up with a large number of domain-level dependencies, and this is what becomes a problem. And again, it would be a problem if your domain-level classes were directly accessing Input, Redirect, and View. They have no need to know about those. ONLY your controllers should know about them and use them. Now, not all controller methods will always use all three three dependencies on a given request. So if you wanted to be super strict about it, then that's an indication you have a controller that's trying to do too much and it could be broken up so that its getting only the dependencies it needs. However, if you take that approach, you sacrifice a lot of the stuff that Laravel does to make your life easier (e.g. using a ResourceController with create, show, edit, update, destroy, and index - not all of which always use View, Redirect, and Input). So this a judgement call on your part. I personally consider View, Redirect, and Input "freebies" that are just there, and I don't worry too much about over-thinking my controller responsibilities. If I have a feature or problem that Laravel has a solution for, I don't fight it, I just use it, even if it's not strictly "right". At the end of the day, if your controllers are readable, maintainable (and by that I mean, don't need to change when your domain logic changes), that's what counts. Testability can be achieved by passing Input, Redirect, and View in as dependencies via the IoC - but the fact that those represent 3 additional dependencies should not concern you.
it covers 5.4 and 5.5 (traits, finally, etc..), the only thing I missed it's the use of composer
Oh cool. That's what I get for only reading the preview.
Just did, Thanks!
No, not in that case because then you're just passing the buck. If you call a method in AccountHandler to log the user in, and AccountHandler also has RegistrationHandler, LogoutHandler, in addition to LoginHandler, it's the same problem: one class that needs more dependencies than it actually uses on any given request cycle. So in this particular case, I would honestly split up AccountController into multiple, one/two-function controllers. LoginController gets the LoginHandler, RegisterController gets the RegistrationHandler. PasswordController can have two methods: forgot, and reset, but still use just a single LostPasswordHandler. Example: LoginController { protected $LoginHandler; public function __construct(LoginHandlerInterface $LoginHandler) { $this-&gt;LoginHandler = $LoginHandler // LoginHandler meanwhile is presumably given the Auth class it needs } public function show() { try { $this-&gt;LoginHandler-&gt;isLoggedIn(); // presumably throws an exception return View::make('login'); } catch (LoginException $e) { return Redirect::to('/account')-&gt;with('message', $e-&gt;getMessage()) // e.g. "You are already logged in" } } public function login() { try { $identifier = Input::get('identifier'); $password = Input::get('password'); $this-&gt;LoginHandler-&gt;login($identifier, $password); // throws an exception if something goes wrong return Redirect::to('/account')-&gt;with('message', 'Welcome back!'); } catch (LoginException $e) { return Redirect::to('/show') -&gt;with('message', $e-&gt;getMessage()) // e.g. "Username/Password is invalid" -&gt;withInput(); } } } 
what was the reason for rejecting the first proposal?
Ah ha! Thank you, this has been very helpful.
&gt; use SebastianBergmann Let's hope the maintainer never changes, that could get awkward. The same issue that Oracle had and has with all the sun-namespaces in Java.
No problem :)
One thing that I do that helps me is I ask myself what a class is going to be doing for **THIS REQUEST CYCLE**. It's really easy to dream up a class that does a bunch of seemingly related functions, but it doesn't always execute those functions (or use all of its dependencies) on any one given request cycle. Different request cycles? Sure, it might use different dependencies. But that is what gets you into trouble. My AccountController was an example of that. Does grouping login, register, logout, and password reset functionality into a single controller called Account make sense? Yes. But does each of those functions get executed on a given request? No. Only one does for any given request. So if you start thinking about your class structure in terms of "what do I need for **this request**", you'll find that you naturally tend to start writing leaner, more focused classes with fewer dependencies. That's not to say that this thinking should be dogmatic. Dogma is not a healthy thing for a programmer to follow. Just use that as a potential indicator that your class is doing too much, and then evaluate it against alternative solutions. If alternative solutions seem worse to you, then don't use them. If they seem better, then by all means refactor.
Uhmm.. that also works in PhpStorm? I can drag any tab "away" and it becomes its own window.
I wouldn't know. I'm not even sure this was *recently* declined. All I know is that the RFC entry is marked as *Declined*, with the latest update on 2014-02-17.
but can you split it? no, no you can't. yeah you can drag it to be it's own window, but you still have to right click the tab to split the view. Look at this and then keep telling me you can do it http://youtrack.jetbrains.com/issue/IDEA-73585
People get all bent out of shape about annotations and I seriously don't get it. The common argument is that comments shouldn't contain functionality. While I agree with that statement, it is completely irrelevant; annotations aren't functionality - they are configurations. No one ever complains about putting configurations in Yaml or stuffing a config/ directory full of .ini files, but the second someone proposes inline configuration (that helps keep relevant configuration with the class it configures) people flip the fuck out! Why!? To your enumerated points, in 1 you are angry that some external program you use strips out your comments, then in 2 you are mad that you have the option of installing an external program to help you better work with annotations. What meta programming tools you use is your business. If they don't work how you want them to, don't use them. I'm not sure how this is anything but tangentially related to annotations, though. As for 3, some people, myself included, think it's nice having the relevant configuration for a controller, model, etc in the same file, like I said earlier, inline configuration can be helpful. If you don't like, don't do it. Any Symfony or Doctrine annotation could just as easily be a line in a config file somewhere in your project. In fact, I believe Doctrine even comes with a CLI tool that converts annotations into config files. And 4, what is this even a complaint about, that a person working on a project will have to understand how that project's tools in order to work in the project? That's the nature of programming, learning how different tools work and combining them to create something awesome.
None of your points make sense, apart from the 4th one. 1) If you want to use hiphop, or a bytecode cache that strips comments, don't use annotations, use a different config backend. 2) Has nothing to do with annotations, your IDE won't complete any other kind of configuration either, except XML if there is in XSD for it. 3) Your routes are in relation with your controllers, and their actions, it's not tight coupling to allow them to exist in the same place. If you keep your routing data in separate files, you still have to look through all of them to find out which action your route is paired with, so this one is not an annotation specific problem either. 4) Yeah, people have to be aware that some annotations are docblocks, and some are configuration metadata. &gt;This is exactly why people don't take PHP seriously. Newsflash: There are other languages than PHP supporting annotations, and it works well. &gt; Deal with it.
Thumbnails of this dude always look like Dwight Schrutte sans glasses.
Can you easily test them? If so, they don't suck. If not, they suck. Nothing else matters really. You can easily test them thanks to the hard work of the Symfony team in giving us BrowserKit and HttpKernel, which are utilized by Laravel. The example unit test that ships with Laravel should help you get started!
It's probably a major version bump because of HHVM and PEAR changes.
So ... don't use them. I don't understand why you're acting like there's a gun to your head on this score.
I agree with this. I adamantly stay away from docblock annotations.
&gt; If you want to use hiphop, or a bytecode cache that strips comments, don't use annotations, use a different config backend. Because no project ever relies on third-party bundles that might make use of this awful concept that is comment annotations, right? &gt;Newsflash: There are other languages than PHP supporting annotations, and it works well. I have nothing against annotations. COMMENT ANNOTATIONS is what I'm angry at. &gt; Yeah, people have to be aware that some annotations are docblocks, and some are configuration metadata. People could code having in mind readability and intuitiveness. It doesn't hurt. &gt; Your routes are in relation with your controllers, and their actions, it's not tight coupling to allow them to exist in the same place. Actually, probably all my classes are in relation with all my other classes. This is an app, things depend on each other. It doesn't mean I should leave them tightly coupled. This hurts manutenability. If one component breaks, you'll have to update everything that directly refers to it, when you shouldn't. That's what encapsulation is for. That is what **design patterns** are for. I'll give you this: this point has nothing to do with my original rant. It has more to do with the way people are abusing annotations than with comment annotations per se.
__debugInfo(). So hot right now.
Quick example from this morning: I had around 40 email contacts that I needed to put into a csv, which came all one one line in the following format: Name &lt;email&gt; Name &lt;email&gt; Now I could have done **CTRL+h, [space]&lt;, TAB, ",", CTRL+ALT+Enter, CTRL+h, &gt;[space], TAB,\r\n,CTRL+ALT+ENTER** (15 'key sequences') But with multi-cursor it was highlight " &lt;", **ALT+F3** (to select all occurances)**, ",", CTRL+Right\*3** (to skip over the email address) **,SHIFT+Right\*2** (to highlight "&gt; ") **,ENTER** (8 'key sequences') I hope the above makes sense! Once you get used to multi-cursor being available, you'll probably find yourself using it more often...
Think about it this way: this is becoming a trend, we should stop it now. Every major software relies on third-party bundles and such bundles should not present a technical impairment because of some shit practice that could easily be replaced by proper configuration placement. PHP Devs should also consider using PROPER annotation syntax instead of creating native functions to retrieve annotations from docblocks. This is not a matter of "just stay away from this if you want to". More and more people are using it, more docs are presenting annotation-only examples and this is madness. This is bad practice and this should stop.
Ok, I agree. 
Phpspec and Behat definitely look nice, however I found the documentation lacking for both. It seems their creator is satisfied with their current state, and there isn't enough community behind them to compensate. There are a lot of let's get started blog posts, but nothing that tackles something a little more complex. 
Because Rasmus still treats PHP as a templating language for C. I mean, we got namespaces only in 5.3 and a finally for try-catch in 5.5. There are a lot of great features other object oriented languages have, but until the BDFL doesn't consider PHP one, there's nothing to do. The community is trying desperately to build great things with it, but there's so much they can do.
&gt; let's not derail Fair enough. :-) &gt; is there a point to creating a Laravel controller that's decoupled from the Laravel framework? This is the part where I hawk [Aura v2](http://auraphp.com/packages/v2) just a tiny bit. In the new work, we don't have a special controller object at all. The dispatcher can dispatch to any object at all. This means your controllers are truly *your* controllers; you can set what dependencies you like. I am not familiar with the inner workings of Laravel, but it seems to me that if its router/dispatcher system does not care what it dispatches to (and I suspect that is the case) then maybe start by creating your own controller object and injecting whatever dependencies into it you feel are necessary. That will get you decoupled from at least part of the system.
Seems like your approach is to determine suck-ness on a controller by controller (i.e., function by function) basis, rather than a controller class by controller class basis. Which leads me to infer you're also saying not to worry too much about how many dependencies a controller class has?
If one must invoke the entire framework (or significant portions of it) to test a particular class, then *probably* there's a coupling issue there. One should not have to browse through the application to test a controller. I'll admit that I fail at this more often than not. ;-)
You assume that is the only way you can test them, and you know what you said about assuming. Just new it up and test it if you want. It's just a class.
I'm saying what is the end goal? A solid, well-tested application? You can easily achieve that while still using the Input, Request, and View facades in your controller.
No, not making an assumption, just stating a point. When I hear "use BrowserKit" I think of browsing through the application, and that raises a flag for me. But whatever man, as long as the class can be tested independently, it's cool.
I mean, BrowserKit is used for functional tests, so .... not sure how you would accomplish that w/o invoking the application via an actual HTTP request. Here's the default Laravel test example Taylor referenced above: /** * A basic functional test example. * * @return void */ public function testBasicExample() { $crawler = $this-&gt;client-&gt;request('GET', '/'); $this-&gt;assertTrue($this-&gt;client-&gt;getResponse()-&gt;isOk()); }
If you have ideas for making use of PHP 5.4's new features in PHPUnit's API that would make writing tests easier/nicer, I would pitch them to the team and see what happens.
Comment annotations are awful. Mark-up, such as `@author` in comments are for comment parsers for auto-doc. Not for code. But `&lt;Entity("users")&gt;` looks horrific. Just do `%Entity("users")` or something.
Yeah, that's the kind of thing we should strive to avoid. Controllers can be difficult that way. However, with some discipline, one should be able to get to the point where one can "just" inject its dependencies, probably including a fake request object, and avoid the rest of the application setup. If there are many or complex dependencies, this gets harder, and becomes a sign that maybe the controller is doing too much.
No problem! Feel free to ping me in IRC sometime if you want to chat about it more.
I didn't say client-side rendering was a concern. What I said was having a method to produce backend templates that would feel natural to front end developers might have merit. 
BrowserKit is primarily used to write functional tests that even interact with the DOM by filling out forms. By no means a requirement for testing any Laravel stuff. Just kind of a cool way to make requests to your application.
OK, but that's not a problem with annotations, that's a problem with how people are implementing annotations which is where a lot of the confusion is coming from I think. The easiest way for you to get people to use a better method, is for you to build a better method.
Joining the Nomad PHP list is helpful. They include news in their emails, not just meetup invites.
Yep, agreed with all of this. Doc comment annotations are a meta language bolted onto PHP, and comments should never affect your code. Doctrine and Symfony both piss me off because of this. And also because as an alternative, they encourage you to use YAML and configure everything up front. I don't want to learn YAML either (I know, it's YAML... what is there to learn? Still, it's the principle of the thing. Would you configure your php application with .ini files or json files? Then why would you do it with yml files?) I hate this as much as annotations... http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/yaml-mapping.html#example 
No difference, really. If you rewrite with PHP, there’s a tiny performance hit since Apache has to pass the request to PHP for processing. But it’s negligible.
Massive 500 line YAML configuration files aren't much better either. No IDE hinting or support, alien key language (what do half of these things mean? http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/yaml-mapping.html#example) makes it hard to learn and read etc... Configs are of course infinitely better than annotations, but configuring Doctrine and Symfony through YAML is basically learning a new language unto itself. The fundamental problem is Doctrine and Symfony are too configuration dependent I think. Thus you have two fairly shitty options: huge config files with a large key language, or configuration via annotation. While I don't really believe in Cake's "convention over configuration" as that is extremely restrictive, I disagree even more with Symfony / Doctrine's "CONFIGURE EVERYTHING" approach.
This has always really bothered me too. You mention hiphop. HHVM supports annotations (and a lot of other goodness) through hack which is their flavour of PHP. You enable it for a script by starting &lt;?hh instead of &lt;?php. It looks like this: &lt;?hh &lt;&lt; MyAnnotation('Unicorn', 42) &gt;&gt; function bar() { } $rc = new ReflectionFunction('bar'); print_r($rc-&gt;getAttributes()); This generates: Array ( [MyAnnotation] =&gt; Array [0] =&gt; Unicorn, [1] =&gt; 42 ) ) I recently talked at GTAPHP's Meetup in Toronto about hack. Slides mention annotations (slides 26 and 27): http://www.slideshare.net/zymsys/gtaphp-hack There's a lot of great stuff in hhvm. I hope that it either forces Zend to add these features, or that it becomes popular enough to become the dominant PHP runtime.
Ahh okay. So, trying to bring this full circle - if I'm getting this right, the use of facades *per se* shouldn't have a negative impact in that regard, since they are so easily mocked.
That's pretty cool. I'm just not sure about the notation; it reminds me of [left shift](http://www.php.net/manual/en/language.operators.bitwise.php) and [heredoc syntax](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc), neither of which are remotely similar. At least using `\` as the namespace separator makes sense given its common use as a filesystem directory separator.
In the HTTP / controller layer, yes, that's my position. Some disagree. But I prefer to keep the conversation very "grounded". Can I easily test this controller to make sure it is working properly? Yes? Cool. You won't have any problem doing that at all, even using a few facades in your controllers.
&gt;a finally for try-catch in 5.5 It's important to note that `finally` isn't really that important if your language supports [RAII](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization), as PHP and C++ (which doesn't have `finally`) do.
Sorry, what's the difference between an annotation and a comment annotation?
I think the original rfc was declined simply as a way of voiding it. https://wiki.php.net/rfc/annotations A new rfc was created with a slightly differing spec, and is still 'under discussion' https://wiki.php.net/rfc/annotations-in-docblock
I was _this_ close to coming to that meetup.
Agree wholeheartedly. Good points, and I really hope the second RFC doesn't pass either. They shouldn't let existing comment annotations used by popular projects dictate the definite implementation of annotations in the php language. 
On the bright side, Symfony does not require that you use annotations. In my client projects where I know the final environment I just go with what I am familiar with (I tend to use comments for Doctrine only, the rest is yml). For projects where I don't know the final destination, XML always over YML and Annotations. The worst part is, aren't they there to make things easier? Yet their use in an IDE is unsupported at best. To be fair, you can easily just not use them, they are not required or preferred in the Symfony environment. Software intended for distribution is recommended to use the XML configuration method instead. They are simply there to make it easier to get your feet wet in Symfony more quickly as far as I am concerned.
I agree. At least considering that a lot of us stuck with PHP because projects like Symfony, Doctrine etc. which are the exact opposite of what Rasmus is advocating: as little reliance on frameworks as possible. That only works if you keep your apps super simple IMO. 
I haven't encountered this prior to that Wikipedia article, honestly it sounds very hacky.
PHPUnit supports mocking chained calls: $mock -&gt;expects($this-&gt;once()) -&gt;method('someMethod') -&gt;will($this-&gt;returnSelf()); $mock -&gt;expects($this-&gt;once()) -&gt;method('anotherMethod') -&gt;will($this-&gt;returnSelf()); etc.. Mockery looks very nice though I just haven't encountered a case where phpunit-mock-objects didn't cover all my use cases. 
But a lot of people obviously like it and use it. Why not add features developers actually want to have? 
phpspec is great and can completely replace PHPUnit for unit testing your code. It doesn't support code coverage though. However because of the way it drives your development if you follow the process you should have no untested code.
Then I guess the whole body of good C++ practice is a hack. How do you figure RAII is a hack but `finally` isn't? 
Right, but mockery has a dedicated syntax which is much simpler: $mock-&gt;shouldReceive('call1-&gt;call2-&gt;call3');
&gt; Then I guess the whole body of good C++ practice is a hack. I would definitely agree with that. 
What are the ownership permissions of the directory? I believe that if it's owned by root, not even 777 will allow it to be writeable. I could be wrong about that though.
Hmm, ok. Although I'm not convinced he used it in this case
I'm not good at explaning things to 5 year olds, but I'll have a try. Most practical example is editing multiple spots in your HTML when you want to change repeated occurrences of &lt;span class="xxx"&gt; to &lt;div class="yyy"&gt;. Another example is editing keys used on an associative array. $customer['name'] gets changed to $customer['fullname'] and you have like 10 places where that happens. Normally it'd take a copy, *10 careful selections*, and 10 pastes to refactor this. With multiple cursors you just copy, multi-select and paste once. Of course for huge refactorings PhpStorm has specific helpers. But semi-small refactorings that normally require mousing and selecting, benefit greatly from multiple cursors. Anyway, give it a try to get a feeling.
Lol okay. 
That's patently untrue. PHP doesn't have a BDFL.
I wish more authors would give credit where credit's due. This library is most likely a fork of https://github.com/mathiasverraes/money/ (which I already forked myself, also, because IMO it needs optimization). I think I'm especially bothered because the license and copyright is EVERYWHERE in this source code. Do you really need to duplicate the info in both the license and class blocks?
As far as I'm concerned, I would like proper annotations. I doubt that anyone actually wants to use the comment annotation crap that we have now, but there's no other option than to abuse the comments, really. 
I would not be joining on a text field if that is what's going on here. Personally, I find that if a subquery is very quick, like querying for data from 10 rows to have data to filter by, it is much better. Even with some larger datasets. At the end of the day though, if you have indexes correct, a subquery and a join are probably fairly similar. Always do an EXPLAIN statement to verify which is touching less rows. Also, don't forget about fetch time. If a join is returning a bunch of extra data, that will slow it down quite a bit too. I try to stay away from joins as much as possible, but sometimes it is the right way to go.
From the manual: &gt; If the open fails, an error of level E_WARNING is generated. Figure out what the warning is, and go from there. You might need to use error_reporting() to make it show up. Also, check the perms of all parent directories, all the way up to / or C:\ or whatever is appropriate.
Rewriting URLs its easier to debug with PHP than with Apache, also if you latter need to move another webserver, like nginx, migrating RewriteRules to nginx syntax could be complex.
Don't make us guess. Let us see the actual code. 
&gt; you're basically just writing a site like people who put a huge pile of jQuery selectors in their code to load their content do. BAM. Couldn't have said it better.
I'm trying to reduce my PHP usage as much as possible. Ruby, Node and Python are all great, and VPS services are cheaper than ever. It's just not a very attractive option for new projects anymore. Why put up with Rasmus's idiosyncratic mess when there are plenty of more mature options?
I have contributed to both projects. I don't think it is a fork. It is a standard implementation of a money value object as described by Martin fowler
Honestly? I can't find a job other than PHP where I live. Well, if I don't count the ones that require 5+ years of Java EE/.NET. 
Does it say anywhere what role does Rasmus actually have? I just assumed he was a BDFL because he's the most visible member of PHP core, and people keep referring to him as the BDFL, like everywhere. 
Definitely dependencies still, it would just limit the dependencies that need to be injected on a per-controller basis.
You are wrong (no worries, *nix permissions can be tricky at first). 777 is also written as a+ugo or rwx+ugo, giving all rights to the user who owns the directory, group members, and everybody else. If root is the user who owns the directory, it applies just like any other user. A demonstration: sudo mkdir demorights ; cd demorights ; ls -al ; touch nope ; sudo chmod 777 . ; touch yep ; ls -al
But what is modern php?
&gt; While I don't really believe in Cake's "convention over configuration" as that is extremely restrictive, I disagree even more with Symfony / Doctrine's "CONFIGURE EVERYTHING" approach. Not sure what the other option would be, other than "build everything adhoc by hand or string together any libraries you can that end with .php". If you don't want to use a framework, don't, but 'convention over configuration' has proven to be a pretty good balance between out-of-the-box productivity and configurability when required.
Aside from the litany of political issues the annotations engine as proposed would have slowed down all method and function calls due to the structure of the internals engine and the inability to condense things at compile time (thanks to auto loading). At least this is how it was reported to me by Elizabeth Smith, I may have a few details crossed but it's the general gist. 
There are people in PHP internals who have a lot of pull. Rasmus is one of those people. He can definitely make certain sweeping decisions for the project, but I've never heard of him having the ability to veto anything. Every major decision goes through an [RFC process](https://wiki.php.net/rfc) and a [vote](https://wiki.php.net/rfc/voting). Nothing says Rasmus has any special role in this.
Yeah it's not a complete solution. Having a plugin modify the view is a very tricky business that's why most of the time you'll just see hooks in templates that allow for something to be output in certain pre-defined places. Is modifying the classes assigned to an element something you really anticipate there's a need for? Or would plugins really be powerful enough just by being able to add content to certain places on the page?
As Taylor notes, no, functional tests are good and necessary. But if can only test a class through a functional test, then there's a problem.
I wouldn't say that making static proxy calls to the container have a negative impact any more than any other static call. But they do count as dependencies, the same as any other dependency (whether injected, instantiated inline, or called statically). 
But why the Welp? Edit: Why don't we have a `composer -g` like `npm`? Downloading some random `.phar` is so archaic.
The problem with hooks is that I feel the template needs to be cluttered with tonnes of hooks. For example: &lt;div class="post-title {hook:'post-title-class'}"&gt;{hook: 'before-post-title' }{{ $postTitle }}{hook: 'after-post-title'}&lt;/div&gt;
* Improvement of **@covers** and addition of **@uses** for better code coverage analysis * Support for the **@before**, **@after**, **@beforeClass** and **@afterClass** annotations Can we have native annotations now, please? I think there are enough use cases for them. Be nice if the idea wasn't constantly shot down.
POST http://phpepl.cloudcontrolled.com/src/eval/index.php 502 (Bad Gateway) phpepl.js?ver=1.5:9667 Uncaught TypeError: Cannot call method 'trim' of undefined phpepl.js?ver=1.5:12811 Code was: function a() { a(); } a(); 
Terminal, it'll put hair on your chest!
PHP: The Right Way by Phil Sturgeon https://leanpub.com/phptherightway
I am currently using http://www.ampps.com/ and I like it so far. It's free and works for windows and mac.
be careful with your words. the PHP mafia doesn't like seeing "facade" and "laravel" in the same sentence.
&gt; I am not familiar with the inner workings of Laravel, but it seems to me that if its router/dispatcher system does not care what it dispatches to It doesn't. You decide what class it dispatches to, as well as the method that gets called. And that class gets resolved out of the IoC so you are free to do dependency injection with little to no wiring/configuration. If you don't wish to let it resolve out of the IoC for you, you can simple register a closure and manually instantiate whatever class and dependency graph you want in the closure. It's up to you. There's only one slightly annoying restriction though, which is the dispatcher calls some filter methods that need to be present, or you can extend BaseController if you want.
Never said it's a best of breed solution, I just pointed out an angle from which it could be argued to have merit.
It sounds more sane when you put it that way, but have you actually used Behat? Does it work well in practice? Do the stakeholders actually write legible, parsable sentences, or do you constantly have to correct them? &gt; It forces them to actually put down what they want instead of it just being some nebulous things that changes all the time That part sounds good.
Here's an example of annotation comments as "code" https://github.com/aws/aws-sdk-php/blob/master/src/Aws/Ec2/Ec2Client.php#L27 comments being used to define functions and their arguments... Because it's not like there's another more obvious way to do that.
php does require 1 ) Annotations 2 ) Getter/Setter 3 ) Type Hints (Scalar + Obj) + proper return types. Finally, *Fuck you* to those who voted "no" on arrayof vote. :-) 
You've got a little ways to go. The stripe API might be simple, but the complexity lies within the application you're trying to implement it in. Codecademy is great, but it should not be your only resource. I recommend looking at open source, PHP projects on github and see how applications are structured. If you're trying to use this as a learning tool, please don't. It is not a great place to start. Try this again after you've done sessions, understand the fundamentals of security, and have written a working web application of some sort.
https://getcomposer.org/doc/03-cli.md#global
[This is a little easier to understand.](https://github.com/stripe/stripe-php) Not to imply that it's impossible, but I believe it's highly unlikely for a PHP noob to be able to successfully setup a payment processor with the Stripe API. Even if you were successful, there's no telling how insecure it might be, which is why I'd never put my credit card information into it.
You can separate calling your domain logic (eg repositories) into a service layer. This way (web) controllers are the only thing tied to the framework. These controllers only have the resposibility of transforming the request into a response using a service. If you have your domain leaking into the controllers then the controllers are violating the SRP (i.e. they have more than 1 reason to *change*). Splitting out a service layer then means you can create CLI controllers (eg Artisan commands in the case of Laravel) and reduce code duplication. We had an application structured like this which was based on Silex, then we decided to change it to use Laravel. This only required porting the controllers and routes. If we hadn't kept the service layer separate to begin with then we realistically wouldn't have been able to switch to Laravel.
Oh...well..then...this isn't an option for phpunit is it? It should be.
http://phpdeveloper.org/ http://websec.io/
It is. When you global require the PHPUnit script is put into `$COMPOSER_HOME/vendor/bin` if you add that to your `$PATH` you can execute `phpunit` from anywhere.
Given your current level of PHP knowledge, under absolutely no circumstances should you be taking credit card details on your site. You are 100% definitely going to fuck this up. Find a professional coder who can build you a site, or use Shopify or any of the hundreds of fully hosted sales solutions out there. 
I'm a big fan of annotations, even the whole @Route symfony2 controller thing (putting routing information in the controller makes it soo much easier to maintain). But I whole hardheartedly agree that docblocks are no place for annotations.
Books on programming languages are a waste of time. Books on language agnostic programming concepts are a better investment.
If they are okay with violating DRY, any IDE wouldn't stop them anyway. They'd just Find + Replace.
&gt; have you actually used Behat? Does it work well in practice? I dabbled, but nothing serious. I've used a few other frameworks in other languages (behave in Python, easyb for Java/Groovy), and they work well enough. It takes a bit of getting used to. I have played with behat, but it doesn't seem to scale up to large projects well. Every "step" goes in a single `FeatureContext` class, for instance. That might work for testing a small app, but not going to fly for a bigger one.
4) Annotations start with a Capital, don't they ? Other docblocks don't, do they ?
no its not... sitepoint is pretty bad
1. I think these compilers will produce code that reads unmodified php files. It doesn't make sense to modify something that won't be executed. 1. If php had native annotations, wouldn't you have to download several plugins either, in your logic ? IMHO, you only need one plugin to check the syntax, because it is the same (for doctrine and symfony at least), e.g. `@Classname({"hash_key": "hash_value"}, ["something"], other_json_thingy)` 1. This one makes the more sense. But also, I think having `@Route` on top of your action is a better because it avoids copy / paste mistakes I've seen in real life where people wonder why two routes lead to the same controller. 1. Look closely. Some start with a capital, some don't. So yeah, they are distinguisable actually. Where I agree with you is that we would be better off with real annotations. Because it is something useful, and deserves native access methods. &gt; If you are to downvote me, please be kind and tell me why I'm wrong. I didn't downvote you, [downvoting is for one something is off-topic](http://www.reddit.com/wiki/reddiquette)
Is this still happening? 10 points to the first side to be the bigger men/women, drop it, and move on. It just doesn't matter.
What is the point of annotations that affect how the code runs? Why can't it just be done in code as it is now?
I agree completely, comment annotations are absolutely an abuse of the comment block in PHP. I too love annotations so this makes me very sad. I don't see annotations becoming a native feature in PHP for some time unfortunately. I think one of the big hurdles is just parsing the annotations as it is. I think the guys working on Doctrine, Symfony, Zend have done an absolutely amazing job where they can using the tools they have to get the job done. The JVM and CLR can scan and parse annotations caching the references within the vm and not have to worry about the overhead. I imagine hhvm could fix a lot of these issues by writing the inferred methods right into the bytecode of something. Speaking of, another thing to consider is that PHP does not have a very strong AOP model to work with which is relied upon heavily by languages with a lot of DI/IoC tools, e.g., Java with CDI or Spring's IoC container - both heavily utilizing proxying, even going full-tilt with AspectJ. PHP has nothing like this right now. Maybe hhvm will bring some of these tools to the PHP eco-system as well. The stuff I have seen so far has been insanely promising (futures, async, scalar hinting, etc..) I'm trying to not gush. 
It usually relates to 3rd party stuff adding functionality that isn't natively provided; sticking this functionality into comments means it would be 'safely' ignored by IDEs/compilers/parsers that don't know how to handle it.
I'm going to the local library today. I'll look for one. I'm returning to PHP after so many years(and did not do much back then anyways) , blazed thru codecademy's course in 5 hours to refresh my syntax and I felt at home! I tried liking Python and Ruby as much as I could but PHP is good for me. I want to start with small projects by examples and small CMS extensions. I'll look into it :) 
Wow. Never knew this was paid software. I'm sure its useful for some, but for me its always going to be compile from source nginx/php under Ubuntu in my dev environment (and production to for that matter). 
The examples are usually in a particular language, but language agnostic books are more about the concepts. For instance, I read a design patterns book with Java examples, but it made me a better programmer overall in all languages I write. If, as a programmer, you have to see examples in your exact language, you need to fix that. Syntax is just syntax, and it's easy. Overarching concepts are important.
What do you mean by "3rd party"? Do you have a real life example? Sorry if I'm being dumb but I don't see what annotations would actually do.
There are some in the OP. Doctrine is 3rd party, and with doctrine you're usong php's comments to define object relational mapping which is kinda important information.
thank you 
the way I see it, you don't have to know and to learn how a car works, just to be able to operate the windshield wiper. And time is pressuring. But i will learn more in the future, thank you 
Besides doctrine, you could add annotations to a class properties/methods, which would instruct an XML or JSON serialization. You could use it for autowiring for Dependency Injection containers. You could mark methods inside a db class as Transactional and it would automatically wrap the method with the right transaction code. These are kind of common use cases for annotations that's been used with langauges with annotations.
sadly, the do not offer what i want, i want to charge the card belayed, not immediately. 
I have to ask, are the details that you're saving different? That is, does your commercial_properties table hold different types of data to residential_properties? It's just the way you have described it, you could be repeating data which is a no,no when it comes to db design.
Then don't. Think about what plugin developers would want to do. There's already a post-title class, and I assume there's an element further up the tree with a module-specific class. Why would the plugin author need to add even more classes in this place? He already has enough to uniquely identify the element in question. You can't make it infinitely extensible, so instead be smart about the places you want to be extensible. Take a good look at the Symfony 2 bundle structure an bundle overrides. Or take a look at how Wordpress and Drupal handle this.
&gt; Your critique of "What does @ManyToMany do vs @param" is no different than trying to figure out the what the difference of different annotations, function calls, or anything else in any language. I disagree with this. When you see doSomething(x, y), you know this is a function. When you see @param, you know this is a doccomment. When you see @something, you have no idea what it is. It was supposed to be a comment, but it might as well be an annotation class. I'm currently working on a project with annotations like @Firewall(rules={...}, filters={...}). This could be firewall configuration for the action, but this could also be doccomment block for the firewall documentation - no way to tell. And in this case, it's even worse: the annotation is acual configuration, but if you remove it, *you alter the app state without breaking it*. You'd just remove the filters and rules, making that action available to everyone. And **there is no way to tell** you changed something without refreshing the page and testing with different specs. It's not a problem of knowing the environment. The problem is that **the environment is hard to learn because things are no longer intuitive**. Comments may or may not offer logic, no way to tell but search for classes with that name.
&gt; I think these compilers will produce code that reads unmodified php files. It doesn't make sense to modify something that won't be executed. Nope, they don't. And that's exactly my point. The comments no longer exists in the bytecode, the app should still work. &gt; If php had native annotations, wouldn't you have to download several plugins either, in your logic ? IMHO, you only need one plugin to check the syntax, because it is the same (for doctrine and symfony at least), e.g. @Classname({"hash_key": "hash_value"}, ["something"], other_json_thingy) Nope. Annotations would be classes. Visual Studio, for example, hints/autocompletes annotations with no issues for C#. Even custom annotations. &gt; Look closely. Some start with a capital, some don't. So yeah, they are distinguisable actually. Well, if you understand it closely, you'll see I can easily create custom annotations and they can start with lowercase. Just because Doctrine and Symfony's start with a capital letter, doesn't mean everyone else's do.
I don't think linking to that post is ever useful for anyone. It's a really really long whine that essentially says "I'm going to shit all over the FIG because of the way they chose to conduct one standard. Furthermore, instead of looking at how people do things and standardizing that, I believe they should just pick shit at random and stamp it done." No. That would be moronic. If that post was written by you then you need to really have a think about some things.
Some do, some don't. Many don't, like PHPDoc.
That is definitely not how the vote works. He usually votes no, but he is only one vote out of many. 
I don't think that's at all what that post is saying. Actually, since that post *is* written by me, I'm pretty, pretty sure it's not. [:-/](http://i.imgur.com/zsswNR3.gif) edit: Seems like you also commented there, will leave a reply with my reasoning below it.
I get the feeling you're just looking for a reason to argue or rant. You stopped quoting what I said after the first sentence when the rest of what I said in that point already touches on everything you just said. You also ignored anything else I posted that could be a conversation topic about annotations in general so I've got nothing further to say now. \*shrug\* Oh well, nothing to see here folks.
Great, so I misunderstood. I left you a comment: &gt; Sorry to come in late here but I just saw this linked up on Reddit and it made me laugh. Just to clarify your points here: &gt; 1. The FIG should not look at what projects are currently doing when creating standards. They should invent what is "best" and just go with that. &gt; 2. Only projects that pass a certain criteria in your mind (of recency and continued popularity) get to keep their vote. Once something is old it is no longer relevant. &gt; 3. You think that votes are a "fake democracy". You would instead prefer a democratic approach where we ignoring the votes of projects you do not like. &gt; I'm lost for words at this point, save this: That is not how things work. Am I misunderstanding your article?
try opening url by appending this: ?XDEBUG_SESSION_START=netbeans-xdebug Probably the problem is that netbeans does not open the browser. 
Mmmh, conversations in two places :-) Already replied to your post - maybe we can discuss it further there? Makes more sense to have it directly connected with the post.
That line you quoted doesn't make any sense to me. Tests that haven't failed in over a year are costing me nothing in terms of maintenance. That doesn't necessarily mean that they are good tests, but they are cheap. And I can afford cheap.
It does not make any sense to me either. In fact, it sounds pretty stupid to me. That is why I told I don't see the point there.
So where would annotations be stored if not in comments?
Certainly. :)
We have a few deployments of EB. It works pretty well as long as you don't need anything outside of what's provided in the AMIs. It's really nice not having to worry about scaling, setup, and configuration. If you aren't doing anything too crazy then I'd recommend using it.
Then find someone to build you a site. You are NOT equipped to take on this coding task. 
Why can't any of that be done in normal code? Seems pretty straightforward to me.
you'd have to have the meta information somewhere else. so it's separated from the class you're configuring for, or put in an unintuitive place. annotations is merely a standardization of where meta data for constructs are represented. It makes things quite a bit cleaner and easier to maintain.
You could use multiple xmls for your test suites: phpunit --configuration config1.xml phpunit --configuration config2.xml Or, although I have not tried it yet, define your configuration per test suite in your xml config. Read more [here](http://phpunit.de/manual/3.7/en/organizing-tests.html).
I have created a package that resolves this issue. https://github.com/robclancy/class-name-fix-utility
Dear god why. 
Looks like static service location wrappers.
And this is why names matter. These are not "facades." These are static proxies to service locator instances.
You could put the slow ones into a group, and exclude that group when you don't want to wait for them?
You can also specify a custom AMI, BTW...
I agree, they're not facades. However, I don't feel they're quite proxies either. I suppose I could be wrong, but when I think of the proxy pattern, I imagine the proxy fully satisfing the interface of whatever it is proxying, which these do not.
After all of this I can't tell anymore if people are serious or just trolling about the issue.
I only use packages that follow the pear coding standards, where can I get that?
Pear coding standard is not currently on our roadmap. We will not be adding it at this stage. Our focus is on scaling for performance critical applications.
I have to say that i dislike \ as a namespace seperator. It is usually used to escape the next character which can lead to unexpected results when used in a string. Windows uses it for the Filesystem, sure, but there exists the same problem. 
Woaw the Laravel framework is going to last and be used for 10-20 years?
This is a pretty common problem across any discussion board when it's anonymous. Hackernews is pretty toxic, and Reddit isn't far off. That said it doesn't help when "high profile" people in this subreddit act like complete dicks as well.
you need to go back to code school if you can't figure it out 
&gt;can lead to unexpected results when used in a string Not really. Classes and namespace names in just about every coding style start with a capital letter, whereas all escape sequences are lowercase. There's no case where writing out a FQCN can have "unexpected results". The only time I've encountered issues with it is when I need to append a variable to a string which specifies a namespace followed by an additional slash, to dynamically specify a class name. In that case I have to escape the trailing backslash in the string. However, basic syntax highlighting prevents that from being "unexpected". By the by, as of PHP 5.5, you should be using the ::class keyword to get class names as strings. It has many benefits, not least of which is that it will generate immediate and clear errors if you have a typo, which literal strings won't.
But I was top of the class at code school. I once wrote a code so good my teacher couldn't read it. I got an A*. 
Wait... are you a [Woot! dev?](http://www.reddit.com/r/sysadmin/comments/1zw1n8/whoops_wootcom/) ^just ^kidding ^;) 
not sure what you mean by that, the meta data is there to tell something else about the data. For that to be right there in the code doesn't make much sense. and even if you could do that would violate single responsibility principal
A proxy may intentionally withhold part of an interface
But if the metadata is changing how the program runs, it should be in code, and the class in question is the thing that would be controlling it.
Well it is in code. It's just making decisions based on meta data. Why would the class in question actually serialize itself? Or save it self in a database? Or get it's own dependencies? That's kind of the stuff good modern programming design tries to get away from. Doing that violates a lot of the SOLID principals.
I thought that was only with cloud formation and if you use EB you could only use a predefined AMI?
just checked out the code. this thing checks out and is PSR compatible all the way to PSR-132. it's got tdd, bdd, std, vd, bbq, omg, and all the amazing methodologies like agile, fragile, mobile, responsive, waterfall, lake, motorboat, etc. so much win for everyone. thanks!
let's all just call this a wrapper and be done with it. this not-a-facade-because-fowler-said-so bullcrap is taking so much time and effort and twisting too many panties to be helpful.
and with 120% code coverage. Shit even test the code that ain't there yet. And no fucking dependencies. Aura guys are going to be pissed!
Well even if they're not proxies, it's important to at least call them something OTHER than facades.
You know, I agree in principle with them. But it's a minor quibble, being blown massively out of proportion. 
Thanks, that Silex case study in particular is hugely helpful.
I'm using CodeRunner too and loving it. You can specify the PHP binary path in the settings. I've set the MAMP one it works perfectly fine.
You are right. The original results I posted ran the code only once. Upon running it 100 times, HHVM did perform better (took 4 seconds less over a 1:30 minute run). However, the code using Zephir performed much worse (took about 2 minutes more, 3:30 in all, where the simple PHP code took 1:30)
You can split your tests up in different ways. Using `@group` annotation and then the `--group ..` or `--exlude-group ..` flags, using subdirectories and then running `phpunit tests/selenium` for example, or splitting them into test suites. Make sure that the bootstrap file in phpunit.xml only contains the bare minimum of setup, and then delegate more of the setup into different abstract TestCase classes.
 'Namespace\Classname' == 'Namespace\\Classname' "Namespace\Classname" != "Namespace\\Classname" You can try it if you want. Imo that is inconsistent and the double quote way is the right one. I know i never need 2 \ in a class name but that doesn't change the fact that it is a weird literal, at least in php. ;) 
We're going to need a much better explanation than that to suggest a solution. By table I'm assuming SQL, either post an ER diagram of the two tables or the SQL create table statement. However, it does sound like you're in need of a drop down box or data list in your form, populated using PHP from an SQL SELECT of your 'insured' table.
I use the --testsuite option
Yes. I was trying to find out how to add a drop down or combo box or whatever so the user can choose the the correct match to go into the foreign key. Obviously not number but masked by company name to make it easier for them Edit: im sorry if this doesnt make any sense. Ive been working on it for hours and its really really late. :/
 &lt;label for="company_select"&gt;Company: &lt;/label&gt; &lt;select name="company_select" id="company_select" required&gt; &lt;?php foreach ($company_list as $company) { echo("&lt;option value=\"" . $company['id'] . "\""); if ($company['id'] == "1") { echo("selected=\"selected\""); } echo("&gt;" . $company['name'] . "&lt;/option&gt;"); } ?&gt; &lt;/select&gt; That's how I print out a select box in a form in one of my projects. It loops over **company_list** and sets the value of the option sent via the forms to **id** and the value shown to the user in the select box to **name**. You may need to edit these based on what your MySQL column names are called and you will need to use either PDO or the [MySQLi fetch assoc](http://www.php.net/manual/en/mysqli-result.fetch-assoc.php) method to populate **company_list**.
Ok. Thank you. Now would this go in my view or controller?
No, not behind. Had to learn php for this project because thats what the company wanted? Yes.
Repetition is the way to go to learn something. I started doing exactly what OP does right now, by asking questions and just blindly following examples etc. After a while you realise why things are done in a certain why and then it clicks. 
Honestly, I think you should prepare for the possibility that you're in over your head.
It's mostly used to keep the code clean and readable.
not blog and not only php - http://coderwall.com/
Full of unnecessary white-space, and you should update your arrays to the new 5.4 version. $string = array("one", "two", "three"); $string = ["one", "two", "three"]; Gotta keep up with convention.
Please, please, *please* don't use the 5.4 syntax for arrays if you want to develop code to share with others. It doesn't add anything other than preventing those of us still running 5.3 from using your code.
Here's my workflow at the moment. Feedback welcome. 1. Check out code on to local machine. 2. Write/edit code. 3. Write some tests using Codeception. 4. Commit to master. 5. Codeception tests are then run on a VM using Codeship. 6. If tests run successfully, Codeship tells DeployHQ to deploy Live. 
Yes, I've tried using [this](https://blogs.oracle.com/netbeansphp/entry/howto_check_xdebug_installation) script from Oracle, [this](https://netbeans.org/kb/docs/php/debugging.html) one from NetBeans, and the [XDebug Wizard](http://xdebug.org/wizard.php). Nothing has been successful. I considered that it was software I installed. (I installed Visual Studio because I got a job offer.) So I uninstalled all that. Someone suggested that I get back to a restore point, but the uninstalle created so many restore points that the point I need is past the menu. [AARRGGG!] I used System Internals' TCPView to watch the port but it seems that NetBeans is the only thing that opens it. I do not get a Windows Firewall warning when it tries to start the debugger, so the firewall is not blocking the post. And the thing that gets me is that the NetBeans debugger was working quite well before all this, I just can't seem to get it connected back together.
Congrats for your first OS project! I suggest you take a look at PSR-0/4 autoloading, so your project can be included in other projects/frameworks. Codewise you could clean up the code a little and maybe add some basic tests. Because its very simple im not convinced about having a interface just for the sake of it, but sure its good if theres another implementation. Also ALWAYS document your code with docblocks, it will help you and the developer using your code. You could take a look at PHP curl libs or use a ready made one for http related stuff, as an alternative to the function you have atm. (File get contents) Guzzle being one good option. Last, you should camelCase your method names, as its the most used/best practice in todays PHP. Good luck with the project and congrats again for your first OS project. 
5.4 is stable for production; stop living in the past. What you're saying right now is tantamount to: "Please don't release this movie on Bluray! The only thing it does is ensure I can't watch it on my DVD player!"
auto increment
Using traits would be a valid reason for making a project 5.4+ only. Syntatic sugar is most definitely not.
Oh, I agree, they're not entirely proxies either. The closest description I can think of is "static proxy call to a service locator instance". But I think they are definitely more proxy-like than facade-like. I suggested the word "Surrogate" elsewhere, if only to get away from the word "facade."
Totally agreed.
Well put. Far too many people would love to see the end to PHP as a language. The only way that's going to happen is if we stop progressing with it as a language.
This. Maintained by people with a ton of php experience!
Maybe this qualifies as satire?
Gotcha. Thanks, by the way!
[You seem confused](http://codepad.viper-7.com/V6FAy7). Both of those sets of strings are equal. There's nothing inconsistent about that, whatsoever.
I would be interested as long as it has composer support (meaning post and pre commands upon deployment etc) and a good degree of flexibility if you need it, otherwise it stays out of your way. I am using beanstalk currently and it does have a moderate amount of flexibility which is nearly always required - although it does not offer NGINX + FPM which is a huge downside. I know you can set it up yourself but I would rather have it as a standard supported option. The CDN option is nice and I like the sound of it, usually these platforms support PHP later rather than first, this would be a refreshing change.
Ok, i thought double quote in php were acting like in any other language but it seems both do it... I won't say wrong but in there own style.
The use of DIRECTORY_SEPARATOR is for portability. If you are just slapping up a quick script no-one will ever see except you, it is easier to put / than DIRECTORY_SEPARATOR . If you show anyone the script, I would consider using DIRECTORY_SEPARATOR because it is more portable and looks cooler! (Sarcasm?) As you mentionned you can indeed redefine some constants. You can also re-use constants in constant definitions: define('APP_PATH'. '/var/www/appPath'); define('LIB_PATH', APP_PATH . DIRECTORY_SEPARATOR . 'lib'); Anyways, you get the picture, though the example is bad. Use the constant if your code needs to run on platforms that use / and platforms that use \. I believe basically Windows works with both \ and /, Linux uses the front slash /. 
It's pretty normal and easily understandable that single quoted strings in PHP only have \\\\ and \' as escape sequences, whereas double-quoted strings have a thoroughly-documented set of escape sequences that exist in just about any language. All escape sequences that use alpha characters are lowercase, so there are not any issues with using the namespace operator in strings so long as you start class names with a capital letter.
My shared hosting provider does not have PHP 5.4. 
That's a logistical problem that you don't force onto a developer. It's of absolutely no consequence to me that you can't use something that I've created because you've chosen either an outdated version of PHP or a host that does.
There are servers with PHP 5.4 but they are expensive, and I don't have that much money. It is like making Skype for Windows 8.1 and claiming that you have not choose 8.1 and you have choose to stay on 7 thus I don't mind. You cannot use Skype anymore if stay on Windows 7. Like excluding the rest 90% of the users. Of course, it is up to you.
don't forget, 82% is still using 5.3 or 5.2. Really bad, I know, but if you want the 82% to be able to use your project, you better skip this feature for now. Using namespaces (5.3 and up) can be done. Over 50% is using 5.3, and another 14% is using 5.4 or higher. Once the adoption of 5.4 gets higher, use 5.4 or higher functionality. The problem with an old language like PHP is you need to keep progressing, but also make sure most of the people can use your stuff. [Stats right here](http://w3techs.com/technologies/details/pl-php/5/all)
Except PHP5.3 is EOL. So your argument is more like "I want to keep using Windows XP even though Microsoft is going to stop supporting it." 5.3 is done. It's not supported. It's time to upgrade. 
I would be interested!
I am using Behat and I have to say it's great. The plain text is actually really good, even for me (developer). If forces to write very clear and small tests by abstracting a lot the technical details. You should give it a go before judging it so fast.
How long have you been in the industry? Generally you work to the server specs chosen by your client, not you telling the client what server specs you'll work with.
Elastic Beanstalk is great if... A) You / the client can afford it and.. B) You have an operations team / resource There's a lot more to the cost than just the Amazon monthly bill though, the setup for Elastic Beanstalk is super simple and seems like a great idea until you realize all the security groups and everything it creates have auto-generated unique ids... then you realize you have no idea what security groups even are, meaning the learning curve and labor involved is really quite steep. It seems all simple on the surface but it truly is IaaS (Infrastructure as a Service) not PaaS (Platform as a Service) so you still need fairly extensive dev-ops capabilities. It's verrrry easy to make a mess with EC2 and AWS in general if you're not careful or don't have infrastructure / ops background. To summarize: It's reliable, ridiculously scalable, learning curve is steep and still has a requirement for fairly deep operations knowledge.
Horku/AppFog/PagodaBox don't have "exuberant" fees for the things you mentioned, near as I can tell. I personally just want PagodaBox+, just a couple of more features and better reliability. I'd like postgres and maybe couch db options, as well as the option to use a single container for multiple apps under a single bill (easier to separate billing for separate clients / projects). The CDN option is interesting but I'm guessing that 99% of clients on your platform wouldn't actually operate at a scale that warrants any additional cost for that particular feature. If anything, a base function to just serve assets from a separate domain would be a good start, doesn't need CDN-geo features. I like FortRabbit too but the hooks integration via BoxFile in PagodaBox is much easier to operate. I'm most definitely interested in more PaaS providers, AWS already owns the IaaS market so no sense competing there, really. It does a good job of that. I still think PHP PaaS sector is anybody's game though so giver!
What you're looking for (I think) is auto-loading. Google around for the topic, basically you define a function that PHP executes anytime you reference a class that has not been explicitly "included". The function will do whatever you ask it to (e.g. - look for a file matching the class name in a given directory and include it). References: http://ca3.php.net/spl_autoload_register http://www.php-fig.org/psr/psr-4/ https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md
No, I'd expect 82% of these PHP developers to understand it's dangerous and wrong to use EOL products. Anyone who doesn't understand that might as well shut down their Windows XP machine and go outside to play with the other kids. Additionally, as someone who actually does hire developers in the industry, I'd never hire anyone who didn't understand this very simple concept... So take that however you want, I guess.
While I agree with you here, your only reason to force 5.4 is to use short array syntax.
Yes, Autoloading is what you're looking at. I'd suggest looking into using Composer and PSR-4 like /u/codenamegary said.
Thanks for advice :)
I'm happy there are still people in the PHP community that have some sense and are speaking out!! You're completely right, I hope a sane approach to annotations comes soon. :)
So you really let your client choose some cheap shared host? I feel sorry for you, and suggest putting some requirements of your own if you let the customer choose hosting.
I can respect arguments to build for a certain version and up, but "inferior" makes you sound childish. 
I can advise but the client has the final say. I'm willing to adapt to a clients needs rather than turn someone down for not meeting my own personal specifications. Especially for something as frivolous as shorthand arrays.
You should realize that the people who write code and the people who buy/lend server hardware are rarely the same people in the real world. 
Done! https://gist.github.com/anonymous/9454640
Same. I separate unit tests from integration/acceptance/functional tests and put them all in separate directories. Each gets it's own test suite. I wish PHPUnit had a way to specific a "default" test suite rather than just running everything.
There are many things that can be improved, but it's a good start. Here are some things I thought of. I'm in the car (riding) so I might have missed something. General: - method name conventions are inconsistent. Stick to camelCase. - echo should be removed altogether or replaced with a logging library. Database: - you should look into PDO for database operations. It's the standard for most db ORMs. Binding is your friend! - a failure to connect to the db should yield an exception, not an aborted script Lesson: - the ActiveRecord implementation should not be coupled to "Lesson". It should be a separate class from which your models extend - you should name your primary key "id" so that it can be consistent across models. If you desire, add a setter to override that property. - once decoupled, the ORM should determine the table name automatically based in the model class name. By convention, it is snake case, lowercase, plural version of your model name. Alright, I'm getting car sick! Hope it helps a little bit, and at least gets you to the next draft. Oh, also, check out auto loading instead of require or include statements!
&gt; **/r/PHP is not a support subreddit. Please visit /r/phphelp for help**
It's become modern PHP practice to not put closing ?&gt; tags at the end of your files. PHP treats end of file as the same as a closing tag.
You need a join like SELECT * FROM insuredlogin LEFT JOIN insuredtable ON insuredlogin.Ins_Id = insuredtable.ID Of course you may want a different join and to select different things so more reading on joins is a good thing. On a separate note, and this is just advice it's up to you, but your column names are really painful to read. Why "U_Name" rather than simply "username"? I have no idea what "Com_Nm" is just by looking at it, it's just a bunch of letters.
That's a crude generalization. Having all properties hidden, yet still accessible through shallow getters and setters isn't the epitome of object oriented design. That approach is often vaguely described as encapsulation. Which however in its original conception was meant for ABI, not API, segregation. Slightly less relevant in PHP and scripting languages, where there isn't even a formalized friend class semantic. What you ought to be doing is making your objects public interface *more enticing to utilize* than *influencing its internal state*. Make properties protected/private only as fallback, if the methods still seem less desirable to use than your objects personal properties. Result state for instance, lends itself naturally to be left as public property mostly.
You should make it public when you are sure you don't need to control the setting and/or getting of the variable, like applying custom formatting etc. Simply make sure you can modify the property directly w/o breaking the code. 
Ok. Ill try that. And ya sorry. Honestly im doing this for a company as my senior priject for my bachelor' s and thats how they wanted them named because they will add to it later. :/ Edit: im not new to programming but am to php. 
You should Google for the definition of inferior. Each new version includes bug fixes and a higher semantic version number; therefore, by every sense of the word previous versions are indeed, inferior.
No, there are [many reasons](http://www.php.net/manual/en/migration54.new-features.php) to use 5.4 over 5.3 aside from the single reason stated here, and compared to other major releases of PHP, there are fewer [incompatibilities and removed functions](http://www.php.net/manual/en/migration54.incompatible.php) as well.
[CloudServers](https://www.ubiquityhosting.com/cloud?utm_source=fbdirect&amp;utm_medium=100x72&amp;utm_term=cloud&amp;utm_campaign=rightColumn) 15GB of SSD storage to install all the PHP 5.4 you want for $4/mo. There's no way for me to possibly understand how you could think that PHP 5.4 is somehow, 'expensive.'
Which doesn't have anything to do with just about anything. If you're running PHP, it should not be in a shared hosting environment; at least, not if you're serious about shipping quality code. The majority of written PHP requires room to spread its legs--get it a tiny VPS, or something. At the very least, spin it up in the cloud with docker and S3.
I've been an IT project manager for almost 10 years. While what you say is indeed true, the majority of the time you end up working with server specs specifically chosen by your client that doesn't mean that those specs that they chose can't be influenced by your needs. Firmly express your technology requirements to your client and/or stakeholders and the benefits involved. Stand behind your decision and good things will come your way.
Hey, that looks a lot like Aura.Sql v2! &lt;https://github.com/auraphp/Aura.Sql&gt;
Oh I'm not the creator, just found it while searching for something to use in my project. In his defense, I don't think the author meant to copy the class, since there are some differences.
Of course there's tons of reasons to upgrade, but you specifically said: &gt; you should update your arrays to the new 5.4 version. You never stated any other benefits until people started saying it was not something people should do.
have I ever contradicted you? Just merely pointing out your childish behaviour
I think these new ORM's need to start thinking about what happens when we need to start incorporating HHVM. This stuff needs to be compileable. If it's not, it will hamper performance of HHVM majorly.
Really? Initialising the database based on define()s in another file?!
Are we looking at the same code? It's entirely different...
I'm not the author, but I have to use something like that because my code goes into public version control, so I can't be putting database passwords in the code. I am however interested in a better method of doing this.
The constructor should take the connection details as parameters. You could certainly use defines yourself in a config file, then include that in your project and pass them into the constructor. But the class should not be forcing you to define specific variable names outside the class.
True.
...Okay? And I was merely pointing out that by every sense of the word, 5.3 is indeed **inferior** to 5.4, but I suppose you took that personally, I suppose? Also, I don't see how using a word in its literal sense, correctly, is considered childish... But I suppose that's just the kid in me being stupid, or something crazy!
It only makes sense to make a class property private if it is entirely internal to the class or should not be directly modified by outside contexts, e.g. it requires a proper setter or getter to validate the property value or format it for consumption. Now, that being said, it is often encouraged for beginners to privatize their properties to get them used to the concept of properly encapsulating their properties and only exposing parts of the class that should be available elsewhere.
They know: http://www.doctrine-project.org/2013/12/23/our-hhvm-roadmap.html
Hey! Good start! Here are my comments based on what I looked at: The method "check foreign key" seems fishy to me... Is it related to security to be sure that actions are executed by a logged in user? Why does the lesson table has a login id? Is it the author id? Why isn't the "loginId" passed as a parameter when it's needed? Another thing that you can do when you have something missing and can't run a code is to kill your application asap. For example, take this code snippet from some method: if (empty($id)) { return "ERRO: EMPTY ID"; } else { // do some code ... return someObject; } What's wrong with that? Every time this method is called somewhere, the code calling it will have to check what is returned (object or string for an error). Which is not good. Another problem is that you're application will be in an unknown state. It won't be where you want it to be, but it will possibly be running other code because you didn't stop it. Coding application and preventing bugs is like being in a zombie apocalypse. If you have any doubt, kill the suspect. So, if your application is not in a normal state, kill it asap. if (empty($id)) { throw new Exception('id was empty!'); } That way you'll know if an error occurred and it'll be easier to find than if you continue with an unknown state. Those kind of zombie apps are those that are the most difficult to debug because the exception comes after the real exception. Also, read about prepared statements. Your code is vulnerable to SQL injection. I wrote an article about it on my blog: http://www.mogosselin.com/injection-explained-and-how-to-fix-them/ /shameless plug So you could just use PDO or mysqli prepared statements. echo-ing SQL is not a good security practice either. It doesn't really matter on your own computer, but if you're putting code online, don't do it. Sometimes beginners will output SQL queries when there is an error but it could help a potential hacker to know your table names, etc. You should use a log library to log stuff. If it's for debugging purpose, you should check out xDebug or phpdbg to debug your code with breakpoints, etc.
Oh...they should really list that as the first option under [Installation](https://github.com/sebastianbergmann/phpunit#installation) with the commands and all. `wget`, `chmod`, `mv` are less friendly on Windows. Composer works everywhere. And feels less hacky than moving executables around.
This is exactly right. It's another post that helps people understand that MVC is not (and never was supposed to be) the end all and be all of your application. Even in CodeIgniter you had libraries for your business logic and your models were meant to stay dumb data handlers, and this is easier and more fun in modern frameworks. People regularly suggest the repository pattern as a direct replacement for interacting with your model. Nope, thats no good, but it can be AWESOME to have repositories and domain models. The domain does the business logic, and repository talks to X data system (or a fake data system) with relatively generic methods. You can unit test that all day, instead of having to unit test against models that interact directly with a database. Good stuff.
Not exactly sure if this is what you're looking for, but this is a really simple library dealing with mainly primitive types. the Unit tests are easy to follow. Here's a link to the [tests](https://github.com/dominionenterprises/util-php/tree/master/tests)
http://github.com/auraphp has lots of small libraries. Eg : http://github.com/auraphp/Aura.Filter for validation and sanitization, http://github.com/auraphp/Aura.Router for routing . I had learned a lot looking at the tests, and has helped me to be part of it.
&gt; Hey, that looks a lot like Aura.Sql v2! I don't know, but it looks similar Paul. 
Check foreign key was about directing the update function correctly. If a primary key is set and the foreign key is set then the sequel statement will run. However if only the foreign key is set, I must prepare a creation sql statement. That's all about flow control. But I see what you mean about the zombie apocalypse. Tomorrow I think I'm going to try this again, just to refine my thinking. I'll look into a php debug extension tomorrow, so I don't expose myself to security threats. I'll look into prepared statements as well. I'll swap my database with a PDO, if it's easy to set up. Thanks for the critique.
They just happen to flock to php like flies on a turd.
I don't know in which ivory tower you live, but when I was still freelancing 99% of my customers already had serverspace in place and where not willing to switch it just so that I could use shortened array syntax. There was the odd customer where I could say "Hey, while we are at it, why not use this better solution?", but most of the time I had to make to with what I got. And that does not only mean 5.3, that sometimes means no mod_rewrite or badly set user privileges. Adopt, adapt and improve!
I wrote [a library](http://github.com/kleiram/transmission-php) that's 100% tested. 
I can see why it will be handy but what's wrong with *replace all* ?
Then, I guess it's a good thing that instead of suggesting that OP change his syntax for a client, I suggested that he change it for his small, very first open source project, huh? &gt;Adopt, adapt and improve! Adopt 5.4, adapt to the new syntax, and improve your standing as a developer!
Expected poorly written click-bait. Was disappointed by useful and informative article with balanced perspective.
If that was the only problem, but it isn't. 1. Not compatible with PDO own interface. 2. WTF is that "error" attribute!? 3. Is nice being unable to pass any option to PDO, specially the statement class or a default fetch mode. 4. Re-creation of unnecessary methods: execute, bind*, yada yada yada. IMO this class is as bad as it gets, better go and use the `mysqli_*` functions. PS: why, oh WHY people don't just use vanilla PDO?!
You should **always** depend on abstractions, not concretions. So, yes, interfaces are "needed" here as much as anything else that satisfies the SOLID principles (incidentally you're suggesting that the "D" is not necessary). Can you make things that work without adhering to SOLID? Absolutely. They will just suffer all the drawbacks that these principles allow you to avoid.
Should be noted that if this is done for the purpose of serving up a mobile-adapted version of the website, responsive design would likely be a much better option. 
Generally speaking because this is domain logic, and I'd rather not put domain logic in a controller. Plus I re-use login checking in a few different places (e.g. on the registration form as well) and I'd rather handle login checking with an exception/try/catch consistently wherever I check if the user is logged in or not. Plus the loginhandler abstracts away the use of Laravel's `Auth::check()`, allowing me a little more flexibility if want to swap out the checking mechanism or criteria later on.
I think I'm a little confused as to what's supposed to count as "application logic" vs "business logic" vs "domain logic". I am getting a fuzzy picture where I'm thinking that the business logic layer essentially provides a bunch of levers for the application to pull, I.e., the business layer is *acted upon* by the application layer. And the application layer is mostly meant to provide an interface between the business layer and the user, whether that be via a web browser or a JSON api or whatever else you may have. But that's an extremely fuzzy notion. It might be totally backwards and in any case it's still hard to know on a case by case basis where a particular piece of logic is meant to go. Can anyone draw a clearer line? Or should I just bite the bullet and buy a book on DDD?
It's noted in the first sentence of the article where it links to http://www.mogosselin.com/4-bad-reasons-to-detect-mobile-browsers/
Buy a book, for sure. Domain Layer vs Application Layer are an important distinction, and I think your analysis of it is spot on. "Business logic" vs "domain logic" are the same thing and only appears there because I was being sloppy in my writing.
The linked article actually starts with that caveat. 
&gt; Buy a book, for sure. Ok! &gt;I think your analysis of it is spot on. Thanks, that helps just knowing I'm heading in the right direction. EDIT: Great article, by the way!
Yeah default scope on variables within a class is what sets the languages apart! @sarcasm
Hi! The URL changed and the old post is broken, so I was just making sure people could reach the article again. Thanks.
So add a redirect then - I'm assuming it's your blog. You still have an old post that links nowhere, so you haven't really fixed the crux of the problem. Redirect the old URL to the new one if it's important that people reach that article. We don't need a re-post, even if the original is not reachable any longer. Debugging the Symfony cookbook example code isn't something we needed to read that badly the first time around, so it's definitely not something that merits a second look or closer inspection.
i would love the next PHP to be called "enthusiastic elephant" :D
&gt; you could raise a notice or warning or other catchable error/exception on a "lossy" cast from one type to another (so if you try to cast "123abc" into a int, you'd get told there was data loss) I know it's a minor point of the post, but an option to turn on this sort of warning/error would be fantastic.
My Unpopular opinion : Responsive design solves this totally
I don't know if I would do this or not, but you could theoretically treat active record "entities" as nothing more than table gateways, then use datamappers to map that data to and from PODOs (which may or may not correspond 1:1 to the table gateway "entities"). So you could have the following classes: **User Table Gateway (active record "entity")** - Responsible for presisting and retrieving data related to Users - The ONLY behavior it contains is relationship query behavior (User belongs to User Group, has one User Profile etc) **User** - The plain old domain object. Has state, behaviors, and child objects pertient to it. **UserMapper** - Uses the User Table Gateway active record object (and possibly other objects) to retrieve data from the database - Map that data to the associated User PODO. The active record relationships of the User Table Gateway would make it quite easy to map the relationships of that active record entity to the appropriate relationships in the PODO (treating it as an aggregate root). **UserRepository** - Might be an overkill abstraction layer, but this could allow you to retrieve users from sources other than the mappers. So rather than treating mappers themselves as repositories, you would treat them explitly as data storage since they are in fact using database table gateways. So if you're "stuck" with active record, this would be a good way to allow active record to coexist with data mapper, enforce a separation of concerns such that your domain isn't explicitly dependent on active record objects, and active record objects have the most minimal responsibilities possible.
&gt; It must be easy to write a single codebase that executes on 5.X and 6.X (and any two consecutive major versions) How about just sticking to a single major revision? Why would you arbitrarily stick backward compatibility across 2 major versions? Great, now is this the LAST version of this feature or is there one more? The compelling reason is supposed to be "because it looks like it took a long time for people to figure out they wanted to switch last time, sometimes". *facepalm* A language specification seems...low priority. The tests are the specification. It would likely turn into another topic to argue over when discussing new features. Also, traits are not the new GOTO.
While I prefer the Data Mapper pattern to Active Record, there is one argument for Active Record that I think makes a lot of sense. PHP is by and large a language intended for building dynamic, data-driven websites. Yes, you can use it for a whole bunch of other purposes, but PHP == data-driven websites for the most part. Given that, data really should be treated as a first class citizen and not necessarily hidden behind layers of abstraction. The statement "*A User object shouldn't know about how it's persisted, or even if it's persisted at all.*" doesn't make much sense in an application where data is a first class citizen. Of course it's going to be persisted. It HAS to be, else the application doesn't work. A User object is in fact, a representation of its data in persistence. Without that database data, the user object is essentially worthless. So to me, direct communication to that data layer seems acceptable. I still prefer a separation of concerns regarding management of that data, but I can see the argument for making treating a User object as a direct representation of its data in persistence.
1. An array is an object having a state composed of different objects. Your argument should be valid for things like `$array[0] = 'something';` Either you are right or everybody should wrap arrays into objects with methods like `setAt($index, $value)` 2. If a user model has a method `getName` that only returns the private property called `name` and a method called `setName` that only sets the private property `name` how is that, from a practical point of view any diferrent than making the `name` property public? 
Passive sounds negative. How about "passionate"?
I can not agree. &gt; PHP is by and large a language intended for building dynamic, data-driven websites. Yes, you can use it for a whole bunch of other purposes, but PHP == data-driven websites for the most part. PHP today is capable of doing much more than just the websites. Public web sites are, probably, the lowest and most trivial of tiers of PHP usage. When this mental border between PHP as HTML templating with some SQL and PHP as a general purpose integrable VHLL is crossed, the problems with "models are persistence" begin to appear. First of all, one of the goals of MVC is to encapsulate the internal data formats of the application; change in internal data formats should not cause breakage outside of the model layer. Second, in non-trivial applications the relationships between data can also be non-trivial; the usual example I give is that given Baskets that contain Kittens and Puppies, how do you count the number of Kittens only in baskets that contain no Puppies? Is the method to do so ought to go into Baskets class, or Kittens? What if you need atomic transactions, are you going to initialize the transaction outside of the model, breaking MVC, or are you going to initialize the transaction in one AR/DM, and then commit it in the other? What if you replace the data backend entirely (e.g. raw PDO =&gt; Doctrine or mysql_* calls to Postgres PDO)? The point here is that any sort of data access layers should not implemented in the models, it should be implemented underneath the models. In fact, there are other cases where models can and should wrap around code that doesn't have anything to do with local persistence: for example, writing output batches, invoking web services, doing calendar calculations. There is no point in doing MVC if it is not followed to the letter; because if it isn't, then it also doesn't deliver on its major promises. Domain logic is a far more general concept than persistence. Even within persistence layer itself there can be variations (soft-bound objects, dirty states, external caching, divertion to e.g. memcached for small populous objects etc). To design models based on an SQL-specific class is a mistake akin to designing home improvement tools based on an axe. &gt; The statement "A User object shouldn't know about how it's persisted, or even if it's persisted at all." doesn't make much sense in an application where data is a first class citizen. Of course it's going to be persisted. It HAS to be, else the application doesn't work. An user object (and several other cases, such as internationalization or session storage) are application specific problems that are so commonly used *both in domain logic and in controller-view layers* that it makes sense to provide them as a part of the framework stack, both as a commonly used implementation and an interface contract that makes application interoperability easier; but in the end, only parts of user objects are managed, read or filled by the framework. Application specific information still should be managed in the user object by the model layer. 
* For reuse - your db connection strings should be passed in via the constructor (or injected somehow). * Use a namespace (especially for something as generically named as "Database" * Use prepared statements * Use phpdoc to document your methods and properties. * If something fails, handle the error somehow, usually by throwing an Exception. 
I appreciate the tip on the redirect, but I disagree with your personal point of view about the matter of the article. Thanks anyway.
&gt; Responsive design assumes that you want all the data on mobile that you can get on the website, but adaptive doesn't. If you have more stuff on a website than you actually want to show, it's most likely misdesigned. 
I don't think he's talking about arbitrarily sticking backward compatibility across two major versions. It sounds like he simply wants to avoid arbitrarily breaking backward compatibility for the sake of it. Iterate and improve, etc.
That's the main issue with identifying devices based on their user agent. It's a never-ending chore. That, and trying to classify a device as one thing or the other becomes increasingly hard given how the device landscape has changed in only a few years, the plethora of devices which differ in both shape and form, and the stuff that's coming in the future. 
At serious risk of not sounding like a serious programmer, What is a language spec?
I would instead say that Active Record has it's place, and when your application is mostly CRUD (and very much tied to your database schema), then Active Record is probably the best way to go. (Personally I've found that Active Record covers a majority of use cases I've come across) In short: Your use case and needs should dictate what tool you use. Don't try to fit every use case to AR or EM strictly. There are plenty of situations where the data model is the first class citizen (software modeling the real world), and data persistence is simply a way to make sure the data models end-result is stored properly.
Do your own homework.
&gt; It must be easy to write a single codebase that executes on 5.X and 6.X (and any two consecutive major versions) Depends. In PHP world, 5.2 and 5.3 _are_ two consecutive major version releases. PHP5 has been going through a bit of a ... growth spurt. It is entirely feasible that it would be impossible to write code that works on PHP6 and cannot run on PHP5.2 and below. Right now, it's perfectly acceptable to have non-PHP4 compatible code. And I'm okay with that. PHP5.x has add a lot of major milestones that PHP sorely needed to become a "mature" language. 
No problem with taking a risk. Its a great question. :) A language specification is a document (or documents) that details the syntax and grammar of a language. A spec helps create a reference that allows other implementations of a language to exist without changing the semantics of that language. For example, Python has the ["PRL"][python-prl-3], and therefor Python's well documented specification has allowed it to have **many** implementations (CPython, Jython, PyPy, etc) without completely tearing apart what makes the Python language. PHP, on the other hand, has a complex situation where the Zend Engine and the language are somewhat coupled without a hardened/documented specification, so a lot of the details of the PHP "language" are actually implementation details of the Zend Engine itself.... this of course creates compatibility issues between PHP and HHVM's own implementation. I hope that helped. Anyone, feel free to correct any of my errors. :) [python-prl-3]: http://docs.python.org/3/reference/
As I've said before, I've been a project manager for almost 10 years. You won't find anyone who understands this plight better than I, however, a client is coming to you for your expertise. If you tell them it's better to upgrade to 5.4 and cite specific reasons why, unless it's prohibitively expensive they'll listen to you. At least if you work with well spoken for developers. Additionally, not many things are _too big a risk_ when it comes to securing the future of a project. Risk management is apart of the information technology project management life cycle for this very reason. As long as the adequate amount of time is taken during the planning phases of a project to firmly explain expectations, pitfalls, positives and negatives no stakeholder is going to deny stable updates to a code base that patches potential security holes, improves readability for future updates, and keeps you current with the competition.
Thank you. It helped. 
&gt; As long as the adequate amount of time is taken during the planning phases of a project to firmly explain expectations, pitfalls, positives and negatives no stakeholder is going to deny stable updates to a code base that patches potential security holes, improves readability for future updates, and keeps you current with the competition. That's cute. What color is the sky on your planet?
Well, I guess you're simply not a very persuasive developer or project manager. Clients come to you because you know something they don't--specifically how to use technology to bring their vision or idea to life, and make it profitable. Cite concerns, and give examples of how it'll end up being cheaper in the long-run, and they'll never tell you no. IT projects are collaborative for developers, PM's, and stakeholders. If a stakeholder ever hires you, and pulls the "it's my way or the highway," always choose the highway option. It's not worth your time.
There are always things you can do. I remember being a young programmer learning PHP whoring myself out for cheap (sometimes free) for hosting space. Back when 1GB of space was huge. Find a friend that hosts a dedicated server and offer to do sine freelance work for them in exchange for space.
Well, based on his article, it'd be to avoid the situation that Python developers face choosing between Python 2 &amp; 3. Or, not being able to use 3 because a lot of libraries haven't been updated.
I guess I'll have to try it out, because I don't really see any advantage over normal find/replace; it actually sounds less helpful. Thanks for the reply though.
That's exactly my conclusion 2 lines below :) But you don't have to: you can type-hint against `Collection` (instead of `Repository`) and still make your code more reusable.
I don't understand what are saying with "instead of just calling them directly". If you are saying why not to create the object and call the function instead of pass the reference, the answer is SOLID. If we create the instances inside our objects the responsibility of our function it's also to create the object. And if we need to change the creation of the object we need to change it various places. If the creation of our objects is in one place our code becomes maintainable. (but maybe I didn't understand your question :)
In my humble opinion legacy kills PHP. If I had absolute power over PHP development decisions, I'd remove that mysql_* crap, give exceptions to functions, which return FALSE on failure, and fix the convention (htmlentities and html_entity_decode stuff)
One thing that always bothers me with PHP is how concerned the community is with BC. PHP has done a fairly decent job with BC, but it's seriously hindering the language at this point. Why can't PHP have a "clean break" and release a version that existing code bases will not work with? The only difference between controlled breaks and a clean break are the number of changes. If you updated a codebase from PHP 4 to PHP 5.5, that is a shit ton of controlled breaks to take care of, anyway! Let's clean up the most common complaints of PHP. Confusing argument order, confusing names, error handling, etc. Make PHP only throw exceptions. Abstract the str and array methods further from their C counterparts. Choose a consistent naming schema. PHP is up against massive competition right now. There will be fewer and fewer new PHP developers as others move onto JavaScript, C#, Python, etc. Why? Because PHP has baggage that it just *won't let go of* that we all know it *needs to let go of*. PHP is on the cusp of becoming a great language. It just needs that last push.
You're missing the point I think. With Python, code written form Python 2 does not run on Python 3 and vice versa. And that's a problem because library authors only cater to one Python version usually. Today it's perfectly feasible to write code that runs on PHP4 and on PHP 5.6, and every version in between. Sure, most library authors want to use PHP's newer features and only support 5.3 or higher. But when PHP's next version comes around, their code will most likely still work without change. Imagine that when PHP 5.6 comes out in a few weeks, none of the existing PHP code would work without a major rewrite, and that after such a rewrite, it would not work on 5.5 and below anymore. Nobody would move to PHP 5.6 in such a case. This is exactly what happened when Python 3 came out.
And you would end like python, two programming languages. 
&gt; If you have more stuff on a website than you actually want to show, it's most likely misdesigned. That's incredibly generalized. It really depends on the application. For most of the time, responsive is the way to go. However, there are some instances where you would want to create a better (and simpler) mobile experience by limiting features on mobile versions of web applications. Lots of websites do this successfully. 
Not to be that guy because I completely understand what you are saying, but I can get the same result in PHPStorm doing normal find/replace with less actual keys pressed and without needing to know all those special keyboard commands.
Like I've said all along: *Most likely*. &gt;However, there are some instances where you would want to create a better (and simpler) mobile experience by limiting features on mobile versions of web applications. Lots of websites do this successfully. And in those instances, one ought to consider whether the desktop versions have been properly designed or not. In many cases, it *is* a matter of the website being misdesigned. Being in the industry, I've seen many examples of the design process having gone wrong, where the designers have first built the website design before caring about the content. In such cases, clients have found and expressed a need to fill empty spaces. That is a failure of design. Design should support content, not the other way around. That's the benefit of a mobile-first approach: It forces you to focus on what is essential to the website and takes it from there. 
I agree for the most part. I think you need to draw a line between "legacy = supporting past projects" and "legacy = holding back the language". The first is positive, but the second is obviously not. People who live in different camps on BC tend to look at it as one or the other. I could see a lot of benefit to cleaning up the API. Inconsistencies like nl2br, strtolower, and isset/is_array/empty are embarrassing bullshit, and should be cleaned by deciding on a format and aliasing everything to the canonical version with a notice on the "old" version. Similar things should be done with the mysql_, mysqli_ etc extensions. It would be good to see PHP encouraging and promoting PDO instead of extensions.
Agreed. But I don't think it needs to necessarily be a "break". I think you could transition quite nicely into these features without absolutely killing current standard code. &gt; Choose a consistent naming schema. Unfortunately easier said than done. This is the same group that can't properly vote for key features that **should** be a slam dunk. Can you really see them agreeing on a naming convention?
Those mysql\_* hit me most. I also think all those backpulls need to raise warning before ultimate remove, but that shouldn't be long period. We already have long period of mysql_* deprecation. 
For sure. By "break" I mean if the * to be refactored breaks the existing implementation, either provide an abstraction for the old ABI to use the new one, or throw some specific exception when it's used. More to the point, I'd love to see PHP move on without concern for how old implementations work. True enough about the finicky arguments over features. If one thing is for certain, developers love their own notion of schemas.
&gt; Sure, most library authors want to use PHP's newer features and only support 5.3 or higher. Most libraries today are written in a way they _can't_ run on anything below 5.3. This was intentional and a shift that's been going on for over a couple years now. Right now, a lot of PHP4 code simply will not run on 5.4 and forward--with very good reason. The author is incorrect in their assumptions of major release number requirements. This is an extreme "zero-tolerant" view on things. What the author means: is the language developers have to look at adoption rates and the majority latest major release version on the market, and insure their code, at the least, remains compliant with that to insure best adoption rate possible. PHP has done this, even though PHP5.4/5.5 code simply will (most likely) not run anything developed for 4.x.
You're missing the point. 5.0 ran 4.4 code, for the most part. Who cares if 5.6 does? 6.0 should run 5.6 code (and hopefully 5.4, but doesn't need to run 5.0). It's not that there shouldn't be progress. And it's not that there shouldn't be breaks. It's that the breaks should be done in a way that's easy on the end-users. And they should be contained in a way that it's always possible to support before and after (for a single minor version before/after at least) a single codebase... 
&gt; Most libraries today are written in a way they can't run on anything below 5.3 Yes, but this is the authors *choice*. They could have written them in a way so that older PHP versions could also be supported. With Python 2 and 3, that simply isn't possible. &gt; Right now, a lot of PHP4 code simply will not run on 5.4 and forward--with very good reason. I have to disagree. The company I work for is still supporting an old custom CMS system (No need to pity me. All out new stuff is shiny Symfony2 on PHP 5.5). It was written in the PHP4 days and was later ported to PHP5, but it still uses quite a few old PEAR libraries from PHP4. I recently moved it from PHP 5.2 to PHP 5.5 with no fuss. Practically the only change I needed to make was making out custom error handler ignore E_DEPRECATED and E_STRICT.
In the next episode... How do you detect tablet phones?
From a pythoneer: &gt; but because it's not possible to maintain a single codebase that works on both versions. Which means that you either use 2, or you use 3. Starkly, completely, utterly false. A single codebase is about the *only* recommended way to maintain Python 2+3 codebases these days, which yes is perfectly doable, of which some of the [biggest python projects](https://www.djangoproject.com/) are. Interestingly enough, &gt; More importantly though, due to this loose type system, you can't 100% of the time know what type a variable will be. You can tell how you want to treat it, but you can't tell what it is under the hood. Even with casting or scalar type hinting it isn't a perfect situation since there are cases where types can still change. &gt; So that means that all scalar operations would need to be bound to all scalar types. Which leads to an object model where scalars have all of the math methods, as well as all of the string methods. What a nightmare... Well python does exactly this mythical achievement, it doesn't have all scalar operations bound to all scalar types, it's not a nightmare, yes it is dynamically typed, and well, it's not an unpopular language. Hell, Go also has a beautiful implementation and it isn't even object-oriented. *Ircmaxell, have you been writing anything *other* than PHP for the last 5 years? 
&gt; With Python, code written form Python 2 does not run on Python 3 and vice versa. Just from an interested pythoneer's perspective, I'm disappointed with ircmaxell's research. You can do *exactly* that, and his statement that you can't is *patently* false. I can't overstate this enough. You know Django, the biggest python Web Framework, or Flask, arguably the second? Both single code bases, both Python 2 + 3 compatible; just in case you'd like examples.
Not really, there are still things that you need to do in backend.
Passionate Heroic Paraflam?
This is HHVM FUD.
True dat
True. Also see my other comment.
I believe the quote about cache stampedes is from my article on opcaches, so I apologize for the confusion! A cache stampede isn't a result of turning on the cache, it's a result of running without a warm cache when load is too high to do so. e.g. With OpCache enabled, and with a pod cache built up, you consistently hit 90% resource usage. This is no issue. You are responding to all requests, yay. Then you need to restart your httpd (or the php-fpm pool) and lose your cache... Now you are in trouble. No way can your machine respond to all those requests AND build up the cache! This is a cache stampede. This same issue occurs when you add a new server to your pool to alleviate high load - you're doing yourself a disservice if you don't take the time to warm your cache first as the server will not be able to take as much load as it otherwise could. If your server is currently able to handle the load without completely maxing out the resources, enabling OpCache will use a small amount of extra resources to build the caches, then be able to respond faster and to more requests as load goes up with more popularity (hopefully!) If you are worried, identify a low-load time and enable and warm the cache (using the scripts in the EY PHP Performance Tools linked to from [the article](https://support.cloud.engineyard.com/entries/26902267-PHP-Performance-I-Everything-You-Need-to-Know-About-OpCode-Caches)) Hope this helps!
Yes, as he suggests, TDA has to be applied properly in order to be beneficial. It does *not* mean "never query an object for information about its state." Consider a simple example. Let's say we have an employee, Bob: $bob = new Employee(75000); // initial salary of $75K Bob has been a good employee, and we want to give him a raise. We can do this in one of many ways: We could make `$salary` a public property, and give him a raise like this: $bob-&gt;salary += $raiseAmount; Or we could "encapsulate" (air-quotes, because this isn't true encapsulation, as I'll touch on in a second) the salary and expose it through accessors, like this: $bob-&gt;setSalary($bob-&gt;getSalary() + $raiseAmount); But both of these approaches are pulling the behavior out of the `Employee` class and into the calling context, and because of this, we also need to pull the state out of `Employee` and into the calling context, as well. This is actually **breaking** encapsulation, which is ironic, since most people create accessors specifically with the illusion that they're preserving it. A true TDA approach would leave both the data and behavior in the `Employee` class, where it belongs, by *telling* the object to do the job: $bob-&gt;giveRaise($raiseAmount); *So where might you still need getters?* Anywhere where you aren't going to be telling an object to do something after asking it for its state and making a decision based on that state. In the previous example, we'd very likely still want a getter for the salary, so that we could display it on a UI.
It's not really a choice between 2 and 3, it is possible to support both (of course it's more work to do that). That said, the python wall of superpowers is pretty green at the moment :)
You can use this https://github.com/gabrielbull/php-browser /shameless plug
High Performance MySQL is imo, the Bible of MySQL, I learned a massive amount of info after reading this book. I highly recommend it! http://shop.oreilly.com/product/0636920022343.do As far as PHP, no idea, always been a database kinda guy versus PHP developer. But I hope this at least gets you half way to your destination :) 
if you are at the point of a stampede, your server is already overloaded. If it's not, you won't stampede, you'll just build the cache and respond slowly in the meantime. :) The traffic being low enough is going to depend on the performance of the box. How much resources your have free, etc. It's not something you can figure out just with the traffic numbers. Though I'd say that even at your peak, modest hardware probably doesn't even *need* a cache to handle the throughput — you'll just be getting a performance boost.
But the guy does have a point if you look at python 3.
Hobestly curious: then why the low adoption rate for python 3?
In reference to people not embracing Python 3 because 2 works well enough for them?
Great read. Can't wait to use Composer at work.
https://github.com/RickWong/Phur - 100% tested patterns.
Very good list, but: keep constructor arguments clean from scalars if possible. And also try encapsulating the password into an object that's not dumpable (return password from a method). 
Yes, that. If PHP 6 is released and breaks everything, while PHP 5.x is considered "well enough" forever (say 10 years), then I don't see the point in dividing the efforts into two long-lived versions, practically maintaining two separate projects. Worst-case scenario we'd be back porting 6-features slowly one-by-one into the 5.x branch. Might as well add the features now directly, and tag 6.0.0 randomly. Edit: I actually like the way it goes now: release minor versions 5.x more often and deprecate more and more stuff each time until shit's cleaned up. Might take a few years but that's tolerable.
Almost the same voting system but the key difference here is that the FIG develops Standards in "userland" while the PHP language enables entirely new solutions through new syntax. Annotations as they're currently used in comments can be standardized by a community, but the language could (should imho) really bless the feature with its own deserved syntax, that does not involve comments syntax for the sole sake of the long overdue shit parser.
Because it's possible to write code of all kinds: you can have code that will only run on 2, you can have code that can only run on 3, you can have code that runs on both. Basically, [ubiquitous library support for 3](https://python3wos.appspot.com/) has only really blossomed last and this year, and only after that do you expect applications relying on those libraries to make the move. TL,DR: the low adoption rate for python 3 is the same as for PHP5 was.
They'd have their own syntax in a new PHP version. Just like namespaces, traits, array splats and generators all did in their time.
Other than mis-spelling my name several times... &gt; Starkly, completely, utterly false. A single codebase is about the only recommended way to maintain Python 2+3 codebases these days, which yes is perfectly doable, of which some of the biggest python projects are. I stand corrected. I will update the post. But, is it trivial to support both (which is what my original point was)??? Also, check out [this article](http://blog.startifact.com/posts/python-2-gravity.html). While yes, it is *possible* to support both 2 and 3, it's far from trivial or incentivised. Quoted: *If you feel some moral obligation to The Python, or at least want to be cool and modern, you might consider writing polyglot code: code that works in Python 2 and Python 3. You gain for this some coolness points, potential users who use Python 3, and a harder to maintain codebase. You gain none of the benefits of Python 3.* So no, I was wrong with the absolution of my term, it is possible. But I was correct with the semantic meaning (that it wasn't done for literally years, and still is a massive problem)... &gt; Well python does exactly this mythical achievement, it doesn't have all scalar operations bound to all scalar types No it doesn't. Python has native types for scalars. So a string is a string. In PHP, that's not true. Strings can be integers, and vise versa. For example: "12".is_integer() Throws an exception, since `is_integer` is a method on the float type, and `"12"`, being a string, is not a float... In PHP, that should return `true`, since `"12"` is a string that's a well-formed integer value. You could argue if this is *good* behavior, but this is the design of PHP's type system today... So no, it doesn't do "this mythical achievement". Python's type system is very different from PHP's. Everything is a first-class object with defined conversion semantics. PHP's are not, with much looser defined conversion semantics. As far as Go's type system, it's also very rigid. It's strongly typed... &gt; have you been writing anything other than PHP for the last 5 years? Great ad-hominem...
Perhaps 'Pornographic' ;)
I can't help but think this approach does long term pain in favour of short term gain. Rip the bandaid off. There are things which need to be fixed and a major bump in version number is as good a time as any to do it. Will it slow adoption? Well maybe. The landscape is very different to what it was during the 4.x/5.x cut over. There is renewed interest in the language and a lot of major projects which are already comfortable sitting on the cutting edge of what PHP has to offer. Sure be backwards compatible where you can, always. But it shouldn't ever be a primary concern when there are things that need to change.
amen.
Could there be any more call's to action on that blog?
mysql_ is going away though: [example documentation](http://www.php.net/manual/en/function.mysql-close.php)
Laziness is my inspiration. I have a reasonably complicated application and object oriented program is the only thing that'll save me work.
I do love how anything mentioning Aura gets downvoted. If you're going to downvote it, at least explain why so the OP knows why they should not be looking at this particular resource...
This is what's usually said to PHP haters. I really like PHP. I want it to succeed. Within the last ten years, RoR has changed how web applications are developed. Python has been boning up its web capabilities and growing in popularity among a less-scientific audience. JavaScript is available on the backend and has a huge uptake by the community. C# is an extremely nice language to work with and has a mature MVC framework available to boot. For the last ten years PHP has survived because everything else was miserable to work with. Perl? Blech. ASP? Double-blech. Even Ruby has some blechiness, but Rails provided a sane web application abstraction. I wholeheartedly believe PHP is a good language with some bad (historical) design decisions. I'm not so blind to see the enthusiasm with which developers are moving away from PHP.
Using techniques to "prime" the cache are a good idea, OpCache includes a function perfectly suited to this ~~(which APC didn't include)~~ (it did, see below) http://au1.php.net/manual/en/function.opcache-compile-file.php
Nah wasn't a question for you, just an observation that anything relating to Aura seems to get magically downvoted, usually without explanation.
did ... http://php.net/apc_compile_file
Usually E_WARNING is used for these kind of situations in the recent versions, even though that some of those were E_STRICT before.
You can move away from PHP and learn Ruby and than the Rails framework. Or perhaps Python and than Django. Or you could stay with PHP and learn ZF2 or Symfony2. Very good frameworks, plenty of jobs, and salary is quite good as well. I do not see demand for good PHP developers dropping. Good programmers are always in demand. There is still work for good Perl programmers (something to think about).
I once worked at a place where the only copy of the code for a microcontroller in one of the products they were selling was stored on a developers laptop. In a folder with &gt;50 files named file_old.s, file_1_old.s, file_old_1.s, old_file.s etc. I tried to get the developer to use a versioning system but he never understood what it was supposed to do. In the end I just told him once every day to push the commit button. Also, it took almost 15 minutes to boot the laptop and it ran Windows ME.
It's -1 because mt_rand takes a min and max value. The random number is being used as an index into that long string of characters to... randomly pick a character. String indexes start at 0 and go to the length-1. So by doing mt_rand(0, STRING LENGTH - 1) you can use the resulting random value as an index into the string of characters you wish to randomly pick a char from. The loop is just going until the length of the created string finally hits the required length as specified in the function call params. Each iteration of the loop just adds an extra char onto the end of the current $return variable. Eventually it will hit the required length and stop iterating.
1. There is a -1 after the strlen because **$num_characters** is used in the **mt_rand** function which generates a number between 0 and the max value **inclusively**. Because we start counting arrays from 0 if you use the true size of **$characters** you could end up having a random aray index longer than the character array. 2. a. You loop while the string **$return** is smaller than **$length** b. You append (=.) to **$return** a random index of **$characters** as defined by the **mt_int** function. As for it returning 4 characters after several refreshes; it's possible that you are either killing the script with a refresh or that it's being killed by the server somehow. You might want to look into the Apache or PHP-FPM logs to see what's happening.
I'd rather have the developer implement new features and cover the core with tests, rather than get stuck in the routine of trying to have tests for every single feature in the framework - ending with the stagnation of the framework.
How is having every execution path tested a gimmick. I could put a die; statement somewhere in there, completely pass the tests and still pass all the tests. Also developers of HHVM run framework tests to determine if the framework will workon HHVM. And up to this point laravel was passing. So now someone might actually switch to hhvm on production thinking that all will be well, but rhose untested 50% of code may contain stuff that wont run
53% is still quite high for code coverage, you should try and not focus on the coverage percentage, or try to find an arbitrary number for it, but instead focus on having as much logic and functionality tested as is humanly possible. It is quite reasonable to have a 50% coverage rate if only because only 50% of the code contains logic that can be tested, and the other 50% happens to be simple DTOs or things that are handled in this case by Symphony components that Laravel wraps. Basically Laravel doesn't seem to have 100% code coverage and that's alright because the coverage that it does have appears to cover a large proportion of its functionality - Taylor could spend time adding an additional 30 tests and still only increase the code coverage by a couple of percent for very little benefit to the project as a whole.
Wasn't there someone who actually did it? I believe he had almost zero adoption rate.
i couldn't care less about code coverage of projects i'm not involved in, the numbers are meaningless for me. if you go down the road with your team on your projects, code coverage is a good indicator, but for you and me 50% cc of laravel doesn't mean more or less than 100%. (well obviously for you it does mean something :))
&gt; How is having every execution path tested a gimmick. I could put a die; statement somewhere in there, completely pass the tests and still pass all the tests. Nit-picking, but PHPUnit can only show you line coverage, it doesn't do branch coverage, so 100% coverage reported from PHPUnit doesn't guarantee 100% execution path coverage.
At least it safe to say that without 100% line coverage you cant have 100% branch coverage )
It's worth mentioning that PHPMD is a much better tool for detecting things like 'die' in code bases
100% branch coverage in one crucial function may be more valuable/important than 100% code coverage in a larger scope.
+1 for phpmd. unused code/variable detection regularly saves me time.
I'm sure Taylor will appreciate pull-requests to increase test coverage if you're up for it.
That scenario is pretty common actually. The only difference is that instead of die; you put some broken logic while refactoring for example. Die; was just an exaguration. You want to have full tests coverage for less worrysome refactoring
Disagree. Knowing when to apply these guidelines and when not to is just as important a skill as knowing the guidelines. Pragmatism before dogmatism, always. There is no practical difference between OP's project with or without an interface. OP has written a single class and there is no foreseen future development. The project would behave identically with or without the interface; ergo the interface is an unnecessary development burden. Not a big one, but when you are billing clients by the hour it becomes important to know what is actually necessary to write and what is not.
&gt; So now someone might actually switch to hhvm on production thinking that all will be well, but rhose untested 50% of code may contain stuff that wont run Introduce me to the person who's just gonna go drop HHVM in production and not even load the site first to make sure it's gonna work. Not that you don't have a point, but this case you state is never gonna happen. 
Anyone know the coverage percentage of Symfony, codeigniter?
Why not test everything thoroughly?
I highly recommend [Laravel](http://laravel.com) and to learn where to get started on most of the stuff you're asking with step by step guides check out [Laracasts](http://laracasts.com).
Considering you're very new to the stuff in all honesty I'd suggest you simply learn the basics first. There's several really strong frameworks out there: - [Zend Framework 2](http://zf2.readthedocs.org) - [Symfony 2](http://symfony.com/get-started) - [Laravel](http://laravel.com/docs/quick) - [Phalcon](http://docs.phalconphp.com/en/latest/index.html) - [CodeIgniter](http://ellislab.com/codeigniter/user-guide/) - [Yii](http://www.yiiframework.com/tour/) - and more... Every Framework has it's own strengths and weaknesses and it is up to you to understand those and then choose the framework that suits you best. I fully understand that this answer won't make you all too happy, but all I can suggest is that you check out the quickstart documentation for all of those frameworks. Try them out, write your first little application and then decide what suits your needs the best. DO NOT CHOOSE A FRAMEWORK BASED ON WHAT OTHER PEOPLE SUGGEST. You'll only hurt yourself in the long run.
I zipped the report, you can get it here: https://www.dropbox.com/s/y3u17qh52jdkyub/report.zip
Laravel and CodeIgniter are great for newcomers, but I feel Symfony and Zend would be a little too intimidating for a beginner.
So you check that the site loads, users can log in and browse around the most common areas, but you forget to check a report page that the CEO uses once every few months, which turns out to be broken. Then you'll be getting angry phone calls on your weekend.
Thank youuuuuu! :)
This is one of the (many awesome) uses of QA. If they know what they're doing, they'll have tested all the functionality before release.
OP misinterpreted DB-Layer with Repository. A Repository includes a DB-Layer but it is way more. If your "repository" would be one, then any ORM would be one too. further reading: http://msdn.microsoft.com/en-us/library/ff649690.aspx http://code.tutsplus.com/tutorials/the-repository-design-pattern--net-35804 
Time constraints come to mind. Sometimes you have to prioritize.
https://eval.in/118081 Check out using the above site for posting code. It's really handy to be able to see the output and the code at the same time. :)
We use a combination of Behat and QA testers here, but until fairly recently we had no test team and the onus was entirely on the developers to make sure their code worked before release. That was a bad state of affairs. Behat can be a pain, especially as it adds ~30-40 mins to our Jenkins builds (we have a few thousand tests in ~100 feature files), but it's also saved our asses on numerous occasions.
Because there are a significant number of getters and setters that are not tested. The facade classes are don't need tests as they simply contain a string pointer to the container. That's an additional 25 classes or so. As far as I know every "real" function and class in the framework is tested. And the things like Auth and Eloquent have many many 100s of tests. Also keep in mind we use a lot of well tested components. Since the log component just wraps Monolog, it's not going to have many tests.
[Symfony](http://symfony.com) has a whole [cookbook](http://symfony.com/doc/current/cookbook/index.html) and sample applications everywhere. It's probably the most accessible framework out there right now.
&gt; A Repository includes a DB-Layer but it is way more. I don't think I said otherwise? Or maybe I don't understand what you mean. &gt; If your "repository" would be one, then any ORM would be one too. I don't really understand what you mean, could you expand?
I think this will benefit your understanding: http://martinfowler.com/bliki/TestCoverage.html Is 53% pretty bad sounding? Yeah. But 100% is more or less a fallacy. You don't test to get code coverage, you test to prevent pushing bugs to production. As such, not getting coverage on a "get" or "set" method for a table entity from the database (as an example) is perfectly acceptable. However, the logic that calls the get or set (such as logic inside the controller) definitely needs to be tested. That is what you should be looking to see tested: Code that isn't simple enough to analyze into correctness. 
Actually that is pretty low since even 100% coverage doesn't mean your code is bullet proof. Let's say you have a function that calculates the number of pages (think pagination) of a result set where one argument is the number of "items per page". You can do a simple `ceil($resultsCount/$itemsPerPage)` and you're done. You may think that you don't need to test that function and yet somehow somebody manages to set the "items per page" to zero or a negative. You can write a test of the normal scenario (where "items per page" is valid) and get 100% code coverage. Statistically though your code is working ~50% of the situations. And that's WITH 100% test coverage.
The problem is that the ecosystem (the grand ecosystem, not the popular frameworks) is really quite fragile. They are already not adopting 5.5/5.4 fast enough for comfort. Ripping that bandaid off may very well cause the entire community to either collapse or fork. Neither of which is going to be good. And that's precisely what I'd like to avoid. &gt; But it shouldn't ever be a primary concern when there are things that need to change. The point is not to *not* change them. But change them in a way that lets people evolve code over time (slowly, through defined and easy changes) rather than having them have to rewrite from the start...
We don't have a separate test team here but management has been receptive to the increased use of automated testing. The possibly hard part is to get developers to write/update tests for stuff they're working on.
People out there are switchng from PHP to HHVM on production without trying it out locally? They deserve whatever happens to them.
Yes, I just did. No, those functions are not functions we normally test. For example, the "validate" function simply calls the "attempt" function with an extra parameter. We don't test something like that. It has extremely low churn. This article might be helpful on why we don't test methods like that: http://signalvnoise.com/posts/3159-testing-like-the-tsa
Yup they would. Actually having those 'tests for one class that provide coverage for other class' is pretty bad too, as the best practice is to make sure that the coverage for a method is generated only from those tests that are testing it directly. Thats why PHPUnit has the @covers annotation. You use it to whitelist which method the test covers, in order to not cover dependant methods. Using @covers adds even more work, but it's pretty cool =)
CodeIgniter by line only has 58%, and by class it's on 12.5%. https://travis-ci.org/EllisLab/CodeIgniter/jobs/20472945 This is somewhat misleading as tests are run for MySQL, Postgres, etc separately so not all coverage in each build is run, meaning the percentages should be a little higher. This is an example of 100% not mattering.
&gt; The problem is that the ecosystem (the grand ecosystem, not the popular frameworks) is really quite fragile. I'd love to see data on this... I assume you have some to back up the statement? or is this your personal belief? Because from where I'm sitting it sounds a lot like you are basing your argument on what happened with the 4/5 jump, and you are neglecting the fact that the community has come an awfully long way in the intervening years. &gt; Ripping that bandaid off may very well cause the entire community to either collapse or fork. And is it not an equivalent risk that the community will fork because in some areas it is running up against language limitations? Or fork because they see Facebook's offering as a better bet? 
If I build my application on top of Laravel, and my application has 100% coverage, then by extension, does this imply for the portions of Laravel executed by my tests and application, Laravel have 100% test coverage? Of course, this assumes I am not completely stubbing out calls into Laravel. Separately, I don't know about you but my code has bugs in it. Therefore, the untested portion I write is certainly going to have some number of bugs. The tested portion will probably also have bugs because I can't think of everything. Although, the number will be allot less. The most concerning aspect of all of this is that ~50% test coverage implies Laravel was not written using TDD. In my experience, this generally leads to tightly coupled, hacky, and brittle code. Future changes tend to break things in seemingly unrelated ways, etc, etc.... We've all been there and done that. I thought the whole unit testing debate was put to bed in the first few years of this century. Seriously, it's 2014. Greenfield projects should be thoroughly tested. Projects meant to be the foundation of many other projects should be more so. Coupling this with the fact that the word facade is used in ways it shouldn't be paints a picture of a project on very shaky ground. Facade has a very specific meaning in our industry. It's already taken. It's like me using the word "semaphore" when I meant "bicycle tire". To quote a great movie... "You keep using that word. I do not think it means what you think it means." --Princess Bride Most of my day, every day, is spent untangling code in legacy projects not built with TDD and getting test coverage in them so I can make changes without unknowingly breaking stuff. These projects always look the same. Not every project is going to have a department full of testers to manually test the code. Therefore, my tests and I have be be my own testing department. I suspect many PHP projects are in the same boat. Unused getters and setters may be dead code and may need to be deleted, maybe. If truly needed, then they should be tested. However, they can be tested as a pair. 100% coverage is really a minimum, not a maximum. For projects meant to be used as a foundation of other projects and also meant for mass consumption, I suspect the minimum should be higher, much higher. Projects are only as strong as the foundation they are built upon. 
What about Illuminate\Queue\Console\ListenCommand ? Seems a pretty decent class. I understand that testing everything is time consuming, and normally I'd agree with you if you were making a website or single app. But since you are aming to make Laravel a widely used widestream project it really should hold to higher than average standards imo.
Well you could try locally but it doesn't mean you'll see the error on the first few pages. If those methods were not covered they probably aren't that widely used by the app in the first place. HHVM was just a example of hy a person might want to have full coverage =)
Could somebody explain to me what this code coverage means? And could somebody explain to me why i should care about it? Thanks in advantage guys!
&gt; 100% coverage is really a minimum. Preach it!
If you use a proper IDE you will immediately see unused code/variables.
Also, you really should take a look to whats causingPHPunit load when generating coverage. For most projects coverage reports generate in few seconds, with laravel it takes 5 minutes with 250 MB RAM and 25% cpu load. It's not Laravels issue for sure, but there is something weird happening with PHPunit.
Please stop recommending CodeIgniter, the project is dead and it's codebase is VERY outdated.
You're pretty limited in what you do visually on a website. Even if you could create a PHP wrapper for your C++ code, that isn't going to help you with rendering in the DOM. For that, you need JavaScript. There are plenty of libraries that help out with this if you're not comfortable writing pure JS. Since you mentioned Python, here's a Game of Life example written in Python and using a JS visualization library: http://jakevdp.github.io/blog/2013/08/07/conways-game-of-life/
I'm not worried about jobs for good PHP developers or jobs going anywhere. I'm worried about new developers coming on board.
Well the getters and setters still get covered as a side effect even when testing more complex stuff
Because you didn't write the tests.
Trivial methods should be suppressed from coverage, in PHPUnit with @codeCoverageIgnore
Code coverage is a measure of how much of the possible code paths is covered by automatic tests. Assuming the tests are designed correctly, a 100% coverage means all meaningful code is tested. A 0% coverage means that, well, somebody out there *believes* it works but there isn't a working way to prove that.
&gt; Of course, this assumes I am not completely stubbing out calls into Laravel. Which you should.
You can't prove it *doesn't work*, hence God.
Zed Shaw?
Alright, and how do i "test" the code? Is it like hard code an test case and see what happens or do you use something else? And when i wan't to use this type of tests, how do i implement that? Is it just a stand-alone app or do you have to code in an particular way? ( sorry, but i'm very new to code / unit testing )
I am sure /u/utotwel would accept pull requests to increase code coverage. He has in the past. It seems to me that it is a non issue for Taylor to spend the time on it since the majority of the framework is tested. The rest can be filled in by the community. 
Interesting. I'm really open to any idea. I mean like I said, I'm not totally experienced or dedicated to one platform. Would you by chance have a link for a tutorial?
You can use the `@codeCoverageIgnore` annotation to make PHPUnit ignore certain blocks of code. If you put it above a method, the entire method will be ignored. Anything between `// @codeCoverageIgnoreStart` and `// @codeCoverageIgnoreEnd` in code will be ignored as well. This allows you to achieve a much higher test coverage while also specifically stating that some methods are intentionally untested.
Let it go man, this discussion is never going to resolve itself. Instead of having this discussion, let's focus on making PHP more awesome.
I never said it has to be specifically him who does those =)))
I know and agree, just guessing as to his mindset on why it is not important to him. I was also responding to your line about it should be help to a higher standard.
There are several types of testing. Unit testing in particular takes a separate component and verifies it behaves as intended when connected to an idealized (mock up) environment. Testing frameworks provide an easy way to manage, set up, describe and execute tests. Tests help you to *design* code, *verify* that it works as intended and ensure that changes you introduce do not break things. They also serve as live examples of use and reference documentation. Typically, tests influence the design of your components. When you begin seeing reduntant code in tests repeating over and over again, it may be an indication of an architectural problem in the tested code. In fact, the less coupling between your components there is, the easier it is to write tests. Some idioms (use of global identifiers or abuse of static methods and singletons) make testing difficult, but those are usually frowned upon regarding of testing. Tests are usually a separate code base in your project, and reside in a separate directory with special configuration and supplementary data required for the tests. 
Since your "repository" only contains data adding/setting/finding it isnt really a repository. It is more of a data layer between the model itself and the data management.
What else would a repository do that would miss from adding/removing/searching?
I'm gonna be straight: Linux or GTFO. I say this as someone who uses Windows as my primary OS - WAMP/MAMP/XAMPP are crutches. if (DEV !== PROD){ BadTime::begin(); }
Service (as in Validation) -, factory (as in saving, updating, creation) -, gateway mapping (DB, XML, JSON, ...), etc. Why im pointing it out in the first place is your second last code snippet, you illustrated a "repository" but in fact it is a model with database access. While a repository should remove db layer of the model. Sources come from different books on safaribooks.com, nettuts, msdna, laracasts etc. 
Wth...? I thought they were perfectly legitimate considerations, he was simply pointing out the pros &amp; cons. 
Do you're own homework.
Yea. I know. I use VIM. I have two shortcuts that sends the current file through phpmd and phpcs. It works for me )..
but way more uglier code. You shall not change codestyle for a tool to work properly.
Good grief I've never seen more FUD in a comment. Go read the Laravel tests directory. Have you? Probably not. If you had I don't think you would be implying I took it easy on testing. I write shit loads of tests on everything that needs to be tested.
&gt; Which you should. No, he shouldn't. The general guideline^1 is that you [don't](http://www.mockobjects.com/2007/04/test-smell-everything-is-mocked.html) [mock](http://jmock.org/oopsla2004.pdf) [code](http://stackoverflow.com/a/1906567/1031898) [you](http://lizdouglass.wordpress.com/2009/12/12/mock-objects/) [don't](http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html) [own](http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own/). 1. Guideline, not rule, use your judgement.
&gt; What you are describing is about the implementation of the repository. What my article is about is the interface. You shouldn't mix the two. I never said that, and no I dont mix the two, such things belong in to the interface, the implementation doesnt. &gt; Mapping objects to DB, XML, JSON, etc.. is a concern for the implementation, not the interface. The interface should be the same in any case. it is and should be part of the interface, i.e. `function getGateway();` &gt; When you say "saving, updating, creation", that's also a side effect of "adding" to the repository. It shouldn't be in the interface, and it is covered anyway by the interface I suggest (get and remove methods). if you mix adding and updating you do a single responsibility fail. Adding is only for adding but not updating. If you would call the method synchronize then doing both would be okay. &gt; Absolutely not, that's exactly what this is all against! The reason behind this article is to explain not to define methods like "find", "persist", "save", etc... but generic terms instead. ehm... have you read what you wrote on your blog? `extends collection` which forces to implement `slice`. Since all methods in a interface are public you could use slice on the repository which is a bit fail because a repository is not a data holder, it only returns data. I think you have a method/interface naming problem. 
&gt; 100% coverage is really a minimum, not a maximum. http://martinfowler.com/bliki/TestCoverage.html &gt; &gt; If you are testing thoughtfully and well, I would expect a coverage percentage in the upper 80s or 90s. I would be suspicious of anything like 100% - it would smell of someone writing tests to make the coverage numbers happy, but not thinking about what they are doing. [...] So what is the value of coverage analysis again? Well it helps you find which bits of your code aren't being tested. It's worth running coverage tools every so often and looking at these bits of untested code. Do they worry you that they aren't being tested?
&gt; I strongly disagree with this. What is the usage behind that? Where in DDD have you read that the user of the repository must be able to know about the backend used by the repository? The repository is supposed to abstract that backend, not expose it. I never read DDD and I never said I did, but I did read way more books about that than just DDD. The repository is the backend, it does abstract the backend for the model. The model should not expose any backend the repository should. &gt; If a repository behaves like an in-memory collection, then there is just "add", no "update". Updating is handled by the unit of work, just like Doctrine does. So in your opinion updating is equal to adding? You know what the word add means? &gt; Let me repeat the quote at the beginning of the article, from Eric Evans: Such a little quote can not, I repeat can not cover the full length of a paradigm. Also the repository doesnt behaves like a collection it creates it (Factory mapping). Let me quote something from the comments which is true: &gt; I think you're taking a far too literal interpretation of that particular phrase in the DDD book. When Evans describes a "collection", he is not talking as much about the implementation details of a collection (being an iterable instance), but more of a conceptual "collection" as a contrast to a single entity. -- &gt; Your point was: "you illustrated a "repository" but in fact it is a model with database access". How is slice about database access?? what should you slice without any data? A repository does not store any models.
&gt; Most of my day, every day, is spent untangling code in legacy projects not built with TDD and getting test coverage in them so I can make changes without unknowingly breaking stuff. I can imagine someone like that developing a deep aversion for code that is not maintainable, which you assumes to be synonymous with 'all non TD Developed code', which I am not sure is true.
ok. Thank you for the explanation. People don't check the code and try to learn self ;-) .
You guys, Laravel is dead!
Even "100%" test coverage is somewhat misleading, as that merely means that the code coverage calculator *believes* the coverage to encompass 100% of the execution paths, but it's not difficult to create unexpected execution paths in a dynamic language like PHP, especially when you consider the usage of functions like *call_user_func_array*.
http://i.imgur.com/HZRC63c.jpg
Nice to see an easy way to add some native code to PHP. This may sound weird, but I hope it doesn't get used too often in open source projects. It's nice for internal things, and for targeted optimizations though.
craziest thing ever I've witnessed happening to PHP!
Make your code readable and easy to follow. Anything else is fluff. Developers are the ones looking at the code and trawling through git changes, so it should be up to you guys what works best.
Is there any extension developer here that can somewhat objectively compare this to the "regular" extension development? Could this facilitate making wrappers for C/C++ libraries?
Well said!
I say: don't. It's useless whitespace and there is literally zero reason to do it. EDIT: If this is what you're new manager is going to do, talk to his boss _now_. This is not what a manager is supposed to do. He is supposed to make work easier for the developers, not implement weird rules that only serve to satisfy his neediness to put his mark on anything you do.
Where does he want to put those? What is his reasoning?
Yeah, but not all of them. You won't need copies of all the objects for testing even the most complicated of testing, nor would you need to use all the setters and getters for the more complex testing. If you are, then you're either testing the wrong thing, or you have a bad design on your hands. Either way, expecting 100% coverage is just going to lead to bad times, especially if it's a "forced" 100%.
Thanks for the headsup. For me it worked just fine on MariaDB/Fedora, but you never know when you need to support the alternative.
Nice how does it perform in comparison with zephir? 
*Your
Then in that context NULL and FALSE are pretty much equivalent. Obviously a user shouldn't have a falsy value for a username if they are logged in (and that includes 0, 0.0, "0", or "" as values.) Being overly specific can introduce more problems then allowing PHP's dynamic nature to work for you in a case like this, because if your code strictly checks for a FALSE and encounters a NULL instead it could incorrectly assume the user is logged in, and if it doesn't strictly check it then it would treat NULL and FALSE exactly the same anyways.
Because its easier for him to use the arrow keys to go up and down a line :-/. He refuses to try an IDE or editor that makes that easy and instead uses a simple text editor. This isn't his first interesting demand but I want to make sure I'm not the only one who thinks they're weird. 
&gt; Well my article is about DDD… it is about the repository interface &gt; Eric Evans is the guy who defined DDD. The quote is from the DDD book. So it's not really a little quote, it's the definition of a repository in the DDD universe. The repository pattern existed before DDD &gt; You are putting words in my mouth. I said "there is no update" in the repositories. The update is handled by the Unit Of Work which tracks changes. Not the repository. Once an entity is in a repository, that's it. You can only remove it… I think you are talking about the repository you find in distros, because you have to be able to update an entity. 
Well, `null` is explicitly for representing the lack of a value, so if a username or email property has no value (the reason doesn't matter), then `null` is the obvious choice. 
It all depends on the kind of interface you want. If you make it null, then you need to have null checks all over your code that makes use of your `user` object. If you make it a reference that returns falsy values for all of its' properties, you don't. It's a matter of personal preference, honestly.
The "regular" way involves familarizing yourself with dozens (hundreds?) of Zend specific macros, some C knowledge (i.e pointer manipulation, {,de}allocating memory etc.), but if you are at a point that seriously makes you consider writing an extension, it mostly comes down to preference. Personally, the C++ way seems cleaner, significantly less segfault-prone &amp; much more maintainable, but YMMV.
This looks fantastic! At work, we've been moving some stuff to extensions for better primitive type handling &amp; performance reasons and using C++ could make it much leaner &amp; enjoyable. **EDIT:** Kudos on the ***excellent*** documentation! I've been reading for the past 20 minutes and it's quite comprehensive.
The article is about the repository in the DDD universe. &gt; The repository pattern existed before DDD Once again: this is about the repository *in the DDD universe*. For example, an entity in Doctrine is not the same as an entity in DDD. There's no point in fighting with definitions, because the term has several definition according to the context. That's the same thing here. &gt; I think you are talking about the repository you find in distros What do you mean by "distro"? I'm sorry it doesn't ring a bell. &gt; because you have to be able to update an entity. Yes. The Unit Of Work handles that. Here is a random link that talks about it: http://www.codeproject.com/Articles/581487/Unit-of-Work-Design-Pattern#WhatistheuseofUNITofWorkdesignpattern
Null is a lack of a type. Imagine that the variable must always be of a singular type (an object instance of some sort, a boolean - true or false, or a string etc) and if there is absolutely no value, then null is the correct choice. Equally, in some circumstances, some types can be empty of their own accord, but null is a complete lack of a value or type. I use null to signify uninitialised variables, and I only use nulls when the variable is supposed to be an object reference. I hope this quick example highlights my point (wrote in a hurry, apologies for any mistakes): &lt;?php class Bar { private $something = ''; public function doSomething() { $this-&gt;something = 'do'; } } class Foo { /* @var Bar */ private $bar; public function __construct(Bar $bar = null) { $this-&gt;bar = $bar; } public function hasBar() { return !is_null($this-&gt;bar); } public function doSomethingWithBar() { if (!$this-&gt;hasBar()) { return; } $this-&gt;bar-&gt;doSomething(); } } 
Can we ban this stupid bot please? I'm seeing it all over reddit today and it is already annoying.
If you ban it, it skips your subreddit, if you don't want it posting here.
Strings should always be strings IMO, never null. I would never null a scalar as adequate validation is enough to call any scalar invalid.
Does that mean Python 3 is* backwards compatible with 2 ? Or does Django's source contain code (or a module) that separates between the two versions ? I'm not well versed in Python, but IIRC there was a 2to3/3to2 tool that "converts" code between the two versions. If 2 and 3 were compatible with each other, why would they make such tools ? These are all legitemate questions BTW, not trying to disprove what you said or anything like that.
53% is no where near 80-90%. 
I hope it does get used in some open source projects, but if and only if they provide it with graceful fall backs. Take that bubble sort example they provided on the website, if an open source project heavily depends on sorting large amount of data (should probably be dealt with at the database level instead of script level, but let's just say for example), they can check if the `native_*` function exist, and use that if so, otherwise gracefully fall back to the default sorting functionality. Then, users on shared hosting will still run as is, but users with dedicated servers/VPS will be able to take advantage of the extension code. 
I am sure you write "shit loads" of tests. I am not implying you are lazy or a bad developer. I am sure you are really great. By the way, what doesn't "needs to be tested"? Anyway, I hereby challenge you to run a code coverage tool on your code base (Laravel) and write tests for branches that don't have tests. Covering all branches is a minimum. Actual percentage is less important. Although, they often correlate. 
Are you referring something like this? function getThings(){ TAB TAB$things = Thing::getAll(); TAB$things = $this-&gt;sortThings($things); TAB TABreturn $things; } Where lines 2 and 5 basically contain nothing but the tab? My response would be that this is pointless. A better code standard would be to remove all whitespace from the end of lines. Most editors have this as a setting. It stops you having commits that accidentally have done the above, or have an invisible space at the end of the line as their only change. If you **don't** get rid of whitespace at the end of lines, doing what your boss wants to do is dumb, because it's a pointless waste of time. This sounds like bike-shedding to me. A strong opinion about trivialities usually masks a lack of actual subject knowledge. 
I'm going to cut through the politeness **you're** obliged to use: he's a fucking idiot. &gt; interesting demand lol, "interesting" indeed. Bonus points: Tell him to grow the hell up and stop being a muppet. Buy a soft toy... maybe a Kermit doll. When he starts saying dumb things, point at the muppet, then point back at him. Make sure it's clear what you're saying. 
You are absolutely correct. It is quite possible that maintainable code that was not developed using TDD exists. I routinely deal with legacy classes that are ~12000 lines long with lines that are 300-400 characters wide. I have no idea what the previous devs were thinking. I have spent entire days deleting unreachable code, commented out dead code, non-useful comments, etc, etc, etc. Sometimes...in a single file! It's absolutely ridiculous.
+1, definitely null. The only time I would use false is if it's a boolean value.
No...don't do that. Not OK at all. 
Yes, thanks that what I was asking about. 
On many occasions I have accidentally selected and returned the wrong private variable from the drop-down autocomplete list in my getters. My tests saved me in those cases. Getters and setters need tests. However, a getter/setter pair can be tested in the same test.
No, no they shouldn't. Trivial methods can be wrong (I have done it) and they should be executed in at least one of the tests of the test suite.
Your normal code almost certainly includes annotations if you're using PHPDoc, which you obviously should be. :)
Law of Demeter...learn it, love it, don't violate it. If you have to mock out Demeter violations, then add it to your todo list to fix. Choo-choo train code annoys they heck out of me.
Why not just setup the `date.timezone` inside `php.ini` and be happy? 
Seconded. Dev should mirror production as much as possible. I like to use [vagrant](http://www.vagrantup.com/) to achieve that.
Why? Because it shows a false test coverage report? EDIT: That might've come off a bit snarky, I'm seriously interested tho!
Why does he need tabs to make the current editor view go up and down? Does he not have a mouse? When you say simple text editor, do you mean notepad or TextMate/SublimeText? Sounds like an utterly moronic idea from someone who hasn't done a lot of actual programming...
=))
It's a CLI tool. Most people run it on a machine that hasn't had any PHP configuration done (a Mac OS X box for example).
This is absolutely correct. It should be held to a much, much higher standard. Since it is a foundational component, or aims to be, it should have a level of reliability close to, if not equal to, the language itself (PHP). 
This is correct and 53% is abysmal. 53% = Legacy Code
Testing every execution path is not a gimmick. It's important. Especially for a project aiming to be a foundational component (e.g. a framework).
PHPDoc is shit. No thanks. Would rather just write self documenting code and not work with idiots who can't work out what something does.
However, tons of hype!
Real developers use Notepad to write code! None of that fancy, girly "smart" stuff like SubliminalText and NutBeanies and what-have-you! Those TABs are NOT extra! They NEED to be there! When I'm using the arrow key on my keyboard - like a REAL developer - I want that cursor to stay in the exact same place on each fucking line until I hit the end of the cheese (that's end of the block for you WANNABE developers out there)!! In fact, I want TABs out to column 120 on every line! Then I can go scrolling annoyingly through the entire file without once have to use the left or right arrow keys! REAL developers know how to minimize keystrokes, ladies - fucking deal with it! Don't forget to delete any extra TABs at the ends if you add anything to a line, though! Anyone doesn't like this isn't a real developer and needs to go find another job where they're willing to cater to you morons!!
Agreed. My opinion is that BC is being broken by default as new (and highly useful) features are added to PHP. For example if I start using the new splat functionality with PHP 5.6 next month when released ( and I will) automatically my code has zero BC with PHP 5.5 and lower. 
you dont generate them?
If he requires coding standards (only!) for the reason of enabling him to use his editor, then he shouldn't even be reading the code.
It's for the same reason we don't turn warnings and notices off.
Well that is once again not actually code style, but they can be used in method declarations too - which is what I was recommending and what was recommend above.
Backwards compatibility is one reason why PHP is not dead. It's very important and a stroke of genius.
Taylor is old enough to talk and think for himself. 
Wow.
No, that's cool. It's fine to have opinions, we all do. I simply took issue with the way you stated it like it was a fact. 
Posting the same shit over and over again doesn't make you right. There is no error here to absolve. It is correct use of words. The word "facade" is not owned in this context by the pattern. At all. It is a useful descriptive word just like other useful descriptive words which by your measure would be routinely abused by programmers the world over (Manager, Adapter, the use of "View" to describe a template in the context of MVC, MVC itself.. the list goes on). Why you have made it your personal crusade to complain about "facade" is beyond me. But hey, maybe you are still worried about all that reteaching you are going to have to do for the next 20 years. I forget how difficult it must be, being such an authority on things as you. 
I'm not sure if I agree with that honestly. Warnings or errors are important for the correct functioning of a program, test coverage reports that have been intentionally turned off are not.
When you cover your app with tests you'll be mmocking the framework. So errors in tge framework will not be detected.
The case I was talking about was turning off code coverage for getters/setters that don't do anything funny to the rest of the state of an object. You can assume (yes, I'm gonna make an ass out of you and me!) that those function correctly. If not, something is going wrong in the PHP engine. As soon as the getter and setters do anything else but maybe cast a type, they should be tested and it should be covered. As always, I think, there are cases where this may be applicable. But be wary when using it.
wut
I am making a statement based on all decisions so far with Laravel. Including not using PSR-2. The obsession with comments lining up perfectly. All done to make code look as good as possible. Adding an annotation is ugly.
[Sylius](https://github.com/Sylius/Sylius) is a big one.
&gt; Posting the same shit over and over again doesn't make you right. No, being right makes me right. &gt; There is no error here to absolve. There is. &gt; It is correct use of words. It is not correct use of words. Within the context of software, the word Facade is misused by Laravel. What they call "facades" are in fact more like proxies. 
I'm an extension developer, I don't use C++ in order to do that, just out of personal preference, it's not actually any real effort to use C++ in an extension, I simply don't want too. http://devzone.zend.com/1435/wrapping-c-classes-in-a-php-extension/ I can't imagine a real use case for this; the problem is that if you are a person who already knows C++ then you don't require it. If you are a person that does not know C++ then you **definitely** cannot use it; the talk of "anyone who can PHP can C++" is just unrealistic nonsense, obviously. There is something to be said for the possibility of writing engine agnostic code using something like this library to abstract away the differences in implementation. However, I still question whether I wouldn't be better off just learning about the new engine, afterall it's not as if you couldn't share code between the engines you were working with anyway.
No part of PSR-2 says anything about making comments line up perfectly. :)
If only you were right... shame you're not huh? The word Facade absolutely, positively DOES NOT mean the facade design pattern. In any context. The word facade means this: &gt; noun 1. Architecture . a. the front of a building, especially an imposing or decorative one. b. any side of a building facing a public way or space and finished accordingly. 2. a superficial appearance or illusion of something Yes, the facade *design pattern* borrows the metaphor, but just because it borrows the metaphor doesn't mean other things cannot. The real question here is why the personal war against this one term given the sheer volume of terms which by your definition are commonly incorrectly used in software development.
This looks pretty good! A few remarks (for an actual implementation, might not be so relevant for this example): * When decrypting, the very first thing you should do is to verify the validity of the MAC and abort if it doesn't match. If you don't do this first you are very likely to run into side-channel attacks (e.g. if you had verified the PKCS#7 padding you'd end up with a padding oracle that completely breaks confidentiality.) * You are comparing the HMACs using `==`. Due to the quirks of loose comparison this might - with low probability - not work correctly (in particular when the hash turns out to be numeric). You should at least use `===`. However, the proper way to compare HMACs is the use of a constant-time comparison function, which will prevent timing attacks. (PHP 5.6 will have `hash_equals` for this, but you'll find userland implementations for this as well.) * To avoid having to explicitly specify two independent keys for encryption and authentication, you can derive both from a master key. Assuming that said key is already a cryptographic key (rather than a password or such) you don't even need to use PBKDF2 for this. Instead a simple construction like HKDF will do (really, just the HKDF-Expand step would be sufficient). Whether you want to derive or explicitly specify both keys depends on the use case. Also, I'd like to point out that the MAC isn't only added to make sure that the data wasn't corrupted. A MAC (or some other form of authentication) is needed to ensure confidentiality against an active adversary. Without the MAC the attacker might be able to decrypt a message through a chosen-ciphertext attack. (AES-CBC is not by itself CCA secure.)
This has got to be faster. I've compiled a number if things with Zephir and some of them aren't even as fast as php doing the same thing. Don't get me wrong, Zephir is still great.
Not sure where we're staying but I'll be there with a troop from Bemidji.
The [PuPHPet](https://puphpet.com) frontend is in SF2! The rest is an amalgamation of PHP, Puppet, Vagrant, Ruby, bash, Javascript, CSS. Oh god please help.
Let me plot that for you... http://imgur.com/7nsc4II Green is how long bubble sort takes as your list gets bigger, red is is quick sort. x = number of elements y = time
It's funny and stupid, plus you may be get used to it that you will use it even the project is not under your manager. 
[PageKit](http://pagekit.com) just had their first private alpha this week, and should be having a public release soon.
Giving your database credentials to a "phpmyadmin" site run by someone else? That sounds incredibly dangerous! O.o
Guess you are one of those not smart enough to write self documenting code and understand what a method does?
Correct - the OpCache has gone through quite a few bug fixes since initial inclusion, so if you are using it - going with a very recent PHP release above 5.5.5 would be a wise idea anyway.
\#facepalm That's all kinds of wrong!
There is an article somewhere, I believe written by Nikita Popov, that refutes performance gains by porting code to C modules. If I recall, you can lose out on JIT, opcode caching, and memory management. In plain-old PHP, opcode caching alone alleviates any pain points between the C-PHP abstraction. Just something to think about.
Thanks for your contribution to the community by the way.
Link you to what? What did the site do, and why would anyone enter their host and mysql login info? What are you asking for?
It would be a PHPmyAdmin login, on the login page it would have Host: host.domain.com user: usr_dasd password: password login Button
So if I make a site right now that looks like phpmyadmin, that asks you for you mysql host, username and password, you are willing to enter that for me? Is that really what you are asking for?
&gt; that refutes performance gains by porting code to C modules. For arbitrary code, this is true. But there are certain areas (like using [Protocol Buffers](https://developers.google.com/protocol-buffers/) for cross-platform communication) that doing it in C is incredibly faster and consumes much less memory (zvals vs. C primitives). &gt; In plain-old PHP, opcode caching alone alleviates any pain points between the C-PHP abstraction. The biggest pain (for me, YMMV) is not about opcode caching, but about strong typing. In PHP you never know for sure whether a variable contains an int, double, boolean etc. because every type can be cast to another type without even a warning. This is especially important when your PHP application is communicating with other, strongly typed languages. &gt; Just something to think about. Indeed! You should only write an extension if you *know* you have to. "This would be faster in C" should not be a valid reason on its own.
Thank you for your opinion and code sample.
I agree with this. I posted a crude benchmark test here where this happened: http://www.reddit.com/r/PHP/comments/1zssrc/need_help_with_a_crude_benchmark_regular_php_vs/
I'd rather have it be a Secure thing and not Phishing
Werd.
&gt; Sure, but this is what abstractions are all about: To enable you to focus on your code and avoid worrying about implementation details. If you can work with "a PHP variable" without knowing all the zval_* macros out there, isn't that a good thing? More importantly, isn't that a good choice to have? No, I don't think it is a good thing, the only tools we have to debug extensions and core code are only useful if you know what you are reading in the stacktraces they produce, and the lines of code those stacktraces point you too. &gt; Also, since when did "scanning a few headers with your eyes" become a substitute for proper documentation? Since PHP has existed, that's how you get to know it ... I'm not saying it is a substitute for documentation ... *this is the way things actually are* ... &gt; By your logic people shouldn't write PHP without Zend Engine knowledge because if/when PHP segfaults, they won't be able to debug it. Do you really think this is a valid argument? The PHP programmer is not at all in the same position; a PHP programmer that finds code that causes segfaults is not expected to be able to fix it, we have bugsnet, issues on github, and pecl IRC rooms; there are official, and less than official, but just as useful routes for that programmer to take. Before you get to the segfault, there are various debuggers for PHP that you can use to ascertain where in the code that you understand the bug occurs, which will be useful when you're reporting the bug, and may help you to avoid it while it is being investigated by someone who knows what they are doing ... So, yes, it's a perfectly valid argument, I think ...
&gt; This is especially important when your PHP application is communicating with other, strongly typed languages. How are you communicating? Wouldn't you typically use JSON or XML data formats? Can you not explicitly cast to what's expected when you build the actual response?
hey darkmag DONT do that, install the phpmyadmin in your own host, anything else is FAR FAR FAR from being secure ... most of /r/php would even argue that having phpmyadmin installed anywhere is an issue, so you should even consider putting an HTTP auth in front of your PHPMA i'd advise you to contact the support of the NOC where you have your mysql db
So use something else. It is working well for me.
I couldn't find their repository link anywhere?
&gt; How are you communicating? Wouldn't you typically use JSON or XML data formats? We are using [Protocol Buffers](https://developers.google.com/protocol-buffers/), which is a binary format that is much faster json encoding/decoding. Payload size is also incredibly smaller than json as unset values are skipped entirely and neither the type of the message nor names of the fields are included in the payload. The only thing that matters is the type and value of the fields. This provides significant bandwith &amp; performance advantages over json/xml. &gt; Can you not explicitly cast to what's expected when you build the actual response? Sure you could, but then you have to explicitly check, for each variable you cast, that data loss did not occur (because even if it did, PHP won't tell you about it). This very quickly turns into a noticeable overhead when you have hundreds of messages, not to mention increased boilerplate code and proneness to errors.
That's fine? This post obviously isn't for them, then.
Not exactly. Your 5.5 code will still run on 5.6. This is what BC is referring to. Upgrading shouldn't break your application.
&gt; Why not test everything thoroughly? Time, money and sanity. PHPUnit's code coverage is based on lines executed so that pretty 100% code coverage metric doesn't actually mean that you tested 100% of a SUT's functionality, just that you executed each line of code at least once.
Crossposted comment from the other thread: Some general pointers on that: - Look for a product to contribute to, based on stuff you (would) use yourself. Nothing more boring than writing code that you will never actually use. I can not stress this enough: DO NOT WORK ON A PROJECT YOU WILL NOT BE USING YOURSELF! You'll burn out in no-time, leaving the project with your half-baked contributions. - Get to know the product/project. Use it for a short while, read the code. - Know a bit about the background of the project. Read the manual, see if there's a FAQ, browse the issues on Github. - If you find a quirk yourself, see if it really is a bug, or if was done so by design. If you're not sure, open an issue on Github "I'm seeing [x], but I'd expect [y]. Is this right?" - If you find a bug, try to fix it. If you're sure you've fixed the bug, fork the project, and do a pull-request. If you're not sure you've fixed it properly, open an issue, explain your fix, and somebody will properly tell you if it's OK. - If the project has (unit) tests, be sure to add a tests that fails before your fix, and passes afterwards. Project admins will _love_ you for that. - No idea what to fix? Read the Github issues, see if there's something you could pick up. - If you're planning to do major reconstructing in a project, always get in touch with the project owners (via email, or a github issue). It feels pretty bad if you spend a lot of time doing something, and your change won't get pulled into the project for whatever reason. Prevent this, by asking if your proposed change is something that fits the project. Finally, a shameless plug: We can always use some extra help for Bolt. [website](http://bolt.cm), [github](http://github.com/bolt/bolt). Feel free to get in touch, if you have any questions. 
&gt; Zend Engine is almost present in every PHP installation in the world Yup, seems about right.
Just looked at your edit and it seems like you have fallen pray to our "great" user notes... the comparison function someone posted there doesn't only fail to be constant-time, it's actually much worse than `===`. The reason is that it uses the short-circuiting `&amp;&amp;` operator. I have now edited the note to use the following function (though the edit won't be visible just yet): function hash_compare($a, $b) { if (!is_string($a) || !is_string($b)) { return false; } $len = strlen($a); if ($len !== strlen($b)) { return false; } $status = 0; for ($i = 0; $i &lt; $len; $i++) { $status |= ord($a[$i]) ^ ord($b[$i]); } return $status === 0; } We definitely need to review the user notes in our crypto sections more...
It can be taken out. 
I've always wanted to try this out, but never had a need!
In the case of comparing MACs, I'd go for "double MAC" approach instead of trying to mitigate the timing side-channel from string (HMAC) comparison by using a constant-time string compare. It is simpler solution (alot less room for bugs and implementation errors) and you don't need any extra functions for it. https://www.isecpartners.com/blog/2011/february/double-hmac-verification.aspx
http://gifts4geeks.ru/bundles/elephant/images/big/php_elephant_3.jpg
The word Facade absolutely, positively DOES mean the facade design pattern in a software context.
But that's not what I'm making fun of.
I've been waiting for more than a decade for perl 6 to come out so I can start using it again. There was a lot I liked about that language when I was first starting out, but other languages (mostly PHP) have replaced it (mostly because in my professional career, which has included C#, PHP, and Java, so far nobody cares about perl).
You are really pasting your content from word in to your website? &lt;p class="MsoNormal"&gt;&lt;/p&gt; your markup is a hell, you dont even have `&lt;h#&gt;&lt;/h#&gt;` tags and you call yourself a talented developer while your contact/blog page is totally broken... 
"OK, let me get this straight: so you want me to add blank lines, and tab-them out to match the surrounding code? Hang on for a second... http://i.imgur.com/fYhaK3l.gif." 
http://gifts4geeks.ru/buy_php_elephant
&gt; it should have a level of reliability close to, if not equal to, the language itself (PHP). Yeah, if we are talking code coverage, I've got some bad news for you there buddy: http://gcov.php.net/viewer.php?version=PHP_5_6
Zephir was announced 7 months ago by the people who built and maintain the Phalcon framework: http://blog.phalconphp.com/post/57161129440/phalcon-2-0-the-future
yes I know it was, and I've been using it for 7 months. This is a repost and I'm saying it's because of the recent post about php-cpp
That's all well and good, but that wasn't Paul who was posting that. It was another user responding to a completely innocent topic with a worthwhile suggestion. I'm not even going to get into the whole facade / proxy thing. It's pointless php drama for the sake of it and completely irrelevant to this post. 
Aura's reputation is bound to its author and thus everything that mentions Aura in a good way gets downvoted.
Why I don't recommend scrypt: PHP doesn't provide bindings for it. 
Do you need the timezone in your script? If so, you should make them set it themselves as it should be done (which you could even prompt for instead of throwing an error). If not, it's just a warning.
&gt; The obsession with comments lining up perfectly. I got confused about this bit, seemed like you were blaming PSR-2 for that. Otherwise you're just saying: "Taylor has made a few choices that I like, so I can now speak for him and say that he would NEVER do this thing that he has not done so far, but maybe hasn't considered." If so, well, that is a weird thing to do. If there are methods that should not be considered in code coverage, then shoving one extra annotation line in with the docblock (which you hate but Laravel does use) then what is the harm.
Current stable is 5.5 @ 25.9%.
He want's to require it...? Stripping trailing spaces is normal but requiring spaces is, how do I put this? Really fucking stupid. Yeah. I think that's about as eloquent as I can make it. Try proposing an existing standard. There are lots to choose from, they are well defined, other people use them and while you may not agree with all of their decisions; they are generally sensible.
Controllers are by nature coupled to frameworks. Name them like you would name any controller class inside any full-stack framework. If you need to separate them, just place them inside different namespaces. Controllers are details of the application. Don't worry about details.
 &lt;?php if(filter_var($email, FILTER_VALIDATE_EMAIL)) // email is valid else // email is not valid 
From a pattern point this code may be decent, but from an implementation in Laravel stand point this is pretty bad.
Long answer: don't write your own regular expressions when better solutions are available in the php core library. Of course, for educational purposes it's totally okay to write your own regular expressions! 
Care to elaborate?
appreciate the feedback, shocked at how popular this is considering its my first attempt at blogging!
I'm not sure what you are asking, but it looks like the sender (did you mean sender, not recipient?) email address is your web server. The person filling out the form isn't emailing it to you, they are submitting it to the server and the server is emailing you. The code you posted doesn't look like it has anything to do with what is going on. All it does it validate an email address. It doesn't process the form input or send any emails. Or maybe I am misunderstanding the problem
**4F0A7E3A**: Where do I put the code? **prodigyx**: I will try to simplify it, client use my contact form on my website, I receive their email but their recipient email is u957631829@ srv17.main-hosting dot com so I can't really reply. **akaaceman**: How do I do that? 
Try this: https://github.com/ellisgl/GeekLab-XPDO (Shameless plug...) 
has anyone used keys to secure their api before?
Unfortunately, I'm dealing with a rather shitty code base and I'm leaving in a little over a month, so updating everything to work with another wrapper would be a huge waste of time.
I'm on the bus right now so can't be bothered to find the link, but ... Satis is what you're looking for. It allows you to run your own packagist like repository. 
Ah, you're saying the post is a response. Okay, I thought you meant the language as a whole.
You could setup a local mirror for the packages your project uses. Here's a how to: http://code.tutsplus.com/tutorials/setting-up-a-local-mirror-for-composer-packages-with-satis--net-36726
You can skip the if else and just cast the result as a bool
Are you asking for their email address in the form they are submitting? I don't see anywhere where you say you are doing that. When they submit the form you need to send the form data to yourself in the email or, better, use their email address as the "from" or "replyto" address for the email you are sending to yourself. 
Use the [PDO-Constants](http://de2.php.net/manual/en/pdo.constants.php) as third parameter, and PHP will cast the value accordingly. An arbitrary string for example would be converted to 0.
I already have PHPMyAdmin on it I just dont want to give my login for Cpanel away
What's the point of using a repository that returns a larval eloquent model? Don't you have to return a POPO or at least make note that whoever uses your repository should not use any methods from the eloquent model?
How are you sending the mail? Are you using a mailer class, like phpmailer or something else? If you're using phpmailer, set replyto via: $mail-&gt;AddReplyTo($email, $email); If you're using the regular mail(), stop and find a mailer class then come back to this.
Isn't everyone sick of this kind of posts? They seem to just be a copy of each other (not just for PHP, but also "Why Python?", "Why Ruby?", "Why grandma?"). I lost interest as soon as I ran into the "T_PAAMAYIM_NEKDOTAYIM" example, which I read about for the 23234723487th time...
You forgot some braces there. Let's not teach bad coding practices. ;-) &lt;?php if(filter_var($email, FILTER_VALIDATE_EMAIL)) { // email is valid } else { // email is not valid } 
If you must? There is no use case for that, and if you happen to think one up, rethink it, because you're wrong. If a framework you rely on expects you to do that, ditch it.
I have to agree with you on this point. I was reading the article and I could not just help but think "He is just blurting out the key talking points that everyone else is talking about". The article does not introduce anything new, it does not go in depth on any topic and is just a rehash of the current "hot" topics. But hey, I can't blame him, that is the best way to gather views and "upvotes". He does not even state an opinion, just that php is getting back in the race (who does not know this already?) and that you should make your own choices/research. TL;DR; You gain nothing from reading this. No new information is introduced in this article, which seems to be a trend.
You can still gain some testability by wrapping it that way. Lets you inject a mock repository into a consuming service instead of making Eloquent ActiveRecord calls directly in the consumer.
The point of repositories are ofcourse to return things in the same format regardless of source, you make a great point that the eloquent model would only be specific to that data source, a POPO would definite work a lot better in the long run. I'll update this article to reflect this, cheers!
Hey, you forgot _not_ to start a coding style war. Let's not teach bad social behaviors. =)
After 10 months of work with over 200 fixed issues, the next minor release is finally here with lots of improvements! [Full list of Changelog](https://github.com/zendframework/zf2/releases/tag/release-2.3.0)
What sort of keys? In general keys are a great and simple way to restrict things without having to go the whole hog of OAuth 1 or OAuth 2. If you use SSL then its not exactly that crackable, but you'll want to rotate keys now and then.
So this is meant to be genuine feedback not a complain fest, but it seems to miss out on a few things that I think are key. 1. SSL is rather important 2. OAuth 1.0a is a bitch to implement compared to OAuth 2.0 3. That package is old as fuck 4. That package is not on Composer 5. This does not show how to actually secure your REST API: * Where does the API client put their token to authenticate a request? * How to respond to a shitty token? 6. What is HMAC SHA1? 7. What is a signature? 8. Why did you pick 2-legged over other options? 9. What scenarios is this article approaching? All APIs ever? I don't wanna preach but I care about people learning how to build APIs, and things need to be explained better than this currently does.
Using `prefer-dist: true` helps. Statis is great. Something does need to be done about the uptime though. Not sure how the community can help.
http://www.mdswanson.com/blog/2013/10/14/how-not-to-validate-email-addresses.html Validate via email confirmation. Trying to test if it looks valid will fail! 
Simply fork them (if they don't already exist) on Github. { "require": { "username/my-repo": "dev-master" }, "repositories": [ { "type": "vcs", "url": "git@github.com:username/my-repo.git", "packagist": false } ] } Satis is a little complicated for your simplistic needs, but it would also work.
I don't care. For one, the title says "two way encrypted passwords and credit cards". If I ever catch you doing that, and you're not currently employed at a bank or payment processor, I will hunt you down and beat you to within an inch of your life with the thickest manual I can find on my way there. Those two things... Passwords, if you store those in a reversible format, a breach of your cooking-with-grandpa site is not just a nuisance for you, it's another leak of mappings between real-world-in-use-passwords and users, and you've not even gone through the trouble to make it hard. Credit Cards? If you have those in your database you're probably already doing something illegal. There is no god damn use case for anyone to have that kind of information lying around, and certainly not in a reversible format. Banks and payment processors, that's it. You, and everyone else, keep your filthy hands off. Store emails and other junk in whatever format you like, I don't care.
That would be really nice. I'm looking forward to reading it.
This, though I at least validate it contains @. Because as far as I know of, at the very least the email will have one.
i struggled with this before until i realized that if you want client code to be ORM agnostic you better be interfacing your models along with everything else. I don't know why it took me so long to realize that. You shouldn't be using Eloquent's use of `__get` and `__set` if you want your client code to be completely oblivious to the ORM. By interfacing your models, mocking them in tests becomes trivial and IDE code completion works! interface Person { public function getName(); public function addSibling(Sibling $sibling); public function getSiblings(); } class EloquentPerson extends Eloquent implements Person { protected $table = 'people'; public function __construct($name) { $this-&gt;name = $name; } public function getName() { return $this-&gt;name; } public function addSibling(Sibling $sibling) { $this-&gt;siblings()-&gt;attach($sibling); } public function getSiblings() { return $this-&gt;siblings; } private function siblings() // &lt;-- PRIVATE or PROTECTED { return $this-&gt;belongsToMany('Person'); } } You'll need to ditch the `save()` method too since that stinks of ActiveRecord. Do all your saving through repositories. $personRepository-&gt;save($person). Typehint your model interface in the `save(Person $person)` method.
What is the code that you are using to send the mail? 
The answer is to run a local mirror. This is why "how do we do signed packages?" is an important question.
I think what you are looking for is //Appears to come from the webmaster ini_set('sendmail_from', WEBMASTER_EMAIL); or //Appears to come from the person submitting the form ini_set('sendmail_from', $email); This is assuming you are using the mail function (which you will want to make sure you are using the correct headers also) mail($email, $subject, $body, $headers);
This is true, but I would go absolutely no further than that on strict checking. The email confirmation will handle this. If they get the email then the address is valid. 
That's..interesting! I will dig into it for sure. I appreciate it!
This is how I do it $sanitizedEmail = filter_var($email, FILTER_SANITIZE_EMAIL); if ($sanitizedEmail != $email || !filter_var($sanitizedEmail, FILTER_VALIDATE_EMAIL)) { //email is not valid } else { //email is valid }
*&lt;?php // To define("WEBMASTER_EMAIL", 'test@test.ca'); ?&gt;* that is the code in my config.php. I don't know if you talking about that one. this is my contact.php code: *&lt;?php include 'config.php'; error_reporting (E_ALL ^ E_NOTICE); $post = (!empty($_POST)) ? true : false; if($post) { include 'functions.php'; $name = stripslashes($_POST['name']); $email = trim($_POST['email']); $subject = stripslashes($_POST['subject']); $message = stripslashes($_POST['message']); $error = ''; // Check name if(!$name) { $error .= 'You forgot to enter your name!&lt;br /&gt;'; } // Check email if(!$email) { $error .= 'Please enter your e-mail address.&lt;br /&gt;'; } if($email &amp;&amp; !ValidateEmail($email)) { $error .= 'Please enter a valid e-mail address.&lt;br /&gt;'; } // Check message (length) if(!$message || strlen($message) &lt; 15) { $error .= "Please enter a message of at least 15 characters.&lt;br /&gt;"; } if(!$error) { $mail = mail(WEBMASTER_EMAIL, $subject, $message,"X-Mailer: PHP/" . phpversion()); if($mail) { echo 'OK'; } } else { echo '&lt;div class="notification_error"&gt;'.$error.'&lt;/div&gt;'; } } ?&gt;* my feedback.php code: *&lt;?php include 'config.php'; error_reporting (E_ALL ^ E_NOTICE); $post = (!empty($_POST)) ? true : false; if($post) { include 'functions.php'; $name = stripslashes($_POST['name']); $message = stripslashes($_POST['message']); $error = ''; // Check name if(!$name) { $error .= 'You forgot to enter your name!&lt;br /&gt;'; } // Check message (length) if(!$message || strlen($message) &lt; 15) { $error .= "Please enter a message of at least 15 characters.&lt;br /&gt;"; } if(!$error) { $mail = mail(WEBMASTER_EMAIL, $subject, $message,"X-Mailer: PHP/" . phpversion()); if($mail) { echo 'OK'; } } else* and my function.php code: *&lt;?php function ValidateEmail($email) { /* (Name) Letters, Numbers, Dots, Hyphens and Underscores (@ sign) (Domain) (with possible subdomain(s) ). Contains only letters, numbers, dots and hyphens (up to 255 characters) (. sign) (Extension) Letters only (up to 10 (can be increased in the future) characters) */ $regex = '/([a-z0-9_.-]+)'. # name '@'. # at '([a-z0-9.-]+){2,255}'. # domain &amp; possibly subdomains '.'. # period '([a-z]+){2,10}/i'; # domain extension if($email == '') { return false; } else { $eregi = preg_replace($regex, '', $email); } return empty($eregi) ? true : false; } ?&gt;* 
I could favor using a sledgehammer, but it doesn't mean shit for loosening a bolt. If it's a personal project, I'm using Ruby. If it's something I want to run on 82% of web servers and on some shared hosting environments, PHP all day. http://w3techs.com/technologies/details/pl-php/all/all
Right before this line in both files if(!$error) { $mail = mail(WEBMASTER_EMAIL, $subject, $message,"X-Mailer: PHP/" . phpversion()); you want to put ini_set('sendmail_from', $email); I would also suggest changing the parameter `"X-Mailer: PHP/" . phpversion()` to a `$header` variable. This way, you can add the following (or customize however you want to) $headers = "MIME-Version: 1.0\n"; $headers .= "From: ".$email."\n"; $headers .= "Return-path: &lt;".$email."&gt;\n"; $headers .= "Reply-To: ".$email."\n"; 
Totally fair points. The aim wasn't to be an authoritative guide on how to build an API, more a simple example of how to utilise OAuth. Perhaps that's a failure on my part to make so many assumptions. Other examples I've seen using OAuth are complicated, and as you say, "a bitch". The 2-legged system that I've described solves the essence of the problem in an elegant way. One of the reasons is that much of the complexity is abstracted away by the OAuth library. -- you don't need to worry about tokens at all. 
You really should keep posting these wonderful articles. I really enjoed it. I just added your blog to 'Visit daily' folder :). Thank you for the update. I will read it tonight! 
You simply shouldn't use `composer install` to deploy in production. You shouldn't rely on any external service to deploy. What if Github is down and you want to deploy? Same problem. You should instead generate an release locally (i.e. git checkout, composer install, …) and then deploy that release to production. You should also anticipate creating the release so that you are not stuck at the last moment with Github or Packagist down (for example autogenerate release each night?).
Well HHVM doesn't include ZE, so that's really about right
Perfect, a use case. I'm not saying PHP doesn't have it's place, all I'm saying is it's probably a bad choice in most cases.
Yep. You can then add that same string to the header variable if you wanted. Just as an fyi, although this is one way to send an email for a simple contact form, it can become spaghetti code very quickly. There are other ways of getting to the same result which would probably be cleaner, but this is still a fairly simple way to implement the functionality.
PHP over Java for ease of use? Yeah I can agree with that. But why not Node or Ruby if that's what you're looking for? I'm not just some new age evangelist either, I used PHP for over 5 years. But to me, having a globally recognized package manager has done more for my development time than any other feature of another language. 
Thanks for getting back to me. I know it wasn't "an authoritative guide on how to build an API", thats tough. I've been writing a book on that 24,818 words I still have a lot of work to do. Sadly your title and what you actually delivered do not match up. This is some snippets showing how _part_ of one OAuth 1.0a process. The expectations could be lowered, and the delivery could be stepped up. Meeting in the middle would be perfect. :)
"in most cases" is a gross overgeneralization. What is most cases? * Company has an ecommerce website to sell shit. * Company only wants a blog to maintain an online presence. * Company starts a new product that will be hosted on customer's servers. * Company starts a new PAAS. In which of these would PHP be a bad choice? If you're creating some game that requires real-time interaction maybe PHP isn't the correct choice. If you're doing some low-level stuff like creating VMs ala Vagrant maybe PHP isn't the best choice. If you're crunching massive amounts of numbers Python offers better libraries for that. However, in the current market those use cases are far outnumbered by PHP, which can scale much easier, faster and better than either Ruby or Python.
Oh, you can definetely do a lot better. I just enclosed the code someone posted in a function to answer the "where do i put the code" question.
Blah blah blah
Thank you Taylor. Yes, one of my friends (Laravel fan) mentioned that you suggested to return an array in your book. I was wondering how I would handle relationships if I return an array... anyway, I too actually use Eloquent model in my repositories (I love Eloquent :) ). I was just curious why all of these repository pattern tutorials always forgot to mention that a repository pattern should/can be used with a POPO. 
Take all 3 into context, not just one. Adding more servers to a PHP application is *much* simpler than either Ruby or Python.
this approach is pretty similar to how most AWS APIs are secured
&gt; Company has an ecommerce website to sell shit. Use a language with decimal support. &gt; Company only wants a blog to maintain an online presence. Literally any language can do this, it just so happens that WordPress is a popular one that happens to be built in PHP. Even then I'd say the fact that it's built in PHP is only a detriment to its ease of use - mind you, being written in PHP was also critical to its success. &gt; Company starts a new product that will be hosted on customer's servers. If they're real servers then you'll have no problem using Node or Ruby, which are dead easy to install. PHP may be on a lot of servers, but that's a pretty awful reason to pick it over something that's going to do the job better.
&gt; Use a language with decimal support. http://www.php.net/manual/en/book.bc.php &gt; Blog A company that only wants a simple online presence will want simplest thing to use. Guess what would win? &gt; real servers You may be the first person I've ever heard say a suggest creating a distributable paid app written in Node. &gt; do the job better Good developers do the job better, not simply the language chosen.
Isn't using 'composer install' on a production system a bad idea? What if you get a new version of a library you haven't tested your app against? You should use 'composer install' in dev and move it all to production when you release.
You're thinking of composer update. Composer install uses the composer.lock file and will get the same versions everywhere you run it.
yeah but why would you
I tried ad its not working. When I test the contact form, I still receive the e-mail but I still get the *u957631829@srv17.main-hosting.com* in the recipient name.
http://framework.zend.com/blog/zend-framework-2-3-0-released.html
The array was just as an example of a something _other_ than Eloquent. If you're wanting to go full-on "backend swappable", you might be better suited using something that supports POPO entities in the first place like Doctrine. Since the Laravel authentication stuff uses a `UserInterface`, it is easy to plug in another ORM.
&gt; A company that only wants a simple online presence will want simplest thing to use. Guess what would win? Blogger.com? Or maybe you write your blog software as a PaaS. Those are both simpler than using PHP, and PHP would be a bad choice in either of those cases. &gt; You may be the first person I've ever heard say a suggest creating a distributable paid app written in Node. Why do you sound so surprised? Node is more portable and less fragmented than PHP. &gt; Good developers do the job better, not simply the language chosen. It's true that a good developer doesn't blame his tools, but you also don't see mechanics using knives as screw drivers.
Agreed, I would rather composer install locally, have everything in version control, then just git push (with hooks) to production.
&gt; PHP is a strange and (let’s get it over with) ugly, little language. Damn no, mate! PHP is beautiful!
I'm not sure if I got everything right, but it seems to me that the only thing is gonna work for you is writing your own exceptions and throwing them in validation before you bind. Remember that even though PHP has come a long way it still lacks a lot of everything compared to java or even python. It wasnt till 5.2 or 5.3 that they actually implemented a DateTime object. (I remember telling that to a friend who does C/C++ and he laughed his ass off) PDO is part of this long-way-coming, but it is the first OO implementation of a database layer. You dont have to escape EVERYTHING, but it seems that you have a use case that needs more than PDO is prepared to offer you.
If you don't want any implicit type-casting to occur in PHP or at the database level, then just do your own type-checking: class MyPdoStatement extends \PDOStatement { public function bindInt($param, $value) { if (!is_integer($value)) { throw new \InvalidArgumentException(/* ... */); } return $this-&gt;bindValue($param, $value, \PDO::PARAM_INT); } // etc... }
You have my comment around the wrong way. If I use *new* PHP 5.6 features in a codebase, they will *not* run on 5.5 or below. 
I'm sorry, but for the type of service this application provides I feel like the implementation is lacking from a security/privacy perspective (especially since you mention that the NSA can read your gmail). I skimmed your code and noticed that the e-mails themselves are stored in plain text. Here's the logic problem: You're "protecting" their gmail password to avoid a hacker gaining access to their gmail account and emails. But...if I'm a hacker and want access to their emails, I could just target your application instead - after all, you are storing that data unencrypted in the database. A potential example: If I want to steal someone's domain, I could initiate a transfer from a new registrar, wait for the confirmation email to make it to target, end up in your database, pull the auth code/links from your database and...well, you know the rest. But let's tackle the real issue at hand - you're storing my gmail password using reversible encryption (and even mention doing this with Credit Cards). One thing I didn't get in to in your application is whether it supported multiple users - and if it does, then I'm going to yell even louder because you're encrypting every user's password with that same, single key you're storing in an INI file. So...really, all I need to do is compromise your application or web server and now not only can I decrypt ALL user's passwords, I could just take a dump of the database and take my time doing whatever I want on my own system. Really, I'll be in and out of your server in a few minutes. But putting all of that aside for a few, let's say that your server is truly unhackable and the above will never happen. I'm still unhappy because you know what? Anyone with access to the database (you, for example, if you're hosting this on my behalf, or the server admin, etc etc etc) can read my email. I'd probably be more okay with the NSA reading my email than you. Anyway, my point is this: someone with access to the server (either rightfully or hacked) should NOT be able to read my private information, whether it's my gmail password OR my email. If someone manages to pull a backup from the server and has all the time in the world on their hands, they STILL should not be able to access my data. How could we do something like that? PBKDF2. In essence, you should encrypt all customer data with a key that is derived from the password they use to log in to the application. That key is never stored anywhere. This means that when the user logs in, assuming their password is valid, the PBKDF2 algorithm is used to recreate a key which you can then use to decrypt their data and do whatever needs to be done. Since each user's data is encrypted with a key based on their password, even if a hacker manages to decrypt one user's data, the information gained is completely useless as far as decrypting other user's data. There's more to this exercise, such as how/where to actually store their encrypted gmail credentials and use it to pull data from gmail. I'm out of time but the answer varies based upon the polling schedule and needs to be handled even more carefully. 
After validating the format, you can also check to make sure that the domain has MX records set to avoid junk like *sdsfaasdffasdfsdf.com*. /** * Check that MX records exist for the given * email address' domain. * * @param string $email * @return boolean */ function activeEmailDomain($email) { list($user, $domain) = explode('@', $email); return (boolean) checkdnsrr($domain, 'MX'); } Just keep in mind that it will add latency doing this lookup and if the service is down for maintenance or something then you'll get a false negative. There's also MailCheck, a great Javascript plugin for catching typos like "gmal" or "yhaoo". Here's a PHP port of it: https://github.com/kcassam/mailcheck
No. I am saying that Taylor makes choices to make the code look good. I know this because he told us. This change would not do anything but make code look more ugly and be to the benefit of people who are obsessed with things like code coverage. A good programmer knows what should be tested and tests it, he doesn't use some percentage to know if he is doing his job well. Someone who tests every little part of an application (this is different than a framework, but the people in this thread are those people) are doing it wrong. Here is an excellent talk on it that I am sure you have seen. If not watch it :) http://vimeo.com/68375232
There is hard coding of methods that could be abstracted out, specifically PokemonRepository::convertFormat. I assume this is to keep the tutorial more precise. **PokemonRepository**: The `__construct` method's first argument is of the type `Model`. This should be set to `\Pokemon`. Your `PokemonRepository` works with the Eloquent ORM and specifically the Pokemon object. There's no need to be vague about what this repository expects. Then name of the repository should be changed to reflect what it is an `EloquentRepository`, the complete name would be `Repositories\Pokemon\EloquentRepository`. Later down the line if you decide to switch to Doctrine or FluentQueryBuilder you could add those repositories `Repositories\Pokemon\DoctrineRepository` and `Repositories\Pokemon\FluentRepository`. Using `Pokemon\PokemonRepository` prevents adding in differing types of repositories. Also your getPokemonByName if branch makes no sense. $pokemon at the time of the if is an object and always will be. **PokemonRepositoryServiceProvider**: I think its better to include all model bindings into one service provider, but that's just a preference in my opinion. This should be changed: public function register() { $this-&gt;app-&gt;bind( 'Repositories\Pokemon\PokemonInterface', 'Repositories\Pokemon\EloquentRepository' ); } There's no longer a need to pass in the `\Pokemon` object Laravel is doing that for you. At this point, I think we delve into personal preference a bit. 1. I wouldn't have created a facade(there's not need for one). 2. I wouldn't have created a PokemonService If you're using class controllers you can do this: class MyController { public function __construct(Repositories\Pokemon\PokemonInterface $pokemonRepo) { $this-&gt;repo = $pokemonRepo; } public function pokemon($pokemonName) { $pokemon = $this-&gt;repo-&gt;getPokemonByName($pokemonName); return $pokemon ? $pokemon-&gt;name : 'Pokemon Not Found' } } Also all of this code is placed in `app/model`. I'm fine leaving the Eloquent objects here, but the remainder of your non-laravel specific code should be placed else where. There are more issues that I might update later.
I've recently done some parsing binary data with PHP and `pack()` doesn't even scratch the surface. I'm not sure why 32-bit integers are even referred to as "long". Those are just ints, or Int32s. How do you parse integers longer than 32 bits? Or shorter than 16? Odd numbers? What about outputting binary and hex representations for debugging?* Whoever designed PCAP seems a little bit crazy too. Why not stick with a particular endianness rather than providing a check number and forcing the consumer to handle both cases? \* Rhetorical. I know the answer, but the article could go in to more depth.
I'm not passing judgment on your tutorial (although I could) but on your implication that there is a case to be made for reversible encryption of sensitive information. Hurt feelings aside, we're out in the real world here and protection of sensitive information trumps your feelings any day, all day long. If you're ever faced with a use case that has you contemplate using a reversible cipher on a saved password, you are looking at a sure fire sign that that information needs to be supplied to your app on a login-by-login basis. Another tell tale sign is that the password gets passed on to a third party, removing the need for you to know it or be able to reverse it. If it were a password for your own site, a salt+hash would be the go-to method. Therefore I can say, with certainty, that your use case is wrong and you need to rethink it. If on the other hand, you're faced with using a service that has you supply passwords to it in plain text, which is what your replies imply you need to, that is a sign of a service that is not yet mature enough for public consumption and [these guys would like to know about it](http://plaintextoffenders.com/). And *"But, but it's over SSL, surely it'll be fine"* is not good enough. *The* rule of thumb when dealing with computer security is this: always assume an attacker is **you**, with the same information and access to the server. Make those assumptions and code accordingly. And finally, there is no such thing as an impervious server, the only thing the good developers have over the poor ones, is how long it would take an attacker to actually get to the data inside.
Yeah posting this in a php subreddit is kinda pointless.
That's awesome. We went with a slightly different approach. Instead of an interface for model classes, we created POPO's. Then our repositories use some skimpy Eloquent entities which get automatically mapped to our model classes.
Thanks for the thoughtful reply. You raise some excellent points. - The problem with IMAP is that it requires regular access to Gmail (unless you're using Google Apps and can use OAuth) ... so a password based encryption key isn't practical - unless you perhaps require the user to log in occasionally and generate a new temporary encryption key per user. - My OSS app - which is different then my code example posted here, does plaint text but only sender / subject (except in some scenarios)... if someone wants to, they can add code to encrypt these in the app as well - it's a feature I might add - I don't recommend hosting the app for multiple users for exactly the vulnerability that you mentioned. 
That sounds pretty awful.
Braces are really god damn important, actually, [in case you haven't been paying attention](http://www.wired.com/threatlevel/2014/02/gotofail/).
You're going to have to get used to the fact that, in the PHP world, duck-typing and auto conversion _is the norm_. If you want to break that norm, you will have to go our of your way to do so, not the other way around. (To be clear, I really wish we COULD have strict type enforcement sometimes, but c'est la vie, this is how it is for now.)
My thoughts exactly.
Fuck that. 
&gt;Credit Cards? If you have those in your database you're probably already doing something illegal. There is no god damn use case for anyone to have that kind of information lying around, and certainly not in a reversible format. For what it's worth some processors will let you store credit card information in a very limited way, and with lots of caveats. 1. The credit card information MUST be split up between two or more storage/transmission methods so a breach to one wouldn't expose all the data. 2. The credit card information MUST be strongly encrypted. 3. The encryption keys MUST be regularly expired/replaced. 4. The merchant MUST pass the highest level of PCI compliance. (This is a massive amount of work in and of itself.) 5. Credit card information MUST be deleted after the order has been processed.
It was definitely not what I expected, but I do have to say all the people I interacted with were very professional. I think this could be a viable option for someone living in a part of the world that has low rates to begin with (India, Brazil, etc.) - as long as they are okay with the (ridiculous, IMO) contract clauses - but I wouldn't recommend any experienced professionals in North America or Europe to bother with this.
&gt; So I wonder where I could find a default fpm/php.ini file? You won't - PHP FPM settings are in a separate file - usually under /etc/php5/php-fpm.conf or if in the source dist here (well, they are built from this template): https://github.com/php/php-src/blob/master/sapi/fpm/php-fpm.conf.in 
This is an opinion and does not contribute to the original question or answer.
If you're using a redhat variant of Linux it'll be in /etc/php-fpm.d/www.conf and you can adjust the settings by adding to the config. These settings override the settings in php.ini. Alternatively create an empty php script with &lt;?php phpinfo(); Or run php -i From via shell and see where it says your php.ini file lives.
I really enjoyed reading your article. I think you nailed down most of the problems. May be I'm missing something here. When you do $this-&gt;orders-&gt;findByid($orderId) in your OrderController, don't you get an instance of EloquentOrder? Can't you still call other eloquent specific methods? 
Just so we're clear, you replaced the $email in his example with $mail, which is the variable used in your code, right? 
We don't maintain packages for each distro, that's left down to the people in the community that use whatever operating system we are discussing ... Remi Collet does a nice line in RPM packages, but I'm afraid not aware of a debian package maintainer I can point you at. There's alien I guess, but I wouldn't .... I will ask around, it's never come up ...
Shouldn't the from address be from his domain to avoid the email looking like it's being spoofed? With the reply address being set to the email entered by the user, it should be replyable without worrying about the emails being marked as spam on his end (especially important in situations where the email is being sent to other users). 
Slightly offtopic, but can we expect PHP to become thread safe by default anytime soon? PHP 6 maybe? The reason I'm asking is almost every distribution out there ships non-zts builds only (for php and various extensions) and I don't think that will ever change unless PHP becomes thread safe by default and non-zts builds disappear completely. Such a change would also mean increased exposure, user base and more importantly, widespread deployment for pthreads which would really help with the "even zts php is not truly thread safe" impression (warranted or not) most people seem to have.
Um. Specify the version of the package you trust in the manifest?
Looking at what he was doing, he is sending an email from his server to himself and he wants to be able to just hit reply to the email which the user supplies. I've done this before with a specific subject line so I know that it came from my contact form (and not from the actual address). Since they all go to him, it shouldn't matter. Edit: Unless I'm missing something, which after reading what you said it sounds like I am. I also don't deal email scripts too often.
Well, we don't choose the defaults ;) It's down to package maintainers how they package PHP, the reason they do not use thread safety (although there are ts packages for the redhat distros I'm used to as a user and deploy too) by default is that there is a (small, but) measurable impact on the consumption and performance of PHP when built in thread safe mode. There exists a patch, prepared some time ago by someone else on the team, that allows zend and extensions to use native thread local storage, this practically eliminates the performance penalty and greatly improves the consumption problem as to make it negligable. I worked on this patch for a couple of days a few months ago and had it working (in unix, where I'm comfortable) perfectly. I lack the knoweldge to do the same for windows, but someone else one the team, Pierre Joye, did manage to get it working there. Writing code is easy, changing minds is another matter altogether, I have no idea how to do that, and have learned there is very little point in trying ... at least on your own ... PHP *is* a community driven project, it is the *only* thing that really drives it in any direction at all, left to their own devices the people voting on most RFC's would just sit about waiting to get older, there's only a few that really put in the effort of writing those RFC's in the first place ... I digress ... this is probably not what you want to hear, but in order to have a chance of being able to discuss integrating that patch and using it as the default, the community needs to get behind it first, whether that means using it, or ranting about not being able to use it after having waited 14 years for it to exist. There was some talk of PHP6 having support at the engine level to actually create threads in order to execute engine level tasks (this is mentioned in one of the recent RFC's on the wiki), I immediately said "I'll do it, if I can expose it to userland without an argument", the response was "no". In actual fact it would be completely pointless for the engine to have support for creating threads (for the kinds of things suggested), but I completely ignored my instinct to be sensible, and still got a "no" ... tasked with it, I wouldn't really focus on the engine being able to create threads (that's one call anyway :)), what I would do is remove (some of) the dated shared nothing architecture, the vm would then be no more suitable to run inside threads (it's perfectly suitable now), but it would be more efficient at doing so. I have no idea how to change minds .... Talking about the thread safety of PHP is a waste of my time, the facts of the matter can be found in the foreword of https://gist.github.com/krakjoe/6437782 The other option is, become familiar with (at least) the build processes of the software paying your bills ;) It's not very difficult to isolate an installation of PHP such that it does not interfere with the system installation, for a lot of use cases this is actually more suitable than overwriting your current installation of PHP with a thread safe one. Becoming even slightly familiar with the build process can afford you that luxury, in addition it presents an opportunity to actually choose how PHP is configured, stamp out the daft defaults, and is also worth 20 geek points ... 
My bad yeah... thought i linked the blogpost and not the changelog (thus my additional comment...) sorry ;)
Don't commit the dependencies: release ≠ repository A release could be a zip or a phar containing everything needed to run in production.
This seems to be the thing to do with Laravel these days, there are literally tens of blogposts being written about this. What I don't understand is: why not use Doctrine and be done with it? It just reeks of NIH especially since Doctrine can be integrated nicely into Laravel. Are people that afraid of another ORM? Here's a repo that can be of help for anyone interested: https://github.com/opensolutions/doctrine2bridge
If he's planning on using this for production, chances are, he'd want to test new versions before he implements them with his stack anyways. Additionally, it's worth note to specify that he didn't exactly set down parameters for the alternatives--so it doesn't matter how difficult it would be to maintain, it still answered his question.
What if your Internet breaks down? What if you locally managed GIT breaks or burns? What if ... you can´t prevent everything. And I would say, whatever you do is far less reliable than packagist is....
If you're using namespaces, how about: namespace Project\Admin\Controller; class SectionController .... class DashboardController .... etc. 
This is Taso, the CEO of Toptal. Yuriy, Thanks for not approving my comment on your site. Since I figured you might do that, I took a screenshot after it was posted in case such an action occurred. In the future, please seek attention not at the cost of others. http://i.imgur.com/SepC2nG.png And FYI, every single member on our team has a very strong engineering background. This slander is not appreciated. Best, Taso
Excellent response, thanks! I'm assuming the "no" came from the likes of Rasmus, Stas et al. but let's not go there :)
Yes. You're right. You will get an instance of EloquentOrder but you must be disciplined enough to only use your interfaced methods in your client code. This is where code completion really helps. You would just doc block 'findById' to return an Order interface and then your ide would let you know what methods on that interface exist because that's all it sees, which is what the client code should only know about too. 
you are right, there things you just cannot prevent. bad luck if a meteor hits your server but if you can prevent it you should at least think about it. you are either the guy who sits back and says "welp, packagist is down, can't deploy right now" or the other guy who can deploy nevertheless because he was prepared. you can choose who you want to be
That not what I meant, I meant that I would trust packagist to keep up way more than my own AWS server.
Strong engineering background, not looking at the code of the SAP. Yes, it checks out.
I hate the fact people do this, if your controller is within a namespace of 'Controller' there's no reason to append the word 'Controller' onto the class. One of the issues solved by namespaces is duplicate class names. Which is why in the 'olden' days you would of appended 'Controller' so your model &amp; controller would have different names. At least this is my opinion. namespace App\Controllers\Admin; class Users {
NULL = don't know. FALSE = no/bad/uhoh.
SPA. They actually did a livecode session with him as well as reviewing some other algorithm's he wrote earlier in the process. I think their approach makes sense. They already know he can code, so the real question was whether he could develop a robust application that handled whatever a user threw at it. Testing that application from a user's perspective rather than looking at the source makes some sense.
There is some logic behind this. When you need to import say a model and controller via you end up with two classes of the same name. You can alias them but I've never liked that approach. So I tend to use class Account for the model and. class AccountController for the controller class. 
thx man, but I'm on Ubuntu 12.04.
How many people are actually doing new model() in their controllers though? most frameworks abstract things anyway into facades/factories/di. I personally would write it like the example below, looking at the code 'Models\Account' that's a much clearer way to understand what the class is without any prior knowledge aswell. namespace App\Controllers; use App\Models; class Account { public function x() { $f = new Models\Account(); 
mail("example@gmail.com[1] ","hello from php!",**$msg**); You haven't defined $msg
If you want to extends your code separation and the rigidity of your business rules, you should have a look at Domain Driven Development. I seen a speaker talking about unbreakable domain which was a suprisingly easy method. Have a look at these slides http://verraes.net/2013/06/unbreakable-domain-models/ 
Very understandable that it looks like it adds more complexity than its worth, this implementation is more designed to the medium to large apps rather than a quick project you do at the weekend. Ok there are several reasons why (I think) you should decouple your code. The main reason for the repository is if your data-source changes, if all your logic is in your eloquent class (the standard laravel models) suddenly all this logic is useless. But if you have your logic across a repository and a service, you can swap out your repository to work with the new data source and your application wont be effected by the change. Obviously for most applications it is unlikely that the data-source will change, but its forward planning, protecting your app by separating the responsibility. Another way to think about it is you are filing your code in logical places where it wont get scrambled up with all other barely relevant code. By putting all your logic related to pokemon in a pokemon eloquent class, its hard to see specifically what accessors and mutators are about, or what relationships are defined. But if you put those functions in another class (say a service) you can easily look at your eloquent model and know everything about the table its dealing with (ish). I'm sorry if I haven't explained well, the article took two weeks to get the wording right, rather than a work break! If you want to discuss more, send me a message from my site and we can happily chat about pro's and cons
Just out of curiosity and for the sake of reddiquette, why is this beeing downvoted?
I'd disagree. Given enough time, an actual [monkey can code anything](http://en.wikipedia.org/wiki/Infinite_monkey_theorem), and just because it "works" does in no way vouch for the quality of work produced. But, I'll admit that I haven't run a service such as TopTal, and so I won't pretend to know the best methodology for finding talent. However, it seems counterintuitive to ignore the most substantive work example provided by the candidate.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Infinite monkey theorem**](http://en.wikipedia.org/wiki/Infinite%20monkey%20theorem): [](#sfw) --- &gt; &gt;The __infinite monkey theorem__ states that a monkey hitting keys at [random](http://en.wikipedia.org/wiki/Randomness) on a [typewriter keyboard](http://en.wikipedia.org/wiki/Typewriter_keyboard) for an infinite amount of time will [almost surely](http://en.wikipedia.org/wiki/Almost_surely) type a given text, such as the complete works of [William Shakespeare](http://en.wikipedia.org/wiki/William_Shakespeare). &gt;In this context, "almost surely" is a mathematical term with a precise meaning, and the "monkey" is not an actual [monkey](http://en.wikipedia.org/wiki/Monkey), but a [metaphor](http://en.wikipedia.org/wiki/Metaphor) for an abstract device that produces an endless [random sequence](http://en.wikipedia.org/wiki/Random_sequence) of letters and symbols. One of the earliest instances of the use of the "monkey metaphor" is that of French mathematician [Émile Borel](http://en.wikipedia.org/wiki/%C3%89mile_Borel) in 1913, but the earliest instance may be even earlier. The relevance of the theorem is questionable—the [probability](http://en.wikipedia.org/wiki/Probability) of a universe full of monkeys typing a complete work such as Shakespeare's *[Hamlet](http://en.wikipedia.org/wiki/Hamlet)* is so tiny that the chance of it occurring during a period of time hundreds of thousands of orders of magnitude longer than the [age of the universe](http://en.wikipedia.org/wiki/Age_of_the_universe) is *extremely* low (but technically not zero). &gt;Variants of the theorem include multiple and even infinitely many typists, and the target text varies between an entire library and a single sentence. The history of these statements can be traced back to [Aristotle](http://en.wikipedia.org/wiki/Aristotle)'s *[On Generation and Corruption](http://en.wikipedia.org/wiki/On_Generation_and_Corruption)* and [Cicero](http://en.wikipedia.org/wiki/Cicero)'s *[De natura deorum](http://en.wikipedia.org/wiki/De_natura_deorum)* (On the Nature of the Gods), through [Blaise Pascal](http://en.wikipedia.org/wiki/Blaise_Pascal) and [Jonathan Swift](http://en.wikipedia.org/wiki/Jonathan_Swift), and finally to modern statements with their iconic simians and typewriters. In the early 20th century, [Émile Borel](http://en.wikipedia.org/wiki/%C3%89mile_Borel) and [Arthur Eddington](http://en.wikipedia.org/wiki/Arthur_Eddington) used the theorem to illustrate the timescales implicit in the foundations of [statistical mechanics](http://en.wikipedia.org/wiki/Statistical_mechanics). &gt;==== &gt;[**Image**](http://i.imgur.com/sfkfQuc.jpg) [^(i)](http://commons.wikimedia.org/wiki/File:Monkey-typing.jpg) - *A chimpanzee \(rather than a monkey\) sitting at a typewriter. Given enough time, a hypothetical monkey \(or in this case ape\) typing at random would, as part of its output, almost surely produce all of Shakespeare's plays.* --- ^Interesting: [^Infinite ^monkey ^theorem ^in ^popular ^culture](http://en.wikipedia.org/wiki/Infinite_monkey_theorem_in_popular_culture) ^| [^Almost ^surely](http://en.wikipedia.org/wiki/Almost_surely) ^| [^Émile ^Borel](http://en.wikipedia.org/wiki/%C3%89mile_Borel) ^| [^Infinite ^Monkeys](http://en.wikipedia.org/wiki/Infinite_Monkeys) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cg1lull) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cg1lull)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
This is perhaps my biggest complaint about PHP: it lets you call non-interfaced class members. One day you'll work with someone who just happens to know the object is an instance of an Eloquent entity, make use of some Eloquent functionality, and down the line when you replace it with a different implementation, things will break. I wish it had some kind of "stricter mode" that would disallow it.
thx man! much appreciated!
Or, more feasibly, one repository per aggregate.
You meant mail server or mail transfer agent not client. 
Yuriy, I also just went through the experience joining Toptal and would be more interested in your story if you had approved Taso's comment on your blog and responded to him here. Why are you ignoring him? It makes you look bad.
This isn't an issue with PHP - this is an implementation issue. It's specifically why your repository shouldn't return an ORM specific model.
Sorry, you're absolutely right... not sure why i said client
Hi yuriyb, do you mind to share with us what was the rate you wanted ?
Still think most of the points Yuri made are valid. He's not saying that your clauses are bad, he just feels he's not into giving you those benefits from his work, which is valid. If you think that the rant is misleading, you could better post the contract clauses and explain the reason behind the ones that might cause concern to those who read Yuri's blog. Yuri says "there's a clause that says XXX" — and your answer is "yes it does, but only because &lt;reason not stated anywhere&gt;". I didn't find this or any bit of information related to this in your faq or other part of the site, so, why would you consider what he wrote a *slander*.
I have also been interviewed with toptal and I can say that they do ask you your rate (OP said this as well in his article).
Thanks to Whereareweheaded, I got it to work. To all the people who tried to help me, thanks a lot. 
nothing fancy, just using it for something right now.
thanks. I have a email plan through my godaddy hosting. I was getting emails but they were blank.
Hi NodeGuy. Some of us suffer from this rare condition that requires us to sleep during the night, so unfortunately I wasn't able to reply to Taso's comment when he posted it in the middle of my night. :) I just saw it and immediately replied. Cheers.
ok, changed $_POST to lastname / firstname and tested it. Got email but again, the data is missing. I thought "hello from php" was the message?.. grrr
You're not really helping your case. Try to take criticism and feedback with consideration and grace instead of lashing out. The former would have made me consider working with you despite OP's complaints. But since you did the latter, now I just think you're kind of a dick.
This thread has been linked to from elsewhere on reddit. - [/r/webdevnews] [PHP Weekly - 13th March 14 \[/r/PHP\]](http://np.reddit.com/r/webdevnews/comments/20bvzr/php_weekly_13th_march_14_rphp/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Send ^them ^to ^my ^inbox!](http://www.reddit.com/message/compose/?to=totes_meta_bot)* 
Taso, there is no "approval" process on the comments for my site. I do see the "waiting to be approved" message in your screenshot, but I have never seen that myself, nor have I ever had to approve a comment on my blog. I saw your comment publicly published as soon as I woke up this morning, and instantly followed up to it. There is no slander in my post - only facts of my experience. // edit - it's pretty funny that this comment is being constantly downvoted. I can guess by whom. My blog has never had comment moderation - everything is posted live, instantly.
Some sort of community-provided mirroring scheme could be good - I'm not sure how you ensure they're trustworthy though.
From Symfony [docs](http://symfony.com/doc/current/book/controller.html): &gt; The class name is the concatenation of a name for the controller class (i.e. Hello) and the word Controller. This is a convention that provides consistency to controllers and allows them to be referenced only by the first part of the name (i.e. Hello) in the routing configuration. Some frameworks use the concatenation for good purposes, such as guessing, like the ones in Symfony. But of course there are alternatives.
You're defended them, I though you were. Anyway, assuming you are a developer, how can you state "Testing that application from a user's perspective rather than looking at the source makes some sense."? As a developer, I don't really care about the UI. That is a designer's problem. You can't judge a developer from the perspective of the layouts/designs he is producing. That's like judging a designer for his driving skills.
Redditor for 2 hours. Only this post. Assume astroturfing...
The not closing the PHP tags was new to me. Is that something most people do? Has anyone actually had any problems because they closed it?
Php namespaces would absolutely confine author declared variables within a 'sandbox' if you will. Don't put the obligation on the author to define said namespaces however. When you import or store the submitted code, you need to generate (literally, as in write a new file to disk) an AuthorClass into which you can place the code, and at that point you can namespace however you like. If its long and convoluted due to procedural requirements in uniquely naming your name-spaced objects , you can just alias this namespace to something more convenient. Since your application will be calling this code, you'll need a class method somewhere to do the namespace translation when invoking these user defined methods anyway. Beyond that, it's mostly business as usual. 
have you read the function description on php.net? This should be your first thing to do when something with php is not working. [php.net mail()](http://de2.php.net/manual/en/function.mail.php) bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] ) you could do something like $to = 'my@email.com'; $subject = 'my very imprtant subject'; $msg = $_POST['lastname'] . " " . $_POST['lastname'] . " tried to send you a msg!"; $send = mail($to,$subject,$msg); if($send == TRUE){echo "mail on its way!";}else{echo "something went wrong!";} be warned this is not meant to be on a public server as this could be abused by everyone. and btw this subreddit is not the right place to ask for help, consider joining stackoverflow.com.
&gt; He says many things that are flat out untrue Could you give an example?
The whitespace character doesn't sound so bad, until it fouls up some XML and you suddenly break everything catastrophically. It's rare, but worth remembering for that one time you get stung
Yes. The company I work for once narrowly avoided breaking ourselves completely because one of the new guys ended PHP mode in a library he was writing, and then let some invisible whitespace creep in at the end. Anecdotal, obviously, but it's a real danger.
Interfacing entity looks nice at first but when you need to add business logic to it you can not which means you have created anemic domain model. That is why entities in DDD do not extend anything. 
Those slides are a bit tough to follow without the talk to give them context. Do you have a link to the talk itself by any chance?
Unfortunately not :(
Oh sorry - they are still in private alpha, working out bugs before a public release.
turning on output buffering globally avoids 'dangerous' breakage completely. but testing ahead of time catches this stuff too. Personally, I think people go overboard in arguing against closing tags. If that's the biggest thing you've got to worry about on a project, you're an anomaly.