I mean like `function fn_wrap($cb) { return $cb(1, 2); }` … passing a callback to fn_wrap which returns void would emit a notice even if the actual return value of fn_wrap is unused.
But would the inclusion of void *now* prevent that optional nullability from being added later? If so, how?
&gt; All in all, use the best tool for the job, right? 100% right. We are really facing the need to separate all this out and have had to already, so I can definitely see the need. Could you take a stab at time estimations per model? Did you find it like a chore to convert or fun? I think I need to spend some time on this before committing and getting my team on it. 
Some form of function references is still something I care about, but I don't think I'll be reviving that specific approach.
&gt; is compatible with the proposed 'nullable return types' and/or 'union types', void isn't. There's no incompatibility. `null` just slots in nicely because you'd have both `int|null` and `null`. `void` would ideally go alongside nullables, on the other hand. But it could also go alongside union types.
Apache 2.4 no longer uses "allow"
So is void. I don't really see the need for a distinction.
Wouldn't absolutely prevent it; would make it not fit in as well, and so less likely to pass, and be more confusing to use imo.
Underated post. Large files through readfile might trigger max execution time also. 
For the record, I am not a huge fan of the nullable RFC, but other people do want to be able to do: function findUserByID() : User|null {...} Which is not totally insane.
I believe it's common to instruct users to place a specific config file in their project with the expected format and a list of options available.
Being guilty of this, it still amazes me how many projects there are for solving the same problem :S
https://github.com/vlucas/phpdotenv
meow
Are you saying that you need to invent frameworks for every new project? In order to connect libs at all you need to put in some code to facilitate cooperation. Unless you waste heaps of time, that will always be opinionated, and likely restrictive... I was with you on some of the trade-off's theoretically, and for what it's worth, now composer is here and supports multiple versions for dep resolution, I couldn't give a flying F if you use a framework, or just make use of some code others have written, in fact today, I'd go as far as to say if you don't use a framework, you'll probably struggle to stay productive.
Okay, let me ask this another way then. Why should we use this library instead of one of the *countless* existing ones, including those that have significant community traction? Not being able to compare and contrast against what's already there is a problem, as it implies that you built this without research into problems others haven't already solved.
How popular/mainstream/widely adopted is .env these days? I know it's used in larger projects (laravel for example), but is this a generally accepted method for other, smaller projects or scripts?
Apparently the aerospike driver has a problem with 7. "The current release candidate has a bug with the persistent list storage, which is how we implement persistent connections. Hopefully they'll be able to fix it prior to 7.0.0." Any chance of a resolution in the next 14 days? Would really appreciate that for a project that I have coming up.
&gt; This isn't in and of itself bullshit. Well, some of it is. Single and double quotes are just as fast at runtime, but there's might be a compile-time speed difference.
I love the picture of elephants.
I believe the TL;DR is that PHP7, through OPCache, is capable of taking advantage of the OS's ability to allocate it memory in large chunks. This allows PHP to more efficiently access data in RAM.
&gt; Breaking backwards compatibility is not an issue since it's a major release. Shit junior programmers say. &gt; In every language Exception is the root class. Not including Java - http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html
"Anti-patterns considered harmful"
&gt; &gt; &gt; &gt; &gt; It seems to me the ParagonIE\Halite\Key and all its children do too much. I would consider extracting all methods that load/save/generate keys in their own class(-es). https://github.com/paragonie/halite/pull/20 :)
Laravel is missing a code generator like Gii, if you like Gii I suggest you go with Yii2
True, but when that meme came about there was a pretty significant performance delta (though still mostly into pointless micro-optimization territory). I'm fairly sure that issue didn't even survive into PHP5. Like most things in programming, many people will hear some idea and latch onto it forever, despite being flawed, outdated, or straight-up wrong. Everyone's favorite A Fractal of Bad Design post comes to mind here.
&gt; Breaking backwards compatibility is not an issue since it's a major release. &gt; Shit junior programmers say. lol :) Take a look at symfony and their upcomming 3.0 release. They got the courage the change things up that are not optimal, sure it takes effort, a good upgrade plan etc, but it's very beneficial, dragging along old stuff for ever and ever is just ridiculous.
&gt; Shared web hotels are down in popularity.
&gt; , in fact today, I'd go as far as to say if you don't use a framework, you'll probably struggle to stay producti You sound upset, your belief in using frameworks may be dogmatic, and now you suffer from this: http://youarenotsosmart.com/2011/06/10/the-backfire-effect/ That being said, I also prefer frameworks for _anything_ but the simplest sites. Even then, a framework is probably best. Ofcourse, it has to be a good framework, not Codeigniter for example, Rather write myself than use codeigniter lol.
Yeah, #2 is basically impossible with PHP 5 (and maybe earlier). The problem is this extension only allows one query to be performed likely for this very reason. I've tried it many times and could never get it to work even though I had a plain as day SQL injection vector.
They need to release this soon. Php is bound to die given the bad reputation it has gotten over the years
What OS are you using? It is absolutely 100% possible to run 2 different versions of PHP. You can even discriminate which version by virtual host, if you want to (so `localhost` uses 5.6, but `localhost:8080` uses 7.0, or something like that).
As a package consumer I've never needed to load tests of my dependencies. Why do you need it? If I want to run tests for a package, I will check out the package separately to install it and run tests.
Yes, you only need to encode the characters that have special meanings.
But it also states that you can encode the reserved that don't have a special meanings right ? I see a lot of implementations directly encoding the query string e.g rawurlencode($_SERVER['QUERY_STRING']), but it seems to me like an "easy way" isn't it ?
we really have to stop going for 5.3 compatibility in new php projects.
&gt; rawurlencode($_SERVER['QUERY_STRING']) The only case where you would perform this is if you want to pass the entire `$_SERVER['QUERY_STRING']` as a value to feed to another URI. In any other case don't do that!! Encode the key and its value separately then join them using the `=` and the `&amp;` characters if needed. Query strings are a key/pair value collection. Most [URI packages](https://packagist.org/search/?q=URI) handle this correctly. Just look at the first two pages in packagist website. 
What is its "feasibility feature"?
Thanks, I'm not sure if you understood my comments as I am pro-framework, and you seem to be too; but have a nice weekend
You don't have to encode anything except [?,=,&amp;], but always be careful to make a case for the specific API, maybe even endpoint you talk to! We wrote an API client requiring us to connect to an ASP (maybe ASP.NET, but it's old in any case) API, for an ERP system that wanted JSON params sent as part of GET (and it wouldn't work with POST). It also would not decode if "{" and ":" were encoded, but required all keys and values to be urlencoded, apart from the "@" character... Now we could have told the client that the person who wrote the API clearly had no idea about API's, JSON, coding, etc, but it was far easier to just rawurlencode the entire contents of the JSON keys and values, and swap the "@" back in. While not ideal the point is that various API's can have nuance and nuisance, and sometimes we cannot replace X; so we have to push forward with nuanced, or less than perfect solutions
It looks similar to fluentpdo for the simple stuff, which I tried and was pretty underwhelmed with. I'll keep an eye on this and may try it out sometime. It would be nice if you could pass it a PDO object instead of the dsn, etc to create a new connection if you already have one.
"Hmm.. That sounds like an interesting read." *Clicks link* "Yep, yep.. Makes sense." *Scroll* "Oh, god.. Pixie fetish crap in place of reasonable use cases and examples." *Close tab* Bruh.
Yes that goes without saying :) you don't want to double-encode your data
Be aware without any sort of validation of $_GET['jobid'], XSS is possible. acceptjob.php?jobid='&gt;&lt;script&gt;alert(1);&lt;/script&gt; You might want to use a check such as: $jobId = (is_numeric($_GET['jobid']) ? $_GET['jobid'] : 0; And do the check for if it's 0 in mail.php. is_numeric won't return true on only integers but it should be enough to stop an attack from a link with XSS in it.
I would be more careful before using `http_build_query` depends on you being 100% sure that all your clients are on PHP and exclusively using PHP `_GET` or `parse_str` to decode the data; Since you can not guarantee that I would suggest staying away of `http_build_query` and build your [own query builder](http://url.thephpleague.com/4.0/services/parser-query/). The example is taken from the league package but another popular package [guzzle](https://github.com/guzzle/psr7#function-build_query) does the same thing for the same reason to enable better interoperability with other languages.
I think you mean "use a 3rd party query builder" not "build your own". For 99% of situations, using `http_build_query` is perfectly fine.
Yes "use a 3rd party query builder" **or/and** be very meticulous around constructing your ongoing URIs.
I found it pretty fun but my idea of fun is often not some else's;) Let me see if I can find time to go through a model conversion use case this weekend and get it to you - I'll try.
Ask your company if they provide college tuition reimbursement, and enroll in a computer science program. You shouldn't strive to "become a pro at PHP" (whatever *that* means). You should strive to become an engineer.
Shouldn't intval($_GET['jobid']) work for this? It will always return an integer (as long as no object is passed). Couple this with a check against 0 and you should be quite safe.
Good call. This is what I usually do in my code. My apologies for being lazy with my original solution :(
Thanks for confirming. Lazy would have been writing *is_int($_GET['jobid'])* as a possible solution ;)
&gt; the problem I had is that I had to load all libraries framework use even though some functionality was not used How come? Composer usually just loads on-demand. Sounds like you've created a weird unnecessary abstraction layer on top of composer with your ini files. Also, for schemas, people usually use incremental migration scripts. Laravel's migrations work like this, for inspiration: http://laravel.com/docs/5.1/migrations
You get the same feedback pretty much every time you write/link to an article. We get that you like pixies, but your fetish is getting in the way of effectively communicating your ideas and work. There's an extremely good reason why the blog/employee/order/etc. problem spaces are so widely used in the tech community: they're universally understood, and nobody has to wonder what use-cases there are for this thing being talked about when the author is going on about faerie dust and moon beams.
I see some downvoting here. I would love to hear an argument as to why Laracasts is not an appropriate answer here. 
Pragmatic programmer written by Thomas Hunt, i have it right here on my bookshelf :) . I think you should read that one before 'clean code' i have clean code on my night desk, and im 4 chapters in, it doesn't have me 100% hooked :) ... I think that the pragmatic book series(there is alot) is all very nice, ive read 'practical vim', 'the pragmatic programmer' and 'the passionate programmer' and im going to read 'the healthy programmer' at some point aswell :) . i think they're all very recommendable. 
What does this have to do with PHP? Sure, Hack is fork/derivative of PHP, but it's still off-topic for this subreddit. Cheers! Edit: downvoted for speaking the truth, typical.
&gt; But shouldn't mklink do what it says? yeah in theory there is a windows workaround|hack for every thing it's missing from from Linux. It's just - it's way more pain to implement then it sounds. If I have 2 devs to hire: one uses linux box, one windows box -&gt; that's a losing battle for a win. dev.
I wouldn't call laracasts an online course. It's more tidbits on various topics for all skill levels. That said, I love it and JeffreyWay is my homeboy. Have an upvote.
You said it yourself. It's a fork of php
Damn I learn a lot from reading Hack blogs. The arrays containing references part was unexpected.
So? This article has nothing to do with PHP, but a language offshoot. Do folks post c++ articles in the c subreddit, or articles for Ubuntu in a CentOS subreddit? No, because it would be **off topic**
Code Academy? 
Cartalyst Sentinel comes to mind, it allows for easy integration for Laravel or native PHP apps [Cartalyst Sentinel](https://cartalyst.com/manual/sentinel/2.0#native) edit: should have read everything, yes Sentinel allows for integration without Laravel, you would have to follow the Native integration steps on their website
I will vote for sentinel, OP, you can build your own custom User/UserProvider/GroupProvider by implementing their interface
+1 for Sentinel. Quality stuff.
Forward slashes in trigger?
What's the point of it? What does it do differently than other frameworks? What problems does it solve?
Thanks for your replies, I also have the impression that phalcon is easy to install but I thought I was missing something ... 
The project is not new. It was started 2 years ago and it's in production since then. It was maintained and improved over the time, and it will continue to be maintained indefinitely. I posted my "new" project here, because I thought that it will be healthy for the project to have a larger user base. But unfortunately, it seems that nowadays it's not enough to have a documented open source project, you must also provide data, comparison tables and other junk that feed the trolls. 
&gt; Mint Mint KDE? I reinstalled ibus, much more loss of keyboard - like at least once an hour but at least very easily fixable just running ibus restart
Phalcon is problematic, because if there is a bug with it, how would you debug it? How would you fix it? If you use a PHP framework, you at least have an idea what is going on, while Phalcon is a black box. Sure, you can downloading the Zephir language tooling, debug that, recompile the extension... but you probably realize how this is a much more involved process than sticking to PHP code. For a lot of functionality we have no choice but fall back to a C extension, like working with sockets, processing low level data, working with images, databases. However Phalcon doesn't provide anything extraordinary that you can't do just as well in PHP. It's actually a very limited framework, compared to others. It has other problems too - the developers working on it have other day jobs, and they can't dedicate too much time to Phalcon. There aren't that many developers working on it, as well. Low bus factor. And because it's somewhat of a niche, it's less battle tested compared to other mainstream frameworks and the extensions that come with PHP out of the box. The benchmarks show a performance improvement with empty apps, but for real apps, the difference is negligible, unless you deliberately choose one of the heavier frameworks out there. I wouldn't say the admin has to "berate" you, but I have to agree that all things equal, Phalcon is a liability and it makes deployment and debugging unnecessarily hard, while providing very little in return, compared to a PHP-only framework. You'll see here people defending Phalcon, but keep in mind a lot of them likely adopt the viewpoint of a hobbyist and small site developers. When it comes to bigger projects, the equation changes considerably, and toys like that become unwanted. Can you name any bigger project running on Phalcon that's not run by one of the core Phalcon developers? I don't know of any. Here's a question for you: did you actually have a bottleneck with your previous framework? Did you exhaust all other options for optimizing performance? If not, you should ask yourself why are you using Phalcon in the first place.
egghead.io is an amazing resource for angular / all things JS
&gt;If your aren't using foreign languages Well, I am. I'm sort of "foreign" as in living somewhere in the "foreign" parts of the world and my people speaks a "foreign" language ;-) Anyway - I actually don't need ibus everything works fine without it. I installed it because it makes it easier to "fix" that issue with java apps (not isolated to phpstorm). Without ibus it happens a couple of times a week up to once a day and I have to restart the machine - or at least logout/in. With ibus it happens once or twice an hour but can be fixed with a simple command. So I've chosen ibus as the least annoying solution.
A long time ago I was using openoffice (which at the time was (still is?) heavily java dependent) together with another large java application. In some situations they shared the clipboard in such a way that if I had a large object copied in one application the other slow down to be unusable (apparently it was constantly updating or checking this object), I always had to copy like a single letter or something to solve it.
Yes. PhpStorm on Gubuntu 14.04. It occasionally happens. I end up killing Java and restarting. I've never lost work when doing this. I imagined it was a leaking memory problem, but I've never investigated to confirm. 
I just saw on jetbrains' website, earlier today, that for some of their products they deliver them with a special version of java for OSX
If you are having issues on OS X, try installing JDK 1.6, as described here. https://intellij-support.jetbrains.com/hc/en-us/articles/206827627-IDE-doesn-t-start-after-updating-to-Mac-OS-Yosemite-or-Mavericks That solved problems I had with font rendering when I upgraded to El Capitan recently.
in a Mac: brew install php56-phalcon
I have to disagree somewhat, on a couple of points but agree on others. &gt; how would you debug it? It's true you can't use xdebug on the framework itself but you can debug it the old fashion way, a bit more involved true but not that big of a deal. What I've done was to simply recompile phalcon with debug printout where I needed it, and eventually solved the issue. I had to run a slightly customized version of phalcon because the devs didn't like my pull request. That is now fixed, I still run a customized version because of another bug that is unlikely to be fixed - so there's that. It was pretty easy to fix and it's easy to keep it that way and still be up-to-date in general. I also regularly pull certain things out of my own code once it's stable and implement it in my own php-extension written in zephir. This is very, very neat. Deployment becomes a binary copied to the server. My goal is to implement a whole application as an extension, perhaps divided into a utility extension and an app-extension. &gt;at least have an idea what is going on Here I have the opposite experience, the phalcon framework is IMO extremely well thought out and much easier to understand than for example symphony. I'm talking about the core framework (zephir) code. It's very easy to go through that code and fully understand a full request/response cycle. The same thing is, in my view almost impossible in symphony (even when in phalcon you do it by eyeballing the code while in symphony you do it with xdebug) &gt;Phalcon doesn't provide anything extraordinary that you can't do just as well in PHP. I agree with this. It's just a framework like so many others. And I have encountered some deficiencies, especially in regard to databases, in general the ORM does not work well for me so I use it sparingly, mostly the connection which is just a thin layer on top of PDO and in some cases I use PDO directly because I believe there is (was? haven't checked recently) a bug or design issue that the devs denied existed. But OTH you can combine it with bundles and modules from other projects and your own implementations just like you do in other frameworks. For me the two main advantages of using phalcon is, as already mentioned, how easy it is to work with and fully understand, the other thing I like is how it hides away complexity that you shouldn't need to care about unless there is a bug, and also allows you to do the same with your own code (this last point is actually zephir related not really phalcon *per se*).
I have the same problem under Windows 8.1, it happens sometimes.....
&gt; he just doesnt want to be bothered with extra work Yeah, even if all his points are 100% true, this is still his main real gripe I reckon.
You have encountered a bug. I would recommend opening a bug report. What is quite likely to be happening is that there is something 'odd' about that particular file that is giving an error. In particular some devices/cameras are known to generate incorrectly formatted exif data. This is probably causing a segfault or other error in the extension. You might be able to generate a little more information by running a test script through valgrind, aka: valgrind php testScript.php But you almost certainly need to make a reproduce script, open a bug report, and make the problematic file be available so that someone can debug it properly.
I guess PHP removes the flag that makes a value a reference when its refcount goes down to 1. That would make sense but it makes arrays complicated (seems to me like whoever implemented it didn't realise that edge-case was possible). I think PHP7 might have fixed this since it handles references differently internally.
Ugh, this seems so complicated. I'd like to look to Hack for how we could do better array typing in PHP, but it seems Hack has loads of different approaches.
Another option to find a guy - codereview on stackexchange . Not sure if stackoverflow points can be seen as solid reputation though.
Down voted for speaking the truth? This isn't stack overflow. We're allowed to talk about things that are similar.
It's a bit of a weird issue. I'm running ubuntu 15.10 with a patched openjdk (for better antialiasing). I basic never run into this issue. My colleague who is running the same setup is running into it multiple times per day. I have no idea what the difference is. 
Have you tried the PhpStorm 10 Preview? I was having major issues with 9.0.x and 10 seems to have fixed all of those issues. Not sure if this bug is included since I've never been able to reliably duplicate it
Same happens for me on Ubuntu 13.x, 14.x and 15.x But all I need to do is put focus in another window, like google chrome. and then put focus back in phpstorm and then it's ok again.
Actually, I feel like PHP has a lot of original ideas – they are just bad ones.
On RHEL / CentOS / Fedora, [Remi's repo](http://rpms.famillecollet.com/) seems to often have Phalcon builds as well. Remi is the PHP package maintainer for Fedora and is active on php-internals.
Hack suffers from quickly adding a bunch of rushed alternatives to the same problems and keeping all the old ones. The result is a mess. What eventually both Hack and PHP need is what, ironically, PHP4 already had - a way to define pass-by-value objects. With classes, interfaces and all that good stuff. Swift is doing it, Java 10 will be doing it, and it's quickly becoming apparent that passing everything by reference is not all it's cracked up to be. References are great for "actor" objects which are implicitly non-cloneable, and often not serializable. They are entities and represent behavior. While values are... values. Anonymous, disposable, and passed through semantic copies around, because they represent state. State and behavior need different primitives, but they both need types, and interfaces, because types and interfaces are contracts. And contracts are useful for both of them as they help us enforce our code invariants. Things that we know we can't mess up by accident without the IDE and runtime complaining. Just vector and dict won't cut it. Vector and dict are a great start, but you need to be able to add restrictions and rules on top of that for a robust programming environment. 
 Sentinel distribution relies on [Composer](https://getcomposer.org/), a really useful dependency management tool. You if you are using Windows (WAMP), download the Windows version and install the binary (the CURL instructions are for manual and linux installations) and follow the instructions on [Basic Usage](https://getcomposer.org/doc/01-basic-usage.md), once you add the dependency and invoke composer it should download everything you need and set up an autoloader, then you follow the native implementation instructions of Sentinel.
Just use public instead of private. No need for magic methods. But personally I prefer immutable objects.
Depends on what your construct method looks like.
This might be related to the issue:[Ibus bug](https://youtrack.jetbrains.com/issue/IDEA-78860) Basically check the version of ibus you're running and use either of the workarounds suggested.
 class Person { public $name; public $address; } $person = new Person; $person-&gt;name = 'Harry'; $person-&gt;address = '4 Private Drive'; If you want to strictly replicate your c# example, there's no need for magic methods or getter/setters, just use public properties.
I'm fairly sure I've had the same issue on 4 different PCs running Xubuntu, Lubuntu, Linux Mint and Windows 8 respectively.
It's building a string that looks like `assert(eval(gzuncompress(base64_decode( &lt;a lot of code here&gt; ))))`. Nothing good can come of this.
Happened to me for the first time (OSX) a coupe days ago, then happened several times since. I switched between some other apps and it worked again. I assumed it was the recent java update.
If your hosting provider put it there they are trying to hack themselves and .. why would a Wookie be in the woods living with a bunch of Ewoks?
It's a backdoor. What's the hosting provider? You should definitely name and shame. Gtfo in any case. Here's the decoded script for anyone interested: http://pastebin.com/z4CXmwBc
It used to happen to me a lot on linux mint, as another poster mentioned it usually helps to switch to another program, then back to phpstorm and usually the problem is gone.
Thanks for that. I'm considering lumens, since Sentinel seems very difficult to integrate. With all the dependencies and nothing working I'll try lumens.
it's hostmonster. long story, but here's a transcript of the chat we had: http://pastebin.com/uFtkhtKb This file showed up AFTER they had told me to delete everything my public_html folder, which was after they had mistakenly deactivated my account, saying that I had a malware infection. When I replied with "You found that 15 minutes after I deleted the entire public_html folder contents?", The file was removed within minutes. I took screenshots as well. 
Depending on the traffic to the sites, it'll probably be cheaper to get an entire Virtual Host. Have a look at Digital Ocean, very reasonably priced, well known and plenty of tutorials on setting up a Linux server.
Part of the problem is that so many library devs put this in their composer.json: "PHP": "&gt;=5.3” Instead of "PHP": "&gt;=5.3,\\&lt;7.0” If that had been written that way, you could just try a composer install on a PHP7 VM to find out what isn't ready.
They're saying make the properties public, then you don't need methods, just use $person-&gt;name to access it.
There is no easy way. The best way is to use a PHP 7 VM to test everything you can. That is what we are beginning to do where I work and it isn't going to be fun.
It's obfuscated PHP code that seems to allow them complete control over your environment using a nice UI. Drop these clowns as fast as you can.
The low-hanging fruit is extensions that we know aren't supported. Following that, testing third-party libraries like PDF generators and so forth. Finally, what we actually do with most PHP version upgrades, is place one server running the new version in the production pool and just collect the errors. Maybe not the most elegant methodology, but hey, it works.
&gt;Here's a question for you: did you actually have a bottleneck with your previous framework? Did you exhaust all other options for optimizing performance? If not, you should ask yourself why are you using Phalcon in the first place. I basically tried a few frameworks (Slim, Laravel, Apigility) and I found Phalcon to be the most intuitive to me and the one with the lowest learning curve. They have good documentation and a generally an active community so I decided to go forward with it. Personally, I didn't consider the performance as the main reason for selecting Phalcon but just an added benefit. But I understand the concerns regarding the lack of full-time developers and not being "battle-tested". 
Can't recommend https://laracasts.com enough. Also check out https://www.codecourse.com/library
I used to work for them. this actually surprises me. Keep in mind that Hostmonster is also Bluehost, Fastdomain and Justhost. and iirc Hostgator SG
Except, in the c# example, name and address are fields with a getter and setter to a property of the same name. The property in c# is Inaccessible except through their getter and setter.
Zend is the worst I have tried, I think I even preferred codeigniter to it. The bloat is simply unacceptable.
Correct, and also very poor form. Writing out boilerplate accessors, while tedious, makes things much easier later on when you need to do testing, validation, and who knows what else. Go the super lazy route by writing a `__call()` method if you must, but public properties (or emulated ones) will almost always come back to haunt you. 
Big Wet Fish. Used to work for them and host my stuff there still. Great guys. Yes the name is weird but they're legit. 
There were several blocks of, basically, `eval(gzdeflate(base64_decode('...')))` One used `preg_replace('/.*/e', ...)`to do the eval, which was clever. I'd basically dump it to a file, replace eval with echo, and repeat. Lots of reformatting with some vim macros because it was a ton of concatenated 6-character strings and such. Always fun to type `200@a` and watch the file reformat itself :)
Personally I'm doing the toolbox subscription, it's cost effective for me and keeps me from having to license multiple ides.
Love me some linode. 
One concern I would have is concurrent access. I see you are using LOCK_EX for writing which is good, that means that the file should never be simultaneously be written to. However, the file can still be read while a write operation maybe on going. To avoid that potential issue it's usual to do the actual write operation to a temporary file then delete/rename to temp file to the original. This way the file will either not exist or will exist and should be valid and never container broken JSON. Another concern I would have, that you have already mentioned, is the trust worthiness of the file. Do you trust the file completely? Will other systems be accessing the file? Can you trust the other systems?
&gt; it's usual to do the actual write operation to a temporary file then delete/rename to temp file to the original. This way the file will either not exist or will exist and should be valid and never container broken JSON. Seems good method to do mate. ?Would do that. Regarding the another concern, I trust the file completely (regarding the data in the file), yes. Actually no one can edit the file (atleast not directly, theoretically ), the file is in a separate directory with 700 permissions but yet to have a concrete test. Anything to help me out with that?
Unlikely mate. Your backup was probably infected. I used to work in hosting and the thing about hacked sites is that they tend to get compromised again and again if the issue isn't sorted. Compromised sites can go months or longer before they start to show symptoms sometimes (think google blocked for malware, dodgy redirects on certain urls etc). I used to do as much of a cleanup as possible but you need to get someone who knows what theyre doing to take a look. What CMS are you using? WordPress? If so, you need to replace all the core files and your themes and plugins from fresh copies and link your database back up. You'll need to save your wp-content/uploads otherwise the paths to your media, but make sure you prevent script execution. You can do that using an .htaccess in that directory, for example set a mimetype for .php files to be parsed as plain text. I'm a little screwed up right now but I hope that helps. Happy Halloween, reply if you want some sober advice in the morning. Happy to help
&gt; In other words they're storing passwords in plain text. I agree with the sentiment of your post but this isn't necessarily true. They can easily check for a password match with one-way algos just as they hopefully do in their application's user-facing login interface. Not that they should be asking, of course.
You should probably consider your server compromised and migrate to a new one ASAP.
Thanks for the suggestions, happy halloween! Hope youre having fun. I really don't think it was an infected backup, and heres why- I didn't have any cms - WordPress or otherwise installed. A year or so ago I did, then got an email from hostmonstet saying that I had malware, account deactivated, etc. Oct 1 2014, to be exact. At that point I deleted the few WordPress installs I had set up, since i didn't use or maintain them, problem solved. Now fast forward 13 months to this morning, when I'm getting the same error message when I hit my site - including the date, Oct 1 2014. Except this time they didn't notify me, they just deactivated my account. I assume some glitch in their system. After almost an hour on hold, and a chat session where I ended up deleting - every single file and folder - in my public html directory, including .htaccess, including all the hidden ones, my account was reactivated. This is after I called them out on deactivating me without warning, both in the phone and in chat. See, all this I could live with, I'm not even using their hosting, only their domain services. It's the fact that within 10 minutes of him closing the chat session, I get an email saying "I found another malware, this file is hacked, please remove it" - and lo and behold there is suddenly a whole new folder named .config, and in it is the file I pasted above. There are no other files. Or folders. Just this one. After I responded with a statement on the implausibility of this file appearing, its suddenly gone. I don't see any explanation other than they messed up, and tried to cover their tracks. Call me paranoid :-) 
Sorry for using a term sanitizing without giving light on it. Basically, its a form, user will say, fetch me details about item "X". User can write in XSS / SQL injection like code. so what I have done is used html purifier for every insert / select parameters and using PDO prepare-&gt;bind-&gt;execute. I guess that was enough. Correct me if wrong, thankfully I can still edit the code and its not submitted to client. I would see about json_error(). Thanks for listing it. and yes about Code readability, I see what you mean, would edit that one per line as recommended. Thanks again :) Removing @. Agreed, will remove before submitting Edit : On searching json_error(), i got json_last_error() and json_last_error_msg(). Which one were you referring to ?
What makes you think they put it there? Why would your host put a back-door php script on your shared server when they control the servers? That's like a hotel owner breaking in to a room they have the keys for. It's more likely that some other application on your server was weak and allowed an attacker to upload a file and give it an executable bit.
Check your ftp logs and make sure you haven't got an old ftp account running like test and the password also being test. Ive seen that before 
2015 called, but apparently you missed the boat.
No it's not
You can use http://deploybot.com/ too.
This. OP got compromised, and whatever was compromised is still compromised and replacing the malware whenever it finds it missing.
Right. And common sense called and is asking you to realize that sometimes you HAVE to use ftp and this might be a useful tool for it.
Why not? I would say using git comes with a number of benefits over ftp. I'm not a php guy, but why would using git mean you would have to deal with other package managers? And why is this an issue anyway? Of course I'm going to have to deal with package managers if my new application uses a new package. I wouldn't dream of using this weird ftp/git hybrid thing that op posted. Just use git. 
&gt; How mad do you get when you have to remember which files you edited and select them on FileZilla to upload to the server? People still have this issue? Just use git and you will never have any issue like this again. 
I disagree in some circumstances. I understand where you are coming from, it definitely adds complexity and composer is a huge risk, but for relatively simple projects I think git is the perfect deployment solution. It also helps identify if someone (perhaps the client) has changed something that shouldn't have changed, and you can quickly automate a deploy through pushing to the remote. In more complex and critical circumstances a build process with unit tests, a composer install and building of assets (like SASS and JS pre-processing), migrating the result afterward, would be far better. But I guess that's why deployment and build automation is a whole industry itself these days, there's no one size fits all.
when did your version 3 come out? if only recently, why are you still supporting 5.3? it will help push the baseline of php up if projects stop supporting really old versions of php in their new and shiny releases.
He didn't give them his whole password, but only the last four letters. The only way to verify with *that* is by storing the password in plain text, or, if the password is hashed, by storing a second hash of only the last four letters of the password - which isn't really a good idea either.
We have just improved this feature https://github.com/coduo/php-humanizer/pull/51 From now its possible to pass forbidden words manualy.
I have a starred askubuntu question for this. I recommend discussing there. I had Ubuntu 14.04 first and now 15.04, default install and had ibus daemon pre-installed. I use the restart command like others had said. Perhaps you can run it in a 30 minute cron? 
&gt; to deal with other package managers? because usually third party dependencies are not stored in GIT index. That's why. When you do `git pull` on your server (or something similar, extracting archive from git export for example), you don't have this third party libraries or their versions may not match. In that case you'll have to run `composer install`or `bower install` or any other commands to sync dependencies. But if you don't have third party dependencies or they all managed via GIT, then yes, you'll be ok with it.
&gt; git is the perfect deployment solution it is perfect if you don't have anything in your `.gitignore` (except caches or something). &gt; But I guess that's why deployment and build automation is a whole industry itself these days This is part of continuous integration and continuous delivery. You could use just makefile/sh + tar to make shippable builds. Then test this build on staging server and then ship this tested build to production server. Things also getting worse if you have front end builds/postprocessing tools (autoprefixer it the most common example I think). Also there is tools like `capistrano` of `capifony` (I like [ansistrano](https://github.com/ansistrano) since I use ansible for server provisioning) to make auto deployment even much easier. I know that for most of the small project this could be a large overhead, but why don't provide simple tools from simple projects which works in the right way, so we can scale more easily?
Polyfills and transpiling are not alternatives to one another, they're complementary. You can't polyfill new syntax features for example (obviously).
Awesome, I semi-recently started working on a large project that for now only allows FTP access. It took 1 or 2 frustrating FileZilla uploads before I wrote a bash script that does what you're doing but a lot less elegantly. Will definitely have to look into this, thanks!
Yeah, I would say modern PHP apps and shared hosts are not a thing that works well together.
Except that it hasn't appeared again, and wasn't there before. 
&gt; You have the same amount of buy in using PHP. PHP has a much larger support, both by a strong set of varied core developers and Zend (and their new owner). So the buy in may be the same amount, but the risk is drastically lower when using PHP. There is no company standing behind Phalcon. There are precisely 0 full-time developers working on Phalcon right now. &gt; Why should a framework provide you anything other than structure? It provides limited structure that affects app architecture negatively. I'm talking about poor extensibility and opaque APIs. Tell me for example how do you supply a custom DI container for the provided router. Or a custom dispatcher for it. You can't. It's three-in-one. Take it all or leave it all, but configurability and flexibility are almost nil. &gt; Not having to recursively load the framework and all of its includes on every request cycle matters. When you are sub 50 ms on every request cycle you don't have time to spend 10-20ms on loading a framework. There are two solutions that address this already: running opcache, and serving your app from a persistent set of PHP processes. Notice neither of them requires baking an app framework in a binary extension. Instead they work with any PHP framework out there (including any customization you may want to apply, without having to recompile and tweak your PHP install to get it deployed). Phalcon is solving a performance problem in the worst way possible, when superior alternatives exist. Also may I suggest if performance is so important, one shouldn't be using PHP in the first place. If you write your app in Java (or at least move the heavy backend stuff to it, keeping the controller/templates in PHP), then you'll get a magnitude better performance than Phalcon can offer. Zephir isn't nearly as fast as the JVM is. I'd rather combine industry standard Java + industry standard PHP to get a lot of performance, instead of obscure language Zephir, run by a tiny team with day jobs + PHP, and get less performance than the Java+PHP combo. How about you?
For protection against crap scripts like this, always disable eval() (is evil) in php configuration and assert() too unless you absolutely need it. You also want to make all files and directories of your website readonly unless it's an upload or cache directory. For all my projects I made a deploy script that does this (well, and loads more), it will rsync all files, then update all file and directory modes
Better to use a dedicated deployment tool like Capistrano or Rocketeer. Git is for version control. It can't handle things like Composer updates, configuration file changes, or development files you don't need in production (e.g. Vagrantfile).
I don't think it's an exclusively political problem. While it might be useful, like any big change it adds a ton of complexity.
&gt; Public properties are a bad idea because they break encapsulation and allows any outside code to mess with those public properties. This is true only if the class is trying to encapsulate something. While much of what we write may live in that sphere, sometimes you just need classes to transport values in a group around. For example, in C# there are structs that meet this need.
Git can handle composer updates by using a post receive hook. If you keep your composer lock file versioned, you can just add a *composer install* command in your post receive script and it will automatically update the dependences to the latest tested versions every time you push. You can automate a lot of things using a post receive hook you just need to be a little creative and have same basic understanding of bash scripting.
Thanks. I didn't know that. It still leaves problems in place. What happens if Composer fails or when it's slow as dirt? How do you handle dev files you don't want in production like unit tests? Do you really want your git commit history on a production sever? How does data get migrated?
Yes, I agree for things like a simple data transfer object.
Is it possible to both pay a whole year upfront and also pay for a monthly subscription so that I would always be able to use the current version even if I stop subscribing? Of course I would have to pay back all the months I missed (up to one year) if I wanted to cancel and then subscribe again and get the same effect.
If you are forced into ftp, this one works too, and very well: Dandelion https://github.com/scttnlsn/dandelion does the same, i think (haven't tested phploy yet, can't be sure)
It if free for one repo with unlimited deployment and unlimited servers. It is very good if you don't want to share server's passwords with the (new) programmers for example. They can only deploy or undo the deployment. They have no access to the server's file system.
With the old model when I stop paying I can use the latest version released on the day my license expired. With the new model I can use the old version from the day my subscription started. I will renew now. Since we will all fall to the subscription model anyway, this will allow me to postpone the change further into the future. And since I never upgrade to the newest version right away, I might be good for a few years. Edit: Renewed, thanks for the reminder.
I think the same way!!
Can you please give PHPloy a try just to check the experience? That would be awesome.
Sure, will do and report back
Have they fixed international keyboards yet? Typing € and @ required me to install a 3rd party plugin (or remap some shortcuts) last time. Stopped using it as I believe a text editor should be able to type common symbols without external plugins. edit: Found the [bug](https://github.com/atom/atom-keymap/issues/35), still not fixed ;( [Workaround](https://github.com/andischerer/atom-keyboard-localization).
That problem reminds me of the good ol' days when php was just a basic templating language.
There are so many CI Tools. I use Travis CI for open source projects (with github) and [PHPCI](https://www.phptesting.org/) for my locale/private projects.
IMO, the best way to test is to keep everything decoupled and separate. Keep the PHP for itself and the JS for itself and test each one individually. The backend should most often be built in a RESTful manner and tested using something like PHPUnit with Guzzle. The front end should consume that API and test itself using whatever fits that particular project. That's at least how I do things. 
&gt;Composer caches all installed versions locally. Run a `composer install` before deploying the files. I don't quite understand. Are you suggesting doing this on the production server? That wouldn't work without the latest composer.json and composer.lock files. And I don't see how it would do any good in your development environment. &gt;I've also had a deployment git repository, with all the vendor files committed directly in the repository to speed up deployment and checkouts. But then you're just implementing the deployment work between your development and production repositories. Why not run it directly, especially when it can make the kinds of changes git can't? &gt;composer install --no-dev That's for Composer dependencies, not your app. &gt;Can use git archive to dump files Didn't know that one. &gt;What data are you referring to? Database or config files changes, for example.
Got a new computer. Setting up environment and this happens. Just my luck. The last module that I need for my project.
&gt; With the backslashed functions PHP does not check the current namespace and therefore **execution is faster.** _Requires citation_ But, no really, I'd actually be interested in knowing if this actually has any tangible benefit in a real world app. Does an opcache obliterate this need anyway?
Perhaps you should start by firing the sys admin , it's not his job to tell you what extension to use , what the actual fuck ? he is no developer.
This is a pretty huge month for PHP. 
I look for PHP 7 testing in the project's .travis.yml file and check builds to see if they passed in PHP 7. This certainly isn't the definitive way to check, and there's probably a better way to do it.
&gt; Unless you have a network issue with your server, I don't see how a composer install could fail with an already tested lock file. Causes I've run into are memory exhaustion and Packagist being down. Not extremely common but they do happen. &gt;So, if you are updating an important core dependency you might experience a couple of minutes downtime until composer installs it. But usually that's not a big deal, even when you run system updates on your server you may have a couple of minutes downtime. But why do that? We're making the decision to take our website offline for several minutes and manually deploy for what gain? &gt;I really don't see an issue about pushing unit tests to prod. One example is tests that make database changes. Why have the code on production where it could do harm, even if it's very unlikely? &gt;But if that really bothers you can just add an rm command in your post receive script to remove them every time after each push. # &gt;If you have data that cannot be versioned with Git you are going to need other tools to handle it, but you can still automate it using a post receive hook. Why not just use a deployment tool if you're going to end up writing your own deployment scripts anyway?
It says it only deploys what is checked ibto Git. We do not check in compiled binaries.
If you can't install git but you do have ssh access, scp a statically compiled version of git to the server and use that.
It's back now
To send over the local server (Server needs to be an allowed sender for the sender domain so it doesn't be marked as SPAM): http://php.net/manual/de/function.mail.php Or the better Alternative, send via SMTP. There are some classes out there for SMTP, like https://github.com/PHPMailer/PHPMailer 
[removed]
Not always but I've seen you do it... can't remember from memory right now. Would need to check out your repos. Actually I tried it on PHP7 on some libraries of mine and yep, it goes slightly faster (around 60ms in my case)... not a big deal...but change is painless so why not. As it says on the repo, it's just an idea based on your talk :)
I'm just not sure how you implement this into the above code... I've tried, but always get syntax errors, even when the code looks okay to me.
&gt; if ($i == 4) { break; } I'm such an idiot... I was forgetting the trailing } Thanks though...
I Have to say, nobody has presented any credible evidence for not using a framework; while I do take on-board your concerns, they seem unfounded, rushed-into and full of "if you don't agree with me you are being dogmatic". I Don't always use others frameworks, sometimes I do have to roll-my-own; but I never pretend that I'm working without a framework, and I never do it without first checking that there is something else that exists, that will scratch my itch made by someone else first. I'd also argue that this is not `a fight between frameworks - no frameworks`, but a fight between those who want to get things done, and those that do the same thing repetitively without good reason...
Not all clients are as willing to listen as others. Some of ours are stubborn as hell and nothing can dissuade them from their old crappy hosting
I like it. I was making something similar, but i like your idea. I would suggest a caching system though
Np, but Im mostly quoting other ppl, just 1 or 2 paragraphs are my own. :)
maybe Reflection itself ? idk , just wondering, everytime u have to generate those routes based on reflection, right ? maybe u could generate it just once and "cache" it. Not exactly caching since php cant serialize reflection objects, but i mean generate a php file with the routes and include it dynamically, just an idea. 
As promised, i'm returning to report after testing phploy properly. It works, really well too. Congratulations. It's really nice to use a php based tool when you're working on php. Cool to have it available with composer. Can be better: documentation. scheme wasn't explained at all. Checking the source code, can assume it accept ftp and sftp in there. In "multiple servers" you're talking about "servername". You could give an example using the default [stating] or [production] that are defaults on deploy.ini, just for the less experienced people that might want to use this tool. Talking about deploy.ini: just as composer has a composer.json, or bower a bower.json, dandelion a dandelion.yml, i think deploy.ini should be phploy.ini, so other people (or ourselfs in the future) don't need to figure out what's that file for. Being part of phploy, phploy.ini is more descriptive than deploy.ini in term of belonging. Copy the composer behaviour in terms of global installation on Linux/OSX. Curl the file directly and move it to /usr/local/bin (easy for the newcomers), and allow phploy to self update just like composer. That would be cool :) Lack of a local path definition. Just like you can set a remote path, using path definition on deploy.ini, is useful too to have a definition for a local path. So you can have deploy.ini one directory outside the public directory in you repo, so even if you accidentally checkout deploy.ini into git, phploy can cd into that directory before start syncing files. Dandelion has this, and is useful. Is really pleasant to have a php based tool to deploy when we are forced into ftp. Having it on composer is even cooler. Hope you can implement a local-path definition at least.
Next time an issue like this would come up, this project might assist you: https://github.com/hmlb/phpunit-vw
I also feel people are mistaking laravel/laravel and laravel/framework. You can use the true framework to start building off of that or you could use the out of the box solution with some structure to it.
Keep in mind this is basically an RFC, intended for interested developers like you in the community, but probably would be confusing for end users. When the details get fully fleshed out and implemented, we'll also have a lot of nice guidance for end users based on our own experience at FB for what tends to work well and how to approach problems. That documentation is all missing right now since, well, we have a pretty good idea how this would slot in (otherwise we wouldn't be doing it :)) but not an implementation and experience yet.
May be the reason is you never tried to view the video again from a user perspective ?
It's really hard for me actually, that why a lot of my docs turn out convoluted in the end. I somehow cannot disassociate from myself
Regarding the docs : I did looked at one of the component auth, but it made me feel there need some sort of Facade. And there seems many dependencies. I may be wrong only going through the docs. Anyway it needs some polishing I felt. Just a thought, again different subject. Thanks for your time and good things you are doing to PHP.
Which particular libraries do you mean?
TIFU - it's all good ~~I bought v9 about 1 month ago and now i can't upgrade, even though the update wizard told me i could use it.~~
PhpStorm 10 is available as a free update if you purchased your license after November 2, 2014. When did you purchased your license? Could you try to download the full release at https://www.jetbrains.com/phpstorm/download/ ?
I'm a big fan of PhpStorm, but I find it ~~unacceptable~~ concerning that this bug still hasn't been fixed: https://youtrack.jetbrains.com/issue/WI-28283. It causes serious usability problems when trying to use scalar type declarations inside a namespace.
Unfortunately, we don't have a patch update from 9.0.2 so please use a fresh install.
We're working on the issue. The fix should be available in one of 10.x.x updates.
Yes, i was missing the "===== LICENSE BEGIN =====" markers.
Sorry, i didn't paste as i was supposed to and panicked.
So my old license is still good? When the popup came up this morning, it said I would need to buy a new one. Which was not how I understood the new pricing policy to work. 
Why did you guys bypass the 9.5.x branch ?
We decided that we have enough features to call it 10 instead of 9.5:)
if you decouple your application logic into a service layer [extract logic from controllers] you don't need guzzle to test your application, just mock some data and inspect your service layer payloads.
&gt; Also, Yaml is still broken Well, you can hardly blame Jetbrains for that. /s
&gt; but I find it unacceptable that this bug still hasn't been fixed: PHP 7 hasn't been release yet, and you find it unacceptable that a tool hasn't added support for an unreleased piece of software?
If I had a nickel for every time a sysadmin threw a tantrum over not wanting to do work I would have enough money to hire a competent sysadmin.
[removed]
This is very interesting stuff, not really related to PHP though. Still very interesting ;)
It would be less of a problem if they weren't specifically marketing the release as including "PHP 7 Support."
FTPS and SFTP are 2 different things. - SFTP is using FTP over an SSH connection - FTPS is using SSL on an FTP connection.
The controller should be doing only a very small number of things: 1. Collect input. 2. Pass the input to your domain logic (in this case a service layer) and retain the result. This means *one* call to the domain logic, not multiple calls. 3. Pass the result from the domain logic to a presentation layer. If the controller is doing anything more than that, it is doing too much. With that in mind, all the additional work you're talking about probably belongs in the domain logic, not in the controller. A "sort of FooThingCreatorService" may or may not overkill, depending on the complexity of the domain operations.
I know this an old post, but I thought I would clarify one point. I do not get any share of Laracasts profits. Jeffrey retains all profits.
Really? I still prefer Sublime. In fact, i prefer Netbeans over Sublime.
Duly noted! Thanks. :-) 
There is some more obfuscation but here's a start http://www.unphp.net/decode/dc69777e62bdc8e343878f4d1e1b8d8e/ edit: it looks like maybe you grabbed that file with the wrong encoding. Is this what the file looks like on the server?
Settings are going to be imported from the previous PhpStorm version on the first launch, so no need to manually export/import them.
This is the only thing I know that lists some features https://laravel-news.com/2015/11/laravel-5-2-a-look-at-whats-coming/
I'm not sure. I will check and follow up. How did you correct the encoding?
Nice post Ben. It's good to remember the people we've lost, not only because of their contributions to PHP, but also because they were our friends.
Is this version based on idea 15 or 14? 
The open-sourced IntelliJ platform, [upon which PhpStorm is built](http://www.jetbrains.org/pages/viewpage.action?pageId=983889), is completely modular. There is a [massive plugin repository](https://plugins.jetbrains.com/) both with official plugins maintained by JetBrains staff as well as thousands more which are community contributed. PhpStorm is itself "essentially" (used *very* loosely) just a special version of the base/Java IDE, IntelliJ IDEA, bundled with the official JetBrains PHP plugin, which is what adds all the PHP 5-7 and PHPUnit functionality to the IDE. AngularJS support is also just an official JetBrains plugin. And so on. So you see, between the various official JetBrains plugins, the IDE, and the platform, there is a lot of interdependence. All plugins have a dependency on the underlying platform (API) version, and some have dependencies on other plugins as well. Therefore the development cycles of the IDEs and official JetBrains plugins are tightly coupled with those of their targeted platform — as you can't make an official release of something that depends on an unreleased platform — and, when the new platform version (currently 143) reaches maturity (which happened today), all the official IDEs and numerous official plugins that are ready all get released together. When they say: &gt;PhpStorm 10 released with support for PHP 7, PHPUnit 5, Angular 2, and more They actually mean: &gt;PhpStorm 10 and [IntelliJ PHP plugin](https://plugins.jetbrains.com/update/index?pr=idea&amp;updateId=22045) released with support for PHP 7 and PHPUnit 5, [IntelliJ AngularJS plugin](https://plugins.jetbrains.com/update/index?pr=idea&amp;updateId=21882) released with initial support for Angular 2, and more Plugins go far beyond providing autocomplete and syntax highlighting to the editor for libraries and other dependencies your project requires, by the way. They can add settings pages, menus, preview windows, run background tasks, create a web view in the IDE to show documentation, etc…the IntelliJ API is exhaustive so you can do pretty much anything you can think of.
That's what I meant, sorry. Check the second link; it's FTP with the ability to set SSL to TRUE.
"Support" by itself does not imply a certain level. The Angular 2 support in the AngularJS plugin is also just "initial support".
Keep up the good work. Great IDE. Worth the cash. 
Atom can't do a fraction of what PHPstorm can.
Perhaps a `CreateFooThing` command - hand the input off to the command bus and have it handle the various bits of orchestration required to get the necessary information required to prepare the creation of your object? It'd look something like: public function create(Request $request) { $this-&gt;dispatch(new CreateFooThing($request-&gt;all()); } In your controller, and CreateFooThing's handler (be that a method or a dedicated handler class) would resolve any of the necessary dependencies, perform any of the lookup of information required, build the payload and perform your create operation. The advantage here is that your controller's responsibility remains focused and small - it gets a request, perhaps handles some validation via a form request or something, and hands the request information off to your service layer. The complexity of performing the save can be housed within a class whose responsibility is dealing with this. There's a little bit of pushback against commands in the Laravel community at the minute, mainly because some it's been latched onto as the new "right way" to do everything, which isn't always necessary. But for complex things they seem to work quite well I find. (Commands are now called Jobs in Laravel 5.1... but they appear to be functionally equivalent)
I have psysh.phar but I inevitably type "php -a" every time by instinct. 
&gt;Because I don't want to spend my evening reading docs of a deployment tool trying to figure out how to configure it and set it up, when I can just write a simple shell script to do what I want. That's your choice of course. I can tell you from personal experience you're just trading a bit of time learning now for a whole bunch of technical debt later. Professionally I don't find the argument very compelling since it can be applied to every other industry standard tool. Why learn git when I can just keep my source code in Dropbox? Why invest the time in an IDE when I can just use Notepad++? What's the point in making a Vagrant box when I can just install XAMP? Why setup Xdebug when I can just do var_dumps? Why spend hours writing tests when I can just run changes past QA? The reason is it's a tool that makes your life easier and more productive after the initial investment. &gt;Furthermore, you don't reinvent the wheel by using Git with a post-receive script, you are using already available, well maintained and tested tools, you just glue them together. That's arguing you haven't reinvented the wheel, you just have a custom design for the round thing that connects to the axle. The deployment tool is the *script*. Whether it's called from git or manually run doesn't matter. It's about what it does. And what it does are all the things git can't and deployment tools are designed to.
I'd rather not spend all day putting plugins together when this does it all and more out of the box. 0 setup xdebug realtime debugging is godly, as is vagrant/behat etc countless integrations.
Autocomplete, refactoring, finding definitions or usages of a class/method/piece of code, step-though debugging (and manipulating the data directly in real time while debugging), git integration, built-in code style specifications/automatic formatting. PhpStorm can do all of these things better out of the box than Sublime can with plugins (and takes considerably less time setting up). As a long time Sublime user who had a similar frame of mind ("I can work quickly enough, why bother?"), it's night and day once you become comfortable in the IDE. That said, use whatever you feel comfortable in. I used PhpStorm in my spare time while building a side project in order to really test it out.
I guess i have to wait until then prepare to upgrade my license. 
I think I agree about the controller doing too much. I am definitely leaning towards the `FooThingCreatorService` based on all the feedback so far.
Yes, indeed. Didn't occur to me to look there, also I found the solution relatively quickly. It's more that I've been through tons of RFCs (and SO posts etc) the last week so when everything start to fall in place this came as a quite unexpected finale. 
Nope. The plugins do lag behind, but not nearly that far. For example, I've been running the [IntelliJ IDEA 15 EAP and PHP plugin with PHP 7 and PHPUnit 5 support](http://i.imgur.com/NlaYd8i.png) for months already, long before the official release of PhpStorm 10 today.
I would recommend zend. http://www.zend.com/en/services/training#PHP%20Courses . See the instructors http://www.zend.com/en/services/training/php-training-instructors , some of them have proven their skills in open-source. Highly recommend.
Be careful about using the same time zone identifier for multiple countries in the same time zone. Different countries might have different rules for DST switching, so using this library you might be wrong up to twice a year for an indeterminate amount of time (edit: it might also suddenly start to go wrong for some countries as legislations change and as your OS updates its time zone database). Depending on what you need the time zone for, this might be ok for you or it might not.
It really depends on how you sell it. Don't say it was a "custom framework", say that you went frameworkless and used composer packages to build your application instead. To a lot of people that sounds way better than even Symfony2 certification for some reason.
If using the custom framework has forced you to understand its inner workings, then that's great - you can talk about that. You could also explain similarities between this custom framework and other well-known frameworks to show you know what you're talking about.
There's also the [`.phpstorm.meta.php` file](https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Advanced+Metadata) that can be used in each project without needing a plugin.
http://www.jetbrains.org/display/IJOS/Home First Google result for "intellij open source" Edit: [Breakdown of the platform](http://www.jetbrains.org/pages/viewpage.action?pageId=983889) &gt;The IntelliJ Platform is open source, and the code is covered by the Apache 2.0 license. This means that you can build both open source and commercial products on top of the platform without paying any royalties to JetBrains. &gt;Please note that the IntelliJ Platform is not a general desktop application framework, and is only designed to be used for IDE-like applications. Basically, if your application requires a code editor, there's a very good chance that the IntelliJ Platform will be suitable as the underlying framework.
Has anyone managed to get PHPStorm and SVN 1.8 to work on Windows? It's been broken for ages :(
Is there a way to get the minimum list of timezone regions that cover all combinations of DST offsets known? Setting a window to check makes sense - no point pulling out a country that experimented in not doing DST in 1978 as a separate selection (or maybe there is?). Seeing them grouped automatically (for this century, perhaps) would be a great first step in helping to curate the list to something the end users will find usable. For example, if Paris, Berlin and Rome all have the same DST from 2000 to the known future, then they could be listed as one entry "Europe Paris/Berlin/Rome". I guess the trouble comes with deciding what to store - Paris, Berlin or Rome? If you choose Paris, and Rome goes off on a limb with DST next year, then some Italian user's accounts will start to give the wrong time. Oh, timezones, never easy.
In my experience, being able to pick up whatever framework (or custom hackjob unmaintainable shitcode) a place is using is the real skill, and to be honest, once you've got some experience with a few of them, you'll be fine. So sell this as a positive, not something you're lacking. I don't think there is anything wrong with referring to it as a custom framework (and not a load of Composer packages stuck together, which, lets be honest, it isn't). Emphasise you skills, ability to learn, and your soft skills (communication, team working etc). Don't assume a laundry list of frameworks is the only thing which anybody is looking for.
It's UTC, not UCT - wouldn't normally correct you but you spelled it wrong like ten times.
That's a nice collection. Thanks for sharing. If you are looking for sources, [there are a tonne of sources here](http://www.iana.org/time-zones/repository/tz-link.html)
So it looks like they didn't back off their perpetual-rent license idea that caused a big flap a few months ago?
https://youtrack.jetbrains.com/issue/IDEA-94942 Looks like the fixed it a couple of years after it was reported. I'll have to try and figure out why that doesn't seem to cure the issue for me :(
Nevermind, i thought you didnt define which class is loaded. My solution is using a path for the controllers, but i dont know which controllers classes are in there, so in my case i think i need to cache it. 
I get a bit annoyed at containerless dependency injection examples. How do you actually implement this in a large app where you need shared instances of objects, with lazy execution, without resorting to static variables inside the factory function (which is basically the same as making it a singleton)? function getPDO() { return new PDO(/* ... */); } function makeDBAL($pdo = null) { return new DBAL($pdo ?: getPDO()); } function makeRepoA($dbal = null) { return new RepoA($dbal ?: makeDBAL()); } function makeRepoB($dbal = null) { return new RepoB($dbal ?: makeDBAL()); } function controllerA($repoA = null) { $repoA = $repoA ?: makeRepoA(); return json_encode($repoA-&gt;getStuff()); } function controllerB($repoA = null, $repoB = null) { $repoA = $repoA ?: makeRepoA(); $repoB = $repoB ?: makeRepoB(); return json_encode($repoB-&gt;getOtherStuff($repoA-&gt;findSomething()); } function controllerC() { return 'hello world!'; } function handleHTTPRequest() { if (something) { return controllerA(); } elseif (something_else) { return controllerB(); } else { return controllerC(); } }
Well, OP posted a "manageable" version with still 150 items, I posted mine with "only" 52. So I try to do the best for my users, really. The first time I need it, it's pre-filled using the timezone of its browser, so most of the time (if the detection works properly and the user is not travelling far away from home), it shouldn't need to be changed at all. It's just an option as part of a larger settings page, I really don't want to put a map in here and take big amount of space on the screen... It's crazy.
My main beef is that once you start having 500 functions like that you've basically made a container of your own, one that is just a lot less efficient than the existing ones and that you need to maintain and tests. It's easy to say "You don't need X/Y/Z" but if I have to rewrite 75% of its features anyway but then in addition to that need to maintain it and test it, I don't feel like it's worth it _at all_.
True. Including the worms. You get worms in cheese, and the Moon is made of cheese. It is the Moon slowing us down that is causing GMT and UTC to slowly drift apart. So yes, it's all connected.
That is one of the reasons why PHPixie does not use a dependency container of any sort, just plain simple factory classes: https://github.com/PHPixie/Template/blob/master/src/PHPixie/Template/Builder.php#L100
Desregard this crap. These are not top hosting companies, they are hosting companies that pay the most in affiliate referrals. Op: Don't be an ass. Evereyone else: Always check your host on webhostingtalk.com first, and avoid all hosting comapanies owned by EIG (this includes HostGator, GoDaddy, BlueHost, etc
I wouldn't frankly. There's nothing wrong with the container approach except that it can be much easier to reason and test if it's just plain normal PHP. We don't need magical detection or external configuration to locate our classes. If you want some magic combine with autoloading and do classname lookup (but don't, seriously what a pain that can be later) As a more explicit example, we've used a structure like this for our applications in the past: &lt;?php class Factory { /** * we'll cache our 'singletons' for database access */ private $pdo; private $dbal; public function __construct(array $config) { /** * we may capture environment-specific config here for our object creation, * or have a ready-made config object to pass on to our application elsewhere if necessary. */ } /** * these can be called repeatedly without generating new connections */ private function makePDO() { if (!$this-&gt;pdo) { $this-&gt;pdo = new PDO(/*...*/); } return $this-&gt;pdo; } private function makeDBAL() { if (!$this-&gt;dbal) { $this-&gt;dbal = new DBAL($this-&gt;makePDO()); } return $this-&gt;dbal; } /** * whereas these will give us a new object each time (though their dependencies will be cached) */ public function getRepoA() { return new RepoA($this-&gt;makeDBAL()); } public function getRepoB() { return new RepoB($this-&gt;makeDBAL()); } public function getControllerA() { return new ControllerA($this); } public function getControllerB() { return new ControllerB($this); } public function getControllerC() { return new ControllerC($this); } } So there's our factory object, it's fully testable and a single place for us to write up our dependencies, or swap them out. // in the past we've used the term 'workflow', as this usually makes better conceptual sense than 'controller', where // like these, the controller has a single action interface Controller { public function __construct(Factory $factory); public function run(); } class ControllerA implements Controller { private $repo; public function __construct(Factory $factory) { $this-&gt;repo = $factory-&gt;getRepoA(); } public function run() { return json_encode($this-&gt;repo-&gt;getStuff()); } } class ControllerB implements Controller { private $repoA; private $repoB; public function __construct(Factory $factory) { $this-&gt;repoA = $factory-&gt;getRepoA(); $this-&gt;repoB = $factory-&gt;getRepoB(); } public function run() { return json_encode($this-&gt;repoB-&gt;getOtherStuff($this-&gt;repoA-&gt;getStuff())); } } class ControllerC implements Controller { public function __construct(Factory $factory) { /* Don't need anything */ } public function run() { return 'hello world!'; } } Our controllers (or workflows) have a single point of entry and have their dependencies listed as typehinted __construct methods. If this gives you the willies have a setUp() or something and call that in your factory. Again we can unit test this using plain PHPUnit since the plumbing is just passing normal objects around. You'll notice I take a Factory argument for my controllers, in the smallest case I would probably just inject the stuff I need instead and not specify __construct in the interface, however once the dependencies start to mount (logging, couple of models, some other bits) the parameter list is massive and looks awful. Your unit tests should pick up if the factory no longer provides a required getXXX method (your PHPUnit mock will break) // Bootstrap.php, used mostly to mask the index.php if the server is broken and serving code instead of interpreting class Bootstrap { private $factory; private function handleHTTPRequest() { if (/* some sort of routing probably */) { return $this-&gt;factory-&gt;getControllerA(); } elseif (/* some sort of routing probably */) { return $this-&gt;factory-&gt;getControllerB(); } else { return $this-&gt;factory-&gt;getControllerC(); } } public function run() { $this-&gt;factory = new Factory([ 'mysql_user' =&gt; '' //etc, whatever ]); return $this-&gt;handleHTTPRequest(); } } There's always going to be one place that you have to do the grunt work of setting up your factories and other bits, so this is it. // index.php require __DIR__ . '/../Bootstrap.php'; $b = new Bootstrap(); echo $b-&gt;run(); Then we usually separate off our index.php just for the rare case that a server is broken and serves up our application code instead of the rendered output. My main criticism of this approach is that you get very big factory classes very quickly which is ugly but not necessarily a disaster. We went to a sort of layered 'call the parent if I don't serve this object' approach which worked decently for additional factories. I have no idea if that will help or anger you, but it's how we 'best-fit' the problem you describe for simplicity. 
&gt; How do you actually implement this in a large app where you need shared instances of objects, with lazy execution, There's a few things you need: i) The ability to use delegate functions in your DIC. This allows you to tell it how to create objects in a 'lazy' (actually not lazy, just very lightweight) way. i.e. this: //The delegate functions are just strings. Even having several hundred of them has very little object. $injector-&gt;delegate('RepoA', 'makeRepoA'); $injector-&gt;delegate('RepoB, 'makeRepoB'); Tells the injector how to create RepoA and RepoB objects, but until an object that the DIC is creating requires a Repo object, none will be created. ii) You need to get into the habit of having multiple dispatching tiers inside an application. function getRouteCallableFromHTTPRequest() { if (something) { return 'controllerA'; } elseif (something_else) { return 'controllerB'; } else { return 'controllerC'; } } $routeCallable = getRouteCallableFromHTTPRequest(); $injector-&gt;execute($routeCallable); The problem with current PHP frameworks is that everything is done in a single dispatch layer or tier. This means that either you have to pass in all possible dependencies required, or you have to pass the DIC around as a ServiceLocator. Splitting the application into separate tiers allows for different dependencies to be injected into each of them, as well as more information to be added to the DIC as appropriate. The [Auryn](https://github.com/rdlowrey/auryn) DIC enables this, and I'm just writing a skeleton application and documentation for my "framework" that implements the above ideas: https://github.com/Danack/Tier 
Bug report: Under RFC Creators, Stas Malyshev has 9 created, 7 approved but lists 0% success.
&gt; Most startups/mid-size companies cannot afford to pay for the time and money investment that testing require. That was actually the entire point of the post. They cannot afford to pay for testing, yet they can afford to pay to over-engineer and build in all sorts of other flexibility devices like events and command busses and the like? What if we inverted that? What if instead of building all this complexity to tollerate change, we simply tested?
&gt; It's easy to say "You don't need X/Y/Z" but if I have to rewrite 75% of its features anyway but then in addition to that need to maintain it and test it, I don't feel like it's worth it at all. Why do you need 75% of its features? I'm not suggesting that you go forth and write things the exact same way just without the container. I'm suggesting you simplify. And that includes not re-implementing the magic of the libraries you're getting rid of. So I'd argue you need only about 10% of what the container does for you: manage wiring. The rest of it is actually just masking complexity with more complexity...
Perhaps you need a facade for this. Facades are great for encapsulating complex actions that require multiple services - I'm talking about Facade pattern here, not Laravel Facades. 
Ah good catch yes, currently computing the % against all RFCs
Highlighted for visibility: http://i.imgur.com/GZpWXRq.png Also appears if you click his name and go to his profile page: http://why-cant-we-have-nice-things.mwl.be/users/stas-malyshev &gt; Created 9 RFCs, 0% of which have been approved.
Try not to make every post about pixie my friend. It seems like the moment /r/php see `PHPixie` they just downvote the post out of instinct because every post feels like shameless plugging. You'd probably be better off writing it like: &amp;nbsp; _That's the reason why I've decided not to use dependency containers of any sort in my framework and [opted for simple factory classes](https://github.com/PHPixie/Template/blob/master/src/PHPixie/Template/Builder.php#L100)_ protected function buildResolver() { return new Resolver( $this-&gt;compiler(), $this-&gt;filesystemLocator, $this-&gt;configData-&gt;slice('resolver') ); } Now it seems like you're contributing to the discussion rather than _shameless plugging_ Just an observation I noticed, have an upvote.
&gt; most of them are just objectified arrays with some methods on top. That's not the type I'm talking about. Something like Pimple is fine. I'm more talking about things that autowire for you, etc. Like Laravel and Symfony's containers... Those that appear magical because they hide a lot of complexity from you.
Not sure if it's intentional or not, but I can't seem to sort the tables using the results in any column that is a percentage. Sorting on the other columns works fine.
Yes need to fix that
They actually compromised and made some large changes. http://blog.jetbrains.com/blog/2015/09/18/final-update-on-the-jetbrains-toolbox-announcement/
Well the thing is that most of my programming actually goes to PHPixie, so whenever I speak about my experience with anything it pretty much comes down to it. But you are right that it comes up like shameless plugging a lot. Your wording sounds way better =)
Don't get discouraged, you'll just have~~need~~ to change your writing habits a little bit.
http://aes.online-domain-tools.com/ is using mcrypt - not openssl. See, for example, the following code snippet, which works, based on the parameters in your screenshot: &lt;?php $plaintext = 'aU4111111111111111'; $ciphertext = 'vI8ZOfGT8oVt/NQ7k/LeKQBg'; $key = '5dfec7bd7fc7ca994db3a087ad2eddfd'; $iv = str_repeat("\0", 16); $ciphertext = base64_decode($ciphertext); $plaintext = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $ciphertext, 'cfb', $iv); echo $plaintext; Basically, mcrypt has two cfb modes - cfb and ncfb. OpenSSL's cfb does what mcrypt's ncfb does and does not have an analog to mcrypt's cfb. http://stackoverflow.com/a/4574258/2224584 discusses the difference. Really, I'd recommend you just not use http://aes.online-domain-tools.com/ to perform sanity checks. ncfb is what it should be using - cfb (as implemented by mcrypt) is non-standard.
Thanks. Got it. Works for me now.
As long as you understand the concepts and can apply it to some other more commonly used framework I wouldn't consider it (as someone who sometimes hires developers) a problem. If you also knew of some shortcomings in the homegrown solution that would be a bonus.
The app is amazing. It aggregates RFC comments with the actual proposals, which is awesome, so we don't have to get into the internals mailing list to see why the hell something was rejected. Also, the stats are amazing.
Oh wow, this is really great. The name is funny, but it's also kind of ridiculous and may turn some people off or start unnecessary drama (is that ever avoidable, though?) while also making it harder to search for/stumble upon. But seriously, this is a great tool. Thanks!
You can still benefit from experience with a proprietary framework, if you make sure you can chat with your next employer about: * What is the overall architecture of the framework? What did it try to accomplish? * How is it similar/different to other more-popular frameworks your interviewer might know about? * What were its strengths or weaknesses? (Even "runs on PHP 4.x" can be a strength, in the right place.) * How did it made you appreciate feature X, Y, and Z in other frameworks? You want to set yourself apart from the people whose experience boils down to: "I memorized many voodoo rituals and seldom displeased the mysterious and fickle spirits." 
Thanks everyone guys, will check this tomorrow at work and reply how it went with new info. Basically what i have to do is during the export process decode one systems stored credit cards, that i am able to do using default system functions, and export them in a different encryption so that later they can be imported in another system (ERP) that using different decryption for that. For now i only need to understand why i cant encrypt needed data using openssl using needed encryption. Everything else will be talked over with client on different occasion. Will check replies tomorrow and see what i can do. Thanks!
Same here. One thing I struggle with time-to-time though is naming many-to-many relationship tables. The rails convention is _plural_plural_. Sometimes, however, it turns out I need to make that relationship a dedicated model. For example _companies_users_ (assuming a user can belong to many companies). If it turns out I need a dedicated model for that table, it becomes _class CompaniesUser_, which is a terrible name. So sometimes I'll give my join tables a meaningful name in anticipation of eventually needing to model that relation. For example _employees_ (id, company_id, user_id). I suppose I could just keep the conventional table name, name my class whatever, then manually point it to the right table, but it's still a naming-things-problem.
This is not an optimization. This is just a "save a few lines of code" trick. And not a very neat one, if you think about it. For example, I always set the column="tablename_id" on my primary keys (for natural joins), which can't be done with this.
Yeah that's because the options are presented in a non standard format (outside of the table) and I'm still on the fence about adding a lot of code to parse that just for that one RFC https://wiki.php.net/rfc/mysql_deprecation
Can you address the additional bug surface created by tests? I find that 90% of the time, the simple code I'm testing is fine, but the test has some typo or misconfiguration that causes failures. So I have productive code that works, but spend time on tests that don't. ETA: I am asking how to reduce that percentage so tests (or worse, tests that are false negatives) don't increase your risk.
Oh, missed that post. I love this part: &gt; This is the most controversial topic. We didn’t realize how many users would differentiate subscription based services such as cloud hosting, monitoring tools, communication tools or repository services from an IDE ... Uhm. Clearly JetBrains folks aren't gamers, then .... Dozens of games have been crippled / locked out due to the removal of authentication servers. I'm shocked JetBrains didn't even think about this originally. That's all. Just had to open my mouth on that one. lol
&gt; it shows lack self-awareness to make fun of Java Oh, come on now, have some humor.
Are you thinking of Phil Sturgeon?
Yea, I get it. It's just a bit of a troll and makes it so I couldn't even tell someone the url, let alone have them find it through search.
Can you expand on what you mean by autowire (I've not used either of them heavily enough to know what they're doing for me)? I use Auryn at the base of most of my code. It does recursive dependency resolution, but I wouldn't say it "autowires" anything -- that is, I still have to register providers, or delegates, or preparers for everything except a concrete class typehint.
He took time away from the [internals](https://twitter.com/JCook21/status/374660746644176896?ref_src=twsrc^tfw)
[**@JCook21**](https://twitter.com/JCook21/) &gt; [2013-09-02 22:30 UTC](https://twitter.com/JCook21/status/374660746644176896) &gt; @ircmaxell I hope you can reconsider. I've really valued your contributions to the community. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Well, it's still wiring things together automatically. Meaning you can't really step through it meaningfully in a debugger. But there is a line, and that's more explicit than most, which is good. As long as you're careful at least.
He could, but he asked about PHP, not "a very specific framework within PHP that I'll have a hard time unlearning". The guides I posted are general PHP and very important for a healthy beginning.
Woah this is amazing, I honestly was completely convinced that everything was proprietary. Thank you.
Yes, which is why the title is misleading. At a minimum I had expected an article about reduced loading times.
Thanks a lot. I'll have to look into it. I'm really not sure. 
It was meant as more of a joke, I didn't think people would take it this seriously to be honest. Guess we'll revise that for the stable release, just need to come up with something better.
Seems to depend on the monitor. As the text color the green is terrible on some of the monitors I have and fine on the others. As the background block color it's either fine on some monitors or great on the others. ¯\\_(ツ)_/¯
It depends what kind of thing your existing site is and what it runs on.
This is how i design my tables too. It hasn't caused any issues so far, but i typically work alone anyway. I find it can make things more clear when doing a large number of joins `... FROM POST p JOIN comment c ON c.post_id = p.post_id` vs `c.post_id = p.id`. On its own, its clear and easy to read, but if I have to join 5+ tables, it can get fuzzy real quick.
Yep, that's it, thanks!
&gt; Pass the input to your domain logic (in this case a service layer) and retain the result. **This means one call to the domain logic, not multiple calls.** The part I bolded above, you should have noted is your opinion, and not any sort of requirement, practice, or recommendation in the community at large. You're effectively saying people should put frontend logic (controllers) in their backend (domain layer) if their controller for some reason needs to make 2-3 domain calls and they need to get that down to one call. I don't think the number of calls is the important metric here. If you need to make N calls to N domains in the frontend to present a single cohesive view to the user, that's fine. Virtually all apps I can think of do that.
I honestly do not. I had not seen `USING` until now. I see where that would make a much more concise statement. The joys of being an amateur, always a chance to learn something!
In my opinion this supports unclean syntax. You shouldn't leave the possibility for another list element if you don't want to include one; I also dislike this in the array syntax. But that is just my opinion.
meh - this is a step backwards IMO. I love this feature with arrays. A lot of times you may re-organize or add more data to an array, so having the trailing comma there is convenient. Using this for function calls, interfaces, etc seems backwards because those are instances where you want to be explicit. If I see a signature with a trailing comma, my first thought is going to be "huh did something get deleted?". 
It sure the hell beats what I currently maintain :) `User ID#` :D
...arrays support this already? what?
* http://www.easyphp.org/easyphp-devserver.php * https://www.apachefriends.org/index.html * http://www.wampserver.com/en/#download-wrapper
Yeah: The use-case for programmers -- the ways that people *mutate* their code with edits -- is different for array-definitions versus function calls/definitions. If somebody has so many arguments to a function that they *need* to split it up over multiple lines and do line-by-line inserts/deletes and leave the trailing comma on the penultimate line for nice diffs... Well, then they're probably doing something wrong anyway. Multi-line array definitions, on the other hand, are much more common, and a trailing comma is much less-likely to be indicative of a mistake. 
Not OP but I wanted to do something similar in my framework :) What he wanted to implement is something thats called [Pipes and Filters Pattern](https://msdn.microsoft.com/en-us/library/dn568100.aspx). It helps you to encapsulate a complicated task into multiple little modules that you can reuse in other parts of your application. One use case would be input validation. You could pass an array that contains all input (from a form) that looks likes this: ['key' =&gt; 'value']. And if one of the validation modules would notice an error it throws simply an exception, the process ends and returns an error message. *Please correct me if I'm wrong, though.*
Yeah, I thiink you are right... I guess I got carried away, being a PHP developer ... :P
Contrary to plenty of others here, this proposal really pleases me and I hope to see it pass. Here's why: *Your code changes over time.* That's really all it boils down to. Classes end up implementing new interfaces (or droping old ones). New traits are used, or old ones are removed. Being able to add this one comma actually makes a **huge** difference in your VCS history. Under current parser rules, implementing a new interface looks like this: class SomeClass extends ParentClass implements SomeInterface { // ... And adding a new one produces a diff like this: class SomeClass extends ParentClass implements - SomeInterface + SomeInterface, + SomeOtherInterface { // ... If this RFC passes, you can do this: class SomeClass extends ParentClass implements SomeInterface, { // ... And adding a new interface produces a diff like this: class SomeClass extends ParentClass implements SomeInterface, + SomeOtherInterface, { // ... See the change in the diff? You no longer touch the line where `SomeInterface` was in the `implements` list. This keeps your `git blame` (or equivalent) *much* cleaner. On small projects, this doesn't make a bit of difference - but in large codebases with lots of developers, this actually becomes very significant very quickly. Trawling through git history is a HUGE pain in the ass on a line-by-line basis, and this one-character change allows you to avoid it completely. I have *never* regretted changes that produce a smaller, more concise diff; in fact, I often go out of my way to optimize for this. To those saying this is a bad idea in function signatures, you're right. If you're changing the parameters of a public function, your process sucks. I'd also argue that having so many arguments that you have to multi-line them indicates a problem in and of itself. However, I value language consistency, so I'd rather that be supported and just not use it. That's the beauty of this (and much of PHP): it's optional, so if you don't like it, you don't have to use it. Set whatever coding standards you want on personal projects, and use the established ones at work (chances are you don't like all of them anyways).
~~I don't understand how it's better. 1 less change line isn't "better", it's just different.~~ The syntax allows for actual copy-paste mistakes. The feature being optional isn't a plus. You can't tell if the feature is explicitly being leveraged not. I have seen javascript written with args like so (I think in Sencha Touch): var obj = { arg ,arg ,arg } There's your clean diff. PHP does not currently parse a leading comma list very well (try using integers) and would require a significant change.
The first time I tried to view the page, I got a PHP warning printed to the page (meaning show errors is turned on) saying that file_get_contents() couldn't load manifest.json.
So, the whole point of this RFC would go away if someone wrote a plugin for a diff tool that understood PHP?
A programming language is a tool, not a product. All else being equal, people will use the best tools. Those tools can evolve to demand over time, or not. Those that don't will eventually fade into irrelevance. Is this particular thing a game-changer? No, of course not. But it's one of those little things that people will think about when starting their next project. If a language's syntax is such that it will naturally produce harder-to-review code, that's a bad thing. Programming is 90% reading and re-establishing context.
the 'priority_zones' bit makes the 150 list a lot more user-friendly by allowing you to put guesses for what's most relevant to your user up at the top of the list.
This would make more sense if function calls could use name parameters (which I wish would be included, although history says is unlikely). That's where one name =&gt; value pair per line makes sense, and re-ordering would be more common. 
I think explicitness of function arguments are more important than additional lines in a modern diff, as part of a change log. After the change, the code is harder to review because it poses a question that can only be answered by inspecting another piece of code and correlating that combination to a business rule. I equate this to default arguments. Default arguments benefit by reducing overall code necessary to express the business rules intended.
The reason of these getters and setters is to remove all duplicated field, like Id,CreatedAt,UpdateAt, etc.. which are common across all project Move it to shared folder and use it across all project. Its not about benchmarks, its about methodology: writing less , do more and faster. Since I moved to this methodology things become much easier. When I need to create a new Model(entity,document), I describe the class I need include needed properties using traits. I'm using this approach in Aisel: https://github.com/ivanproskuryakov/Aisel 
Also, you could take benefit of the `__invoke()` magic method. Instead of having a `run()` method on the interface, use `__invoke`. Then you can use `return call_user_func($step, $data);` in `array_reduce()`. And if you type-hint `callable` instead of `TaskInterface`, you don't even need the `CallablePipe` class, you can pass any kind of function/callable in you pipeline. :)
&gt; I'm just making suggestions based on my own personal experience, I'm not here to argue. And I'm doing *exactly* the same.
1. look over the project spec and decide on what the best tool for the job is 2. use composer - pretty much always (for autoloading if nothing else) 3. Follow PSR-4 4. Test when you're finished. I hate testing when the product is not stable yet 5. Drink a fuck ton of whatever is available. Preferably alcohol! 
I don't really see this being a common use case. In most, if not all cases, you're not going to have many functions or methods with enough arguments that you have to put them in separate lines. If you do, then you should probably rethink the function/method.
&gt;he/she Just use "they".
This is cool, but... cool is the enemy of team coding. It's much better to be obvious and consistent than save 14 bytes (or whatever it ends up being).
Will the amount of electricity saved by PHP7 be measurable?
Believe me, I'm all about avoiding tricks in coding. I hate tricks. But there's a lot to be said for being concise, because the more lines of code, the more things that can go wrong and the harder it is to follow the flow of the program. It's a fairly common thing to test for null before iterating an array, and (IMO, at least) this is fairly straightforward what's going on. If this was a common idiom in a source base, I think people would get used to it pretty fast and I think it improves clarity. Also note that one of the intentions for the two argument ?: is to set a default value; I think people just don't use it very often. This can also come in handy for array_merge operations where some arguments might be null: $a = null; $b = [ 1,2,3]; $c = [ 2,3,4]; $d = array_merge($a ?: [], $b ?: [], $c ?: []); 
If you detect the timezone and use a "best guess" as default value, the more relevant guesses won't be at the top, but near the currently selected value, which is not bad either.
You don't. The offsets are just here for display purpose, not to actually compute the time. Its purpose is the user can quickly scan the list and find where its country/city is the quickest way. The user don't necessary know what is the current offset where he lives, but he sure knows it's timezone based on the nearest city. I'm from Europe so it's pretty much easy for us since (almost) every country here has the same timezone. But I guess that when you live on the Western Coast, you will sure choose "(-08:00) Pacific Time (US &amp; Canada)" over "(-07:00) Arizona", even in the summer where the clock is 1 hour later and the current offset is (-07:00) because of the DST.
&gt;You can't compare them with a deployment tool, it is not the same thing. You certainly don't have to use a deployment tool but it's unfair to judge it if you choose not to. &gt;How exactly this enhances my workflow? Because it's abstracting away the work you're doing manually and has features you wouldn't be able have otherwise (parallel deployment, staging, etc.).
Totally agree. Just wish JSON supported trailing commas though. Just the data structures.
&gt; If I see a signature with a trailing comma, my first thought is going to be "huh did something get deleted?". And will you still think that 3 months after seeing the syntax in use for the first time, or will you get used to it, like everyone gets used to new syntax?
A trailing comma in function arguments is often a sign of programmer error. This RFC removes the ability to catch those errors while not giving me much in return. The possible upsides don't appeal to me much. I almost never make multi-line function calls, so in most cases I won't see any benefit from increased diff atomicity.
Yes, it's surely compatible. Both 2.2 and 5.4 are pretty old and perfectly fit for each other.
I would love to see named params
Yes. I would argue that the VCS should remain language agnostic, but changing a language's basic syntax to make cleaner commits seems backwards to me as well. Like others have said, maybe I'd get used to it. But all other languages that I commonly use forbid trailing comma in function calls, it seems... wrong.
Give me named parameters or give me death... .. well maybe not death, but perhaps an hour of Friday - Rebecca Black on repeat. 
"nobody has presented any credible evidence for not using a framework" There's always the article that started this whole thread :) "they seem unfounded" Correct, I'm just going by my gut feeling about your reaction to the op. Your need to disregard it. That being said, I agree with you, a huge majority of coders out there (ME INCLUDED) would struggle to stay productive without using a good framework (that they did not write themselves). Most people does simply not have time and skill enough to write their own framework. Using a well established one will almost always benefit them, even for the simplest stuff. But if you really want the BEST POSSIBLE end product, then you need to find a really skilled team and write your own framework that suits the product exactly to the point. But, at what cost? Is it worth to spend 2 or 3 times more money to get a product from 98% perfection to 99% perfection. (made up numbers, obviously) I think not. 
A page showing or affecting several domain elements that require several calls doesn't mean it's coordinating domain logic. In most cases it's simply building a composite viewmodel. To take a simple example, if a web page shows an article and a sidebar, then it needs to make a call for the article, and more calls for whatever it wants to show in the sidebar. If it wants to show "Signed in as ..." on its menu bar, then it needs to also make a call to fetch the user profile from the domain (at least once, then cache it in the session). Take Facebook's home page and see how many things are going on on a single page. You think that's *one domain call*? A Facebook engineer would find that laughable. They specifically added async to Hack so they can do more backend (domain) calls per page from their frontend (PHP controllers) in less time. If they had one call to make and wait for response, async wouldn't do anything for them. It's not the job of the domain to concern itself with what that webpage shows exactly. It's not the job of the domain to even be aware of what a "web page" is. So it's not the job of the domain to "send back what needs to be presented", especially in one call for an arbitrary frontend UI. The domain is not for presentation concerns. Tell me, is your domain directly usable for a mobile app which organizes information differently than a web site? The way you explained it, I seriously doubt it. A mobile app won't show the same set of information on the same set of screens. A domain should be slightly more universal and longer lasting than the very particular UI that happens to use it. Otherwise you basically gain nothing for having it.
Use php in CGI mode 
Likewise. Except for timestamps, which always felt slightly inconsistent to me anyways. I now use [first person present tense verb]_time e.g. `create_time`, `modify_time`, etc. to store a unix timestamp. Avoids timezone problems, pretty portable, and makes math fairly easy. I find the quoted idea of the natural identifier (`posts.post_id`) as a primary key particular bizarre - would you name other columns with a similar prefix (`posts.post_title`)? Didn't think so. The table name is basically a namespace, so don't be redundant. In any case, consistency within a project/organization really wins out to me. Everything else is just tabs vs spaces all over again for me.
&gt; I don't think that the cost of testing is justified for most startups/early stage businesses. The cost is just too high TDD. You might as well say to a race team that the cost of maintenance on the engine is just too high. I'm at the other end of your startup-that-cuts-costs-and-gets-shit-done and it's a fucking mess. Because there are no behavioural tests I don't know what the system is supposed to do. Because there are no unit tests I don't know what could break at any time. If you take the attitude that test are unimportant and you just need to ship stuff, then you need to bring along the attitude that you will have to burn your code and rebuild it sooner or later. Which can be a good thing.
I would not necessarily say that you are probably doing something wrong if you need to split function args into different lines... Specifically when injecting several interfaces into a class it can get pretty long with only a few args.
How is this compared to [league/pipeline](http://pipeline.thephpleague.com/) ? I've been looking at that but not sure when a pipeline like this would be a good idea. 
Cool! Exactly same idea as https://github.com/umpirsky/centipede. :)
Does the url normalizer handle current-page relative urls? eg "../parent-sibling-page" or "sibling-page". I have not tried it out, but it kind of looks like it may not support them. Just a hunch.
Ah good to know
could you implement an width upper limit on /requests? the table is so huge on big screens.
Love the name, don't change it (it's already the number 2 hit for "php why can't we have nice things", which is how I'll find it again!) I noticed for the PHP6/7 vote it doesn't really understand it wasn't a YES/NO vote but a choice between PHP6/PHP7 - http://why-cant-we-have-nice-things.mwl.be/requests/name-of-next-release-of-php#votes
That looks very similar to how react works. But wat about things like leftover state between requests and database connections? Does it create a poll of application instances etc?
Yeah was thinking about that last time as well, will do
That's because the system looks for negative words in the answer to mark them in red. In that case I'd consider it legitimate though, neither answer was really a yes or a no, they were just two choices equally valid in my mind
ReactPHP is a series of libraries for async and non-blocking I/O in general. The [HTTP component](https://github.com/reactphp/http) is only a small part of ReactPHP - but it does have similar features. Icicle is similar to ReactPHP and also provides a [HTTP component](https://github.com/icicleio/http). Check both of these libraries out, it's a really exciting area of PHP development :) To answer your questions: I wrote an article on [things to consider when using PHPFastCGI with your application](http://phpfastcgi.github.io/general/2015/08/21/things-to-consider-using-phpfastcgi.html) that talks about state and connection issues. The short answer to your question on state is that if your application is designed using a framework such as Symfony, Slim or Silex - for the most part the framework is suitable to be run over multiple request cycles (as they are designed to be well testable). That said, there are points where this breaks down (e.g. Symfony default session handler). I've spoken to core contributors to the Symfony project who are well aware that people that people might want to use the framework in this way, and they actively want to make it easier for them to do so. Fabien Potencier himself gave a fantastic talk on doing this with Symfony at dotScale: https://www.youtube.com/watch?v=gpNbmEnRLBU With regards to database connections, this is left to the developer. My advice would be to have logic in place for catching connection time out exceptions and then establishing the connection again afterwards (although you can just make new connections every time). I think you can extend Doctrine to do this (I've had the same problem with RabbitMQ consumers) but I'm not sure if it's part of the core?
We use UTF-8 because it is sufficient for Turkish but I'm not sure about other complex alphabets such as Indian, Chinese, Korean, hyroglifics etc. You may have a look at UTF-16, UTF-32, UTF-EBCDIC, [BLOB](https://en.wikipedia.org/wiki/Binary_large_object).
&gt; I didn't think people would take it this seriously to be honest. But your about page makes the site sound serious, like you're actually trying to achieve something rather than dicking around.
Was talking about the name, the intent of the app is serious yes, but the name I mean to me it doesn't matter that much. Have you seen the services and tools we use nowadays? Half of them are just random sounds thrown together with no relation to their actual purpose. To me as long as the name is memorable it's good enough at least. 
I'm pretty sure UTF-8, UTF-16 and UTF-32 cover all the characters (UTF-8 and UTF-16 are variable width) but there's a difference in preference depending upon language (UTF-16 is better for Asian languages than UTF-8 etc) and some other factor.
and those are the companies that you and I are supposed to shit on :D So GET BACK TO WORK AND STOP REDDITING! Time to shit on some people!
Not quite. It helps when dealing with variadic functions: $f = compose( map($mul2), filter($odd), ); Or in non-trivial `printf`. The changes for most of the other sorts of lists (interfaces, etc) are purely for diff cleanliness, it seems.
&gt; However, if it pleases some people, I don't see why vote against it. This is how you end up with an inconsistent mess of a language.
The trick is to make sure your application is not maintaining state where it shouldn't be. As pointed out in another comment, sessions are something that may need to be specifically addressed. In my own experience in another language but a similar approach: the largest single chunk of savings comes from not having to continually set up and tear down your application level routing configuration. Using other models you have to set up all possible routes and tear it down *every single request* even though you only used it *once* for a single path through those routes.
I disagree. Arrays, function parameters, implements etc are all completely different language features. There is nothing to be "consistent" with. You could just as easily argue that you should have semi-colons after the } in if/else/for clauses so it's consistent with variable assignment statements.
I feel like you didn't understand my point about consistency. &gt; there are no good points against it I already stated the points against it in my previous comment, so we'll just have to agree to disagree.
You stated your opinion on the matter, which is subjective. I should have said "there are no objectively good points against it". You just *feel* like it adds inconsistency. But that's okay, we don't have to agree on all matters. It's a good thing we were polite to till the end, even though you're a disgruntled goat. :)
But in this case it's being used in place of self:: which should make it easier to figure out where the class definition is...
Why don't you trust migrations?
I tend to use self:: only from within the static class, so why do I need to know internally which class I'm dealing with when I'm already in it?! It doesn't help with finding the definition because I just need to scroll to the top of the file (files really should only have the one class each, with few exceptions). My IDE is smart enough to know what type of class it is, and offers the right methods out as I'm typing.
&gt; go horse Non-native english speaker here, what does that mean exactly? Go fast? (a Google search didn't yield very interesting results ;)
But work is boring ...
but if you use self:: then there's no refactoring necessary. Also, not sure on the value of seeing how often a class refers to itself with internal methods, but that might be just because I've never had a need to do it before.
I am not a fan of migrations. I remember in Laravel 4 I had to use a raw query to get a timestamp column to default to "current_timestamp on update" Now laravel 4 is old, but it was annoying. I have always felt that I have more control with raw (schema and queries). With that said laravel migrations offers a VCS like system for schemas that you can roll back if needed in future changes
I know... That's why I rage quit my job and I am unemployed currently :D Fucking best life ever! screw work. I am building some GIF related shit for shits and giggles. 
If a class ABC has a static method ASD() that you refer to via self::ASD() and then you move ASD somewhere else, you will have a reference to self::ASD() that you now have to manually find and update. Instead I use the IDE to find classABC::ASD and update that to classNEW::ASD. Granted, you don't do that every day but it is just a habit that I picked up along the way :P
These seem like complementary tools. The migrations put the alterations to your schema in source control. The diagram tool gives you a great view of the current form of the schema.
I'm unsure what migrations give you. You can certainly write your up/down methods in plain SQL and PHP, the basic idea is very simple and doesn't require any special tooling. Your data is your most important asset. It can help a business thrive or grind it to a halt. So why would you wrap it in tools that play fast and loose with data? To save couple of lines of code? For the fancy syntax? Not sure it's worth it.
Are you sure it should be the NTS? It's my understanding that if you use php on apache as a module you should use the TS version... Also it seems that VC9 or VC10 versions can be used interchangeably. Apache 2.4.x introduces changes on the Access control syntax and my 3rd party app uses a lot of .htaccess files all around with those instructions.
If you do intend to use PHPFastCGI, I would recommend running several worker instances (monitored by supervisord) using NGINX as a reverse proxy. From my experience, NGINX will only fail if all of the worker instances fail (so your failover would be running multiple instances). Apache's mod_fastcgi includes a process manager (so you wouldn't need supervisord), but I'm not sure how it behaves if there is an error with one of the instances of your application. I'd also say that PHP-PM isn't stable either, nor is ReactPHP. PHP-PM hasn't tagged a release yet, which makes it difficult for them to respond to any bugs with fixes. Whilst I wouldn't recommend running PHPFastCGI in production for any critical apps yet - if there is an issue, I can respond to it and release fixes :) I am a big fan of PHP-PM though, if it wasn't for the talk Fabien gave on PHP-PM (I linked it in an earlier comment) I wouldn't have had the idea for this project :) Edit: and thanks for having a look at the code!
&gt; I am under the impression that writing raw SQL is annoying when I could create the same schema much easier using a schema builder tool Frankly schema builders are a 1-to-1 mapping to SQL so aren't really gaining that much. There isn't a huge savings in actual keystrokes and once written it never needs to change. What advantages are you hoping to see? 
I've always used the binaries from apachelounge with the NTS version. I was never able to use the TS with the precompiled windows binaries there. But again, it's just my dev environment, and I don't use FPM. I use a very default configuration. If you want to use FPM, I think you need to use the TS version. And looks like you are right. &gt; VC9 modules can be used with VC10.
It's only a sign of programmer error because it is currently an invalid syntax.
The answer is to write raw SQL: * When your tool of choice is no longer actively maintained and you have hundreds of migrations written using it's custom table creation API, you'll wish you had the raw SQL. * You need to know SQL if you're writing web applications backed by a database. Take the time to learn DDL. * You're going to end up writing SQL anyway if you need to added a stored procedure, trigger, custom constraint, complex primary key, or use a data type that doesn't have a 1:1 relationship with your migration tool. In Postgres, for example, there are a whole wealth of features that you leave out when you use a schema builder API. * Raw SQL is faster. * It is easier to debug. Worst case scenario, just copy and paste it into psql and see where the error is. * Raw SQL leads to faster development. You can muck around with your migration to get it just right must faster in SQL. In summary, just use Phinx, and write raw SQL.
[Vagrant docs](https://docs.vagrantup.com/v2/)
That is pretty bad advice and I think you are missing the point of "a migration" in terms of versioning schema's versus moving a schema (possibly with data) from A-&gt;B
&gt; I'm unsure what migrations give you. You can certainly write your up/down methods in plain SQL and PHP, the basic idea is very simple and doesn't require any special tooling. Do you apply this argument to other libraries/frameworks, too? Because you could write your own cURL class, you could write your own address formatter, you could write your own XML Parser, etc. The migration tool allows you to work faster and if some external guy comes in he doesn't need to learn **your** code, he only needs to know code that is used in many other libraries, too. Also, a big advantage - in my opinion - of a library is, that it's field tested. There can always be errors or use cases you don't think of.
Is the current migration system pretty "manual" then? Technically a schema builder is no different from writing the SQL but if the goal is social change then it might be helpful. It's not going to make writing the `down` one any easier ("DROP INDEX blah" isn't any harder than "$builder-&gt;dropIndex('blah')") but the entire framework works around `up`/`down` and it might be a strong hint to build the `down`. You could probably use tooling (and automated testing) to force developers to build the `down` while still using SQL. If you automatically tested your migrations both ways (a good practice anyway) then a broken test might get the developers to build and correct the down methods. 
http://sqitch.org/
There are classes in Wordpress? Anyway, it's just macho stuff. People are weird about programming.
If you can achieve the same results without Wordpress you're fine, otherwise I would say you're a Wordpress developer more than a php developer. But it's just an opinion. People define it how they want. 
It's my preferred migration tool, I don't care what you use, just use one. I'm saying migrations should be written **in raw SQL and versioned along with the rest of your application**. The last part is key, your migrations should be versioned just like any other piece of code. If you're diffing a database through a command line script, there's probably something upstream that's a bigger problem.
There is a huge stigma around Wordpress. The problem is that its is not very object oriented. 
Lots of answers for this one. In general, PHP is the development community's whipping boy. Everybody like to take a swipe now and again. Some people don't like the language itself and some people don't like how it's used. The worst thing about PHP is also one of its best. You can start programming PHP with damn near zero skill, setup, or tools. But that flexibility lends itself to sloppy code because PHP. Then you get to move on to WordPress - which gets shit on in its own right. But coding for WordPress is very specific. There are some things you can do and not do. But you - as a developer - can push your code to a higher level and still work within WordPress. I'm currently making a theme that uses classes, an autoloader, view files, repositories, etc. Or, I could have dumped it all in the functions.php file. PHP and WordPress don't care. It would not be out of line to question someone's knowledge of PHP if all they have ever done is convert comps/statics to basic WordPress themes. But to say developing for WordPress - across the board - isn't "real" is just classic "DAE think PHP/WordPress sux?!?!" circlejerk.
I had a couple of problems with Phinx. Never looked back after discovering Laravel's schema builder
&gt;People are weird about programming. This 
Yea it is. The worst part is the migrations actually can't even run with blank schema from the beginning. A sql dump is used then the remaining migrations can be run. I implemented a better integration testing solution for our web service (the existing one was extremely slow to run 7 min vs. the new 7 secs) in the process I rewrote all the migrations both up and down to match our current production schema using Laravel's schema builder tool. Now since we have essentially two sets of migrations we are trying to choose what is the best solution. I agree that if our CI server ran some automated testing and wouldn't allow committed code without both the up and down working that would solve the issue. &amp;nbsp; With our "broken" migrations now, this clearly causes CI, deployment complications, etc. &amp;nbsp; Edit: Added some content. 
The difference is what industry you're in. Are you happy with building blogs and extending wordpress from there? Sweet the world needs those. Your paycheck will prove it. Want to build a highly custom web application that doesn't quite fit the wordpress mold? That's a different type of PHP developer. Some of the skills you mention above do carry over, but there is so much to learn. But to look down on professions based on your path is pretty stupid. I know a ton of PHP but nothing about wordpress. I couldn't do a wordpress'ians job easily, and vice versa. 
Are you actually using this in production yet? I have been interested in something like this for a while, and was actually hoping to see an announcement from Fabien P. about running a Symfony application in this manner, as he demoed in one of his videos last year. By the way, do you use the Doctrine ORM? You would have to EntityManager::clear() after every request to not have bad side-effects right?
I don't think that's the only problem.
If you were running PHP-PM you would probably want it running under a process manager anyway, but you're right that it's easier to add instances (rather than editing server and supervisord configuration files). That said, it is quite easy to do using Apache's mod_fastcgi. Multipart requests is an interesting one! I was speaking to Matthew Weier O'Phinney who said that they (Zend Framework Team) were possibly going to release some PSR-7 middleware that performed this function. I'm keeping my eyes and ears out for that - if it becomes available it'll be integrated into the project.
It's because when you develop on Wordpress, everything is already made for you. Yes, any PHP development you do will be "real PHP programming". Wordpress is highly regarded [by developers] as a supremely bloated solution to the CMS problem. That being said, I won't turn down a $1200 "build me a wordpress site" offer ever. :D If all you're doing is extending wordpress and you are incapable of creating the default features that wordpress provides (blog, user system, etc), then you are a wordpress developer and NOT a php developer. Edit: Downvoters! Why? Make a point or something. I know quite a few people who work solely in WP and could never write any kind of app from scratch.
Well, I think if someone says I'm an 'X' programmer, then they are a beginner in general. Most professional programmers over the lifetime of their career will program in many different languages. Of course their are exceptions (like the steadfast assembly or COBOL programmer), but I'm talking about decades.
Besides the common language, developping with wordpress or a modern framework is very very different. Wordpress doesn't use any of the modern php techniques. Not even much OOP. For someone who has always been working with wordpress it's alright, but for someone who has worked with more modern tools it's very frustrating to go do anything with wordpress.
This is true. You would pretty much only use PHPFastCGI with Apache if you actually didn't have the option of installing NGINX. I might look at seeing whether a process manager would be a good idea. Thinking about it you could add in some really nice features (e.g. reloading application instances one by one to prevent down time as you suggested). Thanks for your thoughts :)
Since you're compiling the extension yourself, the compiler needs the PHP header files to build the correct interfaces into the binary. This lets the PHP executable and the extension library talk to each other. This is common for compiling any C/C++ shared libraries for any program. If you downloaded a pre-compiled package or the .so file itself for the extension, you wouldn't need the PHP source.
&gt; macho PHP purist those damn macho php purists
&gt; There are classes in Wordpress? Uh, yeah man. Lots of them. Ever have to do an SQL operation with $wpdb? Thats a class. Every widget necessarily has to extend the Widget class. Ever use WP_Query? I'm not saying they're well designed classes, but they're classes.
Those people are just talking shit.
a few answers here, but i'll give you an answer based on what people will hire for. So, in my experience there are two main kinds of sites: Simple "client wants it yesterday" sites, where you're just updating static content, or doing some kind of basic CMS activity, where Wordpress can come in and save the day. Then there's custom sites. This is everything else, your facebook, your reddit, etc. Typically these sites are custom built, and employ developers who are familiar with object oriented programming. So, if you want a job working for an agency making a hundred different tiny sites for 100 different equally demanding clients, then sure, you're a "php" developer. But if you want a job working for everyone else, your "php" experience in wordpress will count for squat, mainly because you will only be showing them you've learned the worst of bad practices, and have no idea about OOP, MVC, or any other fancy popular acronym that exists these days. So no, this isn't some "macho PHP purist conjecture" but rather two very different classes of developers, where one has more experience and makes more money and gets better jobs, and the other is just new to this whole idea of programming.
When I identify the provided value in a library, of course I use it. This is why I'm asking what is a migration library giving those who feel they need it. I see only limitations and short-lived magic shortcuts to achieving what wasn't that hard to begin with. SQL is extremely declarative, the schema altering commands are literally asking the database to do the work for you. Likewise for porting one format table to another: in many cases you can do it all in a single INSERT INTO foo SELECT ...; And your argument is so generic, you could have literally copy-pasted it from an entirely different thread: &gt; Do you apply this argument to other libraries/frameworks, too? Because you could write your own cURL class, you could write your own address formatter, you could write your own XML Parser, etc. &gt; The $INSERT_TOPIC allows you to work faster and if some external guy comes in he doesn't need to learn your code, he only needs to know code that is used in many other libraries, too. Also, a big advantage - in my opinion - of a library is, that it's field tested. There can always be errors or use cases you don't think of. ... And the question what *exactly* value does a migration tool provide remains unanswered. If some "external guy" comes, by the way, chances are he knows PHP and SQL before he knows some flavor-of-the-month migration tool.
I am running OSX and I found this guide: [http://coolestguidesontheplanet.com/install-mcrypt-for-php-on-mac-osx-10-10-yosemite-for-a-development-server/](http://coolestguidesontheplanet.com/install-mcrypt-for-php-on-mac-osx-10-10-yosemite-for-a-development-server/). I do have a virtual machine but when I run composer update locally I get all sorts of warnings if I don't have mcrypt extension.
This. I think an analogy would be cooking. If you only know how to make boxed food with instructions on it, but do not understand how it is actually made, you aren't a real "chef" in a sense. Sure, its cooking, but it doesn't qualify someone as a real cook.
Ran into [this guy](https://www.reddit.com/r/webdev/comments/3r3d6e/hey_rwebdev_what_are_some_open_source_wp/cwktt5g) the other day
I've been using [PHPMig](https://github.com/davedevelopment/phpmig) with Doctrine 2, much easier to work with than Phinx personally. Seems to have Eloquent support as well and pure SQL.
&gt;Here's an article Didn't even need to hover over it to know what it was. 
What you could do is use an ORM layer (I used doctrine) to map to something structured and sensible. That way you can have a somewhat sensible way of accessing the bad db without completely loosing your mind or and not actually change the db structure. I don't know the code, and from what I read, a db refactor seems inevitable in the long run, but that's just me 2 cents
Thats what I have been using as the migration system right now but not sure if our team is going to write raw sql or use the Laravel implementation.
And then he suggests node.js as a good alternative. Yes, javascript is soooooooooooo much better than php. /s
They must be referring to Drupal 8 and Magento 2; neither of the current frameworks actually use Symfony components. Though Drupal 8 is being released this month! p.s. Happy cakeday!
I don't know what you did to grab the file and you didn't answer my question. Did it look like that on the server with all those weird characters? Assuming you used FTP, perhaps you had the transfer type set incorrectly and it mangled the encoding. Try grabbing it again in "binary" transfer mode and put it on pastebin again. It *should* contain only ASCII but I'm not sure what the attackers have done. Whatever the case you should note the server or at least the virtualhost is compromised. That file is more than likely a PHP backdoor.
http://threevirtues.com/ &gt; Laziness: The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful and document what you wrote so you don't have to answer so many questions about it. If you were "truly" lazy you would write the code in a way that it would maintain itself so you never have to do it again, so the long term solution people are in fact actually lazier than you. ;)
&gt; and (IMO, at least) this is fairly straightforward what's going on. &gt; Also note that one of the intentions for the two argument ?: is to set a default **value**; I think people just don't use it very often. To me it isn't straightforward. My basic assumption would be that the ternary operator returns a value, not a variable from which references can be pulled. You proved that my assumption was wrong and I learned something today, which is cool, but in no way straightforward to me. 
Not sure what SF2 is, for twig - we do support mustache which is somewhat similar, you could try that. I'd definitely be interested in adding twig support. For the record it's not very difficult to add support for it yourself, see the [Mako addon](https://github.com/creiht/komodomako) for example. Note that most of what you see there is boilerplate.
Are you the one that posted that a week or so ago? Someone just showed me a WP API but it wasn't an official plugin.
&gt; Also concurrency can screw you over entirely. If something goes wrong you can corrupt the entire tree. Which should not be an issue, just lock the table as needed. The fast reads are worth the "slow" updates. So I'm not sure what you're achieving here. Updating 1000 rows in a single statement or transaction is a joke. ~~Considering your worst-case, I don't think this is worth it.~~ Edit: Misunderstood something, probably still do. Don't you lose all the neat queries usual nested sets let you do?
&gt; You are massively overstating the benefit. I'm giving a clear example of how it improves things, not claiming that adding an extra comma is going to provide sexual favors to all those that desire them. It makes a small improvement in your workflow every so often. It's not like short array syntax which you use near-constantly. I *would* suggest that the detractors are overstating the downsides, though. &gt; Besides, language features should not be decided by faults in tooling. In an ideal world, I'd agree with this statement. But the reality is that everyone uses the same tools (git, hg, and svn) - all which have this issue. Software based on ideals usually languishes while software based on the unfortunate reality of the world we live in thrives. PHP got where it is today because it's easy to use, not the pinnacle of technical ideals.
But you cannot edit all the nodes translations from a single screen (using tags to switch between content), right? You have to go to a "Translation" tab, select the language and another screen will be opened. 
Ahhh gotcha! We are likely going to be plugging into PSR-0 mechanics, giving you better support for frameworks such as Symfony 2, which as far as I can remember uses PSR-0 style autoloaders.
&gt; To me it isn't straightforward. My basic assumption would be that the ternary operator returns a value, not a variable from which references can be pulled. Ha! You know what? You're absolutely right and this is actually a bug in php (as of 5.6.14! Also in 5.5.16.) and it shouldn't work. :) According to the [ternary operator documentation](http://php.net/manual/en/language.operators.comparison.php#language.operators.comparison.ternary): "Note: Please note that the ternary operator is an expression, and that it doesn't evaluate to a variable, but to the result of an expression. This is important to know if you want to return a variable by reference. The statement return $var == 42 ? $a : $b; in a return-by-reference function will therefore not work and a warning is issued in later PHP versions." *Sigh* Ah well, guess I'll file a bug report.
Just because they share one common trait doesn't mean they should be treated the same. A better example might be that classes and functions have braces, but namespaces don't. They all follow a pattern, let's call it "nested scoped blocks" which is similar to your "list of stuff" pattern. There is no call to add braces to namespaces just to be consistent with classes. Look, I'm not completely against this feature, I'm just trying to point out that certain arguments people keep bringing up are not logical and should be discarded.
No, I am not. I haven't had a chance to use this yet, but it looks promising.
What's the use-case of moving from A -&gt; B? Practical, not theoretical, I mean. Versioned schema is great for history and setting up new environments, but I've yet to see any scenario where code-based migration trumps native database tools.
The actual style of PHP in wordpress is perceivably different. It's not No True Scotsman in the slightest but an observation of Code-Style. When you begin to implement something in Wordpress you take a completely different approach to almost anything else built in PHP. You could be a pro Wordpress PHP function fiddler and have no clue in the slightest about how to use PHP without those abstractions. The approaches are so different as to be separate things. You can know how to wrangle wordpress PHP without knowing PHP.
Gee .... So make a module to fit your needs, Drupal is driven by open source contributions. The functioanilty is there, your specific snowflake website requirement isnt and without writing custom code for any CMS you choose to use.... You'll never find a suite of modules/code that does 100% what you want, _how you want_, without custom effort.
Phpstorm's SF2 plugin (it's not an official plugin but community-made) auto-resolves services using `$this-&gt;get('service_name');`, auto-detects what variables are available within twig templates, auto-resolves SF2's shortcuts for URLs, twig template files, routes, etc. It's quite an extensive and in-depth plugin that makes working with SF2 quite easier.
Definitely. Previously I had to utilize the RSS feeds to pull content into different instances but that's rather limited depending on what you are trying to do.
This (sometimes) works for DDL, but it's impossible for most DML.
Absolutely - http://forums.devshed.com/php-development-5/php-fractal-bad-design-hardly-929746.html
Meaning he didn't even read the article he's linking, as several of the points against PHP there are also points against JS.
&gt; a guy who replaced his own alternator by following instructions from a Chilton's manual then says he's a "auto mechanic". More like the guy who changes his wiper blades and says he's an auto mechanic. Nothing wrong with following tutorials or 'borrowing' code from SE, it's how most of us learned and there's *always* some level of troubleshooting when it doesn't work perfectly in your environment vs the tutorial's environment.
Not a bad idea. In hindsight though I think I was pulling from a site we didn't admin (with their permission).
That's the nice thing about community contributions, they do not share your resource limitations and deadlines, they can spend as much time on any one feature as they like, and you will end up with awesome features like this :) This is totally possible in Komodo as well, and while we will make an effort to provide integration with frameworks natively we would not be able to compete with one dedicated developer dedicating weeks of his time to create and maintain an addon unless we ourselves would do the same (at the cost of the rest of the IDE).
Much better analogy. Thanks.
Also followed by "I've not used PHP for a long time"...
Part of the JSON api is going to be in core for the next release: https://make.wordpress.org/core/2015/10/28/rest-api-welcome-the-infrastructure-to-core/
Okay, I was just asking how / why you chose it over other solutions.
Exactly. Carpentry is child's play compared to putting together IKEA furniture. 
If you have node installed, [dploy](http://leanmeanfightingmachine.github.io/dploy) is super easy
Aside from knowing how to use common library features to do things (e.g. curl vs guzzle), I'd say the primary criteria is whether or not you do actually understand PHP as a language - you have full mastery of its syntax and aren't relying exclusively on the framework/library to handle more complex things. Suffice it to say, you cannot work with Symfony if you don't know the syntax of OOP (putting aside OO design for a second) or any of the other language constructs such as arrays, loops, conditionals, functions etc. To your point, not knowing how to use curl because you've been using Guzzle or something similar so long doesn't necessarily make you not a PHP developer. You do at least know how to pull in Guzzle, and use 3rd party library code. This means that your skills are portable to other non-Symfony projects. And I think that skill portability/transferability is the benchmark. Can you ONLY work on Symfony projects, or can you jump into a raw PHP project as well? For Wordpress, could you jump into Symfony and learn ONLY Symfony APIs, or would you also have to learn language-level PHP stuff in addition to Symfony (e.g. you don't have transferrable PHP skills).
I'm a 30 year old dude back at uni getting my slip of paper that says 'he can code gud'. I have never seen so much blind hatred for php. It's funny how when I call them out on it and ask them why it's so bad , they can't seem to give me a real answer. They read a shitty blog article and think they're 19 year old gurus. 
Or even better: php-fpm with apache's fastcgi handler.
Got it - sorry for the defensive attitude :) Mostly because it was framework agnostic (it uses some Symfony components), it supports multiple database environments, and supports writing raw SQL. I originally started with DoctrineMigrations but development stalled for a year so I had to search for an alternative.
It isn't _meant_ for DML. It's meant solely for DDL statements.
All fair. I didn't mean to be divisive or argumentative. I was exploring your point.
I think a lot of people get their start that way. I started out with phpbb plugins 10+ years ago at first just installing/uninstalling plugins which involved manually editing pages, then making my own plugins, then just making my own platforms for personal use. If you work with php you are doing php development whether its simple or complex or part of existing platforms, whatever gets the job done I'd imagine. 
&gt; It's because when you develop on Wordpress, everything is already made for you. Having things built for you is not a bad thing, as long as they are built well. Unless you are writing your own operating system or writing in assembly code or building your own processors or smelting the metal for those processors, you are basing your work off of someone else's work.
&gt; who-doesnt-use-symfony The definition of cherry-picking.
Satire.
Wow, I've never heard of the "No True Scottsman" fallacy before. Sometimes I feel like I'm not a "true" programmer because I don't code in an object oriented style, etc. etc... But now I'm feeling like maybe I am a "true" programmer :)
&gt; I am under the impression that writing raw SQL is annoying when I could create the same schema much easier using a schema builder tool, but all of my coworkers do not share the same opinion. Yes. However, there is a reason work is...well...work. 1) Schemas need to version'd along with the code. Its easiest to do this with raw SQL. 2) What happens if you need to change frameworks or your framework is no longer maintained? Or the tool you use? 3) Honestly, the "schema builder tools" aren't very good at building indices and for relatively complex schemas I've been able to get significant performance gains by not using them. 4) You frequently lose out feature-wise as these tools try to map things 1:1 to their representation with an ORM. Sometimes that creates problems. 5) Frankly, you can get away with using ORM and schema migration tools as long as you have straightforward, relatively simple site. Just be sure to dump the raw SQL for the schema [i.e. create table, not data] somewhere and version it in git. That way if you want out [and you probably will eventually] you can do it without trying to guess the version history of the database.
I do both (in fact I do more than PHP and WordPress); It neither adds to my credibility (or anyone else), or detracts from it (or anybody else). I Do find that knowing PHP more intimately before the advent of frameworks and WP has helped me as a developer; and that knowing things that are not WordPress really help as a developer; and lead me to make judgements on some of the hap-hazard methods WP uses; but at the end of the day it's generally results people pay for, so from a corporate perspective it doesn't matter.
I think it was meant tongue in cheek tbh and nothing wrong with a bit of healthy friendly competition, we all benefit.
It's a good read, but I also have to agree with Disgruntled__Goat here, listing wordpress as an example of how good anything really rapes the argument.
We can, but can everyone else also stop pretending "their shit doesn't stink"? Every programming language I have ever learned has sucked donkey balls in one or more area's, so PHP's hardly a flower of the forbidden valley in that sense...
excellent work as usual 
Sure, and that's fine, as long as you realize that this: &gt; you can take the database from its state at any given point of time to a different state for a different point of time. is demonstrably false because of what I said. And that simply taking DDL from one point to another will not leave your database in a functional state for any non-trivial application. My point being that, while versioning your schema is great for all kinds of reasons, migrations (ups/downs) are mostly pointless.
Slightly off topic, but you should be using openssl instead of mcrypt if at all possible.
Sure. * You can't migrate data in most cases, and can only migrate some subset of schema without breaking your application, so I don't see any use case in which migrations are useful or practical. * Keeping your schema in version control is useful for 1) seeing how it has changed over time, and 2) setting your application's schema up in a new environment (e.g. a staging or development environment). * Code-base migration (ups/downs) are so limited in their usefulness, that I have yet to see any case where they are better than using the tools that came with your DBMS for doing changes, rollbacks, etc.
That title ^^ I have been told I'm not a real engineer since I use PHP primarily. But pound-for-pound the projects I have worked on poop on monolithic enterprise stacks in terms of all the metrics that really matter. And some of those projects were wordpress. If you contribute to the community and build good code that passes public scrutiny then you grew up to be "real" developer Pinocchio! 
I remember that article. People grasping at things to hate. My team lead at the time was hard corps Java guy. He would take every line item and ask me about it. It was a painful week. 
I agree 100% And maybe that's what makes me a shitty WP dev instead of a real php dev. I definitely have the capacity.
Is this thing threaded? Wondering if it can run for days at a time. I tried this once a few years ago and it was a bugger. 
Yes, use brew or vagrant and a vm. From my experience compiling things on Mac can be a total pain in the arse. Totally possible but open to lots of potential issues. 
&gt; that's a domain concerning itself with presentation responsibilities I think that's stretching the definition of "presentation" the point of meaninglessness. (/me shrugs) &gt; Your domain returns viewmodels. The Domain returns a Domain Payload. &gt; don't speak authoritatively as if it as a practice anyone but you implement, as it's evidently not the case (/me shrugs again) The OP asked for advice, I'm giving it.
We all have that kind of guy in every IT classes in college/university. If it's not about programming, it's about brands.
http://php-osx.liip.ch/ is an option as well. Installs everything together as a binary. Very easy.
I think the term you are looking for is Script Kiddie Professional Developers: * about scale and performance of the code they write * think about how their code interacts with other components at a large scale * could write the same thing in multiple languages and understands the benefits of each one * designing something to be maintainable * tries to learn more than just what they work with (you may know PhP but maybe start playing with Haskel for fun) Scriptie Kiddie: * uses 90% of someone elses work * understands just enough about it to make it work * when shit breaks, they say "it's beyond my paygrade" instead of working on it until they figure it out * considers themselves a 1337Hax0r 
Maybe the right term is "Frontend Developer" while PhP is both a back/frontend language, the JavaScript, CSS and HTML to style and make a page nice is more frontend than anything else. 
I work on a system that handles upwards of 30,000 nodes in a single tree with multiple trees in one nested set table. We found the easiest and fastest way to update a tree is by converting a tree to an adjacency list, then converting it back into a nested set. of course we do our processing between those conversions which takes the most time. we also maintain and restrict access to that structure to ensure whatever is writing to it is obeying the locks we put it in place. 
I don't understand why /u/mikegustafson is getting downvotes but /u/cpayan is getting upvotes. Pretty much every function in wordpress that saves to the database is at some point using `$wpdb`. I'm talking about `wp_insert_post()` or `update_option()` or `add_post_meta()` etc. To access the database without it means you're either using PDO or `mysql_connect()`. If you do this your plugin or theme is *probably going to break* if someone changes the database prefix or is used in a WPMU environment. Not only that but you are creating extra open connections to the database which ultimately will slow down page loads. You could probably negate this cost by using cacheing but thats no excuse for poor programming practices. Accessing the wordpress database without at somepoint relying on `$wpdb` should be considered A Very Bad Thing(tm). 
There is no good php code in WordPress... I guess they're php developers but now exactly respected. WordPress code is a big php embarrassment.
Hell they teach this as a required class for a degree I'm pursuing, 4 weeks in,I still have no idea what the fuck the loop is supposed to do. Is it looping because it executes based on whether you have posts available? WHAT IS THE CRITERIA for it entering the loop?
Um if an interviewee comes in with nothing but WordPress experience it's pretty much a sure shot I'm wasting my time.
Thanks! :)
Just to be clear, Im actually happy to see all these improvements on Komodo. Congrats on this release! Speaking of docs, you might want to consolidate it with the [old activestate docs here](http://docs.activestate.com/komodo/9.2/). And maybe add a prominent "Documentation" link in the komodoide.com home page. I have to scroll all the way to the footer to find the link. 
Interesting...
Yep, we only JUST launched the new docs site, so some old links still need to be updated :) Thanks for the suggestion!
Completely agree on Wonderwall, mind you.
Everyone seems to miss the second part of that sentence. &gt; ...that would be at all analogous to a house "where every room is a pentagon and the roof is upside-down. And you knock on the front door and it just collapses inwards." We all know WordPress isn't perfect, just like all software isn't perfect. But WordPress core is hardly one sneeze from falling over.
&gt; ...that would be at all analogous to a house "where every room is a pentagon and the roof is upside-down. And you knock on the front door and it just collapses inwards." WordPress core is a long way from falling over on itself. It has issues just like every piece of software has issues, but most of WordPress' bad rap comes from weekend warrior 'developers' making one-off plugins and people using them far past their expiration date. See: any plugin that still includes timthumb.
I think he absolutely understands that the arguments aren't going to convince someone who agrees with the article. The author of the original article showcases his ignorance of the language and the reasons why the language exists in the form it does. As you've said, if you think your languages should be strict, you're going to hate PHP. If you think your languages shouldn't fall back to 'guessing' sometimes, you're going to hate PHP. If you enjoy the loose and flexible nature of PHP, you're going to hate Java. It really is two schools of thought, and honestly I think ManiacDan covers that quite well. However, to insultingly write off an entire language because your experience is limited and you don't like dynamic typing is frankly a shitty way of thinking, and I think that was the main point of the rebuttal. I'm a PHP dev. I work with Java devs. We ported one part of our site into Java because it was a better tool for that part of the site. I don't shit on Java for being the right tool for the job, and the Java devs don't shit on PHP for not being the right tool for the job. We made them work together in a positive experience for the end user, because that's what we do. We both use frameworks when it's appropriate and don't when it's not. So it's not about whether or not PHP sucks. All languages suck for some things, and all languages have idiosyncrasies that make even seasoned devs shake their head and sigh. It's about whether or not PHP has strengths that make it less shitty at some tasks than other languages, and it certainly has that. It's not a "Fractal of Bad Design", but rather a different way of thinking than the author's. I guess my point is I'm not going to say a paint sprayer is "bad design" because I'd rather use brushes, and I wouldn't say brushes are a stupid idea if my job is painting buildings.
This is my favourite answer. I've found that this flexibility of PHP makes it a good proof of concept tool and I've used it to it quickly knock something together without having to get bogged down in deep design decisions and long set up times. In my junior days, I didn't know how to structure WordPress sites any better than putting everything in functions.php. My first WordPress project, built from scratch, had most of the code in functions.php. To be fair, the project was small when it started so it didn't seem so ridiculous at the time, but as the project has grown, it has become unwieldy. I find myself apologising regularly with development teams that have to spend any time with my spaghetti functions. Definitely don't do this, I'm still maintaining that codebase 4-5 years later.
This is me as well. I moved over to PHPStorm last month from Komodo IDE after watching a coworker use it and haven't looked back. I did enjoy Komodo IDE and Edit for many years, but since moving on to PHPStorm I now chalk it up to blissful ignorance.
I'm not sure that works either. As a "real php developer" (as defined by this thread for better or worse) I have immense respect for good front end devs. Those aren't skills that I've focused on in my career and as such don't know all the intricacies of CSS and don't have a mastery of many JavaScript frameworks. A good front end dev can take a design and make semantic markup from scratch. They know which tools use best practices and they make my job easy. That said I've had a hard time finding them in the past because I end up meeting people that can only edit pre-existing WordPress themes or download a jquery plugin but can't write JavaScript. Maybe it's a matter of semantics that's at play here.
Writing raw SQL is annoying for people who dont know SQL, not for people who do. My opinion is that schema matters and you should use the language of the DB to modify it. This makes it portable as well as readable by someone who knows just the DB not the DB plus a migration/query builder syntax. Laravel migration tools seem cool, but they have some real magic mojo that would concern me on a large, non-hobby project.
&gt; This (sometimes) works for DDL, but it's impossible for most DML. You made a fairly strong assertion without any explanation or detail. Please define how it's "demonstrably false" and what you mean by it only sometimes working for DDL. I'm also wondering why you would want DML in there. The sole reason that I can think of is to perform data transformations before, after, or in-between alterations. This is a thing that I have done, with production system, using migrations. It let me test the changes out on a dev box in a deterministic, repeatable way before applying it to the real deal. It doesn't come up very often, but is a very real and very functional way in which even DML ends up working in migrations. Is there some alternate reason why you'd want DML in there?
Thank you
I honestly don't care what we use but the issue is the current system DOES NOT work if no one is going to write the down migrations and the other thing I proposed does not work if everyone is not on board..... &amp;nbsp; The reason for the post, however, was to try and get a perspective of what other developers use to see how their opinions compare to the people I work with. I am new at this company and still an intern (though will be full time in January) so I don't want to be the *intern* that is trying to pick the easy way, but all I know is how we currently do things does not get the job done cause it was not enforced to have the migrations completely written. And since I rewrote all the migrations they want me to propose what I had used to see if that would be a better solution, but the real problem is enforcing that the migrations are complete.
A preg will still work, you just need to be more creative with it. Stick a bunch of PHP keywords that are usually found at the top of a file into it to strip all initial comments. This won't work straight off, since I haven't tested it, but something like this should get you started... %^\s*\&lt;\?php\s+(\s*//.+[\r\n]+|\s*/\*(?:.*\s*)+\*/|\s*#.+\s+)*% Broken down: %...% -- Delimiters ^\s*\&lt;\?php\s+ -- Match &lt;?php at start of file, with any amount of whitespace and newlines allowed before (just in case) and after. (...|...|...)* -- Match either of the three comment styles contained within - or none, should a file have no initial comments. \s*//.+\s+ -- Comment type 1. Match any amount of whitespace followed by "//", and any amount of characters up to the end of the line. Also collects the newline/return and any blank lines following. \s*/\*(?:.*\s*)+\*/ -- Comment type 2. Match any amount of whitespace followed by "/*", and any amount of characters AND whitespace/linefeeds/returns up to the next "*/". Also collects the newline/return and any blank lines following. \s*#.+\s+ -- Comment type 3. Lines starting with "#". 
Thanks. Gonna have to dust off the reflex part of my brain and give it a try. 
&gt; I think that's stretching the definition of "presentation" the point of meaninglessness. (/me shrugs) I did spell out what it means, you're simply choosing to ignore it. It means your domain is intimately aware of the presentation structure. It knows how the information is split in pages, because you suggest it has separate API calls for every page and what data exactly is shown on every page. A mobile app won't be just the verbatim non-HTML version of a web site, do you realize this? It means you need a new "domain" for every client you support with you APIs. That's a quite wasteful way to design APIs. The conclusion for me is that you either don't, in fact, have a differentiated clients and domain, or you refer to your actual controllers as part of your domain. Why even have controllers, if your domain is designed **precisely** for your website? Such a custom tailored domain might as well read HTTP data, because it doesn't fit another client. You have nothing to gain from the separation, if the controller is literally nothing except an automatable proxy between HTTP and domain.
&gt; It means your domain is intimately aware of the presentation structure. Not at all. The Service Layer knows what to return, the same way any individual call knows what to return. I know you're not convinced, and that's fine, so I'll let you have the last word here.
PHP is back end code. It runs on the server. 
&gt; The Domain returns a Domain Payload Unsurprisingly, when I searched for "domain payload", first result was the guy who claims to have invented that "pattern" and basically all subsequent results are...you talking about it. 
OK, that's fair. I do still have some disagreements, but nothing truly substantive. Thanks for explaining.
I personally HATE people who denigrate php developers, and I seem to run into them a lot, that said Wordpress itself is built on a code base that harkens back to PHP3. It's largely procedural and untestable mess of a security hole. The php world has moved on and Wordpress hasn't. Developing for it willingly I do believe says ... something.
I frequently hear "Waa, the needle haystack order is inconsistent " no it's not, shut up. It's consistent by type, eg string vs array. 
If you really want to understand, try different approaches and see what happens, see how the code becomes, look at the result and see if it seems clean, is easy to read, try to change it and see how easy / hard it is to change. If you really just want to have something that works, just do something and don't worry about it :) The email seems to be tightly coupled with this specific form. (unless you want a generic form-email-model). So, in this case it doesn't matter so much. You could write an email model that takes the form model as input and returns true on success. So the controller could do something like $form-&gt;validate(); $email = new Email(); $email-&gt;sendForm($form); $view-&gt;success(); does that make sense? I'm not sure :)
I would avoid Drupal. I use it too often and to me it just complicates things that could and should be simple. Module for everything™ My personal favourite CMS is [Craft](https://buildwithcraft.com/). It is really powerful and you can set it up how you want (content types, tags, sections). It [doesn't have a multi site manager built in](http://craftcms.stackexchange.com/a/409) but depending on your requirements you *could* maybe get it to fit your needs somehow. I would recommend at least doing a simple prototype, its definitely worth checking it out. :) [ExpressionEngine](https://ellislab.com/expressionengine) has a [multisite manager](https://ellislab.com/expressionengine/user-guide/msm/) but I don't think it allows sharing content between sites. Also, unlike Craft [localisation isn't built in](http://eeinsider.com/resources/multilingual-options-expressionengine/). 
Listen to this guy, couldn't have said it better.
Please could someone break down what skills and experience would be required for each job? - Junior PHP developer - Mid weight (or whatever they call it) PHP developer - Lead PHP developer I'm not sure where I stand on the career ladder and would love to know what each title requires so I can aim to learn those skills. Thank you so much.
It's really wrong when you use mongo and work with it as with a relational db like in the example
The main problem is that wordpress and PHP has such low barrier to entry that a lot of shitty developers use it.
Hi, could you post your example, please?
My gut-reaction is that you should use Apache magic only reluctantly, so that your PHP code is more portable and less fragile.
https://www.reddit.com/r/PHP/comments/3qh2q7/fullstack_based_on_angularjs_phpsymfony2_mongodb/cwf4gu9
If you have even possibility that your data will have relations (90% it has) then mongodb will bring you in the world of pain... I know it because i was there. Schemaless-design is useful only for data aggregation. But this means that mongodb never should be considered as primary data storage. It is useful if you have complex queries with multiple joins, unions and stuff. In this case you just aggregate data of this query into mongodb collection and use it to speed up queries (like data preprocessor). Only in this case all this schemaless stuff is really useful. Learn [CQRS](http://martinfowler.com/bliki/CQRS.html) for more details. p.s. Also since you shouldn't have relations between documents (even in single collection), there is no need to use ODM. This is just pointless since we should use it only for read operations.
That's great. Sorry to be a pain, but if I wanted to make it so the page would only display "Hello" if the referrer was X but NO cookie by that name was detected, how could I do that?
 $ref=$_SERVER['HTTP_REFERER']; $domain_search = "domain.com"; $ref_site = parse_url($ref, PHP_URL_HOST); if (preg_match("/$domain_search/i" , $ref_site)) { if(isset($_COOKIE['testname'])){ echo "&lt;div&gt;Cookie detected!&lt;/div&gt;"; } else { echo "Hello"; } } 
I have a question, which probably I should've started with... what is the responsibility of a controller to you? Calling the domain isn't a goal in itself, it's the means to some other goal. So what is the goal then? I suppose your controllers don't require distinct classes at all, they can be created declaratively: new GenericController(DomainClass::class, 'domainAction', ViewClass::class); Is that it?
Depending on what has to be done, PHP development without resting on an existing application *may* require more skill. WordPress development is actual development, but in scope it's relatively narrow. If your job is best done on WordPress, that's not a detriment. As for arguments about what's real and what's not... those are pointless: https://en.wikipedia.org/wiki/No_true_Scotsman
I've used Craft, Wordpress, Joomla, Silverstripe and many more, they all do their thing nicely but all suffer from either too much "correctnes" or completely lacks "correctness". Drupal has so far managed to mix the two pretty well, but at the same time you will have to tailor your development to the "Drupal" way and trying to shovel development practices and circumventing the built in API will end in tears and hatred of life. Yes Drupal is complicated and yes sometimes it eats more time than it should having said that; it scales, has a massive community and sounds like it fits mostly what you want, also is most flexible. @_tenken points out, you will not find one that fits the bill 100% but something that gets you close and then you will have to do the heavy lifting yourself.
I doubt it, since the servers will still draw the same power from the PSU.
It's not the same thing. I've had guys interview for PHP positions with wordpress/joomla/drupal "experience" who didn't know what magic quotes were. 
Read the book PHPUnit Essentials by Zdenek Machek, it is helpful: http://www.amazon.com/PHPUnit-Essentials-Zdenek-Machek/dp/1783283432/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1446719903&amp;sr=1-1&amp;keywords=phpunit
Get yourself a nice cup of coffee and have a read through this for an afternoon: http://www.phptherightway.com/ Even just breezing over the concepts for now will give you great insight into the vast possibilities for improving, and it's general knowledge you can take to any platform. It's plain and simply good coding practices, then you apply those practices to your work within WordPress. But I feel a key is that whenever you come to a problem, don't think "How can I get this done, now." think "What's the most elegant way to get this done? What's the best way to get this done?" It may take you some noggin scratching, but the result will be cleaner more efficient and more manageable code, and you will be writing less code more often than not. The unfortunate thing about WordPress is that despite it's best intentions, it is fairly poorly written, and so you can't learn from it. It's fully of bad practices, and the plugins and themes marketplace is the same. It was never written to be the most popular framework for the web, it was some guys bedroom project, it just so happened to be easy enough to digest that it caught on. It's the Justin Bieber of the web platform space. But if you put yourself into a good framework you can use the framework itself for inspiration, by reading it's code. It's similar to the notion of keeping good company. Spend time working with good code and you will learn from it really quickly. You can take a stab at some other frameworks, Laravel is a great place look. Laravel is very modern PHP, always using the cutting edge in PHP language features and built using some very high level but easy to core concepts for good code organisation and quality. It sets a very high (but easy to achieve) standard. 
you may want to read this book: http://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530 then these ones: https://leanpub.com/u/chartjes 
None of that means it is well-designed.
De nada :)
Nothing, but it can protect from common issues with applications themselves.
Who is that Sergey? What are his other works? Do we know anything about him and his level of expertise?
Do the 'context-sensitive' changes to the parser in PHP7 mean that *in theory* we could now use different characters for certain syntax? For example, using a . or : as namespace separators instead of \ ? Not saying it *should* happen, just wondering if it's possible.
What is this book worth ? Just a copy/paste of the documentation ? Or something worthy ?
Does $_SERVER['HTTP_AUTHORIZATION'] not get set? You could also use [apache_request_headers](http://php.net/manual/en/function.apache-request-headers.php) for the interim if that variable isn't set. -- edit -- A quick Google search found this on the subject: [apache pass authorization header to php's server http_authorization](https://devhacksandgoodies.wordpress.com/2014/06/27/apache-pass-authorization-header-to-phps-_serverhttp_authorization/)
Thanks for the review. Won't buy this book.
Yeah, since it's based in New York. I don't know why they decided to go with the terms "Multimedia Programming" rather than just playing it straight 
Hi Ozymandias-X, thank you so much for this great reply. This is exactly what I was hoping for. I would say I'm I fall into the top endnkf the junior level. Any advice on getting to the middle level?
I've already read through PHP The Right Way, thanks. I agree that it's a valuable and important resource for all PHP developers to read. See, the reason I'm interested in "WordPress The Right Way" is sometimes, you are just forced to use it. In my current work, I'm the lead developer of a SAAS that runs on WordPress. When I went onboard, the business has already invested too much on it. It's relying on a WordPress plugin to do bookings, for example. And it works. Until we come up with a module to generate revenue, we're sort of "stuck" with WordPress. Sometimes, you just don't have a choice. I was wondering, again, if there's a "WordPress The Right Way". Google doesn't really help much because, as you mentioned, it's full of bad practices and not all resources available reflect what I've learned from good PHP resources like PHP The Right Way. EDIT: And if you're talking about the theme I mentioned above, it was just a side project I took and tried to apply good PHP practices with it. Same problems though: it works, but I did not feel as satisfied.
Yeah, but those common issues can also be prevented by good programming habits. :)
Unfortunately it looks like forcibly re-encoding it with that command is doing what the unphp link does above and strips out the characters we need to make sense of the whole thing. Otherwise I don't see the PHP making all that much sense but I could be wrong.
Well, I'd place myself in the middle of the developer tier. The thing that helped me most going from junior to dev was rubbing minds with people who knew (and still know) waaaaay more than me. 
Agreed -- I stated wrong... I meant taking the malicious files, and taking them back to vanilla-php-esque so I could see what they were doing. Not that I was using that to recover files that were mangled from malware. My work has the best "backup solution"... GitHub, or at least that's what they think we're paying for.
I'm happy that it is a bug instead of an inconsistency in the syntax, thanks for letting us known and good work on finding it in the first place! I'm a fan of clever programming myself, I like to write short and concise code and sticking to descriptive code and `if/else` everywhere can be boring when working in a team.
https://jtreminio.com/2013/03/unit-testing-tutorial-introduction-to-phpunit/
I'm sorry, I don't. It's just something I've started doing. But I assure it's not complicated. **functions.php** &lt;?php use Theme\ThemeClass; new ThemeClass(); **ThemeClass.php** __construct() I do general loading here. Stuff that has to be early. Theme constants, set any classes we will need, fire of an init(). init(); Here I fire off methods that use what I set in the constructor. For example, I have two classes that each have a custom post type defined within them. /** * Add custom post types needed. */ public function addCustomPostTypes() { register_post_type('auction', $this-&gt;getFirstCPT()-&gt;get()); register_post_type('contact', $this-&gt;getSecondCPT()-&gt;get()); add_action( 'init', function () { register_taxonomy_for_object_type('category', 'first'); register_taxonomy_for_object_type('post_tag', 'first'); register_taxonomy_for_object_type('category', 'second'); register_taxonomy_for_object_type('post_tag', 'second'); }, 50 ); } And that's pretty much my main theme class. Loading menus, widgets, post types, adding, ajax callbacks, etc. **Page Templates** I use alot of page templates. For those I will have a main class like ```SuperAwesomeTemplate.php``` and a view class at ```SuperAwesomeTemplateView.php```. You get all the data you need added to an object and then pass that to the view. I use static methods for rendering. Wish I could do more but I actually have to go finish up a project like this. 
https://www.reddit.com/r/PHP/comments/3rid9e/wordpress_php_vs_real_php/cwpim4q
Thanks for following up!
Looks like it's actually inconsistent about when it actually happens, and it's fixed in PHP 7.0: https://bugs.php.net/bug.php?id=70857 I suspect they didn't specifically fix it in the PHP 7, I think it's more that the entire underlying data structure management has been rewritten and a side benefit is that it solved wonky things like this.
You're not really doing anything worth unit testing in this class. In fact, if you run it through phpunit it'll probably produce a very low C.R.A.P. index. However, it may be worthwhile to write an integration test to make sure you get the data you're expecting.
Yes. All code is worth unit testing. It would also be good to a have a functional test on this as well. You'll find that this would actually be annoying to test and eventually end up writing nicer code because you want to write easy tests, especially if you test drive.
If you write WordPress php and put that on your resume and call your self a php developer or a professional developer, good luck getting a job. You are nothing more then a script kiddie trying to play with the big boys. You are a laughing stock, a joke and a disgrace to the development community. If you walked into my office, id laugh you out of the interview so fast your head would spin.
Is this *really* part of your domain? It sounds to me like app logic, not domain logic. But to answer your question, your goal should be to unit test every unit in your code. Note "goal", not "requirement." If a unit doesn't do something non-trivial, whether or not to write tests for it depends on whether you feel like the odds of the implementation ever changing *at all* are low enough to skip the few minutes it takes to test. In practice, I find that this applies to virtually no units I come across in my day-to-day, since anything trivial enough to consider not writing tests for is also trivial enough to test, so: why not?
I believe this is how [Laravel Cashier](http://laravel.com/docs/4.2/billing) works. People will say that your model should never be linked to your datastore(DataMapper). However, I think that is a moot point since you're alreadyd using ActiveRecord. If you can make a clean API that you can test, there's no reason to not follow a "cashier" like pattern.
I wrote a little series ages ago on softwaretestingmagazine, here: http://www.softwaretestingmagazine.com/knowledge/php-unit-testing-with-phpunit/
Yes. you are setting stuff to the `$query` so you can test the output of `handle()`
Would a static analysis tool check what happens if the required user doesn't exist? If the user exists but doesn't have the right permissions? If the user doesn't have any stats? Personally for this one I would write a test and configure mocks for each dependency, checking the happy path as well as all the unfortunate events that could happen.
&gt; Can/should a model be a synthesis of two data stores if the are intrinsically linked? Absolutely but you need to make sure that you own some form of identifier on your model. In other words, don't use the external ID as your primary key. Have a secondary unique index on that external ID, but make your own primary key. I do this sort of thing a lot for work and mapping internal identifiers to external is one of the biggest pain points. You'll need to have some accountability around the changes that are meant to go to external APIs. If a request to the external API fails and your stuff gets out of sync that could be a big deal depending on the situation.
None of the reasons cited are reason PHPUnit is slow but rather why your test suites are slow. Also I would highly suggest not using sqlite for testing, it doesn't expose the same API MySQL does. If you write a migration that renames a column or change its type Sqlite will explode.
Yep! It's really handy if you want to implement site-wide exception handlers. You can specify a common handler for a specific exception type.
True which is why I included "Some thing that are inherent to unit tests that make them slow." list. And because PHPUnit equivalent to "PHP Unit Testing" for all practical purposes. There isn't much that can be done with phpunit. It's just slow. 
Didn't respond to the sqlite. Wanted to do it separately. All major database migrations are kept out of the frameworks. Devops needs to do that. Unit tests aren't built for testing deployment tools and we don't allow the software to modify tables in production. Also the biggest problem with sqlite is the native typing. Working in VM's with mysql on the magnet is totally unacceptable. 
&gt; best if used in moderation. You probably don't need hundreds of exception classes. I usually one 'default' exception per module/library and use that as the default exception thrown by that code, and only create specific ones where they are appropriate, and make those more specific ones be children of the modules default exception. That makes catching all exceptions thrown by a particular module be trivial, rather than having to think about it.
Best real work example would be a library. When you call into it you want to be able to catch exceptions specific to that library and let anything else through. One way to do that is to create an exception base class and extend it everywhere in the library. class LibraryException extends \Exception { } class SomeSpecificError extends LibraryException {} // other exceptions, etc Now clients of your library can do this: try { doStuff(); } catch (LibraryException $e) { // clients know it was an error from the library } catch (\Exception $e) { // some other error happened } You can use a [marker interface](https://en.wikipedia.org/wiki/Marker_interface_pattern) to accomplish the same thing: interface LibraryException { } class SomeSpecificError extends \RuntimeException implements LibraryException { } And clients can still do the try/catch seen above. The advantages are you can extend an exception specific to a situation and still get the ability to catch all exceptions from the library. For example, maybe you want to throw `InvalidArgumentException` from your library. With a marker interface you do that and still keep the concept of a `LibraryException`. With a base class that can't be done (no multiple inheritance). namespace SomeLibrary; class InvalidArgumentException extends \InvalidArgumentException implements LibraryException { }
Interesting, I wasn't aware about that fact.
Hi mate, come see me in my office tomorrow after lunch, please.
This would be funnier if you were his actual boss. Less funny if you were his actual boss and punished him for this. 
It's easy work, the pay is good and it's close to my home. Once I have a few years in I'll start looking. They're also paying me to learn Drupal, so that's pretty sweet. I just wish he would have reached out to me first. It would have saved everyone involved a lot of time.
Laravel to Drupal, I am curious. Not exactly the same comparison but similar. I would love to know how you have found it.
A few ways to look at this. A lot of people who put together websites with a CMS are just mashing together lego blocks which is more like assembling pre-fab than it is "actually programming". Not a bad thing at all. But, the fact that you use WordPress does not stop you from being a "Real PHP Programmer" if you're writing PHP code. That's just macho PHP purist bullshit as you pointed out. Not all WordPress developers are PHP developers. PHP developers can use WordPress. 
We have apps in .Net, Ruby, Laravel, and Drupal. That's what happens when you just throw money at contractors and give them no oversight. Edit: To actually answer your question, I'm looking forward to Drupal 8 a lot. It makes heavy use of Symfony and looks to be a huge leap forward in terms of code quality. 
My boss tells me to install FTP so that we the 2 developers can work on the same project. By the way we, we have a Git (that I have introduced to the company) on our main app. I hate working for people dumber than me. Edit: The downvotes are given without hearing my story.
I don't know if I'm smarter than my boss, but I'm definitely a better PHP programmer. I'd rather let him deal with the suits and managers and just focus on programming. Edit: This isn't ego, my boss only started learning php this year. He's a much better .NET developer than me. 
Eloquent ORM http://laravel.com/docs/5.1/eloquent Can be used outside of Laravel: https://laracasts.com/lessons/how-to-use-eloquent-outside-of-laravel
With a telephone. 
You could probably use [http_request](http://php.net/manual/en/function.http-request.php) or [curl](http://php.net/manual/en/curl.examples.php). 
Doctrine for a DataMapper ORM, and Eloquent for an ActiveRecord ORM. Pick your poison.
I would personally suggest using Curl if you're writing straight PHP. It's a little more complex, but it also has a lot more useful features. There's also some security concerns with allowing fopen to download remote files. In this instance, we're using the Laravel framework. Because hitting REST services is a common task, there exist some great libraries to simplify the process for you. One such library is Guzzle. 
/r/iamverysmart 
Great response, thank you!
That totally looks like a graph to me. &amp;nbsp; ^(yes, I do know what you were trying to say - but where's the fun in that?)
The [CakePHP ORM](https://github.com/cakephp/orm) is pretty dam sweet!
That graph doesn't even make sense.
Harder than it sounds sometimes. Cloud Front and Load Balancers that change things, even as simple as what method you use for getting the IP (if it's through the load balancer then you have to use the X-Forwarded-For header) that's hard to mimic. 
How does blocking fopen solve the authentication problem that clearly exists? How do you authenticate a request ... that's the question.
Our outsourced frontend team sends JSON strings in query parameters because they can't figure out how to make POST requests. And we accommodate this insanity. 
Learn http
Excellent. This seems to be a common answer, I'll take a look at it. Out of curiosity, how do you feel about it's migrations?
Guys, he has *a git*.
cURL has a horridly verbose API and is often overkill. If it's a simple yes/no get request, `file_get_contents` and the like are fine.
It uses POST and requires basic authentication.
If you werent smarter than your boss in your speciality there would be little reason to have hired you. He isn't supposed to be smarter than you in your speciality. He is supposed to be smarter than you in getting you to do things for him which it seems he has done. You have been bossed.
SRP is a maxim, not a law
Cool! Now it would be in everyone's best interest if you share this information with your co-workers as well, rather than just point out their shortfalls online. I'm not trying to come off as a dick, but I'm sure they would be more than happy to learn something new. It would make for a better codebase as well. 😀
Lol, I did. Walked him through getting Guzzle installed and some basic uses. Sometimes you just gotta vent though. 
While you're at it, go ahead an disable fopen for URLs in php.ini with allow_url_fopen=0 
Guzzle is heavy and almost always needless overkill. File_get_contents with a stream context is usually sufficient.
Thank you for asking. You're not the only PHP amateur around.
Bro you sound like a Jr. Dev too. Nobody in their right mind would ever think to complain about this, let alone on reddit. Why don't you fix the situation instead of bitching about it and trying to look cool?
According to the PHPdoc, the handler is not supposed to throw exceptions. It might be because it's not up to date, it often happens with documentation.. On the other hand, we.could have unit tests that describe the behavior of this class: they could actually as a living documentation (and if they're not up to date, you will know as they will fail).
Sometimes we suggest an improvement to the application and he says "no need for such thing". Then he sees the exact same thing few months later somewhere else (or in a recent case it was suggested by Microsoft to us) and then he comes with our same suggestion and says "guys, here is what we are going to do, I saw it in this web site / Microsoft has suggested to us, we need to do it, is will increase the value of our product".
I was literally begging to use git. He was saying "it is extra job to install and use git, I don't want it". Now we don't have the issues that were constantly appearing after FTP deployment.
Maybe try what they have here? https://help.1and1.com/hosting-c37630/databases-c85147/mysql-database-c37730/connect-to-your-mysql-database-using-php-a771846.html $link = mysql_connect($hostname, $username, $password); if (!$link) { die('Connection failed: ' . mysql_error()); } else{ echo "Connection to MySQL server " .$hostname . " successful! " . PHP_EOL; } $db_selected = mysql_select_db($database, $link); if (!$db_selected) { die ('Can\'t select database: ' . mysql_error()); } else { echo 'Database ' . $database . ' successfully selected!'; } mysql_close($link);
Hi, yes, thanks for flagging. As the guy below guessed, this isn't being used did anything particularly important. I'm actually using it as a spam protection measure.
This code will not work with php7 which will be released iminantly. Instead it is better to use PDO for database interaction. Googling php pdo tutorial would hopefully come up some nice resources. That or use the php docs :)
Don't worry about this comment, he's trying to sound smart. But in regards to your question. Domain logic is the core logic for your application, so if you've got an invoicing system the domain logic is the logic that is about invoicing. This logic you can pretty much test every way possible since it's through out the application at each layer. Application logic, is logic that you'll only use for the application because it relies heavily on how you implemented your domain. You can't use this code with other domains (you could use your domain logic with other application logic). Application logic is generally held within controllers or in various other moving parts especially in a framework. With these classes however you'll need a functional test, especially considering in some frameworks the app logic is basically configuration.
I'm biased, but I think the [CakePHP ORM](https://github.com/cakephp/orm) is a great choice. It was designed for working with both simple and complex databases but strives to be simple to use and to learn. The features I think make this ORM stand out: * Easy to learn * Support for complex query building (like derivate tables, subqueries, sql functions) * Intelligent associations loading, it can decide when it is a good idea to use a join, use a subquery or a plain select. * Automatic associations saving, depending on the passed data structure * Built-in two levels validation * Support for user-defined complex types. * Support for composite primary keys * Built-in behavior for working with tree data * Tools for converting user submitted data into structures the ORM can save and use * Very good tools for working with bulks of data (unbuffered queries, bulk inserts, ability to set additional sql flags) * Tight integration with a stream collections library. This mean you can apply transformations to the data at the same time you are reading it out of the database * It is very close to working directly with SQL, so the abstractions will not be a barrier
Of course, but I am asking how they are handling it because it sounds sketchy. He is trashing his boss for using a supposedly "unsecured" method that has nothing to do with security. fopen isn't the problem.
&gt; 'pear channel-discover pear.phpunit.de' *closes tab*
I agree that bragging/venting on reddit is bad form, but not leveraging the time saving features of the framework is bad form too. 
You know, it's impossible to point someone in the right direction without knowing where they want to get to. We've got no magic ball here, to foresee "issues" you've been having or at least the code you are trying. You'll do yourself a huge favor if put some effort at least in asking this question.
In fact, switching databases is a less important PDO feature, partly because it is not that easy as most php users imagine. And the difference betewen PDO and mysqli is not that negligible as you think. It's rather critical, as raw PDO is usable out of the box and mysqli is not (and thus should never be used as is).
I'll give it a try again :D thanks
Didn't know (i also prefer to use curl/guzzle) about this. Thanks.
Bosses need to get told when they're shit, too.
That's why only "if you need only response body".
I'd say it's a good practice. The key thing is that it allows you to choose which exceptions you catch (and don't). e.g: try { // Database code } catch (ConnectionTimeoutException $exception) { // Reestablish connection logic } catch (DatabaseException $exception) { // General database exception handling } // Intentionally let other exceptions fall through to other handler edit: formatting
How do you have an employed php dev that doesnt know about fopen or basic programming practices? For no matter what reason, other than taking a kid under your wing, that doesn't make sense to me. I have a hard time finding any work, and I'm relatively experienced with PHP and deployment of automated services.
I would assume the process writing the image would have a r/w lock on the file and hence PHP should wait until its unlocked. I could be wrong though. 
I think you should do what you have to to get the headers as the client sent them. If PHP does some parsing and obscuring (and it does in this case) of headers then it is acceptable it configure your HTTP server to compensate. 
I don't think I would ever use fopen for consuming API endpoints though. That is generally suited for reading and writing to local files.
You kinda have to deal with CP-1252 if you are taking input from MS Word etc.
I find Collections to be very useful, especially if the collection is strictly for one object type. The behavior would be similar to templates or generics in other languages, except for strictness is handled at runtime. I created a library to handle that: https://github.com/danielgsims/php-collections I've included some other collection types in the library, but the Collection class is something my team uses every day. Doctrine has a popular collection library, but it isn't strict, but that's okay for a lot of use cases. https://github.com/doctrine/collections Laravel also has a collection class, but it's bundled with some other stuff, so I don't know how useful it is for plug-and-play: https://github.com/illuminate/support/blob/master/Collection.php 
Yes, Despite the relative power of the PHP array type (it's somewhat like a bunch of different container types munged together) I miss having proper separation of container types, Python does it pretty well.
Would you still find them useful even if they weren't strict?
and you shouldn't but you could! as well as you could use file_get_contents or even include() ... but for a junior its good to learn the options he has and the pros/cons on what to use, before you push him to curl or guzzle
lets be honest, no one is that good ;D
My "developer" boss keeps underbidding projects because "I could do that in 3 hours!". Hasn't written a line of code in 10 years, doesn't understand modern development environments, self-taught PHP from a book long ago, still thinks register_globals is pretty handy.
I had to implement it in a website for the automated emails. Also the way that you have proposed would have changed from service to service.
I'm married, so I'm allowed to be a dork.
I don't think there's any difference, TDD the first thing you are tasked with.
The company abandoned .net years ago to switch to open source. Most of the devs quit, the ones who stayed on are learning php and linux. This particular person only does php dev 1/3 of their time, the rest is maintaining legacy .net code.
We have local, dev, stage, and prod. Dev is used to make sure all developer changes play nice together, stage is for internal review.
Wouldn't work with me. I don't load remote content in my emails. Not sure this would get through my work spam filter either because the image doesn't have an extension.
I wrote a fairly well received series of articles on learning how and what to unit test: https://jtreminio.com/2013/03/unit-testing-tutorial-introduction-to-phpunit/ I'm currently writing the next part(s) of it. Hope this helps.
Thanks. I neglected to mentionthe cron job php is a different php file than the one served on web visitor. So its question of multitasking but not duplicattion. I think the "release" may have been called releasing an "instance" or something similar. There was something about php not relessing itslef for the next hit if the web vistor was still interacting with the page and it wont release unless the vistor closes the page or you program the release somehow before the visitor closes the page. Something to do with the php server needing to keep an association with each separate vistor so it can properly complete a chain of events associated with that visitors prior events on the page . I wish i could remember what that is called. My page has no prior events and simply shows a page. The visitor will always just only be able to reload it or go to another page so retaining an instnace is never necessary once the page has been served. Also It sounds like I need to do the save to interim image thing. I have sometimes tested the page and found a few large graph images will only show tthe firsthalf of the image with the bottom blank as if it isnt finished saving it when the visitor comes along.
Too many error cases....where is the checking against: i) redirects ii) Garbage or HTML being served by the remote server. iii) Imagick doesn't have controllable behaviour for request timeouts....so there's not possibility of determining whether an exception was caused by network failure rather than a problem with the image. iv) The code is really hard to debug...if there is a problem with the processing, as the image wasn't downloaded to a file first you can't repeat what happened without re-downloading the image. Or to put it simply, look at the people on SO who are asking questions about why code like that isn't working, and it's impossible to answer, because when it fails it provides zero information about what went wrong. Just using libraries to do what they are designed to do well, and the right tool for each part of your application, is better than using a tool that can kind of do something, but does it very poorly. 
But don't you convert it into UTF-8 on input?
It sounds like you want to do functional level testing. I would look at Behat and Symfony WebTestCase. http://code.tutsplus.com/tutorials/basic-functional-testing-with-symfony-2s-crawler--cms-20666 Along while getting the kernel. But Behat would be better especially if you use https://github.com/sensiolabs/BehatPageObjectExtension
[CakePHP ORM](http://book.cakephp.org/3.0/en/orm.html), its the best on for me. No doubt!
&gt; Also i read something about when one visiter hits a php page that the server doesnt "release" that visiter until they close the page The only thing like that is that PHP Sessions are blocking for each user. e.g. If a user opens up a page, and another page in the background, any attempt to open the session data for page 2 will be blocked until the first page is completely served. They can still have it open in their browser, it's just blocking while the server is generating the page. For that reason I strongly recommend people don't generate images in the actual web server, as generating images can be slow and block other requests the user makes. Instead generate them in a background image processor that is being run by something like http://supervisord.org/ 
 Edit: so the release thing is apparently called "sessions" which is talked about here and prevents the next page from loading. http://php.net/manual/ru/function.session-start.php Their example &gt;Пример #4 Reading the session and closing it &gt;&lt;?php // If we know we don't need to change anything in the // session, we can just read and close rightaway to avoid // locking the session file and blocking other pages session_start([ 'cookie_lifetime' =&gt; 86400, 'read_and_close' =&gt; true, ]); So i habe no idea what this menss for my page and how i shoukd do it but it seems i wohkd want to manually release each visitor becuase my pages need nothing from their cookie or session instance to work. Can i somehow release them at the top of the php index.php pag eand still finish the page so the next vistor can also be served at the same time and avoid some kind of collision? 
I'm not really looking for anything, was just wondering if anyone would use well-designed array alternatives if they existed. Sequence, Map, Set, etc. 
Yes.. Hack style collections please.. with generics..
&gt; useful even if they weren't strict? at least it should recognize string integers (as keys)..
Final encourages composition over inheritance and reduces the internal complexity significantly, because you don't have to honour inheritance everywhere.
Yes, yes, a million times, yes.
That last part will take thinking becuasethe time the webpage index.php is called will be different than when it wss created by tje cron job so i cant use a time derived hash as i normally would for uniquness. Have to think of something the index.php cna generate that will be the same as what the cron job minute.php last genersted. Is there a way to leave a variable on the server with the last created name? Bit then i have the same problem with THAT file as i did with the image file. Ideas?
I don't like cron for background jobs. It is too inflexible with respect to the number of workers, being able to monitor their status and backlog. [SupervisorD](http://supervisord.org/) is much better at running background tasks.
Final forces composition over inheritance is what you mean. I think that should be my decision. I'd be less annoyed if there were addition means of extension like objective c class categories.
I don't - which is why I use PHP. There are plenty of other languages if you like that - let's not fuck up the the ones I like by adopting features from every other language. That seems to be the trend lately. Next thing you know we will have "generics" which is a pointless concept in PHP - it is already generic
Why is everyone here dismissing the SPL? Isn't this exactly its purpose?
file_get_contents not sufficient if allow_url_fopen is not enabled. There is not a big difference between fopen and fread and file_get_contents. cURL is almost always to way to go when dealing with HTTP requests, however the cURL functions in PHP are horrible. And that is where Guzzle fits right in.
Well it is /r/php ;)
Yes, this is a very common practice used in many applications &amp; frameworks. I consider it the standard way to define custom exceptions, and rarely do you need more than the stack trace it provides.
&gt; His boss obviously knows how to write a working solution in PHP. Unfortunately, that is not true. I only found out about this because it didn't work and he asked me to "spend 15 minutes fixing it". Instead, I spent two hours going through the process with them, figuring out why it was broken, and then setting up a superior solution (imho). 
Go to github.com and start looking at how some packages and libraries are running their tests. 
Cool stuff. There's also [this](https://github.com/Webiny/GitSplit).
Sometimes one just can't help but poke the bear. Even if one's business success is due to php :P
In my experience there are two structures of the SPL that do get used despite some thorns: `SplFixedArray` and `SplObjectStorage`. The `SplFixedArray` is often used to reduce memory. With PHP7 making great strides in reducing memory usage and improving performance this becomes less useful. As a side note, I believe `SplFixedArray` is generally slower than an array. I don't have tests laying around for this, but feel free to do your own benchmarks and see for yourself. Anyway, the point is that this ends up being even less useful as of PHP 7. The `SplObjectStorage` is decent but it literally only works with objects as keys. It also doesn't provide a way for you to give your own hashing function. Furthermore when you use `foreach` over one you get the *keys as values*. See https://bugs.php.net/bug.php?id=49967. Despite this some people still use it because it does allow objects as keys which arrays cannot do.
They are still in use, just not in quite as many places.
Oh, now that would be nice. I think we're going to see more in the way of type hinting with scalar type hints coming in PHP 7. I would be nice to be able to specify a collection of a specific type.
That's so true.
Thank you. I had never heard of it and wi check it out.
Nope - we've just not optimized collections as they're not a hot spot for us. We've looked into why this is, including the idea that they're not fast because they're not used enough for us to optimize them &lt;-&gt; they're not used enough for them to be a hot spot because they're too slow, and that wasn't much of an issue. The bigger issue is that while we dislike a lot of things about arrays, the COW semantics are actually really good (except for weirdness when references are involved). Edit: as /u/carlos_vini said, we've also not implemented the alternative yet - we're still at the stage of trying to get a good idea of what they should look like.
Personally I recommend [Paris](http://j4mie.github.io/idiormandparis/), small but does the job perfectly and has a nicely designed query builder methods, thus your queries really do look like plain English which makes them self explanatory. Edit: typos
\*shrug\* "widely-used"?
Let's go with that.
But the default maximum script execution time is 30 seconds, isn't it? 
There isn't a situation where you *only* want the response body. No matter what you're hitting, APIs and websites can have outages or issues. What if the API is overloaded? It might return a 503 code with a JSON response body and your script will think the request succeeded. Using something like cURL or Guzzle will allow you to check the status code was 200.
Just some info: 1. This will not detect obfuscated function names. 2. The actual process should be its own separate service instead of being part of the command itself.
Sorry but you're wrong. file_get_contents is not sufficient for consuming an API when you need to do stuff like check status codes to know if a request succeeded.
Correct.
Kill him before he lays eggs!!!
Why are they sending data via GETs? :P the only query strings should be things like filters or sorting options.
~~That's right, but only if you keep the default value for default_socket_timeout. You can use ini_set() to easily change it if you don't want to (or can) touch the php.ini for some reason.~~ Edit: That is not the case because according to the documentation stream operations are not affected by max_execution_time.
I didn't said the opposite, I just pointed add that emilvikstrom's [comment](https://www.reddit.com/r/PHP/comments/3roedu/caught_my_boss_teaching_a_jr_dev_to_use_fopen_to/#thing_t1_cwqojpz) is wrong since file_get_contents() actually has a timeout, even if that is not going to make a difference if you keep the default value. I agree that using cURL is better, especially because it allows you more flexibility about the error handling.
No, I probably wasn't clear but they wanted to do post requests for even retrieving data. They wanted to post filters because they couldn't figure out how to put the filters for fetching data in a query string.
Ugh, that sounds terrible, and there is the worry you will hit the URL max length....
Many developers use print_r for debugging instead of var_dump (I have no idea why but many seem to prefer it), so I guess it warns you if you accidentally forgot a print_r function somewhere you shouldn't, which could lead to the leaking of some sensitive data (e.g. if you do something like print_r($_SESSION)), or simply mess up your design.
Yeah I thought that was great but like I was saying it makes me worry still about instances where the function or class is referenced by its string representation in a variable, does PhpStorm take into account things like call_user_func($my_func_name_string) ?
I am all for strictness and generics, I hate the dynamicness. On the other hand I do understand that some people might find them useful and I do hope that they are going to stay, even though I would welcome strict types as default - it would help PHP gain traction again. Strict types are incredibly useful to find mistakes in your own logic (which is also why generics are so incredibly useful e. g. in Java - instead of fucking up at runtime, your program fucks up at compile time meaning you will instantly find the problem even if the code is not used yet).
Not OP here, but my most common needs are: - sets - "arrayof" (generics? key is being able to typehint on the content, e.g. `function workMyFoos(array&lt;Foo&gt; $foos) {}`) - shapes - pair (common case: `list($ret, $err) = somefunction()` type of thing) Also native language support for enums, which has come up in several RFCs. For what it's worth, I think I've only touched the SPL datastructures maybe once in the 10+ years I've been using PHP, and doing so didn't actually help anything. The exceptions are very useful though, even if not ideal.
I'm not saying that there is no tool that can find a lot of these things, but from a theoretical standpoint, depending on your codebase, it may be impossible to find all of them. Consider this example: &lt;?php require 'autoloader.php'; if (class_exists($_GET['class'])) { $object = new $_GET['class'](); $object-&gt;doStuff(); } This is an extreme example but there are less contrived and obvious ways, in which this sort of situation may make it impossible to determine whether or not a given line of code is ever used, especially if your codebase is like I am imagining it to be.
1. Write application level tests for code that you are changing (functional one) 2. Do TDD and add more unit tests by the way Kent Beck describes this in his book: http://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530/ref=asap_bc?ie=UTF8
Java's List, C++ Sequence (I think). A linear sequence of items, like a vector or linked list. 
will do, thanks
If people want to enforce type hints in collections or even in method arguments, then they may as well go for a strongly typed language like Java. The reasons are sound to want that functionality, so why not make the switch?
Java and PHP have different markets, PHP is ubiquitous on the web.
Because their app is already written in PHP and there is no reason not to allow strongly typed methods especially for critical code or frameworks.
The way I've been seeing it, is if PHP7 is twice as fast, we'd need half as many servers to do the same amount of work. That seems pretty big? Adoption rates of course being the biggest thing. This makes me think that any webhost that adopts php7 will immediately start losing income in exchange for less servers required/maintenance/electricity?
Sorry it [used to be part of the install instructions](https://github.com/flashtag/subsplit-service/blob/8a3491309cac83995286579d31e3856eeb9664fd/readme.md#setup). The project is barely a day old so I haven't really spent much time on the readme, but thanks for the reminder. I've added [another section](https://github.com/flashtag/subsplit-service#powered-by).
If it was pass by value like arrays... yes. But simply slapping some classes in PHP core won't change much I'm afraid.
[Have you met Ted?](https://i.imgur.com/wfx3sJR.gif)
Telling the reality of the situation isn't "being hostile" nor "being a dick". I'm sure it's nice up there on your high horse, but where do your politeness police lights and sirens go?
What's wrong with symfony/console? The last part is possible. In the docs it's called a [single command application](http://symfony.com/doc/current/components/console/single_command_tool.html).
In addition to the other recs, I would suggest [c9s/getoptionkit](https://github.com/c9s/GetOptionKit), although I usually just use symfony/console.
[removed]
He might mean literally. Fancies himself a martyr for language features in php.
Yeah, if it's a newer PHP framework (like zend 2 or symfony 2) then #1 priority should writing functional tests that simulate HTTP requests and check the response against known-good responses - do this for the top features in the site to make sure that future changes don't break critical paths. (Also, does this boat version of airbnb have plans to expand into canada?)
how about we look at argv and getopts?
I just can't understand how this: Array ( [a] =&gt; apple [b] =&gt; banana [c] =&gt; Array ( [0] =&gt; x [1] =&gt; y [2] =&gt; z ) ) is much simpler than this: array(3) { ["a"]=&gt; string(5) "apple" ["b"]=&gt; string(6) "banana" ["c"]=&gt; array(3) { [0]=&gt; string(1) "x" [1]=&gt; string(1) "y" [2]=&gt; string(1) "z" } } Maybe at the end of the day it's just a matter of preference and what you are used to. Anyway, thanks for the reply, I don't think wasting our time debating on something like this even worth it.
It does both the parsing of what command needs to be run, as well as the dispatching of that command. I have a refactored version that separates the two: https://github.com/danack/console That allows you to use it just for console stuff, but then run your application code however you want to.
&gt; it came out because microframeworks were picking up and symfony wanted in. Slim and Silex [started around](https://github.com/slimphp/Slim/commit/e80b4e57702cb2aea33746e91cc02feb6f9e81e1) the [same time](https://github.com/silexphp/Silex/commit/0a6309a74c96c5c15f3c87ba3497680a4c249e0b). Granted Silex's 1.0 release wasn't until 2013, Slim's was way back in 2010. Most of the other micro frameworks I've seen started sometime well after Slim and Silex. [Microframeworks](http://i.imgur.com/PNDBuAU.png), as a [trend](https://www.google.com/trends/explore#q=microframework%2C%20micro%20framework%2C%20php%20micro%20framework%2C%20php%20microframework&amp;cmpt=q&amp;tz=Etc%2FGMT%2B5), started picking up in 2006 with .NET. PHP started trending around 2011. &gt; there's nothing micro about silex nor the symfony kernel. `HttpKernel` itself and the event dispatcher, http foundation, and routing components are all pretty small. the HTTP Kernel package is not (it should be two packages, IMO), but Silex skips a lot of the stuff there. Anyway, micro frameworks, to me at least, have always been about their feel rather than their code size or speed. Configuration in code not external files, simple to use and get running, minimal interfaces, lack of conventions, etc. [How Heavy is Silex](https://igor.io/2013/09/02/how-heavy-is-silex.html) is worth a read.
PHP isn't normally the bottle neck though right? Its more likely IO.
something to consider is that we don't have an option in the web world if we like strict typing. javascript, php, python, ruby, etc are all dynamically typed. frankly, i don't want php to become strongly typed; i want a sane, well-designed web-based language with consistent function nomenclature, strong typing, OO support that isn't clunky and aggravating, and syntax that makes sense and is readable. and php quite honestly fails on almost all of those criteria, regardless of how much it gets changed. (also i know java technically fits that - it's possible to write servlets that serve up web content. but god why would you ever want to?) 
So a user pastes some content that was copied from word into a content editable (rich text) area, then submits it via a form to the server. How/when do we convert the encoding? (serious question, I actually want to know). 
I agree with the statement about feel. That is why when I tried [Lumen](http://lumen.laravel.com/). It felt heavy. I really like slim as I can get a site running in a single php file quickly. I can then refactor into multiple files.
yeah i've read that post by igor. micro is subjective and his own definition of micro is not really something followed by most microframework authors. it's viewed as a fancy spin to justify silex's bloat. no. silex wasn't the trigger for microframeworks to go mainstream. symfony, maybe (because of it's size/complexity). i know microframeworks existed outside PHP, but we are discussing this in PHP space. considering the amount of process bootstrapping and number of machine instructions involved in handling one request in Silex (testing callgrind/valgrind), it really can't justify it's claim of being micro. and you have to do that for every request. i'm not talking about compiling to byte code (which gets addressed by the opcode cache). i swear, all the hard work done by internals in speeding up PHP goes out the window as framework authors keep on putting more layers of unnecessary abstractions on top of simple concepts for the sake of looking smart and fancy.
You can totally get the status, you just have to know where to look. Try the following. &lt;?php @file_get_contents('http://httpbin.org/status/418'); print_r($http_response_header); 
This is actually a freakin fantastic idea and so damn simple I'm embarrassed I never thought of it. Cheers, sir. 
Haha, is that the Rasmus Lerdorf quote ? It's true, but on complex CMS/frameworks that don't read too much files (eg. Symfony cache and bootstrap) the amout of executed PHP code is not negligible comparing to I/O operations. If the I/Os were the only bottlenecks, PHP7 would not have brought nice performance increase on WordPress, for example. Also, OSes have great optimization on frequently accessed files (the first read could take 2 seconds and the 10th 0.001s) so reading the framework's files is not truly a problem. More, PHP I/Os are blocking, so when a file is read, a database is selected, nothing is executed. After a data is available, your code is "slowly" executed and no file is read in advance. That's why NodeJS applications could be so fast with only one server instance, since everything is asynchronous (even hashing in md5), because I/Os and code execution are performed in parallel.
Yes. I use them a lot in Ruby and they are always useful in any language.
Schema.org
This is great but I'm not sure how well it transfers over to a relational database structure. I'd like to see a collaborative effort on designing relational database schemas. Of course not everyone's application needs are the same but maybe it would give a good starting point for people. 
Since 5.3 getopt has worked on windows
&gt; If that matters to you - why don't you use a language with those features? Java, for instance. Believe me, I would love to. But more often than not I have no choice but to use PHP, be it because the server only supports that or the client specifically wants that. &gt; If all the languages are going to get all the same bandwagon features what is the point of having different languages? Not all languages have to be the same. But all languages should receive modern features that help developers - if not the language will die out. Do you think PHP would be as popular if it didn't receive OOP support? &gt; I heard it from the c++ people in 1992 and the Java people in 1997 and I'm hearing it from the swift people now and my experience as a smalltalk and objective c and Ruby and PHP and Python developer is that everything you typed is just not really true. Nice of you to say that. Doesn't mean you are right in any way, shape or form. What that I said is not true? You mean you don't want your mistakes to show themselves during compile time instead of during runtime? You like your applications crashing because you didn't test a very specific change? I like to notice errors as soon as possible, just because you don't doesn't mean what I say is not true. &gt; It's one of those mythologies - one of those fake facts everybody thinks they know - but if you do the real research - it turns out to be wrong. Yeah, because the compile process erring doesn't mean you notice mistakes earlier! Come on, grow up. What you type is wrong and you know that. &gt; Xml took the strong typing approach - and it failed. Seems like a very large chunk of programmers didn't get that memo. &gt; People dumped it for json because loose easy typing is easier to deal with and more useful. JSON uses less space. One of the only advantages it has, which definitely makes it nicer, but more difficult to read. &gt; Json is easy to deal with in PHP - in Java it is hell because of the stupid type mania. Then you are simply a bad developer. You can simply read your JSON data into a string array and let your object factory deal with instantiating all the objects from the JSON string if you want to do so in Java. I like that more than having your program crashing because of the stupid dynamic type mania.
Ah, you're right
Is there any discussion among internals for adding value types to PHP (see value types in Java 10 and structs in Swift for more info if curious)? There are two things that make class collections a lot less practical than they could be: 1. They're passed by reference (which means you need immutable version if you want any predictability in their state as you pass them around), while they should be preferably passed by value. 2. We have no generics. I feel once those two problems are solved, we'll see a proliferation of collection type use in the community.
There's http://www.databaseanswers.org/data_models/ which is a large collection of data models. 
I agree with what everyone else has said so far, but to be more practical: If you're trying to break in as a junior developer, my team would expect you to have a good understanding of how the web works, have competent html/css/javascript skills, and have a firm grasp on PHP. Specifically I look for knowledge around OOP. We also expect that anyone writing PHP professionally should be up to date on community driven efforts such as PRSs, Composer, knowledge of popular libraries and frameworks,etc. Obviously, we care about the soft skills just as much as these technical skills. I think it's important for an entry level junior to have the knowledge, but not necessarily the experience. That's the main difference between a junior developer and a developer. Mid tier Developers will get more autonomy and responsibility. Senior developers even more so. 
Try [/r/phphelp](/r/phphelp) (per the sidebar) or [open an issue](https://github.com/bcit-ci/CodeIgniter/issues) on the CodeIgniter repo.
Yeah, schema.org has got nothing to do with relational databases. It's to do with making web pages more machine readable, mostly for the benefit of search engines.
had a quick look on the code, and i noticed two things: * your scan will produce false positives (as it will find its stuff within comments too) * the naming of your classes seems weird - your tool is not fixing anything, so why this fixer namespace and fixer prefix?
You are absolutely right, I don't know how I missed that. From the [documentation](http://php.net/manual/en/function.set-time-limit.php#refsect1-function.set-time-limit-notes): &gt;Note: &gt;The set_time_limit() function and the configuration directive max_execution_time only affect the execution time of the script itself. Any time spent on activity that happens outside the execution of the script such as system calls using system(), stream operations, database queries, etc. is not included when determining the maximum time that the script has been running. This is not true on Windows where the measured time is real. Stream operations are not affected by max_execution_time so the script wont timeout in 5 seconds but in 10. 
Are you using a framework? Are you using any features that would break HHVM?
Do you think its better to spend time learning someone else's schema and fit your project around it, or spend time planning your own which is a perfect fit for your project? I can understand when it comes to code, because when you don't know how to build a particular function or process or whatever (e.g. Not having knowledge of RFCs etc) then its definitely quicker and easier to use someone else's work. But database design often isn't as complicated (in my opinion).
Oh. I am so sorry. Your well though out response has clearly changed my opinion on this topic. Thank you for enlightening me. /s You made it more than obvious that you are not interested in a productive discussion, but you'll have to understand that I am going to continue thinking of you as a bad developer. Everybody should be glad to notice bugs at compile time rather than run time, and if you seriously think that dynamic typing poses such a big advantage (even though it clearly doesn't, in most cases you have to know exactly what kind of object you are gonna got or you won't be able to access its' fields properly), I cannot take you seriously (remember, my opinion may be influenced by you being an asshole).
[removed]
My understanding is that if your page tells the browser that it is UTF-8, that the browser should be submitting the forms as UTF-8. You can also try to force this with `&lt;form action="foo" accept-charset="UTF-8"&gt;` - http://stackoverflow.com/a/3237887/778719 If you're seeing some browse not follow that, maybe post an SO question and ping me here or there. I believe some sites use hidden UTF-8 characters (e.g. the snowman) to check that forms are being submitted in the correct charset, and then taking appropriate action e.g. http://php.net/manual/en/function.mb-detect-encoding.php 
Yeah but this is an ini setting. - even with your example you can set that up. Theres nothing stopping anyone from putting a lb in front of dev
Not the *best* example but you can see how I did it here. https://github.com/matdombrock/contact_zero
He apparently has just not in each developers environment. Which makes no sense...
Who the fuck wrote this regex haha
A function you might find useful is checkdnsrr(). Pass in the domain name of the email address and the record type (MX) and itll dig to see if that domain has an mx record. Returns true if there is an mx record and false if not. E.g.,: $emailArray = explode('@',$email); if (checkdnsrr($emailArray[1],'MX') === TRUE) { //continue Etc. This is useful to catch spelling mistakes (e.g. someone@gamil.com, someone@hotmai.com), however it wont tell you if the user exists at that domain or if the domain's mx hostname even accepts emails. But it can't hurt!
Story behind Laravel is - high quality, tested, well packed &amp; decoupled code. Every dev who tried it fell in love with Laravel - me too. If you need hard core PHP go with Slim(or similar) framework for basic routing and write your own code structure. Stay away from ORM in this case - use good old plain PDO. Good book to read: http://www.phptherightway.com/ Hope this will help. 
I see a couple problems with your proposition, the idea is thought-provoking but i think it's in a sore spot where it cannot be of any use. For your project, you don't want a "one-size-fits-all" CRM database because it would incorporate plenty of stuff you don't need, and it would probably miss plenty of stuff your customer actually wants. On the other hand, if you want a basic minimalistic database for your project, something you can evolve later on depending on your needs, well it would take 10 minutes to make, you'd spend more time browsing around and actually getting to know someone's database that you would designing it from scratch. At this point, you already have lots of levels of abstraction available, depending on the ORM you chose, the backend framework, the frontend framework, the interaction framework... But you cannot abstract yourself from your client's needs and the database is the purest, simplest expression of what your client needs.
Why don't you think about it and explain the pros and cons to me?
&gt; Every dev who tried it fell in love with Laravel That's not even remotely true.
I did not know that. You say if it has an A or CNAME but an MX record has to be a hostname- an IP address is not a valid MX record. So surely an A record cannot be treated as an MX record? Regardless, this function is still useful for catching incorrect domain names such as gmai.com or hotmaik.com etc (if they dont exist). 
Using any tool in the extreme (to the exclusion of anything else) is not good. ORMs in general help reduce a lot of boilerplate code which, if you rolled it all by hand, may be more suspect to security concerns. IMO, ORMs can also help you think about data problems differently (and probably improved over starting from scratch). If you see the tool deal with problems in particular patterns, there's probably something to be learned there. At least study what the pros/cons might be. Personally, most of my projects use ORMs of some stripe, and there tend to be 5-15% of the queries in a project which end up getting written by hand. They're typically move heavy-duty reporting queries which aren't easily optimizable by query builders, or the needs of the project change a bit and some ORM relations don't support an extra query that is needed for a particular screen. But... do I try to fit every single possible use of a SQL database in to a single tool (ORM in this case)? No.
Your first paragraph is my reason for not using an existing theme to try and meet a client's front-end needs. I find it easier to add to my own code than to remove from somebody else's code when fulfilling the needs of a client.
Oh I see thanks for clarifying. However I cant imagine any email provider not setting an mx record, can you??
Models should not know or care about whether and how they are persisted. Saving and loading objects is complicated enough and should be done by a dedicated layer - data mappers.
Oh i'm feeling it right now on a project of mine. The designer made some mockups with a 20$ material design theme, i'm not exagerating when i say the whole thing weighs in at 45Mo. At least 20 js libraries and css frameworks, jQuery, Angular, every .js and .css file in existence found its way into his damn mockup. I had to spend half a day just to trim it down to the bare essentials, and basically told him that i'd add back every feature on a one by one basis, provided he documented their use case and why this or that library is a good choice for this feature. It's not even that i'm a purist or anything, but as you say it's always saner to add functionality than to start with a gigantic toolbox and remove what you don't need.
&gt; Story behind Laravel is - high quality, tested, well packed &amp; decoupled code No that's not really the story ! Story is some questionable design choices in order to make it easy to use for beginners.
You've got a point! Must fix this... nice idea Will be fixed: https://github.com/nilportugues/php_forbidden_functions/issues/2
Aww yeah.
This is just wrong.
Model is a layer not a class.
No, your question was "What is so bad about Active Record ORMs?" .. in case you already forgot.
"Model" can mean a layer as well as a persistable object, especially when used in the plural form. * https://doctrine.readthedocs.org/en/latest/en/manual/introduction-to-models.html * https://docs.djangoproject.com/en/1.8/topics/db/models/ * http://sailsjs.org/documentation/concepts/models-and-orm
Or, you know, `filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)`.
but why would I care if someone uses the same password for all websites?!! Why should I encrypt your password on my website, so your facebook/gmail account doesn't get hacked?!!
Would you rather be the person who had an encrypted password data leaked with no discernable data and your users are safe, or the person who chooses not to write a couple lines of code to prevent it?
You want to hash passwords, not encrypt. Encryption implies that there are methods to decrypt. A salted and hashed password is a one-way conversion, and means that even if someone gains access to all of your database and password-storing logic, the plain-text passwords cannot be retrieved conventionally.
Because proper developers do that, it's good practise. It takes exactly 2 minutes to hash a password, why are you so against it?
The emperor has no clothes.
Even this is misleading. "Salting" was a reasonable defence back when rainbow tables were the dominant attack strategy, but in 2015 we have GPU-backed tools that can make billions of guesses a second on reasonable hardware. Hashed salts are no longer the correct strategy. Use [`password_hash`](https://secure.php.net/manual/en/function.password-hash.php). (If you're on PHP before 5.5 but after 5.3.7, use [`ircmaxell/password_compat`](https://github.com/ircmaxell/password_compat). If you're on PHP before 5.3.7... uh, upgrade I guess.) That API will do the right thing, even as the password arms race continues.
I'd say "PHP the right way" plus "The clean architecture in PHP". Second book will help you to detach from a framework even you're using it 
You're correct, but keep in mind that password_hash uses salts automatically.
A solid PHP foundation starts with a solid programming foundation (arguably, an OOP foundation, as PHP is better as an OO language than a functional one). So putting PHP aside, the thing to focus on is [using SOLID and GRASP principles to write code](https://nikic.github.io/2011/12/27/Dont-be-STUPID-GRASP-SOLID.html). Laravel, or any other PHP resource, is not going to teach you OO. You can write great OO code in Laravel, or shit OO code in Laravel. You can write great OO code in your own PHP projects, or shit OO code in your own PHP projects. Using or avoiding a framework is not going to help you with this, as frameworks have no say in the quality of your own code. Now, when it comes to a PHP-specific foundation, the good news is that this is already covered by Laravel, so your efforts are not being wasted. For all the shit people give Laravel, Laravel is teaching you a few key modern PHP best practices that you would apply in any other framework or "from scratch" PHP project. 1. Front controller routing through a single entry point 2. Using PSR-4 autoloading and namespaces to import code 3. Using composer to pull in and manage 3rd party dependencies Take those skills to Symfony, Slim, Cake3, Aura, your own code... anywhere. That *is* how you build PHP applications in 2015, whether it's in Laravel or anything else. But like any framework, Laravel does let you take short cuts. Here are some bad habits you might be using in Laravel that you definitely want to change. # Static facade access everywhere (aka not doing dependency injection) If you're doing something like `View::make()` or `Redirect::to()` or `User::create()` or `Auth::user()` or any of that static facade access throughout your code, you're creating tight coupling and you're making your code rigid and brittle, and harder to test. Instead, you should be favoring dependency injection, which Laravel *also* provides a great mechanism for doing (or not doing, if you want to use your own factories for things). If you want to keep working in Laravel, [read this part of the documentation](http://laravel.com/docs/5.1/container) and start practicing it today. Specifically focus on the part in "Resolving" where it says "Lastly, but most importantly, you may simply..." If you want to explore the idea of dependency injection containers outside of Laravel, there are many to choose from, but here are a couple notable examples: * [Pimple](http://pimple.sensiolabs.org/) * [AuraDI](https://github.com/auraphp/Aura.Di) But you'll see Laravel is basically doing the same thing. # Leaky Eloquent This is not a Laravel-specific problem. This is a general programming problem. Avoid letting Eloquent active record calls leak throughout your application just as you would *any other implementation detail, such as raw SQL queries*. `$user-&gt;comments` or `$user-&gt;save()` or `$user-&gt;load('comments')` or `$user-&gt;articles()-&gt;where(....)` scattered throughout your code *will* make your applications harder to maintain, and more fragile, the bigger they get. [Active Record is great, but use it in a disciplined way](https://medium.com/laravel-news/separation-of-concerns-with-laravel-s-eloquent-part-1-an-introduction-c9a6dc6b4a65).
&gt; he can see all the user's data Strange you think that's the only reason someone would want to gain access to another user's account.
Pulling from my blog post on [basic cryptography definitions](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded), I'd like to emphasize a very important point. **You don't encrypt passwords.** Instead, you *hash* them with an appropriate algorithm (e.g. `password_hash()` in the case of PHP). These two verbs have totally different meanings. Encryption is reversible (provided you have the correct key), hashing is one-way. Password hashing is a special case of general-purpose cryptographic hashing with its own requirements, but it is **NOT** encryption. Further reading: [How to safely store a password](http://codahale.com/how-to-safely-store-a-password/).
When did /r/php become Stackoverflow?
I agree! Thanks for the info 
I'll throw another one in mix: league/climate
Yes, this is not understandable by a 5 year old software architect, who designs enterprise applications in Duplo. I'm afraid the only answer that would make sense to them would be "stop reading daddy's programming books".
It is entirely possible that MySQL is configured to use the local system time and not utc. Verify what MySQLs date/time settings are. Truthfully it shouldn't matter unless you expect the NOW() to be in utc. 
If the MySQL timezone is wrong, then you need to tell MySQL which time zone to use. I'd make sure my OS time zone is UTC (since I think MySQL will default to the OS TZ), as well as telling MySQL always to use UTC. https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html If MySQL is using, for example, US Eastern time zone, you can use NOW() and it will store the UTC equivalent in timestamp fields, but when you select it later, MySQL will convert back to Eastern, which your PHP layers may not realize is not UTC.
Searching https://github.com/amphp/aerys ? Not sure why it should be dumb… It's exactly as dumb as building a webserver in plain node.js. Why would you build it in node when you have nice webservers written in C? ;-) And this comes down to: to have the ecosystem in one language (personally I found it annoying to have a websocket server in node and the main application in PHP) and the application persisting in-memory.
&gt; Yes, `password_hash` uses unique random salts as an implementation detail. That's necessary, but it's sufficient only for defending against rainbow tables I'll also point out that this is false as well. Unique salts per hash also prevent mass parallelism. If you have a database of 10 million hashes, if they all use the same salt, you can check a candidate word against all 10 million hashes in one go for the cost of one password hash calculation. Doesn't matter if that's using bcrypt or scrypt, etc, a static salt would destroy a large part of their resistance (things like oclhashcat can detect if you feed it things like bcrypt/scrypt with static salts and increase their speed on such hashes). You have to use a key derivation function in conjunction with a unique salt in order to prevent GPUs from having great acceleration on password cracking. You can even throw in memory requirements on top in order to make ASIC resistance appear (see Argon2). They rely on each other; if you do any of them wrong you reduce the resistance against attacks.
[Follow this guide to acquire and install an SSL/TLS certificate for your mail server](http://arstechnica.com/information-technology/2014/03/taking-e-mail-back-part-2-arming-your-server-with-postfix-dovecot/1/)
Yeah, I don't mind using Laravel, it's useful but I wouldn't say that I love it.
Amen. I've been writing PHP since there's been a PHP and I personally consider Laravel to be an abomination. An over-engineered miasma of cute abstractions that attempts to turn PHP into .NET, and does it horribly. That said, I have to work with it every day. If you just give up caring about things like the number of method calls being made under the hood and complete over-reliance on magic methods, then it's nice. But I personally feel like Laravel is so far removed from the language that you could be a Laravel developer without knowing a shred of actual PHP.
Well if one of the values is "0" but it should be 0 (for whatever weird reason) it might cause issues but you'd have no way of knowing the type is wrong when using print_r. Just playing devil's advocate here.
I can give you three good reasons. First, because if your web application gets hacked the attacker apart from all the users' data will get the ability to login and do anything to your website as any user. Imagine what is going to happen if the attacker is able to login as an administrator to your site. Second, many users use the same password in many websites. That means if your database gets leaked, the attacker will be potentially able to hack a user's email account and then reset the passwords and gain access to any account that user has on any website e.g. Facebook. This off course will not work if the user has enabled 2FA for his email account, but most users don't. Third, by properly hashing the users' password not encrypting them (bellpepper explained the difference on his post), no one including you will be able to decrypt them. Currently a very popular method of phishing is to just setup a website that provides a service for free and then simply let users sign up using their email and a password. Then the attacker can take the user's email and password who used to sing up and try with them to login to their email. By hashing the users' passwords and making that clear in your privacy policy, the users can know that your site is not one of these phishing sites. Remember a phishing doesn't have to be a fake site that tricks users to login, it can be an actual website that provides a service for free in order to make people sign up. This way the attacker will collect email addresses and potentially the passwords to the user's email. If enough users sign up eventually the attacker will get access to the email accounts of some users.
The N + 1 select issue is a good point that AR definitely makes easy to fall into. However, I would go easier on the pattern. Only holds up in basic CRUD? That sounds rather familiar, like when people say PHP only holds up under basic web development. With AR vs DM we could be talking about only this minor difference in interface signature. DataObject::save(DataObject $object = *$this) vs DataMapper::save(DataObject $object) An ORM can implement one or both. You can arbitrarily extend any ORM to become one kind or the other too. DM is a great way to teach the benefits of separation and modularity, but I think there is a bit of dogmatism in SOLID :( Though, I am not writing PHP much these days, so uh... don't listen to me.
With DataMapper you can easily load and save very specific *sets* of objects. Saving one object is merely a special case of it. Additionally, such seemingly trivial differences as you show are often the difference between a good practice and a dead-end. Say, the difference between flexible DI and tightly entangled classes with global shared state can be this: class Foo { function __construct($x) {$this-&gt;x = $x;}} vs class Foo { function __construct() { global $x; $this-&gt;x = $x;}} Don't compare architectures by Levenshtein distance :-).
mailgun's free tier gives you 10,000 free mail monthly. they have APIs that you can use for sending, and checking the status of your messages. 
Why not both? 
6.5/10 troll. Better luck next time.
If you're typing mcrypt_* into a code editor, you're doing it wrong. Stop using an unmaintained crypto lib. OP, check out phpseclib. Much easier than worrying about how to do this correctly. Even better, outsource your card data storage to Stripe or similar. Let them be responsible for it.
The way to go, IMHO, is to use https://github.com/nikic/PHP-Parser , write a traverser with the matching logic.
All good advice. I do think it's the better practice overall. Every ORM I've ever used in production was in the DM pattern. Regarding the importance of "flexible DI", I've spent a few days now disentangling the classloader, file reader, writer, and memcache of this java app, and I suppose you've known a similar pain, but that's somewhat of a different topic.
Personally, I'd say don't use MySQL NOW(). Let alone timezone issues that others have mentioned, it means the source of current time comes from 2 places. If you ever end up on a hosting environment where the DB and App are on different servers, and those servers run different time clocks .... Instead, always get the current time in PHP in a known timezone and put in SQL yourself.
Great post! But, please don't perpetuate the common misconception that `functional programming` is `procedural programming`.
This
I use this for very small projects that usually consist of a few static files.
Stuff like this line is all legacy code from v1 and v1.5: https://github.com/joomla/joomla-cms/blob/ec8a72f4cd0519786b9001dd3dd593131e7d32d2/libraries/joomla/crypt/password/simple.php#L151 This is all just to keep old passwords, if imported, working. Once an old password is detected, it is rewritten on next login to use a Blowfish hash ($2y$) and PHP's crypt function. I can't speak towards the rest of the code though.
Were these raised in private to the security team before this public disclosure?
&gt; Without seeing a single line of code. You can tell more about the quality of a developer by the way he plans his code than by actually seeing his code. &gt; Apparently this is how you form all your opinions on software development - by pulling them out of your misinformed ass. Not quite. As long as somebody doesn't seem like a total asshole and doesn't use stupid idioms, I often take a deep look at the way he plans and writes his code to form my opinion. Thankfully you don't fall into this category, so I don't have to do so. &gt; Obviously you didn't read the links. Pearls before swine I suppose. Total waste of effort. Kinda. I know development good enough that I don't have to form my opinion based on random links. Do you know why so few errors would be fixed by static typing? BECAUSE MOST LANGUAGES ARE STATICALLY TYPED, SO THESE ERRORS ARE FOUND DURING DEVELOPMENT. That is not a difficult concept to understand. Very few people are killed by dinosaurs, so dinosaurs are not dangerous! No, there are no dinosaurs, so they can't be a problem. &gt; Which really reduces the persuasiveness of your argument a lot Who started being an asshole? Hint, not me. &gt; since you're the one who started preaching complete unsubstantiated (and incorrect) BS about software development to a complete stranger on the internet. Since you are the one circle-jerking about his outdated development methods and starts crying because total strangers on the internet don't agree with you. &gt; I took that cue from you when you decided I was a "bad developer" based on refuting your completely wrong viewpoint. Because forming my opinion on developers based on the very basis of their code is such a bad concept! Seriously, if I said I like to write EVERY SINGLE ONE of my functions as a variable $s = "substr"; $str = $s($x, $y); would you think of me as a good dev? No? Then why should I think like that of you even though you are against very helpful concepts?
Non-Blocking, quite similar on how node does it: * http://reactphp.org/ (similar to nodes approach) * http://amphp.org/ Cooperative Multitasking using co-routines: * http://recoil.io/ there should be www examples for all three EDIT: forgot this one earlier https://github.com/icicleio/Icicle
I love AltoRouter, especially for small projects. It is also very simple to use the routing mechanism to actually call controller methods: if($match) { $target = $match["target"]; if(strpos($target, "#") !== false) { list($controller, $action) = explode("#", $target); $controller = new $controller; $controller-&gt;$action($match["params"]); } else { if(is_callable($match["target"])) call_user_func_array($match["target"], $match["params"]); else require $match["target"]; } } else { require "static/404.html"; die(); } Mind that I never tested the second part of that code, I always simply assing every action to a controller.
POPO?
Plain Old PHP Object. In the Java world they're referred to as [POJO](https://en.wikipedia.org/wiki/Plain_Old_Java_Object) 
I like this a lot. Definitely will try this out later, thanks! 
View::make and Redirect::to are definitely two instances where I would recommend just ALWAYS using facades. Firstly, their outputs are essentially entirely predictable based on their inputs, since once simply loads a static file and one creates a HTTP response with your input. Secondly, any testing of these constructs is going to be at the integration level so mocking them is useless. 
Nothing.
I feel there is absolutely nothing wrong with it. I've built, shipped, and profited from multiple applications using it. Never once has ActiveRecord ever been a problem with those applications. Ever. Not even close. Not to mention the other large companies running on it:GitHub, Shopify,AirBnb, etc
I think this response covers it, https://github.com/joomla/joomla-cms/issues/8329 &gt; May I ask you to send potential security issues in future to our security team using either https://developer.joomla.org/contact-security-team.html or security@joomla.org.
&gt;Who started being an asshole? You did when you stopped talking about programming and started taking about me. And your argument is totally based ad hominem attacks rather than actual evidence.
swiftmailer + sendgrid
Because I would sue you into oblivion if your system leaks my data and it causes my bank account to be compromised. Bad password choices are irrelevant. If you store secret credentials it is your responsibility to keep them secure. If you fail to do that, you can be held legally liable for the damages caused. This is the reason that large companies try to get out in front of large data breaches by purchasing identity theft protection for customers whose data was breached, even if it was stored in a secure format on their servers. 
You can do that with `file_get_contents` too, but it's a tad obtuse.
Or you could just use whichever works for you and not make a mountain out of a mole hill.
&gt; ...Oct 1 2014, to be exact. At that point I deleted the few WordPress installs I had set up, since i didn't use or maintain them, problem solved. Now fast forward 13 months to this morning, when I'm getting the same error message when I hit my site. 2014 you deleted everything and now you "hit your site"? what site may i ask if you deleted everything? sorry bro but you're full of shit. cool piece of malware and analysis of it in this thread though. 
Do you really want to be [that guy](http://www.commitstrip.com/en/2013/09/02/crime-contre-le-code/)?
Wordpress has a coding standard: https://make.wordpress.org/core/handbook/best-practices/coding-standards/php/ Unless you're talking about plugins not following the standard?
&gt;You're the one doing that. No I'm not. &gt;OP asked why anyone would use print_r Which is me. &gt;I gave some reasons. Yes you did. &gt;Pretty simple, bud. Peace out. All right then.
Thanks, fixed the link.
&gt; I saw a grizzled unixbeard do something similar many years ago If he hasn't patented it, this may be your chance. Lots of companies out there using your invention without paying. That's not fair!
Let's rephrase this question: "ELI5: What's so bad about a hammer. For clarification: I meant hammers vs screwdrivers. Sorry for any confusion."' Answer: They are both great tools if chosen wisely. E.g. don't hit a screw in the wall with a hammer. You could (try it once for fun), but you're better off with a screwdriver in that case. Is a hammer useless? Nope: try screwing/hitting a nail in you wall...
Hey there, sorry for the late response. I took a first pass at it! Let me know if you update it and I can take another look.
* fork? We're using stream_select() in the native version. It's good enough for 98% of cases. * Now, imagine an Apache bug… you can't fix it at all, because it's too complex for a first-comer. And yup, precisely. Awesome.
This means we'll have a new presumable date, November 26th. I really hope we'll get it out by then.
Cool, I have a PHP 7 project I'm developing, and I sort of fell behind, so this gives me two more weeks to get it ready for public consumption :D
A break during thanksgiving to upgrade your servers.
I wish you well, Scott. But I don't think it's healthy for me to continue this discussion, or otherwise interact with you going forward.
Understood. Good luck with all your projects and ventures.
http://seclists.org/fulldisclosure/2013/Jun/149 Sidenote: Looks like I'm not the first to report signs of trouble in Joomla's cryptography either.
&gt; it is rewritten on next login to use a Blowfish hash ($2y$) and PHP's crypt function Why did the Joomla team decide to take it upon themselves to implement their own hashing instead of using the password API when available, and falling back to password_compat when not?
one hour later... you're working on it now or are you still reading reddit?
42
Aaaannnddd [no](http://news.php.net/php.internals/89100).
Thank you, it was an interesting read. 
good, a 1 month wait is nothing if the quality is not on par atm.
&gt; Which is me I was referring to [magkopian](https://www.reddit.com/r/PHP/comments/3rruxe/nilportuguesphp_forbidden_functions/cwqz4p1)
No, I am too
Nobody should upgrade their serious servers the moment PHP 7.0 comes out. There is always surprises in the .0 release.
Thats why you've been testing the betas/RCs on dev clones of the website for awhile, right? RIGHT? Mitigate the issues. Heck, to be fair, I just said "servers", not "prod servers". Upgrade your dev servers in the corner after you've finished your turkey.
It's from the mailing list. Try here instead: http://www.serverphorums.com/read.php?7,1339936
As a Debian Stable user this whole PHP 7 thing makes me feel like I live in the past. I really hope the next stable release will include PHP 7.
[removed]
*"A foolish consistency is the hobgoblin of little minds, adored by little statesmen and philosophers and divines. With consistency a great soul has simply nothing to do. He may as well concern himself with his shadow on the wall. Speak what you think now in hard words, and to-morrow speak what to-morrow thinks in hard words again, though it contradict every thing you said to-day."* ~Emerson I think most in the community prefer that PHP is a slave to quality and not a slave to dates. So it's very reassuring that the project quality is monitored carefully and on an ongoing basis. It'll be a great release!
Thank you so much for your efforts Andrea. Php is really shaping up
The time you've spent trying to justify incompetence is longer than it would take to just do it properly.
It will be worth the wait I am sure :)
Why?
xdebug profiler and webgrind http://www.xdebug.org/docs/profiler https://github.com/jokkedk/webgrind
It's a really common C anti-pattern that kind of pervades bad online C tutorials http://c-faq.com/decl/main.html void main() { } being the C equivalent
Could do with some syntax highlighting for quotations but besides that it works pretty well. There are probably other places like Google Groups if you can stand their UI. But that's the best you're gonna get until they stop using archaic messaging systems.
So, does assigning the result of a function call that should return void end in a fatal? If it doesn't, this could be real bad.
Nice but it would be great if you could pass in a controller method to the map call instead of a file path.
http://www.urbandictionary.com/define.php?term=ERP ?
 if(!$match) { require "static/404.html"; die(); } $target = $match["target"]; if (is_callable($target)) { call_user_func_array($target, $match["params"]); } elseif (strpos($target, "#") !== false) { list($controller, $action) = explode("#", $target); $controller = new $controller; $controller-&gt;$action($match["params"]); } else { return $target } No more nesting of if statements.
Most likely they mean Enterprise Resource Planning, but I would be lying if I didn't think the same joke when I saw the subject.
Woah, thank you for the detailed answer. What is special with blackfire?
Are you looking for an open source ERP? What do you need, specifically? There are no large PHP "ERP"s that I'm aware of, but there are large ecommerce platforms (Magento, Woocommerce, PrestaShop, Thelia). In general, for opensource, I would recommend Apache OFbiz or ~~Opoo~~ ~~Oboo~~ Odoo. There are others, but asking for an ERP is like asking for an operating system -- it depends on what you want to use it for. Edit: spelling for /u/kutapaki OpenERP is a lot less embarrassing to say and more descriptive. Not sure why they renamed it.
I know little about Ops, but the performance gains seem like they'd be a huge benefit if you're paying for processing power on the cloud.
[strace](http://linux.die.net/man/1/strace) - and here is a [script](https://gist.github.com/Danack/de16db746dd2c6a29c8d) that would allow you to attach it to a running PHP-FPM process. One of the ways strace can be used is to give you a breakdown of all the system calls that are made by an application. I believe most poorly performing PHP application are due slow more to having more system calls needed than necessary, particularly filesystem accesses. 
Depends entirely on the app. Something like Magento is completely bottlenecked by PHP. At work we'd run 20-40 XLarge instances of front-end servers and just 1 master and 1 slave MySQL server. 
I was mostly looking at it because it seems simple to set up compared to Xhprof. Blackfire was originally based on Xhprof but was rewritten. Recently I read [this post](http://blog.blackfire.io/performance-impact-of-the-php-garbage-collector.html) about profiling garbage collection in Composer, which is a pretty nifty feature.
The biggest open source ERP in terms features and functionalities is [ino ERP](http://inoideas.org), and it's PHP based. inoERP is quite complex and you might get lost if you have not worked in big scale ERPs sch as Oracle/SAP. (it's far more complex than ban, Microsoft) If you are looking for something simple then can try [webERP](http://weberp.org). webERP has a very old architecture (PHP 4 kind) 
From looking at the docs linked, I think main is supposed to return an int: &gt; function main(void) : int { } What this has to do with PHP I'm not sure.
So you're saying the mailing list should stay ugly? I mean, It's so easy these days to make web look better. Why not?
FINALLY. I found the one ☺
I generally use blackfire these days. Xdebug is amazing and so is xphrof, it's just blackfire's GUI is really really nice and it's easier to set up. Sadly you can't get the premium features for single users but the free stuff is still good enough for my needs. http://www.blackfire.io 
Simple fix: Refuse to list plugins in the official Wordpress plugin repo if the plugin does not follow the standards. There's a LOT Wordpress can do to fix their broken ecosystem. They just choose not to.
same here :)
Why build something new when loads of other brilliant resources out there exist?
~~Opoo~~ odoo
Played around with PHP7 this weekend, at first glance everything is working very well and I really love the addition of scalar type hinting, return type hinting and anonymous classes. Such a massive step in the right direction, IMO the only thing I'm really missing is generics. Definitely worth the wait!
BC only in the "every other language uses this term" sense. Holding onto the implicitly returned null is pointless, not harmful (unless you try to call a method on it or something, but the return type just makes it more obvious it will break). But it's something static analyzers will probably complain about though. 
Thanks. This helped a lot. It is just a 24h project , what we now have is a design and our database structure. We want to make some quizes about the languages and after every question for example a % bar goes on and on etc. Then some jQuery to make it fancy etc. 
Glad to see them taking their time. No rush at all. We're not upgrading out 5.6 servers until after the new year anyway.
Yeah, great and of course you're right, full blown parser not necessary, nice :) Looking just at the commit: - do you really need to cal `$this-&gt;getForbiddenFunctions($configFile)` for every "token"? Can't you just get them once for every file or better, for all files? - out of curiousity, if you don't mind (because I'm too lazy to actually run it right now ;), doesn't `$code` contain the function name, making `strpos` possible obsolete and use something like `in_array`? :-)
Unfortunately I think this approach is not appropriate what I try to achieve. I failed to explain that in detail, so the fault is on my part. "Usually" a PHP project runs with little modification using the built-in server (but no concurrent requests of course), so I try to expand on that. I event-based approach like NodeJS won't work, because simply there's no bootstrapping/boilerplate for this (and I don't want to write it) and last time I looked at react, any attempt failed because most library can't handle that approach (yet; with some nice exceptions like Guzzle).
Yes, you're answer is spot on. We tried the "multiple instance" approach but it's too intrusive to the project/framework and thus want a cleaner solution. Thanks!
Would you say that you feel that it's basically personal preference at that point then? I've not really used AR much, how does testing work with it?
http://why-cant-we-have-nice-things.mwl.be/
Use an API whether Mailgun, Mandrill or Sendgrid. These are specifically for email and saves you from the headaches of using SMTP yourself. :)
Why not use a public API dedicated for this rather than create a spider/crawler that you'd have to alter for almost every 3rd party you crawl, such as [Google Places API](https://developers.google.com/places/) or [Yell Places API](http://www.yellowapi.com/api/places/)
&gt; Would it be a better option to connect the PHP to a 3rd party service such as Mailgun or similar to send outgoing mail, and if so, is this difficult to do? Generally speaking, I think so. I switched over to using Mandrill (an API email service run by mailchimp) and I couldn't be happier. I needed some way to capture and act on bounced emails and their webhooks made it really easy to do this. It is free for sending up to 12k messages a month and pretty reasonable for volumes beyond this. 
Interesting. Can you guide me to the repository?
Exactly the reason for asking this question - I didn't realize there'd be an easier way. One answer is that I'd like to play around with spiders from scratch anyway as I'll most likely have to make another one - they're pretty useful.
So you want to write a project so people can learn the languages you use to write production systems? Why not work on the production systems with code review?
&gt; So you're saying the mailing list should stay ugly? No, I'm giving you the reason it *is* ugly.
RemindMe! November 26th "check on /u/sarciszewski php7 project"
Messaging you on [**2015-11-26 13:41:29 UTC**](http://www.wolframalpha.com/input/?i=2015-11-26 13:41:29 UTC To Local Time) to remind you of [**this.**](https://www.reddit.com/r/PHP/comments/3s1ggf/php_7_is_not_coming_that_soon_rc/cwu1dzf) [**CLICK THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/3s1ggf/php_7_is_not_coming_that_soon_rc/cwu1dzf]%0A%0ARemindMe! November 26th ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! cwu1e9k) _____ |[^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^([Custom])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^([Your Reminders])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^([Code])](https://github.com/SIlver--/remindmebot-reddit) |-|-|-|-|-|
Yes it's absolutely personal preference. Testing works the exact same no matter what you choose.
There is a link in the footer. Not sure if that is active or they moved to github TBH
I'm missing the PHP 5.6 benchmark using phpdbg? Other than that, nice! Didn't know about phpdbg!
Personally, I'd prefer nullables and method overloading rather than union types, since method overloading seems much more universal and benefitial in the long run (but I know the method overloading is pretty much hated by internals) - and if there ever was need for unions, adding unions after you have method overloading seems like an easier process than vice versa. :( Generics I wish they'd happen, but based on internals reaction to most generics topics, I can only keep dreaming I guess. Callable typing in 7.1 would be great though; is there an RFC already for that and I just missed it, or are you planning to do one in the future?
So far this thread has 4 upvotes and no comments, so all I wanted to say is I can see why Seinfeld was so successful.
i blogged about doing it with slim framework 3 a while ago, and this approach could be used with any other psr-7 based framework. https://devedge.wordpress.com/2015/08/09/king23castle23reactphpslim-framework-3-0-for-the-fun-of-it/ however you are correct about the libraries. Now from your edited post, i think maybe https://github.com/php-pm/php-pm is what you are looking for?
Nobody is using PHP7 yet and nobody has said anything bad about it either, so no rush; Just make sure it works.
I like it. Just needs a PHAR.
Yeah, completely dropping PHP 5 support from Debian is not going to happen any time soon. Debian mainly focuses on stability and the incompatible extension is not the only issue.
Should it be added to composer via a pull request?
Specifying the parameter and return types for the callable type is something a bunch of people have wanted (e.g. it would fix some issues with strict scalar types). I thought someone had a draft RFC for it but I might have been wrong. I'm sure someone will do it though. If not me, someone else will. Edit: Márcio Almada was the one working on it.
https://github.com/FriendsOfPHP/Goutte this has all you need to write a decent web-crawler in php, its basically a bridge between guzzle and the symfony dom-crawler.
Fuck it, PHP 8.
[removed]
I tried Blackfire a few weeks ago and I don't really get it. I found the UI really confusing whereas qcachegrind and webgrind are both completely intuitive. What does it do that those tools don't?
id rather spend my time writing business logic and trolling reddit.
&gt; Not any more. Odd. I'm looking at my web control panel right now and it shows I've used about half of my free 12k sends this month before payment kicks in. Maybe I'm grandfathered in or something.
ib someone makes this thing put in PRs like Greenkeeper.io does for npm.
If you're running it on HHVM, 'perf' from the linux perf tools; it's especially nice as it isn't just for your PHP code - it can look at multiple processes or your whole system: eg it will say that &lt;x&gt; php function is slow because it's calling mysql_query(), and mysql_query() is slow because it's doing &lt;y&gt; in libmysqlclient, and that's slow because it makes the server do &lt;z&gt;, and that's slow because the kernel is doing &lt;something stupid, probably involving auditd&gt;.
This was asked recently, take a look at https://www.reddit.com/r/PHP/comments/3ob348/why_and_where_to_use_class_name_resolution_via/? Hope it helps.
I filled it ;) It's just too bad you can't select more than one language, my own server and the servers at work use more than one "main" language.
Well... basicly you are right, canonical MVC (1979) isn't possible in PHP (neither on the backend) since it requires view to has a state, but... &gt; The php file itself IS the view No. PHP file is just a single PHP file. It can be anything. It is just a file. &gt; The controller should be accessible FROM THE VIEW. View shouldn't know anything about controller. Controller should process user input and pass data to model for processing. View just reads the Model and watches it changes (via observable relations). And since on the backend model is stateless (in context of request/response) you can just skip observable part. &gt; to make 10 API calls for every single database query this is model concern (actually service layer, but this is in scale of whole app). All this data-processing stuff should be encapsulated into model (service) and some DTO should be passed to the view (for simplification reasons controller also exposes data to the view, and this is true even for frontend) Few days ago i [draw a simple](http://i.imgur.com/zc3gExi.png) diagram to illustrate MVC pattern for some peoples (very sorry for my bad english)... The main thing is that MVC is something small, it doesn't describe whole arch of application. This is just a small part which responsible to segregate data presentation from data processing. The same thing can be applied to backend, the main difference is that you can skip observable relations between model and view. Also `Model` has nothing related to active record model. This is just some component which encapsulates data processing (or business logic). Controller handles HTTP requests, extract data from it and passes it to some Model (Service actually, or command bus, or something else what will process data in order to fullfil business logic). Service will return some state (DTO) of itself and then this state will be passed to the view. Anyway... most of the framework is just a interface framework, the **bad thing is the substitution of concepts**: Model became not something abstract but something concrete.
&gt; Controller handles HTTP requests, extract data from it and passes it to some Model (Service actually, or command bus, or something else what will process data in order to fullfil business logic). Service will return some state (DTO) of itself and then this state will be passed to the view. That's a relatively good description of [Action-Domain-Responder](http://pmjones.io/adr). 
i.e. Laravel. Or would that be considered magic lasagna?
The view should have access to the controller methods and variables. The view should be able to obtain non-static data whenever it needs to. Abstracting this logic so that it is solely contained in the controller is a complete anti-pattern. Your diagram, while neat, displays the over-complication of layer non-issues which are solved by PHP in a much simpler and more elegant fashion.
&gt; The view should have access to the controller methods and variables No it shouldn't. Controller also shouldn't store any data. It just exposes data to the view: $this-&gt;view('some_template.twig', [$some, $exposes, $data, $or, $dto]); &gt; The view should be able to obtain non-static data whenever it needs to. The view should already has all the data it may need. Not view decides what data it needs, we just passes current model state for it. &gt; Abstracting this logic so that it is solely contained in the controller is a complete anti-pattern controller doesn't contain any business logic. It just converts http request (for this particular example, it could be CLI arguments and options) to application request (DTO, command, use case). This application request then passes to the service layer (single method call of service layer per action, thin controllers and stuff) and recieves current model state (DTO) which is passed to newly created view. &gt; which are solved by PHP This diagram is for angular developers, not for PHP. But this is pretty the same for backend, except that only stateless DTO will be exposed to the view.
&gt; if they do not use a targeted framework. framework is just a bunch of tools, You can get some PSR7 implementation as your entry point, add some routing component, some ORM, PHP-DI for example and... you can your own framework, which isn't hard to support since it already based on well known solutions. But yes, there should be a reason to do that. https://www.youtube.com/watch?v=0oGpWmS0aYQ
A class for CRUD and database manipulation operations, a class for pulling, displaying, and filtering the data, and a php file used to display the user interface and perform functions utilizing said classes.
You don't need to reload nginx. When using nginx &amp; FPM it might actually be enough to change the nginx FCGI parameters to supply realpath to PHP as script path instead of the symlink to the document root and you don't even have to reset the cache as PHP will get the newly resolved path from nginx. I couldn't use it like this because I have a legacy app with include paths and auto prepend file pointing to the symlinks which is outside of nginx's jurisdiction, so I don't know if it works with proper modern apps... it probably does.
App quality should not be judged on what frameworks were/were not used.
&gt; We're talking about PHP here. You can write GUI application in PHP. MVC is GUI architecture pattern. As already mentioned, ADR is fits better for backend. &gt; A view file is perfectly capable of executing the exact same code as any of the model / controller class files. In this case you are mixing responsibilities of model and view and will lose segregation between data presentation and data processing. And this is MVC is all about. Also the view is not a file, this is something (possible object) which responsible for data presentation. The simplest possible case of view is `echo json_encode($dto)`. p.s. Do you use some code igniter or yii maybe?
What would you suggest? It's a mailing list and in monospaced so they can post code without worrying about it being thrown out of whack or having to do special formatting. Only think I can think of would be to use markdown.
No, laravel is broken on HHVM. But only a little? http://hhvm.com/frameworks/
I don't usually write many global functions, since I'm almost always using a framework, in which case anything complex enough to warrant a function that isn't also covered by the framework usually gets it's own class. In your specific case, I'd probably create a [Repository class](http://code.tutsplus.com/tutorials/the-repository-design-pattern--net-35804) to contain the query logic and then set up [PSR-4 autoloading](http://www.phptherightway.com/#namespaces) so I never need to worry about writing includes or requires. [http://www.phptherightway.com](http://www.phptherightway.com) is a great resource for learning, by the way, as is [http://laracasts.com](http://laracasts.com). Many of the tutorials there are specific to the Laravel framework but a lot of them cover more general topics like writing good Object-oriented code.
&gt; I would like to know where would be the best place to check the permissions. For fetching users. Admin can list all of them, user only from his group. Should I check that in the repository method getUsers()? If your scoping rules are pretty consistent, scoping within the repository is really nice. There is a good article [here]( http://culttt.com/2014/03/31/multi-tenancy-laravel-4/) about how to implement it. You can see an example from Taylor Otwell's old workplace [here](http://blog.userscape.com/post/organizing-snappy). I prefer that approach so that your scoping business rules aren't scattered throughout the application. &gt; Where should we validate the incoming request? I validate using the FormRequests. I check the types are correct (string, int) etc but I'm not doing advanced business logic stuff like 'can this user update this field' in the FormRequest. &gt; Do I need a factory? I usually just use a constructor on the model, and add a factory if it gets really complicated. Re: why not put it in the repository; The repository is for interacting with some sort of storage layer to get and save objects by their ID. When you make a new user they don't have an ID yet, and creating an object doesn't need to interact with the storage mechanism. &gt; I plan on using Dependency Injection and staying away from Facades :thumbs up: Once you stop using facades you might find yourself needing to inject 10+ classes in to another class. That's usually a sign you need to break it down in to separate classes. I still use the helper functions in my controllers since I don't unit test those and they are pretty much part of Laravel. &gt; What should the request lifecycle look like? &gt; user hits page &gt; middleware (authentication, check permission) Yep &gt; form request (validate the request, if the object has a parent_id check if user can use the parent id here?) Not sure what the parent ID is, but basically I would do a broad validate() and authorize() here. If the endpoint is to update 1 specific entity (user id 2) you could check they are authorized to update user id 2. &gt; controller (create object using factory, save using repository) You _can_ do this in the controller. Since I might want to create users from a cron job or a beanstalk job or something, I create an 'application service' that handles interacting with the repositories and factories and stuff. Then my controller basically does `$this-userService-&gt;create($userId, $email);` instead of dealing with all of that other stuff. It makes your code really easy to test since you don't need to deal with the HTTP Request/Response objects when testing the create user code, and you don't need to deal with all the create user logic when testing the HTTP part. The best resource I've found for learning about repositories, services, factories and all that stuff is [DDD in PHP](https://leanpub.com/ddd-in-php). It's about domain driven design but most of the stuff is helpful without going full DDD. They have a really good example with code in the back explaining why you would use a service layer. LMK if I can explain something clearer. Good luck!
It saddens me that people think blindly creating expressions like `f(g())` without first knowing the return types of `f` and `g` is actually a *benefit* of PHP. That really says a lot.
Why? If you're using it to check composer packages, you have composer obviously.
These are actions that take place in the Envoyer 'Activate New Release' stage: **BEFORE** # switch to the current release directory cd {{ release }} # copy the environment config from the home dir of the release user cp ~/laravel-environment .env # run database migrations php artisan migrate # create a symlink to the always-there node_modules folder ln -s /sites/envoyer-mysite/node_modules/ node_modules npm cache clean npm install # run my elixir build gulp --production **AFTER** # Notify rollbar.com of the release curl https://api.rollbar.com/api/1/deploy/ \ -F access_token=MYSUPERSECRETTOKEN \ -F environment=live \ -F revision={{ sha }} \ -F local_username=`whoami` # cache the routes cd {{ release }} php artisan route:cache As you can see there's no need to fuss with permissions. If any of the 'before' scripts fail (npm install, for example, or the database migrations) the deploy is aborted. There's no need to run artisan up/down. If you're REALLY concerned about permissions just write something to check them in the pre-deploy script. 
The website uses the public nntp server as its source of truth. You're welcome to write a new one.
Sound like you want Hack! :)
In your case id put a bunch of functuons in a file, but split them up by topic (Database stuff in one file, html stuff in another...). Youll be more organized, have fewer files and get fewer bugs than when you have the code in a file. Now this isnt really best practise, but works. Once you want to learn a more "modern" approach you should look into composer and phptherightway. 
Or you know.. Php 7
I thought you were being sarcastic - but looking at your other posts here I'm guessing you're serious?
&gt; PHP is better as an OO language than a functional one
"Deployer" is another good option, in php
&gt; I'm trying to accomplish as little db queries when not necessary. **This is where you took wrong turn.** There is *absolutely* nothing wrong with db queries, yet many PHP users indeed suffer from *queriephobia* - a completely groundless syndrome. A database is intended to run queries, nothing wrong with it. Not to mention that **a database has its own means of caching query results.** What you really have to be concerned of, in order of importance: 1. To make your queries run FAST by means of optimizing them. 2. Instead of caching just arbitrary query results, **you have to cache only the data that takes significant time to gather**. 
Ah yes. The "stick everything in a class" method. I so don't miss working with PHP devs. 
What's your plan then captain constructive?
This is a great aim, but I suspect is an order of magitude over OP's head. The question was, should I use functions rather than no such constructs at all? The answer is a resounding "yes". Do move on from there quickly, but understand how functions work and can be used. Move procedural code out of the global context.
I think everyone has missed this aspect of the question.
K.
I wish i could use blackfire, but since they are not providing on-premise solutions that is a complete no-go. 
I have a feeling they will start providing it at some point, since they'll be missing out in quite a bit of business by not having it.
convert it to DOM tree and then iterate, stripping unwanted tags or attributes
I'm sorry but what is the point of this library? On what exactly are you looking for feedback? I'd say that the functions should, instead of: if (is_array($variable)) { return true; } else { return false; } be return is_array($variable); but I'm at a loss as to what it is you're trying to accomplish. Don't get me wrong, I encourage experimentation and learning on examples, I'm just a bit lost as to what you're trying to do here - effectively, you just made native PHP methods longer to type out, while at the same time coupling this impracticality with your specific class.
He means to actually parse the content as HTML with this http://php.net/manual/en/domdocument.loadhtml.php If you are having performance issues with htmlpurifier, I don't think it would be an acceptable option for you.
Actually, the point of this library is to test and control the PHP native functions, so all the interest should be on the tests. For example, I didn't know the PHP function `is_int` recognizes a binary or a hexadecimal value as an integer. Another example could be the function `is_numeric`, because it accepts the hexadecimal, the binary and the octal values, but the documentation says it's not. I don't know if I'm wrong about that, but I'm just learning PHP and also I'm learning how to properly write and test PHP projects. Thank you very much for all your feedback.
Hi, I didn't understand Q1 and Q2, I'll only answer the last two: Q3: I've seen [debug_backtrace()](http://php.net/manual/en/function.debug-backtrace.php) used for that. Q4: IMHO you want each class to have it's own dependencies injected, so instead of passing $this to imageCropper and tableGenerator, you should pass the subclasses. Also: public function __construct(God $god) { $this-&gt;god = &amp;$god; } You shouldn't need to assign reference, since objects are passed as references already. Unless you want to do something weird to the god.
HTML purifier most likely isn't the problem, the problem is probably in your application architecture. Consider looking into implementing task queues (RabbitMQ, Beanstalkd, etc) to offload CPU intensive work. 
Okay, I'll improve the `ReadMe.md` with some documentation and examples. Thank you!
1. Broken link to examples here: https://github.com/Payum/Payum/blob/master/src/Payum/Core/Resources/docs/examples/1-paypal-create-gateway.md 2. How does this compare to omnipay?
Q1: I just need to structure try/catch blocks (because, catch block is duplicated in all abstract classes) in an inheritable way without duplicating it, because right now every abstract base class contains similar catch block, and I know duplications are usually caused by a bad practice design. Q2: - Q3: Hmm, I knew about `debug_backtrace` but never thought it would be used for that purpose. Thought there could be another magic, such as passing the object to the logger (somehow) and cast a reflection on it to obtain class name and namespace. Q4: Well, the God class depends on the sub classes, but sub classes needs to access God class's properties. Perhabs sub classes shouldn't be accessing god class at all?
Hi, Currently, you only need to run phpunit through phpdbg like in "phpdbg -qrr vendor/bin/phpunit" and code coverage will be collected.
&gt; How does this compare to omnipay? http://stackoverflow.com/questions/33018841/difference-between-omnipay-and-payum/33214384#33214384
Posting this here because I'm curious what people will think of it. It's not completely finished: everything works, but there's no tagged release because a few things still lack tests. I've been procrastinating about fixing that. If you're wondering how to use it, look up a tutorial for JavaScript's implementation. This isn't array typing in the typehint sense, but rather it's a way of handling binary data. So, for example: $pixelData = new Uint8ClampedArray(640*480*4); for ($x = 0; $x &lt; 640; $x++) { for ($y = 0; $y &lt; 480; $y++) { $pixelData[$y * 640 * 4 + $x * 4 + 0] = intdiv($x * 255, 640); $pixelData[$y * 640 * 4 + $x * 4 + 1] = intdiv(intdiv($x * 255, 640) + intdiv($y * 255, 480), 2); $pixelData[$y * 640 * 4 + $x * 4 + 2] = intdiv($y * 255, 480); $pixelData[$y * 640 * 4 + $x * 4 + 3] = 255; } } This makes a pretty picture encoded as 32-bit RGBA. Is it more useful than pack/unpack? That remains to be seen. They're more performant.
Legit data to me is what is expected to be contained within the defined field. If I have a table with some column named html that is a text field, I would expect it to contain html markup text. This is a valid use case especially if you're maintaining user defined markup which is something I'm sure many people do. We return that html markup as json encoded data in our rest api. Personally I would build out an API that allows users to define data elements as triggers rather than trying to allow javascript in html markup which html purifier filters out / breaks. This is how we handle it anyways. 
&gt; New accounts have 2500 free messages in total (not per month). Yowza. That is no good. I'm glad I got in on it while I could. Most months I don't exceed the 12k limit so it has been perfect for us but I gather they had to re-think their strategy. It sounded exceptionally generous to me when I signed up about a year ago.
What is with the crazy method names in ArrayBuffer? https://github.com/TazeTSchnitzel/TypedArrays/blob/master/src/ArrayBuffer.php 
Sorry the only real life use case I have is [Drupal](https://www.drupal.org) and if you're not a drupal developer that's going to be a large chunk of code to try to navigate in order to find the bit you're after. If you do go down that route, look at the comment module and the filter module.
Feels quite vain to post this here. But it's useful to clear things up.
If you are doing field validation in FormRequests where is all your advanced business logic? Would I add it to the Factory? I see how FormRequests could return a list of errors with a 400 code and the advanced business logic (for example checking is user has the right to edit a post) would throw a 403. Do you think that's a good approach? Services are another thing I haven't touched yet. Everything was going into the controller so far. I will look more into them. If I understand that correctly. The controller would call a service and this service decides what to do. The only question I can think of is if the service calls to factory or is the factory called from the repository? My first guess would be the service in case we wanted to add more logic involving the object before we save it to the DB. Is that correct? Thank you for the response. We will order that book and I will start reading up on Services and DDD.
You can emulate friends in a number of ways. For example, closures defined in a method are effectively anonymous methods. Whoever you give that closure now is your "friend" as they can call this method, without it having a public name. You can also bind an existing closure to another class, gaining access to its protected methods, without making them public. Another way is the "object capability" handshake, where a class has to pass in a secret empty object, which is compared to a protected property or else the method throws.
&gt; It makes no sense. When have you ever found a program breaking due to trying to use a 'void' function as a useful thing? I find the ability to chain any functions to be really useful for logging: function logResult($result) { fwrite(STDERR, "Result is '$result'\n".); } function fn1() : void {}; function fn2() : int { return 1;}; function fn3() : string { return "shamoan";}; $fn = "fn".rand(1, 3); logResult($fn()); This code is not only correct according to how PHP works, it also does what I (and everybody else) wants. No one wants to have code like this break just because we used 'void' instead of 'null'. &gt; It makes no sense. As I said before, this is why the return type should have been null.
Not going to copy + pasta the [whole reply](https://en.reddit.com/r/PHP/comments/3s2jxf/void_return_type_rfc_accepted_for_php_71/cwvairm), but when have you ever found a program breaking due to trying to use a 'void' function as a useful thing?
&gt; When have you ever found a program breaking due to trying to use a 'void' function as a useful thing? It's a lot more useful than doing the wrong thing. If you explicitly forbid a return value, then you can't access the return value. What we have now is a meaningless `void` keyword. "Hey, this function doesn't return anything, but have at it and get its return value." is much worse then "hey, your program broke here because you got out of your way to tell the interpreter that this function can't return anything and yet, something tried to access its return value." The function signature is a contract one must abide by. If you contractually agreed a function can't have a return value (you can't even return `null`!), then you also have to forbid its return value usage. It's only logical. Allowing use of `void` functions as values is prone to errors. &gt; this is why the return type should have been null I agree with you that having a `null` return type would make much more sense. But in the sense of having trully `void` functions, PHP should return `null` and throw an `E_NOTICE`.
&gt; How does this compare to omnipay? Docs. Omnipay docs are completely crap to non-existant for most gateways.
Passing a closure around is an interesting approach I hadn't considered. Similar things are sometimes done in JS, I think. I originally did use Closure::call() (binds and calls in a single method call, I added that to PHP 7), but it seemed like an inefficient way to do things and meant more code everywhere. The handshake is also interesting. What if you used type hinting? Pass yourself to the object, which only accepts your class, and it calls a method or something back on you? (Does that make sense?)
appreciate all your work and everyone gets tired at some point in their career. also, is there a video somewhere of your talk in October?
Great write up, thanks! 
&gt; Allowing use of void functions as values is prone to errors. No. It's only an error when you need a specific type. function acceptsInt(int $x){...} //requires an int function acceptsNullOrAnything($x) {...} //accepts any value including null function noUsableReturn() : void {} acceptsNullOrAnything(noUsableReturn()); //This code is fine acceptsInt(noUsableReturn()); //This code has an error. It's fine for a function to say that it doesn't return a usable value, other than null. But sometimes you explicitly want to be able to use that 'lack of value' as the parameter to another function, and in PHP that lack of value is represented as null. &gt; What we have now is a meaningless void keyword. Not going to argue there. I'm just saying that using void was the mistake, and we shouldn't compound it by fucking up the language, just to cover up that mistake.
A payment gateway with zero tests is not very reassuring.
I meant what I said. Functional programming is a paradigm you can almost sort of emulate in PHP. Not as well as other languages, but you can. I deliberately did not use the word "procedural" because that's not what I intended to say.
cringe