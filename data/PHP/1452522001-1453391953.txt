Yes and no. Shitty PHP you can learn from abudant last century articles and tutorials, is still the most easy language to learn indeed. It won't make you a programmer though, but a rather monkey-coder. Matured modern PHP that assumed most of the achievements in programming science of the age will require the same amount of learning as any other language. 
Friend of mine moved to Manchester in September to get his PhD. Seems like a very good reason to fly up there on company costs.
&gt; isset($obj-&gt;prop) === true Yeah it wouldn't make any sense to do it for PHP functions which return bools anyways. If they want you to do this, then theres no good reasons for it... its just someone wanting you to conform to their style.
php redis and memcached are missing... :/
Legacy? I installed mcrypt because Laravel required it. And Laravel is anything but legacy.
Using `===` is more characters but makes it simpler and there are fewer exceptional values. This reduces the cognitive overhead of considering other truthy / falsy values, means you don't need to write so many tests and makes refactoring simpler. With just `if ($foo) {}`, you have to consider whether the author of the code thought the value could be: * `""` * `0` * `"0"` (but not `"0.0"`) * `0.0` * `[]` * `false` * `null` * maybe some kind of weird null `resource` type that I wouldn't be surprised if PHP had This may only take microseconds in your brain _right now_ but code, people and business requirements change. Type ` === true` wherever possible and your future self will thank you. 
As far as I'm aware, Laravel no longer requires mcrypt, it's perfectly fine using OpenSSL instead.
This library has 120 contributors and only 8 stars on GitHub... Why??? I think this's really unfairly!
&gt; PATH/year/month/epoch.ext That is not very concurrency-friendly. It is *very* possible that multiple uploads finish at the same second. I would go for hostname-processid-microtime.ext followed by sleeping for one microsecond. Or keep a concurrency-safe counter somewhere, such as in a transaction-safe database.
I am well aware of Phalanger - but being a mostly-unknown PHP dialect, I did not reference it closely. Regarding it's syntax, it has a dedicated parser implementation, so I don't know why they chose the `&lt;: :&gt;` syntax - perhaps due to parser limitations, but either way, not due to parser limitations in the standard PHP parser, because they don't use it. I chose to reference other [gradually-typed](https://en.wikipedia.org/wiki/Gradual_typing) languages that have succeeded with generics - mainly TypeScript, which had to address many of the issues we face with generics in PHP. Being essentially type-hinted JavaScript, it has to address the fact that generic type-relationships are possible and already exist in plain JS codebases. We face similar challenges with PHP - for example, it has to work in a sensible way with existing un-declared generic type relationships, such as arrays containing only one type of key and element. Other referenced languages include Dart, which is also reflective and therefore and important reference - and C#, to some extend as a reference of things we *can't* do, because PHP is not compiled, and e.g. number of type-hints aren't even known until a class is actually loaded. Java was referenced, but did not directly contribute to any hard decision-making. Scala was not a source of reference, because I don't know it very well. 
- /r/phphelp - you need to make AJAX call triggered by that click, that calls a PHP script which will run your query 
Socket labs should have a test mode; others do. Use the test mode for QA configs.
How long ago was this / what version and its age? I don't and haven't used it personally but some half-remembered conversation is telling me it doesn't need it any longer?
Yeah, it is actively maintained. I'm just saying mcrypt was still widely used as late as last year.
Oh - also, I'm not even sure that letting people be able to select the algorithms is a good idea. Consider for a moment what happens if a vulnerability is found in one of the default algorithms. I guess in PHP 7.2 anyone using that algorithm would receive an E_DEPRECATED warning and then in 7.3 that algorithm would be removed all-together. You couldn't remove it in 7.1.5 because that'd be a BC break. But what if you instead including the algorithms being used in the message itself? The ciphertext could be in a container format that contains the algorithm info within it. Then you could change the defaults without having to worry about BC breaks. Old "ciphertext's" would still work - the decryption function would autodetect the algorithms (since they'd be included in the ciphertext) and decrypt it even if the encryption function never used them. But if we're going to go that route we're pretty much re-inventing PGP or S/MIME and at that point I'd have to wonder why we weren't just using PGP or S/MIME.
Have either of you done considerable amounts of work with a generic language? Most developers I know, who have, learned within a year or so why typed arrays are just the tip of the iceberg - it's the most obvious problem and the first and most easy to understand justification for generics to someone experienced with primarily (or only, say) PHP and JS. Generic arrays, however, are a subset of a bigger problem, which is type relationships, which, in a dynamic language like PHP, do exist - codebases are full of them. Being able to describe only some of them (arrays) would create another inconsistency in a language that's already full of them. That's the last thing we need. A feature such as generics needs to be consistently available for you to apply to type relationship problems of all kinds, not just the most obvious. Bottom line, this RFC aims for a consistent, widely-applicable feature, not another "quick fix" applicable only to a subset of problems. (see my notes above for pain points in Go, a language that went the "arrays only" route, albeit for other reasons.) 
if (function()) and if (function() === true) don't evaluate to the same thing - as you probably know. The latter requires the function to "return true;" (as opposed to "return 1;" or return "return 'true';") Using strict types can be helpful in identifying bugs by making programs act in an all-or-nothing manner. That's probably why they want to do it. It seems like a pain in the ass to swap, but it's usually better to be explicit with your types.
The node based Meteor framework is the easiest I have used, but I've never actually used it for production, just prototyping. So fast to crank out a working product, especially if you are versed in JavaScript and/or node. 
If you are familiar with the basic concepts like if else, loops then you can easily start development using frameworks. i would recommend you to start with Laravel even if you are newbie to PHP. 
You should point out that [isset() is not a function](http://php.net/manual/en/function.isset.php#refsect1-function.isset-notes), and therefore it should be exempt from their new coding standard. The same would apply to [empty()](http://php.net/manual/en/function.empty.php#refsect1-function.empty-notes).
gazillion upvotes
Yes and No. 1) You need to avoid all the shitty tutorials and learn the following: A) a proper MVC / Object Oriented process for developing websites. CakePHP, Laravel, etc. B) Functional programming (Aka the other decent way to write code) - this is harder since there isn't really a framework and its really, really easy for a newbie to confuse shitty tutorials from another age with how to do this correctly. So start with A, then from A figure out how to go to B. 2) Assuming you do #1 correctly, I'd say its *slightly* easier than Python, Ruby on Rails, etc. 3) Regardless of whether you do #1 correctly, Node requires one less language to learn (as you only need Javascript) but has massive pitfalls in line with PHP's shitty tutorial problem so I'd say its equal and equivalent to PHP for ease of learning.
May not be related to the reason at all, but who uses 1D barcodes anymore? Especially for online use? If I were to use any kind of barcode it would be a 2D one (like QR codes), but I still fail to see a large number of use cases. My guess is that someone tried them out, contributes to the library because of lacks, bugs or feature improvements, but real use of the library is really limited.
Nice article! Looking forward for the next ones...
As an addition: Once familiar with PHP other languages derived from C and even C itself will be more easy to learn because the syntax looks quite familiar to what you already know.
The repo was just a subtree split of zendframework: now it's the main component repo. Also: stable, maintained software isn't really "hip" in these days: people tend to star new stuff, even if useless or if they'll never use it.
Knowing that it's not 100% what you were looking for originally but might be interesting in this context: [secondcrack](https://github.com/marcoarment/secondcrack) is &gt; A static-file Markdown blogging engine.
EDIT: I'm completely wrong, as /u/mbthegreat pointed out below. Sorry about that. ~~Good article! Small correction:~~ ~~`if (!$a instanceof A) {`~~ ~~should read:~~ ~~`if (!($a instanceof A)) {`~~
interesting, the author of the weakref was just started on porting it to php7, he also mentioned that he isn't satisfied with some of his past decisions. edit: aaand the release is just out: https://pecl.php.net/package-changelog.php?package=Weakref&amp;release=0.3.0
&gt; May not be related to the reason at all, but who uses 1D barcodes anymore? We do, in our production facility. All the 2d scanners we've tried are *way* slower to scan than 1d scanners, especially when needing to scan multiple barcodes that are next to each other.
Echoing /u/mariobb I wish I had more than one +1 to give - this is one of my favorite refactoring techniques, and one that I see surprisingly rarely. For the sake of those not familiar the process looks something like: 1/ If/else madness if (expr1) { } elseif (expr2) { } elseif (expr3) { } else { } 2/ Transform this into the equivalent switch (true) statement: switch (true) { case expr1: break; case expr2: break; case expr3: break; default: break; } 3/ The body of each case can now be extract re-factored into a single-method interface &amp; appropriate classes $instance-&gt;dispatch($params);
I don't think any languages are really "easy" to learn. What's easy about PHP is the setup. You can be up and running with PHP with a very small set of tools. It even has its own server. You can even do something super simple like Digital Ocean with their pre-configured servers. Five bucks a month gets you a sandbox with everything installed that you could need.
&gt; I'm trying to understand why they want it, Because it makes checking for other types of errors be a lot easier, as you don't need to keep remembering, "oh this function is going to be returning a bool, we don't need to do an explicitly valid check" aka it allows you to document that the value the function will be returning must be bool, or there are bugs. For example: function areAnyWidgetsAvailable() { return false; } function getNumberWidgetsAvailable() { $widgetsAvailable = -3; //widgets are on back-order. return $widgetsAvailable; } if (areAnyWidgetsAvailable()) { echo "areAny says: There are widgets available."; } if (getNumberWidgetsAvailable()) { echo "getNumber says: There are widgets available."; } Both of these functions return values that can be checked without using === - but one of them is buggy as negative numbers are non-zero and so are considered truthy. The missing === on the first comparison makes the other one "blend in" to the crowd and be harder to spot in a code review as a problem. &gt; ternarty operations, and it's totally screwing with my head! Well....don't use ternary operators then..... 
Just to confirm, the author means to use `$this-&gt;names`, not `$names` in the two helper methods, right? class Names { private $names; public function __construct(array $names) { $this-&gt;names = $names; } public function reverse() { return new self( array_map('strrev', $this-&gt;names) ); } public function capitalize() { return new self( array_map('ucfirst', $this-&gt;names) ); } } $result = (new Names([...]))-&gt;capitalize()-&gt;reverse();
Not sure but does this actually make a difference? I thought `$a instanceof A` was already a single unit? Did this in PsySh: $a = new \DateTime; $a instanceof \DateTime &gt;&gt;&gt; true $a instanceof \StdClass &gt;&gt;&gt; false !$a instanceof \DateTime &gt;&gt;&gt; false !$a instanceof \StdClass &gt;&gt;&gt; true Your example is probably more readable but not sure it makes any actual difference, you're suggesting the default behaviour is more like (!$a) instanceof \StdClass &gt;&gt;&gt; false if I understand you correctly. Hope I'm not wrong because I've done it without the parens at least a few times!
Yeah, I just didn't expected that he will add it in near future, there was some reports in [issue about adding PHP 7 support](https://github.com/colder/php-weakref/issues/19) but no progress. Glad he found some time to upgrade extension. Anyway, I need notify-based approach, not poll-based. I guess two working extensions now are better than nothing, like before.
That's essentially what we do. Development environments have a different configuration file than live with different mailing settings (essentially rerouting all mail on the server to the same shared inbox without changing recipient information so we know it would have gone to the right place if it was live - I'm not sure how you do that if you just rewrite `to`, `cc`, `bcc` and so on to point to some other mail account), api credentials (hitting sandboxes instead of live, obviously), caching, error/warning reporting, job queuing, etc. It's the same services, but different servers. 
Just double-checked the [order of precedence table](http://php.net/manual/en/language.operators.precedence.php), and `instanceof` has higher precedence than `!` so you're absolutely right, the parentheses aren't needed. D'oh. Think I must've based my misconception that `!` has higher precedence on [this example](http://php.net/manual/en/language.operators.type.php#example-144) in the PHP docs.
&gt;&gt; Once you know that you're comparing booleans, don't overdo it But when exactly do we know we have a boolean? Unless working with PHP7, there is no way to guarantee that. Well if you exclude is_boolean(), that is. You can always display your intention by using PHPDoc comments, but unfortunately this won't keep stubborn people provide smth else. You are practically forced to "overdo it". I am totally fine with always checking for a real boolean / whatever type and I would always recommend this over being less aggressive while handling parameters or return values.
SymfonyCon 2016 in Berlin approximately at the end of the year: http://live.symfony.com/
sure, and props for your contribution!
Can you explain 3/ in more depth please?
I've used generics in Java, Rust, and Hack. I know how they work and I know what they bring to the table. PHP doesn't need them. You might as well just use Hack at this point, because it pretty much was created to solve this use case.
I believe they reference them as "[language constructs](http://php.net/manual/en/reserved.keywords.php)."
Shouting and saying "no no no" and being completely steadfast and firm in that position is good. Then you'll need to violate it at some point, and you run the risk of teammates complaining that you're a hypocrite. :) But I strongly support your view, and by and large I hold that same rule. I *do* also break it now and then, but it's generally a rare exception, and generally called out in the comments that "this is suboptimal and breaking the coding guidelines for the project". Having enough unit tests around the code in question helps reduce the concern, imo.
I usually alm for only one point of return. The alternative is just too spaghetti-y... 
I tried using a base64 decoder (google it, there are online decoders) but there is some nesting going on to further obfuscate and would take someone more familiar with PHP and encoding than I. Even though I can't fully decode it, the fact that it *is* encoded in the first place is a huge red flag for me.
https://ruxit.com does what New Relic does and a lot more (e.g. zero configuration and auto discovery of an application environment) at a lower price point.
I assume $this-&gt;names was intended, too.
Can't tell yet. It's got multiple levels of obfuscation...
For someone that did not do C at Uni, or any real programming and I am struggling to learn PHP, understand basics but struggle to put it all together. Could learning a low level language like C help me out?
This is properly decoded source: http://pastebin.com/U4USbAkt Together with .bat, it changes the Hosts file to redirect services.paradoxplaza.com to localhost:80, and responds to requests from game api I suppose. Seems to do no obvious damage.
Aside from whether it is safe to run, doesn't this cheat the server owner of revenue they can plough back into their service? (Wrong sub btw - you want /r/phphelp). 
Can I suggest that this thread is exactly why it should have the extra parentheses around it (`if (!($a instanceof A))`)... it would have saved a whole bunch of people a whole bunch of time looking up and testing in a REPL by making it very explicit what the intended order of precedence is :) 
Great read! I completely agree on most of this article, but I have to disagree on two points: 1. I feel like double checking for a boolean is actually a good practice. It seems like a good precautionary measure for future code changes. * Yoda conditions might have a high readability price, but the chance of making a hard-to-find bug seems like an even higher price.
Great stuff.
Thank you so much, I really appreciate it. Lovely subreddit. Thanks all! Edit: Out of curiosity, how did you decode it?
I would normally agree with you. However the game is dead, has very few players. They stopped supporting it over a year ago. Ta
**To Point #1:** &gt; "We encourage contributors to apply this etiquette outside our collaborative spaces." Moderators could certainly mediate or offer guidance (if either party requested it), but the proposal follows the idea that public moderators have a duty to public spaces, while owners a duty to their own private spaces. **To Point #2:** Diplomats don't (usually) carry guns, because it's (usually) distracting to the negotiation. Same philosophy follows here. Mediators seek to resolve the dispute in a way that leaves both parties feeling validated and, ideally, in a better position to communicate in the future. Mediators don't carry the threat of eviction. That will fail for some interactions and some contributors. In those cases where mediation fails, mediators can recommend censure to those who actually have the power to vacate contributors. As for how mediators structure the discussion, see my example mediation in an internals thread: http://news.php.net/php.internals/90419 It's important to stress that resolution doesn't come by authority, it comes by forging understanding between the parties. Mediators are trained to do that by standing back, remaining objective, listening, and validating.
Yep, this is precisely type of code / solution that I had in mind.
Ok that makes a lot of sense, thanks for laying it out for me!
&gt; Our collaborative spaces are not free speech zones Free speech is one the most fundamental rights a person has and the most valued in a western society. It is actually the foundation for how you get your "Converse in our collaborative spaces without fear of harassment". That is what free speech is. If you allow it in some cases, but disallow in others you are defeating the entire point
i'm running a small silex app on php7. No surprises yet.
So it really is meant to be a user-input validator instead of a true assertion library, where the asserted statements are always expected to be true. It isn't meant to replace php's built in `assert()` functionality. Edit: In other words, this isn't true of this library: &gt;[Assertions](https://secure.php.net/manual/en/function.assert.php) should not be used for normal runtime operations like input parameter checks. As a rule of thumb your code should always be able to work correctly if assertion checking is not activated.
As for the stage 7, it's the extra-network connective apps, and the apps with offline support. You not only have to support your network, but your app client needs to learn to cope without the server to some extent, a sync procedure needs to be developed as well as the potential for non-internal clients to connect to your application.
&gt; http://news.php.net/php.internals/90419 That's beautiful. Thank you! I'm curious what the responses were, I haven't been able to locate any, due to the size of the thread and the poor UIs in the available readers... &gt; It's important to stress that resolution doesn't come by authority, it comes by forging understanding between the parties. How will you convince contributors that don't buy in to this mindset to agree to the mediation and abide by the results of it? Without some sort of tangible "negative" consequence being possible, why wouldn't a hypothetical bad actor continue to act poorly?
tl;dw: `php -S localhost:8000 -t public`
I kvetch about this similarly in another comment myself, actually. Your arguments assumes really simple, short code - what about functions with a couple hundred lines, with half a dozen or more returns wedged in here and there in various nested conditionals? I see that sort of thing fairly often in our legacy codebase, and it can make it hellish to read and debug. That's what drives me (and presumably /u/Boye) to protest at multiple exit points within a function. Even if a function starts of simple and clean, there's no guarantee it will stay that way over time or that someone can be bothered to refactor it out there in the real world. As such, I tend to favour the first example over the second myself as the first is only more readable when there's little to no actual code in a function that never gets touched again.
Thanks for that, I suppose I'm more envious of the concept of being a hobbyist programmer back then than a professional one lol.
In summary: Is easy to learn but difficult to master, not because the language is extremely complex (like C++) but because it wasn't properly designed. You pretty much bind yourself to long hours in stackoverflow , googling and lurking the PHP docs given the quirks and inconsistencies in the language.
One could argue that the default value is pointless if you're potentially going to overwrite it immediately. Same could be said for using a variable at all, since it's essentially a throw-away (micro-optimizations and all that jazz). At the end of the day, unless you're really squeezing every ounce of performance, it's more or less a development style/convention. Choose your flavor, they all do the same thing.
It's a pity that all PHP you met is a shitty one.
I think until you have a network internal system, it won't matter how you scale the one monolithic system at earlier stages. Thanks for getting back though, and it was a thought provoking article
This is great. When will part 2 be posted?
Learning C is a worthwhile activity but if you're struggling to learn PHP it will be of no help to you.
I could imagine that it would be useful in a production facility, but the barcodes would probably be provided by some other software than a PHP library?
Go and javascript
Every machine we build gets a serial number. Those serials need labels. We generate the labels by creating a black &amp; white image of the barcode and tossing it at a thermal transfer label printer, along with our company logo &amp; name. This is done in PHP, using the prehistoric PEAR Barcode library. Hey, it still works, so we still use it. We use printed barcodes on a bunch of labels and process tracking documents. They're a major key to the way our operation works. But we don't just generate them, we scan them as well. We'll work with dozens of individual components when doing assemblies, and almost all of them have 1d barcodes as identifiers, provided by their own manufacturer. 2d wins the density war, but 1d is ubiquitous. 
Gave this a look, but to me it seems. More tailored towards someone that knows php and to fix bad habits?
I am running a huge app on Silex and it has never got in the way as I have scaled. * I don't get upgrade problems as there is very little to upgrade * It never really gets in my way, but when I want to do something pretty advanced, it generally supports it. * Super easy for other developers to pick up as there is not a lot of code to look at. * You get to pick your fav ORM, templating engine and any other tools that you like (this can be both good an bad). 
Ask this in /r/programming
What is the use case of Weakrefs on a normal app?
I really don't understand this as a question. The premise is so vague as to be pointless. * Where do you live? If you're in a city where most developers use Flub, start with Flub. It will be easier to find mentors and jobs. * What are you aiming to do with your programming knowledge? Going into business? Use VBA. Science? Python. Aiming to be a webmaster? PHP and JavaScript. Sysadmin? Go. * What kind of person are you? If you like following instructions, you'll want something with great documentation. If you prefer to dig in and play around, you might like Lisp. In the end, most of the responses to this survey are little more than a popularity contest. "I use this language and so should you." That's no help to anyone. If you just want to learn how programming works - things like control loops and conditionals - use whatever you like. It won't make any difference.
Am I the only one who doesn't use real email addresses in a staging environment database? We take a copy of the production database, run a data masking script on it that anonymises all data while trying to keep it as production like as possible and changes all email addresses to use a test domain. People can update accounts to use their own email addresses, phone numbers etc to QA anything.
This feels like email collection exercise on the OP's part.
Adam is really good at explaining his thoughts and I'd say this screencast would be a good watch for anyone looking to learn a TDD workflow form a pro, regardless of their interest in Laravel. It's also a nice introduction to some of the out of the box support for testing that Laravel ships. 
Ill stay away for now then. Cheers
Mixing good practices with bad code doesn't make the bad code good. A function with 'a couple hundred lines, with half a dozen or more returns wedged in here and there in various nested conditionals' is likely doing too much and could probably be refactored into multiple methods or classes that are individually easier to maintain and understand. The problem is that is that the code you are working with is bad, it would still be just as bad and confusing without using early return statements. If your business and team care about quality, your code will improve over time - simple and clean code will stay that way and people will be bothered to refactor bad code. If this is not the case, then you have bad or lazy developers in the team who are writing bad code with no accountability, or the business doesn't care enough about quality code to invest enough resource to get it. None of this means that good practices such as early returns are bad, just that they don't improve already bad code.
I appreciate the work that you've put into this library - but I think you're wasting your time trying to write an implementation for this specification. It looks like you've tried to handle the problem of 'getExpiration()' not being on the public interface by serializing the object before it goes into the cache and handling item expiration at application level: https://github.com/jmatosp/TumbleweedCache/blob/9f0f5469eb3c45dd2a89fb44d7deaeed7f262c79/src/RedisCache.php#L190 https://github.com/jmatosp/TumbleweedCache/blob/9f0f5469eb3c45dd2a89fb44d7deaeed7f262c79/src/Item.php#L85-L98 This means that the underlying cache system can't actually tell the difference between an expired or live item. A couple of obvious problems with this solution: 1. When the cache gets full it will drop live values whilst still maintaining expired ones 2. With expired values your solution will have all of the cost of a cache hit for a cache miss - this will make a big difference if you're caching large amounts of data. I'd try and avoid this situation at all costs - it's worse than just adding the public method. +1 for the clean code and awesome test suite, but I think this specification isn't worth the effort.
Victim blamer!
Alas not all of us have the luxury of being the sole maintainer of their own original code base, nor the time to go through a few tens of thousands lines of code to refactor it all (or even enough time to refactor it so just the piece being worked on isn't so awful).
Eval needs to receive the code which will be executed. Replace it with echo and it will print it instead. There are usually several layers of obfuscation, so you replace eval with echo, run, rinse and repeat. I don't recommend you do this without a good understanding of PHP.
If you are totally new to programming then you should first learn programming basic concepts. C is called mother of programming languages so you can start with C.
Yes, 5.0 which was released a year ago required it. Although 5.1, their LTS version, switched to OpenSSL-only. Since the support period for non-LTS releases on Laravel is only 1 year, 5.0 is no longer supported. Edit: Sorry, the actual release date on 5.0 was February 4, 2015. So it is 3 weeks from no longer being supported.
I think its the Cuba next to Greece. 
&gt; it's just unnecessary complexity. Really thinking about this a litter bit longer I fully agree with you.
Fun. I was using Hoa to handle user inputted formulas. Guess I should figure out what library I need to use now and refactor. If only I had waited a month to implement this...
That's always been my opinion. It's funny how much this has come up in the past month.
Thanks for your comment. I'm aware of those problems, and agree that the specification lacks "some" functionality... There is a way, but don't really like it, the CachePool is an observer and CacheItem subjects. this way there a communication link between the two. CacheItem would notify Observers when expired has changed. But CachePool had to track expired dates for all cache item. 
Haha that would be great, then I can be smug about tabs too :D
Thanks, guess we made the right choice.
Nice project. Looks like a pretty big community too. Thanks for your feedback.
[removed]
Could any recommend any repositories on GitHub that you believe contain very clean, well documented and professional code that adheres to things like SOLID, etc. Trying to improve the quality of how I code by thinking more about how I'm going to implement something, rather than just coding and hoping for the best so I thought studying some GitHub repositories might be a nice exercise. Of course any other recommendations are always welcome! :P
It's happened in other projects - why won't it happen here?
Don't forget to remove all of the commits /u/Garethp has made (damn, I wish there was a valid English pronoun I could have used without offending someone.)
&gt; for putting up with the /r/php boys club bullshit. Yeah, no agenda being pushed here, none at all. That you left out "shitlord" somewhere in that rant is amazing.
Actually nothing changed for you. I suppose you are using Hoa\Math. Just update it and every thing will be fine. No BC break from your perspective :-). If you need help, ask on IRC or Twitter.
Too bad, we have a new logo. Unfortunately you were not able to evolve, I feel sorry for you.
[removed]
Sorry those guys don't have it. Good work guys! .
Nice! I'd love to explore more of Hoa, but unfortunately many of the libraries does not have any English documentation from what I can tell. Those that have are really well written and was a enjoyable read. Looking forward for those when and if they come.
Thanks for your help. That is the only bug report I could actually find I could find related to this. On the third look it might actually be related to mine. First I just assumed not because it was already marked fixed in 7.0.0. The error I am getting is: url_setopt_array(): You must pass either an object or an array with the CURLOPT_HTTPHEADER argument when the CURLOPT_HTTPHEADER is actually an array. But it is also a [constant integer](http://php.net/manual/en/curl.constants.php) so it might be related to this somehow. But the second question remains. The bug is indeed fixed in upcoming 7.0.3 but where could I find the commit for that one? Thanks to the bug ticket atleast I have some coordinates what files commit history I should be looking.
This playlist was posted here a few months ago and the first video, [The Clean Code Talks -- Inheritance, Polymorphism, &amp; Testing](https://www.youtube.com/watch?v=4F72VULWFvc&amp;index=1&amp;list=PLKxYePINkYhRZtRuWTfgHeqXSFoElAba0), did a good job of explaining the concept.
please no. You just went from an algorithm with it's logic in one nice, neat, tidy spot to an algorithm with logic flung out over umpteen different files. Just because you can doesn't mean you should.
\*shrug\* It's the closest it's got to "real annotations" right now. And no, they don't enforce anything anyway, they're just information for checking tools.
`/me` wants to rewrite your title for easier parsing! FWIW I don't mind this style rule - it's not the end of the world if you ignore it, but since `elseif` exists in PHP, one might as well use it. I mildly agree that it is clearer. 
Yes, I thought about rewriting title too, but it was too late. About using it - yes, yes, I just disagree with them using SHOULD word. I think MAY is better in this case.
Are you using an automated style checker? If not, just ignore this rule. If you are, maybe rules can be disabled on an individual basis?
It is the easiest to deploy on a cheap hosting provider. It is easy to generate text from PHP since it is a templating language at first place. 
I could not find the post you were referring to, could you possibly PM me it if its not too much trouble?
There are some of *those* guidelines, such as the recommended line length being 80 characters rofl which you SHOULD ignore. Just kidding obviously but as long as it is not enforced in a project you are working on - just ignore it.
I recently migrated all of my Symfony apps (5, sizing from small to large) to a php7 server and haven't encountered any issues yet.
Thinking about this there is a way of knowing whether the item has fallen out of scope, as you can utilise the __destruct method. Proof of concept: https://github.com/php-cache/adapter-common/issues/12
Just one paragraph above it says &gt;The body of each structure MUST be enclosed by braces. This standardizes how the structures look, and reduces the likelihood of introducing errors as new lines get added to the body. The `} else if (...) {//}` would break the rule it just defined, ie. it would have to be `} else { if (...) {//} }`.
My only issue is when I use twig on 7.0 and 7.0.1 when the rendering take longer time than on 5.6 but I think it should be solved in 7.0.2
That's not what 'sexualised' means in this context.
I'd been thinking for a while that you could trivially write a trait for an immutable object that just implements `__set` and makes it throw an exception. But why does this completely take over a class's properties? I don't get why it needs to make `__get` special too and route everything into a special array in a private property. Still, a cool idea.
Don't plan on using twig (templating not in design scope). So I guess this won't affect me. Thanks for responding. 
Is 80 characters that unreasonable? If you're exceeding that in line length, you might want to pare down a function's complexity.
It is reasonable as long as you use 1-letter variable names and code directly on a [punch card][1]. `class_exists('Symfony\Bridge\ProxyManager\LazyProxy\Instantiator\RuntimeInstantiator')` is already over that antiquated limit. (a single expression from symfony src, where the whole line takes 147 chars in Kernel.php:608) [1]: http://programmers.stackexchange.com/a/148678
TL;DW In memory filtering of your wordpress blogposts and debugging with `var_dump`. I think that this is very bad way for new developers to learn stuff.
So, why not make the properties private with getters and values only settable in say the constructor?
There are things I disagree with and agree with in PSRs, but it's not a rule. The R stands for recommendation. 
 if ( ... ) { ... } else for ( ... ) { .... } I've done this in several languages.
we wrote one a while back which uses MongoDB. https://github.com/dominionenterprises/mongo-queue-php
Would `__set` still be called if there is public property with that name? I thought that `__get` and `__set` were fallbacks for non-existent/inaccessible properties.
Agreed, using an IDE can help in more situations. I use PHPStorm and I also installed a bunch of plugins to have even more warnings. Though I do sometimes do quick edits in Vim over SSH, etc. So having a habit that can prevent potential bugs doesn't hurt, in my opinion. Yes, it can't be used for comparing variables, but it's still useful in many other situations. It's like a fork. You can't eat soup with it but that doesn't mean it's useless :)
Hoa project is being used by both industrial and research worlds. From research, several papers and even a PhD thesis or journals have been published. See this Section http://hoa-project.net/En/Literature.html#Research. You are mentioning the `Hoa\Compiler` library. This is the result of a research. It does 2 things: It can **validate** data against a grammar but it can also **generate** data matching a grammar. See for instance http://hoa-project.net/En/Literature/Hack/Compiler.html#Generation (research paper and keynote are here: http://hoa-project.net/En/Event/Amost12.html). Enjoy :-).
Thanks :-). We are working hard on translating and writing all the documentation!
It's a style guide, it should be definitive. The decision about which syntax to use is essentially arbitrary in many cases, the point is that the style guide provides a defined way of doing it.
&gt; Punishment is like lighting a fuse; mediation is like soaking a fuse in water. Which best achieves the desired outcome? They should totally feel better for being manipulated into feeling good! I really can't wait for this shit to blow over. I remember a time when people simply left a project when personal conflict got to a point that they were unwilling to deal with it. Nowadays it seems like someone is going to get bullied out of the project or the project is going to be spending resources on "groups" to "mediate".
Maybe read the [Introduction](https://github.com/matthiasnoback/convenient-immutability#introduction)? That's literally the first thing explained in the link.
From rfc2119: &gt; SHOULD This word, or the adjective "RECOMMENDED", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. 
Very valid example. I've never thought about this case (the same goes for the "else for()" somewhere below), and was kinda upset about following this PSR recommandation.
I know people are downvoting this as a self-promotion post but good for you guys. It's crap that more companies won't give back into the opensource community, when their entire profit is reliant on it. When companies draw a big profit and use opensource it's a pretty dick move to at very least not give something back (no matter how small) to help improve the projects and/or community around said projects.
I'm not sure about some of the points though: * __Tell, don't ask__: They move the if into the function, effectively asking the funciton to do something, not telling it. Because the if in in the funciton, you don't know if it's gonna do what you want in to do yet... * __Single type return value__: If you follow the tell, dont ask method. And you move the if inside the function, you are gonna need to return false if you do not enter the if you just put in there. Another solution is to throw an exception if the if fails, but then you need to wrap the function in try/catch, and complexity is higher again... * __use a map__: So I need to instantiate every decoder but I'm only going to use 1 of them? seems a bit strange to me. Still a good read though, especially for beginners, looking forward to the follow up articles.
This is interesting. Any links to provide more information?
I can't imagine examples of those errors, when there is else if without { in the middle.
Since the same time they decided that spaces were better than tabs. I don't think you'll find one person who likes every single thing in PSR-2, but it's useful and it's what we use
I have never seen this style. It is interesting as it kind of adds a check for some special base case before doing a loop, but I would probably be surprised if I saw it.
I think that's the real reason. It also causes problem when auto formatting with an IDE using PSR-2, all your "else if" are automatically turned into else { if { So you're better off using elseif if you want it to be a single operator.
&gt; I think core developers of PHP should take on this then improving the engine that PHP could not only be single request living thing but long time running process too. Do you have any particular improvements in mind here?
Pretty much. I disagree with the premise a lot of the more in-depth things of PSR-2 (How does some of the really nitpickier details help with Framework Interoperability? It just feels weird for it to go that specific), but having a standard is well worth the standard not being 100% to my liking. Between PHPStorm's lovely auto formatter and phpcbf, I've got no real complaints. All I've got is an ideological belief that FIG wasn't the right group to set the standard, but in the end someone had to and if it weren't for PSR-2, we probably wouldn't have a standard most people followed
Who doesn't look for a getter before trying to access a property directly? It's very rare to encounter a public property on a class in any PHP code... &gt; looking in the code that you can in fact access it, everyone would think you can't. Well, no, it's the other way around, you look at the accessors, or you just type `-&gt;get` and your IDE tells you what you can access. This library adds much magic. Everybody looking at the class will think the property is public, but it's not, the IDE won't have a clue what's going on...
Yeah the controller was an idea tbh, wasnt really the point ^^ I just want an easier way to deal with inputs that i really dont care where they come from be it _GET/_POST/_PUT/php://, whether they are json encoded or good old form-data posts.
I follow the old PSRs closely, but for life of me i cant really warp my head around PSR-7, i think it's really big from code-point to maintain for solo programmer 
it has more code then my whole app =)
The upside of a crazy **unique** names like this, is that when you do a Google search, close to 100% of the results are relevant. For this same reason, I always recommend that anybody building any new software project give it a unique name with no spaces/punctuation. Makes searching (web, your filesystem, package managers etc) much much easier. And means you'll never need to compete for the name on github, package managers, domain names, twitter etc. The opposite example of this was naming a programming language "Go", it was especially surprising as it was a dude that worked for Google. Yeah you can always search for "golang", but the fact that you need to do that proves the point to begin with.
I've not watched; is there much point given how much the ecosystem has changed since 7's release?
Is that a problem though? Does it cause performance issues? Does it prevent you from using the app in the way that you want? Depending on your situation, you could use the HTTP Foundation library for now, with an assumption that you'll remove it later if it proves worthwhile to do so.
not me sadly :/
it will be a problem as i have to maintain the codebase for several years to come, and im not really into symfony coding philosophy. The performance is also kinda questionable, creating an object for each parameter is IMO a memory waste when dealing with possibly high number of parameters, anyway i might end up creating a bridge to symfony/http-foundation for now and reinvent the wheel later. just wanted to know if there is light alternative to http foundation 
well, if we are to follow SOLID /u/Garethp make sense, i really don't like the idea of having alot of function arguments, i like at most 5 and possibly array $options = [] for taking unusual parameters. 
Over 9 minutes long video on "array_filter" function which is so simple to use. What's the point of recording anything like this? The php manual shows good examples how to use it.
I don't see how this affects SOLID. The first "bad" example he gave is still using an injected dependency `$controller::paramCollector`. Adding an `$options = []` argument just to have less arguments but filling it with junk, is even worse, imho. What if you POST a form, you're going to put each form field as a function argument? If you want to answer "no I'm just going to give an array $form" Than you are effectively just passing `$_POST`. So why not do the same for `$_GET`, or even `$_REQUEST`? In the end, it'll boil down to what you started with: user symfony/http-foundation, parse the request and pass that `Request` object to the actions. as symfony standard also does.
To prove that writing bad code breaks things
It's just a minimal example to illustrate the bug. It's not supposed to be useful or quality code.
if you noticed i said "performance is also kinda questionable", not that is the main reason for not using HTTP Foundation, my main reason for not using the library is that my codebase is really in the low end we are talking about less then 5-6k LoC and less then 30 files, adding to that more then 50 files plus thousands of LoC just to access parameters kinda defeat the purpose of creating the minimalistic codebase instead of using regular symfony framework.
But you only need to use one class (Request).
Eyes don't cope with widescreen text well, and most places that display code will show at most 120 columns.
No... this just proves that PHP lets you do stupid things.
Two of the training sessions are exactly what was at phpworld, and the third one is an intro to PHP. Guess I'm not signing up for the training days.
Use the search function, it's been discussed a million times before. Proper searching skills should be part of every developer's CV, too ;).
do you think it could be easily separated from the main library?
man, one word stupid, after reading all your comments it looks like you have 0 understanding about PHP...
I'm skipping php[tek] this year in favor of [php[cruise]](https://cruise.phparch.com/about/). Hope to see you all in Freeport
Yes, it's still the most easy web dev language. There is no "but writing *good* PHP code is challenging" without considering the challenges associates with writing *good* code in any other language. PHP is faceroll, it does not have a high difficulty limit, it gets no consolation prize. The language can be mastered in months if not weeks. Wrapping superglobals in objects, using PDO and SPL, and utilizing PSR-4 does not require a master's degree.
&gt; i think it's really big from code-point to maintain for solo programmer If you were to write custom implementations for your app, I'd agree - luckily there a number of good implementation that you can depend upon. For example there's [Zend Diactoros](https://github.com/zendframework/zend-diactoros), originally developed by Matthew Weier O'Phinney (the final editor for PSR-7 and the person we can thank for getting it to finally pass).
&gt; logic flung out over umpteen different files. This is a good point, it's definitely a trade-off; there are situations where this is a *really bad idea*. For example, I've implemented a number of moderately complex parsers where the main lexing occurs in a large switch/case - in this situation the logic is part of the same conceptual unit. To split it up as I described above would simply obfuscate the intent of the code. Often, however, the logical units of work are conceptually independent and/or the system needs to specify which possibilities to execute at runtime. In these cases clarity is gained by separating them into logical units, and by using dynamic dispatch we gain runtime flexibility.
I was asking a simple question about an alternative to symfony/http-foundation because frankly the library is bigger then my codebase, not sure how that turned into me having 0 understanding about PHP. I'll take look at the package you linked. Thank you.
Yes, just use that class and ignore the rest. I'm not really understanding where your issue is. Having some PHP files on disk that are never called is not extra overhead.
Uh, no? The problem is the wacky inheritance model; nothing is stopping you from doing this in, say, Java. Is there ever, ever a case where you absolutely must redundantly implement two interfaces when one is an extension of the other?
No, everyone uses bloated frameworks, even big companies like facebook! They would never write their own implementation which exactly fits their purpose! /s The narcism in this subreddit is really killing it.
My interview was less about the manager testing my PHP skills (why else would I be applying) and more about him getting to know that he was hiring a well-rounded team-friendly dev as opposed to a close-minded know-it-all. Best job I've ever had.
Don't rub lamps, rub lapps and get more satisfaction.
I dont know much about internals, as I am just learning about them. But I think current engine knows what after request everything will be cleared, so maybe think that it maybe could run for ages not on single request.
&gt; rub a true lamp. Not sure if this was on purpose, but I like it.
No doubt. I failed to mention there was a skill exercise that I completed at home and online. The interview itself though was all very high level stuff. And for what it's worth, "why else would I be applying" was my manager's viewpoint. In essence: if you don't know your stuff, I'll weed you out... so let's just chat.
Sounds like a fun project. &gt; I want to mitigate maintenance involved with recreating a relational schema that emulates/relies on each third party API. Looking for an elegant way of representing external objects instead of importing the entire schema to SQL and using models. I don't fully understand your use case, but can you get away with not storing the data at all? If I was approaching the project I think I would try and connect my objects to the remote APIs, and use the objects to build my response on the fly. The first thing I thought of was this [proxy manager](https://ocramius.github.io/ProxyManager/docs/remote-object.html) library, but you would need to use interfaces and can't really treat the objects as normal models. If you want normal models, the only thing I know of is this [skeleton mapper](https://github.com/doctrine/skeleton-mapper) project, which is a beta release. If you used something like skeleton mapper you would write plain php classes. then when you load your object from a repository it does a call to the external REST api instead of a database and builds your objects. Since your implementation is behind an interface, the rest of your code doesn't know or care where the data came from. &gt; Looking for a schedule/cron/process solution to manage and log errors for fetching external API data. I like the illuminate console component. You can pull in the [package](https://packagist.org/packages/illuminate/console) and use it without laravel. [Monolog](https://packagist.org/packages/monolog/monolog) is pretty standard for logging. &gt; I'm considering using Laravel, Fractals and Guzzle I use all of those and I'm happy with them.
I would recommend to use ocramius proxy manager. You could wrap the object in an proxy class, that inherits from the original class, and pipe all methods trough an custom adapter, where you could check for getter or setter. With this mechanism you could have protected properties and immutable objects.
I did a lot of research into DDD recently and almost all of the examples I could find were in Java. The [sylius code](https://github.com/Sylius/Sylius) is the largest well coded Symfony code base I know of. This isn't as general as SOLID, but I have some links for the entity boundary interactor pattern / hexagonal architecture / ports and adapters: [This repo and talk](https://github.com/igorw/doucheswag) is really excellent. They write a framework agnostic application that plugs into silex and test it with Behat. I did a similar talk at the LaravelSF meetup using Laravel. The repo is [here](https://github.com/matthew-james/quicksilver) if you want to see a Laravel version of the same idea.
I tested out what the cost would be if you began assigning a property but forgot to declare it on the class. With a simple class, objects look to be about ~300bytes heavier without the declared property! https://3v4l.org/JFXTV/perf#tabs https://3v4l.org/NOL3E/perf#tabs
Thanks a lot, I'll take a look over them when I finish up at work. 
It is not the case that 5 to 7 changed in some other ways? Please reread what I wrote: I specifically said that I was not saying that *this* changed. Merely that some *other* things have between 5 and 7. Are you disagreeing with what I said, or did you misread what I wrote?
If you're in a position where you are implementing two interfaces and one of which is already implementing another then you should seriously reconsider your API design. I really, really feel this is something that only someone fresh off a Java EE course who overengineers everything will come across. Also I'm still wondering how it &gt;lets you do stupid things When the issue is that it's *not*.
The [RFC to extend PHP 5.6 support has passed](https://wiki.php.net/rfc/php56timeline#vote): - 1 year active support (end 2016) - 2 years security support (end 2018)
Sorry about that. We've found that out more 'unique' training sessions simply didn't sell well. And in the end we were losing money on them. So with the new venue and lots unknown. We are keeping this one to the 'classics' that lots of people want. Would love any feedback on that :-)
The decision as to whether or not you need the "runtime flexibility" is quite simple. Was there a requirement change that needs the flexibility? Because really, when you're talking about this "runtime flexibility", what you're really describing is using things like IoC to *build* the object during runtime in a way that can be changed easily. We know this because it's literally the only thing you can't do with the switch approach (but you can do it with the map approach). If that isn't what you meant then shame on you for describing your approach as significantly different in this regard. That switch statement is also a runtime construct, literally the only difference is that instead of cracking open that 1 source file to make the change, you're cracking open source files all over your project to find the class definitions. I'm not sure why you think that brings clarity to the situation. Where you're likely to want to refactor in this way is if the dispatch is a part of a larger algorithm where you want to hide the details. The thing is, the call table approach does that just fine AND it does it without the downsides of the class hierarchy. In particular, you can have a single function construct the call table so if anyone ever needs/wants to look at the details of that call table, they can do so in a single spot. And it still gets the benefits of both the runtime call dispatch and the hiding of details without the downside of spreading the implementation across multiple files. Do you know where the switch/call table approach fall down? When you're writing an library of some sort and you want people outside that library to easily add functionality. THAT is an appropriate use of a call hiearchy, maybe, depends on your needs. But reaching for a class hiearchy because someone used a switch statement? Fuck that shit, thank god I don't work with people who have that mentality.
So, start abandoning arrays for minisucle space savings to lose all the common array related sorting/searching functionality already built? Sounds like a microoptimization leaning toward more brittle, less maintainable code.
The post doesn't seem to discuss the load factor for the hash table. Hash tables usually aren't fully filled since keys are assigned to buckets based on a hashing function and to minimize the risk of hash collisions (which costs time) you try to keep some extra spare room. That proportion is called the load factor, and it can easily be 50-100% extra memory consumption. I would love to know how PHP handles that (but not enough to bring up the computer and check out the source code myself...)
Thanks, I understand the reasoning for it. As long as the core conference days have some new, unique sessions, I'll still be excited to attend.
Sorry if this is a stupid question, but the example seems to compare an object to an associative array. Do objects also use less memory than list arrays?
&gt; Yeah totally. Repository should be like $userRepository-&gt;save($userModel); and also $userModel should be "dumb" (just a "data holder") class EloquentUserRepository extends UserRepository { public function findByEmail($emailAddress) { return EloquentModel::where('email', '=', $emailAddress)-&gt;first(); } } You're still returning an Active Record as opposed to a "dumb" data holder (POPO). 
I guess you didn't read my previous message because I 've written: "In this particular example the Eloquent Model will leak back so you have to be disciplined to use the Model only as a simple data holder." :-)
&gt; So, start abandoning arrays for minisucle space savings to lose all the common array related sorting/searching functionality already built? No... there's a difference between saying "objects with predeclared properties use less memory than arrays" and "you should use objects instead of arrays"; the post is mostly the former, and the latter is notably absent from the conclusions: &gt; * Upgrade to PHP 5.4 if you haven't yet! PHP 5.3 doesn't yet have this cool optimization. &gt; * Declaring properties isn't just a best practice for class design, it will actually also save you a good bit of memory. &gt; * Not using objects because they are "too heavy on the memory" is dumb. At least if arrays are the alternative. It just says not to do the incorrect microoptimization the other way, not that you should do the 'correct' one.
Yeah, that tends to happen after a while. And removing those manually is apain, i always ended up just deleting the boxes through the normale file manager.
Perhaps if you took a little time to read what other people are writing you wouldn't spend so much time befuddled over why nobody seems to be understanding what you are writing.
It may actually be returning `0`, not `false`. It's a convention. `0` means everything executed OK. Non-`0` means something went wrong.
sweet.
LOL
eh not really... the faster we get people on php7 the better. its almost a drop in replacement unless you were using the features that have been deprecated for years.
Surprisingly it looks like this article holds true for non-associative arrays as well! [object](https://3v4l.org/ttUnj/perf#tabs) vs [list](https://3v4l.org/0hI3J/perf#tabs) vs [associative array](https://3v4l.org/tFjSC/perf#tabs)
They should just end all support for it now and focus their resources on PHP 8.
Please explain to me how either of my two points are incorrect in any way: * Several things have changed between 5 and 7 * I am not saying that this post is one of them (or isn't). I said nothing about the gist -- and in fact said *explicitly* that I was not speaking about the gist, but rather the general principle that things have changed between 5 and 7, and that readers should be cautious because some of these types of articles are now outdated. I was then told that I was wrong. How was I wrong? It would seem to me that you did not read what I wrote at all, nor did /u/KorvinSzanto. The only way in which I would be wrong is if you are asserting that there are no outdated articles about PHP on the internet. I humbly submit that there was a simple misunderstanding here, and we're just talking past each other.
Yeah, this post is pretty dated. The basic concept stays the same in PHP 7, the numbers are different. Without verifying the numbers, I'd say it goes something like this: Arrays: 56 + 36 * roundPow2(N) Object: 48 + 16 * N Where roundPow2(N) rounds N up to the next power of two, with a minimum of 8.
&gt; I don't know how "this kind of thing is outdated as of 7" could possibly mean that "Other things changed in PHP 7 too!". The opening clause: "I'm not saying that it changed in 7," with it referring to the specific subject of the gist. &gt; Saying PHP 7 has different stuff than PHP 5 is pretty irrelevant to the topic at hand. I was referring to the fact that optimization articles on the internet are about to go through the same cycle they did with PHP 3 to 4, with major changes like objects going from very slow to useful. That there is going to be another set of outdated articles. And since this is a subreddit for the topic of discussing PHP and the PHP community, it would seem to be relevant to the greater topic of the subreddit. There seems to be quite a bit of antagonism here. You didn't understand my point. It's okay.
upgrading to php 7 on prod then waiting until customers complain that something isn't working then fix it /s 
Hey /u/nikic -- I appreciate the reply! I've been using PHP since the PHP/FI 2.x era, and I was merely making a observation that we're going to have a new chunk of outdated articles with the release of 7. It did seem to cause some consternation that I was somehow slighting your work. You have a mighty army of quite zealous defenders. :) As for the topic of your Gist, this is very useful to know, as I do a ton of heavy JSON &lt;-&gt; object translation, often having a large number of data structures loaded (and occasionally a ridiculous number). That there is no memory benefit to switching it to an array is helpful to tuck in the back of my mind.
It's pretty damn hard to upgrade code, especially if its legacy. I still support Java 6 applications. I would expect PHP to continue support past 2019, but even then just because they ended support doesn't mean people will migrate.
Hey Man, I have been working with quite a lot of API SDKs, one SDK that I thought looked really nice was for BigCommerce. It was what I would consider really simple and easy to work with. They have tests, and what I like is the structure is pretty straight forward. https://github.com/bigcommerce/bigcommerce-api-php Another one is Intercom which really is from I see is built around config files vs lots of code for each class. I suspect they have built a tool that produces these JSON files, but a very interesting idea. https://github.com/intercom/intercom-php Lastly I highly recommend you look at Stripe. These one seems even simpler again. https://github.com/stripe/stripe-php Cheers, John.
Which makes sense and isn't even uncommon. For instance Python 2.7 is supported 6 years longer than 3.2 but they were released at basically the same time.
Yes! thank you, I think this is the answer.
A PHP SDK is typically documentation. I think of AWS for example: https://aws.amazon.com/sdk-for-php/. Are you thinking of more? If it's mostly "code documentation", have you considered a generator to get you started? Examples: http://apidocjs.com/ and http://www.apigen.org/. If you're providing it to the public, keep it clean and simple and be clear about versions.
&gt; the features that have been deprecated for years Check. I have a 400k app currently that I need to migrate. I am a dev team of one. I need all the time I can get.
Ugh, im sorry. Thats no fun.
I think what you're going for is a Hello World type application for your particular API? I've only seen kinda trivial (hello-world-ish) examples packaged with APIs, so can't be of much help... but anecdotally..... It's funny, when I was in college, I thought packaging science majors were idiots. "*How frickin' easy is it to make a box? Those guys are like the IDIOTS of engineering, amirite?!*" And *then* you see a nicely packaged product: e.g. Apple, Google, hell, even Xiaoyu. Literally, the box crafts your perception of the product BEFORE you even experience the product. Would be nice to be able to provide that kind of experience with your API...
Hey! /u/bobthecow just figured out you are the author! Thanks for all the contributions you made to PHP! Just a wanted to let you know in the current version (Psy Shell v0.6.1) `use` is still returning false.
I'm not entirely clear on your use-cases, but you might find some useful stuff searching under [Aspect Oriented Programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming).
&gt; build the object during runtime in a way that can be changed easily. Yep. &gt; and you want people [...] to easily add functionality. Yep. &gt; But reaching for a class hiearchy because someone used a switch statement? &gt; Fuck that shit, thank god I don't work with people who have that mentality. I didn't say that developers should avoid this at all costs. I do however regularly see pathological examples where the cognitive overhead of dynamic dispatch would be justified when compared to it's current state.
The XPath isn't valid because the search string in the contains function needs to be in quotes, like: $test=$xpath-&gt;query("//div[contains(.,\"".$trythis."\")]/text()");
&gt; - symlinks in our projects were not working on windows (fixing this issue was funky and different based on exact windows version) This is a big one. Unfortunately, the only work-around I know of is using Virtualbox with native file sharing. This means it's *dog slow*. &gt; when switching git branches or just creating files - &gt; they would not appear in shared volumes causing all kinds of hard to troubleshoot bugs (using nfs fixes it but still, nfs, more tech debt.) This is due to Virtualbox's slowness. Look at this: http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines You should be using something more performant, like VMWare. If you can't jump to it, then consider using rsync or SMB. If you can use NFS, use it. There's not any real technical debt there. Not sure what you're referring to! &gt; - every time devs would shutdown they computers they'd have to do "vagrant up" next morning and follow the 2 minutes install process Older versions of Vagrant would do a `provision` on `up`. This is no longer the case, and booting up a sleeping VM should only take a few seconds!
But what about internal profiling that shows where the execution is lagging? Is it PHP, the db, or the network?
Install XHProf (https://github.com/jonaswouters/XhprofBundle) Review the resulting call graphs from multiple test runs. ??? Profit. Joking aside, trying to ascertain the reason something may be slow without using something like xhprof or xdebug's profiler is basically a guessing game. 
here is a image of symfony profiler (for dev env) on my local machine, json response usually takes no more than 60ms http://i.imgur.com/XtVEhnd.png 
I do mostly niche stuff with PHP, so probably out of the loop. What is the stuff that Zend is selling that makes him nervous? I saw they have some new modern debugging stuff, would never want to depend on anyone else for my software at least. 
https://github.com/paragonie/halite/search?utf8=%E2%9C%93&amp;q=strict_types :)
You have a few years to write all the tests necesary to migrate to PHP7 :P
Thanks for the link to php7cc, that's a nice place to start.
Wouldn't expect *you* to have done anything else! :p I'm still annoyed it's a file level control.
Any Symfony 1.x apps among yours? I'm maintaining one and it definitely could use a x3-4 speed up.
you truly seem to care about your customer.
They were all using Symfony 2. But you will probably get at least a 2x speed improvement (the only websites I migrated that didn't receive such a boost were Wordpress websites). Symfony 1.x is a bit more difficult to upgrade though. I remember having to update one from 5.3 to 5.4 at my job, which was a pain in the ass. Edit: I should also mention that the old VPS was kind of clogged because of directadmin
I saw the "/s" flag, but - depending on the type of software you're running and your customer base - you can do that if you put it on a 'beta' server with plenty of warnings. Then this can be a valid way of upgrading, and getting real feedback about whether it was quicker as well. Your unit and integration tests will pick up any immediate problems, and you can always switch off the whole beta and stay with PHP5 if it looks like it's going to be difficult.
Does your signup work? I just tried twice and it just bumps the page to the top with no success message.
No. I have no need by default.
I see what you did there.
Probably the most unfortunate techname I've seen this year - pity, as it looks interesting.
I'm torn between imploring them to reconsider the name, and just letting this happen and having developers talk about 'building an app in Phap' or maybe even having to 'discuss the merits of Phap-ing something..'
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Having an SDK that is updated alongside the actual API can be incredibly useful and time saving though (depending on the complexity of the API).
I think your solution will work fine, you just need to control what migrations completed sucessfully and then rollback only that ones. All lastest batch for each sucessfully migrated database will be exatcly the same.
The right tool(s) really depends on a couple of things: * Your workflow * Team size * Project size and complexity Smaller teams and simpler projects allow the documentation to be built from doc-blocks. I work in a medium sized team using TDD and with a fairly large API (&gt;300 URIs). We tried automated document creation but found it was too prone to mistakes and there are always limitations with versions etc. Building from the spec forced us to be more focused on user interaction and being true to REST. We have started using swagger.io for endpoint documentation and guzzle to build functional endpoint tests before implementation. All functional tests are just a dependant repo, which doubles as an SDK and can be distributed with the docs to clients. The other nice side effect is that devs are more conscious of their code if someone outside is going to see it. We also enforce a coding standard. 
https://github.com/philipbrown/cribbb The author wrote a series of articles about DDD/hexagonal architecture in his blog (http://culttt.com/) while he was developing a personal project. I really like the way he thinks about problems and solutions.
smells on indian dev
Imagine that there has been 3 releases, each had a new migration added and executed on all clients. Their migrations table would be: | migration | batch | | migration_1 | 1 | // executed during deployment of release 1 | migration_2 | 2 | // executed during deployment of release 2 | migration_3 | 3 | // executed during deployment of release 3 Then I add a new client and run all migrations. They would have: | migration | batch | | migration_1 | 1 | // executed during initial new client set up script | migration_2 | 1 | // executed during initial new client set up script | migration_3 | 1 | // executed during initial new client set up script Now for some reason, lets say I need to roll back a release from release 3 to release 2. The application code that I roll back to relies on the database being at the state it was in `migration_2`, so all client's databases should be rolled back to that state - however, that isn't possible for the new client, because they only ever had one batch of migrations applied. Using my "logging each successful migration during deploy" solution means that their database isn't rolled back deleting their entire database (which is good), but it means their database stays in the state as of `migration_3` whereas it should be in the state of `migration_2`. So although it's not a terrible solution, I don't think it's perfect either.
It still doesn't support much of php7 syntax? [issue link][1] [1]: https://youtrack.jetbrains.com/issue/WI-27468 
Internally it use the delete methods from vagrant so you get the same confirmations as you would when doing it manually :)
Interesting approach, although letting the migrations happen automatically behind the scenes makes me nervous. As far as I can tell, the Laravel migrate command has no way of specifying a specific revision to migrate/rollback to. Maybe a custom artisan command that does just that is the solution? Let's say an application has three migrations available: `migration_1`, `migration_2`, `migration_3` that are to be executed in that order. Then I run my new custom command `php artisan migrate:version migration_2`. This is what I expect to happen: **Scenario: client's migration table only includes `migration_1`:** `migration_2` is migrated. **Scenario: client's migration table includes `migration_1` and `migration_2`:** Nothing is migrated. **Scenario: client's migration table includes `migration_1`, `migration_2` and `migration_3`:** `migration_3` is rolled back. Before migrating a tenant database during deployment, I log the last migration from migrations table - when a deployment fails, I run `php artisan migrate:version &lt;last_migration&gt;` on each client database that was successfully migrated. This ignores any differences in migration batch numbers I talked about [here](https://www.reddit.com/r/PHP/comments/40xh6l/in_a_multitenant_application_whats_the_best_way/cyxwu6w). What do you all think to this? Any downsides I've not considered?
NFS -yeah but that means veryone on the team must be able to install and configure nfs or samba server on their dev boxes. In my experience I just had to hold their hands with that and solve every issue that would pop up. very time consuming.
Nice, that's definitely a handy tool to have. Thank you. :D
January 2019? What? It ends in December 2018.
Ported to java 8. I guess is imposible right now to create a native app to give your users a IDE with good performance. 
Just learning how to use PDO properly can be great. Although you don't want large frameworks I still feel obliged to suggest looking at Doctrine. The learning curve is like running into a cliff, but once you've mastered the basics it's extraudinarily easy to manage. ProTip: Fields as Traits ;)
Just to clarify, you're saying your code-base contained a lot of `list() = $array`, with completely empty `list()`s? Why?
It sounds like they've switched to PHP7 but haven't followed through on all the dependencies. You may need to find a third part apt repository with a newer version of PEAR, or try installing it manually. 
I'm already keeping track of the migrations in each tenant db (Laravel does this automatically). How do you suggest I keep track of migrations per code update version? I can't record it at the tenant level (either in the tenant db, or a log file per tenant) because we'll be added new tenants all the time that tenant might not have existed on the server at the time of deployment, an example of which can be seen: For example, lets say I deployed successfully yesterday during which a new migration was added and applied to all existing tenants. Now lets say a new tenant was created this morning (the script for which includes running all migrations without using the deployment tool, meaning they also got the new migration that was added yesterday), and now I want to roll back to the previous release (before yesterday's release). If I was recording which migrations were applied during a release at the client level, it would look like the new client wasn't migrated during yesterday's release, and so nothing would be rolled back - when in fact the last migration (that was added as part of yesterday's deployment) should be rolled back. So maybe there should be a single log of migrations that were applied at the release level (rather than logging migrations applied per tenant) - but then how do I calculate that? Just assume the migrations that were successfully applied to the first client were the migrations that were applied to all clients, using the first client's migrations as the source of truth to be used during a rollback? That doesn't seem right. Do you have any suggestions? Another thing to note, would I be right in thinking that this solution would also require a custom artisan command that allows me to roll back to a specific migration as I mentioned [here](https://www.reddit.com/r/PHP/comments/40xh6l/in_a_multitenant_application_whats_the_best_way/cyxxcn8), where the specific migration to roll back to would be the last migration applied during the release being rolled back to (queried from the log of migrations applied per-release)?
Every new feature is additional complexity in PHP. We don't want the language to get unmanageably large. In the case of this feature, it might be useful, but it is at least partly redundant given the option of scientific notation for floats. So we have to ask if the additional complexity is worth it. I'm not sure, so I haven't voted.
I've used the separator in Perl a couple of times in the past. The one or two times I needed to write bigger numbers in PHP, I thought "Would be nice to have the separator like Perl has" but I don't do it often enough that it really matters to me. I think it would be a nicety for those times someone wants to use it but the language isn't suffering without it
That's a decent idea. I've thought about the same thing. Keep type coercion near the top layer where user input is concerned, and then strengthen the typing deeper in the app and into the domain.
It doesn't say January 1st 2019, it says December 31st 2018. I understand where you're coming from, but it's still confusing.
The main thing to realize is that the default response to any new language feature *should* be somewhere between "against" and "strongly against", shifting more towards the latter with increasing maturity of the language. The absence of specific reasons against a proposal, is *not* a reason for it's inclusion. A proposal has to provide sufficient merit, to surpass both this default opposition to doing any language change, and any specific issues found with it.
&gt;I'm already keeping track of the migrations in each tenant db (Laravel does this automatically). How do you suggest I keep track of migrations per code update version? Can't speak for Laravel, we use a custom solution, but I guess you can add a hook or similar in Capistrano when deploying and record new migrations included in that code commit/revision, you can simply check for new files in migrations folder. &gt;For example, lets say I deployed successfully yesterday during which a new migration was added and applied to all existing tenants. Now lets say a new tenant was created this morning (the script for which includes running all migrations without using the deployment tool, meaning they also got the new migration that was added yesterday), and now I want to roll back to the previous release (before yesterday's release). If I was recording which migrations were applied during a release at the client level, it would look like the new client wasn't migrated during yesterday's release, and so nothing would be rolled back - when in fact the last migration (that was added as part of yesterday's deployment) should be rolled back. No, the new tenant gets migration X and Y (applied with your script) and then you roll back version XXX to yesterday state. You know (you need to keep track of this) that migration X is part of version XXX so you roll back that migration in the new tenant (and the other tenants that has migration X applied) &gt;So maybe there should be a single log of migrations that were applied at the release level (rather than logging migrations applied per tenant) You need both, a log with migrations per release/commit/version AND a log with applied migrations per tenant DB &gt;Another thing to note, would I be right in thinking that this solution would also require a custom artisan command that allows me to roll back to a specific migration as I mentioned here, where the specific migration to roll back to would be the last migration applied during the release being rolled back to (queried from the per-release log of migrations applied per-release)? Yes, I have this custom command in place, but we don't work with Laravel :(
I can't imagine that in 10 years, we will all be writing PHP where the first two lines of every file are: &lt;?php declare(strict_types=1); I really hope within a couple of years they have switched it on by default, albeit with the option to disable it in php.ini. 
If it's an optional flag why would it be a BC problem?
That's a really helpful answer, thanks! I could still do with a little clarification on some things, but I think I'm almost there. During deployment, and before migrating any databases, I'll get Capistrano to call a custom artisan command `artisan deploy:migrate:diff &lt;release_path&gt; &lt;current_path&gt;`. This command will diff the files in the two provided directories, and save to a file within the release path containing a JSON array of the names of the migrations present in the release directory that aren't in the current directory. That way, each release has a definitive list of migrations saved within the path, that can be inspected at any time. Then I'll proceed to migrate each tenant's database, using my custom migrate artisan command that loops over all tenants databases and migrates each one individually. This command automatically populates the tenant's individual migration table with all the migrations that have been successfully applied. If any tenant migration fails, I'll have a Capistrano hook that calls another custom artisan command `artisan deploy:migrate:rollback` in the release directory that will first retrieve the contents of the saved JSON array of migrations that were applied during the release. It will then loop through all tenant databases and check if each of the migrations in the JSON array are present, and if they are, roll only that migration back and remove that entry from the tenant's database. This results in a guarantee that each client's migrations are rolled back in the order that they were applied, but only if they were ever applied in the first place. This seems pretty good, my only major concern at this point is that if a migration failed for whatever reason, it could indicate that attempting to connect to that same database to see if it needs to be rolled back may fail as well, causing the rollback command to fail. Any ideas as to how I could tackle that? Thanks again for taking the time to respond, it was very useful!
Yeah, pretty much. If I turned on strict types at the layer in which user input hits code, there are going to have to be explicit casts everywhere in my code and I'm going to hate it. Better to let the hints do coercion when other classes and functions are called and be strict from there on in to be absolutely sure that things are what I think they are.
No, not completely empty, just missing elements. [Like this, but apparently I misread whatever is in the docs about missing things in `list()`](https://3v4l.org/K3bmp).
That's an excellent point and it would be great to have, but I think it's pretty much impossible to allow custom *syntax* in an interpreted language. Python, for example, is pretty much like PHP when it comes to [adding syntax/behaviour](http://stackoverflow.com/a/9108164/879047). You would need something like preprocessor macros, but for PHP *at runtime* and I can't imagine what that would look like. Can you?
Yeah, that's pretty close of what we use &gt;This seems pretty good, my only major concern at this point is that if a migration failed for whatever reason, it could indicate that attempting to connect to that same database to see if it needs to be rolled back may fail as well, causing the rollback command to fail. Any ideas as to how I could tackle that? Well, things will fail, locked tables, connection failures... in fact devil is in the details and shit will happen. You can automatize 99% of cases, but you will need to solve manually some failures, automating this edge cases will be painful and not worth it IMHO. But it depends on your business case and contract ties of course.
It might be worth your while to take a look at Paul Jones' [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) book. It has a section on removing globals, and a whole host of other other good advice and techniques that would probably be applicable to your project. 
And now that it has a longer support cycle than 7.0, people will be disincentivized to upgrade.
Again, it's a backwards-compatibility and library interoperability nightmare, and you're assuming everyone will use strict typing.
I guess I am in the camp that I don't see a need for it. When I am using large numbers like they are always abstracted to a const or variable, so I think the examples listed in the RFC are poor (eg 97802345932 &gt; 97802349532) because why would you ever do that comparison? You would be doing $largeNumber &gt; $otherLargeNumber OK now that they are abstracted to say a constant it would be useful there. Ok maybe slightly, but a const is something you set it and forget it, once it is set does the readability matter? The variable name should be descriptive enough so you dont care what the number actually is. 
phuny !
ba dum ts!
why i think it's kinda cle.. oh
if it's a joke, they've put some effort into it: http://phap.landingpage.io/images/9XmwejS93znx3nZrT.png
I am also a little skeptical of anybody who doesn't know C. You don't need to be a guru, but if your chosen field is programming, it's like being a writer who has never read Shakespeare, or a chemist who has never handled test tubes. Sure you can do it, but there's just such a primal elegance to the language and it's so influential even today (even if it's a language trying to *not* be like C), you should know it just for context.
Wouldn't this be better represented as `3 * 24 * 60 * 60 * 1000`?
I'm not familiar with how migrations work in Laravel, but I've built an almost identical system in Yii2 (down to the custom migration commands). I haven't had to solve this problem yet, probably due to the fact that we only have a handful of tenants as this stage. Maybe you could store the previous version of each successful migration in an array, and upon failure iterate through that list and revert each of those tenants to their previous state? Consider the below pseudo code: public function migrate() { $previousVersions = []; foreach ($this-&gt;tenants as $tenant) { $version = $this-&gt;getMigrationHistory(1); // store the current migration version try { $tenant-&gt;migrateUp(); $previousVersions[$tenant-&gt;id] = $version; } catch(MigrationException $e) { $this-&gt;revert($previousVersions); return self::EXIT_CODE_ERROR; } } return self::EXIT_CODE_NORMAL; } Though this doesn't consider the event in which reverting fails, which is something to think about.
So ugly and so unneeded. If your *code* needs to compare digits like 89745564, you're doing it seriously wrong.
[Here](https://www.youtube.com/watch?v=65NrzJ_5j58) is a great talk about removing globals and modernizing legacy php. I haven't read the book but I watched this entire talk and I found it to be very helpful, explaining everything clearly in small simple steps.
It even says "new DemoAppScreensiPhoneHomeScreen()". The example code is for apple devices, not android devices, so that pattern fits. Although it's still most likely a joke.
What would PHP's transformation from open source project to publicly-traded multi-national corporation have to do with ... what?
I'll have what he's having, please.
I still find great thrills in the programming itself. But I know what he means. I use frameworks as much as possible and I reuse a lot of old code. Actual programming I try to minimize becase the end result is always the main focus.
im going to stop calling myself an engineer
This is one of the main reasons I strongly prefer Postgres for pretty much everything. The implicit commit of DDL actions inside of a MySQL transaction is pretty annoying.
I'm aware of that. So it's set to false by default, but a user can change it to true if they're able to and wish to. Seems like a no-brainer, not sure what I'm missing...
"I can't see a use for this, so there must be no use for this".
This website would be perfect on mobile if they made the header disappear when you scrolled. It currently takes up such a large portion of the screen in landscape mode that you're forced to switch to portrait mode.
You've been shadowbanned from reddit: https://www.reddit.com/user/mbadolato The /r/php mods didn't do it. Contact the reddit admins to unban you. Good luck.
I feel like I come across that more and more each day, and some sites have gone as far as adding a fixed footer as well. Which leaves 50% of an already small screen for the actual content.
They'll have to sell a _lot_ of iPhpones...
...true of pretty much any setting in php.ini... 
Wow, lots of information here to digest. Thank you both for the highly descriptive and detailed responses. 
This is an amazing thought. You're an amazing person.
Not sure why you've gotten so many downvotes. C is often the low level implementation language of many other higher level languages. It's the closest you can get to the metal without writing assembly. As such it instills a much deeper understanding of processor architecture by necessity. Without that knowledge you can still use higher level languages, but you're going to be a less effective programmer if you don't understand what's going on under the hood.
To be fair, the RFC doesn't provide any *practical* examples in contexts where PHP is *typically* used. From my personal experience two applications come to mind, namely large hex numbers for bitmask and other twiddling (`0xffffffffffffffff` is much less clear than `0xffff_ffff_ffff_ffff`) and constants for scientific computations. However these are examples that come up in my C code and my Matlab code respectively, *not* my PHP code. It would likely help this RFC if it contained some practical examples that can be associated with.
His transition into Old-Man-Lerdorf has been mesmerizing.
I think you're either being brigaded for something, someone has a sock-puppet army after you, or the redit vote fuzzing algorithm has gone crazy. A minute ago you were at -13 for making a mildly controversial statement echoing the article in a post that appears to have had very few readers. There are only four other comments, none of which were at more than +6. Even if you dropped some absolute racist kitten-kicking bullshit you should only be at -8 or so in a post like this.
Which is why a lot of behavior-altering php.ini settings are deprecated or already removed. Libraries depending on certain behavior creates a ton of issues.
Thank you.
Yes, I'd agree.
wat
No idea why so many downvotes, I've found myself stracing processes to find out what they're doing if other debugging tools aren't available and the system calls are so close to C that it's useful to have a working knowledge of it.
"Fellow engineers." That's gold, baby!
Now we have "Constant Scalar Expressions" sure. But my use predated that. But I guess its a moot point as this is for a future version anyway.
The votes not looking good so far.
actually thought a homeless person was trying to sell you boxes then i saw it was php
That must be some powerful ish you're smoking.
&gt; Not sure why you've gotten so many downvotes. Probably because: &gt; I am also a little skeptical of anybody who doesn't know C Which is nonsensical and inflammatory at the same time. "Knowing C" isn't even a stochastic value, nor is understanding an abstraction necessary to be proficient at another abstraction.
An insight into the downvotes from someone who was initially compelled to downvote: At first it comes off as kindof pompous, like you're judging people for not knowing C when it is not at all required to write decent code in other languages. So even though I agree with you in that in an ideal world developers of any language would have an understanding and respect for (or at least have a sufficiently informed opinion of) C, my knee-jerk reaction was to downvote you because of the perceived attitude of your comment which was probably not intended. I just think several people didn't make it past the knee-jerk.
the icon look very much like netbeans
I doubt that Guido, Wall, Pike, or Matz would say the same. And that's what gives php both it's strengths and weaknesses probably. Although really at this point just the soul is from Rasmus. It's a ship of thesseus language.
You are right, it does look similar, though it doesn't have any connection with Netbeans.
Yeah, I can see the usefulness there.
Is the convenience of Parse worth the vendor lock-in for you?
Yeah, that's what I'm afraid of. Adding third party repository or manual installation. But if that's the only way, seems I have no choice. Thanks!
No, It couldn't even float on the stock market.
Etsy sounds like a [delight](https://media.giphy.com/media/1047xUIi3HQnmw/giphy.gif) to work at
And "all" of it apparently...
You could even use constants to make things clearer: const SECOND_IN_MS = 1000; const MINUTE_IN_MS = 60 * SECOND_IN_MS; const HOUR_IN_MS = 60 * MINUTE_IN_MS; const DAY_IN_MS = 24 * HOUR_IN_MS; $timestamp = $now + 3 * DAY_IN_MS;
The problem isn't whether the language is interpreted. It's mostly a choice on the language designer's part. Loading macros dynamically could be problematic, but it depends on the approach.
Programming is the art of doing less work
People generally disagree with me, but I wish the web was just mostly text. Wikipedia, for example, is great on mobile. 
I'm thinking you may be right. 
Whoa
new patterns don't necessarily mean better patterns.
I think his point is that truly new problems require new solutions. And new problems are exciting to solve. While repetitive re-implementation of the same solution with a permutation of field names, brand names and visual styles is boring. And re-implementing the same thing over and over happens either due to an institutional problem, or inexperience as a programmer. One of the key aspects of good architecture is to know where to draw the component lines, what to reuse, and what not to reuse (and turns out most is reusable, but not in the form of frameworks or other monolithic structures). 
These relative fractions are just constants. You don't need to know their value. On the Aerys options I agree, I should have written them as `256 * 1024` etc. (Instead of `262144`) By the way, in general I don't see much literals in code which aren't just physical constants (where the actual value doesn't matter, it's just relevant for the result … you don't really go ahead and _read_ these numbers). [Here are a bunch of hex literals with up to 7 digits](https://github.com/amphp/aerys/blob/master/lib/HPack.php#L6-L40) … but I still have to find a place where I actually would need to read the values. I just can't find a place with long literals in places where their value is necessary to understand the code. As to scientific notation, you always can do `10**17 + 1000` if needed.
I don't mean things like OO patterns, I mean things like implementing an auth system for the 500th time. Even with a package that does most of it for you, it's still the same basic problem solved by the same basic pattern of code. What's been fun for me is diving deep into Javascript and learning how to build rich front-end applications that tie into simple server-side APIs. It's fun learning a new language and entirely new patterns/problems/solutions (state management, async, promises, and functional programming etc).
I know this may be too late but if the code is all the same you could consider symlinking it all from each instance instead of copying it to each. Makes it much easier to update as well. For instance if you use composer just symlink a shared vendors folder. If you have local customs code generate and autoloader for each instance that uses ./src or whatever to add custom code or override classes 
I was always under the impression that PHP would become the next Chewbacca and run for president of lisp. I bought a lottery ticket last year and have been keeping it safe under my cat for the day that happens.
Indeed. I couldn't even begin to enumerate all the people that helped me learn all the things I know, in one way or another. My journey from "lame web dev in middle school whose website kept getting hacked by jerks" to "avid security researcher" started on Enigma Group over a decade ago and took a haphazard course through various IRC servers and a succession of now-dead .onion sites. Some of them, I'll never know their true names (if they're even still alive) but, all the same, they never knew mine either. One of the more positive effects the Internet can offer is greater connectivity to *ideas*, even if the people you encounter don't stick around. I contrast this to my local community growing up: Always the same people, rarely any new ideas. In the past few years I've seen the line blur between the two, for better or worse. It's an exciting time.
I think you're thinking of InnoDB's [support for online ALTER TABLE statements](https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html) that was introduced in 5.6. In 5.5 only online "ADD INDEX" and "DROP INDEX" was supported. However, these statements still cause an implicit commit even in MySQL 5.6 and couldn't be used to solve the OP's case (they can't be rolled back): https://dev.mysql.com/doc/refman/5.6/en/implicit-commit.html
I think you should look at Laravel. That'll set your head straight. The next level after that is Wordpress.
I don't love hammers and saws but I love sitting in chairs.
To be fair his point is that the outcome/product is the part he finds interesting not the implementation details which is a pretty healthy attitude to have out in the real world. People that really love programming are great but unchecked they are also the cause of a lot of the bad things that happen on projects (not-invented-here, database/language proliferation, lack of perspective). Furthermore this approach is exactly what PHP is all about - the quick 80/20 win, not getting bogged down in creating the BEST solution but rather the one that is delivered on time and works well enough.
We have created a migration commit queue. Essentially a custom command line tool (lets call it `cluster:migrate`) checks each target database for pending migrations and queues up each migration and the server its running on. A separate migration task runner process then executes through the queue until its empty. If one of the migrations fail the queue is set to a failed state and everything done for that segment gets rolled back to before the tool was executed. The benefit of this is that the queue can have multiple runners to speed up the process (when you have a large number of databases to modify, waiting half an hour for a migration to pass is boring,) it is also able to identify if any of the migrations fail (as well as log the reason why) and perform a full restore back to the original point (so long as your migrations `down` method is well written, but you test those right?)
Which is something most programming related day jobs won't allow in the slightest, so for a vast majority of programmers, programming does and will eventually become boring if whoever you work for doesn't give you time to try new things.
well memed ... thought memes werent allowed here though..
Pun intended?
As long as you don't die, that happens to everyone organically.
Don't forget the banner ads the float over content. Always an important part of the UX.
Hi, I'm learning about OOP php and I have a question about a design choice you made in the following piece of code in the class: ParagonIE\Halite\Password public static function hash(string $password, KeyInterface $secret_key): string { if (!($secret_key instanceof EncryptionKey)) { throw new \ParagonIE\Halite\Alerts\InvalidKey( 'Argument 2: Expected an instance of EncryptionKey' ); } Why use the if statement inside the function and not declare the function like this: public static function hash(string $password, EncryptionKey $secret_key): string Or if you don't want to use a concrete declare a new interface? (like this? or maybe with a better name) public static function hash(string $password, SecretKeyInterface $secret_key): string And then make EncryptionKey implement both KeyInterface and SecretKeyInterface?
Maybe http://hoa-project.net/Literature/Hack/Compiler.html? Is it helpful?
[420 comment karma](https://www.reddit.com/user/p2rmigiano). Stoner confirmed.
Thanks for pointing that out. I also thought about making heavy use of Guzzle as main dependency.
?
Could we please keep the Markov generated posts to /r/subredditsimulator ?
&gt; you should definitely look into Drupal, and shiver as it looks back into you. I can't explain how morbidly accurate this is...
AmsterdamPHP guy I believe. 
Can you retweet Facebook posts? Hmm..
java yes, but gui apps? At least what jdownloader, eclipse, netbeans, minecraft, etc are not efficient .
maybe "hack" if Facebook don't discontinue the project 
http://phap.landingpage.io/
And here I thought it was called procrastination.
First I read about this "phap" post, and now this. What the fuck is going on on /r/php?
I think it's still up in the air as to whether PHP7 will be included in 16.04. Have you seen [this guide](https://www.digitalocean.com/community/tutorials/how-to-upgrade-to-php-7-on-ubuntu-14-04)? The PPA listed there is by the same person who manages the PHP stuff for Debian, so it's as official as you can get right now.
Sometimes you just have to go and try them to figure that out, though. 
&gt; There is no use. It's sugar. Those are two conflicting statements. Syntactic sugar can be very useful. It makes things more concise and easy to read, in which there is great utility.
Tried to find anything valuable from said knowledge, but failed.
THERE IS NO WAY THIS IS REAL HAHA &gt; I was pretty excited and later spoke to my wife about investing some of our savings into PHP. STOP IM DYING &gt; I was thinking of perhaps a function that will boot up a vagrant box and perform all the necessary dependency injections, continuous integration, unit testing etc and be ready to scaffold frameworks out of the box. We've had this for years... vagrant up in the command line, pick your poison on loading scripts in the VM, and use composer or similar methods of scaffolding apps. PHP isn't an entity or corporation you can buy stock in. What the hell.
PHPHones Ffffffones
Sometimes they do though. And the only way to find out is to give them a try. Even if the new patterns don’t work out, you should gain insight into why the existing pattern is better and maybe even discover a way to improve it.
Someone really made something pronounced [FAP](https://www.urbandictionary.com/define.php?term=fap)?
*Here's the Urban Dictionary definition of* [***fap***](http://www.urbandictionary.com/define.php?term=fap) : --- &gt;The onomatopoeic representation of masturbation. Often used to suggest that something is attractive. --- _Did you see those Natalie Portman pics? *fap fap fap*_ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/PHP/comments/40ziuk/does_anyone_else_think_php_can_become_the_next/cyz7k1g) ^| ^(**Summon**: urbanbot, what is something?)
&gt; it's up to twice faster and allow you to check types of parameters and return values Revolution.
Just please don't call yourself an artisian
I think the key words he used were 'your own time', and I agree. Don't rely on other people. Make it happen. If you can't do it at work... Do it at home. At my workplace, we have a don't take work home type policy, but some people take that as 'don't do anything you might do at work'... But then they only learn new things at work... I'd rather they learn at home, and bring that knowledge to work, and share it!
That PHP's original author thinks "programming is boring" partly explains it's history as a terrible language. I'm glad more adults are involved now.
This is a case of bikeshedding if I ever saw one. It really doesn't matter. If you're using PhpStorm, the "special case for else if" formatting option will make sure they are both formatted correctly.
&gt;In Java for Android, there are no lambdas. In Objective-C for iOS, lambdas are hard. In PHP, lambdas are super simple, making functional programmers feel right at home. lol?
So, about PSR-6. The vote was pretty bad... but it was accepted. Will the big projects be adopting it? Will Doctrine, Symfony and Zend?
How is an `array&lt;string, ...&gt;` going to work when PHP turns string array keys into integers if they happen to look like integers? Eg, at the moment: foreach (["98" =&gt; 5] as $k =&gt; $v) { print gettype($k); // int! } Will this behaviour be disabled if the array happens to have `string` as its type of key, so `"98"` stays as `"98"`? I'm very impressed that generics are being considered for PHP. Having a `Generator&lt;string&gt;` will be a treat. :)
I was referring to the eval. I have eval. Eval is Evil.... it just seems ripe for some kinda exploit... 
ablution!
Have you performed any benchmarks using your implementation on big view files? I'm pretty positive that eval() does not have support for OpCache so you are only winning on reading file content but loosing in execution time. Since compiled classed can be pretty big PHP will have to tokenize their content on every request which might reduce profit of using non harddrive store. I think you might use APC/APCu cache to store cache key information but keep compiled files on harddrive so OpCache can process them (no idea how much profit you can get there).
I can't wait to Phap an IOS app :p
&gt;The project uses globals everywhere since it was originally designed to be modular. I'm not too sure how this follows. Modular should mean there's a consistent interface to each module so you can replace/update things piecemeal without concern for breaking things in other modules. &gt;so I would need to convert each of the globals to classes which use namespaces. The hate for globals is because globals are used and relied on globally, not simply that they are variables in the global scope. A global singleton that control massive parts of the program is a global variable in spirit if not in syntax. The idea is to decouple your code from global state as much as possible, and if there's a huge amount of global state already in the program that may not really be possible without significant rewriting.
This guy gets it.
Trade-offs. If IntelliJ were native, it would be faster, but would have much less features, because native code must be ported and maintained on multiple platforms, and offers less convenient features for the programmers.
It is easy to get the php crowd going. It takes a lot of self delusion to justify using the language. Once you have that self delusion in place, the echo chamber that is /r/php will amplify any trivial 'accomplishments' to huge proportions...
/r/lolphp is leaking
...said /u/phpguy2 to himself, his "GOD HATES PHP" sign held proudly as he stood alone outside a local tech conference.
ya have benchmarks
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
you could try to use stream wrappers to emulate file system while actually fetching php code from apc and use it all with include/require
I'm thankful I escaped the PHP train. I'm still dealing with a lot of shit, but compared to anything PHP, it's heaven. And that's considering how compared to Drupal, most other PHP is heaven.
If you really don't like the eval, you could write a stream wrapper and use include :)
..So it seems. Looks like I can `include` a data:// uri. Don't know if that can leverage opcode caching; better odds than eval. Also, requires `allow_url_include` to be enabled in php.ini, but ok. I'll add that as an option here in a few. Edit: Doesn't benefit from opcache. 
You could also use a ramdisk for your "on file system" cache with the other bits stored in APC. That might be faster, would be a fun one to test anyway.
There will definitely be a lot of work ahead and I'm not expecting it to be easy, but that's part of the fun and challenge for me. I'm doing this more as a hobby because I saw some potential in the original design. Where possible, I try to find what the best practices are and adhere to them as much as possible. I'm not a developer by trade, but I'm close enough to the code that knowing this side of the world helps me in my day job. The part about the modular was an article that I found which said that legacy modular applications typically had defined globals on each function because you needed to be able to tap into what you needed and what you didn't. I'm oversimplifying the article, but it seemed to fit the general history of this particular project. I'm also not claiming that this is right or wrong, but someone long before me made a decision and I'm just looking to rewrite it to be more efficient and use today's standards since there are more efficient and more secure ways to do things now. In short, I am expecting a lot of rewriting and the core application will be significantly different when I'm done. 
I'm not sure your approach will scale. If you had 1M tenants, would you still want to upgrade them all in one 'transaction'? What do you do if you spot a bug in production an hour later, would you still want to rollback all, and potentially lose data? Let me suggest an alternative approach - decouple the code release from the DB ones, and deploy iteratively. Make your apps work in both vCurrent and vNew, for example check if the DB has a new field before attempting to save there, or having feature flags. Do DB changes in two iterations, i.e one to add something new, and later remove the old stuff. For more info, see: http://martinfowler.com/articles/evodb.html http://agiledata.org/ In this way, you can make back compatibility easy for all but the most destructive DB changes easily, and even deploy to some forgiving clients first, before rolling out the change to everyone.
You could (but probably shouldn't) do this: https://gist.github.com/huanga/1e38fc0dd3d8c362ea58 Few things pops to mind: 1. allow_url_include is required for the work around, which could expose you to dangers of malicious third party scripts doing nasty remote includes. 2. Doesn't really make it any less sketchy; instead of eval arbitrary code, you're including arbitrary code. 3. Cache poisoning is a real thing, and unless you're on your own server (e.g.: not a shared/reseller account), you probably don't want to do any of these...
Why would there be a need for that?
PSR-7 Psr\Http\Message\ServerRequestInterface Unless I'm mistaken...
&gt; unfortunately php's include requires the filesystem, and as far as I know, the only other way to load and create that class is feeding the string to eval. Internally, `eval` and `include`/`require`/`include_once`/`require_once` are the same opcode. They pretty much behave the same, as well. `eval` is open to abuse, but so is `include`. They're not really that different.
I'll try to repeat it in even simpler words then... the downside is that certain projects will start depending on the setting to be on, and other projects will assume it's not. These projects can then be incompatible with each other. 
http://www.phptherightway.com
As is the case every week when this gets asked, phptherightway.com But search the sub, there are tons of threads with suggestions.
I think the biggest revolution is that it happened. Internals has been a mess for years and now things are actually getting done. There is a roadmap, new features and real progress being made. Oh, and benchmarks.
...with a huge sense of self-satisfaction, even though no one was listening.
Wait til you configure it to use nightly releases! Check out the lube lib too, its a bit slippery to get going, but once you do you'll seriously question how you ever phapped without it!
Agreed, WSOD was always a pain
seconding http://www.phptherightway.com Plus, w3schools is pants :-/ (IMO!)
Too little, too late.
w3schools is awful, I don't think you need to qualify with IMO, it's kinda widely known :).
I tend to agree. The *only* benefit I saw to using that method, was the possible use of other data sources besides `data:`, But since opcache can't benefit from it I like the eval solution better.
The only logical response.
My canned response to this is: * http://www.phptherightway.com/ * https://github.com/paragonie/awesome-appsec (yes, application security IS a programming fundamental) * http://lowendbox.com/ - learn by doing
I'm not sure you got me right. Here's what I meant http://php.net/manual/en/class.streamwrapper.php This can be an example how to implement it https://github.com/goaop/ast-manipulator/blob/master/src/Hook/StreamWrapperHook.php
Not sure what point you're trying to make, but on your bandwagon, using php is as steady as ever: https://www.google.com/trends/explore#q=use%20php%2C%20use%20python%2C%20use%20ruby&amp;cmpt=q
See the sidebar here: https://www.reddit.com/r/PHPhelp/ (Disclosure, one of them - I ♥ PHP - is my tutorial).
CCA stands for **C**hosen-**C**iphertext **A**ttack, in case anyone was wondering. The actual vulnerability here is almost comical; or it would be if people weren't actually using this library in their projects!
Yes, it was bad thing in 1.1. It was there mainly because Yii was created before PSR-0 was accepted and overall PHP autoloading approach was formed as a primary thing. It's only in 2014 when PSR-4 was accepted which finally standardized that autoloader should not throw exceptions or raise errors in order to be interoperable. Yii 2.0 which was released in 2014 has it implemented correctly right from the start as many other things. You should try it.
Oh. That's interesting. So I could capture `file:`, and create my own transparent virtual filesystem? That raises some questions. I see opcache only functions with `file:` and `phar:`, and mention of a streams-is-cacheable rfc, But if I'm hooking `file:`..? I doubt that I'm that lucky, but maybe I'll explore the idea anyways. Edit: No idea what I was thinking. Of course that doesn't work.
Can't see anything obviously wrong but the formatting on mobile is terrible. Put it on paste bin or something.
Slides: http://ocramius.github.io/extremely-defensive-php/ Vidya's: http://ocramius.github.io/talks/ - probably of previous presentation.... Actually, why the heck is that going to facebook? His tweet doesn't: https://twitter.com/Ocramius/status/687907438956253184 
Have you been able to replicate the issue? Is it possible someone is double clicking the submit button and calling the script twice?
[removed]
I think it's a bot, autoposting his #php tweets
No. Not having parameter type and return type was the truly revolutionary when typeless languages like php and javascript first came out. Like fashion it's going in full circle. 
Don't have anything useful to add other than I can see your post so I assume it's been approved Good luck though
Based on the relatively small amount of data you provided, it sounds like this dev has a decent idea of what modern PHP architecture looks like. Silex is a solid choice. I have no idea what Doctrine is doing in there if the app is only supposed to connect to other APIs. MVC doesn't make sense for what you've described because a middleware application shouldn't really need models or views. (Some will probably argue against this and say that REST output can be represented as a view, and they wouldn't be wrong, technically.) I think the primary thing you should be concerned about is testing. Make sure that everything is abstracted correctly and 100% unit tested, not just functionally tested. You might also want to decide (as a team) on other patterns that are helpful, such as Command and/or CQRS.
So MVC really doesnt apply all that well to console based apps, so I feel like you're a little off base there. I should also mention that DI is used in conjunction with some MVC frameworks like Phalconphp so its not really a MVC vs DI thing. In saying that it sound like the dev started with a relatively simple code base and as it has expanded has tried to adopt some sort of method to structuring it out. My suggestion would be to hang tight, understand exactly all the reasoning etc without presenting an air of judgement or presupposed ideas. Once you're as good or better than the other dev at coding in their system, then you have the basis to begin introducing positive changes. Try and take them on a journey of betterment along side you so that the changes arent just your ideas but theirs as well. Be a team player and if they are a decent enough human being, things will work out well.
Plus its optional. I think the declare(strict_types=1) is an ugly hack... but still. One of the biggest complaints about PHP was that it didn't support strict types, which led to all sorts of issues, quirks, and extra argument checking. Now I can't believe people are downplaying it or say its not useful.
Sorry, I forgot to mention that this app is storing some info in its own database, so Doctrine does have a reason to be there.
I've read this post http://www.whitewashing.de/2015/02/10/a_case_for_weak_type_hints_only_in_php7.html and it made me think that weak types are more natural to the way PHP works. Didn't you have to explicit cast types too much after turning strict types on?
Probably the best candidate for doing some pair programming I've heard in a while. There are many schools of architecture and test driven development you can follow. Work with the usual red green refactor, maybe ask him to pair with you driving and you might get a better feeling for the thinking behind the design decisions. Conversely he may be able to learn your approach to problem solving and arrive at a middle ground that is better than any solution derived independently. Sounds like a fun project.
I haven't used it yet, i guess its cryptography, or something like this, i haven't tried strict types yet, just wanted to know how was your experience using it
Well, when it comes to security, being strict and explicit is desirable. Weak types system are some of what people rag on scripting languages like PHP for. I'm happy for scalar type declarations, strict or otherwise. I don't care *too much* if it's more "natural" to use weak types. If I can get away with strict without breaking anything, I'm turning it on.
I just want to point out that it is very common not to structure your application with a top level Controllers, Models and Views directory even when you are using MVC. The **M** in MVC is not referring to single model classes (more appropriately called entities), it is referring to the entire model of your domain which can (and should) include a massive variety of different class types (Service classes, Models/Entities, Repositories, POPOs, Value Objects, etc.). Having a "Models" directory can be entirely misleading. Separating based on module really is a better approach and I would definitely consider getting used to it.
Honestly, looks like you are very lucky to work with someone who actually has a clue. The codeigniter way of MVC with just using AR and making dependency injection hard is very outdated. [This tutorial](https://github.com/PatrickLouys/no-framework-tutorial) could help you a lot, it goes over how to set up a proper application from scratch like you are describing, but still loosely follow the "MVC" that you are familiar with. At least it has Templates and Controllers :) Also your understanding of MVC seems "wrong". I highly recommend that you read [this series of posts](http://blog.ircmaxell.com/2014/11/a-beginners-guide-to-mvc-for-web.html) from ircmaxell.
Well. To be honest usually ones with MVC knowledge like you describe, are "fresh out of school guys". And if they are questioning best practices, good methods, dependency injection etc, they are usually scholded by older guys (me included) to learn and keep learning. If they'd keep to what they were taught they'd code in Turbo Pascal still... So, your best bet now is to look at what your dev is doing and learn. Plus your "plan forward" isn't really learning ;) learn new and better ways of PHP with web apps too! As for MVC the way you described... I've seen "mvc" followed to the letter of "I don't really know what mvc is", so there were only 3 dirs: Controllers, Models and Views. In each of those, there were more that 300 files. That was hell.
We tend to celebrate most Fridays with the [song of our people](http://rebecca.blackfriday/).
Thx for your reply. When i said natural, i wasn't talking about the feeling the programmer gets using it, i was talking about the fact that core functions and most of existing libraries are not strict which would force you to explicit cast things when calling my strict code, like (int) $foo, and (bool) $bar. I guess i will have to give it a try and see if it happens.
Sounds very similar to our application in terms of architecture. And once you've shifted your vantage point from typical web MVC, it's quite wonderful. I can't give specifics but I'm happy to discuss our architecture a little more in depth if you'd like. It's not even that different from MVC, just that the M part is very thick and basically it's own application that whatever frontend plugs into. Take a look at [Uncle Bob's clean architecture talks and writings](https://youtu.be/WpkDN78P884), as well as things like hexagonal architecture and [Ross Tuck's Hemoglobin and Hobgoblins](https://youtu.be/ajhqScWECMo). But basically, your "model" is it's own little application that exposes hooks for things to plug into. Need an API? Call your model from Silex. Need a CLI? Use whatever CLI tools PHP has. Background tasks, GUI, etc, etc. Some applications go further and the model is just data processing that doesn't know *where* it's data is coming from, it exposes a hook to plug that in - database, flat files, external API, etc. Which works if you need it. 
idk that four posts constitutes prolific: http://stackoverflow.com/search?q=cryptoguard There are two answers from the same guy proposing CryptoGuard as a solution and one question and corresponding answer about CryptoGuard. And that's it. There aren't enough questions to justify creating a tag on stackoverflow for it. And 1,300 installs could just be from bots or some such.
It's easy to work without one these days with composer. But even if you use one (a modern one), most of the stuff in the tutorial is still applicable. You just don't have to handle the routing etc. Once your controller method is called it's all the same.
&gt; The M in MVC is not referring to single model classes It took me a LOOOOOOOOOOOOOOOOOOOOOONG time to get this when I was first learning about application structure and architecture. Every single article and tutorial would say things like "skinny controllers, fat models", and give examples of how your business logic should live in classes with "model" as the class name suffix.... So your comment should be copypasted onto every single tutorial, blog post, or article that tries to introduce people to MVC. And as a sidenote, OP's confusion is what happens when you take a pattern designed for one context (the original reactive GUI MVC - a pattern in the *small*), and totally warp it to fit another fundamentally different context (an architecture for stateless server-side request/response processing...) And then the Javascript community, which MVC is perfectly designed for, is abandoning the concept of MVC entirely, leaving PHP holding its dick using a small GUI pattern as a server-side architecture in all the wrong ways lol... Yay webdev. 
Don't forget tools like PhpStorm, which changes development speed drastically!
Sigh. https://en.wikipedia.org/wiki/PHP#PHP_6_and_Unicode
Then I don't trust your opinion. Enjoy your undefined is not a function errors.
skynet
Do they work with bound parameters so that you get proper escaping for the datatype specified by the argument?
&gt; it would be good to leave mcrypt_create_iv($num, xxx) to proxy to random_bytes() while discarding the possible second parameter. Agreed 100%.
Fair enough, thanks for the fast reply!
&gt; I've tried in EasyApache .. are you running cPanel? cPanel doesn't support PHP7, and won't for a long time.
Oh you sentimentalist you. I've really benefitted from these user groups. Yeah it's hard to get to some meetings but I found chatting to other devs invaluable in my last job where I was the only PHP person
Using a control panel may be convenient, but it's going to hold you back if you want to do anything more advanced with your server. Read this: https://secure.php.net/manual/en/migration70.php If your distro doesn't supply it, you'll have to use a repo like [dotdeb](https://www.dotdeb.org/) (on Debian) to get the latest versions. Also check any required extensions because some aren't available in stable yet. You can also build PHP yourself, but if you're not already familiar with the build process I wouldn't recommend it.
ohh life::saver you
Yea, now if we can get cpanel to support it.
Arch had an announcement too www.archlinux.org
The work that's gone into EasyApache 4 makes stuff like PHP7 a lot easier to do. I'm pretty sure it's on their short list.
&gt; cPanel is actively working on PHP 7 support https://features.cpanel.net/topic/php7-support
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I specially love the proposal to have it work in the function declaration, as an alternative to named parameters. This is really great!
I saw a launchpad bug a short while back that Canonical engineers are considering shipping PHP7 by default in 16.04. The current daily images have both 5.6 and 7.0 for evaluation, but only one will be included final distribution.
That would be nice. Waiting 2 years for it to be installed in a LTS would suck for the growth of 7.
Found it: https://bugs.launchpad.net/ubuntu/+source/php5/+bug/1522422
Hey r/php, I wrote a whole blog post about why I built camp and how it works on [my blog](http://mattallan.org/2016/01/16/camp.html). It could still use some work but I wanted to share it and see what people thought. It was really hard for me to find any information on compiling a portable PHP binary, so maybe this will be helpful to someone. Edit: It's OSX only for now, since that's what I have and it's the only platform without an official package.
That was what motivated me to implement this (see [the previous subreddit discussion on named parameters](https://www.reddit.com/r/PHP/comments/3z4jhu/is_now_the_time_for_named_parameters/)). Though I've thought list() with keys would be useful for quite a while.
Trivial accomplishments like the best wiki platform, CMS's, availability on every web host, design architectures and frameworks that are light years ahead of every other language. Sure, trivial. Everybody else must just be dumb, I mean that PHP thing I don't get it, so obviously everybody else is just on a bandwagon.
I had my account suspended for an hour on one host, because they weren't closed automatically. I always avoid not closing them, now.
according to this [bug report](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=807165), they are co-installable. there is no need to find a way.
Spin up a droplet on digital ocean and practice. 
You could use a PHP version manager.
On one hand, neat little convenience... but on the other hand, I'm nervous about anything which encourages people to use PHP's ancient `array` constructs for key-value stores more than they already do. (Especially in all these scenarios where the keys are known at design-time and being hardcoded.) My two biggest beefs with `array`: 1. It's not a vector. It's not a map. It's a bastardized unpredictable multi-mess that's always at-risk for doing something unexpected. 2. They have their own *unique* semantics for copying/modifying that are not shared by other objects... or even "array-like" objects that can use the same syntax. I'd like to see something to aid/encourage the use of classes, but offhand I'm not sure what form that'd take.
They are. You misjudge the cause for whatever "suspension", and barking the wrong tree.
This answer, although being technically correct by itself, is essentially useless for the OP, whose problem is different, and to answer it, one should be able to think one move ahead. PHP community at its best.
This is not "has a few advantages". This is the **only** proper way.
His shitpost complete, /u/phpguy2 leaned back against his dilapidated office chair, hand occasionally twitching over the F5 key. The plebians would listen to him now. They *had* to! A single tear threatened to roll down his bearded cheek. He blinked it away and cracked his knuckles. He would not despair.
&gt; It is shitty. But it is also a big part of what makes php easy to use. Until it abruptly isn't, as gaping maw opens and inky tentacles writhe forwards to pull you into the depths of madness, dumbly struggling to curse a god you no longer believe exists... Yes, it's easy to start using :p
Well it's such a leap forward in progress and performance, not switching to it would stifle innovation.
Looks pretty good! My main niggle is that `["foo" =&gt; $foo, "bar" =&gt; $bar, "baz" =&gt; $baz] = $someArray;` as appears in many of the examples smells pretty repetitive - perhaps there should be a shorthand for punning the array key and the destination variable name? One possibility is something like `[$=foo, $=bar, $=baz]`, where `$=var` is always semantically identical to `'var' =&gt; $var`. (Or maybe `$=&gt;var`, but I find that uglier and it doesn't read as having the right meaning to me?) Would also make sense to provide that punning shorthand for array construction, come to think of it. Maybe I should write another RFC for it.
While I do like the idea of creating easier unpacking mechanisms, I really don't like the idea of using a language construct that looks very much like a function as a method parameter. It looks very weird, is a very special case and is not something other languages have. We don't need even more quirks which one has to remember, we are just moving away from that.
Cool solution ☺ You do have some merge conflict in your source code you might want to fix, and I would strongly suggest that you sepperate logic from your view(html), at least as a stepping stone to proper MVC (model - view - controller)
There are two alternatives more: Using a Setter or using a service manager/locator or dependency injection. Whatever way you go: The connection close() should be in the __destruct() of you database class which might be a separate singleton and relies on PDO or mysqli or something other.
I was just trying to show OP how to get to that conclusion.
Thanks for the advice. What do you mean by merge conflicts? This is really the first website I've made with PHP. I've only really ever used it for scripting. Do you have any recommended reading for implementing MVC design principals with PHP?
BTW, i'v solve same exact problem with database layer prototyping similar way - by using class default values and reflection based analysis of models: class Post extends Record //or RecordEntity to use as DataMapper { use TimestampsTrait; //Database partitions, isolation and aliasing protected $database = 'blog'; protected $schema = [ 'id' =&gt; 'bigPrimary', 'title' =&gt; 'string(64)', 'status' =&gt; 'enum(published,draft)', 'body' =&gt; 'text', //Simple relation definition (optional) 'author' =&gt; [self::BELONGS_TO =&gt; Author::class], 'comments' =&gt; [self::HAS_MANY =&gt; Comment::class], //Not very simple relation definitions (optional) 'collaborators' =&gt; [ self::MANY_TO_MANY =&gt; User::class, self::PIVOT_TABLE =&gt; 'post_collaborators_map', self::PIVOT_COLUMNS =&gt; [ 'time_assigned' =&gt; 'datetime', 'type' =&gt; 'string, nullable', ], User::INVERSE =&gt; 'collaborated_posts' ], ]; } But my behave schema generated using static analysis so runtime code does not need reflections (everything is pre-calculated) plus database schema can be generated/adapted automatically with diff.
I'm a lurking python dev. :P I love context managers and I definitely count them as explicitly closing an open-thing. `with closing(...) as x:` is pretty baller. 
The RFC covers that.
ECMAScript 6 has an option where you can abbreviate `foo: foo` to just `foo`. I don't think I want to go down that route, though.
Well, yeah, it is a common thing - but is that really a thing we should continue? We don't need even more T_PAAMAYIM_NEKUDOTAYIM, do we?
But this isn't introducing a new one. list() already exists.
What about garbage collecting? You have reference loop in your code: $consumer-&gt;dto === dto(consumer)
&gt; Destructuring assignment exists in many other languages. Also in method declarations? I am not sure about this. The languages I know don't support this, but I don't know too many languages. Do you have any examples? &gt; Well, obviously. Every new feature to PHP is new, that's kinda tautological, no? There is a difference between adding a new feature and adding a complete new syntax. No need to get so defensive. &gt; It's not a particularly special quirk. If anything it makes the language more complete and consistent: if array() supports keys, why doesn't list()? Please make sure you understand what my point is. I am not arguing against having list() support the key-value-syntax. I am arguing that making list() available in method parameter declarations is a completely new syntax and a very special quirk I have not yet seen in other languages. &gt; While I'd like to add list() to function parameters, that is only part of the future scope and not the RFC itself. Welp, seems like I completely missed that. I shouldn't read new RFCs right after waking up. Sorry! &gt; That said, list() is not a function, it's usually quite obvious it isn't one (it only appears on the left-hand side of an assignment) and anyone who has used PHP for long enough should be aware of it already Tell that to all the devs who were puzzled that you couldn't negate empty() until a few versions ago. ;) &gt; Probably not. Hopefully not, but this is the kind of thing people might start thinking. &gt; T_PAAMAYIM_NEKUDOTAYIM is simply bad, it's a deliberately obscure name. list() isn't the best syntax, but it's what we've got. The problem it presents already exists. I am only arguing against the Future Scope part of the RFC (my mistake, sorry again!). The change to list() itself is a great idea.
Yep, you can absolutely use destructuring assignment in method declarations in other languages! Python has supported the feature for a long time, and JavaScript has also added it [in ECMAScript 6](http://bit.ly/1P8LceO). It certainly isn't written using a language construct that looks like a function call in either language, though. ;)
&gt; Also in method declarations? I am not sure about this. The languages I know don't support this, but I don't know too many languages. Do you have any examples? Alongside the example in the RFC, Haskell has this. &gt; There is a difference between adding a new feature and adding a complete new syntax. New syntax is new, yes, as is any new feature. &gt; I am arguing that making list() available in method parameter declarations is a completely new syntax and a very special quirk I have not yet seen in other languages. Parameter destructuring is not new to other languages, as previously exemplified. Anyway, I don't think it would be difficult to understand what it does. &gt; Tell that to all the devs who were puzzled that you couldn't negate empty() until a few versions ago. ;) You mean use empty() on non-variables? We probably shouldn't have ever done that, it's identical to ! for those. Oh well.
The main argument against removing arrays isn't that they're "easy to use", it's that they're very widely used, and even if you could somehow justify breaking almost all PHP code ever written, currently have no good replacement. But this supposes that arrays are bad and need removing. I'm unconvinced.
&gt; Alongside the example in the RFC, Haskell has this. Ah, okay. I didn't know that, never did much with Haskell. Seeing other languages supporting this feature gives it a better feeling. &gt; New syntax is new, yes, as is any new feature. Still with growing age, the community should become more hesitant to add new syntax to a language, especially when it is as ambiguous as the proposed usage of list() in a parameter declaration. &gt; Parameter destructuring is not new to other languages, as previously exemplified. Yes, but using something that looks exactly like a function for that? As an example [Ruby](http://tony.pitluga.com/2011/08/08/destructuring-with-ruby.html) seems to do it completely differently, which looks less irritating. &gt; You mean use empty() on non-variables? We probably shouldn't have ever done that, it's identical to ! for those. Oh well. I now remember what the exact problem was: You couldn't use functions in empty. I had a function that returned an array and I couldn't use a direct call inside of empty() to that.
Setter is practically the same meaning, different look. Same for DI. While locator should be avoided for explicitly created class, as it introduces strong coupling. It should be used only when cannot be avoided, i.e. for the factory-created ORM objects.
Typically people who disclose vulnerabilities give the vendor months to fix the issue before they disclose it. sarciszewski didn't even give this guy a day. From his post: &gt; Wrote their own block cipher implementation I see nothing wrong with this. Everyone has to start somewhere. Even OpenSSL and libsodium were written by people who "wrote their own block cipher implementation".. &gt; ...in PHP... Why not criticize cryptography libraries for being written in C as well? C, after all, does not do bounds checking, which leads to buffer overflow possibilities. &gt; ...and forgot to account for function overloading! That's fixable, although I question the necessity of such a fix since it seems quite likely that the library wouldn't work anyway with mbstring.func_overload. &gt; Chosen-ciphertext attacks (The existence for which is almost implied by "PHP crypto". Almost.) Because it's not doing authentication? If you do that you cease to be a "cryptography primitive" and start heading into the direction of being a "cryptography format" (unless you're using a mode that does both - like GCM) &gt; Defaults to a weak random number generator (32 bits of entropy is enough for AES right?) This is a fair criticism. &gt; Defaults to ECB mode (https://blog.filippo.io/the-ecb-penguin/) If you're using a "cryptography primitive" it shouldn't matter what the default is since you shouldn't be using the "cryptography primitive" anyway unless you know which mode you're using. Are there people using this library in ways they shouldn't be using it? Sure. Does that mean this library is inherently flawed? No. &gt; Offers a laundry list of ciphers available, some of which are stupid &gt; ...like SimpleXOR (remember JCrypt?), Vigenere, and Enigma! If you don't need a cipher don't use it! That's like saying PHP is a bad language because it has goto. PHP may be a bad language but if so it's not because it has goto in it. If you don't like the feature don't use it! From sarciszewski's github post: &gt; Also, cache-timing attacks. https://cr.yp.to/antiforgery/cachetiming-20050414.pdf See http://crypto.stackexchange.com/questions/27314/why-do-crypto-libs-use-table-lookups-when-theyre-vulnerable-to-timing-attacks Most AES implementations out there are vulnerable to cache timing attacks. They're extremely impractical to exploit, however. Only real way to prevent them is by using something like https://en.wikipedia.org/wiki/AES_instruction_set and a lot of libraries don't do that since they aim to be highly portable. Most ARM CPUs, for example, do not support AES-NI. TLDR I think sarciszewski is, to an extent, doing a good thing by bringing an awareness of common issues to the community at large. But he's also being a huge dick about it, being extremely trigger happy to publicly shame any and every project he can. People talk about how the PHP community is hostile. Anthony Ferrara talked about toxicity in the PHP community in his 2015 php[world] talk. See https://www.youtube.com/watch?v=MWTe-iswnqc#t=29m30s . sarciszewski represents the worst of this. He's like the poster boy for toxicity and we cheer him on like he's some sort of hero. He's not. He's publicly shaming developers with small pet projects that practically no one uses. The next time the developers of these pet projects write a project it's unlikely they'll open source it since the last time they open sourced something it got shammed in every possible forum. Like this project. Sure, maybe a handful of people use it. But just a handful. With 9 stars and 6 forks it just isn't a super popular project. Sure, it has had a few pull requests but only a scant number. sarciszewski - if you're reading this... please just stop.
If you have control over the array keys you could always use `extract`...
&gt;&gt;&gt; Chosen-ciphertext attacks (The existence for which is almost implied by "PHP crypto". Almost.) &gt;&gt; Because it's not doing authentication? &gt; https://en.wikipedia.org/wiki/Chosen-ciphertext_attack Quoting that wikipedia article: &gt; A better approach is to use a cryptosystem which is provably secure under chosen-ciphertext attack, including (among others) RSA-OAEP secure under the random oracle heuristics, Cramer-Shoup and many forms of **authenticated symmetric encryption** when one uses symmetric encryption rather than public key cryptography. (my emphasis) Even [sarciszewski's own github.com post](https://github.com/gilfether/phpcrypt/issues/6) indicates that the reason it's vulnerable to chosen-ciphertext attacks is because of it's lack of authentication: &gt; Also it appears that every cipher (from your long list, which includes such gems as SimpleXor and Vigenere for some reason!) is vulnerable to chosen-ciphertext attacks, **since you aren't authenticating your ciphertext in an Encrypt then MAC mode.** (again, my emphasis) And as I said, "*if you do [what sarciszewski has proposed] you cease to be a "cryptography primitive" and start heading into the direction of being a "cryptography format" (unless you're using a mode that does both - like GCM)*" &gt; Read what Scott linked to: https://blog.filippo.io/the-ecb-penguin/ &gt; ECB is rather insecure, it shouldn't be used. No where in my post did I imply it was secure. I only said that if you're using a "cryptography primitive" you ought to be using a **specific** mode anyway. You ought to be aiming for interoperability if you're working with "cryptography primitives" and if you need ECB to achieve interoperability so be it. Fact is, some legacy systems do use ECB and you can't pretend that away. Maybe it'd be better if the library didn't default to a mode at all. Maybe it'd be better if an exception was thrown when a mode wasn't explicitly defined. But he doesn't do that and I still stand by my statement that that's not a huge issue, security considerations of ECB aside. &gt; If a cipher is worse than useless, you shouldn't include it. Otherwise people will use it. sarciszewski linked a number of projects to https://github.com/gilfether/phpcrypt/issues/6 (scroll down to the bottom; search for "Please plan a migration path away from PHP_Crypt"). I challenge you to find an instance of Enigma being used in any of the projects that uses PHP_Crypt. If you can provide a real example of this being done I'll eat my words. &gt; You can't just privately complain about such things, because you can't find everyone who uses a given library. Also, if you aren't public about it, then people looking for crypto libraries will continue to use garbage ones. This crypto library isn't perfect (even I agree with sarciszewski's point on the random number generation) but calling it garbage is a stretch. The one legit issue sarciszewski found is quite fixable. &gt; If you write a pet crypto project, don't publish it. People might end up using it. Well then people aren't going to learn.
Fair points. Although even with this proposal you'd still have to essentially whitelist certain array keys and you can do that with `extract` by using `array_intersect_key`. But I will concede that there's virtue in having the default behavior be secure, which can't be said for `extract` (unless you have control over the array keys and aren't being careless with your naming of array keys or variables)
I'm not sure that gc would be much of an issue, given the scope of picotable as a prototyping aid. That said, I'm sure there's plenty of room for improvement in the connecting process. At the moment, the dto takes a reference to the consumer so that it can set up the connected columns collection - that bit might need some more thought. But as your first comment notes, the premise of picotable is a bit flaky anyway. You'd normally design models/entities with storage in mind from the get go. ;) 
&gt; Typically people who disclose vulnerabilities give the vendor months to fix the issue before they disclose it. sarciszewski didn't even give this guy a day. I'd guess the explanation for that is: &gt; Like most "pure PHP" cryptography projects, this code is pure security theater. There is no salvaging it. 
Personally, I think that providing an array as a single argument to a function for supplying configuration, etc., is an anti-pattern. It is useful in cases where the provided information is truly dynamic, but even then it should be avoided because it makes functions harder to document and reason about. Explicit parameters, even with defaults where appropriate, provides a much clearer API. This RFC seems to aim to shove us further down the rabbit hole of passing opaque data structures around everywhere instead of writing thoughtful, decoupled functions that manipulate data with standard and simple approaches that can be easily understood. Moreover, the syntax is somewhat confusing, conflating the hash map syntax with an assignment; newcomers to the language will look at `list('one' =&gt; $two) = $propertybag` and not have any idea what's going on.
I've been programming in PHP a long time, and I have yet to run into a real-world problem caused by PHP's swiss army knife arrays. Granted, I don't have a lot of experience with languages that have "fragmented" constructs, so maybe I'm missing something, but I can say for 100% certain that I've not run into anything weird or unexpected with arrays. They have always worked the way I would have expected them to. PHP's array function library? Yeah, it has some weirdness that trips you up ONCE, then you know...
Usually 500 errors deal with errors within your code or file permission errors. Make sure your php files are correct and that they have proper permission. 
Interesting idea. I'll have a play around with the code. Thanks again :)
Why on earth would we put this syntax into the function signature itself? Couldn't we instead implement named parameters as has been suggested and attempted so many times before? At least then PHP would be getting closer to other languages people are familiar with rather than yet further away from them.
Okay. Look at what file is missing. Figure out why it might be.
&gt; Couldn't we instead implement named parameters as has been suggested and attempted so many times before? No, they pose various problems. The biggest one is simply that parameter names are now part of a function's signature, which has a number of consequences: * For internal functions, there would need to be a massive effort to synchronise parameter names between the PHP manual (in all language versions - yes, some of them translated the names :/), PHP arginfo structs and PHP prototype comments * Everything inheriting from a class or implementing an interface must now keep parameter names the same (backwards-compatibility headache) * You can't change parameter names across versions in libraries * Callbacks must now have correct parameter names * Relaying of arguments can no longer be done reliably with `call_user_func_array` and must use `...` See this previous discussion: https://www.reddit.com/r/PHP/comments/3z4jhu/is_now_the_time_for_named_parameters/ Also, it's never been decided what the correct syntax to use is. &gt; At least then PHP would be getting closer to other languages people are familiar with rather than yet further away from them. Array destructuring within parameter lists is not a new idea unique to PHP. ECMAScript 6 also uses this approach. It avoids all the problems of introducing named parameters to a language that did not have them before.
I have a simple task for you. Write a function that accepts an array of strings and return another array with strings in the input array set as keys. Now write another function that accepts the output of the previous function, as first argument and another string as second argument. In this function, assume that you have some reason to iterate over the the input array using foreach, key =&gt; value format. In every iteration, in addition to other stuff, you also have to check if the key is equal to the input string (the second parameter of this function), and if they match do some stuff.... Please just write down how you will do this in php. Anyone is welcome to attempt this simple task.... 
Advanced PHP Programming was released on March 1, 2004 before PHP5 had even been released (PHP5 was released on July 13, 2004). And Essential PHP Security is almost as old. It was released in 2005. Of course, that said, I think Essential PHP Security is still somewhat relevant. As PHP has evolved new attack vectors have been introduced and old ones have been plugged but the core ideas are still relevant.
&gt; Haskell has this.. Can you show me what exactly in Haskell you mean?
Haskell has pattern matching, and it supports records, so you can use records to get something akin to named parameters. You can define a record like so: $ ghci GHCi, version 7.8.4: http://www.haskell.org/ghc/ :? for help Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Prelude&gt; data FooBar = { Foo :: String, Bar :: Integer, Baz :: Bool } Prelude&gt; data FooBar = FooBar { foo :: String, bar :: Integer, baz :: Bool } Then define a function which pattern-matches against that record: Prelude&gt; let foobar FooBar { foo = _, bar = _, baz = baz } = baz And then apply it, passing in that record: Prelude&gt; foobar (FooBar { foo = "test", bar = 1, baz = True }) True Prelude&gt; foobar (FooBar { foo = "test", bar = 1, baz = False }) False Pattern matching is more powerful than mere destructuring, though, because you can have different versions of the functions for different matched patterns. A good example of this is the factorial function: factorial :: Integer -&gt; Integer factorial 0 = 1 factorial 1 = 1 factorial n = n * factorial (n - 1)
I'm not misjudging the cause. I got a "too many open connections" error and was contacted by the techs directly, stating exactly that. They explicitly recommended closing, to avoid it from happening again. I'm not claiming anything other than not closing them explicitly made my account being suspended for an hour on that host. It doesn't mean the server was properly configured or anything. It just means that I lost sales during that hour, which sucks for all parties involved. Edit: the script was a small mysqli query to update 500 rows, no big deal, probably 40 lines of code.
I'm relatively new to php and had been using wampserver/xammp, but decided yesterday to configure apache out myself and add php7/sqlite3/postgresql. Did it on two machines for my localhost. Was a lot of fun actually, because I had to configure everything myself. I was thinking though, how deep should I be on server configuration to be an effective php developer? Is this normally something a devops engineer does? Should I know apache/nginx/iis/etc inside and out? 
Proof of what? I'm not sure you're replying to what I'm saying, so maybe that's what's turning this conversation upside down. After running the script a couple of times, the SQL server returned the error on a WSOD. I'm sure there is always the possibility of some underlying reasons I'm not aware, but when the SQL server returns that error, I'd start checking that. After I started closing, I've never experienced the same kind of error so the account didn't go offline because of that anymore. As you said, dealing with incompetent techs is "expected" in this field, so anything that avoid situations like having your account suspended for an hour is always a helpful reminder, IMO. We never know what we'll have to face, with hosting...
Yeah, I guess list() moves things around a bit, but that's just how destructuring assignment works.
&gt; Write a function that accepts an array of strings and return another array with strings in the input array set as keys. $array = array_flip($arrayOfStrings); &gt; Now write another function that accepts the output of the previous function, as first argument and another string as second argument. In this function, assume that you have some reason to iterate over the the input array using foreach, key =&gt; value format. In every iteration, in addition to other stuff, you also have to check if the key is equal to the input string (the second parameter of this function), and if they match do some stuff.... &gt; Please just write down how you will do this in php. Anyone is welcome to attempt this simple task.... foreach ($array as $key =&gt; $value) { if ((string)$key === $someString) { doThing(); } }
&gt;By picking only one framework to represent your skills you make yourself less appealing to those who assume you don’t have transferable skills. Sure they’re wrong, but you just lost out on a potential job offer. After-all, if you are a good enough PHP developer to easily use any framework, why are you listing yourself so specifically with one specific framework? You are a PHP developer who specializes in Laravel, not a Laravel developer. https://philsturgeon.uk/php/2014/01/02/the-tribal-framework-mindset/
I don't actually like this one... I find the intent and structure of the original syntax much clearer. Also, the new syntax is only a few characters shorter. I wouldn't mind having it in the syntax, I just don't see the point and I will not use it. 
&gt;Not being able to use numeric strings as associative keys is intentional and documented. But you still ended up writing broken code. That is the only point I wanted to make. &gt;much about this contrived use-case Mm..You earlier said that it was "incredibly simple..". Now it is contrived?
You forgot to add the comment and unit test to go with this code so as to prevent someone else coming along and cleaning the 'unnecessary' casting breaking the code subtly. Jokes aside, I think my point was made by the response of /u/betterphpguy (which came before your response). Even hardcore php programmers with years of experience can be bitten by things like this. I mean, the guy used the latest Php 7 shiny features (strict types) and was extra careful in the first function...all for nothing! What this shows is an age old principle. A chain is only as strong as the weakest link. You can add all the shiny features to the language. But it will remain shitty and dangerous. Ditch it and move on people ASAP.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] ["It is so simple in Php, let me show you". "Mm. No it is broken". "Oh. It is just a contrived use case!"](https://np.reddit.com/r/lolphp/comments/41fqib/it_is_so_simple_in_php_let_me_show_you_mm_no_it/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; Some people expect list() to assign in the order of items in the array, not in the order of their indices. Why? That's how the regular list() functionality is. What would be the point of adding completely redundant syntax? &gt; That RFC was rejected Using list() in function parameters seems like a worse version of that RFC to me. But it's not part of your RFC so that's by-the-by. Overall, I just think this problem is better solved using either named parameters, or destructuring + object literals.
&gt; sarciszewski - if you're reading this... please just stop. Okay, if that's what you want, I quit security research. You're all on your own now.
&gt; But you still ended up writing broken code. That is the only point I wanted to make. The code I wrote was a literal translation of your requirements to PHP. The behavior is expected according to your own requirements and the PHP language spec. Expected behavior is, by definition, not broken. &gt; Mm..You earlier said that it was "incredibly simple..". Now it is contrived? Writing the functions to implement your requirements was incredibly simple. Your use-case is contrived.
I can't find the file anymore, I guess you fixed it ☺ I'll see if I can find some good articles...
Yep, no exaggeration. Literally that simple. Edit: BTW, 300% was a conservative statement. Most things were 4-500% faster. This was literally just dropping PHP7 into a Laravel install and observing the improvement.
For me the book selection is too code specific. It feels like the languages are changing faster today than the authors can keep up with them in their books. So after I bought a book about web development in JS (fml) I didn't saw the difference between the book and the already available ressources (such as MDN). IMO the two books out of the collection that stick out the most are: * PHP Objects, Patterns, and Practice * Essential PHP Security In the first one you have stuff that was established years ago (thinking here about the GOF book) and you can translate all the patterns to other languages as well. The second one is also a good choice, because of the reasons /u/kemmeta already listed.
&gt; Adding new syntax that doesn't rely on functions. `list()` isn't a function. &gt; Off the top of my head, something like this: What about Nikita's suggestion of symmetric syntax? Heck, that's even mentioned in the RFC.
Ping Jeff Atwood.
&gt; Turns out % doesn't work the way you think it does in PHP. You need to use fmod(); No, % behaves sensibly. It performs an integer modulo in most programming languages, PHP is no exception. That it doesn't quite go with /, however, is an accident of history.
Check this out: http://www.phptherightway.com/
Switching to a framework like laravel might save you quite a bit of time on development as well as security concerns.
I am working towards getting away from the "wrong" way of php (mysqli, php in the same page as html, etc) and learning object oriented php. Is laracasts.com a good resource for this? Would it help to build a couple applications with laravel? Any other good resources for OOP php?
The accepted answer to that question is refuting your claim. PHP microöptimisations like these are often worse than useless.
Then you've got this https://github.com/flarum/flarum :)
My main goal with 6BB is to provide forum software which is rapidly updated. It will automatically update the software. I'm currently looking at daily updates. But on weekends development could be released by the hour. Of course updates will be tested before an update is released.
I like Laravel as much as the next guy but I don't think it'd really work for something like phpBB or Wordpress since it kinda takes over a site. phpBB and Wordpress, in contrast, don't. They can live in their own silo'd little subdirectory and be perfectly happy.
Thanks for that advice. I'm making that update now.
One of the rare cases nowadays where Gentoo was earlier than Arch (Gentoo took about a week and a half). I'm surprised Arch didn't have it ready 3 days before release.
Typically file permissions should be 644 and folders 755 on Linux 
PHP hasn't completely changed from what Rasmus originally created. It's gained a lot of new elements over the years, but basic code written for PHP/FI 2.0? With tiny changes, it would work on PHP 7.
I still don't understand dependency injection and service containers :(
Why do you feel that is important? Are you specifically referring to security updates? What burned you with other forum software?
Why not just have concrete classes as the single input value? If I saw this syntax scattered all over the place, I would have serious reservations about the integrity of the code. There would be calls to isset all over the place, and it would make it difficult to understand due to the presence of so much housekeeping code.
Yes laracasts is a great start. I wouldn't venture too far from practical development. No one will pay you to flex your CS muscles in PHP. This is the "getting stuff done" language.
why?
Why you need so many updates? Daily update for an app is a nightmare for a user. 
Mainly to keep things fresh. And I plan on making sure everything is well tested (within a day though) before releasing the feature (it won't be unstable software by any means).
DI is quite a simple concept. Objects should *not* create their own dependencies (calling "new" for its dependencies), they should instead be "injected", typically via constructor, or by setter. Which means the dependencies need to be handled before a new object instantiation. They can be stubbed more easily and therefore unit tested without external interferences. Service containers is typically a container that handle / manage those dependencies. By using function references (like pimple does, for example) it allows a clever "late" binding of all dependencies (instantiation on need, in a way.)
Go to bitcointalk.org . The owner of that site has spent a few hundred thousand dollars rewriting the future forum software that will be used there. They can probably hook you up with a capable team.
&gt; bitcointalk.org Ok thank you so much. I'll ask them for assistance.
Which tool did you use?
This tool: https://github.com/philip/MySQLConverterTool
It's definitely a huge improvement. Though I'm hoping with when v8 rolls around in 5-10 years that they'll go ahead and change/remove a lot of the really stupid syntax and naming convention stuff that's still floating around.
&gt; Do you have any recommended reading for implementing MVC design principals with PHP? On the topic of MVC, it might be helpful to learn a bit about [SOLID design principles](https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) and [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns) - "MVC" [doesn't have a generally agreed-upon meaning](http://blog.ircmaxell.com/2014/11/a-beginners-guide-to-mvc-for-web.html) across frameworks (though that's no reason to shy away from a framework, knowing this may save you some confusion down the road).
then, at least, use composer to manage your dependencies and generate autoloader for your script
Yeah, that's what I meant. It just feels so strange.
I guess it's just a matter of opinion, but I don't think a non-variadic function should accept a key-value bag as an input. Using a concrete class, abstract class, or interface can enforce data integrity in terms of preconditions and assumptions about the data you're passing into the function. How else will you check that your input contains the things it's supposed to? How will you enforce the parameters and their types? Would you just blindly assume that the values exist for the keys you're expecting? If you're the only one or you are on a small team that is disciplined in its documentation, I could see this approach working, but if you need to have several people use your method, there are bound to be programmer errors and/or data inconsistencies. Again, this is just my opinion, but I don't see how the gain in programmer efficiency by saving a few keystrokes outweighs the benefits of a consistent and reliable interface.
I think you'll find that there really isn't all that much to forums.
Been there done that, you're going to learn a ton. And eventually you'll, realize you can write a project faster if you don't write everything yourself.
Go on... 
It's a joke, from someone wanting to stir shit (/u/rydan). The owner of that forum accepted thousands of Bitcoin as donations when they were worth far less, and has not been held accountable for the millions he now holds. [He has been paying his friends salaries in the hundreds of thousands of dollars a year to make a new "revolutionary" forum.](https://www.reddit.com/r/Bitcoin/comments/2mei83/for_the_amount_of_money_that_theymos_is_paying/) For the layperson, it looks like he is just stealing the money. https://github.com/epochtalk
I don't think you understand how **ENORMOUS** this kind of project is. Have you heard of Flarum? Well, the guy behind it [quit school to work on the project full-time](http://flarum.org/story/) - for the past [13 months](https://github.com/flarum/core/commits/master?page=51). *And he's still [nowhere near done](https://discuss.flarum.org/d/1780-release-date-stable-version)*! Oh, he's also using a lot of [laravel components](https://github.com/flarum/core/blob/master/composer.json) to help him develop faster. Because you want to write your own custom code, then you should expect the process to take even longer. So uh, good luck. I hope you have a lot of time and determination if you really want to pull this off.
[removed]
How are you learning PHP? What projects have you completed previously?
I believe the symmetric syntax would be the better choice. There really is no reason for the word `list` to be part of the language construct, when it could just an updated, improved, and simpler syntax.
If you know how classes work, [give this tutorial a try](https://github.com/PatrickLouys/no-framework-tutorial). Make sure you also try to understand the theory, lots of good resources linked in there.
Dependency injection is one of those programming terms which sounds intimidating, but it's stupidly simple. Like /u/matloco already said, DI simply means passing objects to other objects. For example, imagine you have an emailer class which _depends_ on a logger class and email server configuration. Wrong way: class Emailer { protected $logger; protected $config; public function __construct(array $config) { $this-&gt;logger = new Logger(); $this-&gt;config = $config; } } $config = ["host" =&gt; "localhost"]; $emailer = new Emailer($config); Right way: class Emailer { protected $logger; protected $config; public function __construct(LoggerInterface $logger, array $config) { $this-&gt;logger = $logger; $this-&gt;config = $config; } } $config = ["host" =&gt; "localhost"]; $logger = new Logger(); $emailer = new Emailer($logger, $config); The "right way" is dependency injection. That's it! Instead of letting the emailer create it's own dependencies, we pass the dependencies to it. The downside to dependency injection is creating a new emailer gets complicated. It would be a pain to write the following code every time you want to send an email. $config = ["host" =&gt; "localhost"]; $logger = new Logger(); $emailer = new Emailer($logger, $config); $emailer-&gt;to("joe@reddit.com"); $emailer-&gt;send(); A dependency injection _container_ simplifies the process of creating objects which have dependencies. Instead of creating the emailer ourselves every time we need to send an email, we have Pimple create it for us. First we configure the container: $container = new Container(); $container['config'] = function($c) { return ["host" =&gt; "localhost"]; }; $container['logger'] = function ($c) { return new Logger(); }; $container['emailer'] = function($c) { return new Emailer($c['logger'], $c['config']); }; Now to send an email you only have to write this code: $emailer = $container['emailer']; $emailer-&gt;to("joe@reddit.com"); $emailer-&gt;send(); You can use `$container['emailer']` anytime you want a new emailer, and it will already be wired up with all of it's dependencies and configuration. There's no need for you to manually create a logger each time you need an emailer. Pimple does it for you. Of course the emailer is a simple example. Often times classes have half a dozen dependencies or more, and using those classes would be very tedious without a container to automatically wire up them up.
let me whip... watch me nana... :D
curl is used for making requests over a URL. for getting a local file, which is what you're trying to do, use `file_get_contents()` – see [php.net reference](http://php.net/manual/en/function.file-get-contents.php)
Well that was the worst thing ever.
If you're purely dev you will rarely touch server stuff, if at all. If you're a dev op then it's more of a time trade off. Generally companies have people dedicated to do server management but it never hurts to have experience in it. Company I work for only has 1 sysadmin and when I sit with him during roll outs sometimes I have to remind him of what to do. Not in an elitist way but just to get the flow going again. Devops is becoming mandatory regardless of the company's structure. 
cURLFile is for uploading files. For reading files from disk, simply made a request to file:/// followed by the local path. But I would ask why you are using cURL rather than PHP's file reading functions.
Drupal is pretty shit though.
&gt;I am looking to start learning Coding and have been advised that PHP is a solid building block to start with Sorry. That is just wrong. Php is the [worst language to start](https://www.reddit.com/r/lolphp/comments/41fqib/it_is_so_simple_in_php_let_me_show_you_mm_no_it/cz2e69x) with if you are a beginner. Try starting with [Python 3](https://www.fullstackpython.com/). Yes. you should have a harder learning curve. But at the end you will have learned things that are widely applicable as opposed to things that are relevant only in one language, as it will be the case with Php. I will soon be downvoted and attacked by people from here for saying this. But for gods sake. stay away from Php. 
Thank you very much, I get the impression from your wording that you do not agree with PHP as a starting point?
Thank you very much for the feedback, I will be doing some investigation before going further it seems...
Here is a simple book to get you started: http://daylerees.com/php-pandas/
Good luck to you. I would get involved, but then I would start playing EVE again, and my time would fall into a black hole. Love the game, but it takes up far to much time!
OP, you're getting some weird advice from people. To start with, let's clarify *what* you are going to be learning. You said: &gt; I am looking to start learning Coding What do you ultimately plan on coding? Server-side logic for web applications? Then yes, start with PHP, don't start with C++ - it will be a very inefficient way to indirectly learn PHP... Games for the XBox One? Then yes, start with C++, don't start with PHP. Mobile apps? No, don't start with PHP, start with Swift or Java. Rich client-side web applications? No, don't start with PHP. Start with Javascript. Presumably since you're posting on /r/php, you plan on doing web development of some kind. As said above, that breaks down into two categories: writing code that runs on a server, and writing code that runs in your browser. Server-side code for web apps is handled by just about any language, but in my *biased* opinion, PHP is most suitable for myriad reasons. You don't need a compile step like C#, Java, or Go. You have a solid, bullet-proof webserver ecosystem (apache, nginx) that takes zero time to get up and running. PHP itself offers the flexibility to be typed or duck-typed depending on your preference, letting you start simply and evolve towards more strictness (languages like Ruby and Python are duck-typed *only*), web programming is kind of part of PHP's DNA (one such element of that is built-in templating, so it's one less abstraction to learn and deal with when first starting out). PHP has a decent model for writing object-oriented code. It's not as complete as languages like Java or C++ or C#, but it's *plenty good enough for the kinds of web development you will do in PHP*. The one caveat here is that PHP does not have a good built-in module system. You MUST MUST MUST MUST use an autoloader and follow PSR-4 standards w/namespaces to get module-like functionality. PHP does not give it to you out of the box like other languages do. This is PHP's biggest flaw IMO, but it's a non-issue once you know. Aaaaanyway, resources (assuming you already know HTML, and assuming you do indeed want to learn server-side web development) ## Getting your feet wet (syntax, control structures, classes etc) * [The free book Taylor linked to](http://daylerees.com/php-pandas/) * [The free codeacademy PHP course](https://www.codecademy.com/learn/php) (or some similar course) ## Getting a mental map of "proper" PHP * [Read PHPTheRightWay.com like a book](http://www.phptherightway.com/) (you may not understand all of it. That's ok. Just read it to expose yourself to the concepts it outlines) ## Learn SQL * [Free codeacademy course to get your feet wet](https://www.codecademy.com/learn/learn-sql) (PHP and SQL go together like peas and carrots. You need to know SQL to build practical web apps) ## Learn git and the command line (if you don't know it already) * [Again, code academy](https://www.codecademy.com/learn/learn-git) * [And again....](https://www.codecademy.com/learn/learn-the-command-line) (unless you don't have a Mac or Linux machine, in which case.... I'm sorry :( ) Sorry for all the codeacademy spam, but really for getting your feet wet for free without a huge time investment, that's a good place to start, but by no means complete.
This is dumb. In my opinion, NULL has a well defined meaning (not set / no value). It doesn't mean "I don't know" Using pseudo-non-values is dumb: 0 can be a completely valid, different value than "not set" for integers, as can -1 (the use of which for otherwise unsigned value could prevent the correct usage of an unsigned field, potentially halving the possible range of the field). The article spends a lot of time going into things such as the lack of scalar type hinting in older versions of PHP - but these are completely unrelated to the use of null. In many cases you still want to enforce types regardless of whether nulls are allowed or not.
It's not quite the same thing, but PHP 7 has [anonymous classes](http://php.net/manual/en/language.oop5.anonymous.php).
was going to write the same. http://php.net/manual/en/language.oop5.anonymous.php 
I'd advise you to start with JavaScript, the damn thing is everywhere now. And I wouldn't advise to start with really serious languages C, java or whatever, in my opinion it's pretty discouraging and unsatisfying when you can't do anything "useful" right away. It would take a day of learning to figure out neat little HTML/CSS tricks with JS, it would take an eternity to make some shitty looking OOP java notepad that your can't even show off to your friends because no one is going to bother downloading and launching jar files.
what do you exactly mean by declarative object syntax ?
I like null. I hate* having to deal with fseek/ftell because they return either a valid (int) position or 0/-1 respectively when there is an error. I would rather they just throw back either null or throw an Exception. *edited typo 
https://wiki.php.net/rfc/objectarrayliterals
 try { // ... } finally { $conn-&gt;close(); }
&gt; This is dumb. In my opinion, NULL has a well defined meaning (not set / no value). It doesn't mean "I don't know" It literally means “Not Set,” sure, but it doesn’t tell you *why* it is not set. That’s where the trouble comes in.
Maybe get rid of `NULL` by using a real language like Go or Ruby, both of which call it `nil`. That's what I did. :P
&gt; Which is why the correct API design is to make it the non-obvious option, where it requires some reading to know that the option even exists. That way, you filter out the developers who just don't understand what they're doing. I can agree with that. Although to be honest I do think even that is a bit of a pipe dream. Someone's always going to Google "how to set key with [library name]" when, in fact, they should be Google'ing "how to set password with [library name]". And then they're going to find an example and they're going to do it that way, be it non-obvious or not. I suppose in that regard it kinda sounds like I'm coming full circle and agreeing with you on your statement about how people will invariably use Enigma if it's available since that's kinda the same thing but idk... I think people are more likely to use a password as a key than they are to use Enigma over AES. Not that I have any empirical evidence to back that claim up - it's just more of a gut feeling type thing lol. Other than that... good response!
&gt;Date: 2011-06-04 (Updated: 2011-06-06) So I guess that won't be coming very soon...
This is where Javascript's "undefined" clarifies that situation. There, null just means "no value", but that value has been set somewhere. That could be some of the ambiguity the article is trying to address.
I think you are in the wrong forum 
/u/phpguy2 can do better
oh he's cute!
Someone would need to update this RFC. Short syntax will never pass: {bla: 1, foo: 'bar'}. Something like {'foo'=&gt; 1}, is hard too because it's seen as syntactic sugar, but it's possible IMO.
He sure makes it sound like that's the point... &gt; In this part I'd like to take a closer look at something we call null. Our main goal will be: to get rid of it. 
I just want to offer you a possible explanation in case it's at all helpful to you. My guess is your MySQL server has persistent connections configured which allows a database connection to be reused by other processes. Although connections do close on script termination they have a delay and I think in your case you may have had too many requests and the delays caught up to you. Closing the connection in the __destruct() method is a sensible solution. You want to make sure your code in that destructor is as bullet proof as possible though as PHP can exhibit odd behavior if there is an exception in a destructor.
&gt; rage I think the object-cast ist the correct syntax. It exposes the usage of stdClass as the lazy crap it is. Yes. I know there is reasons for stdClass to exist. Like SOAP and unserializing JSON into objects. So you can tell anyone using the output, that you have no idea what it is, aside of "some object". But once we leave that domain, for the sake of god, name your things. It is hard. Yes. Especially to non-native speakers (like me). But using (object)['key' =&gt; 'Value'] is unnecessary. Be honest and use an array. Casting it to (object) does not make it OOP. &lt;3
Either do JSON or don't do it at all, I would say :)
&gt; I can agree with that. Although to be honest I do think even that is a bit of a pipe dream. Someone's always going to Google "how to set key with [library name]" when, in fact, they should be Google'ing "how to set password with [library name]". And then they're going to find an example and they're going to do it that way, be it non-obvious or not. Right now, there's a high likelihood of that occurring, but that's more a transition problem than anything else - whereas somebody will already know what a 'password' is, 'key' is a much more foreign concept to beginners. They will likely only know the role it plays because some tutorial told them about it. This could probably be mitigated by hard-recommending against insecure-by-default libraries, and getting secure-by-default libraries to explicitly document that "you don't actually want to use it as a key directly, you want this instead:" as soon as possible. That way, there will be no blanks for people to fill in (as the correct solution is obviously presented), and the wrong instructions won't come to exist in the first place. To show a practical example: you will rarely find tutorials instructing people incorrectly how to use libsodium. Even though it *does* expose more low-level features, almost every tutorial will point people at the high-level ones. The misinformation was pre-empted, so to say. &gt; I suppose in that regard it kinda sounds like I'm coming full circle and agreeing with you on your statement about how people will invariably use Enigma if it's available since that's kinda the same thing but idk... I think people are more likely to use a password as a key than they are to use Enigma over AES. Not that I have any empirical evidence to back that claim up - it's just more of a gut feeling type thing lol. Not having looked at this project specifically, but basing it on what I've seen in general, I think both are quite likely - but picking Enigma over AES is more likely to occur in proprietary environments, where there's a manager to impress and such. Telling them that you've implemented "Enigma crypto" sounds a lot more impressive than "AES". Either way, I don't think no implementations of these algorithms should exist at all - they should just exist in a separate project/library, clearly indicated as "do not use, this is for educational/demonstrative purposes only". This is also how eg. books about (the history of) cryptography usually approach the matter. &gt; Other than that... good response! I appreciate that you took the time to read and understand my arguments - that does not happen often in these kind of discussions :)
You're doing that thing where your main goal here seems to be "being contradictory". Whatever someone has said, you're seeking first and foremost to refute that statement. Is there any universe in which he can be right? In which you can say "ah ya, you're right about that - good catch"? Or no matter what, you're always going to have a reply lined up that explains why he is wrong? *edit* I feel like reddit needs to have a "debate class", where people can learn that it's alright to disagree, and that the ideal outcome is that you eventually come to terms and agree on something. That doesn't mean you "lost" or are "a loser", it means you learned something!
Null, None, Nil whatever you call it has a place. But...I agree with the idea of using NullObjects. They're not always the answer but they're often better than a straight up Null. Too often I find myself guarding against nulls because what I'm using internally has used it as an "escape" value. Which in turn makes testing a little bit harder because I like passing nulls into constructors in tests as a way of saying, "This argument isn't going too be the source of any issues in this test" 
Guessing based on how I've seen it typically used, it's a preference for arrows over square brackets. Definitely not the reference semantics, which if anything tend to cause problems with this lazy approach to object definition. 
Alright so I need to figure this out. lumen/laravel's dic: Alright so I setup my twig singleton in laravel's dic, https://gist.github.com/G4MR/0992798be98c33197fb5 this works fine no issue. I have a class called TwigView which takes a TwigFactory Object which takes Twig_Environment. Now inside the service provider using make works fine and uses DI correctly even with the TwigView (I can see the twig instance using the correct folder path). Now when I try extending a controller which takes TwigView in the constructor, it doesn't have an instance of the correct twig environment at all. I've even tried doing a var_dump on the app make function inside the route itself and it creates an empty twig environment as if the loader wasn't being passed at all. How the hell do you use laravel's DIC? Edit: If you're curious how the route's setup: `$app-&gt;get('/', ['uses' =&gt; 'HomeController@index']);` Edit2: Yeah this is baffling, the `view()` function called inside the controller method works fine, seems as if it's grabbing the container instance, but it's not properly applying the dependencies at all to the controller. This is quite the annoyance. I've tried bind, singleton and instance in the ap.phpp and inside the appserviceprovider file both methods I've tried doesn't work. Edit3: Going back to slimframework 3 &amp; auryn. Rather put in a little more effort than fight with laravel this Monday morning.
Like in JavaScript [] is for array and {} is for objects. var a = {}; // JavaScript object
Hahaha you just need to know the Public crest API's which is what they apparently use in game, how ever - they seem limited in terms of market details. I have had people ask for volume sold and what not, I might be able to get that information over time as people use the system to search for items and as I collect the data
Not for the 16.04 tls imo.
&gt; This is the weirdness. It should accept floats so that it behaves like other mathematical operations (such as division), and other languages. It's not like there is One True Operation in mathematics that `%` should implement. You're glossing over [all of the complexity](https://en.wikipedia.org/wiki/Modulo_operation#Remainder_calculation_for_the_modulo_operation) behind the arithmetic - it's not just "works with floats" or "doesn't work with floats". I wouldn't do the topic justice in a reddit reply, so if you're curious, do a little research behind modulo vs. remainder, why languages chose to implement one over the other for `%`, how those implementations differ in other ways, etc. &gt; At any rate, none of your reasoning will change the fact that this behavior ate an hour of my time, that would simply not have happened in most other mainstream languages (which would either straight-up allow it, or straight-up error out). No, but you would have other problems in other scenarios, so it's unfair to point to one single scenario and say "see, if PHP acted like X in this scenario, I wouldn't have gotten bitten, so PHP is deficient." That's not the whole story. If PHP acted like X, you'd get bitten in other scenarios, just like people using those other languages do. Like I said, try `-21 % 4` sometime. C/C++/Go/Java/Node/PHP all say `-1`, but Lua/Perl/Python/Ruby all say `3`. Are either of these sets of languages deficient because they work differently? You'll note that your "mainstream languages" don't agree.
as an example `{"key":"Value"}` would be basic, but actually, I'd love it to be more powerful; maybe (type)$objVar, or allow trailing colon type {"title":"some title","created_on":"2016-18-01"}: SomePostType 
Exactly the same use-case this would fit for. I am aware of them, but I have not had the chance to use yet. Thanks
just been using Python, JS and Ruby a bit more in the holidays and like the fact they all support using hashes, a bit like we use php stdClass, but there is a literal declaration syntax available.
As a commenter says on YouTrack, a recent plugin called [Php Toolbox](https://plugins.jetbrains.com/plugin/8133?pr=idea) provides this functionality. But it should definitely be added to PHPStorm as a default suggestion.
I hope so. According to [some comments here](https://bugs.launchpad.net/ubuntu/+source/php5/+bug/1522422) they're at least considering it for 16.04, although the schedule is a bit tight.
for the lolz &lt;?php return json_encode(array_merge_recursive(json_decode($_REQUEST["a"]),json_decode($_REQUEST["b"])));
It'd be way better without infinite scroll at the thread level. Pagination is sometimes stupid, but making content hard to discover is worse.
Content is easy. Managing the content - the backend toolset - is the hard part.
The [original MySQL extension](http://php.net/manual/en/book.mysql.php) was removed in PHP 7. I'm actually relieved to hear that it won't be getting shipped in Debian (and thereby, by extension, likely not Ubuntu either). I had nightmares of package maintainers picking up the old code and doing just enough work to keep it running with PHP 7.x indefinitely, thereby perpetuating the 15+ years of antipatterns we're trying to eliminate.
Huh, and here I thought I knew all the small competitors from the days of the UBB.
My sides 😄😄😄
I don't mean to discourage you here, but allow me to discourage you. It is not worth writing new forum software right now unless you have a *specific* and *custom* feature set that you need for a specific purpose, and nothing else out there does it right. Why? Because forums are just collective comment systems, and comment systems are "easy." It's a solved problem. There are no new thoughts in this realm, not even in Discourse. All of the unique magic in a forum package is in the admin toolset, and what it does to let you customize the user experience. This is the only place where the products on the market *truly* differ ... and even then, they don't, really. Older projects have more features, and more knobs to turn, and more complexity, but that doesn't make them better. Unless you can't find an existing forum package, commercial or otherwise, that doesn't have that *one* knob you're looking for, don't build your own. If you *are* going to build your own, don't think about releasing it. Every PHP developer, at some point in their career, will be tempted to write a CMS, a blog, a forum, a chat, a poll, or some other thing that scratches an itch. There's nothing wrong with reinventing the wheel *as a learning exercise*, but we don't need more forums out there from people that wrote them as a learning exercise. Your code, as currently laid out, follows practices that we've known are bad for over a decade. You've used bad resources to learn how to write PHP applications. You've been given a lot of pointers in this thread about how to improve, but let me give you one more. You've gotten to the point where you want to show off this code. That implies you've hit a certain level of feature complete or code complete that you're satisfied with. Write down alllllll the things this code does, feature-wise. Take that list, and then go out there and pick a framework. Learn that framework, and take that list of features, and create a forum in that framework that has those features. Don't reuse your previous code. Now, stop and do it again - pick another framework, and do the same features all over again. This time, though, see what code that you wrote in your first framework experiment can be reused. Why would you do such a crazy thing, though? I mean, didn't I just tell you not to bother writing custom forum software? I did. But, it's clear that you're learning PHP, and it's clear that you have *some sort* of forum itch that's screaming out to be scratched. "Wasting" all the time implementing the same software two more times could be an *amazing* learning experience. Why two, though? It's so you can see what you like and loathe about frameworks. You seem to distrust them now, but they can be amazing tools if you use them correctly. Give it some thought. Source: For five years, I was employed as the maintainer of *the* granddaddy of all modern forum software, and I've written six different custom forum packages since then, none of which were good enough to ever consider releasing. 
It's still cute that he tried, though.
Null objects are a workaround, nobody's going to make a null variant of every type of object just because it can be used in a context where returning it may be optional. Also, returning Exceptions just because something does not exist is plain silly, leave exceptions for exceptional things. In a typical statically typed language returning NULL instead of an object is as valid as returning 0 when the function is of integer type. Only PHP devs can overthink this. 
That's awesome! Excellent and useful information here.
oh... not that anyone would try that, but I think an acceptable use case for that would be to make an object and assign the array values without valid keys to `_data` property?
No.
Legend. Another question: Do you think that jumping into a framework, like Laraval, is a good way to understand how MVC applies to PHP. I have done a bit of work with Ruby on Rails and understand how MVC applies there. But I feel like its different with PHP?
Oh Gentoo, I often miss Gentoo. Mostly portage... 
I agree with most of this. I was actually looking at the insert method realizing I'm an idiot :)
Possibly they are piping the emails to a script and storing the data in a database. Just a guess.
We use it at my job. For the most part, it works well. It's definitely caught things that we should fix before that code goes live. We haven't fully integrated it into our workflow because of a few problems however: occasionally we just randomly stop getting reports, the change detection is somewhat flaky, so you can make a 1-line change to a "bad" field and your report contains every bad thing in that file, etc. Some of this is our fault (we have lots of bad legacy code), but until we get to the point where it's not giving a large number of false positives, we can't rely on it.
Is there a way to configure dependencies for the analysis? there is a way for builds, but I'm not sure about the scan. How fast do your inspections normally take? Since their team won't help me maybe you can. 
I've had the same experience. I like the service but they haven't responded to a single question.
Would you not just use a Ephemeral pool like http://www.stashphp.com/Drivers.html#ephemeral (sorry I don't know if Stash is PSR6 yet)
You wouldn't generally use PHP for *receiving* emails, you'd use an established mail server. In theory you could write the right stuff in PHP to receive email, but it'd be a massive waste of time and effort compared to just using an existing solution. To do something like 10 Minute Mail you'd have your mail server in one way or another understand what names are active right now - maybe just put active addresses in a cache for example - and check any incoming mail against the active addresses. If there's a match add the mail to the cache as well, and the user's mail page should poll your application for any mail for its address and you simply return the mail in the cache. If you wanted to use an external mail service to actually receive emails for you then you can make a catch-all mail address and use IMAP or POP3 -the two most common protocols for getting your mail from a mail server - to get at the emails and process them similar to above.
The only reason to do object literals is to have a nicer syntax than array literals. Unfortunately this just isn't possible with PHP as you can't do `{foo: 'bar'}` due to ambiguity with defined constants. Plus it doesn't solve any other problems like having to use isset all the time. You can probably make something that's slightly better than arrays like `{'foo' =&gt; 'bar'}` but what would be the point? Go big or go home IMO.
You'll probably find it easier to understand the reason a design pattern is used by looking at a simple implementation of the concept than by studying a framework. [Design patterns](https://en.wikipedia.org/wiki/Software_design_pattern) are a way of organizing code - with the exception of patterns intended to overcome language limitations, implementations will achieve the same effect across a variety of languages. Applying design patterns should make your project's code more intelligible to people - including your future-self - which becomes more important as your projects get bigger and more complex (or you find yourself wanting to reuse some code you wrote a while ago).
If there is, I haven't seen it. I'm not entirely sure how it'd work either, short of doing `composer install` at pre-analysis time. Our inspections take a good 25-30 minutes, but we have a _lot_ of code.
- Security. - Update function is an excellent example of [The most fatal PDO code](http://phpdelusions.net/pdo/lame_update) that makes your wrapper prone to SQL injection. - Another vulnerability is a slight chance of making a wrong query if your data happened to be of int type but it have to be checked against string data in database. In this case loose typing will be used with unpredictable results. - Usability. - I'd suggest to get rid of most of Query* methods and make only one that returns PDOStatement. I know it will make a leaky abstraction but it will make your class a lot more usable. With PDOStatement you will be able to get the resulting data in [**dozens** of different formats supported by PDO](http://phpdelusions.net/pdo#fetchall). - Get rid of try..catch as well. You don't do anything useful in this block, so better leave PDOException alone. - I see no point in Execute and GetType functions as well. PDO can do all this stuff already, while GetType is rather harmful. In short, this wrapper duplicates a lot of PDO functionality, at the same time making it less usable than original PDO. What one would really need from a wrapper is a simple function that accepts query and parameters, returning a statement. public static function run($sql, $args = []) { $stmt = self::instance()-&gt;prepare($sql); $stmt-&gt;execute($args); return $stmt; } From this function you can get data in any format supported by pdo, using method chaining. Like $name = DB::run("SELECT name FROM pdowrapper WHERE id=?", [$id])-&gt;fetchColumn(); $dic = DB::run("SELECT name, id FROM pdowrapper")-&gt;fetchAll(PDO::FETCH_KEY_PAIR); and so on. Speaking of helper functions like Insert, I would rather either move them into ORM (in the form of save()) or - better - implement them in the form of custom placeholder that will make your query looks like this DB::run("INSERT INTO table SET ?u", $data); But, although this method should be preferred, it probably will be too complex for you.
I'm using WooCommerce, however their plugins aren't free. I'm wanting to do things by hand as quickly and simply as possible.
The $79 to purchase a WooCommerce extension to do this for you is still your best bet. You can definitely roll your own method, but how much do you value your time? Here is the documentation you seek if you wish to do it yourself: https://docs.woothemes.com/document/payment-gateway-api/
Oh. Sorry, I had no idea you were asking for a praise, not a feedback. Good luck :)
If you're going to provide Query methods, please provide a fetchmode parameter so that other formats can be used You can even default it in the function definition to your preferred, just give the flexibility :)
ehhh I think I'll just stick with Doctrine, `composer require doctrine/migrations` done and done
Perhaps a callback would be better?
Oh no. It is not about being a dick. It's about a pride that was badly hurt :)
Hey, I know you from stackexchange, if I remember right, you've contributed a ton over there, nice to see you here. In this case, I think part of it is that Paul rubs people the wrong way.
You can achieve this kind of interface with a big switch statement in your class's magic __get and __set methods. For example: &lt;?php class Foo { private $x = ''; private $y = ''; public function __get($name) { switch ($name) { case 'x': return explode(':', $this-&gt;x)[1]; break; case 'y': return strtoupper($this-&gt;y); break; case default: throw new InvalidArgumentException("Unknown property '{$name}'"); } } public function __set($name, $value) { switch ($name) { case 'x': $this-&gt;x = 'blah:' . $value; break; case 'y': $this-&gt;y = $value; break; case default: throw new InvalidArgumentException("Unknown property '{$name}'"); } } } $foo = new Foo; $foo-&gt;x = 'testing'; echo $foo-&gt;x;
Note that PHP5 FPM from the official Debian repositories and PHP7 FPM from Dotdeb conflict with eachother, so you can't have both installed at the same time. If you use libapache (why would you?) you might be OK.
As someone who has had to deploy credit card processing and the headaches around PCI compliance for a cheapskate boss who cared more about not spending 2.9% of sales on credit card processing fees than about the amount of time or effort it would take to set it up, definitely don't roll your own. It's more trouble than it's worth. (He did all that just so we could get Interchange Pricing Plus from Authorize.net, which costs 0.10% + $0.30 per transaction.)
In case you will brace yourself and make yourself open to an argument: - A database layer should know nothing of the data origin and quality. All it's job is to perform a query safely. Any query with any data. A developer that starts picking on data sources whether they "safe" or "unsafe" makes his first step to disaster. - helper methods are good thing in general. But either way they have to be based on a main query method that returns PDOstatement. Say, `queryOne` should be like this queryOne($sql, array $parameters = null){ return $this-&gt;queryParams($sql, $parameters)-&gt;fetchColumn(); } - in its current form try-catch is useless. you are bypassing an exception and $error variable is not used anywhere. So in effect you just mute errors. - it is not PDO can detect types but Mysql can accept almost any data as strings. Simple `$pdo-&gt;execute($parameters)` will do all right. While detection magic is evil and should be avoided. - Honestly, PDO is friendly if you know it. Like many others, you are just reinventing the wheel, rewriting PDO functionality that already exisxts. - insert and update functions are good only as long as your idea of SQL is very basic. While simple SQL `NOW()` function make you a lot of headaches, followed by new wheels reinvented. Then a keyword like IGNORE follows the same pattern, then a function with a parameter like inet_aton() and so on. This is why custom placeholder is preferred, but only few people can grasp the idea, so, this insult is not personal. 
Turns out I could just `apt-get install php7.0-fpm` and it installed cleanly alongside PHP 5 :)
You are right, it's *technically* not using Laravel's migrations outside of Laravel, but in practise it accomplishes the exact same thing because you get to use Laravel's schema builder outside the framework. It just uses Phinx to do that instead of Artisan commands.
Which is good, but much much simpler then the rest of what you need to do...
If you have completely transparent public get and set methods that don't do anything special, why do you need getters and setters?
It failed then and would fail now because the proposal was far too complicated.
There was a time when they answered me. Before they changed their licenses. But since then, I haven't received a single answer. I thought that was because I'm still on the $19 old license they removed, but looks like it's not this. I wanted to know what I could do on my side to improve the security analysis, I'm still waiting for an answer. But I know they are still working, since they added support for PHP 7, and fixed their SSL cert on Firefox.
The other way works fine though (PHP 5 from Dotdeb, PHP 7 from Debian). I'm running that right now. 
Erm No... The reason for object literals is that object implementations to my knowledge take less resources, and definitely less key-strokes; it's that simple for me. Right now we would either use an array, or make an stdClass instance and assign properties to it (probably using JSON for either case). For some people, sometimes, type safety is irrelevant, and by using a defined object you can shoot yourself in the foot. In fact, 50% of my work, type safety is irrelevant, and in the other 50%, probably 50% does not need strict typing, or objects. To implement them simply has no benefit, either because of vendors having unstable or constantly changing, or because owners constantly swap vendors. In-fact to your processor, type-safety is largely irrelevant. I Get that most people that write PHP now have never written anything in any other language, certainly not many in low-level languages, but types are largely inferred by the parsers and compilers you use. They are a construct to help us program systems where we can address ever more fine and specialist use-cases; which is fine for production software, as it needs stability, maintainability, etc. I'm just stating that IMHO when proving a concept, the code will often be dirty as F#** anyway. This would hopefully not make it into apps in the wild, but it would be hell-a useful in speeding up PoC (Proof of concept) work, where currently PHP arrays are used, and then supplemented with objects, down the line. Using this syntax, we could replace the object definition (largely static to prove use-cases), and replace with an instantiation of a class, and add type checking, interfaces etc, but the calls to the data can stay the same. technically we can even test methods on the stdClass, although at the point it's more than a struct, and access params; i'd largely agree it's ready for a formal class definition. In any case largely great points from everyone and as I mentioned in the initial post, I'm unlikely to do much with this as I'm stretched pretty thin as it is (hence looking for language features to fit my use-case).
I'm not sure if there's any other way to do this in code igniter. The way I usually do it is create methods which build complex page-parts return these as string then pass them by array to their parent view. Which basically means you're constantly concatting html strings. Works well though ✌🏻️
Funny enough I [asked this on Stack Overflow](http://stackoverflow.com/questions/7473739/creating-a-database-generated-menu-on-every-page-in-codeigniter) a long time ago. As explained there, you need to create a `MY_Controller.php` that extends the default controller. Add a method in there that takes the view name and the data, then do what you like with it. If you want to apply something to certain views only you can add a switch in there for those views, and in the default case just call through to `$this-&gt;load-&gt;view()`
Scrutinizer is a good product, but if you don't feel comfortable with it and the situation lingers you can always try an alternative product, such as Codacy - https://codacy.com/ - (I can assure you your feedback and questions will not go unanswered).
This feels familiar, wasn't this article already posted here recently?
Thanks. Gonna test this on a server and hope not to break anything. Fun shall be had.
I shared this project for the first time in this very subreddit, some 2 years ago, while it was still called "damnit". Some 5 million packagist downloads later it's still going strong, in great part thanks to the help of one the project's early contributors, [denis-sokolov](https://github.com/denis-sokolov), who I can't praise enough. I've been working on a redesign of the error page for quite a while, and it's been recently released, along with some other goodies and bug fixes.
This is the first package I include in any project! Love it. Thanks for all the work ye put into it.
How does dotdob compare to Debian backports?
If I'm not mistaken the design has changed a little, mainly titles are smaller (which is great). What else has changed? I can't find a changelog. And btw thanks for this great package!
Why do people keep recommending to start with C and C++? You should suggest languages in which people can progress quicker and get real results. By starting with C/C++, you'll only get frustrated and most likely stop learning. If your main goal is to make websites, you will not enjoy reading about pointers and all that crap Starting with PHP or any other language doesn't mean you'll write terrible code, and starting with C++ will not make you a good programmer
Our code base is large as well, we are seeing 15~ minutes. I have been trying to determine if that was a norm for static analysis tools and our size. AS for the dependency, not a great sign, we have a lot of false positives from our dependencies. 
Extend the core in you app side, extend the view and add a callback to check for whatever you want to include, then in your my_controller add it into the construct so any page under that controller does the menu logic, and then the view extension will add that obj/variable into your view scope.. though what I do in CodeIgniter is simply this: $this-&gt;data = whatever. I can add/extend that in construct, or methods and can start from the parent construct without overriding the core or anything. each view gets that $this-&gt;data. $this-&gt;data-&gt;items, $this-&gt;data-&gt;header, $this-&gt;data-&gt;footer etc..
Whoops is cool. Nice.
I cannot see a change log between 1.x and 2.0. Do you have a list of new features?
Much better indeed! I think it would be good to include a small changelog (even if it's just to say that only the design changed, for example by adding those 2 links), that helps a lot to upgrade.
Awesome. Congrats on the release. We've used this in Bolt since basically day one, I believe. The PR for v 2.0 is in: https://github.com/bolt/bolt/pull/4728
Why don't you just consistently name your methods?
Yes, you'll need to worry about PCI compliance. The point of redirects (or hosted payment pages, really) is to limit your PCI scope. Basically, you don't want to have yourself in a position where you receive or store full credit card details. If you use a hosted payment page, you can design it to look like a page on your site, but it will actually be housed on your processor's server. Customers input their info directly into that form, but the data is transmitted to and secured by your processor, not you. 
Absolutely agree with everything you've written Paul. I hope this gets thrown out of the RFC process as inappropriate.
Have fun in Miami, everyone. (Last time I went there, I nearly got killed by three different drivers in the span of a day. I will never go back.)
Software (and this includes FOSS) should be as much political as it should be religious. Not at all. It's sad to see how stuff like this messes with healthy structures like open source projects where the community members personal opinions on politics or lifestyle don't matter. And I really don't see a problem in the PHP community with not being welcome or similar. 
I read this blog post 3 times and I still don't see where the problem with a CoC is. Does the argument really boil down to "I don't support social justice and I don't want to be held accountable for that viewpoint!"? It sure sounds like it.
Just as an FYI, it's considered spam to post your own blog, /u/pmjones, but given the topic, I think this should stand :) Personally, while I don't agree with everything (much) of what you've written, as I have explicitly stated, I do _not_ support using the Contributor Covenant for the PHP project, so we agree on that much at least. I also agree mostly on your list of project channels but I'm not sure what you mean by: &gt; perhaps even all php.net email accounts Do you simply mean any email sent/received using our php.net email accounts, or anywhere you advertise it as a means of contacting you. For example, if I start a neo-nazi website (which I wouldn't, to be clear :P), and put "Contact me on davey@php.net if you want to discuss this" in the footer, where does that fit? What if I put it in my contact me slide at the start/end presentation? I _certainly_ don't want every conversation I have in any context to be considered under a CoC, I'd be out on my ear within minutes I'm sure — but that doesn't mean I don't want an appropriate, and appropriately applied, and enforced set of guidelines that could be called a CoC. I think that it's entirely possible for someone to harass you, here, on Twitter, via phone, email, and many other avenues about your opinion on this, or any other PHP project related stance you may hold that they disagree with, and there should be a way for the project to remove people if they are doing those things.
&gt; I read this blog post 3 times and I still don't see where the problem with a CoC is. Does the argument really boil down to "I don't support social justice and I don't want to be held accountable for that viewpoint!"? It sure sounds like it. Say someone is bigoted with offensive opinions (say, he's against gay marriage). But he's also professional, makes awesome features on PHP, and is never off-topic or offensive within the project. How does banning him from contributing improves the project? How is it the project mantainer's responsability to check what people are saying outside the project?
1. What constitutes "professional"? If you choose to discuss work and personal things in the same medium (eg: Twitter) then I think the line becomes extremely blurry. 2. I don't think it is the project maintainers job to do background checks, but it is their job to respond to notices given when someone is offended by a contributor.
Would it work properly with ... Wordpress? 
Professional is someone who acts professionally. If someone has never disrespected anyone inside the project boundaries (github, mailing lists, forums, etc), then the project contributors have no business snooping through their personal social accounts to see if they oppose gay marriage, for example. While I have very strong opinions in favor of same-sex marriage, I will defend everyone's right to oppose it and to raise discussion on that matter.
&gt; Injecting politics into [open source] is simply divisive and destructive. I don't agree with this statement as an absolute. Choosing to willfully ignore complaints about an abusive contributor can also be divisive and destructive. 
Sorry not at a workstation but I think __set/__get is only called when a property is non-default (defined at runtime)
&gt;Furthermore a meritocracy can only be maintained if all people are ensured a safe working environment. I must dismiss that out of hand. There's no evidence that the PHP community or project isn't a "safe working environment", or that the merit of anyone's work is being dismissed because of factors about them outside of their control (what's between their legs, what colour their skin is, what gender they identify with). It's neither here nor there to make that point. So far all I've seen in support of this CoC RFC is completely unsubstantiated and vague claims of "harassment" and "death threats". It's crybullying, through and through.
I agree this is totally something that could be caught with a linter, but I prefer the readability of direct property access. Also in giant code bases you want to give peoe some flexibility or more time will just be spent on busy work, not just building stuff
The ONLY solution to a crappy code base it give people more tools to make it even worse ;) You have a point, but I like to think that this feature would give people less flexibility with naming (which always goes wrong) but still let them write code they have in their head
I'm simply asking for any case where someone has been called out in the PHP community for harassment, or any case where harassment looks to be occurring. I don't think it's unreasonable to demand that before taking action. It's not exposing the victim to any harm. If anything, it's rallying support for them and exposing an abuser. But I suspect that'll never happen because the PHP community and project is made up almost exclusively of *good people*. I also think that pro-CoC people need to find a different poster girl than Randi Harper. I've avoided speaking about her at all for two reasons. The first is that Anthony seems to be friends with her, and I don't want to damage my friendship with him over this. The second is that I *fear* her. She has demonstrated time and again that she's willing to ruin lives for shits and giggles. One need only type her name into Google to see that. I fear that simply speaking her name in a negative tone is going to have a cadre of crybullies rain harassment down on me. I don't have any sympathy for her, and I'm not aware of anything that's happened to her that I would consider harassment. Certainly nothing that supports enacting a CoC. I also disagree that there's wide support for CoCs in the open source community. There is simply a push right now by highly political interest groups to shove them down our throats, so that they can gain political power with teeth.
In the various discussions around the CoC I've read, none of the alternatives seem to address how to prevent or strongly discourage a contributor from engaging in abusive behavior outside of official channels. Surely there's *some* mechanism that can discourage political activism without also allowing obviously abusive behavior outside of "official channels".
I suppose your one negative experience(which relates nothing to SunshinePHP) should be relevant to every other person's potential experience.
Isn't one of the main points of the rebuttals precisely the fact that it shouldn't even be PHP's job to worry about this? It's outside of their realm of jurisdiction. If you are harassed on Twitter, take it up with Twitter. If you are harassed in person, contact your local law enforcement. Also, how would you EVER prevent harassment outside of official channels. Do you know how easy it is to register a throw-away e-mail address or Twitter handle? What are people going to do? Harass others from their work related e-mail address? Of course not. They are going to harass anonymously anyways, so you wouldn't even know who to ban.
I imagine the litmus-test as: "Are the contents of the links, and the profligacy of the user's submissions, something which would be also appropriate as as long-form text-submissions in this subreddit?" 
If you don't agree with codes of conduct that's cool, but there's no need for ad hominem attacks on Contributor Covenant's author. Argue the merits and stick to the facts.
What a relief to hear such a voice of sanity out of this stampede.
&gt; but it is their job to respond to notices given when someone is offended by a contributor. Really? There needs to be a task force within PHP specifically for the purpose of responding when someone *feels* offended for any reason?
Have you read the other side of the "freebsdgirl"'s story? At all? She has a history of abusive comments and harassment herself. I'm sorry but I have to take everything she says with a tablespoon of salt.
That's valid, but I think it feeds too much to the "oh no big bad SJWs are coming to steal my cheese" conspiracy theory echo chamber. I hate that it's come to the point where technology projects need a contract that boils down to "be nice to each other", but it's necessary. I'm not on the internals list and I don't contribute to PHP itself. I've got no dog in this, but I think the RFC has merit and could lead to better future collaboration.
If you haven't built out the SMS integration [Catapult](http://ap.bandwidth.com/?utm_medium=social&amp;utm_source=reddit&amp;utm_campaign=dtolb&amp;utm_content=_) is a good competitor to Twilio. It's cheaper and still a growing part of Bandwidth.com (the company that helps power Google Voice and Twilio as well)
I couldn't agree with you more, Paul. Furthermore, the whole Code of Conduct thing is embarrassing and damages the respectability of PHP developers. We don't need "Don't be a dick" spelled out for us. We're not so infantile that we need to defer moral responsibility to a document. It introduces a very slippery slope. Sure, no one wants sexual harassment or personal attacks, but it won't stop there. The list of offenses is mostly nebulous: &gt; * The use of sexualized language or imagery Who defines what sexualized means? Sex is very subjective. Sometimes a cigar is just a cigar. &gt; * Personal attacks Personal attacks could mean anything, including all rules that follow. One man's personal attack is another's heated discourse. &gt; * Trolling or insulting/derogatory comments Are we so thin-skinned that we can't ignore childish behavior? &gt; * Public or private harassment There are [actual laws](http://www.criminaldefenselawyer.com/resources/federal-stalking-and-harassment-laws.htm) for this in the US and I'm sure abroad. &gt; * Publishing other's private information, such as physical or electronic addresses, without explicit permission If doxing isn't illegal, it should be. It doesn't need to be explicitly stated. &gt; * Other unethical or unprofessional conduct Who gets do decide what is unethical or unprofessional? **This can and will be abused.**
The way I see it, the entire CoC / online protection / online harassment debate can be voided with [this tweet](https://twitter.com/rickygervais/status/687342197809754113).
I think it's important to clarify that when people are talking about something being "political" in this context, they're saying that the issue at hand is mired in current global political controversy. It's indicating that one should keep in mind when having this discussion that, while we should assume good faith, we should also assume that everyone has an ulterior motive behind what they're putting forth. Having such a motive isn't a bad thing necessarily, but it does contaminate the discussion such that it's no longer simply about what's said outright, but also about what's happening on a larger political scale. An example less steeped in vitriol would be, when we have discussions these days about how we're going to improve PHP, there's an overtone of "How is what we're doing going to reflect on us in relation to the efforts of many to push PHP to a more 'engineered' form?" There is a divide among many that has one side wishing for PHP to be Ruby-esque, in that it's intended to be a relatively simplistic general purpose language used with more regard for getting shit done than getting shit done *well* (which is not an insult at all). The other side wants something more like Java, in that the language would move towards being more considerately designed for enterprise usage - less simplistic, more formal and opinionated. Neither of these sides is necessarily wrong in wanting what they want, but they want different things, and they have significantly different ideas about how to get there. This matter colours the discussions had when we look to make changes and plan for the future.
You make valid points Paul, but I can't help but see the irony in you attacking someone for using PHP as a vehicle for politics.
How's that for a summary? Tl;dr: What's considered offending is arbitrarily defined by the person who's offended.
I don't expect this to be approved. It doesnt match with the push toward changing PHP to support more complex abstractions and redundant syntax.
Fair enough.
&gt; but it's necessary Prove it. What makes it necessary? We are all adults and we don't need a "code of conduct" to act professionally in software projects.
I don't think a coc should be so vague, that one needs to do research about the authors political views to understand it, in the first place.. 
Thank you.
Seems like Person A should just ignore it? It's Twitter.
Live in FL - can confirm Miami is absolute shit. Also - the hotel Sunshine PHP was at last year was smack dab in the middle of the ghetto, with shitty confusing streets and way too many overpasses. I have solemnly vowed to never return to that horrific hell hole.
Me: "Uh-huh, Uh-huh, Uh-huh... Oh, his first citation is *esr*." Nope. No thanks. Now, as a commie pinko, I know that my opinions are suspect, but you're not winning me over by quoting esr. Or rms, for that matter. That being said, yeah, codes of conduct are stupid. We don't need *prior restraint* to police the social space. We just let normal socialization take care of it: be an asshole, get ostracized, apologize, seek re-integration. Pretty simple. Binding codes of conduct create a forgiveness-free and polarizing world where people who make poor decisions are ejected and never get to learn their lesson or make amends. They are anti-social in the same way that talking about Wendy Carlos's genitals-at-birth is anti-social. **Especially** because the current issue of polarization is caused by the easy-insulation that the Global Internet has given us. Groups can spin off and self-reinforce their ideologies to the point of rejection of society as a whole, and assault upon it. We need less of that. We're all stumbling towards the future, and telling everyone to be an angel or be ejected from the group isn't helping us get there together. And, to be clear: neither is rejecting people from the group because they aren't like you. (Though I haven't really seen that, myself, because "people who program" implicitly have a strong relation.) (Epilogue: But, then, I'm over 40, so maybe I'm just more sanguine about all of this than the emotionally-unregulated twentysomethings that work on OSS stuff these days. Y'all need to regulate your ritalin dosage. Srsly.) 
I'm really hesitating to get involved in this but I did read the blog post and was particularly struck by: &gt; So, when is a project participant not representing the project? The answer appears to be “never.” as, if so, that suggested that the RFC, whose basic principles seem reasonable, was over-reaching badly. So in the end I actually read the RFC and I think you're wrong there as the RFC section on "Examples" makes the scope clear. It also leaves me thinking that "Opalgate" would fall outwith the RFC as if, as she says: &gt; Elia Schito is publicly calling trans people out for "not accepting reality" on Twitter there is no suggestion that Elia was doing so in any context relating to Opal and the RFC has a section "Activities on a social network" which explicitly refers to Twitter and appears to me to make it clear that in this context the RFC would not apply. 
I can't believe this is really happening. I thought I was safe from this bullshit in this subreddit. 
If that's the case, why do official communications require policing? You can just as easily call the police about a threatening internals email, or commit message right? I just don't see the point if that's the case.
You could, and if you feel that it's a legitimate threat, you should. You could and should also alert individuals of influence in the project about the matter, and they could and would deal with it appropriately.
Maybe I misunderstood the question. PHP has literal array syntax (`['a' =&gt; 'b']`), but I thought that OP was asking about literal object syntax with property assignment. Which Python definitely does not have out of the box (as my comment demonstrated).
Would be nice to get a email error handler, and maybe a production one too that just displays a generic message for an end user.
You know that simply is not true 100% of the time. Is it true most of the time? Of course. Programmers are people, though. Not robots. Some people are dicks. Dicks should be ostracized.
I've made a point of keeping my distance from this one. TBH I'm still not sure how I plan to vote on this. I guess I'd better take a closer look....
&gt; In my opinion, NULL has a well defined meaning (not set / no value). It doesn't mean "I don't know" Unless you're dealing with [3-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic). An example of this is access control, where a value of TRUE will immediately grant you access (author of content), a value of FALSE will immediately deny you access (anonymous users accessing protected resources), and a NULL value will signal that you don't care about the current access request, and let someone else handle it.
Is it too late for me to join and vote? Or what's the process involved?
Create a smtp server with reactPHP ( https://github.com/SAM-IT/react-smtp ) and when you receive a message insert to your database... but i preffer nodeJS to create smtp server. You can also use mailgun and others services to do this. 
Anyone used frameworks (Laravel, Symfony, Slim, etc.) AND WP Rest (2.x) who could compare the workflow (and relative sanity) of building APIs with one or another ?
It's disheartening to see a post like this from a prominent member of the community. The [awesine-django github post](https://archive.is/dgilk#selection-731.0-733.0) was rather blatant trolling. The [purge the bigots article](http://www.slate.com/articles/news_and_politics/frame_game/2014/04/brendan_eich_quits_mozilla_let_s_purge_all_the_antigay_donors_to_prop_8.html) was satire from a writer who [argued against vilifying Prop 8 supporters](http://www.slate.com/blogs/saletan/2014/03/07/gay_marriage_and_religious_freedom_don_t_stereotype_the_christian_wedding.html). Noticeably absent is any text from the code of conduct and ideas on how to improve it.
Authoritarians everywhere.
Yea, if I wanted to hear this sort of stuff I'd go get a frappuccino with my 16 year old sister.
lol /r/php is a bunch of dicks sometimes, shoutout to those that actually pointed him in the right direction on how more modern php is written even though most of those responses are kind of vague
The only point to be made here is that this is off topic discussion and should be moved off the RFC system.
That's pretty much how being offended by something works. 
&gt; To where would it apply? PHP internals? Any project that adopted it? Who would (or could) police such a thing anyway? It's all in the link: https://wiki.php.net/rfc/adopt-code-of-conduct#process_for_reported_incidents Basically it applies when you are representing PHP (i.e. on php.net, at a conference talking about PHP, or on social media talking about PHP: &gt;For example, merely having “PHP contributor” in an about or bio is not enough to be “representing the project”. However, a conversation about the PHP project itself (including RFCs, etc) is enough to justify “representation”. It's an elected group of 5 people, and 4 out of 5 have to agree for there to be any 'consequences' to someones behavior.
Right. The title is misleading.
I completely agree that a sane set of guidelines is necessary for "Do X, Y, or Z and you can be dealt with from 'your contributions to the project will no longer be accepted' up to and including being banned from the official project communication forums" But a few paragraphs does not a legal document make. The main point of confusion is in the ambiguity of the proposed CoC. Where does the jurisdiction begin and end? What prevents the judgement of those being removed from the project from becoming an industry blacklist? What does "other unethical or otherwise unprofessional" mean and who determines unethical/unprofessional? There is no ethics board in software. What does "fairly" mean in the application of the CoC? What does "ban" mean in the context of a CoC applied to the project, does it mean rejecting direct contributions to `php-src`, does it mean legal action when trying to act as a representative of the PHP project if even possible? And most crucially what does "respect" mean? Is it an implementation of the ridiculous "Yes, and..." policy where criticism is disallowed? It's just so vague. There is so much room for misinterpretation, misapplication, and abuse. The FreeBSD CoC (https://www.freebsd.org/internal/code-of-conduct.html) is less vague but still leaves tons of room for misinterpretation such as the same ambiguity of words like "ban", "expulsion", "community", and "bullying"
Unfortunately my OpenCart installs are so mangled with shoddy plugins and hacks I don't think I will ever be able to upgrade.
&gt; Software is Binary, it either works or it does not. &gt; People are not binary. Didn't you see??? There's a "Reasonable Person Test" for that! /s
http://www.techchattr.com/never-use-opencart
Heh, seems to happen quite a bit online. I remember back when lots of my friends were using IRC socially, quite a few of the girls had a nick ending with "girl" or "chick". And those that didn't, usually had something that still made it pretty obvious. Must be something to do with being a minority in that place or something, which I can understand. More basic things set you apart, so less imagination is required in coming up with a unique username. Not as many guys seem to do it. But then again, we quite often use the name of character/actor/musician etc, which does unintentionally denote our sex anyway, as I have here. 
The fact that you think this works, offends me. So could you please stop thinking that it works? 
In a project I've been working on recently (which isn't ready for use yet), I've aimed to prevent directory traversal attacks by simply rejecting any path that has two consecutive dots in it ('..'). Is that sufficient? What else could people try?
LOL.
&gt; So basically they can be like human. IT isn't special, I highly suggest you avoid sales or corporate management if you think this is bad. &gt; Yes, and it's awful. But we don't work in sales or corporate management so writing a draft about that would be silly.
I had to deal with open cart once. Hol-ee-balls I never thought I'd find a project that would make me feel bad for shitting on WordPress all these years.
Just my 2 cents worth, while I don't agree with the way he has handled these issues. I do hope security researchers are not just posting directly to GitHub's Issue Tracker without giving the devs a chance to fix and release. If they do then (thumbsup) to the professionals.
My main objection is that the title doesn't match the article, I would have been genuinely interested in your post had you been using Laravel Migrations outside of the Laravel framework. However you are not, so perhaps a title a long the line of "How to use laravels schema builder with phinx" may have been more appropriate. 
they really often contact opencart maintainer via private line, but mostly get that kind of response or the proposed solution implemented without contribution
I shit on wp. That terrifies me. I've seen this come up more than once and each time I'm like WTF? How did this project become popular?
&gt; without giving the devs a chance to fix and release. [it was not ignored dick head why lie! are you a professional or not? professionals don't need to lie to prove a point they use facts!](https://github.com/opencart/opencart/issues/1534)
I've been using dotdeb for a number of years. It tends to track the upstream PHP/MySQL/whatever releases quite closely - so you generally keep up to date better - and has had more/different extensions (e.g. php5-pinba). However, I have had some issues when upgrading Debian release in the past. Usually fixable by removing $package and reinstalling.... (files moving from one package to another for example). And a few months ago, there was a Wheezy security update to PHP which outnumbered dotdebs and left things kind of broken, so you probably want to add an apt-pinning rule just to be safe ... (See http://codepoets.co.uk/2015/dotdeb-apt-package-pinning/ ) 
yes imo it should be the last resort to post it publicly, especially when the devs are hostile towards the reporter.
Not that I know of.... the best is if there's a conflict defined in the package, so installing FooBar would trigger the removal of FooRah. 
There are magic get and set functions. You could have a private "properties" array, so the get/set functions are automatically called if they are defined. This would certainly be a nice change though.
&gt; Kind of missing the point. That is tit for tat and just as childish and unprofessional. The CoC should be second nature as a contributor. If people are not wanting to contribute due to reasons, they need to be sorted. If your partner is being negative or stressed, do you mirror the actions/emotions? No, I would hope not. You wouldn't accept that behaviour. It is the same here, it should not be accepted behaviour. I am not missing the point, I am pointing out that this is pretty much the response of the community. Especially with the CoC, if you're nasty to someone then we'll gang up and be nasty to you by not letting you play. &gt; Thats great, but its to inform the people that might do so, something like "join our community, but these are the rules and consequences" is good for everyone, whether you will break the rules or not. There already are rules for php.net, no? &gt; To say that you are not bothered and that it is a silly thing and not needed is not a reason against and further proves it is needed. Why does my apathy on this matter prove it's needed? I don't get how me not caring about something that doesn't affect me proves that it's needed. &gt; I don't think any more is needed to be said, we are not going to agree that a certain attitude required. The PHP League have a CoC and it seems to work really well. A great sub community of PHP. Has it been enforced or are you suggesting that mere presence of it makes life better?
&gt; How did this project become popular? Can't speak to OC specifically, but I've found that, in general, the "worse is better" principle seems to apply with PHP projects that hit a certain critical mass. Most seem to be projects that eschew most 'best practices' from a security and maintainability standpoint and which allow for end users to do a lot of 'copy/paste hacking' (vs a more structured approach - perhaps OO and enforced separation of concerns). It seems the more times typing 'global' is allowed or even encouraged throughout the platform, the more popular it may become (it's not a requirement, of course). Specifically in the case of OC, I suspect having dozens of payment gateways prominently on the front page (and 888 'payment gateway' extensions in the marketplace) is a big reason why people might choose it. Whether or not it's any good, or there's any good security practices behind these... that's probably immaterial to most people. In fact, many end users, and even some devs I speak with, seem to be confused that someone would be offering something (especially for sale) that's known to be bad. "Wait, they're charging $79 for this plugin, of course it's going to do what it says". Well... nope, that's really not always the case.
I am a bit surprised Laravel comes out on top. I've heard of Laravel being popular, but I've never worked at a place where it was talked about as a viable option for developing. I should probably learn my way around Laravel at some point, but last time I looked in to it, it felt like there was too much magic in the homestead tutorial for my tastes
Ok so I also tested the code /u/betterphpguy wrote. Since the root of the problem is coming from [array_fill_keys](http://php.net/manual/en/function.array-fill-keys.php) I checked its documentation. I chuckled at the [top comment](http://i.imgur.com/y7ewvMl.jpg) &gt; now string key "1" become an integer value 1, be careful.
I think if we paid for PHP and it was a business I could understand some 'rules'; in the interest of customer satisfaction etc. But open source contributors are volunteers. There's no obligation for them to be 'nice' people. There's no obligation for people to be good. They just have to be not-illegal. If someone feels their personal rights are under threat from people on the internet they should contact their local authorities. If the law doesn't help them, then it's up to real politicians to decide how to change that.
Homestead is not laravel, it's a vagrant box. Laravel is mostly popular amongst small sized companies &amp; startups, and bigger businesses tends to favor Symfony (probably because it's very Java-inspired). However, I wouldn't take this survey too seriously, it's a bunch of WTF, like Phpixie being ten times more popular than silex, or what in earth is Nette ??? :)
Why is this a video? Why not just link to php's [vastly superior documentation](http://php.net/manual/en/function.define.php)?
Kudos to whoever (scott?) registered a new user just to let them know. Daniel absolutely doesn't get that people are trying to be helpful.
When I started my current job we were using Scrutinizer. It _was_ a great product and definitely helped, although in the last 6 months we noticed it would begin to take extremely long times to complete analyses, fail set up steps every so often and support waiting times increased from a couple of hours to a couple of days. I'd highly recommend going for something like [CodeShip](http://codeship.com) for CI + a suite of products for things like coverage, quality etc. That way you can switch things up a bit easier if one of these services goes bad.
At the moment we are just looking for some analysis to improve our code base. Would love to find another tool though at this point. 
Consider not having getters and setters
&gt; I don't get why people even need to share their race / gender online You might need to sign a contributor agreement to contribute to some projects, with your legal name, which might reveal both. You might want to use a personal photo as your avatar on Stack Overflow or Github or whatnot. You might want your real name on your Github so you can include it with job applications. You might've used the nickname since you were in middle school and not want to change your online identity just because there are assholes on the internet. You might be using sites that require a Facebook connection to create an account. etc. etc. etc.
I promise that it wasn't me.
&gt; What I am saying, is the reporter should give the dev a chance to fix and patch a vulnerability before a PoC is developed and released. This is just responsible disclosure. No. [**Responsible disclosure** is wrong](https://adamcaudill.com/2015/11/19/responsible-disclosure-is-wrong/). Call it coordinated disclosure.
&gt; There's no obligation for them to be 'nice' people. There's no obligation for people to be good. Correct. But the rest of the group has no obligation to listen to it either. https://xkcd.com/1357/ and all...
I mean [this about says it all](https://archive.is/ODXfo) as far as how the CoC would be used. Object to a CoC supporter's opinion? aBUsIvE
Late reply, but just reading this now, Bootsnipp has snippets of Bootstrap code and a form builder, might not do everything you are looking for, but should save some time. http://bootsnipp.com/forms
&gt; If that doesn't work, post it and move on. I think that's what was done? I gather sarciszewski didn't post on github but he posted the issue none-the-less. Might have been nice if sarciszewski posted on github.com but it looks like sarciszewski [has had prior dealings with him](https://github.com/opencart/opencart/pull/1594) as well and they haven't been very productive so I totally don't blame him for not posting again.
In my limited interactions with the Wordpress devs I've found them to be friendly enough. They're encumbered by trying to maintain backwards compatibility with an increasingly dated code base but I don't think there's a good solution to that either. I don't think the WordPress devs deserve the shit that they get. OpenCart on the other hand... the guy's brought this shit onto himself.
[removed]
I said nothing of the devs, sure they're nice people and even excellent coders. I was referring to the product, in the case of wordpress it's a product of it's evolution, in the case of opencart it's a product of the owner being a tool.
Oh ok. I can agree with that!
Or, you can view it as Laravel being so popular that all of the beginner PHP devs flocking to it and asking silly questions. I have a feeling you're a little off. Seasoned programmers rarely often ask questions on forums.
&gt; small sized companies &amp; startups thats because laravel 4 (the first really viable version for businesses) was only released ~2.5 years ago... not enough time for most medium sized places to be using it as their products would have already been set in stone before it was released
&gt; "... Oh, his first citation is esr." Nope. No thanks. Now, as a commie pinko, I know that my opinions are suspect, but you're not winning me over by quoting esr. (/me grins) For my part, as an over-40 small-l libertarian, if that's your major complaint with the article, then I think I can consider that a "win." ;-) More to the point, Ehmke is responding to ESR, so it seemed reasonable to link to the thing-being-responded-to. Agree with everything else you said there, in particular: "We don't need prior restraint to police the social space. We just let normal socialization take care of it." Me agreeing with a commie! Dogs and cats, living together!
Is Daniel Kerr an alcoholic, or just that careless with what he types out?
Most big companies in my city are slowly moving to Laravel. Rapid development = $$$
Do you think market share = the amount of people who responded to a Sitepoint poll ? that's totally irrelevant.
Right, I'm seeing that trend too and its a good thing. 
i spend about 3 minutes looking at the code: 1) the first thing i noticed is quite some use of @ for error suppression https://github.com/datto/php-json-rpc/blob/master/src/Server.php#L62 https://github.com/datto/php-json-rpc/blob/master/src/Server.php#L147 https://github.com/datto/php-json-rpc/blob/master/src/Server.php#L153 (theres more) 2) not sure why you'd do validation within an exception, also rather than doing this huge or chain, you might want to consider using in_array. https://github.com/datto/php-json-rpc/blob/master/src/Exception/Application.php#L144 3) there is an abundance of static methods - often even when there is no reason to have it static https://github.com/datto/php-json-rpc/blob/master/src/Server.php#L276 edit: for nicer formatting
He's careless with the code he writes too, it appears.
From where I stand, both Raymond and Ehmke are fucking nutjobs and in a culture of meritocracy, would both *shut the hell up*. It's always the least sensible voices that are the loudest. ...George Bernard Shaw opined that "The Unreasonable Man is the source of all progress" but I'd suggest that he `s/progress/change/`, because sometimes it's regression that the Unreasonable seek.
Why don't people band together to write a better open source PHP cart? One that is object oriented with proper extension methods... and doesn't rely on a CMS (like Wordpress) to run.
The best rebuttal and challenge to this whole CoC movement I've read so far is the recent blog post by /u/pmjones. Looking through the related stories, and the internals emails, both sides will never come to a compromise. One side wants to attach everything that a person does everywhere, anywhere, anytime to the project. The other side, which I think is absolutely reasonable when it comes to technical/code-related projects, does not. I've always thought (and probably always will) that contributions to (open source) projects are viewed and reviewed without consideration of the contributor. The only basis for accepting the contribution are its project-related technical merits. That withdrawal email is written in a way like he's taking the moral high ground, and as /u/pmjones noted, more kafkatraps.
After what Ive seen on twitter, internals and IRC, Im just disappointed. Not in the adoption of the RFC, cause it wasnt at all in a decent state, but because of how everyone reacted. Not to name names, but people on both sides were slinging insults on internals, twitter and IRC. And these are some people Ive looked up to since getting into PHP. These are the people I learn from, and to see civility break down like it did makes me question if I want to truly be involved anymore. Everyone needs to grow up, and understand the world isnt as black and white as you make it, but there are tons of grey areas. 
Growing up also means knowing the right places for the right kind of things, eg. report real-life harassment to the proper authorities, or learn to accept that opposing views/opinions exist on matters you're passionate about, and the correctness and normal vary from culture to culture, people to people, etc.
Been running it on several production servers for months (built with laravel's forge service) and haven't had any issues.
Exactly. I keep seeing people who were in favor of the CoC on twitter literally saying that people opposed to it, and caused it to fail, are evil. The vitriol is just incredible. 
I am very disappointed in the leaders of this community. You have lost the vision of providing a stable server side software package. If it were up to me, the lot of you participating in needless ranting would be all written up for unprofessional behaviour. I'm quite disgusted with the conduct over this. Given the fact that I have literally spent my entire professional career working with PHP, I am beyond angry with your actions of late. If I could switch software packages I likely would. There is a time and a place to have these discussions, over social media is not one of them. I 100% guarantee if we locked the lot of you into a room and told you to not come out until you had an agreement there would have been 100% less childishness.
I see they also advertise on their home page the fact they came in 3rd on sitepoint's survey as well. If it was intentional to do this, it was very scummy of them.
I agree, but it's even more regrettable that the vitriolic anti-CoC people essentially got what they wanted. They may have looked bad, but they essentially "won" the argument. I wish there had been a neutral arbitrator that could have taken the role of the stereotypical pissed-off judge: "I want you two to work this out. Don't come back here and force me to make a ruling on this, because I guarantee you what I say won't make either of you happy."
Hoo-fucking-ra. Now you can focus your energy on something that matters.
While I agree that shitslinging on twitter is just about the opposite of professional, this was a pretty big deal that could have done a *lot* more harm to the PHP project / organization / community if left unchecked. Guaranteed it would have been used to selectively punish people that fell out of favor or disagreed with more prominent members, or to "take someone down a peg."
&gt; I've looked into using Doctrine2 before, but was not able to use them due to some complex joins (read: bad decisions) that I've since started to correct. Custom Doctrine Repository abstracts all this for you. Use DQL where you can, and if you have some crazy nastiness due to some insane sql query, Doctrine lets you grab the underlying connection and execute whatever queries you need (until you don't need them anymore). Not saying Doctrine2 is or isn't the right solution, but you can always get at the connection if you need to do something sketchy, I wouldn't let that hold you back. &gt; I've been following quite a few DDD model presentations, and in theory they all sound great. In practice, they are a pain to implement--but I may be going at them the wrong way I've found with Domain Models and Unit Tests, if it's tough to implement (within reason), I'm probably doing it wrong. It's usually a code smell for me. "Oh man, this really isn't super friendly to use, time to step back and reassess". 
You know, stuff.
And `~/.ssh/id_rsa`
Like Magento? Or Prestashop? 
&gt; The more objections I see, the more I feel the nature of the objections actually justifies the Covenant And this, my dear son, is called a kafkatrap. Use the opposition against your proposal to justify your proposal.
Edit: So I don't cause any conflict, what are you using if you aren't using Eloquent or Doctrine?
[removed]
Oh the irony of having to clarify this when discussing a code of conduct…
Consider generating passphrases (made of N words from a pool of M, where log2( M^N ) &gt; 128; for example [10 diceware words](http://world.std.com/~reinhold/diceware.wordlist.asc)).
It did, and I agree. Both sides need to grow up 
Note that he is one of the core devs for Debian. I trust his work and consider it stable for production.
I know this thread is a few weeks old, but I've been using Nusphere's phpEd since mid 2006. I'll admit I don't use a ton of the editor like features that I should, but it's been really solid for a long time.
Running several 14.04 LTS + php7 + MariaDB10.1 combos, one of them hosting Wordpress, zero issues.
Obligatory [reference](http://esr.ibiblio.org/?p=2122).
Meanwhile, Swift has the exact same CoC and they are busy writing code instead of hypothesizing that someone will kick them out of the project for an innocent comment. When was the last time someone used Swift's CoC as a weapon? 
Nice explanation!
Sorry, not trying to coin/use the term, just implying to be responsible when disclosing security issues :) you are right, it should be called coordinated disclosure (or perhaps even sensible disclosure?)
Jesus Christ, this isn't going to stop until they get their own way is it?
yes, and nothing but respect for them. Just saying to make it clear for others flying past. Not implying in any way they did the wrong thing.
In what ways is it distinctly different? They have a diversity statement and a mechanism to ban people. The wording is gentler but the effect is the same. And if we're modeling off other people, the original proposed PHP one was identical to the one in Swift. So it's not like one PHP guy came up with this horrible version himself.
Quick comment about diceware, I'd not recommend to use diceware (at least not without a warning). Diceware is a "poor design concept", as it has a mile long list of elements (almost 8000), but the quality of the elements is poor for many of them. Say, elements like "a", "aa", "!" etc. short ones doesn't really help one to memorize the outcome of a diceware passphrase, and doesn't contribute much to the length of the passphrase. Instead, I'd use a reasonable size pool of, say, "real English words" (4096 for example) which are "clearly different from each other word, orthographically or semantically" and are at least 3 characters in length. Picking (uniformly at random) 6 words from that set will result 72 bits of entropy, which should, in general, be a good passphrase.
irony is what most people think is called sarcasm
What I like about it is that it's left just vague enough to get it's point across in a way that is difficult to misconstrue and be used for political attacks. The Contributor Covenant takes a step too far and becomes more specific, but also easier to abuse. What determines an attack or harassment? Who determines what's unethical or unprofessional? These questions can, and will, be abused. With Debian's CoC it's both easier to understand and deal with troublesome individuals.
You've covered 2 separate issues: 1) MD5 is no better than plain text for storage. It's so trivial to brute force on modern hardware. It's been considered broken for 2 decades now. Stop using it already, even in examples. Why on earth would you use it when there are much better schemes available. And now we have the password library, there's no excuse at all. [Purpose built setups](http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/) can try 180 billion combinations per second against MD5 (and that was 3 years ago - you can probably do better today). Even ignoring those, the cloud and bot nets make large amounts of computing power trivially accessible. 2) Regarding entropy: See the XKCD for a brief overview, or [Explain XKCD Wiki](https://www.explainxkcd.com/wiki/index.php/936:_Password_Strength) for more detail. Why would you generate a difficult to remember, easy to crack password when you can trivially generate a much easier to remember, more difficult to crack passphrase?
I see your point, thanks for the insight. That does seem like you're leaving more to the discretion of the person(s) reviewing the complaints, which can be a blessing or a curse. 
Composer and PHPUnit. You're welcome. Next time Google.
Debian's statement also needs to be interpreted, and it's actually potentially broader in scope since it's not specific. Essentially, the two are loosely the same thing though.
http://shetterly.blogspot.com/2014/04/xkcd-doesnt-understand-free-speechor.html
https://wiki.php.net/rfc/adopt-code-of-conduct
Good answer. I think it might be useful to mention github.com though, as well. Composer kinda implies it but that it does may not be immediately obvious to someone unfamiliar with it. That said, what, exactly, should the OP have typed into Google? Correct though your answer may be I don't think Google would have been as helpful as you're implying.
&gt; Nuance Nuance is a word that doesn't get nearly enough usage in very, very many contexts these days.
This is very helpful, thank you. I am already familiar with GitHub, so I'll be okay there.
&gt; 1) **MD5 is no better than plain text for storage**. It's so trivial to brute force on modern hardware. It's been considered broken for 2 decades now. Stop using it already, even in examples. This is not true. Sure, it is true for poor passwords in practice, but for passwords which has high entropy we still today can't crack them (yes, even if it was a plain MD5 hash). It is a pure technical fact. I'm not talking about password handling best practices etc, but just technical side of things. &gt; Why would you generate a difficult to remember, easy to crack password when you can trivially generate a much easier to remember, more difficult to crack passphrase? I wouldn't (I would use a proper wordlist), but I was merely only commenting as you said "12 characters chosen from a pool of ~65 **is not very strong at all**." Which is, at least in my opinion, wrong information (if you compare it to a "regular passwords", which definitely doesn't have even near the amount of guessing entropy). 
Snide comments everywhere
Yii 1 top 10, irrelevant survey sorry.
One problem with the magic get and set methods is that although we assume people are using them to set properties, their behaviour is only defined at runtime, so people have done odd things with them. Something like: private $foo; private $bar; __set($name, $value) { $this-&gt;foo = $value; $this-&gt;bar = $value; } I guess this RFC is partly about trying to remove that ambiguity.
Your example is needlessly verbose. See my comment for a much simpler implementation that also allows much more ergonomic instantiation. I wasn't commenting on the proposal itself, just a misrepresentation of Python's core object type. Just because Python is flexible enough to build it doesn't mean Python has it built in. It's theoretically possible to build in PHP as well by passing an array into an object's constructor to get the field names. Sorry if that wasn't clear.
http://phppackagechecklist.com/ should be helpful
I gotta agree on that (sorry to anyone who acutually helped). Also I decided to nix the idea of a GitHub Organization due to the lack of interest. I'm still developing the software but under my personal account: https://github.com/nsuchy/6BB
What I'm legitimately struggling with is.. this has been the case for years. Yet there are *commonly* threads in /r/webdev a /r/ecommerce where someone asks "what ecommerce script should I use" and the most upvoted answer is "opencart".
Use Github + Composer + Packagist. Basically it is: Step 1) Put your code on Github. Step 2) Create a composer.json file for the project and put it on the root directory on the github repo Step 3) Share your package using https://packagist.org/ Step 4) Tell people that they can use your project by typing: composer require GITHUB_USERNAME/GITHUB_PROJECTNAME
&gt; Why do you hate Eloquent? Not here to discuss/argue why I like/dislike a certain library. Thanks for the suggestion though propel was the next one down the list.
Let's not invoke racism when it comes to things like police brutality. The sad fact is that unless we can demonstrate that the issue affects Joe Schmoe, it will not get fixed. If you listened to the debate on the Democratic side, you will notice that all the candidates want to control the war on drugs. Why? Because we know now that Joe Schmoe now knows that it affects their children, not just the children of minorities (or you know "those people"). I want to get rid of bad policies that hurt everyone regardless of race. I want to get rid of lack of oversight on our police because our politicians are too obsessed with making sure they get the backing from police unions. This will not happen if Joe Schmoe thinks that police brutality is a black people problem. The reality that this is a black people problem doesn't matter; Joe Schmoe has to think that this issue will affect them. We are going a little off-topic but what I want to do is not fix misogyny or racism or discrimination against gay people. What I want to do is promote better ideas in our code no matter who wrote it. If Adolf Hitler wrote a nice little library and made it free software, well there is nothing wrong with using it. On the other hand, if a person with disabilities submitted a pull request that breaks the build well then call a spade a spade and reject the pull request. This is real life. I don't want special treatment and neither should anyone else. A code of conduct does not fix misogyny and racism. How can CoC fix something that the constitution and the thirteenth amendment could not fix? Let's be reasonable here. All it really does is it makes some guilty people feel better. Well. guess what? You shouldn't let them feel better by doing this token lip service. I've said it before and I'll say it again. Fuck the tumblrinas. They've never actually felt real discrimination. They've never been asked to step aside *every time they fly* for "random" searches. They've never had their car pulled over because they're driving a Cadillac while black. I like Morgan Freeman. What he is saying isn't perfect but it is pretty close. https://youtu.be/GeixtYS-P3s 
Yes, that would work out great for people with limited liability like Alice Walton of Walmart: &gt; Walton has been involved in at least four automobile incidents, one fatal. During a 1983 Thanksgiving family reunion near Acapulco, Mexico, Walton lost control of a rented Jeep and plunged into a ravine, shattering her leg. She was airlifted out of Mexico and underwent more than two dozen surgeries; she is said to suffer lingering pain from her injuries. In an April 1989 incident, she struck and killed 50-year-old Oleta Hardin, who had stepped onto a road. Witnesses stated that Walton was speeding at the time of the accident, but no charges were filed.[18] In a 1998 incident, she was reported to have hit a gas meter while driving under the influence. She paid a $925 fine and served no jail time.[17][19] &gt; On October 7, 2011, her 62nd birthday, she was again arrested for driving while intoxicated in Weatherford, Texas, after a dinner with friends in Fort Worth. Walton's attorney released a statement acknowledging the incident and expressing regret.[20][21] The charges were dropped by Texas prosecutors in September 2013 without formal charges being filed.[22][23]
Well "brigading" was probably a strong word but clearly someone in the community publicised the vote to their users. You've probably got 90% of Nette users voting on that poll but only 5% of Symfony/Laravel users.
Wow. After reading through that RFC, the only thing I can say is.... Wow. So many policies. So many procedures. So many councils and tribunals and judgements. So much trying to account for every possible issue. And really, if someone calls some a name on twitter, you reserve the right to make the project as a whole **less complete** by removing their contributions? _What the actual fuck is this?_ 
Ignoring this completely keeps focus on providing a stable server side software package.
If you're going to self-post your content, can you at least make your content &gt;3 tiny things taken from another project's docs?
I *think* the parallel he is trying to draw is it doesn't matter what the actor believes or whatever so long as the films he makes are good. I am sure there are people out there who avoid Tom Cruise films because he is a Scientologist, which shouldn't matter as long as his films are good. Likewise it doesn't matter what the contributor thinks or feels so long as their contributions to the project are good. At least that's how I interpreted what he wrote.
I understood what he was trying to say. My comment was meant to point out the gaping flaw in the analogy and parallel being drawn.
Because that worked for Mel Gibson, his career remains successful and his movies are beloved of the people. The court of public opinion is a thing. And now that the programming field is not just a bunch of white guys, that court has come to us as well.
&gt; Unit tests aren't strictly required, but they're good practice, and especially valuable for anyone else who wants to work on your code. Personally, I won't use a package that doesn't have unit tests and at least 80% test coverage.
The Contributor Covenant's home page reads like the opening to the depths of Tumblr extreme politically correct hell. That is the problem I have with it. Any good code of conduct is fine, but the Contributor Covenant clearly does not have a neutral point of view. It was founded by groups biased with personal agendas.
Can definitely agree on personal agendas. People being harassed, abused and bullied are likely to have those. Usually, starting with "Stop".
Question: Numerically speaking, how many people does this really cover in terms of maintainers/contributors? At the end of the day, is this a legalistic fix to a problem (perceived or actual) which is social? I mean, you can have something printed a dozen times in a Company Handbook, but it won't make any difference if it's not an *unwritten* value already. (Well, it makes HR's job easier to fire people, but aside from that...)
Right, obviously he faced the wrong side of this. He pissed off people in power and, in spite of the quality of his work, he's been ostracized. 1. I feel like you're agreeing with my position 2. I was *specifically* saying that **for me**, I don't care about the actor's personality or personal life, I care about the product they produce. I obviously draw the line somewhere, if you're decapitating puppies to take puppy-blood baths, sure you can go fuck off.
Seriously should just let it die already... It should be logical that people shouldn't need a 10 pages wiki article to tell them how to behave.
Oh _please_
I feel like most of this stuff is just self-serving. "Look how much I did for the &lt;insert chosen cause&gt;, aren't I great". For me, I think most people need to just deal with the nature of humanity and that not everyone is nice to everyone, that people have different views, and not everyone will like you. Of course it would be great if everyone got along, but I don't think it's possible given the massive spectrum humanity covers. The reasons people dislike other, and the others they dislike will shift and change, but never disappear. If people want to change the world for the better, do it by being a better person yourself, and by sharing your views, not ramming them down people's throats, or enforcing them via rules. The world (or community) isn't going to get better overnight because you wrote a list of rules, as like you say, the people who would need to be reigned in by it won't care anyway. 
Conferences have their own codes of conduct these days.
Those campaigns of harassment matter as little as this code of conduct does. It's amusing that you remember those though. `:)` Good call.
Anyone who looks directly at the covenant will also have their faces melt off
i would tend to agree
I agree. I mean, I thought the RFC was a little broad, but holy shit the anger over it. And to be honest, this sort of stuff is why I never want to work as a web developer. There's jobs out there with healthier and more professional cultures, even if they don't pay nearly as well.
i never understood how that many people could be angry about participating in a language authored by a homophobe, when that particular language compiles down to javascript
There is a level of hypocrisy here, after the shameful witch hunt of Tony Marston, and the ongoing systematic downvoting of users like dracony. Perhaps we should all just attempt - in the words of bill and ted - to be excellent to each other.
The balance probably comes down to the topic of conversation more than the medium through which that conversation is happening. PHP absolutely shouldn't be regulating the general discussions that contributors have online, that's an absurd idea, but if those conversations are about PHP matters, with other PHP community members, bringing up PHP internal discussions, then there's a clear issue. The difficulty is wording a CoC that balances that well, and also maintains a clear divide between ensuring a fair and welcoming community, vs trumpeting the author's personal political beliefs. My favourite one so far is actually the Debian CoC, although that clearly would have needed some adapting to make more PHP-centric.
Eh, it seemed to me that the anti-CoC viewed any passionate argument for it as "anti-free speech" and "oppressive". I still think there's a fair argument for a CoC. The one proposed wasn't brilliant, but that doesn't mean that the alternative has to be no CoC at all. e: spelling
Debian has elections to elect a board that can make decisions on behalf of the Debian project. PHP does not. The Debian CoC can be enforced by their elected board.
Week long circlejerk on his failings, his ideas may be antiquated, but not sure that it was necessary to direct that much derision at a single person.
Not defending Daniel Kerr, but such consistent misbehaviour (a label I'm sure you'll agree with, right? RIGHT?) hints about deeper problems than your simple expectancy of politeness, wouldn't you say? His replies and _yours_ alike will further this situation. Not all people have social abilitites like you sensible and behaved lot. Whenever I hear about him, I think about how it must feel, the poor ostracized bastard. He's nasty alright, but give him a break. Also, stop using opencart ffs.
One could argue that a good IDE make the busy work trivial. 
And [node.js](https://github.com/nodejs/node/blob/master/CODE_OF_CONDUCT.md)
I imagine people are aware of past incidents in other open source projects, and the internet in general, and they wanted to be proactive instead of reactive.
In the grand scheme of things, developers (contributors, and users) are the scarce resource for open source projects (ideas). So if having a CoC results in more contributions, maybe it's worth it. But if we look under the hood of this perfectly spherical cow model, we see that open source projects are just a group of people, and they have preferences other than making the project the best of all projects. Naturally, if they wanted to just have all the developers/users, they'd start feeding them free crack cocaine in a pyramid scheme. So the question is, what would the PHP project, the users and the devs want? Users just want stable releases, nice features, better performance, and I guess they don't want to be associated with an extremist project (neither end of the spectrum is appealing for them, we can assume). Devs basically want the same thing. This reduces the CoC question to how much it would push the project toward one of the extremes. And users probably wouldn't care, because they are not really affected. So developers, developers, developers. And it seems that the issue is a polarizing one (duh), so proposing it as an RFC was actually not a bad idea, but still the consequences of adopting or rejecting it could be worse than this simple withdrawal. (Because a vote would just make the divide more transparent.) There was the case of glibc maintainer Ulrich Drepper, who was seen as rather infuriatingly stubborn, which resulted in no one really contributing to glibc, only a few must have taks were done. (Support for new syscalls, and bugfixes.) But maintaining glibc was not seen as a great thing for developers, so no one forked it (there are alternative libc implementations, sure, but those had additional goals in mind too, like smaller size, or better portability, etc.). Nowadays I don't know how developers view PHP, but I guess eventually it'll come down to getting rid of some incumbent developers who are hard to work with, but that might not mean that it's worth it from a technical quality viewpoint, as it's entirely possible, that the new and upcoming quality developers are not even interested in contributing to PHP. All in all, there is no great cognitive framework for evaluating this, other than trying to make something very fundamental (let's say Rawlsian justice) into a CoC rule book. (But then that'd seem like a bit too much activism, too much "extremity". As basically we can see in the reactions to a mere RFC proposal.)
Status appears to have changed to "reopened", author is now Derick Rethans. While I'm not against a CoC per se, this one is incredibly vague. How is "other unethical or unprofessional conduct" an "(example) of unacceptable behaviour by participants"? When the political process around CoCs is so fraught with us-and-them false dichotomies and unresolvable back-and-forth strawman shouting matches, how can you actually appoint mediators without the whole process being captive to one or the other of the two warring factions?
It sounds like people need to thicken up and stop worrying about what people say on Twitter. You can't force people to fake-nice in such a passionate industry. That said, where are all these trouble makers that are just offending people left and right?
The fact that a lot of responses here are generally against the author's suggestions, saying things like -- "null is perfectly fine" "no one's going to create a null object for every class" "I need warnings and notices to be thrown all over the place to know what I did wrong" -- makes me embarrassed to be a PHP developer in this community. 
Most of us act better than prisoners...
Not in a free society they don't. Your feelings do not deserve protections - and if someone hurts your feelings by saying something you don't like, but submits code that improves the project, we should only give a shit about the code.
Because a social movement, which is concerned very little with the communities they are invading, demands that they be able to ostracize those they don't agree with.
Used ondrej's packages in production for a long time (not just PHP7 stuff) never had an issue with any of them. 
&gt; And now that the programming field is not just a bunch of white guys Bigot.
http://code-of-merit.org/ I think something like this should be required by all open source projects and it should supersede any other CoC https://archive.is/EVWyt this a "by the book / textbook" classic cycle of bully/provoke the community into accepting the CoC then claim victim hood on twitter also known as the SJW crybully routine. I must have seen it used a hundred times already, I just want to make people aware of how it works. I wish he would have addressed the objections to the CoC instead of taking this path. Here in this example we see that passionate disagreement is converted into "attacks" in order to claim the appropriate victim status. This new victim status will now "show" that there is a real "problem" in the PHP community and will be used as evidence/proof that the a CoC is necessary and will likely be used to push a further CoC onto the community by taking advantage of the newly gained status, assuming usual method is followed. As a result everyone who doesn't know better is thinking there is actually a problem with inclusivity, which is in reality simply a passionate disagreement. That is generally how the cycle works. That's not to say this guy isn't the nicest or most well intentioned guy on the planet, he probably is. There is just a pattern to these things that has to be identified when seen. https://archive.is/50GhH
Which means we should stop having laws?
This doesn't answer the question.
I prefer unit analysis. const SECONDS_PER_HOUR = 3600; const HOURS_PER_DAY = 24; const DAYS_PER_WEEK = 7; You see, like math, you have denominators cancel out numerators if they math, and we can chain them. $secondsPerWeek = (SECONDS\_PER\_~~HOUR~~) * (~~HOURS~~ \_PER\_~~DAY~~) *(~~DAYS~~\_PER\_WEEK) 
What does that effectively do? It's not going to stop this supposed social media harassment of people, that's what I don't get. 
It defines a process, just like laws.
Is this what an ideal community looks like to you? https://github.com/nodejs/inclusivity/issues/9
Man up sport
it doesn't start out that way but you have identified the endgame effectively. It starts out as simply elevating their own comfort above the project itself under the guise of "safety" that's how they get in the door without too much fuss. But it ends like you said usually after amending or expanding or abusing one of these codes.
As soon as I see the use of the word problematic these days I know I can probably assume the following content is going to be totally inane, not disappointed here.. They cannot be serious..
Likewise! Cheers.
The proposed CoC was literally like 4 paragraphs long, it's not exactly a book
That thread has about ~50 replies where people are sharing ideas, working on a problem, and compromising on a solution. Regardless of your or my opinion on the topic, the group was working on something important to them. As is mentioned many times in that thread, the group working on the project already decided to address the issue and were simply discussing "how" to address it. Everyone who commented that they should stop caring about it was simply not acting in good faith. Sadly, you can't stop trolls on the internet and they do manage to derail many productive conversations.
i would think publishing him on sitepoint would be the deepest insult possible
i think you might have missed the joke. 1) everyone's angry because of homophobes in opal 2) opal compiles to javascript 3) brendan eich
oh for ffs are you kidding me
Also if something is happening at a conference it is pretty hard to prove to people who weren't there (the moderation team). It becomes a "he said, she said".
Oh, it gets better: &gt; *congratulations you have now gotten opencart-ce project banned from being mentioned in the opencart forums!*
There is something that can be effective when someone says that what you wrote offended them: saying sorry, then moving on. It seems that as a society we forgot that word, that we think we'll be lesser beings by merely thinking about saying it. It's not a war, there's nothing to win. At the end of the day, we all want opensource projects to succeed. That can't happen if no-one ever says sorry when they fuck up. 
&gt;So if having a CoC results in more contributions, maybe it's worth it First time I heard that one. More developers because of a CoC? Regardless if you have numbers to back that up or not, how does one come to the idea that this will occur? I don't see it happening. I don't think the reason people stay away is because there isn't a CoC, it's because they don't have the time to spare after their day job. &gt;Naturally, if they wanted to just have all the developers/users, they'd start feeding them free crack cocaine in a pyramid scheme. Something tells me that would have declining results. &gt;I guess they don't want to be associated with an extremist project (neither end of the spectrum is appealing for them, we can assume). How would we arrive at a project, any project, being considered extremist? Whether a project has a CoC or not, a person can claim whatever they want. Basically the only thing a project can do is to publicly distance them. After that, it's up to the people to interpret this. &gt;There was the case of glibc maintainer Ulrich Drepper, who was seen as rather infuriatingly stubborn, which resulted in no one really contributing to glibc, only a few must have taks were done. (Support for new syscalls, and bugfixes.) But maintaining glibc was not seen as a great thing for developers, so no one forked it (there are alternative libc implementations, sure, but those had additional goals in mind too, like smaller size, or better portability, etc.) That, I don't understand. If the maintainer of a great project turns out to be an asshole, the logical outcome would seem to fork and continue without that person. From where comes the conclusion that because that project was in such a state, a fork was not appealing? That seems completely irrational to me. I'm, not against a CoC, if it's written in such a way that it's not vague. A stubborn maintainer or developer is something you need to be able to get past. My problems with CoC's in general is their tendency to evolve in to thought police, or are overly draconian, penalizing people for using single-gender references in code comments. &gt;But then that'd seem like a bit too much activism, too much "extremity". As basically we can see in the reactions to a mere RFC proposal That's a populist statement. People didn't dislike this on the basis that they dislike any and all CoC. People complained what was written was too vague. Meaning: too open for interpretation. Meaning they feared people would be able to abuse the system.
what incidents?
Oh, I get it, you think capitals area just *better* than other letters! 
well, yeah; to be fair I did think about this after writing my pithy reply. And of course we do need to take cultural sensitivity into account.
Is this real?
That's a pretty nice concept, however I don't like the autowiring stuff, I'm against such magic involved.
Aside from your ridicule of mental health issues, which is another of those real things some people like to pretend don't exist, other real things that exist are harassment, bullying, abuse of position, etc. These have no place in an open source project under your own value proposition since they may drive away contributors which will result in reduced lines of code being output. By all means go with "hurt feelings" though. It's an understandable tactic to make all those real things look inconsequential.
&gt; That withdrawal email is written in a way like he's taking the moral high ground And sadly, another emotionally vulnerable programmer nerd has been guilt-tripped into taking it upon themselves to carry the flag the next several miles.
&gt; It seems to me that the CoC crowd viewed any passionate argument against it as "abusive" and "bigoted" K A F K A T R A P P I N G
&gt;people on both sides were slinging insults on internals, twitter and IRC. why do I never see this stuff happen? :-/
Well, what do you need to know? I just don't like this magic as I said, there is nothing more. I just prefer to be more explicit in configuration. When I come back to the project after a year I will just look at service definitions to find out what is going on instead of trying to remember that I used this bundle to make it work.
&gt; Purpose built setups can try 180 billion combinations per second against MD5 (and that was 3 years ago - you can probably do better today). 180 billion is just 37.4 bits. It would take that cluster 2^(72-37.4) = 26 billion seconds (~800 years) to crack the password. So, yeah, 12 random characters from a pool of 65 is a good password, even if hashed with md5. I would be more concerned with a good source of randomness when making a password generator. Using rand() as a source of randomness would undermine password security greatly.
Just stop.
How to stop using Laravel?
&gt; they don't want to be associated with an extremist project (neither end of the spectrum is appealing for them, we can assume) What do you mean with "an extremist project", and what ends of what spectrum?
Brendan Eich is a homophobe, because he didn't want gay marriage? How is that connected?
And rust and node and Go... But just have a close look at the process how the CoC was accepted there. In all those projects the discussion was forcefully shut down and the anti side shamelessly silenced. If that's a sign of things to come, there will be a lot of surprises and injustices.
What's unprofessional about a passionate discussion?
Yes, exactly. I tend not to get into long drawn out discussions, so sometimes the point I'm trying to make gets missed. Personally, I live in the US and work in IT, so my idea of professional means I treat everyone with the same base level of respect. It's the way I was raised and what is socially expected of me.
First example I found with one second of Googling: [boobs or gfto](http://lindseykuper.livejournal.com/418854.html)
Not sure why the down votes. I'm exactly the same. If your package doesn't have substantial unit test coverage you have absolutely no idea whether small, seemingly insignificant, changes are breaking someone else’s use case. Unit tests aren't an absolute guarantee against that, but they're a bloody good start.
Hardly any convicted murderers or rapists are part of the core php team...
"Moore in the cloud" With VM instances that have more power than before, PHP7 with vastly improved performance, off-loading of processing to the client with JS reactive frameworks, is it time to scale down the cloud ? As in what we did 3 years ago with a load balancer, a varnish cache, 3 front-ends, a master-slave MySQL setup for a popular website (1 million pages/day), can we now scale down to a single VPS ? Dissert and test ! 
PSR-6 made the decision that it didn't want to provide any implementations, even if they were trivial. As a result, even exception definitions **are actually interfaces** and the cache InvalidArgumentException doesn't actually extend (or have any relationship to) the PHP \InvalidArgumentException! My personally opinion was that removing trivial implementations (such as exceptions and null objects) is solving a problem that doesn't even exist - but it is what it is. If you need a PSR-6 null object, I suggest you use the [php-cache/void-adapter](https://github.com/php-cache/void-adapter). 
It's not. It's just preference. I do think a lot of people's controllers are probably too big, but I think this is erring too far in the other direction. My rule of thumb is to create a controller around one resource and if I have to start adding methods outside of the typical resource verbs (get, create, update, delete) I know the controller is getting too large.
Controllers extending the abstract Controller class are classes: * with hided dependencies (because they use directly the service container) * coupled to the framework (so hard to reuse) * hard to unit test (because of the first 2 points) This bundle fixes all those points. Having one action (and not necessary one route) per class is not mandatory (the bundle work even if you have several actions per class). It's just promoted. It encourages to create shorter classes (it's always better) and reduces the risk of creating complex objects breaking the SRP and having a lot of dependencies.
You're right. That's why those classes are called "actions" in the bundle and not "controllers" (it's also a reference to the Action Domain Responder pattern). The goal is to transform this "glue" to a reusable set of middlewares.
My example is not a strawman - my example is explaining how fucking little I care about your personality if you can contribute good code.
My suggestion to any new developers is to use MySQL Workbench. This package assumes you know how to do a lot of environment configuration. Like setting up a vhost with local access only. W/o it anyone on your local intranet can access the remote sql editor and do whatever they want to your DB... which is a really bad thing.
[removed]
Easy, just hard code and return`spanish-inquisition` because nobody expects that to be the password.
Abuse of power always starts out small.
Tom Cruise bounced back in his career by deliberately lampooning himself. And he did so after losing his closest friends, his wife, and his kid.
You are correct, but now days every desktop application converting into web application. So, i thought why not i made an web application that can have same functions as desktop remote SQL e.g Heidi SQL, MYSQL Workbench etc. 
I want to make sure that I fully understand your position before I say for sure that I disagree with it. It seems from your allegory that you're arguing that "if a person's output is good, then their personality isn't relevant". If that's true, then yes I firmly disagree with you. When I worked for an online publication in New York for three years, the CTO headed our team, and he was very smart and taught me many things. But he also insisted that his employees come to the bar several nights a week after work, where he would get belligerently drunk on whiskey and start wrestling matches and/or get in our faces like he was going to beat the shit out of us. He would make remarks to his female employees about their bodies and the way they dressed. And *lo and behold*, after three complaints of this behavior (albeit outside of the workplace) to HR he was fired, no matter the fact that he basically architected our technology initiatives from the ground up. The work environment was extremely hostile to us coders, and most of us were too afraid of disagreeing with him to contribute intellectually to any project. And this is why I don't collaborate in open source projects. Because there's no system in place for firing a contributor when he's breaking harassment laws. And yes indeed, an open source collaboration *should* be considered a workplace, even if it's a volunteer workplace, so harassment laws should apply. Edit: It occurred to me that I should add that in the past those who have argued to me what you seem to be arguing (pending verification) are arguing it on the basis that policies against harassment result in the loss of good personnel, and a reduction in the quality of the project. But allowing harassment in the workplace results in a much greater loss of good personnel, and much more reduction in the quality of the project. Those who create hostile work environments hide behind "free expression", but hostile environments generate more censorship than non-hostile ones. Environments like the PHP collaboration can't even get a full measure of how much better it would function without that kind of conduct, because it never *has* functioned without that kind of conduct. And now, due to this RFC being shut down, it will continue under that status quo.
Because not being a man is a bad thing..?
I've used this approach some times and it really helps. The only concern i have is that solving each item, step by step, may lead you to write procedural code.
One time too many.
Well I know that the act of receiving emails is not PHP. However, I want to interact with the emails with code. Now, what language would you suggest so that I can interact with them? Im not trying to make a mail server using php, i just want to be able to interact with them. So my thoughts with a "catch-all" email was that. asdf@123.com and fdas@123.com both get sent to the catch-all, but maintain who it is supposed to go to. Now I want a user (asdf) to be able to access asdf@123.com. I do NOT want to set up an email account for each person. These need to be burned 10 min after creation, and who knows how many I'll need running at a time. 
Probably a better approach: private methods driven development public function doTheThing() { $this-&gt;doThe(); $this-&gt;damn(); $this-&gt;thing(); } Then implement each of those methods. Leads to much cleaner and expressive code ;-)