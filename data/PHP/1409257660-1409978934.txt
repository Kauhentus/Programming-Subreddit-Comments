As well, for all except line 6/7, you should really use str_replace instead.
Looking at Webtatic, I don't think they've built/released 5.6.0 GA yet (still 5.6RC4). I've never like the Webtatic packages, opting instead for [Remi's](http://rpms.famillecollet.com/) packages. He's always on top of new releases, and package quality is excellent.
 $regex = ["/r1/", "/r2/", "/r3/"]; $replacement = ["a", "b", "c"]; $value = preg_replace($regex, $replacement, $value); Boom
It took a long time for FB to get to the point where building their own JIT to run their code became necessary... so, no, they are not say "should never have been built with php".
Thanks for your help
I couldn't do that due to the "|" scenario. Unless I just don't understand how str_replace works. 
 $value=str_replace(['BASEH','ECONH',PRM1H','PRM2H','PPO3H','PPO4H','ENHAN','BASE'], "H", $value);
True. For me it depends on what is the easiest to understand, what performs the best, and what has the least chance of breaking over time. On many occasions I have had developers send me a 3 page SQL query and I broke it down into 3 or more simple queries and combined them in PHP. That is preferable for easy of understanding. I don't know about you but when I come back to code I wrote 6 months ago it is as if a stranger wrote it. So I make things real easy to understand. For performance I will break the ease of understanding rule. But honestly simplicity *usually* brings performance with it. The only exceptions are bulk inserts, those usually require some complexity/finess. And for huge datasets you usually don't get many options, you have to do what you have to do to fit it into memory. And for reliability, I tend to bring things into PHP to check if a value is null, or to validate anything that could have been entered by a user. I suppose this can all be done in SQL but it tends to really hurt the SQL queries readability. If I wrote it, and it fails because a time format is incorrect (for example) then its on my head. I don't blame a developer for having an incorrect value in the database, I validate anything that could cause my code to fail. 
Thanks
You should, whenever possible, use str_replace. str_replace is faster than doing regex replacements, along with reducing complexity when it may not be needed. 
If you are submitting 300 rows (must be a hell of a form) that is not a use case for storing JSON in a database. JSON in a database is usually a case where you have a very dynamic schema. And if I am storing JSON I use something built for it like postgres. I guess the rule I use is that if the data is not relational I use JSON. But thinking about it I have used JSON for performance as well. JSON performance is much better than a bunch of EAV tables. For cases where I need to insert 300 rows I build a temp table and do my inserts into that. Then in one line of SQL I insert my temp table into the table.
I'm afraid not: that's PHP 7 (formerly known as phpng). I wouldn't expect to see a stable PHP 7 release for a while yet.
For Ubuntu users (and Debian) Just upgraded my docker build deb scripts for PHP 5.6 (not much of a change, some file download URL flips :D ). https://github.com/magnetikonline/dockerbuilddeb First thing noted, nice and sexy new phpinfo(); :D 
We've just launched PHP 5.6 support for servers managed by ServerPilot. You can switch an app to 5.6 through the app details "change runtime" option shown here: https://serverpilot.io/community/articles/how-to-change-php-version-from-5.5-to-5.6.html
I've talked with the core maintainers of Hack/HHVM and seen non-PHPers ask them why they didn't rewrite it in "insert talking heads favorite language." They always just kind of give them a dumb look and smirk, calmly asking them if they'd rewrite 10 million LOC or instead, hire the smartest people in the world to rewrite a compiler. PHP requires Hack to compete at scale which 99% of businesses will never encounter. There are _hundreds of thousands_ of companies who are profitable and have done so with scaling hundreds of servers running PHP on the backend.
Well the optional parameters using the 5.6 variadics don't have keys, just indexes. So they're not really what you'd want. If you want to take in an array of key-values as a parameter like in your example, you can then use [extract](http://php.net/manual/en/function.extract.php) to turn them into induvidual variables.
It *can* be similar. In one mode, Remi has repos for 5.6, 5.5 and 5.4. The packages *replace* the existing standard `php` package for the system. In the other mode, it uses the ["software collection" mechanism](https://www.softwarecollections.org/en/) to provide side packages with unique names, like webtatic does. You then use the software collection tool to switch which packages are the "real" active PHP.
I think you missed "open source projects". Most of these have to support the most common lowest denominator, i.e. the lower "sane" version to run in production. Most of them target 5.3 for now, I hope this gets bumped to 5.4. 5.5 is too much of a stretch for now.
Didn't know [NumberFormatter](http://php.net/manual/en/class.numberformatter.php) was a thing. Neat!
Symfony 2.3; runs really quick even in dev mode on a fusion VM.
&gt; you can then use extract Don't encourage extracting! Leave them in the 'array'!
I have a Stable (master), Testing, and Unstable branch for my projects. Features make their way through the latter all the way to the former in various stages. Unstable is for experimental things like a new router I'm building for a client's blog which will hopefully be more efficient than my current router. Once I feel it's safe enough, I bring it to Testing where I have a PHPUnit rig going on alongside the code's intended implementation. So I will eventually drop the router into testing, and it will be tested alongside the blog it's a part of using dummy data. Finally, when testing finishes up, I do QA (double check PSR and PHPDoc stuff), and schedule a maintenance window to merge and tag the version. Oh, and outside libraries are kept up to snuff with Composer. I like the simplicity of my workflow, but it would not do for a multi-man workplace. Version control would need to be tighter and such. Still, it works for me and that's what counts.
What you're describing is exactly concrete5. They also have excellent multilingual support (i18n support for many languages via transifex), and starting with 5.7, symfony2 support makes web services (especially setting up their routes) much more practical. c5 sets pages up as a collection of 'attributes' (specific to the page), 'areas' (regions on the page where you can put:), 'blocks' which contain the actual content. You can make blocks specific to one page, or part of a 'stack' that can exist on many pages. If you're starting out with it, I recommend beginning with the beta version 5.7. It's going to be pretty unstable, but it's much prettier, and as mentioned the symfony2 support will change your development approach significantly. If you need to push something out in the next month, you may need to use the latest stable. It's still good, but 5.7 is great. http://www.concrete5.org/get-started
[The current highest-voted comment in the thread](/r/PHP/comments/2et8ew/php_56_released/ck2w80r) is a glowing endorsement of a language in 2014 with all the verbosity and all the concurrency support of Java 1. Java itself got threads in 1.2, btw. You tell me, is that what PHP's trying to become?
Damned by faint praise.
yea, its part of [`ext-intl`](http://pecl.php.net/package/intl)
&gt; You tell me, is that what PHP's trying to become Honestly, we don't know what php is trying to become. We just want to fit in with all the cool kids..so we are sort of imitating blindly what others are doing...
As a wordpress dev, I still have to code for 5.2.x. :-(
I'm with you - nothing wrong with having a nicer looking status page. It's welcome here :)
Maybe they're on shared hosting? 
Consider me humbled! **[Thank you Squiz](http://i.imgur.com/tPByL3O.jpg)** for creating and maintaining one of **the** two essential PHP tools. PHP_CodeSniffer is one of those great tools that you set up then don't have to tinker with for a long time. Every year or so when I go back in to tinker I recall "oh ya.. that weird parallel error-level thing" :) I figured the reasoning behind it had to be either some legacy feature and/or "I just don't get it". Obviously with a huge user base, not something to change willy-nilly. After spending the good part of the day piecing together some sensible comment sniffs I needed some venting. reading /r/phphelp posts.. it's hard not to yell out loud - "lesson #1. use PHP_CodeSniffer!"
somewhat related... make sure you don't need word boundaries in there ie, something like `$value=preg_replace("/\b(FE|FSA)\b/", "NMED", $value);` which will result in "FEY FE AFE " -&gt; "FEY NMED AFE" rather than "NMEDY NMED ANMED" 
psst. he was showing off [variadic arguments](http://php.net/manual/en/functions.arguments.php#functions.variable-arg-list)
But...but...you can get a VPS for $5/mo! Why not switch?
example $id = 1; $args = ['name' =&gt; 'John', 'age' =&gt; 30]; function example($id, $args) { echo "User: {$id}&lt;br&gt;"; if (isset($args['name'])) { echo "Name: {$args['name']}&lt;br&gt;"; } if (isset($args['age'])) { echo "Age: {$args['age']}&lt;br&gt;"; } }
Are you supporting my statement with an example, or are you trying to counter-argue by suggesting it's slightly more verbose?
Yep, just the same as for example RedHat releases [security fixes](https://rhn.redhat.com/errata/rhel-server-errata.html) for even the ancient PHP 5.1
Well yeah, obviously. I don't use shared either, but for some people it is still more practical than figuring out sysadmin stuff or having to mess with it.
I think you are just salty for some reason.
I agree with you, however it has enough overlapping features that I would feel happy not using it in favor of Symfony components.
Some people have to fight with infrastucture :(
I'm struggling to see the benefits of LTS these days. At some point you have to upgrade, why put it off for 5 years? It just makes it harder when the time comes.
I don't think it'll really suit this project. This isn't a normal website with content and pages. It's a single page website for a design agency that went mental with all of the transitions and page loads. Having a CMS which you edit from the fontend is not really an option here I think.
Disclosure here, I'm one of the contributors, but have you checked out Bolt? You can either define mutliple html fields for each content page, or alternatively you can join multiple other content items to a main page. Not sure if this is what you're looking for but I've done some fairly similar complex things. Shout either here or on IRC #boltcms if you'd like some help.
Why 83?
0 in front of a number = octal So 0123 (octal) = 83 (decimal) Source: http://stackoverflow.com/a/1412725/2847035
Thank you, that seems very useful! Posting my own autoloader has really taught me a lot about some very useful PHP features that I didn't know before.
Perhaps some confusion as using quotes in array keys doesn't work. E.g. echo "$arr['test']$arr['foo']"; However you can wrap these in braces and it does work: echo "{$arr['test']}{$arr['foo']}"; 
How fast is 5.6 compared to 5.2? or other versions?
You should not be passing $_POST values straight into a SQL statement, this a big problem - lookup SQL injection. You should also not be using the mysql_ set of functions. Take a look at the mysqli functionality: http://php.net/manual/en/book.mysqli.php Finally - have a look at PDO and prepared statements, this is a much better way of working as it fixes your SQL injection problem and has a lot of other benefits too. The learning curve might seem steep if you're starting out but you'll be a better coder for getting your head around it.
5.6 should exhibit the same performance as 5.5. Maybe marginally faster. But of course 5.5 is a lot faster and more memory efficient than 5.2.
Well... one advantage which comes to my mind is that you spend less time of your work upgrading. Also Canonical is trying to focus on stability of the packages instead of features.
Stability and security are the benefits of the "LTS" (or similar long supported version slike RedHat offers). For example, looking at Ubuntu 12.04 LTS, there has been 22 different security vulnerabilities fixed in the lifetime of 12.04 (up until now). Ubuntu 12.04 was released in April 2012. But if you look at the amount of security vulnerabilities there has been on PHP since the April 2012, the amount is _much_ higher than 22 vulnerabilities. Meaning if you would have kept updated all the time, you would have been much more exposed by the bugs there has been in the new versions. This means if you keep on the latest versions all the time, you are exposing more room for bugs/security vulnerabilities. I.e. a security bug in a new feature which was added in PHP 5.4 doesn't affect 5.3. That said, this is sort of an two edged sword. Maybe one would be good to host his "non security critical" app on PHP 5.6 system (at the time being), but he would never host his "security critical" app on the latest PHP version, instead he would at this time go with 5.3/5.4 (or maybe even 5.5). And besides security, stability also can matter. No BC breaks and no other bugs caused by new features/new code. Some (PHP) applications may have been designed to run for the next 5 years, and LTS versions gives a good foundation for it.
lol
wat
Interesting. Do you happen to have resources where I can learn more about this and how to implement it? I'm sorry but I'm new in the handling of servers. Webtatic worked just fine for me, but /u/paranoidelephpant made me doubt
And sometimes you run it in a loop?
And sometimes you run it in a loop?
And sometimes you run it in a loop?
Because that's what your host provides or you have a plugin/theme that you want the widest distribution possible?
If they are paranoid, why are they using a version which will no longer get updates?
And by "a lot" I've heard people see 200% improvements in performance. 
RedHat will "support" it (basically security and "critical" fixes)... until 2023. Why use the distribution? Updates are seamless, setting auto-updates are usually safe because compatibility is a very big concern. PHP 5.3 in 2023... please convince your admin to upgrade to RHEL7 before then. 
I am feeling very, very skeptical.. &gt;The ever elusive monad in easy steps.. OK. [Slides from the author](https://www.simonholywell.com/static/slides/2014-02-12/) Not anything new or ground breaking there, (there is even one that says php functions are referentially transparent, not sure I get that right though).... Also, functional programming done in php may result in code with poor readability. Real functional languages provide other supporting structures, (like algebraic data types) that you can use to express your program with much more clarity. Not sure if that is possible with php. So there may not be much point in trying to do all those stuff in php.. I don't have much idea about FP anyway.so I may be wrong...
And I think you're suffering from Stockholm Syndrome.
For someone who …"[doesn’t] have much idea about FP” thats a little too skeptical. 
&gt; When you do a startup, here's what matters (on the tech side) &gt; &gt; * Is your team efficient? &gt; * Can you fix bugs quickly &gt; * Can you create new features quickly A different one I've heard: 1. Make it go 2. Make it right 3. Make it fast Vanilla PHP makes the first step retardedly easy compared to other languages. HHVM is working on the other end. HHVM will probably reach the middle first.
A competent Python programmer would be meticulously correct about whitespace and clarity, so you ain't one.
Here's the [Hydrator](https://github.com/mvc5/framework/blob/master/src/Service/Config/Hydrator/Hydrator.php). Here is a sample container [configuration](https://github.com/mvc5/application/blob/master/config/service.php). They're intended to be serializable value objects used when resolving the dependencies of a service as it is being created. The Hydrator class has a name and an array of calls, a Service class has a name and an array of args, both are child classes of the main service [config](https://github.com/mvc5/framework/blob/master/src/Service/Config/ConfigInterface.php) class which has both args and calls.
I enjoyed the history of PHP you gave in your earlier slide-deck; I noticed a lot of the same things, hence why I avoided PHP wherever possible up until 5.3. I do find that there's still a lot left in the Zend engine that's quite functional-unfriendly, one of which being the hefty overhead for function calls themselves. HHVM solves much of this, as will PHPNG I hope, but my point is there's still quite a bit in the engine that is evidence of PHP's FP unfriendly roots. One more thing I've never cared for with PHP is its sloppy and inconsistent set of array functions. Being able to simply `myvar.map()` in ruby, or the Collections that hacklang uses, is really handy. The whole `array_map($callback, $array)` vs `array_walk($array, $callback)` is a constant source of annoyance. I admire anyone looking to apply a paradigm that's unpopular to a particular language. I'm still not completely convinced that FP in PHP is a great idea, but you do make a compelling case that we're at least heading in a direction where FP in PHP is becoming more feasible.
Do you just code Wordpress? 
Enlighten us if you believe what he said is incorrect
There are plenty of single-page themes for concrete5. I've written a couple myself - you can either just use one big page, or you can put each section into its own page, then write a block that displays all the content of its sub-pages beneath it. Single page sites haven't been new and hip in a long while.
&gt; I never told that I am one True; you sound more of a VBScript person.
I put effort into something I like and want to improve, you seem to put effort into bashing something that you seem to not like or use anyways. Not sure what's the point in that.
It's not a single page theme, it's far more complicated then that. To give you an idea of the complexity I'm dealing with, the agency had to provide designs in the form of *video*, as their requirements could not be expressed in simple PSDs. It looks closer to a mobile app than a standard website, which is why the frontend needs to be pure Angular and the backend needs to stay out of the way and just deal with editing content. Drupal 8 would work for this as it has web services built into the core and you can use entity references to build up the content incrementally but the admin interface was never designed to do that, which makes the user experience appalling.
You can start building solid stuff in e.g. Go after a few days. Maybe worth the investment? http://blog.iron.io/2013/03/how-we-went-from-30-servers-to-2-go.html
If you're convinced it's really that complex, then I don't see why you'd look for a CMS anyway. It sounds like what you want is just a good framework to build your web application on. symfony or laravel.
Yeah, honestly I appreciate the suggestion and I would have no issue on 99.9999% of builds but this is the exception. As for Laravel I would love to use that but we need to sell it to the client and my manager has outright told me that they won't accept something like that. We've told the client how it's going to be if they force us to take this route. They are also proposing ModX to their internal client on Monday which does allow for nested content and templates. I guess that's all I can do for now. Thank you for your help.
Then as soon as you are done with this project, i would suggest giving this a good read: http://www.phptherightway.com/ It is very current and can help guide you on how to prevent common mistakes like in the code above. If any parts of it do not make sense to you, ask for help or explanations!
Its actually just a configured Bash (4.1) The font is ["Source Code Pro"](https://www.google.com/fonts/specimen/Source+Code+Pro) (I use "Source Code Pro Light" size 13 on my 27" iMac). If you're curious, my [**dotfiles** are on GitHub](https://github.com/Rican7/dotfiles).
The [repos are here](http://rpms.famillecollet.com/), which has a link to the [repo config instructions](http://blog.famillecollet.com/pages/Config-en) and a [FAQ](http://blog.famillecollet.com/pages/English-FAQ). Announcements are made on the [blog](http://blog.famillecollet.com/).
Cool stuff. I just finished watching the Laracasts episodes. I'm not using PHP that much anymore but here's a question: there are many ways of doing the same thing on Laravel 4.3. How much impact will these changes have on maintainability? Just imagine a cenario where you received two new codebases, one using 4.2 and the other 4.3. It's not your code, but you need to figure it out things. Did I got the wrong impression about this?
&gt; "I am a shitty programmer. We don’t worry about warnings; we only worry about errors." FTFY
I like the changes apart from the structure change and all of the namespacing everywhere. These videos say "Laravel knows where the controller namespace is" - I thought it would do it behind the scenes somehow, rather than have yet another config file.
Thanks!
Blame PSR-4, I guess?
I was thinking this exact thing. 
Relax, it's a joke.
Great suggestion, I just pushed an update that documents a bunch of the possible methods, I hope it's helpful.
I'm more exited about the new DI feature that can resolve dependencies in a lot of new places like controller methods.
I agree with you, they should've been there. Now that they are there, I'm excited about it. **Terrible Analogy Below:** If you were under paid and then got a raise to industry average, wouldn't you be excited/happy?
I've moved to one action per controller, not as a hard rule, but just as a goal. In actuality, I'll often have two, eg renderForm and handleForm. When your controllers are this specific, I don't think injecting services into the constructor is as much overhead.
I'm sure there are a ton of people, my boss for one, who have been upset that Laravel didn't insist on namespacing before.
Fair enough. I'd have probably left the job because I knew I could do better. :D
Yeah not saying it's a bad thing that it's been updated to that, just that since it wasn't used before, seems a lot more cluttered now and a bit more "hacky" - my opinion anyway.
so where do you put your other methods, like index, view, etc?
Something along the lines of this for a crudish endpoint Route::get('/products', 'Baileylo\Shop\Controllers\Product\View@viewList'); // list is a reserved word in PHP Route::get('/products/{product}', 'Baileylo\Shop\Controllers\Product\View@viewOne'); Route::post('/products/{product}/update', 'Baileylo\Shop\Controllers\Product\Edit@handle'); Route::get('/products/{product}/update', 'Baileylo\Shop\Controllers\Product\Edit@view'); Route::post('/products/{product}/create', 'Baileylo\Shop\Controllers\Product\Create@handle'); Route::get('/products/{product}/create', 'Baileylo\Shop\Controllers\Product\Create@view');
Nice..I can see that you had fun. How much time did it take?
The initial prototype took one night at a bar (about 5 hours). That compiled with no optimizations. Using just the AST. It was fragile, but it was FAST. Then I rewrote it to use a graph. That took about a week of off and on development (prob 20 hours in total). Then I built optimizations for it (about another 20 hours). And then I refactored, cleaned, and prepped for release. So I've got about 50-60 hours into it so far.
You can get seamless updates from 3rd party repos, of course if you're really paranoid you wouldn't trust them and you'd compile them from source ;)
That's why I prefer using a VPS or handing it off to the deployment team with a "Requires PHP 5.4" in the Readme
Interesting, kinda like ultra-skinny controllers, sounds a bit strange tho, separating your controller up like that, just because of the DI overhead, why not use Facades?
Do you have plans to continue this and make it a full fledged compiler that supports more of the PHP language, or is it a one-off hobby project?
I love PHPUnit's integration in PhpStorm. Does it integrate nicely with Codeception as well?
all languages has its downsides `Array.prototype.forEach.call(arrayLike, function () { ...` I'm truly expecting that `[1, 2, 3] instanceof Traversable == true` for now I'll keep my hope, maybe one day..
Sounds like you're using [ADR](https://github.com/pmjones/mvc-refinement) - which can be a very good thing.
1. How are calls to php library functions done? On a one-by-one basis. Strlen is compiled as an operation (so not a function call). Others are planned to be implemented on a case-by-case basis (with some sort of generic call mechanism for a fallback). This is because it's very inefficient to convert from native types to PHP types just to call a function that's going to do the opposite... 2. Can my compiled functions refer other un-compiled user defined functions? Yes. They become compiled functions. I am planning on adding support for calling arbitrary userland functions without needing to compile them, but for now, no. 3. How are these represented in the IR form? As their own IR. This is one are that needs to be revisited. 4. Will it be something like a .so file? Well, we can output an IR today, and do the final compilation at runtime. But eventually we were talking about doing either a .so or elf file which could be brought in directly... 5. Also, what are some real life situations where something like this can be used? Today? Math. It can execute math algorithms FAST. So things like crypto (implemented in PHP) could be make extremely fast. In the future? Who knows. The sky is the limit...
Exactly where I got the idea. I've worked on projects whose controllers become thousands and thousands of lines. I don't think you need to subscribe to a 1 controller one action philosophy, but you need to think about your code.
My company still uses a legacy asp codebase to do this because there is a tool, asppdf, that does the job wonderfully. If you find a solid solution, please update.
Could somebody explain the benefits of namespacing absolutely everything as opposed to how it was before? Because now it just seems like more of a pain in the ass.
Thank you for your work
Don't tell him to relax
PHP written in PHP. Reminds me of nimrod
I hate this attitude. Just for comparisons sake, where may I view your open source contributions so I can shit on them even though you've put them out for the world to use?
For fuck's sake, use a [DOM Parser](http://php.net/manual/en/class.domdocument.php)
Those are the benefits I'm struggling to see. Of course it's more secure, and more stable, but what is the definition of "more" and how does it stack up against the pain of running old software and the significant effort required to update 3 or 5 year old systems and not break anything? I guess I'm a dev, slowly moving into the ops world, and from what I see rolling updates is the way to go. Sure you risk breaking things, opening security holes, but these risks exist anyway. You might as well concentrate on reacting to them rather than minimizing them.
I shall inform infrastructure they are no longer required :|
I do too :\ My CTO is in charge of that stuff at my job, but if I nag him enough it eventually gets done.
That's weird. That's a lot of burden for the OS developers to maintain 3rd party packages...
Don't tell me what to do
Is it possible to cache Recki compiled code, to avoid having to recompile it on every request?
Unless I missed it, there doesn't appear to be a mention of classes in the documentation. Are they compilable?
Plugins and themes. Gotta work with WordPress' min req of 5.2.4 or risk breaking a huge [chunk](http://wordpress.org/about/stats/) of user websites.
I use Silex for my side projects. And C# for my "lazy programmer" tools
&gt; Also, functional programming done in php may result in code with poor readability From the slides: &lt;?php $data = array(1,2,3,4,5,6,7,8,9,10); function get_algorithm($rand_seed_fnc) { return (odd_even($rand_seed_fnc())) ? function($value) { return $value * $value; } : function ($value) use ($rand_seed_func) { return ($value * $value) / $rand_seed_fnc()) + 10 } ; } function odd_even($value) { return ($value % 2 == 0); } $rand_seed_fnc = function() { return rand(); }; $results = array_map(get_algorithm($rand_seed_fnc), $data) First I want to ask this? *WHY* would you name a function, `odd_even`? Why not just `is_even`? Here's what (I believe) the equivalent is in Python: from random import randint rand = lambda: randint(1,4) # 4 chosen by fair dice roll def guess_the_algorithm(rand): if not rand() % 2: return lambda x: x**2 else: return lambda x, r=rand: (x**2)//r() algo = guess_the_algorithm(rand) data = [algo(x) for x in range(1,11)] Which do you think is more readable? I'm not slamming PHP, necessarily, in this context. He just made a mess of that code.
I don't understand why interfaces from multiple packages are now contained in a single package. Seems... odd.
Why are you asking for a comparison between Laravel and Ruby on Rails instead of a comparison between PHP and Ruby? Are you asking if you can rapidly build a well architected, tested application in Laravel? Yes, you can. Can you do that in Python, Ruby, and other PHP frameworks? Yes, you can. In PHP land, the only two frameworks worth getting into are Symfony and Laravel. Laravel is significantly easier to learn than Symfony is and does just about everything Symfony does but in a more straight-forward way (and whatever it doesn't do out the box, can be easily extended or added on to do so). Either way, the debate isn't really between Laravel and Symfony, it's about modern PHP development &amp; workflow, which both frameworks are built for. Are people going to be using Laravel in 5 years time? How is anyone supposed to answer that? Taylor could stop working on it tomorrow and it could go the way of Codeigniter. 
This is no joke. Some people have PTSD from Wordpress, Drupal, and Joomla.
Do you literally program at a bar? I've heard of coffee shops, but never a bar. Sounds fun, but I don't think I'd produce good code in that state.
I would love to use functional programming in PHP, but it's got two major problems, which you've pretty much identified: 1) array_map / array_walk / array_filter / array_reduce argument ordering. It's pretty nonsensical and if you have a series of these calls, you end up with your array in the very middle. If we could could do something like [$myarray-&gt;map(...)-&gt;filter(...)-&gt;reduce(...);](http://nikic.github.io/2014/03/14/Methods-on-primitive-types-in-PHP.html) that would help a lot. 2) Performance. In PHP using array_map is a WHOLE lot slower than just creating a new array and using foreach to append elements. That code may not be as elegant, but it sure is faster. It makes it a whole lot more difficult to convince others that they should try out functional programming because they understand the imperative method better (if they haven't learned FP yet) and it's FASTER. In addition to the hefty function call overhead, the other problem is the fact that PHP single-thread, single-process. One of the biggest advantages to FP is that it lends itself extremely well to concurrent programming - take Python's [multiprocessing.map](https://docs.python.org/3/library/multiprocessing.html) - very little extra code, and now you're using all of your cores. Something like this might be helpful for PHP as well (although I suppose one could argue if you're doing heavy computation in PHP you're doing it wrong)
Depends. What if his visitors don't support SNI (it happens though rare)? Then he needs two distinct IPs. Or he could just get a wildcard domain at about 10x the cost and not have to worry about it.
Very interesting work. I was following what you did with PHPPHP (I tried it it works and it is quite fast IMHO). What is your intent with this? It is like some sort of PHP code optimizer allowed by the source AST (@nikik powered) then doing deep analysis on it &amp; implementing code reduction/optimisation ideas? Like C++ compilers were doing at preprocessing time? Other question: are we sure HHVM is not doing this already (or even Zend engine?) Even though, I see real advantage of maintaining a sort of community based optimizer that would be independant of PHP flavors.
stupid question: would it be interesting to Generate IR (Intermediary Representation) back to a php file in some cache folder? (maybe it is what the backend does, I did not try it but I think will when I got some spare time) 
I also follow semver, but on internal projects I don't use the @since tag in phpdoc at all. I see a lot of agencies using the CI build number as the version number as well, but I hate this approach. You end up with something like "1523" which only tells you that it was a more recent version than "1300" or something similar. Semantic versioning at least gives us an indication as to whether the release contained new features, or just bug fixes.
What is a "Java-fied" mess??? What do you mean by that?
Now I can finally use PHP for games!
That's exactly what it can do already. There are separate IR generation and IR compilation steps, so you can cache it yourself.
Yup. Sit with a beer or three, and code away. I highly recommend it. And no, the best code isn't produced. But some amazing ideas do come out of it, which you can then refactor later.
http://github.com/spiffyjr A few on there: * [DoctrineModule](https://github.com/doctrine/doctrineemodule) * [DoctrineORMModule](https://github.com/doctrine/doctrineormmodule) * [SpiffyFramework](https://github.com/spiffyjr/spiffy-framework/wiki) * [ZfcTwig](https://github.com/zf-commons/zfctwig) Be my quest. Shit away.
There was/is a long-standing bug with schema generation and using defaults. It would generate update schema for entities that have no updates. Just a heads up that you may (or may not if it is fixed) run into that.
If you want a very very simple and basic ORM that incorporates with any other framework take a look at Flourish (http://flourishlib.com/) (but don't expect much features).
Still starts faster than the competitors' IDEs. Disabling plugins, buying an SSD, and a decently powerful machine will generally be enough even for the biggest projects.
I can't compare Laravel to Rails, but about Laravel it's philosophy is exchange a bit of good practice for a lot of productivity. Laravel is more likely to change in 5 years than Rails is, but don't let that discourage you. I've switched frameworks quite a few times and never felt that the knowledge went to waste.
I flirted with FP vs imperative a lot last year, and it's amazing just how much overhead there really is to running those array functions vs a foreach. A foreach by reference may not be as pretty as an array_walk with a Closure, but it's so much faster. I setup a simple test of foreach, array_walk and array_map and ran in both zend engine and hhvm (go through 100000 length array, assign to var) and `microtime`, and got this: PHP 5.5 Zend foreach time: 0.00943922996521 array_walk time: 0.26015782356262 Array_map time: 0.29104089736938 HHVM 3.2 foreach time: 0.0015268325805664 array_walk time: 0.018699169158936 Array_map time: 0.0057330131530762 `foreach`ing is always the fastest (since there's no function call), but it's 31x faster on Zend, but only 4x faster on HHVM. I haven't run w/ phpng but I'm hoping it'll show similar improvements. On PHP the different is not trivial and even the worst 'microoptimization parrot' who makes that claim about anything trying to make PHP faster would see that 9ms vs 291ms is a pretty huge difference. btw not to talk too much about other languages, but hacklang's collections solve your 1) problem. There's even lambda shorthand, so instead of: array_map( function($el) { return $el['first-name'] . ' ' . $el['last-name']; }, $users); you could say: $users-&gt;map($el ==&gt; $el['first-name'] . ' ' . $el['last-name']);
I'm using VoodOrm right now. It's lightweight and essentially perfect for me. https://github.com/mardix/VoodOrm
You can use Laravel's ORM as a standalone library : https://github.com/illuminate/database
There's an [open issue on Symfony](https://github.com/symfony/symfony/issues/6129) that has some thoughts on separating API from implementation. The idea is to reduce coupling. So I could rely on Laravel's interfaces without relying on the actual implementations. Which is (probably) great from a library dev perspective: building something for Laravel? Use this public API only and you more guaranteed to deliver something that works well with the framework.
Sometimes, ill use semantic, and the the build number.... like x.y.z.build
This is not a job board.
You can choose something from: * https://github.com/c9s/LazyRecord * https://github.com/daniel-melzer/teacup-orm * https://github.com/iNem0o/PicORM * https://github.com/ihabunek/phormium * https://github.com/j4mie/paris * https://github.com/kijin/beaver * https://github.com/qeremy/ormlike * https://github.com/lox/pheasant There is a lot simple ORM/Active Record implementations in PHP.
Agreed, and that's an important point: the reason there are different languages is because each has its own strengths and weaknesses. When you've studied javascript, it's clear why code like `Array.prototype.forEach.call` need to be written that way. ecma is extremely weakly typed (I'd say it's the weakest typed language I know), and is pretty focused on FP too.
So it doesn't. Could've sworn Taylor Otwell said something like that at Laracon US.
I have never used AngularJS and PHP personally, but my team has used EmberJS with a PHP API. You shouldn't encounter any problems with PHP really, the only problems you may encounter are with your API, and the way it has been designed. I like using Laravel to build API's. Hopefully that helps somewhat 
This "PHP tutorial" is basically a poorly written description of how to install an off-the-shelf link shortening library. 
If you mix it with HTML, you don't follow design patterns and so on it can be a nightmare, but if you follow best practices it's **very useful**
I've only used Angular with Python backends, but I can't imagine it'd be very different than powering it with a PHP backend. You'll probably want to use Laravel for the PHP framework. You'll have to consider the normal things, like XSRF-prevention &amp; avoiding collisions between your backend framework's template delimiters &amp; Angular's (lots of frameworks, both back- and front-end, use double-curlies; not Laravel/Blade though...). Anyhow, nothing too crazy though, pretty standard stuff these days.
I'd recommend symfony, though you'll be fine with laravel. Setting up routes that make sense is the most important thing -- a basic MVC or MVVM would be your best bet, as angular works best if you're set to return json representations of your models. My experience has all been around moving a more traditional PHP MVC site (php returns fully-rendered web pages) to include features where I don't want to require a whole page refresh, e.g. dropdown search fields.
Any automation? I mean, you change the version number manually?
I built a rather complex Angular app with PHP about a year ago. The difficulties were mostly related to non trivial Angular usage. At the time of writing these were the issues I've encountered: - anything a bit more complex is not documented. For instance, if you want to hook into events like route change or the beginning of a request etc. you have to read the source. - I felt that directives (basically components through which you manipulate the DOM) are really hard to understand at the beginning. The related documentation was just awful, and figuring out stuff like transclusion on my own was a pain in the ass. - there were really few best-practice guides that were actually useful. Basically, anything non-trivial wasn't covered in blogs. I found a lot of guides to really basic apps, but nothing that covered scenarios when you have 20+ controllers etc. For this reason I had to figure out a lot of stuff on my own and had to do a lot of refactoring. My conclusion is that doing a Symfony like bundle system is preferable to just using controllers/services/views folders if your app is getting large. - on the PHP side I actually used Codeigniter due to various reasons, and it worked out just fine. As long as you can build a nice RESTful API any framework (or even just Composer packages) will do. - the first bottleneck of these kinds of apps is always the network latency, so it's good to make as few requests as possible. It's better to have really specialised methods than to have 4-5 GET requests/view. For instance, if I had a form with 5 selects I'd request the data for all of them in one call, rather than make 5 for each. 
Have fun with the remaining year or so of your career (if you avoid js). 
But which off the shelf one - the horribly wretchedly insecure one, or the slightly less horribly wretchedly insecure one?
Do you know any good complex open-source AngularJS app? I'm beginning to develop one on github (It's an human languages learning tool for myself but I plan to open source it) using Laravel as a backend, but to be honest I haven't found any good example in order to follow the best practices.
No problem mate :)
Currently no, we bump the version number in the application config in a release branch, something like release/x.y.z, and then when it gets merged to master we tag and the CI server auto-deploys new tags.
I've done a few Phonegap apps using AngularJS and a PHP backend. Mostly went without any problems, used a custom backend built on Laravel that was communicating via REST api. If you're not set on AngularJS, you might want to look into things like Meteor, as what maskalor said is true - the documentation is lacking and at times hard to follow. 
Thanks, but I need my libraries to be "composer friendly". ReadBean4 drops support for composer. So it's a pity (I used it in the past) but I have to choose a different solution... 
I understand the separation of interfaces and implementation as it should have always been that way. What I find odd is that the Auth related interfaces are not found within the Auth package, etc. I don't see what the benefit is in storing all interfaces within a single package.
Are there any books you'd recommend? Someone suggested Ng-Book to me a while ago and I've been eyeing the O'Reilly Angular book too. Thoughts on those? 
That's not entirely accurate. I've been pushing more and more towards encouraging people to use the Laravel dependency injection container, which is very powerful, as well as recently introduced a separate repository "github.com/illuminate/contracts" that contains nothing but interfaces (something that was very common in my .NET practice), which allows people to *entirely* decouple their domain code from the infrastructure of the framework.
&gt; Of course it's more secure, and more stable, but what is the definition of "more" and how does it stack up against the pain of running old software and the significant effort required to update 3 or 5 year old systems and not break anything? After 3 or 5 years it could be a whole new system that has "nothing" to do with the previous system. Imagine a situation where a system is made and planned to be run for the next 5 years (without any maintenance on the app code). "It just works" and it needs a stable foundation. The system owner is not happy to pay every 6 months (or even every year) any maintenance costs caused by server software upgrades. And the possibly smaller surface for security bugs could be a significant merit. Maybe the Heartbleed bug is a great example about how older software "can be more secure" (albeit some may say the Heartbleed was only "once in a lifetime situation"). Sure the situation may be whole different if the app code is always under constant development/maintenance.
What are you smoking? If you will NEVER have to do maintenance because of end of life then of course doing maintenance makes no sense. But this is almost never the case. Therefore, the pain of doing a massive upgrade every 5 years far outweighs the insignificant risks of upgrading continuously.
I'm in the midst of my first project using Angular and it's a little but of an experience. Doing standard LAMP dev for almost a decade now, I finally decided to get hipster and go 100% JS with SailsJS and AngularJS. The concepts are cool and I love the bindings and such but I keep getting tripped up getting some basic things to work since Angular's methods are so much different than anything from the LAMP world. Someone else asked about O'Reilly's Angular books. They are having a 50% off sale right now and I picked up three of the popular Angular books (and one on Mongo). They are pretty good. Haven't gotten deep into them yet but from a cursory glance...$10/book is still a good investment.
I've done a couple of bigger projects using AngularJS and Laravel and overall I really like working on both of them. The biggest difficulties on those projects have been more related to AngularJS and it's kind of lacking documentation and my lack of experience with AngularJS, which kind of requires a whole new way of thinking frontend stuff compared to other frameworks (at least it did for me). There isn't really any AngularJS + PHP specific problems that wouldn't concern any other MVC/MVVM framework + PHP. You'll just need to design your JSON API properly and that's pretty much it (easier said than done). Asset pipeline for Laravel is pretty handy when working with bigger Angular stuff where you have tons of controllers, directives etc. as separate files (although other frameworks have similar solutions as well).
I'm working on a rather complex mobile app (ionic/angular/Cordova/ui-router) with a mostly laravel PHP backend. We have some unusual and stringent requirements like offline support. The app is proprietary so unfortunately I cannot share the code, but would be happy to write more about things you're interested in. Our implementation is young and this is my first angular, ionic or Cordova app. I'm sure I've personally made mistakes, but we are moving forward, improving over time. Things I've personally found tricky or witnessed members of our team struggle with: - auth (because security is hard), and even auth angular seeds are not perfect depending on how complex your existing server side auth structure is. - offline capability: I use localforage to store http service call results, then all views are populated from localforage, not the http results. - not being able to use a relational db for the front end of the app. LocalStorage is ok but ultimately key value and thus makes me rewrite constraints normally handled by the db. - Cors seems so simple to set up and it is if only have one API server. It can be tricky in multi dev environments with multiple, changing subdomains or local host requirements. I would strongly recommend putting your dev Api environment/server/servers behind a VPN so that you can use an allow all (*) for your cors headers in dev. In prod, you can easily swap out the headers to be only those of your actual API servers. - tooling. Expect to spend some time working with tooling if you are planning on writing tests, using uglify, concatenation, minification, etc. if you do minification, don't use grunt-ng-min. Use ngAnnotate. - mind shift. This is the hardest part of angular for most PHP or frontend devs who've worked with jquery. Angular is all about defining dependencies and breaking things out into very well written components. The problem is that there isn't a roadmap for that. It will take you really understanding the domain requirements and app requirements. It will make you think about coding in a better way. With that said, expect to try to learn it and give up at least once. It can, at times seem over architected and like it gets in the way of your coding. The thing is that if you want decoupled, testable, frontend code, you have to get away from such a tigh coupling with the dom. That's Angular's mantra in a nutshell. 
I still don't get it. I assume you are railing against the use of interfaces, DI, SOLID etc?
Auth seems for me one of the most difficult parts of developing an Angular app, what's your app about? (In case you can share that, of course)
How would you compare Angular docs to Meteor's?
Why the fuck are we calling interfaces contracts? God damn it, /u/utotwel, didn't we go through this shit already with facades/proxies? Stop remarketing all the things!
http://www.phptherightway.com/
That's still horizontal, really. A user controller will never be near a user view/model.
I am returning to php after awhile with all the new js libraries and stuff its overwhelming... Now I like the MVC approach, but it seems like Laravel handles the view/controller/model stuff server side which is replicating everything that things like angular are trying to do. Are Angular and Laravel things that are supposed to go well together?
Referring to an interface as a contract is nothing particularly new or Laravel specific.
It would seem it's so that you can write packages which are compatible with various parts of Laravel without needing each individual part as a dependency. It does seem a little odd though..
I have been writing angular/php apps for my job for the last year. If you give me a week I will make a somewhat indepth application for people to look at with nice docs.
&gt; If you give me a week I will make a somewhat indepth application for people to look at with nice docs. That would be amazing. If you do so please notify this subreddit :)
The application's [mvc5/framework](https://github.com/mvc5/framework) only supports dependency injection and does not need to be bootstrapped. It can be used to modernize an application and has an interesting DI configuration interface. It is probably not for everyone, but it does demonstrate the functionality that I think modern application frameworks should be able to provide.
I rewrote an application with angular and php for my job about 18 month ago. We have around 35k unique users using it between 6a and 2p and it has been great. I decided not to develop for IE9 and below, and for the most part we don't have too many support calls. I think the application does work on IE9 but is just a little buggy. The back end has been just fine. We are using apache and are talking about switching to nginx if we start hitting connection limits.
Sure. The app is for students and instructors in EMS and Paramedic education programs. Among other things, it allows them to track skills, grab ambulance shifts while they get ready for their certification/exams. 
Not sure why this got downvoted, it's true.
Always have it as an option. 
You should use composer to install dependencies (and use its autoloader), and then use a build process to package those files up so they can be used by someone without the use of composer.
I don't use facades much, this seems wrong to me. The testing of Facade's from what I've seen is really easy. And using a Facade doesn't create any tighter coupling than injecting dependencies through the constructor. If there is any time to use a Facade, it would be a controller. The controller is an area of code where domain specific code interacts with framework code. I'd tend to work under the assumption that controllers are framework specific, thus its one of the few logical places to use Facades.
Yes.
Can't really say with 100% certianity as I've only skimed through them, but the Meteor docs look a little better, more clear. Also, Meteor has way more helper objects that make it all around easier from what I've seen - especially when it comes to work with remote objects.
Yes. I think once you use it you won't go back. 
Use composer. It's a standalone php file and users can run it in any environment. Get your package a custom installer: https://getcomposer.org/doc/articles/custom-installers.md
Isn't that a way to customize the composer install? OP wants to not run the install at all.
The books I did look at were already out of date. Perhaps Angular 1.2 will be a bit more stable now? I would look at books targeting that version. 
No, you don't need to use composer. It will make your life significantly easier, but it's not a hard requirement.
Thanks everyone for all your helpful comments!
It's quite handy because then you don't have to include your library files in your repository. And then there's the advantage that it does everything for you.
I see an opportunity for ::class here...
After no concrete answers. I have setup a test machine behind our load balancer. Switched from opcache vs 7.0.4 dev to opcache- 7.0.3. Seems to have resolved the problem. I think its a bug in opcache. 
We use this process as well with [bolt](https://bolt.cm). An example of the build script is here: https://github.com/bolt/bolt-distribution/blob/master/package.sh
Anything really, Make, Phing, Robo, shell scripts etc. Depends on the project.
Read more carefully what I wrote. There is a difference if you never have to fix the app code and if you _have to_ fix the app code _because of_ changes in the underlying sever software (i.e. who pays?). Sure there are lots of situations where it makes sense to deploy updates regularly, but I'm just trying to point out that it may not be _always_ the case. &gt; insignificant risks of upgrading continuously To me this looks quite a narrow-minded. It can be true for cases A and B, but in case C the risk can be considered not insignificant, but instead the opposite - significant. As an example, on the very other edge, how often have you seen server OS/software being used which is based on rolling release? The point is that stability matters, and it is possible that it matters on the PHP code level too.
You're right, that's an even better result. Thanks.
A working knowledge of git tells me you have at least some idea what you're doing. Funny enough I'm *interviewing* my first junior dev this week, so I'll be interested what others have to say here. I'm less interested in the line-by-line details of your code sample and more interested in the bigger picture decisions you made and can talk to. Presumably you will not be put in charge of writing a login system from scratch on day one. Here's what I noticed and would ask you about: * You used PDO - great! Why is it important? * You used superglobals ($_POST, $_SESSION) inside methods rather than passing them in as parameters. Why is this a bad idea? * You appear to be hashing + storing passwords correctly - I would have you discuss the different use cases for different types of encryption (e.g. symmetric vs. one-way hash functions) Basically, be prepared to speak knowledgeably about the right way to do things and the reasons for doing so. Good luck! 
They are vague because it's for a junior position and they expect you to not know everything. That said, if that for code is your own, you'll do fine. Just remove negative comments like "probably not secure" from your code.
&gt;You used PDO - great! Why is it important? Prevents SQL Injection for once. This, I assume is the main reason. Other than that, I honestly don't know. &gt; You used superglobals ($_POST, $_SESSION) inside methods rather than passing them in as parameters. Why is this a bad idea? I have absolutely no clue. But I'd sure as hell love to find out! &gt;You appear to be hashing + storing passwords correctly - I would have you discuss the different use cases for different types of encryption (e.g. symmetric vs. one-way hash functions) Yeah, that's a bit much over my pay grade. I went with password_has() after reading some on stackoverflow about it. Most people recommend it as a fairly good encryption. Well balanced between how long it takes to encrypt and encryption strength. 
Without SwiftMailer and the password lib thing, it's all mine. And I keep those comments because I don't honestly feel it's secure.
&gt; Prevents SQL Injection for once. This, I assume is the main reason. Other than that, I honestly don't know. That's the main reason. As a bonus it's also easier to read and maintain than a concatenated string. Re: the superglobals, take a read through this: http://www.phptherightway.com/#dependency_injection. You want to pass things as arguments to methods instead of referring to the global namespace. This makes it easier to change things down the line. Symmetric encryption (e.g. MySQL's AES_* functions) just means it's reversable - if you hash a password, you can't get the original value back (which is why we use it). For something like credit card information, you want to store it securely but be able to get the original number when you need to send a transaction to the payment gateway.
I modified the GitHub link. I accidentally linked to the Master branch. I have another branch where I commit after I test it. The master branch got left a bit behind.
I agree, but he should present it in a constructive way and in the readme. It doesn't belong in the code.
I follow XenForo, which is to have a text version and an integer version of the format xxyyzzabb, with xyz being the usual, a denoting product maturity (1 = alpha, 3 = beta, 5 = RC, 7 = final, 9 = PL) and b denoting product maturity level (alpha 1, beta 4 etc). This makes version comparison very easy.
Don't be daft. All your reasons are subreasons of "more modular."
No, the code is exactly where it needs to be. Provides the context that you need. 
Some other quick suggestions. Any POST variables should be trimmed into a new local variable and then passed into a method to finish the job. Keep functions separate and small to help with readability, extendability, and debugging. Index the username, password, and email address. If your database ever grows above a few thousand users, the queries will slow down considerably as-is.
When would you use an interface and an abstract? What is a trait? What is the factory pattern? What is the difference between a queue and a stack? What is dependency injection? What features of PHP 5.6 / PHP 7 interest you the most? Stuff like that
While I agree that the name "Interfaces" (note the plural * ) might have been better, at least the name "Contract" isn't *wrong* for what it describes, like "facade" is. (* Can't use just "Interface" as it's reserved.)
The comment is at the top of the index page with very little code on it. There is no context on that page for security. This just reminds us how interviews can vary so much between interviewers.
I thought it was a pretty good joke.
junior means they pay you less, the tasks are tedious but easy, and/or they have a senior php coder who will teach you the ropes when you get there and being paid less is usually only a short term thing in the php world, if you simply focus and work on it
How else will you have the time to take hour long coffee breaks?
My advise: learn a bit about the OOP terms. * What's the difference between class and object? * What is polymorphism, inheritence, etc...? * What is an abstract class and when would you use it? * What would you do if you experience a white page when running PHP? * What is the difference between static, public, protected and private members? These are some of the more common ones I've come across. Question 4 was interesting because I gave the right answers, but not the one the guy was looking for (using XDebug). Every PHP interview I've had, I've been asked questions 1 &amp; 2. Question 3 is nice to know because it shows you understand some of the more...unfrequented OOP concepts (I don't see a lot of abstract or interface classes). Qustion 5 has come up a lot too. So its good to show you understand how relations and inheritence works. Overall though focus more on how and why you'd use things instead of what they are. Its nice to know that private members can't be touched but by the class that creates it, but if you can't explain why you'd use it then why know it?
I've hired a few junior developers over the last few years. We actually decided to stay away from asking PHP questions in our interviews. The reason was that no matter who we hired we were going to have to train them; instead we focused on stuff like this: - Tell us about a hard programming problem you encountered and how you solved it. - Tell us about your favorite and least favorite parts of web development. - Tell us about your favorite programming project you've contributed to. - Tell us about common security problems in web development that they are familiar with. - Tell us about your most complex database query you have written. - Have you used version control software? With that being said, I expect that other places will focus on more PHP questions. It's sad, really, but they don't realize they are asking the wrong questions. Even still, I would recommend that you think about the above topics and then come up with responses to them in a PHP context (if appropriate); that should help you prepare adequately for any place I'd consider working at. --- And for the others in this thread who are conducting interviews... consider this my plea to you. Stop caring so much about PHP specific knowledge, particularly in Jr. Developers. After the first round of interviews you can always ask more technical, PHP related questions to pick between good candidates if needed. Also, when they are talking about their favorite programming project you should ask questions about it. Show interest in what they are saying (and you should be interested; you are possibly hiring this person!)
its not pdo preventing sql injections, its prepared queries .. you can do that with mysqli as well as old mysql libs
Out of curiosity, how is that easier to compare than semver? It seems to me that a version string like 1.2.0-RC1 is much clearer than 010200701.
Thanks. &gt; It can be done with 5-10 lines of code.. Most of the JS deails with saving/retriving the data to/from local storage. But, I am really curiour how you can manage that many states in 5 - 10 lines of code. What am I missing? 
&gt; What would you do if you experience a white page when running PHP? Turn on error reporting xD.
You don't have to use Composer but you should use a dependency manager. You could use Maven if you wanted to but Composer is a bit simpler to setup.
Maybe, if the job involves throwing Wordpress sites together, but if I have two junior devs interviewing where I work, and one of them knows the answers to those questions, they get the job. 
Well, it's what they will be doing. It's all basic oop stuff, and the answers can be found with 20 mins of reading, if they don't know it they can't do the job. 
Got your queues and stacks the wrong way round. Traits are used for horizontal code reuse. 
I had my first PHP interview about 2 months ago. This is what I was asked: * What would you do if you ran your code, and only a white page appeared? * How comfortable are you working with others? * What programming languages would you like to learn? * How experienced are you with MySQL? * Complete the FizzBuzz test. * Complete a small object oriented test that is similar to how their system worked. No documentation. Just look between files and see how it works. * How experienced are you with Git? * What kind of projects have you made in the past? * What kind of stuff are you currently working on? Thankfully, I ended up getting the job, and it's great! Just be confident during your interview. This may be on a per-basis, but during my interview, they treated it like a conversation, not an interview, which definitely made me feel more comfortable. It might be helpful for you to do the same.
&gt;What would you do if you ran your code, and only a white page appeared? Turn on error reporting. Clearly. &gt;How comfortable are you working with others? I have a habit of occasionally throwing my own feces around when feeling threatened. But in all seriousness, I don't even know how to answer this. Clearly I am since I'm here, but that seems a bit condescending. &gt;What programming languages would you like to learn? Python here I come. &gt;How experienced are you with MySQL? ...well that's vague. &gt;Complete the FizzBuzz test. I actually looked over it. It's pretty standard stuff. &gt;How experienced are you with Git? I can work my way around it fairly well. &gt;What kind of project~~s~~ have you made in the past? I have the stupid habit of never completing one before jumping to the other. So, project, singular. &gt;What kind of stuff are you currently working on? See link in description. ---- This is really helpful actually. Overall I'm getting a good idea of what awaits.
Contracts is a completely legitimate and semantic module namespace for what this is. Both Interfaces and Abstract Classes describe interfaces of classes of object implementation. Naming it "Interfaces" would imply, to me, that there were only interfaces and would possibly create friction as to what belonged in the module long term. Framework developers have to account for this type of future proofing. In addition, consider the trend (in the PHP community) to remove "Interface" and "Abstract" from class suffixes and prefixes and instead describe the contract for what it is. It's not PSR, but Laravel isn't PSR and part of that might be for freedoms like this? :shrug: I'm not Taylor. All in all. There are a lot of bright minds in this community and I find it unfortunate that so much effort is spent rehashing the same arguments over naming things. The facade/proxy horse has been beaten into a smoothie. Taylor isn't going to change the name until he does (or doesnt). Either way, if a framework's naming conventions affect your (general you, not specifically the posted of this comment) application, you lost the war on day one. A framework is an afterthought in most of my applications. I try to defer technical decisions as long as possible so that I can make the best decisions at the points where I have the most information. I'd suggest you do the same rather than worry about framework package nomenclature. 
The comfortable working with others question was because the developers work in one area. A front-end developer can just turn around and say, "Hey swagboy, I need this done," or "Hey swagboy, I'm getting this error from something you pushed, what's causing it?" People also give their opinions on the efficiency of my code and help me improve it. So can you handle people asking for stuff every so often? Can you handle the constructive criticism of your code so others can help you improve it? Your company may be formatted differently, though. The MySQL question was mainly, "Can you do joins correctly? Are you aware of proper SQL syntax? How can you make database look-ups faster... etc."
I haven't really come across a whole lot when it comes to tutorials and best practices. I am using [angular-localforage](https://github.com/ocombe/angular-localForage). I think a blog post is probably in order so I'll write one up then post it here when I am done. I am working on moving my blog so it may be a few days. Once you get localforage into your project properly, it is really easy to use. I've only run into one weird problem with it. It only happened on older iOS (v6). When redirecting away from the current page (using window.location = 'new.html') and using localforage.clear in the same promise chain. This combination caused a really weird indexOf(a) not found error. It could have been my fault for all I know, but I ended up just throwing localforage.clear in the page load for my login form rather than in the promise for my log out button. Again, this was a temporary thing and certainly is an edge case since most ionic apps will be a single html page.
This is just brilliant, conspiring to make this happen, working on jitfu ... best. fun. ever. I look forward to whatever comes next ...
(I somehow completely missed that this even popped up on /r/php, so apologies for popping in a week late.) I certainly can't disagree with you that this is madness. Why, just the other day one of the other devs hit a fun case where our error handler to spit out debugging data conflicted with the typehint error handler because while still within the first error handler it happened to call code that relies on the second, making PHP cranky and the original error difficult to debug. It's also *really* useful: it started as controller-only (so approximately once per request) and leaked into models because the other devs enjoyed using it so much. I will, however, disagree that it can't possibly be made non-heavy. In theory, I could use PHP-Parser to convert: function f(hint $arg) { // ... } into something more like: function f($arg) { if (!is_hint($arg)) throw new InvalidTypeException(...); // ... } on deploy, which would entirely bypass the error handler hack outside of dev machines. Suddenly, much less heavy. But right now, profiling doesn't even register it.
Yeah I'm sorry about that. I really don't understand tribalism over tools. To be clear, not arguing for Laravel here. I feel folks react poorly to both sides and I just accept that as the human condition. But you've made your argument and I agree with your opinion on many things, but I know that once I make an argument with someone and disagree with no solution, I let it go and refocus. You're a very bright developer and I know I have learned a lot from you. I just feel like you waste effort tunneling-in this deeply on one issue. However, I also recognize that I have no right to tell you what your time is worth or how you should spend it. Personally, I've cringed at a lot of the responses on both sides of the tribal line. Can't we all just get along! Haha. Have a great day, Paul. 
Oh, do you have that PR handy? I'd like to review it if you don't mind. I must have missed that. 
That's good to know, particularly for the stuff that couldn't be replaced by scalar type hints (e.g., row_id $id basically meaning is_int($id) &amp;&amp; $id &gt; 0). It's also a bit sad. PHP's implementation of it leaves something to be desired, to be sure (it's no handler-bind!), but being able to handle errors without unwinding the stack is the bee's knees.
Ahh, I take back half of my other comment then. This describes the value you see in honing in and focusing on the issue. I agree 110% on framework-de-jour and understand what you're saying. I suppose it's a difference in perspective that separates us. I simply use a framework as a tool and understand many of the trade offs / problems being solved so, to me, what it's called doesnt matter so much as long as it fulfills a solution to the same problem. Your goals seem to be much more in community outreach and stability through standardization / policing of these types of things and I respect that. In the end, Laravel calls it's service location facilities a "Facade". I choose to think, "hmm, that's odd but I'm going to use this for service location and move on". That doesn't really help provide understanding for folks coming to the framework for the first time, but that's the tradeoff for me haha. I'm not far enough in my career (I feel) to do the types of outreach you're doing, so I keep moving forward. As far as honest feedback goes, my previous interpretation of your quick responses on this issue had a feeling of "snarky jabs to fuel the troll fire" but I now understand your motives a bit better I think. I don't know what this means for you as far as delivery, I'm just letting you know how it comes across when I scan through these types of discussions. 
In my experience, someone who is doing senior level work in a junior level position and pay structure is going to be gone the second someone sends a better offer their way. 
Where I work, that's not senior level.
What makes ZF2 so bad that it's not even worth getting into? Are there any good, serious reasons?
I was interviewed as a junior dev about a year and a half ago, and it was a CodeIgniter shop. They asked me this exact question, turned out they were trying to see if I knew about CodeIgniter's logging abilities (as it happened, I didn't and in fact I still don't). I'd say error reporting is a good one, or a decent debugger, like XDebug.
It takes extra configuration through specification of an alternate test runner but it's doable. This came up in an issue recently. I should blog about it. *runs away* :)
When you ask someone: &gt; What is a trait? A correct answer is not: &gt; Traits are used for horizontal code reuse. /u/kurashu89 answered that question correctly, he/she seems to be acquainted with a language that supports multiple inheritance. Traits are an effort to incorporate that into PHP. Also, he/she is quite clearly hinting at "horizontal" code reuse when mentioning the benefit of traits to those other languages.
Then your job roles may be labelled wrong and not inline with the majority of other employers. Unless of course you are a huge blue chip company.
Admittedly, horizontal code re-use is a simplified answer, but I would understand what someone meant if they said that to me when describing what they are. We are talking about PHP specifically here, not other languages.
Priceline
Thanks for the congrats :) The [Bitcoin wiki](https://en.bitcoin.it/wiki/Base58Check_encoding) has some good reasons for using Base58: - Don't want 0OIl characters that look the same in some fonts and could be used to create visually identical looking account numbers. - A string with non-alphanumeric characters is not as easily accepted as an account number. - E-mail usually won't line-break if there's no punctuation to break at. - Doubleclicking selects the whole number as one word if it's all alphanumeric. Also, Base64 contains symbols which are used in URLs: +, /, and =.
This. Even in apps with no external dependencies I use Composer's autoloader. I consider this a "solved problem" and intend on never writing my own autoloader again.
They'll be allowed 20 mins of reading during the interview? I don't expect anyone to keep up with absolutely bleeding edge of PHP 5.6/7, I haven't kept up with them. Would definitely fail your interview.
yes its possible, it depends on the version of php you're using, so keep your distribtion up to date, or consider using Application Security tools, Suhosin is also very good if you either have a php 5.3.x version OR can install php &amp; suhosin from its sources. it is much more likely though to be able to attack your system/server because of your code and not because of PHP itself - buffer overflow attacks vs php are very rare if you want to keep up to date in terms of attacks vs php and its modules google "php cve" and pick a site that keeps up to date with existing exploits
Nah, this is a guy asking what he should expect. I mean spend 20 minutes reading up on that stuff now, and then go into a job interview looking awesome. Also, I wouldn't expect bleeding edge, just know what knew features are coming. It shows you are truly interested in your field, and willing to make sure you are keeping up with the trade.
Not sure if others pointed this out, but while many are looking for server side exploits, a lot more common these days are XSS attacks, these are something to keep in mind. Anything the server uses from the URL that is displayed on the page could be used to inject a script on another domain and give them access to each individual user that uses that URL. This is mainly done using links on pages or emails.
As exceptions (and presumably abstract classes) are included as well, the more general 'contracts' is appropriate.
$this-&gt;studyupSon;
Fantastic. That all makes good sense. Good work.
White page on a live server? if ($_GET['random_param'] == 1) { var_dump($variable); } it is wrong from any and every point of view and wild dinosaurs should run and kill me exactly like in this picture http://imgs.xkcd.com/comics/goto.png. But, it did prove effective at finding the error quite a few times when i had a pretty close idea of what was the cause. Of course this would also need upload access to the live server which is horrible.
Every benchmark i have ever seen always showed that php 5.4 is faster than 5.3, and 5.5 is faster than 5.4.
$this-&gt;doStudy();
Ooh I can feel that burn. VBA is better than VBS because Excel gives you a nice IDE. All hail VB.
Strangely enough, the 3v4l.org wbesite now shows different results. It was a graph, now there is a grid. And php7 appeared And now the recent php versions now look faster than previous (it was the opposite!) So maybe it is this website itself that is unreliable since we have no clue about the test methology. 
Here: &lt;https://github.com/laravel/framework/pull/3835&gt;
/me nods Again, I thank you for your kind consideration. :-)
They're not super special, and really I wouldn't expect anyone to seriously read about PHP7 (to the point where they could discuss it at length) until it was much closer to release. His questions are mostly above what a junior should know (should vs "would be nice"). Yes, I would be happy if a Jr knew how to use traits, but I wouldn't hold it against them if they didn't. I get the impression his company hires people below their skill level (ex: SA -&gt; Sr, Sr -&gt; mid, mid -&gt; Jr, Jr -&gt; no job/QA).
Between those options, Which one do you prefer and Why?
Honestly, MVC should only be treated as a guideline. Don't mix domain logic with application control flow logic, don't mix display logic with domain logic, ect. Don't try to force every class to be either a model, a view, or a controller. Instead say this class belongs in the model layer, or this class belongs in the view layer, or this class is a controller. If you think of MVC as 3 separate layers rather than 3 types of classes your application will more accurately reflect the "concept" it is supposed to be. When you're using Laravel with Angular, you actually have 2 different views. When talking server side (Laravel) your view is actually just Json. The Json that gets returned by any endpoint is your view. Now with angular, that json is actually part of the model layer. It represents the entities/models that your view will display. So when you're thinking about what the view is in the context of angular, its actually the rendered HTML that the end user sees. So in the end, you have 2 different MVC frameworks working together, and what you are referring to when you say view or model depends on the context. If you try to treat your server as purely database access, you'll probably end up exposing sensitive information client side, so you cannot handle all of your application logic in angular as all the data is visible. Try to make your front-end and back-end as ignorant of each other as possible and you will find it much easier to develop and maintain your application.
Then you'd already know... $this-&gt;doStudy(); != $this-&gt;doStudy;
Just out of curiosity, why not keep the base 64 and replace the problem symbols? You keep your power of two, you can get rid of the URL characters, and you avoid the big integer division. Unless I'm missing something?
Written in PHP; Figured it was worth sharing here on the sub reddit :D!
I have a question that's definitely off-topic. I too have a jr. dev PHP interview this week for a position I'm really excited about. It's a huge back-end database job, just the sorta stuff that fascinates me. Question: I have a suit that I only wear to job interviews, and my white dress shirt has a stain around the neck. I only ever wear my suit to interviews because it was expensive. Do you guys have any tips for getting that stain out of the necks of nice shirts?
What would you replace them with? Base64 uses pretty much all universally usable characters already. 
:) You're very welcome.
There are workarounds for that. For example: function base64UrlEncode($input) { $str = strtr(base64_encode($input), '+/', '-_'); $str = str_replace('=', '', $str); return $str; } function base64UrlDecode($input) { return base64_decode(strtr($input, '-_', '+/')); } **EDIT**: I'd appreciate if the downvoters explained themselves, since these functions are used my many, many open source projects and url encoding/decoding with base64 is extremely common.
Good question. It's something I considered while developing the library but I decided to stay focus on one encoding scheme to keep things simple for now. I'd definitely consider it for a future release.
There's nothing special about them, they are just an example of what we would ask at our company. They would show you know the basic principles of up to date PHP software engineering, and you are also interested in the future of web development. You don't necessarily have to have ever implemented any of these principles, just know what they are.
Because you would have to replace them with other symbols. Base58 doesn't contain any symbols, only alphabet characters and numbers.
Lol. A lot of reasons for things in programming are non-technical.
Not sure I understand your response. I was assuming there might be a technical reason (more compact using less bandwidth/storage, faster, whatever). There wasn't any. I was being polite and thanking OP for explaining their reasons... 
Those people have obviously never used Magento before.
Well done on your first release; this genuinely looks interesting and I now have it stared on git-hub for when it becomes useful in a future project.
Rolling like Arch. One example (as I have already said) is an app which is designed to run for the next, say 3 years. It should run that period of time without any need to fix the app code (there will be never any legacy problems as long as the server software won't break anything). This, and the benefit the system may gain from the security side, can be a huge plus for the specific situation. The security gain also applies if the app code worked without any maintenance even if the server software would have been kept in its latest version the whole lifetime off the app (as said by D. J. Bernstein "Security holes can't show up in features that don't exist."). That could be a reason to host the app (at the time being) on, say, PHP 5.4 instead of PHP 5.6 for some situations. Such things should be acknowledged when designing a system.
 for ($i = 1; $l = count($bytes), $i &lt; $l; $i++) { should be for ($i = 1, $l = count($bytes); $i &lt; $l; $i++) { or you wouldn't have any improvement, right? ([Link](https://github.com/stephen-hill/base58php/blob/master/src/Base58.php#L76))
&gt; One example (as I have already said) is an app which is designed to run for the next, say 3 years. Again, what are you smoking? If you're app has a 3 year life cycle and your platform as 3 years of support then there isn't much point in discussing updates. The benefit to upgrading is zero. &gt;can be a huge plus "can be a huge negative". These aren't actual measurements. You can't just say "massive benefit" and not demonstrate quantitatively what that benefit is. &gt;could be a reason ... for some situations could be, possibly, in a certain situation where it was ... you are just defining yourself to be correct. I'm well aware of the reasons in theory, I'm not seeing them in practice, but I am seeing the downside of having to update a 5 year old machine without breaking anything. 
Thanks. Will take a look at that this week :)
Thanks. I'm going to take a look into data providers this week :) I'm interested if you could please explain why "if assertions on one of the strings fails, the following tests won't be executed which is wrong" My current thinking is that if even 1 test fails, then the current code is no good and should be fixed. But keen to hear if I'm thinking about this wrong.
Thanks very much for spotting those mistakes. It's good to have people look over your code. Now fixed https://github.com/stephen-hill/base58php/commit/3cd02b3eb73665dec8f2efdce89fbc94d463ee2c
I'm sorry, apparently I'm not being clear. The point of continuous upgrades vs an LTS of say 3 years is so that you don't have to do a large upgrade after 3 years. If you won't have to do that because your app is EOL, then the point is moot: you don't need to do them either way. Are you trolling me? &gt;The benefit is less exposion to the security bugs I get it. It's not a difficult concept. But ... &gt;say, 8 security vulnerabilities. But if you upgraded PHP all the time, your system would have been exposed to, say, 16 security vulnerabilities You aren't saying anything concrete. You're just saying the words "security" and "vulnerability". It doesn't mean anything. I can just say: after update your performance increases exactly 9/16 units of vulnerability, so we are better off upgrading. &gt;I'm just bringing up other sides of things which are good to acknowledge, especially when working on systems where security and stability is a high priority. Sorry, but you aren't bringing anything up at all. You are simply using the words "security" and "vulnerability" and "stability". They are meaningless without any quantification. &gt;I see where you are standing on this and I respect your view. But at the same time I ask you to give a little thought on what I'm bringing up here. I'm trying to. But I understand what you are saying, and I'll say once more: all I get are headaches from not upgrading. I have systems that I upgrade every 6 months, 1 release behind, and I don't have any security or stability issues that I'm aware of (meaning Ubuntu dist upgrades, security are done regularly). Can you please bring something concrete to the discussion, or stop replying. Good day.
How do you do that? I've never managed to get local projects to play well with Composer.
What's your reason for implementing this with bcmath instead of gmp? As far as I can see you only need bigint computations, not fractionals, right? If you're only working on integers, I'd always recommend using gmp over bcmath, because it's a lot faster (often in the 10x range) and provides more functionality, e.g. you could do a gmp_div_qr to get both division and modulo. Or your code for the base256-&gt;10 conversion would just be `gmp_init(bin2hex($str), 16)` (in 5.6.1 that one will become `gmp_import($str)`).
I assume you're talking about MVC frameworks. They offer a logical way of splitting your code into different parts of the application (Models, Views and Controllers). The larger frameworks provide a lot of code that you would otherwise have to write yourself eg. Http classes, form validators etc. The only reason I can think of not to use one would be if the project is very small with little or no chance of need to grow.
I don't know where your test strings come from, but ideally every test string should be used to test some specific behavior / execution branch (i.e. encoding digits, encoding lower case letters, etc. which is applicable to your algorithm). Thus if you exit on the first failure, you don't cover the rest of possible branches and probably don't show other errors.
I'll be honest, I just picked one. But you right, GMP is much faster, and I'm planning on adding it in a future update.
It's pedantic I know but please [read this](http://www.reddit.com/r/PHP/comments/2e5fjc/looking_for_a_really_simple_mvc_framework/cjw9t0x). There's lot of other resources I could link but alternatively you can just google that guys name. tl;dr There's no such thing as an MVC framework. 
Thanks :)
&gt; You aren't saying anything concrete. You're just saying the words "security" and "vulnerability". It doesn't mean anything. I can just say: after update your performance increases exactly 9/16 units of vulnerability, so we are better off upgrading. Some pointers for you: CVE-2013-7226, CVE-2013-7327, CVE-2013-7328, CVE-2014-2020. At the time those bugs got a CVE number, if you would have been on PHP 5.4 (instead of PHP 5.5), there would have been _zero_ expose for your system caused by those bugs (because those bugs didn't exists in PHP 5.4). And as a drastic example (while not specific to PHP thought), remember Heartbleed? I understand you may not find this kind of things noteworthy, but on some other systems/situations such things need to be acknowledged (and acted accordinly).
$son-&gt;studyUp('PHP');
Seltzer water, but not really, it depends on the stain, is it red wine, blood, sun screen, or lipstick? Best bet would be to take it to the cleaner and have them deal with it.
Thank you. That certainly helps me explain my POV. I don't have time to look at those in depth right now, but just taking the first one: &gt;Integer overflow in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an imagecrop function call with a large x dimension value, leading to a heap-based buffer overflow. You need to be cropping an image with a user supplied width for this to happen (at a glance?), and even then it's just a DOS vulnerability, something which every thing on the internet is already vulnerable to. To me that's a perfectly acceptable level of risk in order to 1, stay up to date and take advantage of new features/fixes sooner rather than later; 2, not have the headache of performing a massive overhaul every 3-5 years. I'm not talking about bleeding edge here, I update Ubuntu 6 months behind the releases, and PHP is at least a minor version behind, if not a major version (by major I mean 5.5 vs 5.6, at least till they sort out release naming conventions). I'm new to the ops side, but I'm thinking that LTS doesn't hold much value when talking about web apps. 
What is gearman ? 
&gt; V597 The compiler could delete the 'memset' function call, which is used to flush 'final' buffer. The RtlSecureZeroMemory() function should be used to erase the private data. php_crypt_r.c 421 I've *never* seen GCC optimise-out calls to `memset`, and the suggestion to use `RtlSecureZeroMemory` instead is about as useful as a chocolate teapot. If Microsoft's compiler is removing `memset` without replacing it with something that has an equivalent effect then it's a bit braindead. The rest of the PVS-Studio has picked out seem to be legitimate though.
before you decide to use or not use them, first learn what they are. That is the most important part. After that, you'll realize more than people can tell you now, if you need them or not.
Interesting. Seems like a PHP extension might be a better fit since you said it was slower than base64
gearman is a job manager that allow your applications to submit jobs in background. http://gearman.org/
There is browser related limits for IE URL lenght: 2083 characters http://support.microsoft.com/kb/208427 And for Apache 8190 bytes by default in LimitRequestLine http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestline 
You write the exact sentence that I would write :) Autoload dependencies is awesome!
I'm trying to understand how it works for all 6 characters. Edit: Look, you can't complain about downvotes and then downvote your replies.
I've used white vinegar to get rid of sweat marks on a white shirt before. Left it to soak in for a while before putting it in the washing machine.
I have had no issues using PHP on the backend, at least none that wouldn't be found in any other language being used to build a RESTfull API that an JavaScript front end client talks to. So far my experience with Angular matches what a lot of other people here are saying, in that the documentation is severely lacking in many areas, something that tends to delay development as you end up doing some reverse engineering to figure out stuff that should really be documented. 
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537 Seems actually gcc can and does do the same optimization. I've never heard of it before either, someone used to working with security sensitive code like that may have I guess ... I wouldn't call it a bug, or security hole ... but it is a thing ...
&gt; I'm trying to understand how it works for all 6 characters. I think the other characters are already url friendly? &gt; Edit: Look, you can't complain about downvotes and then downvote your replies. [I didn't downvote you](http://i.imgur.com/sF2edQE.png). Whoever did should reverse it as well.
&gt; Why should i use them and why should i not use them ? (i hope that makes sense) **When to use frameworks** * When you realize you've written the same basic code for the 50th time and think "there must be a better way" * When you want to rapidly build a robust application that has reliable, strong bones and joints * When you want focus on building the domain &amp; core of your application, rather than worrying about building a bunch of infrastructural stuff over and over again * When you want to use a tool that provides simple ways of writing good, clean, well-separated code so that you're not tempted to take shortcuts on things like dependency injection and SOLID principles. A framework helps discourage bad habits by making good habits easier. * When you realize that using a framework is like the convenience of going out to dinner and having someone else cook your food and clean up after you so that you can focus 100% on just enjoying the food, except that a framework is completely free so you get all of the benefits with none of the downsides (going broke, having to drive somewhere). * When you realize that if someone asked you to build a table, you wouldn't then go out and grow a forest, chop down and mill the trees, build a table saw/hammer/, build the house the table will go in, and THEN build the table... * When you want to learn something new and push yourself as a developer **When to not use frameworks** * When the environment you're building on is extremely old (like older than PHP 5....) * When the environment you're building on doesn't have a lot of horsepower (for example, I'm currently building a PHP application on what is essentially an anemic Raspberry Pi, and a heavy framework like Laravel or Symfony are out of the question. Could use a micro framework though!) * When you're trying to learn how concepts like dependency injection, inversion of control containers, ORMs, and autoloaders really work under the hood, and you try building them yourself for educational purposes. * When you're suffering a bit from Not Invented Here syndrome and you have a skeptical distrust of not only other using other people's code, but LEARNING another tool when you know PHP so well. But if you do the above point: the learning/doing it yourself, you usually end up realizing that someone else has already built a better, more robust, and more stable version of the thing you're trying to build yourself, and now that you know how it works under the hood, you're not skeptical about it anymore. **TL;DR** I would love to tell you that you should always, without question, use a framework of some kind to get the boiler plate code out of the way. But, jumping right into a framework without really understanding the underlying concepts and components behind the framework, can make it difficult to use the framework properly. A framework is not a magic bullet; like any tool it needs to be used properly. Yes, absolutely use a framework. But I encourage you to build your own (or parts of your own) for learning purposes. A modern framework should have these basic components: - Everything routed through index.php - Autoloader ( worth building your own, but using Composer's is perfectly fine) - A router to match URIs in the browser - A dispatcher that figures out which controller to call and what data needs to go to it - A dependency injection container to manage all of the dependencies you want to inject (can be a configuration-based container, bonus points if you can use reflection to make it auto-resolve dependencies for you) - A view class for registering view data and loading a template file - A database connection &amp; abstraction layer (bonus if you want to build a light weight ORM) If you go through the learning process to build that, and follow good object oriented principles to do it, you'll gain a much greater appreciation for full stack frameworks.
Are these local/legacy projects with existing codebases, or fresh projects from scratch?
Interesting stuff, I hope a PHP developer sees this post and does some bug fixing. Some of it I didn't understand since it's been so long since I did any C programming. 
Something is very wrong with the tests used for the graph in that picture. I'm sure of it.
Well it's a function man. Do you expect study to be a variable. It's complex stuff yo.
Why have you passed this off as your own article when it was originally published over a year ago: http://www.infotuts.com/drag-and-drop-multiple-file-upload-using-php-and-dropzone-js/ Infact, a lot of the content on your website is ripped from elsewhere. I don't find this "Highly creative" or "innovative".
Almost everywhere I've had to dig into assembly I've always found `memset` even stops GCC from doing constant folding no matter which optimisation flags were passed and it seems like a massive misnomer to think that `memset` could ever be optimised away so this is a new one for me. Ty for the link, will have to have another look at it.
It is a social media website.
The site looks like it was made in the 90's, there is no design. It's so ugly that I didnt even bother reading, and just closed it. Atleast 10 diffferent Advertisement dom element were on their randomly in different location. OP is trying really hard to get rich quick schemes.
Site was built in Wordpress using the [Hueman](http://alxmedia.se/themes/hueman/) theme. The theme itself isn't bad, but the content on this site is just atrocious.
It's not pedantic, it's wrong. "MVC framework" means a framework that *enables* an MVC app, not that the framework itself is MVC.
Depends hugely on your app and it's functionally, but here are a few general ideas; Privacy (who can see what) Localisation (Timezone, currency, language etc) Security (Password reset question(s)) Alerts (friend request, password change etc) Blocking of other users
Or you know... use [SoapClient](http://php.net/SoapClient)...
Desired fart sounds per hour is a must for any api.
Fresh projects, but it applies to both, any code. Let's say I have some kind of library code or whatever I want to put in its own Composer repo, but I just want it locally for now, not on Packagist etc. The only method I found was to link to a git repo on my computer - which is fine, obviously it should be in VCS. But I can't develop that package and use it without having to commit every change. And I also have to run composer update every single time, too. As far as I could tell, there is no way to just link to a folder of code using composer.
This isn't related to PHP at all...
stupid question regarding versioning [Github allows you to create a release and give it a version](https://help.github.com/articles/creating-releases) But I still don't know how to have the release version reflected in an [@version](http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_tags.version.pkg.html) phpdoc comment. Anyone?
Another one: http://zf2.readthedocs.org/en/latest/modules/zend.soap.client.html 
While most implementations of memoization are stateful, it is precisely the immutable functions themselves that makes this kind of memoization safe. It could be argued that referential transparency holds as long as the program's behaviour is consistent observationally -- disregarding execution time in this case.
Pierre already [pointed it out] on the internals list, it's being looked at. [pointed it out]: http://news.php.net/php.internals/77005
That is not a question. Please delete and try again.
&gt; The 'auth' offset is bound in Illuminate\Auth\AuthServiceProvider to an instance of Illuminate\Auth\AuthManager. If you don't want to use AuthManager, you can delete the inclusion of the AuthServiceProvider from app/config/app.php and add in your own Service Provider, or you could do this how ever you want(in the route file if you like that way) Yes, but the problem is that it changes that implementation GLOBALLY for all places where the Auth::user() facade is used. This is the problem with ALL facade/static usage. Yes, you can swap out the binding that the IoC references, but you have to do that globally. 
C# Has static constructors which I think are neat.
PHP needs a tuple instead of the strange stdClass object. Every time you want to return multiple values, you have to wrap them up in generic objects, which is annoying.
 function foo() { return ['abc', 'def']; } list($first, $second) = foo(); Not acceptable?
You can follow the singleton pattern in PHP. It has several traits of C# static constructors.
Yep
I rather like how Python differentiates between class methods and instance methods. Class methods are roughly analogous to static methods in PHP, but there is enforced separation between the two concepts.
Annotations. Hack lang has provided most of what I already wanted.
Well i guess the first thing would ve to have a unified syntax and drop all the weird and bad things. Other than that Python like list comprehensions would be great.
and then PHPStorm shits itself
Named parameters.
Stupid question stupid answer, fucko
I consider this Yet-Another-Workaround. I'm not saying you can't do it, but that there should be a formalized (and optimized) way to return multiple values. 
Not yet mentioned in the thread: [Array Of](https://wiki.php.net/rfc/arrayof), [Return Type Declarations](https://wiki.php.net/rfc/returntypehinting) and nullable type.
I'd **REALLY** like better/cleaner support for regexps. A regexp operator would ideal.
I think I'm gonna try this method. I'll report back with my progress. thanks!
So, is there something wrong with my reasoning?
RE: get/set--maybe a v1.3 RFC will actually pass? (I hope, pretty please) https://wiki.php.net/rfc/propertygetsetsyntax-as-implemented
Please watch: http://www.infoq.com/presentations/8-lines-code-refactoring 
IIRC 7 brings about better list comprehension
PHP should have two new native types (instead of the new [] syntax): array (via []) and hash (via {}) so you can tell a numerical array from a hash. They can both use the same accessor syntax as existing arrays, but $foo =['a','b','c']; $foo['bar']= 'quux'; should be a warning about casting an array to a 'php array()'
But in C you have to define and return a struct to return multiple values no? I feel that's a worse workaround (unless there's a newer/better way of doing it that I'm not aware of)
Fully agreed on this
I think it'd be cool if there was something like iPython Notebook for php. 
Java has a ton of cool features but mandating using all of them creates the mountains of Java boilerplater we have to look at when working on Java programs. I blame the deluge of Java annotations (example: aspects) on this cruft. Annotations are optional! Optional solutions for "sometimes a problem" is what I would like to see more of. I'm not sure if you were talking about static typed features or just the deluge of DI and enterprisey discussions, which I loath.
on a somewhat related note, I'm psyched about 5.6's variadac functions.
Lambda expressions. PHP currently supports closure but with an extremely verbose syntax. Coming from C#, lamda expressions are something you really miss after having used them. Also list comprehensions become a non issue when combined with a fluent interface. Hack already supports these through the ==&gt; syntax. $collection-&gt;map($x ==&gt; $x * 10) 
That would make my day. 
a little late for that...
what, using that stupid `self` parameter? which causes nothing but confusion the first time you see "got 3 parameters, expected 2" when your call is `obj.method(x,y)`. or do you prefer that it's decorated with `@staticmethod` instead of an actual keyword?
what singleton pattern in PHP? there have been plenty of times I've wanted to initialize static member variables but I couldn't because they're not constants.
This. It's not used widely, but {} is already reserved for arrays/strings: $a = ["foo", "bar"]; echo $a{0}; $b = "foo"; echo $b{0};
Agreed on the last two, but instead of the "array of" thing, I think proper support for generics would be better.
Really? THIS is #1? There are plenty of good languages with without this feature that can be used for web applications. This just illustrates how narrow and short sighted you people are. This community is a constant disappointment. 
Why? And you could always typehint in phpDoc if it fails.
You've obviously never ran across a gem like this: $cHandler-&gt;CreateReportEx($this-&gt;psReportName, true, true, false, false, $this-&gt;piExportType, false); I'm not saying named parameters solve every problem, but if I can't limit the world to two parameters, this is my second choice.
Exactly. This is what PHP is lacking most right now.
http://www.phptherightway.com/pages/Design-Patterns.html#singleton
better run-time performance
I agree. A standard syntax and a coherent functions naming and params order. Fully OO primitives. And since everything is moving fast here, start introducing some concurrency notions.
 function dothis( $arg ) { echo $arg + 5; } dothis( $watchacallit = 5 ); &gt; 10 - function dothis( $arg ) { echo $arg + 5; } dothis( /*watchacallit*/ 5 ); &gt; 10 But yeah, with named parameters you may change the order. So maybe the function should take a relational array of parameters instead. function dothis( $args ) { echo $args[ 'num' ] + 5; } dothis( array( 'num' =&gt; 5 ) ); &gt; 10
I've never worked in a language that allows me to heavily utilize lambdas, but I've been using doctrines ArrayCollection a lot lately and it has really makes me appreciate how useful lambdas are (as well as desperately wanting true generics). 
Design and consistency in place of arbitrarily bolting on whatever language construct is deemed indispensable this week.
Traits
nooooo. Not here.
More effort on GTK/QT bindings, because I'm the kind of mad man to make GUI applications out of PHP scripts (no really, it's easier to hand some automation scripts to non-programmer team members if they can use a GUI rather than the command line.)
&gt;..how narrow and short sighted you people are... That is pretty much required traits to like, or even to be tolerant of php...
method overloading. I want to be able to load a user by making two methods: function getUser(String $email){} function getUser(Int $userId){} and then php figures out which method to run, by looking at the parameters. Nore more of this getUserById(), getUserByEmail and all that...
How can this post upset you this much lol
isnt 7/NG supposed to take care of the third point?
&gt; indispensable this week... And abandoned in the next, because 'it doesn't make sense anymore', you know.
Good luck! :-) 
I think having both wouldn't hurt each other (ArrayOf's scope is narrower, but simple and powerful enough to justify its addition). And AFAIK it was about to be accepted if a faster implementation would have been ready, whereas I don't see internals considering generics in the near future given all the things they are involved in with PHP7. I stopped thinking about impossible additions a long time ago, but if we are dreaming a bit, I agree that generics would be a great addition, and also typed class properties. In fact, I would be using Hack if it had PhpStorm support and I trusted Facebook a bit more...
A sensible standard library design...
Pretty much...
&gt; ability to cache data locally between requests (Aka .NET's application variables). ie not have to use memcache (or similar) and copy / re-create all data for every request Have you looked at http://php.net/manual/en/intro.sem.php?
For what it's worth, Facebook's Hack has this in the form of "shapes". They're like associative arrays (or Maps in Hack) but the values are typechecked. 
Noooo. Composition over inheritance, every time. 
&gt; I stopped thinking about impossible additions a long time ago, but if we are dreaming a bit, I agree that generics would be a great addition, and also typed class properties. In fact, I would be using Hack if it had PhpStorm support and I trusted Facebook a bit more... I fully agree with every single word here :)
JetBrains have an open task to implement support for Hack in PHPStorm. Last I checked, it was one of the highest voted feature requests. Hack is fully open source so it can always be picked up by the community if Facebook drop it. It's not going to be dropped any time in the near or mid term future though, giving the enormous amount of Hack code Facebook have. Disclaimer: I work at Facebook, I'm a frontend JavaScript developer though so I rarely write PHP/Hack. 
How would this be expected to work with dynamic typing, would it resolve the method depending on its parameters at runtime? Besides being slow, I think that it would cause annoying bugs as I doubt you would expect: $obj-&gt;method(1); To call a different method than: $obj-&gt;method('1'); Or even: $obj-&gt;method(1.0); I know scalar type hints have not been implemented yet but I believe the two could not be mixed due to PHP's type juggling. I do like the idea of method overloading but I guess if it were to be implemented, scalar typehints would have to 100% strict.
Is there a particular reason you're opposed to learning both?
Why is this an either/or question? If you want to learn Node, learn Node and if PHP pays the bills, use PHP to pay the bills. It's not like you have to make room in your head for additional languages or anything like that; you really can know more than a single programming language at a time.
Hopefully this year we will have PhpStorm support and we will face the final choice: [Facebook-business-driven decisions or retarded-but-democratically-voted ones](http://i.imgur.com/ounym.gif). (joking, both are doing a great work, both have downsides, but it's impossible to agree 100% on something) BTW, why didn't Facebook invest in a plugin for PhpStorm? I know many developers prefer it over vim/emacs, and it's a deal-breaker for everyday usage.
We have [our own web based IDE](https://www.youtube.com/watch?v=UCR4Ac6z_l0) with integrated debugger and profiling tools :). A large number of developers use it (although some use vim, emacs or Sublime Text). Last I heard, it was eventually going to be released. There's still a lot of Facebook-isms in it so it may be a while until a public release. 
On understanding JavaScript more: http://ejohn.org/apps/learn/ But good question by the way. I used to want to learn Rails (which using Ruby, I thought would have been a lot more productive to use than PHP) when every job seemed to demand PHP. I just ended up learning PHP and forgetting about learning Rails despite being interested in it. In the end, PHP is a good language with lots of support and Rails' popularity wasn't increasing as fast as I thought it would anyway. You have nodejs here though whose additional merits are not needing to learn a separate language for client/server side programming, and that the I/O calls are async. I would say go for PHP if you feel like paying the bills is more important, and you will learn a different server-side language when the time comes.
&gt; Then here comes Javascript, __where I have very little knowledge about.__ Discerning for any developer. JavaScript is so basic, and so widely used it should be akin to knowing HTML. It's a necessity. &gt; I really want to learn Node js so bad because it is the new thing I laughed so hard. Thanks. The only advice that you should take, is keep doing what you're being paid to do. If you're being paid as a PHP developer, well, you have to pay bills, right? There's no reason why you can't learn Node in your freetime, though.
i use a getUserBy($fieldname, $string) {} I guess this have the same use?
could you show an example for this?
What does it do? Seriously, I read the readme, and I have no clue.
doesnt even explain anything, just links to github...
 &lt;script type="text/php"&gt;
 public function __clone() { parent::__clone(); $this-&gt;childClone(); } The above is a perfectly reasonable manual call to `__clone()`. Note that this was also allowed before my change. I don't know why you'd want to do `$this-&gt;__clone()`, but given that it's practically the same as `self::__clone()` (which is allowed) the point is kinda moot. Basically, it comes down to this: Either we disallow direct calling of all magic methods, or we allow it for all of them. We chose the latter behavior, only `__clone` was left behind, because it was introduced early.
White page on a php script typically is due to an php error that is surpressed in the http response, check the logs would be my answer.
STOP! PHPNG is and will not be 5.7. It was (since it no longer exists as it has been merged into master branch) the basis for what will be released as PHP 7. Remove the 5.7 version from your systems IMMEDIATELY - there may well be a PHP 5.7, but it will NOT be based on phpng - it will be a standard iteration based on 5.6. The early *development* branch for phpng did have 5.7.0-dev in the version, but only because at that point the developers did not know what it would become and it was considered far too early in development for them to care enough - they never expected anyone to be insane enough to be trying to put this *development only code* live. Further more, phpng has NEVER been released in any form that should ever be considered suitable for production systems. Attempting to provide it as such is doing a disservice to your customers and the PHP community and will only cause unnecessary confusion and strife. I implore you, on behalf of the PHP community, DO NOT offer phpng (the branch itself is now dead as it has been merged into master - what will be PHP 7, but not for a significant amount of time and before significant changes have been made) in any shape or form, *especially* as 5.7
Before moving to a new version, code needs to be tested with it and maybe fixed to account for deprecations or minor BC breaks. Furthermore many people are apprehensive of using .0 releases. But still, PHP version uptake *is* pretty slow. It doesn't help that you still seem to be supporting PHP 4 and PHP 5.2, which are pretty ancient.
From .NET I like [LINQ](http://msdn.microsoft.com/en-us/library/bb308959.aspx). Thats basically a query language similar to SQL for xml, objects, arrays, and other data sources... class app { static void Main() { string[] names = { "Burke", "Connor", "Frank", "Everett", "Albert", "George", "Harris", "David" }; IEnumerable&lt;string&gt; query = from s in names where s.Length == 5 orderby s select s.ToUpper(); foreach (string item in query) Console.WriteLine(item); } }
Next thing you know and PHP will skip 5.7 straight to 5.8 because some hosts have already put "5.7" (or rather PHPNG) in production… :p
I know, it's just so cumbersome, and it was one feature I really loved when using C#.net...
The languages are just tools you use, and in the end the question is when to use what language. Unlike spoken languages programming languages are very similar, and most have the same concepts. If you know one, you really know them all (at least the imperative ones, judging from PHP). That said never limit yourself to some one language, specially not to PHP alone. Try Python and Ruby, go for a LISP (Clojure is a modern dialect on the JVM), learn functional programming with Haskell, program near the metal with C and try out D and Rust. Theres so much innovation going on in never labguages you can take advantage of. I have seen developers that have lockes themselves to something like Drupal, and have done it for almost 10 years, and they never took the time to learn anything else. DONT MAKE THIS MISTAKE. Always learn.
&gt;I don't know why you'd want to do $this-&gt;__clone(), but given that it's practically the same as self::__clone() (which is allowed) the point is kinda moot... No, the point is the user cannot use the usual semantics to call the clone method. Does allowing type casting render static typing pointless? And you are not addressing the fact the clone behaves differently from other magic methods as I mentioned in my comment....
https://wiki.php.net/rfc/abstract_syntax_tree , &gt;Directly calling __clone is allowed &gt;Doing calls like $obj-&gt;__clone() is now allowed. This was the only magic method that had a compile-time check preventing some calls to it, which doesn't make &gt;sense. If we allow all other magic methods to be called, there's no reason to forbid this one. 
PHP is already a collection of other languages' _best features_, what PHP do need, is better identity. Right now it feels like many languages being duck-tapped together.
Not before every one had a 2 week long "discussion" over it...
It's a pretty typical example of how PHP devs think about types. It annoys me to be honest. How come something that is a String or an Int can be FALSE? What is a false string? What's false about it. It would make sense to use NULL (=no value assigned) in these places or "correct by type yet incorrect by meaning" values like $userId = -1 (which is most likely unrealistic) and $email = '' (empty string that an e-mail address cannot be)
unlucky 8
Care to elaborate why you can't use traits for that?
In Nikita's AST doc, he stated: "List comprehensions / generator expressions where the result expression comes first, e.g. [x * x for x in list] in Python. In PHP only the reverse syntax is possible: [foreach ($list as $x) yield $x * $x]" So with the new AST in place, it would be possible to implement Pythonic list comprehension. I do admit that the way I remembered it was that it was already an RFC itself, rather than a possible future result of implementing the AST. 
You cannot instantiate a trait I have object a, object b, object c, and I want an object d that extends a,b,c while all of them are useable. With traits it is less elegant. But whatever, apparently I am the only one :)
I think it's much more common nowadays to see folks using null in these cases.
There are many types of people in this world, and it pays to figure out which kind you are. (Not that you can't change, but...) Some like learning because it is awesome and doing stuff that other people want the way they want it is a chore. Others like getting things done and getting paid, regardless of what it takes. If you are the prior, tackle the hell out of the PHP project. Get it done as fast as you are able. Then get to learning Node. Don't allow yourself any time w/ anything else until it's done and done well. Then, maybe, do the same project in Node, or something similar. Compare and contrast. I think programming is fun, but not necessarily so when someone's breathing down your back.
To be fair that situation *does* exist in other (good? Opinions) languages (C++, Java) and it is usually solved by the IDE. It is a pretty big problem for me in PHP I will admit, but mostly because I am notepad++ pleb. I prefer IDE solution because it is way less verbose when you're actually writing code. The guy above who suggests comments/arrays has a point, too. It solves the issue just fine. So I would say I'm conflicted but I mostly agree it shouldn't be the most desired feature, in my opinion anyway.
Sorry, I don't get how `__clone()` is different from any other magic method, like `__construct()` or `__destruct()`. All magic methods are automatically invoked and should usually not be manually invoked. What makes `__clone` different?
Official support for annotations. Enough of these comment annotations already!!
And how would having tuples fix that alleged problem?
I'm not sure that this is an abandoned idea or something which just went under the radar since it's introduction.
A lot of this is incomplete, misleading, or incorrect. From the whole thing though, this is the worst offender: &gt; Tip 10:Password Security &gt; $salt = 'SUPER_SALTY'; &gt; $hash = md5($password . $salt); This alone should completely dispel any illusion one might have that the author has any credibility with web application security. Blog authors need to stop trying to put themselves forward as something they're not. If you want to write about security that's fine, but do your homework and cite/link to credible sources.
if you don't have PHP 5.5 you can also use: https://github.com/ircmaxell/password_compat if you have less than 5.3, then upgrade, you're using an EOL version. (That should probably be in the list, keep PHP up to date with security patches at least and don't use EOL versions)
And #4 - you should be using a recent (and maintained) version of PHP, where register_globals doesn't even exist any more. 5.3 is no longer maintained and 5.4 is currently in security fixes only mode. And #1 where it tells you to completely disable error_reporting on live. You should never completely disable error reporting - set up proper error handlers to send you details / log errors that occur on live. Your users will run into errors / bugs that you never encountered because they have all kinds of crazy browser versions and try to do all kinds of crazy things (and that's before you even start considering those are are actually trying to be malicious).
What annoys me is this article is 'new'. So when a new article is advocating the use of MD5 + salt, as the best way to secure passwords, the credibility of the author goes out the window. PHP is bogged down by to many 'experts' who feel they have the necessary experience/knowledge to publish blogs in an authoritative manner. They may think they are helping, however they are actually hindering progress. Leave the teaching to people who are genuinely experts. 
Consistent needle/haystack for built in functions, consistent naming for built in functions and built in functions throwing exceptions rather than the current error behaviour.
Full Unicode support without hacks.
PHP's scoping is terrible, the global thing is a hack. Just make the scope like C/C++. 
keyword arguments. $derp-&gt;makeIceCream(litres=4, flavour='chocolate'); I frequently see people getting trapped into adding more and more options to the same function to toggle different pieces of functionality and then having to pass the parameters in between manually. e.g. $derp-&gt;makeIceCream(FALSE, 4, 0, NULL, 'chocolate');
Yea thanks captain obvious. I Know you can return an array but not that's the point. It would be shorter to do it if it was natively built into the language like so: function makeMagic($x) { return $x, $x * $x; } $a, $b = makeMagic(3);
I was keen on this until I just decided to start writing more functions that take 1 argument that is an assoc array of options. Now that we've got the [] syntax, it's just an extra two characters really. And you get the benefit of having access to all the existing functionality to work with arrays. Would there be any advantages of named parameters over just using an assoc array? To me it just seems like an array but with much fewer features, and more limitations.
&gt; use func_num_args() and func_get_args() to detect what arguments were actually passed and what type of variables they are Though they are useful functions, no need for func_* in this case: function getUser($userIdOrEmail) {} And simply do the type checks on that.
As for the first, hope to play with [Ratchet](http://socketo.me/) soon..
Don't do what Donny Don't does.
&gt; What makes the one more "formalized" than the other? I'm pretty sure there's a more compact structure than an array. The Array interface isn't necessary for a tuple, for example. You wouldn't want to be able to modify a returned tuple anyway.
i like!
While I agree that method overloading is amazing and sorely missed in PHP. In the meantime, you could use the **is_int()** and **is_string()** functions within your getUser function. So, it would be like this: function getUser($identifier) { if(is_int($identifier)){ //treat like an int } elseif(is_string($identifier)){ //treat like a string } } Not a great solution, but still solves the problem.
You could, but then IDEs and such wouldn't give you any insight that $foo is actually usable in the first place. The __get() stuff is error handling, although useful. It shouldn't be much of a 'performance' hit - any code caching/optimization system should be able to figure it out in the first place. Groovy compiles the code down to each class having automatic get/set methods for each member variable in the first place, so all calls to -&gt;foo get compiled to -&gt;getFoo and -&gt;setFoo anyway. Having a way to do that last line you wrote - putting in get/set methods that don't match the property name - would introduce more overhead (I'd think) than just always looking for a standard getFoo/setFoo pattern. 
&gt; During development, this makes code readability so much easier. That is true, but it is *only* true because the distinction matters. In a language that could offer overloading it would be a non-issue.
but anyway you should't have too many arguments in a method.
actually using phpdoc correctly, IDE's would be able to the correct insight (PHPStorm does atleast) [From the PHPDoc website](http://manual.phpdoc.org/HTMLSmartyConverter/PHP/phpDocumentor/tutorial_tags.property.pkg.html) * @property mixed $regular regular read/write property * @property-read int $foo the foo prop * @property-write string $bar the bar prop
I _love_ lambdas, but the verbosity of syntax is less of a concern to me than the Zend engine's ridiculous amount of overhead for calling a function. HHVM has way less overhead, so whether you're on PHP/HHVM with the verbose `function($x) { return $x * 10; }` syntax, or hack/HHVM with the lambda operator, it's way more feasible to use closures everywhere. As painful as it is to admit, I'm almost glad the syntax is as verbose as it is, if it means I'm less likely to rely on a library built with horribly-performing closures. Ideally I would want to see both lambdas and those engine improvements come in at the same time. Here's a simple test I ran comparing PHP/Zend with PHP/HHVM, where I go through a 100,000 element array and simply assign its element to $a and microtime each. The extra overhead for the function call is massive on Zend, but not bad on HHVM: PHP 5.5 Zend foreach time: 0.00943922996521 array_walk time: 0.26015782356262 Array_map time: 0.29104089736938 HHVM 3.2 foreach time: 0.0015268325805664 array_walk time: 0.018699169158936 Array_map time: 0.0057330131530762
I can't tell why you are being downvoted, LINQ is AWESOME in C#. However the query syntax is kind of ugly IMO. I prefer the other way. names.select(n =&gt; n.length==5)
Is it really being a "captain obvious" or just using the language features to closely recreate a feature that's available in some languages? IIRC, you can't return multiple values in C without the use of structs or arrays/vectors. As a PHP developer, you learn to compensate for the languages lack of certain features, but not by a large margin. I love list comprehension in Python or multiple returns in Go. Would I want to have them in PHP? List comprehension yes. MRT? I already see it implemented by using list() and plenty of other languages don't have it implemented at all (C, Javascript, etc).
Completely agree, and that's similar to how many js functions are written as well, except they pass in an object instead. The `array` structure, while confusingly named for those of us who come from the C world and expect it to be a block of memory with a type and a pointer to the start of it, is the heart and soul of so much good PHP, and the engine is highly optimized for it. To me this is easy to read and write: sendReminderNotice([ 'name' =&gt; 'Josh', 'message' =&gt; 'Spend less time on reddit', 'when' =&gt; 'now' ]);
I kinda agree in principal that you should keep the number of arguments to a minimum, but there is a very legitimate need for keyword arguments where the are a large number of things that could be customised. You basically have two options: 1. Pass in an array of 'options', e.g. `makeIceCream(['litres'=&gt;4, 'flavour'=&gt;'chocolate']);` but that's not ideal because you then have to implement default values and more argument validation into the function body and it's not possible to do static analysis, type hinting or auto-completion etc. straight out of the box (e.g. so it just works in your IDE). 2. Use objects, `$derp-&gt;makeiceream()-&gt;flavour('chocolate')-&gt;litres(4);` which isn't too bad to look at syntactically and supports static typing etc. but also gives you the overhead of having to define yet another function for each argument along with a class to wrap the parameters. The second one is probably the better option and is how I'd refactor code to look like when the number of variables increases, but keyword arguments still have their place.
Interesting, although it's a helluva a lot of extra ceremony to add vs the language supporting the behavior in its core.
In Perl, you could do the equivalent of: doSomething(Array("name"=&gt;"Alexander","action"=&gt;"Be Great")); ... and use the array as named parameters. I haven't tried any of the newer PHPs, can arrays be created in function calls like that now? 
But without breaking backwards compatibility. /s
Personal preference, really. They are clean, and they work. 
Fucking Hell! I read that whole pull request and have never seen so much hate for something that was trying to improve the understanding of Design Patterns. In my opinion, if a developer from outside the laravel community saw that the facade pattern was used incorrectly, in a framework of that size, then they might think twice about using that framework. This would then lead to less, not all but less, pull requests. Then again they may not. Still doesn't excuse the backlash to a single pull request! * edit - typos
the methods would have to use scalar typehinting, obviously, but i dont think everything would have to. If it didnt, the method overloading would just not work.
Or Java haha. Yeah, i dont like using those methods. It makes the method end up being huge.
Does anyone know when this version is expected to come out? As in be main stable release? I'm keen to start using Laravel, but would rather wait for this version to come out before I start, as it looks like a lot of the structure is being re-arranged.
What do you mean? I find if (preg_match("^\d+$", $some_var)) do_stuff(); to be pretty clear.
what's the prob with learning both?? " I really want to learn Node js so bad because it is the new thing" &lt;-- Just because *its the new thing* doesn't mean that it will survive for a decade or so.
The big advantage of named parameters over just using an array is type hinting. Granted, this is somewhat less useful without scalar type hinting, but that is coming eventually.
That's the thing I like the **least** about preg_match(). preg_match("/(\w+):(\w+)/",$input,$matches); seems MUCH less intuitive/readable than this: ($one,$two) = $input =~ /(\w+):(\w+)/; # Perl
What would you want it to look like?
This post tries to advertise something, but ended up exposing it's poor decisions were no match for its clients.
Sure, but python does it for example, so I thought I was allowed to fantasize about it, apparently not.
This... I'll use an array but really, being able to type hint AND vary order would be wonderful.
Same here.
Don't mix up intuitive with familiar. I'm not familiar with the perl and that doesn't not look intuitive at all. The php method call makes it obvious that this is a regular expression, even if you don't know what a regex is you can look at the documentation and get a value understanding. Whereas in the perl example, now I'm trying to google `/(\w+):(\w+)/;`.
Not sure, I tried asking the author of the RFC about the matter in [this thread] (http://www.reddit.com/r/PHP/comments/2ejm7c/rfc_abstract_syntax_tree_ast_accepted_for_php_7/ck05cvt)...
Should rename it to "cuddle".
If you're Googling the actual regex itself, then neither syntax is going to be intuitive to you, as you don't even know what a regex is/does. If you don't know what something is/does, you can't have an expectation for how it should be represented syntactically, now, can you? :-p
http://pastebin.com/9q9X0699 that is the thing
Have you tried classmapping or autoloading your local package with PSR-4? I'm not 100% sure if this works with directories several levels up but I do it all the time for things I'm building inside the repo. For instance, say you have a library you're building within the "DGoat\AwesomeMVC" namespace and it's located at... /home/dgoat/projects/libraries/awesome-mvc/src/AwesomeMVC Then you have an app that you want to use it from located at... /home/dgoat/projects/test-app/src In /home/dgoat/projects/test-app/src/composer.json, you can (I think) load your library like this... "autoload": { "psr-4": { "DGoat\\AwesomeMVC\\": "/home/dgoat/projects/libraries/awesome-mvc/src/AwesomeMVC" } }, And the relevant documentation link... https://getcomposer.org/doc/04-schema.md#autoload
Honestly I haven't seen anybody use the @version tag in a while. That said, you'd bump it manually like any other version bump. The way to do that depends on your workflow. One of the more common right now is [git-flow](https://www.atlassian.com/git/workflows#!workflow-gitflow), in which master always reflects the latest release and development work happens in another branch, usually 'develop.' When you're ready to tag a release, you'd cut a release branch from develop, make any final adjustments (including bumping version numbers), and then merge the release branch to master. The new tag is then cut from master, which has the versions already set. Of course that's only one workflow, but the basics are the same in all of them: you'll have to bump the version numbers somehow before you tag the release.
Fixed.
Sounds like your on the right track! I would recommend looking at phpcs to enforce syntax conformity - I have it as part of the build/test process so that builds will *fail* if the syntax dose not conform.
I downvoted your post because: 1. You seem to have done little to find out what an undefined index means, and don't put any effort into providing helpful information such as what you expect to happen vs. what happened instead, etc 2. You pasted a large block of code without any formatting whatsoever, and either didn't bother checking after you submitted it or didn't care and expected us to spend time and effort formatting it. Your only explanation is "this is the thing". Not very helpful. 3. /r/php is not a support subreddit, which you should have read in the sidebar This post gives me impression that you care very little about making it easy to help you. As such, I care very little about helping you.
Duh. I got confused from a basic actor implementation the other day. Explainations kept saying "Messaging queue" but really it was a deque/double ended queue - push to the left/bottom, and pop from the right/top. Still not too bad despite never actually building either myself. 
True. Despite being a Python guy, I lurk here because PHP was my first love. Though, I tend to stay in trouble here because of it. :/
That looks fantastic, thanks for the tip. I hadn't heard of that before.
Well, there's the implication that you could also have different numbers of other parameters depending on how you were calling it. getUser('david'); // by name getUser(13, true); // by group and is_creator status 
Well I don't anticipate it to happen overnight, but I would like to have this running by the end of the year. Thanks for the feedback!
I've been using PHP since 1996, and to the best of my recollection this has been possible that entire time.
Video states: * annotations lead to magic and magic is bad * [Command pattern](https://en.wikipedia.org/wiki/Command\_pattern) creates a common interface * that re-factoring (in his example) with lambda expressions can solve DI
To clarify, your build process should build an all-in-one zip version, but you should also put the project on packagist for people to use with composer. 
Agreed. Thanks for the comment.
I'm sort of neutral about, having never used it, but I know there are people out there who consider multiple inheritance a bad idea.
Hmm, well, only one of those really relate to annotations.... And its only magic if you don't understand it. Nothing "magic" is happening in the core. Thats like calling events magic. But thanks for the rundown!
Martin fowler wrote a [good article](http://martinfowler.com/articles/rake.html) about rake, and contrasts it with ant. I believe that Phing is very similar to ant, so you might find the article of interest.
Take this a bit further and you don't need to declare function params at all ;-p I'm all for named parameters, but in their absence, I'll take readable code $0.02
I don't know if you're hosting JIRA yourself but if you do, you can also buy Stash (if you're using cloud hosted JIRA you can still use Stash). It integrates with JIRA extremely well, for example: you can create a new branch from JIRA, set certain requirements before a branch can be merged back into master (such as the number of reviewers that approved the PR) and a whole bunch of other neat stuff. We're using it at work, and it's really good! (Plus only 10 bucks for unlimited private repos).
I meant that `[]` are already used for associative arrays as of 5.4; we can't really go back on that now. But you're right, I guess `{}` is used too, although it's conceivable that it could still be differentiated by its context.
Last time I checked too, as you'll see in these numbers from an earlier comment: http://www.reddit.com/r/PHP/comments/2f7t9v/what_other_web_languages_have_that_php_should_have/ck74eop A foreach going through a 100,000 count array was about 28x faster than array_walk, and it's not a trivial microoptimization either: my execution time was 291ms for the array_walk() vs 9ms for the foreach.
I've been working on an rspec/jasmine style Spec BDD testing framework: https://github.com/chrisguitarguy/Demeanor/blob/master/test/acceptance/Filters.spec.php you might like the syntax better than the alternatives. Definitely not ready for primetime, however. 
yes, but as I answered elsewhere, that's a very pale shadow of the functionality that's available on other platforms.
I would like array (or [tuple](http://www.reddit.com/r/PHP/comments/2f7t9v/what_other_web_languages_have_that_php_should_have/ck6plgy)!!) argument unpacking without `list`. $values = [1, 2, 3]; $x, $y = $values; // the last element is ignored $x, $y, $z, $a = $values; // throws exception I would also love multiple return values that get converted to an array or tuple whenever unpacking isn't done. function y() { return 1, 2; } $x = y(); // $x is an array or tuple $x, $y = y(); // $x = 1, $y = 2
that looks interesting. I can't see from the site how it handles multiple requests concurrently? (and given how important that is, I would expect that to be somewhere "front and centre") It seems as though it possibly you have a long running request that will block that Ratchet server until that request is completed?
Python's solution feels elegant. As for your last point, it seems to me like both MI and traits can make for bad programming if abused. I'm unfortunately not very experienced with OOP (I mostly work with procedural legacy code) but the whole idea of "hey, as of now you can just plug any code into any class and it's called traits!" seems like it's not the OOP way to do things. It's always seemed like something you should use sparingly but beginners might be tempted to sprinkle everywhere.
Traits and Mixins are more for when you need repeated code across several inheritance paths that don't necessarily make sense in a node further up. I'm sure you're familiar with the concept of an ORM? If not, I'm not sure if I envy you or not. In Python, typically you'll see SQLAlchemy used outside of Django apps. A common way of constructing models is to build a `PrimaryModelMixin` (or maybe it's just me and I'm really lazy) that defines fields common to your primary models - say a primary key called id, a name field, a table name and a few methods only used by your primary models. It doesn't make sense to patch this onto your secondary models. So you can inherit from BaseModel and PrimaryModelMixin to get going faster. As for abuse, Yes. But the same is true of anything. Poor choices lead to poor code no matter the language or application structure. Object programming *is* more than slapping the word `class` in front of a group of functions and calling it a day. At the most base definition, an object is a data structure that has methods for acting on itself or for others to act on it. Object programming is learning to compose a program out of primarily objects acting on each other. Which sounds vague because it is. OOP, and it's cousin Functional Programming, is often used nebulously as if it were magic pixie dust that makes every thing better by virtue of turning everything into an object. 
You need to check for the existence of superglobal values with isset() before trying to access them. You did this with the first post value but with none of the others.
Yeah, for teams that are 10 or fewer, you really can't beat Atlassian stuff if you plan to self-host. If there's heavy use of the products and your team grows to where you need to upgrade to a more pricey license, it's still very much worth it and not at all hard to justify the expense by that point.
If you want to start somewhere with coding standards, first start with the PSR's and build on top after that. For example, at our work place, we decided we want to improve readability by address chaining a specific way we mutually agreed. This is not something that is in PSR, so we're not "breaking" conventions, and it helps to make our code more readable... at least in the office.
For starters it outperforms both extensions, has many more features, development on it is MUCH more active than memcached(where memcache's development has completely stopped), but one of the greatest thing, is you get an admin panel where you can debug things much easier. Considering you have to learn whichever technology you decide on, I would highly recommend to learn redis as opposed to memcache(d). For the basics they've all got pretty similar apis.
Debian/Ubuntu are more popular than CentOS is now for web servers. I'm not saying you are wrong that support in official Fedora or CentOS repos is important, but Fedora doesn't represent the "vast majority of Linux platforms that developers have to work on", stats show that Debian and Ubuntu have been steadily overtaking the most popular mantle over the past few years. Almost 60% of webservers now run Debian/Ubuntu. http://w3techs.com/blog/entry/debian_ubuntu_extend_the_dominance_in_the_linux_web_server_market_at_the_expense_of_red_hat_centos
You should use a proper HTML sanitation library for that. 
Alright.... now I have to find out what a proper HTML sanitation library is....
[If only there were some kind of way of finding things based on supplied criteria.](http://lmgtfy.com/?q=php+html+sanitizer&amp;l=1)
One step ahead of yah. 
The metrics are unconvincing. I don't see this in industry. Some cursory job searches are all that I need. Combined, Ubuntu and Debian come close to CentOS. 
I need to learn Debian. I can tell it's going that way, evidenced by the HHVM and excellent DebCon 2014 Linus QnA.
Do you have a reason other than your anecdotes to ignore the evidence? You surely don't have personal experience with the entire industry, perhaps you are suffering from a selection bias?
do you ever try to use Carbon? https://github.com/briannesbitt/Carbon it make easy to work with time, timestamp, and date manipulation
I'm sure some of us have had the opposite experience. I know I have.
&gt; Do you have a reason other than your anecdotes to ignore the evidence? I don't believe the evidence is compelling. You think it is (raw metrics of webservers). My preferred metric (albeit equal as a metric) is via who is hiring to work on systems. I run machines at a loss (personal projects), but I wouldn't put my indie machines as part of the industry.
Ok you convinced me. I'll check it out.
I'm just really confused right now. These answers are really helpful. Thanks guys.
you should be able to use Carbon to use week calculations from a fixed date... Looping shouldn't be needed... think $today-&gt;("+4weeks") type of stuff...
First problem is the days of the week. We need to write these as more logical conditions. The problem we have is the words "every other wednesday". This means that A shift may have worked this wednesday or next. 1. So lets see if we can figure out a way to get which week an event occurred in. 2. I would try and find a number of weeks since 1 jan 2010. Eg today would be 430 weeks since 1 jan 2010 (at a guess). 3. ROUND(DATEDIFF(FROM_UNIXTIME(your_unix_time), FROM_UNIXTIME(unix_time_for_1_jan_2010))/7, 0) AS weeksgoneby http://stackoverflow.com/questions/3960419/mysql-how-to-calculate-weeks-out-from-a-specific-date 4. Now you have some idea of how many weeks have elapsed, doing a few test, you need to find out if every other Wednesday happens on even weeks, or odd weeks. (OH I see you have this in the second set of bullet points). 5. So now you will be able to write a statement that says, if day is Sunday, monday, tuesday or (wednesday &amp;&amp; weekgoneby is even) Then shift A. else if (day is ... ) To get the day name from your unix time use day(FROM_UNIXTIME(time)) as day which is a number or dayname(FROM_UNIXTIME(time)) as day which is a string. Lastly and most importantly, you need to tell MySql your timezone for functions like DayName as the same unix time stamp in New Zealand can have a different day name, Eg its Monday in the USA, but its Tuesday here in NZ but our unix time stamps are the same. so to do this, very first line after connecting to DB is: R::exec("SET time_zone = '+12:00'"); Or what ever your timezone or timezone name is (it might be set correctly depending on where your server is located). That should pretty much solve it. You should nearly be able to do the whole lot in mysql using Case Statements. But failing that write some code that you can understand. But you will find MySql to be about 10x 100x faster if you can get all the code in mysql. 
That works too in this specific case. I was actually thinking of an instance where you could just do getUser() to get information about the currently logged in user and getUser($someParamater) to get information about a different one, but that's actually a different problem.
My anecdotal experience comes from 15-ish years working in the ISP, datacenter, gaming, and hosting industries. I see an incredibly large majority, roughly 90-95%, of RHEL and CentOS in production. People use Fedora if they want the Red Hat experience with newer packages and tech, but that's rare (and quasi dangerous). They use Debian if either they're more inclined towards the Debian way of doing things, have GNU and GPL leanings, or are required by their app. I see a little more Debian over Fedora. I almost never see Ubuntu servers. The ones that I do are usually run by folks that learned desktop Linux on Ubuntu but generally have no idea what they're doing server-side. Every now and then I stumble on a Gentoo or Arch machine in production. Most professional orgs I know go with the CentOS "sure thing" or RHEL if they need the support help or have the money to point a finger at someone in case something breaks. FWIW I prefer FreeBSD in production but use CentOS when the powers that be want to standardize on Linux. You silly children with your Linux toys. Get off my lawn.
TIL: Less than a year is 'long term'.
In most cases: you don't use it WITH PHP, you use it INSTEAD of PHP. They fill the same role: server-side language. That said, they *can* be used together, but why would you want to? (Seriously; if you have a valid use case maybe someone knows a way)
You're probably looking for a front end JS framework like Angular or Ember. That's something you could/would pair with PHP for the back end.
No prob with fantasizing:-) 
I guess you could use this to host PHP in a Node server, but I don't know why you would want to. http://www.digitalcoding.com/open-source/JavaScript/php-js-PHP-JavaScript-interpreter.html 
looks great!
Same here.
wat.
I want to cache (memory only is fine) multi-dimensional arrays. Redis wants to cache specific types of objects (strings, arrays, etc), how would I cache an entire multi-dimensional arrays in Redis and fetch it back in to a usable PHP variable?
Nevermind I figured it out. Serialization is not enabled by default? I enabled it, and now it works great.
First, don't be clever. Clever is hard to debug. This is actually a *great* situation for using test-driven development. You can start with the easy cases (ie, days that are neither Wednesday nor Saturday) and get more complex from there. The challenge is to make your problem space small, fast. 1. Eliminate half the possibilities by examining time of day. 2. Examine day of week. You now have your answer in 6 out of every 7 cases. Now here's where it gets interesting. Fortunately, Wednesday daytimes are predictable. Always C, A, C, A, C, A. Saturday evenings are also predictable. B, D, B, D, B, D. The clever option here would be to then take the timestamp in question, and resolve it to the preceding midnight, then subtract the midnight of both possible shift references. One of them will modulo 14 days with a result of zero, and that's your answer. But that's the clever way, and without clear function and constant names, you're going to hate debugging that if it ever comes up (if you don't have a comprehensive suite of unit tests). So we'll look at it in a somewhat more programmer-friendly way. Use PHP's date() function to derive the week number for both the reference points (which you'll keep in the code as constants) and the shift in question. Take those week number, and take modulo 2 of them. Whichever reference point matches the time in question is the shift where the problem occurred. If you need some cleverness, and/or microoptimisation, feel free to right-shift the week number one bit instead and take the output of that. A caveat, though: this may not work well when rolling over years, and will certainly eventually fail on you. No loops needed, just tests and math. \* To paraphrase Knuth, "beware of bugs in the above pseudocode; I have only proved it correct, not tried it."
Sadly, automatic (**and silent!**) conversion of dots to underscores is a major wtf in PHP even today, maybe it could be fixed by an RFC for PHP 7?
I think they told you to use javascript together with PHP, or learn both, using them each on different projects. Not on the same one.
Hey there, We use PHP and Node where I'm at. Most pages are rendered with PHP but we're slowly moving towards Node. Both are there because we're in transition. We started moving because we needed NodeJS for Engine.IO support. AFAIK, PHP doesn't handle this too well (yeah yeah ReactPHP, but we need something stable). Then we started using ReactJS on the front-end, and there's no packages to generate those in PHP... except to use the PHPv8. Which is silly. So, that's why we're moving. IMHO, don't use both unless you really have to. It gets messy real quick. 
And yet "Mac OS X installation is currently EXPERIMENTAL and UNSUPPORTED."
http://www.troll.me/images/xzibit-yo-dawg/yo-dawg-i-heard-you-like-scripts-so-i-put-a-script-in-your-script-so-you-can-script-while-you-script-thumb.jpg
I think Riak here is a bit different, a lot more complex software than Redis or Memcache
Loops are fine. You dont have to loop through everyday, though. You can just jump weeks passing strings like 'next sunday', next saturday' etc.. Write 4 functions for each shift to accept reference dates and return intervals for that shift till today. Write a fifth function to see if the timestamp falls in any interval in the previous returned array of intervals. Combine those and you are done.
This seems a very useful thing to me. Just a few days ago I was developing a REST API client, and since I don't have a sandbox to play with (only production API), I generated curl commands manually in order to see what exactly my client is about to send to the server.
Great news! I've been debating if I should run my next big project on HHVM but have been a bit weary about running a nightly in production.
For your SVN to git migration, give svn2git a try: https://github.com/nirvdrum/svn2git I converted over a dozen production projects to git using it, while retaining full commit history and authorship. I can't recommend it highly enough.
Huh, I know there's some situation in which you cannot simply define an array in the argument list to a function call, though I can't for the life of me recall what it is. 
Perl may be many things, but readable it is not - it is the prime example of a [write-only language](http://en.wikipedia.org/wiki/Write-only_language). 
Every time someone links to that goddamn load of shit known as the "fractal" I want to drag that fuckwad out to a secluded desert, put a bullet through their head, wait for forensics to extract the bullet from their liquified brain, break in and steal the bullet from the evidence locker, melt it down into a new bullet, break into the morgue, and finally blast that bullet right through their fucking skull again.
I use node as a build server.
This kinda describes the situation that I am in. My current plan is: - set up [GitLab](https://about.gitlab.com/gitlab-ce/) &lt;-- should be done this week - fix the infrastructure for development/staging environments - implement some deployment And then the next step wold be doing something about the disaster that is out current codebase .. =/
My anecdotal experience - the last two companies I worked at (an online retailer and an ISP, both with several million customers) used Debian. My current employer (bricks and mortar retailer with ~50 stores) uses Ubuntu 12.04. Never worked anywhere where they used Fedora.
true. but still if I were going to use it I'll go for https://github.com/symfony/Yaml. Less Lines of codes. btw, YAML seems not specific to symfony: http://www.yaml.org/about.html 
Thanks for the tip re Stash. We do self host JIRA, but I think we would prefer to have our source hosted in the cloud - I think at a management level this would be easier (especially when working with external teams).
We had this exact problem with JIRA!
Thanks, will take a look!
Cheers for the tip - have you tried the tool recommended in https://www.atlassian.com/git/migration#!migration-prepare - if so how does it compare?
here is my one-line framework. &lt;?php exit('This text was generated by the awesome one-line framework') ?&gt;
The memcache driver natively and intelligently handles PHP serialization; internally it only stores plain text keys and values. Redis supports other data types, which can often be quite helpful, but if you absolutely need to store something more complex or custom (like a PHP object, for example), you should serialize it yourself and store it as a string. For a multi-dimensional array, you could also consider JSON encoding the value. 
Redis and Riak both have many more features and configuration options than memcached. 
Have you considered adding support to something like [PHPIDS](https://github.com/PHPIDS/PHPIDS) filters? Making use of those filters you would get much broader set of detection rules.
Well, over here we're using JIRA for more all project management (both development and other kinds of project) so we're at 8 users.
Sorry, that's shit. Configure it to fix the syntax, not to fail; that's the most obnoxious thing it could do.
This is great news. Although rapid development is useful, application developers need long-term support in their platform to do their jobs properly.
Well, it's all relative. This is longer-term-than-before :)
PHPIDS filters looks very good. I opened an issue to add more filters. Thanks for suggestion!
I found the concept interesting since I have also been playing with a few ideas for a mini framework. How do you handle route parameters? It looks like you only match exact strings like '/films'. What about '/films/123', '/films/124', etc?
It's pre-compiled.
Among other things Node is pretty good for long running processes, which php typically doesn't do too well. So you could have your main app in PHP and your daemons in Node for instance.
This must be a joke right?
array performance is a bottleneck on my application with a lot of services the HHVM is almost 50% faster on our internal benchmarks
&gt; I'm creating a PHP application that is targeted towards users that have shared hosting or might not know how to use Composer. Should I still use it, or should I just bundle the dependencies in? The licenses for them say that it's OK to include them with the application. I read that as "I'm building a PHP Application that other people will install on shared hosting. Do I package it as a composer package and let Composer handle my dependencies, or do I simply bundle in all of my dependencies and let people download everything raw." Installing composer isn't really an installation. Running the composer install command simply downloads things into a folder.
I hope the author doesn't look at lua arrays next, he'll have a heart attack. :)
Indeed, this is minimalistic though If you want to handle such URLs, you'll have to use GET parameters and URL rewriting
How I just *LOVE* open source's knack for naming.
Thanks for this feedback. You're right for dependency injections. Plankton is not handling all features of an actual framework anyway, but it's handling as much as possible, keeping the core footprint really really small (a few lines of code). The thing is to do the more work as possible, even if some improvements are obvious. (Lazy loading, Dependency Injection, URL matching etc.). The question is: how can I work in an environment that looks like a big standard framework without having the white elephant of it? So, for instance: why having a dependency injection system where a simple array() can do most of the job? Thanks for extract() improvement https://github.com/Gregwar/Plankton/commit/bff192401eab667fdd140b587414695243842875 I actually don't know the overhead of including all the files, specially with APC &amp; so installed
&gt;So, for instance: why having a dependency injection system where a simple array() can do most of the job? The dependency injection will make sure everything's loaded when it needs to be instead of loading EVERYTHING when maybe you'll only use 1 thing
You can already do all of these, essentially. There's no need to use the defined variable (altho I generally consider it a bad idea to completely ignore exceptions - generally they should at least be logged somewhere), and since all Exceptions (should, ultimately) extend \Exception, you can catch any exception with "catch(\Exception $e)" (again, this is generally considered bad code - you should only catch exceptions you expect to happen, unless you're doing something specific like logging / notifying, otherwise you can trap exceptions you didn't expect and hide bugs / problems). Adding more ways to write exactly the same code just adds unnecessary complexity to the language, and can make written code harder to read.
Using an array is a Service Locator, not DI. See an earlier post this week for attempt to make it easier for a developer to see and control the workflow of an mvc/app (at least there are interfaces).
Could you give me a case where you don't use the variable in the catch block like did in line 5? Also how would you handle the exception that is caught in line 9? There is a reason why you catch Exceptions, and that is to log them in production or display them while you are developing. They are called Exceptions for a reason.
This is as classic a response to 'bloat' as it gets. The problem with this framework is that it doesn't actually do anything. The point of a framework is to make common tasks easier and to abstract implementation so it doesn't need to be repeated. This doesn't really do any of that. No shorthand for escaping output, no helpers for validating input, no easier way of handing incoming URL parameters, etc etc etc. This code separates concerns of the view versus logic, which is the first step toward maintainable code, but now the next step of code duplication is still going to occur when the same logic needs used in multiple places, ways, etc. Once the amount of logic in the application reaches real-world levels of complexity or simply quantity of things being done the lack of more helpers and task simplification is going to greatly increase the amount of code duplication and also reinventing the wheel of things that are already in many of the 'bloated' frameworks. Another person has already mentioned Dependency Injection but I want to expand on that for a moment. Dependency Injection is more than a object or class or framework, it's also a design pattern. It's a way of asking for what you need instead of looking for it. It's a separation of objection creation from object usage to encourage code reuse. The slides I used for my DI Design presentation can be found here, if you're curious: http://zimzat.github.io/di-slides/
You mean like a finally block? Not sure if that's what you're after but seems like it may be what you're describing. http://php.net/manual/en/language.exceptions.php Check out example #2.
This is no joke.
Thanks man. I guess moving to node is the thing now. :)
Mac OS X isn't a web server. It "can" be, in the same way you can technically use a motorcycle to bring your kid to soccer practice. Virtual Machines are cheap and easy.
I don't agree with you I think the added value of Plankton is interresting. Calling it "framework" is of course a little provocative, but a framework is first a way to organize your code. In the case of PHP, one of the main interrest is to avoid the usual mess of mixing views and logic. As a Symfony user, I'm aware of good practices and I think Sf2-like frameworks are really nice to create "real" applications. However, Symfony is really hard to teach, because you have a really big gap between "from-scratch" PHP and frameworks. In the other hands, I noticied that even Silex is really slow, due to all the overhead of matching routes, instanciating thousand classes and using reflections. Silex is like 4M and a simple Hello world page with it is about 10ms on my computer. All performances comparison are "versus bare-PHP", so why not having a good almost-bare framework? For note, in some embedded applications, I just could not afford the overhead of Symfony, then I actually used Plankton. And, of course, I'm not trying to make you believe that a few lines of PHP will replace your favourite framework ;-)
Fuckin lua...
And I encourage you to write your own 42 lines of code, since this is pedagogical ;-) To do such custom and simple architecture, Silex is quite good, if you're happy with it performances
&gt; why having a dependency injection system where a simple array() can do most of the job? I'm afraid you might loose track of what's necessary in $app array as your project grows, even if it's not intended for big projects, considering it's a micro framework. Another aspect is that you can't tell right away what the controller function needs just by its signature. And why did you use $app['model'] instead of global $model? Relying in global variables is a bad practice, they say. But doesn't it do the job just the same? In what aspect $app['model'] is better than global $model? It may not exist, it might change, it may be unset, it may not be necessarily what you expect, you need to set it prior to call the function, all the same. Of course these are just opinions. A good way to make sure the current implementation is reasonable is adding new examples. If you don't see the need for a new approach, it's good to go. Try adding some tests too. If the code is easily testable, it's another sign it's probably well designed.
You should learn both, but you don't need to use both at the same time. It's always good to have more tools in your tool belt.
You probably want to define database settings like user and password in a separate file that's not on version control.
&gt; Serving “raw” URLs like “about.php” hasn’t been OK since IE6 Ugh. I'm so tired of that sentiment. The vast majority of users don't give a fuck about the URL of a site. 
Good point. I'd say $app['model'] don't pollute the global variable names. It makes controllers testable, because you can inject a crafted $app instead of relying of global values Another point: $app is available in the templates, so you can access your "services" in the template this way. It also makes you philosophically closer to actual frameworks with DI containers like Sf2 or Silex 
&gt; you should only catch exceptions you expect to happen Unfortunately, the flipside is that people throw `Exception` willy-nilly, even in PHP core (c.f. `DateTime`).
&gt; Indeed, this is minimalistic though Minimalism is not always good, especially when you are missing features that 90% of sites need. &gt; If you want to handle such URLs, you'll have to use GET parameters and URL rewriting And having to write that yourself gives you an idea why frameworks are more than 42 lines :)
To be fair they also state 43% of *nix web servers have an unknown OS, likely because they've been configured not to leak that information to the web.
IMO This will make for more succinct PHP code, and many DBMS are optimised for just this sort of drudgery. With that query and resulting recordset established to work with, the PHP code written is likely to be far simpler to read.
oh no, I meant to improve the `catch` construct only.
Node.js has a lot of useful features for frontend resources such as image compression, minifying css and js, compiling SASS/LESS, that kind of thing. It also can watch files for changes and do things like automatically run unit tests and the like. EDIT: Or, I should say that node allows you to use NPM to pull in packages with said features.
TIL: 3.3 is less than 3.10 Took a while to comprehend WTF was going on with their version numbers.
They aren't optimised to do that kind of drudgery, though. They're optimised to find records in a dataset, and putting your business logic inside your database puts it in the wrong place. It also increases latency, because sending that query across the wire, to be query-optimised and compiled, wastes a lot of unnecessary cycles. It also makes the logic unnecessarily difficult to test and debug.
Sure, all of this is true but none of it is new. What PHP calls arrays are not arrays (ordered hash maps), references are not references (aliases) and strings are not strings (byte arrays).
good and valid points. I've added a bunch of real life examples. Also, note that there are different contexts for catching exceptions. Sometimes you _expect_ some invocation to end up in an exception -- probably because poor api design, but that's a very different problem. 
Latency? Depends on whether it's a TCP connection to a remote database, or a local UNIX socket connection. Debugging? If he's using migrations or otherwise issuing the query from his code (likely unless he's using Views) then it should be nearly self-documenting. And if he's not performing those operations in the database, then he's doubtless going to have to iterate in PHP through the recordset to determine whereabouts in these date thresholds the shift lies. Fine with a smaller recordset, of course.. Also, to an extent (though granted this isn't automatically some primary goal) this is more portable, this part of the logic is in SQL (well, my-SQL). This could be ported to another DBMS easier than a PHP script could be ported to another scripting language. I just don't think it's clear-cut that this _shouldn't_ be in the DB.
..plus many projects throwing SPL Exceptions as part of their API. &gt; throwing an `InvalidArgumentException` for things like "not such file" is non-sense.
OP's problem doesn't require access to a database, though. Given an event that happened at time T, determine what shift group it occurred during, according to the following rules of shift scheduling. Probably for the purpose of determining what subset of employees to interview about the event. I don't see any argument for farming this out to another processor. There's no iteration over anything needed if you do it properly. As far as the SQL being self-documenting, I've long said that *self-documenting code isn't*. It doesn't tell you what it's supposed to do, only what it does. And if you're trying to debug, that's not helpful. If you really need to do this in a DSL, SQL isn't the DSL you're looking for.
I'm too lazy to read through a bunch of wall-o-texts that seem more or less to be stating how they want you to design something you wrote. So, I'll just throw this in... To me, this is more of a proof of concept. It won't suit everyone's needs, but it does give the idea that a minimalistic framework is possible and usable. Will it beat out Symfony? Not by any sort of margin. But people design bases all the time to make it reusable for other projects. Instead of criticizing you for this or that, I would rather take this in and learn from it. Will this fit my need? Probably, but I'm not comfortable with how this works. That's fine, I could build off of this and tweak it to my style of code. So, for that, I say thank you /u/Greg_war.
I wasn't aware this was a thing. What would the alternative be? Personally, I prefer the url to be clear, so I know where I am.
&gt; I think the added value of Plankton is interresting. Calling it "framework" is of course a little provocative But that didn't stop you from calling it exactly that. &gt;one of the main interrest is to avoid the usual mess of mixing views and logic. I wish people would stop saying this. It's not about separating views and logic. You should be using logic in your views. It's about separating the logic which isn't concerned with presentation. &gt;Symfony is really hard to teach, because you have a really big gap between "from-scratch" PHP and frameworks. Programming *in general* is really hard to teach to some people. I'd argue that something like Symfony makes it easier to teach because Symfony does more so the student doesn't have to. This makes it easier to isolate certain lessons while still allowing them to do something interesting. &gt;All performances comparison are "versus bare-PHP", so why not having a good almost-bare framework? Because 99% of the time speed isn't the issue. Speed is just how frameworks try to market to you - for most people any framework is fast enough.
I'd rather not have some program manipulate my code. I'm better off having the program make suggestions, but have a human implement them.
tl;dr
I never said anything about YAML lol. Also the yaml component isn't as powerful as this, or the config component. But again, if you dont like it, you dont have to use it. Read the other guys comment about why you'd want to.
&gt;what's the simplest controller? A closure. That handles precisely one endpoint. Why should the definition and scope of a controller change when it becomes a class? That is one of the observations that informs [Action-Domain-Responder](https://github.com/pmjones/mvc-refinement).
HHVM is for Facebook before anything else so it's surprising it's getting even that much extended support.
Putting an @ on an include causes null errors later if the file doesn't exist and if there is an error inside that file it will eat all of them and never tell the developer a single thing has gone wrong or why until some other code goes belly-up due to something unrelated. This means more headache and time to backtrace variables and application state.
I'd agree arrays are rarely the bottleneck in an application, but they can be when it comes to deep sorting and rebuilding. Consider the Reddit comment system which has hundreds of comments per page, with deeply nested replies. Sorting and reording a flat array into such a structure can be a slow PHP process. I don't know if Phred solves those problems, but we shouldn't treat PHP arrays like infallible golden gods. They could use some improvement for certain use cases. Besides, not being the primary bottleneck in a system isn't an excuse for accepting poor performance. "Oh, the database is 100x worse than the app code. So we shouldn't worry about the app."
Is this where Phil Sturgeon takes everyone else's contributions and tries to make money on them?
An alternative (without even the need for a framework) is http://sitename.com/page1/ Put index.php in /var/www/page1/ and you get a clean URL. For simple sites this is no big deal, though it does give you cleaner URL's. For applications, it's more important as there is no need for a user to actually see what part of the code is executing. On the applications I write, the displayed information varies greatly (login screens, edit screens, account management, etc.), but the user only sees http://mysite.com/myApp/ as the URL throughout their interaction with the application. There are some nice security implications here as well (for applications), but that's another comment for another time.
PHP Arrays *are* cool. When you're just writing a quick script or doing something else non-performance critical, they save a lot of time. It's a convenience that I often find myself wishing other languages had. And the new (borrowed) syntax makes it a lot easier on the fingers. $foo = ['bar' =&gt; [1, 2, 3], 'baz' =&gt; [3, 4, 5, 6]]; is so much less carpal-tunnel and headache inducing than something like: Dictionary&lt;string,List&lt;int&gt;&gt; foo = new Dictionary&lt;string,List&lt;int&gt;&gt;() { { "bar", new List&lt;int&gt;() { 1, 2, 3 } }, { "baz", new List&lt;int&gt;() { 3, 4, 5, 6 } } }; There's a time and place for nice strongly typed collections, and under those contexts, yeah PHP arrays might be the wrong tool for the job. But not many other languages beat PHP arrays for handiness. ^Edit: ^a ^letter 
Nice work adding auto-resolution Paul, and thanks for your commitment to this project. You're doing awesome work!
It isn't the users unforuntately, it's the search engines that care - http://moz.com/learn/seo/url
Except that...Silex is not a microframework. Saying this is really a complete intellectual sham. I think you should replace Silex by Slim or Fatfree in the title. and for static sites there is jekyl http://jekyllrb.com/ Several full CMS are about the same code size as Silex 
Oh, call me back when I'm working in an industry where I give a shit about SEO, thanks
You'd use mod_rewrite or similar to change URLs to talk to your application. This is nice for a public REST API, and nice for SEO, but certainly not required for either. It's nerdy window-dressing in most cases.
My biggest issue is where you mention: &gt; You can't read all the source-code of Silex or Symfony, you'll have to accept that some things are complicated, read the API and follow the guidelines someone told you First, accept that some things are complicated. Lots of things are complicated. Some of the most interesting things are complicated. Learning libraries/frameworks are daunting at first. This doesn't mean you can't learn how they work. You take chunks of it at a time and eventually you figure out how all the pieces work. Just because you don't understand it within X amount of minutes of reading the source code doesn't mean it's overly complicated. 
Just a side note, if there exists a concern about request processing speed on embedded systems with limited resources, you could check the file path for the controller and if it exists, attempt to load it, rather than loading all the controllers as previously mentioned maybe like this: $segments = explode('/', $page); $file = $root.'/controllers/'.$segments[0].'.php'; if(!file_exists($file) { header('HTTP/1.0 404 Not Found'); exit; } $actions = include($file); I have done something similar in my ["framework"](https://github.com/ShadowedMists/one-php-mvc). I too started with about 49 lines of code, but I then I added more functionality.
Modeling such a system wholly in memory using nested arrays is, itself, the problem. Anyone doing this is making bad software architecture decisions and pointing a finger at PHP is disingenuous, at best.
If you have form specific content or maybe there are some permissions differences.
Ignoring the complexity is also a very good way to dive into a new codebase at a new workplace as well. Grab some smaller tasks, grep for the closest related place in the code, and just explore the related parts. You don't have to know everything in order to get started. This is how I excel at being productive quickly in a new workplace and get praise for it. The same also goes for frameworks.
I'm curious as to how auto-resolution impacts your performance. I only ask because I read a post recently that compared Auri.Di pretty favorably to several other IoC containers.
how is silex not a microframework? The title of their homepage is "Homepage - Silex - The PHP micro-framework based on Symfony2 Components". SLOC doesn't equate to micro-frameworks entirely... 
And i guarantee i could make symfony fast enough for you that it wouldnt matter. Its all about how you implement it. These speed benchmarks are full of shit.
Noob. I don't see any inline css.
Stop spamming links to this "Phred" project please. You just did this with another terrible title yesterday. In fact, all of your submissions are links to the same github.
&gt; I mean, a "string" is nothing if not a "byte array" in any language. Strings and byte array's are *very* different things in *many* languages. The most important difference being strings have encoding; i.e you get a certain string by encoding a list of bytes. The fact that PHP *doesn't* acknowledge the difference, is the reason it has many different implementations for dealing with encoding. Some functions rely on a global encoding, some uses the encoding of the file it is in, and some require it as an argument. Even the manual [admits it is a mess](http://php.net/manual/en/language.types.string.php#language.types.string.details). &gt; I'm not even sure what the conceptual difference is between an "alias" and a "reference", but PHP uses a pointer under the covers, so that's a reference AFAIC. The PHP docs [explicitly state that references are *not* pointers](http://php.net/manual/en/language.references.whatare.php).
Yeah.. Wondering the same thing.. How is this a static site? What he built is just a site without a CMS...
Do you use this on things like Wordpress? If so, how you you manage enforcing the syntax (assuming PSR-1 and PSR-2) when files are doing both view and logic?
As far as Wordpress goes, we've started using a version of [this Wordpress skeleton](https://github.com/roots/bedrock) to install Wordpress core via Composer and it's been working pretty well! You can also check out [WPackagist](http://wpackagist.org/) for Composer mirrors of all public Wordpress plugins.
how would **you** define a microframework then? Judge by yourself through SLOC(=source lines of code): - Slim 22 files/2630 SLOC (most popular Microframework) - FatFree (15 files, 3998 sloc) - Silex: 296 files/18054 SLOC Most of Microframeworks are below 5000 SLOC Silex compares in sloc to FuelPHP, Codeigniter, CakePHP, Laravel. As a comparison, wordpress which is a full application that has 191 files/84224 sloc. Several full CMS are about the same code size as Silex **(ie Monstra CMS -366 files19437 sloc)** So IMHO it would be the worst choice for doing that. 
That's a really great point. I'll update my beliefs. :)
by how much it does for you. Its still a very fast. Faster than most frameworks. It may be slow on the microframework side, but its stilla microframework.
So does php...? and composer....? 
Take a look at how [Flask defines a micro framework.](http://flask.pocoo.org/docs/0.10/foreword/#what-does-micro-mean) Now compare it to Silex. Not that it's definitive, but I like how it's defined there. 
Sure, but using node and gulp I can get it set up in about five minutes. To do the equivalent with node would take significantly longer, unless I'm way, way out of the loop when it comes to task runners like Phing, Envoy, etc.
http://bldr.io/ Theres a frontend-block for doing that same stuff. Not to mention, your project doesn't need to be a node project to use grunt/gulp.
Completely agree on the intellectual sham part.
To be fair, JS and Python get it right: `{}` for dictionaries/objects, `[]` for arrays. But PHP's approach isn't too bad.
&gt; What PHP calls arrays are not arrays They are arrays, they're just associative arrays.
&gt; Strings and byte array's are very different things in many languages. Some languages. Not all have the Unicode string/byte array distinction. C and C++ don't, for example. Python kinda does and kinda doesn't have this - it has binary strings and Unicode strings, and it also has byte arrays. What you call a "byte array" is also known as a "binary string". It's a no less valid way to implement a string than a Unicode string is.
You know the saying *To assume is to make an ass out of you and me*? Well, in this case, it just makes you out to be the ass...
A stylistic transformation, can not be semantically altering. Also this way your just making the coding style more annoying than it should. With a static analyzer on the other hand, there is no transformation that is easily done, so there reporting works best. Doesn't matter anyway, if that get's annoying, there are people that will do like me and disable that and have the transformation run before the test.
I started off by having a goal - my goal was to create a database system for my local museum. It took me several months to create it (about 9 months) but that was because I started off using the MySQL extension, then to using the MySQLi then to using PDO. As long as you continually update and WANT to update your code by learning, you'll do fine. 
For simple websites, all you need is a "framework" that allows you to separate layouts and views, really. So create your own or find a really tiny framework pre-built like http://slimframework.com. Never used it, but it seems good enough. Better than what you can write yourself, most likely. That wasn't a dig at you, it is just what I "live" by. USUALLY in most cases, if it exists with several people working on it, it is most likely going to be better than what you/myself can write.
I don't remember CodeIgnitor being good...ever. There are also a lot of other application architectures rather than MVC, but alright. The article writer also says, he follows good design practices but doesn't need MVC(one of the simplest architectures btw) or objects. Honestly, he sounds pretty close minded and doesn't seem to care to improve himself because the work he does doesn't call for it. Bad programmers will always be bad programmers until they motivate themselves to do better. Also, I'd like to see a few of his 'projects' to see how testable it is and what kind of good design practices he implemented as he didn't explain at all what he does to accommodate for his non MVC/OOP approach. His, "I use DRY and separate HTML from PHP" statement doesn't mean anything to me. 
yep. Aura.di was good already. http://www.sitepoint.com/php-dependency-injection-container-performance-benchmarks/ perf impact may be important... 
The author's alienation of the "cool" reader with "mad skillz" and use of limiting words like "never" and "ever" make it really hard to give a crap about the opinion of a guy who has apparently done nothing but worked on small websites for small companies that no one knows about
Don't forget that Josh was the original author. Contributions would need permission, but Josh is free to release under multiple licenses. So he could release the website under CC BY-NC-SA, but release the book under a commercial license. This falls down quickly unless a CLA was used, which allows him to retain that power.
sure. but it is a very imcomplete definition IMHO. 
Some examples are weird. Why is the m function so nice to create a map when it's parameter IS a map? m([x =&gt; a, y =&gt; b, z =&gt; c]) ; OK, I get it. It returns an object. I don't like standard objects, I wanted a dumb map. ;) Overall I think the approach of this phred thingy is not so nice... It seems so anti php. 
Honestly, Jekyll is where it's at. It's easy to use and incredibly speedy.
Do people generally use frameworks for the purposes of coolness and showing off their mad skillz? Personally I tend towards frameworks because they make my life easier, even for small projects.
I like the idea, but! This is kinda like the way i used to code Php a few years ago. I just put the controller logic on top of the file and then begin doing the html template with a bit of view logic sprinkled here and there. Like this &lt;?php $db = get_connection(); $users = get_all_users($db); ?&gt; &lt;html&gt; &lt;body&gt; &lt;?php foreach($users as $u): ?&gt; &lt;?php echo $u . '&lt;/br&gt;'; ?&gt; &lt;?php endforeach ?&gt; &lt;/body&gt; &lt;/html&gt; Its a simple example but it gives you an idea of how it looks. I still do like this, when i have a very small thing to do and as long you code is simple and clear i don't see any problem with this style. But do i need a framework for this? No not really, but what i would like is a library that i could plug into any project i was doing no matter what style of development i am using but still did make some stuff easier for me. 
Hey you called me?
Yeah, that's what I did. My first goal was make a clan website for Counter-Strike beta 2. Good times.
Looks good! I wrote a [base85](https://github.com/scottchiefbaker/php-base85) library that's similar. Congrats on your release.
If you're suppressing errors, you're doing something wrong.
I second this suggestion. gmp is more common in PHP installs than bcmath anyway. My vanilla install on Fedora includes GMP, but not bcmath().
It sounds like the author feels, the trends are all about frameworks and MVC, where they tend to be overkill for a lot of small projects. I tend to agree with that, but maybe he likes to dig in a little more than most and find he doesn't need to build out huge class structures and routing mechanisms but just needs something barebones that works. Someone mentioned slimframework which is something he should consider, or honestly something like TextPattern is a great option. Both offer small footprint and easy to buildout or maintain.
^ And this, my friends is merely tip of the iceberg as to what's wrong with copyright today.
/u/hackiavelli brought up a really great point that I hadn't noticed or considered: &gt;To be fair they also state 43% of *nix web servers have an unknown OS, likely because they've been configured not to leak that information to the web.
This is a great, great question. **TL;DR: I don't expect there are slowdowns related to auto-resolution, but I have not measured it so I cannot say for sure.** (Read below to see why.) Still reading? OK, let's look at the parts of the Aura.Di _Factory_ class that "unify" the parameters from the inheritance chain for the class being constructed. Before the auto-resolution was in place, the _Factory_ reflected on the constructor parameters, and walked through each _ReflectionParameter_ to find a useful value for it: &lt;https://github.com/auraphp/Aura.Di/blob/66cbce274a6bbff4efed78381c1d874f6188f145/src/Factory.php#L404-L417&gt; (My guess is that the reflection activity weighs heavily in performance terms, but since it occurred prior to the auto-resolution functionality, it doesn't make a difference in our comparision.) Then, in preparing for auto-resolution, I extracted that bit of code to its own method: &lt;https://github.com/auraphp/Aura.Di/blob/58bc207d590983378dd4c9742331996055c361fa/src/Factory.php#L400-L419&gt; (You can see that there is no substantial change in the logic. It's a plain old extract-to-method refactoring.) Then, to implement auto-resolution of array and class typehints, I added three new `if()` statements to that method: one to check for `array`, one to check if the typehint has an explicit resolution, and one to resolve the type implicitly: &lt;https://github.com/auraphp/Aura.Di/blob/905b183727fe728409860aadf46687a2261771fc/src/Factory.php#L468-L482&gt; (Yes, this method is still a bit ugly; frankly, the whole class could do with some refactoring. Scrutinizer-CI complains about it too.) Seeing as the reflection has already occurred, I would not guess that the performance reduction from these added lines is significant. It has to slow down a *little*, since there are more lines of code to work through, but aside from that I don't expect there is a major drop. However, this is all professional "best guess" conjecture. I have not benchmarked or performance-tested the before-and-after scenarios. The only way to be sure would be to measure it. 
At least the guy contributes to our community. Judging by your history you don't contribute to anything other than responses like this.
/me bows Thank you, sir. I appreciate it. :-)
The only problem with a downloadable book is that they acknowledge its a 'living document' that will change over time. Whats 'the right way now' might not be in a years time. I'd rather they just stuck to providing the online version at http://www.phptherightway.com, at least then newbies in 4 years time wont be working from some old PDF they happened to find on a website
What's the use case for this?
Oh, I see. You're the one person that doesn't use a relational database, which returns results as a flat array that may need to be properly structured before being displayed. My bad. /s
Exactly. I can see how people might not get on with how opinionated he is, but he got that way because he walks the walk and knows what he's talking about. If you're seeing this Phil, I think the vast majority of us appreciate the work you put in and appreciate your opinion, even if we don't all agree. That's more than I can say from the downvoted tool above. 
Thank you very much, this was the information I was looking for! EDIT: Omg thank you again this is working perfectly, my PHP code is finally showing up!
I'll be sure to check this out. Isn't Team Treehouse a paid service though? I'm also going to work with Codeacademy, hopefully that provides some sort of guidance.
Honestly, auto-resolution of class type hints is something I've been resistant to since the beginning of Aura.Di. But in systems where there's a lot of "new instance" injections, or lots of sharing of the same services against the same type hints, there's a case to be made for *not* having to explicitly specify the same resolutions over and over and over by hand. So with that in mind, and realizing that implementing auto-resolution was the work of only a few lines (as detailed above), it seemed like a reasonable feature to add, given the tradeoff of not having to manually specify each and every injection.
The guy is blunt, I give you that. But I agree. I attribute a lot of my knowledge to him. Thanks Phil!
Url's are different. Click mine.
Yeah, I'm pretty motivated right now. Creating a museum database sounds like a lot of fun (and also a challenge) :).
I'm assuming this is a joke?
Right, and is stated elsewhere, he isn't making money here either. 
It is a joke.
How would you handle it?
Luckily, *PHP: The Right Way*'s CLA looks good: &gt; By submitting a pull request to this repository, you agree to allow the project owners to license your work under the the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. &gt; The same content and license will be used for all PHP The Right Way publications, including - but not limited to: &gt; &gt; * phptherightway.com &gt; * Translations of phptherightway.com &gt; * **LeanPub: PHP The Right Way** &gt; * Translations of "LeanPub: PHP The Right Way" &gt; &gt;All content is completely free now, and always will be. Still, I stand by my distrust of CC NC. It's a lot more restrictive than people think.
Creating Atom or RSS feeds for static site generators should be as easy as creating another page that generates XML instead of HTML output. I'm doing that for Sculpin for That Podcast's ([thatpodcast.io](http://thatpodcast.io)) iTunes feed: http://thatpodcast.io/itunes.rss https://github.com/thatpodcast/thatpodcast.io/blob/master/source/itunes.xml Full disclosure: I'm the creator of Scupin ([sculpin.io](https://sculpin.io)).
I probably have made a few assumptions here. 1. I assumed the events are stored in MySql, if that is wrong then my answer might look a little screwy. 2. I bet you that the OP's events are stored in the DB. (he has posted code but it doesnt elude to if he this stored in the DB. 3. If this data is in the DB then you could have got solved this whole system in 1 query vs 90 lines of SLOW php code. 4. The DB will be able to pull 1000 of lines out super super super fast once the query is sent (1 kb) and return the result a few bytes (Shirt A). 5. Doing this in PHP could make sense in terms of debugging but not 90 lines. thats a bit of a mess, I pretty much solved is week even in bullet 3 of my original solution. Vs 14 lines for the OP's solution. 
Claiming your code is well-designed without OOP is useless if you're unwilling to share any of it. Talk is cheap.
I'm not sure what you're talking about. The moment you take any data out of a database it's modeled "in memory". A couple kilobytes of memory to be exact. If you feel sorting a couple hundred array elements requires special handling then I'd suggest you're over engineering your solutions. We're talking about preparing data for display on a web page, not calculating trajectories to the Mars. Comments and replies are very neatly modeled by associative arrays, and sorting them is a trivial task, but PHP is not nearly as fast as other languages when it comes to sorting, which is why I would like to see other array-like data structures.
Yeah, looks pretty good. Could use a bit of cleanup, though; you've got a lot of places where you're either using magic numbers or assigning variables when you should be using constants. Fixing the magic numbers will be better for the next poor schmuck to come along and maintain it (probably you, in six months, when you've forgotten half of what you intended), and replacing, say, `$one_week = 60 * 60 * 24 * 7;` with `define('ONE_DAY', 60 * 60 * 24); define('ONE_WEEK', ONE_DAY * 7);` will not only provide a handy optimisation, but also tighten up your code and make it clear that some of your variable in your calculations simply aren't changing. You might also consider wrapping this in a class. Your API here is just getShiftThatWasWorkingByInputTime($input_time), so by making the other functions private within the containing class, it becomes much more clear that this other functions have one use, and it's in the calculation of what shift was working, based on a given input time. The construct `if (test) { return true; } else { return false; }` can, and should, be tightened into `return (test);`. Almost every time. You can also clean up the assignment of $time_when_shift_started. Try this: define('EVENING_SHIFT_START', 183000); define('ONE_DAY', 60*60*24); $time_when_shift_started = mktime($hours, $minutes, $seconds, $month, $day, $year); if ($my_compare_time &gt; EVENING_SHIFT_START) { $time_when_shift_started -= ONE_DAY; } I'd also avoid double-assigning the array values for [day_shift][wednesday] and [night_shift][saturday]. It's just a waste of cycles.
A few points here: 1) You're not even in the ballpark by several orders of magnitude with your "couple of kilobytes" comment. In fact, represented in memory as a string, just the text in your *one* reply is 640 bytes *by itself* (almost half of your "couple of kilobytes" allowance). Multiply this by hundreds of replies, replies to replies, and array overhead. The average large-ish reddit comment stack is in the tens-to-hundreds of MBs of data (see example below). 2) You're wrong about it not taking any more memory. There is a marked difference between pulling everything into an array, and then dumping it into the output buffer, vs. just streaming it directly to the output buffer as you're pulling it out of your database. It's going to take more than *twice* as much memory to do the former. 3) Sorting is better handled in the RDBMS *before* you receive the data, rather than in memory using PHP array sorting, for exactly the above reasons. Proof: &lt;?php $str = &lt;&lt;&lt;STR I'm not sure what you're talking about. The moment you take any data out of a database it's modeled "in memory". A couple kilobytes of memory to be exact. If you feel sorting a couple hundred array elements requires special handling then I'd suggest you're over engineering your solutions. We're talking about preparing data for display on a web page, not calculating trajectories to the Mars. Comments and replies are very neatly modeled by associative arrays, and sorting them is a trivial task, but PHP is not nearly as fast as other languages when it comes to sorting, which is why I would like to see other array-like data structures. STR; echo memory_get_peak_usage(), "\n"; $arr = []; for ($i = 0; $i &lt; 100; $i++) { $arr[$i] = array( 'text' =&gt; $str, 'replies' =&gt; array() ); for ($j = 0; $j &lt; 3; $j++) { $arr[$i]['replies'][] = str_shuffle($str); } } echo memory_get_peak_usage(), "\n"; Output: 238048 545312 **Edit:** Just to clarify, that's a ~300KB increase to load a (very modest) 100 comment, 3 replies-per-comment stack into an array. Anything near the front page would be much, much larger. And this is just one request for one end user, mind you.
Debugging can be an art in itself. Knowing what you're comfortable with and being good at it, is worth more in the end. Edit: Developer.
Create a Second Edition when the time is right, and so forth.
Why not hit up your local chamber of commerce, and start attending some business networking events. That's how I get lots of contracts, so I know it works.
I know how you feel. I can hack my way through a few languages, but I don't write much in anything.
Neat. I'm kind of sad that my bitcoin investment went down, but now I'm kind of excited that if it starts stabilizing we can start using it as an actual currency without being too afraid to spend it. Maybe I should start accepting bitcoin...
Price stabilisation -&gt; Customer confidence -&gt; More use for purchasing -&gt; Popularity -&gt; Investment goes up. :)
A hobbyist?
Yes, but if you can't write a program, you're not really a programmer, are you?
This functionality is related to the concept of callable classes in PHP, where you can treat an array with the 0 index as a class name, and the 1 index as a method name. This is passed into a method that accepts callable and will resolve the method accordingly. The Invoke class takes two arguments, the callable class and the arguments to be passed to it. Then the Dependency seems to resolve the qualified name of the class. It is actually hard to understand how it does this in the ServiceFactory because there is a lot of magic going on within __invoke and no apparent ServiceFactory::get() method.
It would be nice if you provided literally *any* context for this at all. Obviously this is through a framework of some kind, but you couldn't spare a single sentence to provide some background information? I just clicked on your example, saw 200 lines of ugly DI configuration, and gave up.
Networking events is where I've meet some of the best people I ever worked with. I think the initial casual conversation lets you figure out if you like the person enough to work with them.
If you only know wordpress you really don't know much. If you can write OOPHP you still just might be a scripter. I can write C++, Java, PHP, and Python and Ruby if I needed to. I still feel somewhat limited because I'm not doing enough low level stuff. I don't know if I could call myself anything more than a developer.
Sorry about that. The configuration is written in PHP as it easily allows more complex configurations to occur than what might be achieved with a text file or an xml file. Its also been less code and easier to do this way.
You are both right, maybe my argument was maybe a little bit clumsy. What I meant is that a developper with a "from-scratch" background may be affraid diving directly in big frameworks such as Sf because it will have large amount of code that will, fur sure, help him but also be complicated and thus hard to do exactly what he wants with. I'm thinking of my own experience, some things are really not easy to do in Symfony, like hacking the login process or even customizing forms, so you spend weeks reading the doc and cookbook, which is normal. If you come from from-scatch, you can being frustrated because of this, because you're now dependent on the big machine.
Makes sense. I seemed to have had the confusion because I didn't read the correct trait. I had looked inside the FactoryTrait instead of ServiceTrait. Since you are the creator of it though, is there any insight as to why traits are used instead of abstract classes or using a combination?
I've been going with the notion that it is better to just implement rather than extend. Which for example easily allows a Manager to be both an Event and Service Manager at the same time - the events and listeners are pulled from the SM if needed. So with traits I haven't found a real need for an Abstract class - I'm still asking myself this question too. Btw, once the basic FactoryInterfaces have been ruled out, the heart of the ServiceFactory class is the di method which (if needed) recursively merges child/parent configurations and then instantiates the object.
Slim framework is awesome! Use it with the components installed through composer such as Twig on http://roadcrash.in
IMHO, using unit testing really improves your code quality very quickly as it forces you to make your code testable, and testable code should be decoupled code. I found that the more that I wrote tests, the more I understood the purpose of design patterns and the more I understood the importance of using dependency injection. I think the learning curve for PHPUnit is quite steep for a newbie, however, I find that decent knowledge of it normally allows you to walk straight into a php dev role.
there is a php clone: http://phrozn.info EDIT: there exist several in PHP : http://www.modernstatic.com/ 
In my school, there was two main "branches" at the end, people who actually wants to become developper/software engineer, and system administrators. I really think both profiles are clearly present in companies, with different skills - and different minds. I guess developpers are working on long-term projects, basically writing code, when sysadmins manage servers, deploy applications and monitor them, preffering writing some scripts sometime than involving in big applications. The tasks you described looks more like a system admin, maybe this is what you are? 
Another pico framework: https://github.com/Gregwar/Plankton
Don't forget to download the updates. 
Thanks.
&gt; I had looked inside the FactoryTrait instead of ServiceTrait That still puzzles me too :) Probably need a different name than factory.
Try http://mandrill.com/ (same company as mailchimp)
Paul, I got to say, after I mentioned it a few times about two months ago, you did exactly what I asked for: grouped your release messages, gave me information about what has changed, gave me links to more detailed info for each if I wanted it, and made it something that's noteworthy for non-Aura devs. Not only that, but Aura itself has been steadily improving. :) I'm actually in charge of application architecture where I'm working now, and planning on using some Aura packages. Thanks for the release, and well done to all the contributors.
Who said anything about it being a web server? You could use a Macbook Air to run a few VMs in the same way you can technically use a motorcycle to tow a caravan. Running interpreters locally is a must for many developers.
// sarcasm on of course people use frameworks to show off their skillz //sarcasm off
Yeah, I suspect that the reason that half of the mail *did* arrive is more to do with spam blocking than anything in OP's code.
1. What? What is this about? What DI library or framework? Some context please. 2. This is wrong. You are using static DI container configuration to write actual code. DI container configuration is about wiring dependencies. **Request**, **Route**, **Response**: these are not dependencies, those are value objects that depend on the current request being processed. They shouldn't be stored in the container. If you want more justification behind that, [this Symfony blog post](http://symfony.com/blog/new-in-symfony-2-4-the-request-stack) is a good start. So what this example shows is programming **actual code logic** using a pseudo language -&gt; this should be done in PHP. Yes, container features that are **helping** to do that are good. But programming this kind of logic using the DSL of a container configuration is wrong.
I've done a lot of email deliverability research and this has nothing to do with spam filters as far as I know.
I understand what you are saying, but realistically speaking if I wanted to ensure scope, I would create another container and then trigger an event (assuming for example I wanted multiple MVC events). For most applications they can function perfectly fine without having to get into the intricacies involved in retrieving these scoped workflows; the existing one suffices. Hence it would be easier to create or maybe clone the container. A good example, is the Current Route. How is the View going to get it. This is what dependency injection is for. Further more, being able to perform actual code logic can be invaluable, not only does it mean less code, but it also means I don't need a concrete interface to bridge two different domains. This can be handy for modernizing existing applications and also just piecing together various packages. The versatility is there! I'm pretty sure there would be away to resolve your issues if considered more thoroughly, but you are stipulating that scoped sub requests is a requirement when it is not, the code that exists is for what the system actually needs in order to perform its work, i.e there has been no use case so far. Again thank you. And incidentally if you cared anything about interfaces, you would see that I'm trying to present a clear and definative model.
I did give an explanation of the topic I wished to discuss and /user/joellarson kindly provided even more detail. Seems like you woke up on the wrong side of bed this morning.
12.000 e-mails sent for free every month? Is there a catch somewhere or are they really this awesome?
&gt; Now that we've got the [] syntax, it's just an extra two characters really. Two characters on top of what? Using arrays is still a lot of characters compared to other languages - you have the quotes around the keys, two characters for mapping (`=&gt;`), plus the brackets. Using jkoudys's example, it would be nicer if we had something like sendReminderNotice([ name: 'Josh', message: 'Spend less time on reddit', when: 'now' ]); Honestly, PHP should scrap constants, that'd solve the problem :)
&gt; This is wrong. You are using static DI container configuration to write actual code. It is a serializable representation of an anonymous function. Don't alot of people write anonymous functions in their configurations. Isn't that what these micro frameworks are doing and supporting? The keywords are static and serializable.
this is not a bitcoin SDK its a razrbit SDK .... it doesnt work on the bitcoin protocol
Here you go 'Request' =&gt; new Call('RequestStack.request') I edited it to try and make it a little more correct (you get the gist). 
I don't need one. I just push it to github and it's live. 
To be fair, you still didn't answer my question. Obviously this code is wiring up dependencies, but it's like you assumed everyone in /r/php is familiar enough with your framework to understand what's going on. This post would have likely gotten more traction with a title like "DI Gem in $framework: using the Invoke class to replace closures for dependency resolution"
With object instances and method calls, you could code your entire application using your container. That doesn't make it right thought. That's the point I'm trying to make: where does it stop? You could as well call methods on repositories using request parameters, and inject the returned entities into views and all… What I'm trying to say is that the container is for architecturing your application/wiring everything together. Think dependencies. Objects like requests and responses are not dependencies. So everything else shouldn't be coded in the container.
This is a bitcoin SDK - it works with bitcoin.
I understand that, but to be fair also, another click and you would of been able to read the entire read me and we could of taken it from there. 
The projects are still quite young but I'm sure the dev's will add tags soon.
As far as I'm concerned anything passed to a function or class is a dependency! &gt; That's the point I'm trying to make: where does it stop? That's the interesting question, powerful isn't it? The effect of DI is that it removes more of the glue code. And just like php, its up to you how you use it, not every project is the same.
They really are that awesome :) Have been using it at work and for private projects for many months and loving it!
12k really isn't that much to them. 
Oh Absolutely. But it you're trying to showcase your framework's features, it helps if you make the barrier of entry as low as possible. Especially for people like me who have the attention span of a small lizard.
Dude you know I'm sorry :) I've posted about it recently before (and also a similar DI Gem), I also feel the discussion can be had without talking about any specific framework, its the semantics and oh no's that matter.
There's more demand for shitty wordpress "jobs" than actual web development jobs because statistically there are more shitty companies than interesting ones, but don't let that discourage you; on the long run you wouldn't want to make a "career" in those places anyway. You just need to broaden your job search, don't expect to find a job in the building next door in your town, go make interviews in other corner of the country and move wherever it takes and you'll find something great eventually (assuming you can, that is). Sidenote: I haven't used it yet but I always hear good things of the Stack Overflow Careers site ([link](http://careers.stackoverflow.com/)), might want to look there.
No, I would agree with /u/cYzzie... this is an SDK for a platform which supports bitcoin. It is not a bitcoin SDK.
is this any better than the Symfony2 replacement for intl ? [link](http://symfony.com/doc/current/components/intl.html)
Symfony's replacement is limited to english only (the "en" locale). Since that makes it not useful at all, the team is looking at rewriting it, I've nominated commerceguys/intl as a possible approach: https://github.com/symfony/symfony/issues/11737
Yes, it says "Coming soon: date formatting" on top of the README ;) I needed to focus on 100% test coverage first (now done). 
I can vouch for cosha1. Redis has all the features of memcache(d), does them better, and has way more features to top it off. Data structures, relatively good cli support, introspection (try finding out how much time you have left on a key timeout in memcache, it's not possible afaik).
&gt; As far as I'm concerned anything passed to a function or class is a dependency! I disagree with that. To me there are dependencies, and parameters. function add($a, $b) { return $a + $b; } add(1, 2); Integers `1` and `2` here are not "dependencies", they are not about decoupling modules/classes, they are just parameters to the function (values). Taken from wikipedia: &gt; The pattern separates the creation of a client's dependencies from its own behavior Clearly, the behavior (i.e. the logic) isn't affected by dependency injection, it's just the creation of the objects.
Cheers!
We use amazon ses for our emails. Takes sometime to get everything going perfectly... But for us it's worth it. Ses to sns to sqs
How do you compare it to Amazon SES with only .10c/per 1k? 
&gt; Selecting a strong PHP coding standard - any recommendations here? Just follow PSR-1 and PSR-2, and then if you want, pay for Scrutinizer. Or give everyone a license to PHPStorm and implement this code standard that can PHPStorm can use to format your code accordingly.
PHP only cares about satisfying interface dependencies and makes no differentiation between function add($a, $b) and function setA($a) Most params do not have to be buffered and can reside in the container or be retrieved from an object in the container. For example, what happens when 'one' is a configuration value? It only becomes a value when it is used. And so what if you can program the entire application just by managing its configuration? There are probably other ways of visualizing and managing this. Either way, it offers additional versatility.
"Let it never be said, that I have not heard the cries of my people." ;-)
In my experience, you have to be careful with static analysis for things like that. Especially with older legacy apps, you will find some strange ways of files being conditionally included based on the app's state, or with strange concatenations using variable variables etc that static analysis won't pick up.
You could give https://github.com/sebastianbergmann/phpdcd a shot
The problem is, I'm on a semi shared server, and I only got what I got. Unfortunately hosting decisions don't get made by me, lol, I'm a web developer working for the wrong kind of company.
I regularly build sites for the other 1%, and seeing your casual responses to performance concerns here is why I am not choosing Laravel. And if you're measuring CPU usage in a web app to determine performance, you're measuring in the wrong place. I would much rather check your memory, I/O, and queue length.
1. This answer is how I know I'm talking to a programmer. [Pedantic](http://www.urbandictionary.com/define.php?term=pedantic). 2. When did I say anything about using less memory? 3. We're not talking about pure sorting. We're talking about turning a flat array structure into a nested structure, which is a task relational databases are not designed to handle. In fact they total suck at dealing with hierarchical data. Stackoverflow is littered with questions from people trying to model nested comments in a relational database, and the answers are not pretty. The only answers providing any kind of sane approach is to pull the comments out of the database and structure them inside the application. But sure, go ahead and do the heavy lifting of sorting and restructuring inside the very expensive and difficult to scale database server, instead of the cheap and horizontally scalable web server. &gt; and array overhead You mean the overhead that doesn't exist when using *real* arrays? Which don't exist in PHP. Which is the whole point of this discussion? &gt; just streaming it directly to the output buffer as you're pulling it out of your database. I hate to break this to you, but the buffer.. is memory. There is no "streaming". You're copying data from one memory location in your application (the database results) to another location (the buffer), and you're "modeling" the nested comments in memory, which is why your original reply doesn't make any sense.
*Here's the Urban Dictionary definition of* [***pedantic***](http://www.urbandictionary.com/define.php?term=pedantic) : --- &gt;A state of mind which is about caring a lot about formalities, often more than necessary. One may be called pedantic when he/she points out corrections in unimportant details. --- _Okay okay, so there were five people there instead of four, no need to be pedantic. Now anyway..._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/PHP/comments/2fcip6/php_arrays_aint_really_cool/ck91g7c) ^| ^(**Summon**: urbanbot, what is something?)
I don't really see the point in this. You appear to have created an extremely simple router. Okay. Why couldn't we just use a composer package for this, plus some regex capabilities? You have little separation of views. But no separation or concept of models. You actually mix your "router" into your "controller." All this talk about separation of code, and you actually don't do it yourself. I'm sure it works well for you. However, for a majority of developers, it wouldn't. This just doesn't fit any general needs. If a developer is concerned enough with micro-speed to use this over Silex, or Slim, then the developer is smart enough to know how to use micro-frameworks, micro-optimizations, and narrow in on specific needs leveraging independent composer packages.
MySQL is still far behind PostGIS in this department. What you're looking at in the manual is far from what you'd get in postgres with the GIS extensions. If you're ok with treating lat/long points as simple points of geometry on a flat surface, MySQL will do the trick. If you need them to get geographic in nature (points on a projection), MySQL simply cannot handle it. But, if you're ok with the world being flat, or are dealing with points in a relatively small space (like a city), you might be ok. TLDR; MySQL stable currently has no real geographic capabilities (lat/long, projections, etc), only geometric (x/y, geometric calculations, etc).
You need to move to more dedicated environment unless you're company is okay with high latency. GIS is always computationally heavy, and you're not doing yourself or your company any favors being in a shared environment. If the upper brass doesn't understand that, they're bound to fail.
The bummer of it is, I'm stuck with mysql. For what I'm looking to do at the moment, a flat projection would work. The most advanced thing I'd like to do at the moment is see if a point is inside of a polygon. To this effect, I'd be checking if a point is in a polygon that's attached to a city, zip, or county, then pull up information related to those if it is inside of them. I'm really just seeing if I can do it at the moment as I think it'd add some cool features to a component of the site, and realistically looks like it should be cached, but getting to the point is where I need to look more into the capabilities.
Present a business case for a proper hosted VM to the brass. It's probably not very much more expensive than where it's being hosted now.
Have you considered finding an external company that provides this sort of thing via a web service, and then simply integrating into their offering? Might take less development time and give better results.
Mandrill also has a nice template feature where you can create one template and just merge in the unique data for each recipient at send time.
I haven't looked into it yet, but it looks like it might be in my best interest, in general though, I hate being tied down to anything 3rd party
I feel ya, but consider the perspective of your company: they're "tied down" to some solution no matter what. On the one hand is a solution made by a developer with huge constraints (you) doing his best to make a custom thing that would be tricky to find a replacement maintainer for. On the other hand is a solution from a company, that they can call for support and sue if it came down to it. The latter actually offers more flexibility.
Don't know; unfortunately. I use them because of mailchimp; and have never had a problem. That's all I can say.
I perceive composer update to be much faster when I can actually see all the work it's doing behind the scenes. I find -vv to be a happy medium.
Selling bits is about as close to a 100% profit margin as you can generally get...
Interesting article. One could make this request for *any* framework.
yeah, cause they dont have to pay for servers and developers. /s
wat?
Sounds like you want to associate entities? [http://doctrine-orm.readthedocs.org/en/latest/reference/association-mapping.html](http://doctrine-orm.readthedocs.org/en/latest/reference/association-mapping.html) But really, redesigning schema without understanding what it's being used for seems like a really bad idea.
For small stuff I used phpmailer in the past. Worked flawlessly. 
1. No, sorry. The difference between "a couple kilobytes" and 3 KB would be pedantic. I'd even allow you up to, say, 20 KB. But you were off by a factor of **100**. That's *orders of magnitude*, my friend. That's not pedantic, it's gross ignorance on your part. 2. You rejected my original assertion that handling this problem by modeling the data with nested arrays was horribly inefficient. I can only assume you did so because you're under the mistaken impression that it isn't. In fact, it uses roughly twice as much memory, as I've pointed out. **This particular problem is the entire reason iterators exist.** Iteration allows you to process single chunks of data *iteratively*, and throw them away before moving on to the next chunk, effectively reducing the memory usage to a single chunk, rather than the whole dataset. The output buffer is memory used in *either* scenario. Loading the data into a giant array structure forces PHP to hold **two** redundant copies of the data - the one in the array, and the one in the buffer. When you stream data iteratively into the output buffer, you're completely skipping the array representation, and using **half** as much memory. Of course, you need to use iterable database statements and not return the entire dataset as an array from your driver in order to benefit from this. A lot of developers don't even know you can do this. I can only assume that this is where you're getting tripped up. *Edit: Apologies - I definitely meant generators, not iterators. Though, they're often intertwined.*
I've started a branch to add GMP support which is almost complete and ready for merging into master. It should be released as v1.1 While it is faster, my benchmarks have shown it's not that much faster.
Also this depends on what the PHP script does with that variable. I have seen cases where someone had an innocent PHP script that hammered the database with a 5 minute SQL query. This particular script calculated all of a large factories yield for the last quarter to date. Well surprise surprise as the end of a quarter approached everyone was going to that report and refreshing it often. Which basically crashed the SQL server. The fix was to cache the page so that the maximum frequency that the database could be queried was once every 10 minutes. 
This is a good question but it's tricky to answer in the way you want it answered. Why? Because the web page you're looking at is actually the LAST thing that happens you type a URL into a browser. Here's what happens: 1. You type a URL into your browser address bar 2. The server (which can be a server in a data center, or it can be just your own computer) reads the URL you typed 3. It then forwards that URL to PHP (or Ruby, or Python) 4. PHP (let's say, Laravel) reads the URL and checks to see if it matches a `Route::get('/my/url/here')` that was defined in your routes file 5. If it finds a match, it calls upon another PHP file that you've told it it should call upon should that route match (this is the controller - a controller is a just a PHP file) 6. The controller then usually calls upon a model (or any other file) to get data out of the database 7. The controller then calls upon a view file that contains the HTML, and gives that data from step 6 to it 8. The view contents then get echoed to the browser where you then see them In a framework like Laravel, steps 4 through 8 involve a lot of magic that Laravel does for you behind the scenes, so technically you really only need to know how to use Laravel, and it will take care of the rest for you. If you want to know how Laravel actually does all that, then you have to dig into the source code to understand it. But if you're struggling with this concept in general, then the key is to actually go back to two basic concepts 1. The basics about how a request from the browser works in PHP, and how file includes work. 2. The concept that you want to keep your code separate and organized (e.g. different pieces of code in different files) Then you will be able to grasp MVC. Now, to get at what I think is the crux of the issue for you, from a line in your article: &gt; Okay, great.. But all that just to see this? It's a bit disheartening. I'd like to develop a website, but if all those steps are required just to see this basic CRUD result, I can't imagine how much more will be needed for a fully functioning site!) It sounds like you're a bit overwhelmed the sheer scope and scale of what's needed to build a fully functioning site. What I can tell you is that yes, "all that just to see this" is true. But even more importantly, Laravel has done 90% of the work for you. If you were to write that CRUD demo from scratch, you would be writing 100x more code to do it somewhat well. 1,000x more code to do it well. There is a lot involved in making a site work, even with a framework. BUT, I would argue it's far less work than doing a responsive front-end with application-like behavior (ajax calls, javascript, media queries, stylesheets etc). So if you've designed and built a responsive website, then you've done far more work than is needed to do some basic CRUD stuff in a framework like Laravel.
here is a related good reading - &gt; "Design and Implementation of an &gt; Ahead-of-Time Compiler for PHP" http://paulbiggar.com/research/thesis.pdf
Few nitpicks: * Use Composer * Use Guzzle * Don't just throw generic exceptions. Throw exceptions that can be caught individually and handled.
In addition to what Disgruntled__Goat mentioned I would add the following: - Look at webserver logs and filter for *.php - If no VC is available for some reason then prepend and underscore to the file as flag for deletion and wait some time before deleting. 
This is where I think a clear distinction between developer, programmer and software engineer comes in. A developer can use the tools at their disposal to produce something, but they couldn't necessarily build those tools themselves. A programmer could build those tools, but not necessarily design them. A software engineer could design those tools, as well as determine the necessary architecture require to ensure they are utilized to their full potential.
Your filesystem may tell you when the files were last accessed, which may help. http://unix.stackexchange.com/questions/8840/last-time-file-opened
Nice :)
You can use it and for those with a shared host, create a downloadable bundle (like Symfony does).
When I attend networking events I have a policy to not try and sell myself at all. If people ask what I do I answer, and they always do, but I never bring it up. I found that people want to meet you, and find out what you do, and that by simply being interested in talking to them, and listening to what they have to say I find work without dealing with the typical sales rejections. Worst case scenario you meet a few people, who will most likely remember you at a future event. 
I get that argument. just doesn't make sense then to have a developer on staff if we can't/won't do things our self.
I haven't been able to find the calculations for finding if a point is contained in a polygon yet. I found a nice solution that requires mysql 5.6, unfortunately, I'm locked in at 5.5 until our host can be convinced to upgrade it.
Think more from a higher level point -- you are ingesting and refactoring legacy code. There are some general techniques to this thankless task. One of them is to make as cheaply as possible some basic tests -- like use Selenium IDE to walk through all the basic workflows, and just re-run those manually to test. Import the whole thing into git, include a database export of settings if that's where it keeps configuration. Then, you can be much more aggressive about yanking files, running your tests, and moving forward. You can recover the files from git if you need to. You will refactor to a manageable state much more quickly and reliably. Also, I second the suggestion for phpdcd, but more importantly you must track your changes and have some sort of tests.
Most produciton servers will disable atime because it's a performance hit, so it's unlikely this will be helpful.
You're still going to integrate it into the website, it will still be development work, but it's like assembling something from known good components rather than re-inventing the wheel.
That sounds so crazy it might just work. Do you have any good resources on GTK bindings, beyond the manual pages?
Yes... I know.. :)
**My wish list** Language features like: * generics * package private accessibility (i.e. class or method is only visible in the same namespace) * anonymous classes * __cast($type) (like __toString() * char, int8, int16 * data structures, optionally immutable (tuple, vector, list, set) * different extensions for files that have side effects and files that declare classes / functions Syntactic sugar like: * list comprehension * consise lambda expressions * native json and XML
Really like it actually. And I saw a PR for some tax mangement, which is just the last step to make it ready to use for me :) At the moment Im writing symfony bundles for both the price and intl libraries, but making the bundle for a master branch can lead to a broken bundle, which is not nice (been there, and its not funny) And yes, Im also making close to 100% code coverage (I havent found any way to test a __toString method) on the price library
Yup, it usually gets disabled pretty quickly, but its still useful to know. If you have root access, you could enable it for a while, check the atime on files then disable it again. Probably not the best solution in most cases though.
best answer so far
Well, that seems familiar. And no, I haven't read that yet. Thanks!
I thought relatime resolved that.
It definitely helps because it significantly cuts down on writes, but I have yet to see a single production server with it enabled. YMMV.
looks great, might consider using it for a project
You should look into this: https://www.paypal.com/cgi-bin/webscr?cmd=xpt/bizui/IntegrationHub-outside
So I have a payment gateway already set up through the theme I bought. I guess my question is more a long the lines of can someone read the code and tell me what to do or guide me on how to do it. Reading up on PHP right now so I may be able to figure it out. I feel like I am doing the right thing but every time I update the files online nothing happens. Just stuck right now.
I guess your solution could be a "dirty" rectangle SQL query to get a sub set of possible candidates, and then whittle those down in PHP land against your polygon region? Or maybe you can spin up a separate server/MySQL 5.6 instance and write your work as a rest API back to the main shared server? Might help spread the load too. 
OK, stupid question. What would qualify as a Programmer(PHP in this case). How can one tell if he's a Junior programmer? Genuinely curios.
Web server logs are going to be pretty useless as will only log the requested file - not anything included down the chain. Also any URL rewrites in play will only worsen the situation. 
I actually see this question quite a bit. But you really have to take what a developer is at face value--one who creates. If you don't create, you're not really a developer. (IMHO) Other than that, I really don't care what you call yourself, but you wouldn't call someone who gave a child cough syrup a doctor, would you? In the same regard, you shouldn't call someone a developer because they can setup WordPress correctly or create a few plugins for a pre existing CMS.
The best way to get started with Magento is to delete it from your development machine and never speak of it again.
Easily the best solution. And thx for the heads up with get_included_files() - nice find. Could log this data to Redis if your app is hosted on a farm of machines &amp; to avoid file locking/race conditions - wouldn't even need a full redis client. Could just open a raw socket to Redis and pump in the list of files as text/PHP struct. 
&gt; so my portfolio is sickeningly light for all the work I've done [We all feel like the butter robot, sometimes.](https://www.youtube.com/watch?v=8d_hveJL4mU&amp;t=20)
You are correct, I should have thought about the question a bit more than shooting from the hip. Upboat.
Let designers do design work, and programmers do programming work. Projects are so much better when you stop trying to be a jack of all trades. The importance of a highly skilled UI/UX designer can not be overstated. In my opinion, it's just as important as the programming.
 Lightweight - Because it's one file. Fast - Because it loads only one file. Customizable - Because it's one file, there is so much room for more. Flexible - Because it's written in PHP, and it's only one file. I'd like to point out this is only one file long. In case anybody was wondering.
I'd love to test it when it's released. Let me know.
catch 22 ;)
We are all learning - always :) No dramas :)
Here is a use case: An application written in php needs to become realtime. Solution: Use sockets.io and handle realtime things with Node.JS, while generating pages with PHP. Cons: Code duplication for DB access. Also if you don't have the legacy code, it's easier to start from scratch using Node.
I have never used it or had a need for it but what makes it such a bad program to work with? Just curious because I have seen a few job posting for positions related to it.
Eh I don't know why anyone would subject themselves to the chaos that is known as the WordPress api. Although I would think a developer would be able to figure out how to write one.
A programmer in my opinion would not think that the language has anything to do with him being a programmer. Yes you should know some and a few really well but you should be able to figure out any language and bug when required. We all work with very complex systems now days and should be able to with the proper time debug and understand them. 
Well first off they have little to no documentation, almost all their documentation is for non-technical folk on how to use their UI. Instead they rely on outside blog posts to teach people how to actually code in Magento for anything beyond the most trivial situations, and even then there is so much of Magento which they say is "Extensible" but the only way to learn anything about it is by reading the source code (the quality of which varies drastically from component to component). Third party library integration is pretty much a no-go. They don't conform to any sort of standard and roll their own custom autoloader so good luck using something like composer to bring in third party libraries. You're basically restricted to their "Community Extension Store" where some of the extensions are actually quite useful, but they are exclusive to Magento and thus won't be as robust or battle tested as the framework agnostic ones you could include from composer. Oh yeah, and a good many of them require ion cube to run, so if you have a bug or issue with an extension you can't even look at the source code or debug it. You just have to hope their code is behaving like they say it does. The database abstraction layer is one of the biggest culprit. They implement an EAV(entity attribute value) architecture which means that your one Product class is actually spread across 10 different tables, the exact same tables that your user class is spread across. Basically, the database will never be human readable. The amount of needless XML you will need to write is insane, and this is coming from a guy who loves Symfony. Any custom functionality you need to implement is done in the form of an extension, which needs to have every single way it interacts with Magento registered via xml. You like unit tests? How about cleanly seperated concerns? I'm not saying its impossible to do it, but Magento does so much to make it difficult and encourage you otherwise that if you get a job at a Magento development shop 99.99% change they don't have any sort of automated testing. The design patterns and skills your learn developing in Magento are (when compared to nearly any of the other big frameworks today) only useful for developing in Magento. You need to learn all the nuances of Magento and since everything is undocumented, whenever you encounter something new assume that it follows the patterns as you've seen before hope you're right, because if it doesn't you're in for a good time of digging through the Magento Core code. Also, many of Magento's features are pay only. So the whole thing about magento being free is true, but without paying you will get limit features and 0 support. Which, when you think about it, makes sense as to why they don't release any documentation, since it just means more people have to pay for magento Enterprise (10k per year per server) Now you might ask why Magento is as successful as it has been if all these aspects of it are so terrible. Well the reason for that is Magento did a really good job of filling a niche. It was the first, and likely the best among the shitty alternatives when it came out, E-commerce platform that could actually be used out of the box for people who had no programming experience whatsoever. This created a lot of situations where people were already tied to Magento before these issues I listed above were exposed and an alternative could have been chosen. Edit: Another goodie I forgot to mention. The default Magento installation ships with the entire Zend1 framework packaged as well. No, its not installed from an upstream source or by a git submodule or some sane form of dependency management (like, god forbid, composer????). The whole zend framework is strait up copy pasted into the lib folder. Oh wait, and it gets even better. It maybe uses 5%(?) of the functionality of the zend framework but still ships with the whole goddamned thing.
Better option than logging everything to file: Setup an opcache (apc, likely in this case), run site, ask opcache what files are cached.
My response was going to be "rm -rf /magento/path" but you beat me to it :D
Download an install - view a few template/controller files and how they are put together. Report back with your opinion after your five week bed-ridden recovery has passed....
It's better than trying to shoehorn WordPress into an ecommerce solution. And OpenCart. Oh OpenCart. 
Riak is adding data types (like redis) in the next version which is kinda interesting. The big advantage of Riak is that it's distributed. Neither memcache libraries, nor redis (yet) have ever really proven satisfactory for HA purposes. Riak, on the other hand, was designed for that from the get-go, so does it much more reliably.
Aura don't have such a package. The one you mentioned never exists. See /u/CertifiedWebNinja link .
How about prestashop?
Is that your #1 pick? I'll have to give it a go. 
Give [BigCommerce](http://www.bigcommerce.com) a go!
All of the above is true. I am in the middle of a Magento project, and every day brings new entertainment. To add a few gripes of my own: * The EAV implementation is tangled up between Core and Catalog modules, and trying to implement custom EAV entities required much reading of source code, single-stepping through a debugger, and copious amounts of copy-pasting code from the Catalog module. Now our codebase contains six custom EAV entities, and each of them includes: eight-ish DB tables, nine model classes, a pile of XML, eight classes (a controller plus seven presentation classes) to implement CRUD in the backend, and more. * The convention for referencing entities, modules, etc. You can use `class_bundle_name/relative_class_name`, `module_name/relative_class_name`, `module_name_relative_class_name` (resolved differently than the previous style) and probably more. There is a method behind this, somewhere. * The naming/architecture convention paired with the autoloader makes for really long class names. The EAV model classes in my project have names like this: `VendorName_ModuleName_Model_Resource_EntityName_Form_Attribute_Collection`. And they extend base classes with similar names. * The perverted use of magic methods to implement an arbitrary data store on all objects. You can use `$foo-&gt;setWhateverProperty(123)` and later `$foo-&gt;getWhateverProperty()` to read it back (the internal store actually stores that value under the key `whatever_property`, just to mess with you). How do you know if the data you want is `$foo-&gt;getTitle()`, `$foo-&gt;getLabel()` or `$foo-&gt;getName()` ? Duh, read the source code. And you get to enjoy all the "missing method" warnings from your IDE, because it's a very rare sight to find phpDoc annotating getters/setters that are actually used. * The XML parser is mental. If you have two sibling nodes with the same tag name, they will be folded into a single node. I get it, this is made so you can override one config file's content from within another file, since they are all collapsed into one great big ball, but it's still twisted. * You can substitute core classes with your own through XML config. What happens if two third-party modules substitute the same class? Probably, the substitution that sorts later alphabetically wins. It's not Magento specific, there is no winning move in this situation. * Internal error messages are useless. Most "string -&gt; object" lookups return NULL silently, so you get a generic "tried to call method of non-object" error after the fact. Most frequently, lookups are cached in private properties, so the error happens when that property is accessed, not when the lookup was performed. Have fun tracking back to see what lookup failed. * On top of that, some critical errors in *non*-developer mode (like PDO exceptions in install scripts) result in an exception dump, followed by `window.location = "about:blank"`. Which gets cached by Google Chrome in some weird way and it won't even reissue the HTTP request for that page any more. * Speaking of install scripts, there are two different helper methods to create a DB index when you create a table vs when you update a table. The first one supports indexes with specific column lengths, the second one only supports column names. * And I haven't even mentioned the theming layer. That thing uses even more XML to define all the elements (blocks) that will be included in the pages, so the designers can simply modify the XML to add/change/remove stuff. Of course, in reality this requires knowledge of things like valid XML, block reference names, etc. There's even a way to document certain methods that should be called on the block when initializing it: `&lt;reference name="product.info"&gt;&lt;action method="setTemplate"&gt;&lt;template&gt;mymodule/product.phtml&lt;/template&gt;&lt;/action&gt;&lt;/reference&gt;`. Easy. * Speaking of frontend development, Magento uses Prototype.js . So you need jQuery noConflict and hopefully all your plugins are compatible with that (of course, most of them will be, no big deal). The project I'm working on needs more interactive wizard-style UI in the frontend, so we actually removed Prototype from that and are building all dynamic stuff with Knockout and JSON, but that's just our choice. * A lot of JavaScript is peppered through the templates and uses global classes defined in other templates, making it ... interesting... to follow and extend it. With all that said, it's still a better option than OpenCart or almost anything else. DrupalCommerce could be an alternative if Drupal weren't so slow and loopy. WooCommerce might work for smaller shops, if you are willing to touch WordPress (I'm not).
My first thought was of how funny it'd be if you were like, "meh; I don't know... I might use it...". Not trying to be a dick; just thought it was funny enough to share :)
Not sure if this exactly addresses your question, (I pulled it straight from one of my blog posts) but it covers the topic of PHP and Node a little (it was mostly written for my own reference). ------------------------------ In this job you are always researching and using new technologies. Today I was looking at NodeJs again Here is a summary of the information: - I know NodeJs allows for server side Javascript code, but I was curious if there was a server side library for MySQL and JS - it looks like there is one called node-mysql2. It looks like it escapes parameters and has prepared statements so may be safe to use. - I know you use NodeJs to create a server, but here is the mechanics - you have a separate script to create the server listening on whatever port you decide, and you have to run that script on the server (just like you have to run Apache). Then in your client you connect to that script using something like SocketIO - once you have the connection you can send/receive data. - A difference from PHP is that the node server stays running and can memorize things, but this also means memory leaks can crash it and potentially you could return one client connections data to another client by mistake, so you need to program for this possibility. - People generally don't recommend NodeJs to server your static pages. They suggest using a combination of Nginx/Node or if you already use Apache, then a combination of Apache/Node. - The mechanics of these combinations: - if using an existing apache setup, you can use .htaccess to direct some requests to a different port (proxying) which is where your node server is listening. However you still have the Apache overhead if you do this. Call this an Apache/Node setup. - better is to make Node listen as your primary web server (on port 80) and have it proxy non-node requests to the Apache n(call this a Node/Apache setup as Node is the primary). You have to change Apache config file to listen on a different port but also remember to change the config files for all your virtual hosts too. - if you have a new setup, they recommen using Nginx instead of Apache as it is faster/newer/etc. but use it in a Node/Nginx setup (so Node is the primary) - One article talked about installing Node on port 9000 and Apache on port 8000 (so it does not have to run as root which maybe is not true if Apache is on port 80), then use iptables to reroute all requests to port 80 to go to the web server at either port 8000 (Apache/Node config) or 9000 (Node/Apache config). All very interesting stuff. ----------------------------------------------------------------- I personally don't think NodeJS is a good replacement for PHP but it is a different tool with different strengths to b used for certain types of applications. For any real-time interaction or constant connection between a web browser and server (long-polling type use cases) it would seem smart to use Node and something like socket.io but for normal CRUD applications, ecommerce, corporate intranet systems with extensive database access and reporting requirements, batch jobs, external interfaces etc. it makes sense to me to continue using PHP (or java or .net or ruby/python or whatever). I do think it is worth learning NodeJS to compliment your PHP knowledge, also to get the npm (Node package manager) and use it to install tools like grunt which can help during development (in watch mode) and also during deployment (compressing and minifying/uglyfying your files). It is also worth noting like all new tools NodeJS has some challenges. In particular the risk of someones bad programming on the server returning client A's data accidentally to client B when client B requests a page. This could be pretty bad depending on the application (i.e. dont use it for a banking app.) Just my opinion...
I don't understand why you're getting downvoted. Sure, there are other ways mentioned above, but your solution should work just fine. What am I missing?
Yeah, that's why I said that this is pretty much different products. Because Riak is just another level, it's almost Amazon motherfucking Dynamo.
&gt; Slim and ZFW2 at least centralizes their routes in a single file. At first I thought this was the way to go. It isn't. Defining the route, requirements, and even api documentation right on top of the action is a very nice way to work. If you want a list you can just php app/console router:debug | grep acme 
[Swap](http://en.wikipedia.org/wiki/Swap_%28finance%29) isn't really an ideal name for a library to deal with currency rates. Maybe they could have used Spot, Cross, FX, Curr, CurrPair, FXPair, etc.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Swap (finance)**](https://en.wikipedia.org/wiki/Swap%20%28finance%29): [](#sfw) --- &gt;A __swap__ is a [derivative](https://en.wikipedia.org/wiki/Derivative_(finance\)) in which two [counterparties](https://en.wikipedia.org/wiki/Counterparty) [exchange](https://en.wikipedia.org/wiki/Trade) cash flows of one party's [financial instrument](https://en.wikipedia.org/wiki/Financial_instrument) for those of the other party's financial instrument. The benefits in question depend on the type of financial instruments involved. For example, in the case of a swap involving two [bonds](https://en.wikipedia.org/wiki/Bond_(finance\)), the benefits in question can be the periodic interest ([coupon](https://en.wikipedia.org/wiki/Coupon_(bond\))) payments associated with such bonds. Specifically, two counterparties agree to exchange one stream of [cash flows](https://en.wikipedia.org/wiki/Cash_flows) against another stream. These streams are called the *legs* of the swap. The swap agreement defines the dates when the cash flows are to be paid and the way they are [accrued](https://en.wikipedia.org/wiki/Accrual) and calculated. Usually at the time when the contract is initiated, at least one of these series of cash flows is determined by an uncertain variable such as a [floating interest rate](https://en.wikipedia.org/wiki/Floating_interest_rate), [foreign exchange rate](https://en.wikipedia.org/wiki/Foreign_exchange_rate), equity price, or commodity price. &gt;==== &gt;[**Image**](https://i.imgur.com/wLz0U9V.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Philippine-stock-market-board.jpg) --- ^Interesting: [^Foreign ^exchange ^swap](https://en.wikipedia.org/wiki/Foreign_exchange_swap) ^| [^Swap ^ratio](https://en.wikipedia.org/wiki/Swap_ratio) ^| [^Forward ^contract](https://en.wikipedia.org/wiki/Forward_contract) ^| [^Recovery ^swap](https://en.wikipedia.org/wiki/Recovery_swap) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ck9rdlc) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ck9rdlc)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
The argument about really long class names is absurd. You do realise Magento was released in 2008, before PHP 5.3 and Composer, right?
Why? Do you have a better alternative that has a featureset as large, as complete and as stable as Magento?
Thanks, I read that while trying to get EAV to work. It's a good start. Afterwards, I found [this StackExchange answer](https://magento.stackexchange.com/questions/22367/how-to-create-an-eav-entity). But I still had to dig into the code to figure out some odd pieces that went over my head in the initial read-through or just weren't mentioned.
Magento was the reason I really got into development. You have to remember Magento is 6 years old and latest practices weren't around back then. For the feature set only Magento beats any Open Source ecom solution out there. However, if you do want a modern solution, check out Sylius. Very excited about the project.
&gt; Sylius I never heard about Sylius before, I will certainly take a look. 
It looks promising. Built with Symfony components.
http://nixcraft.com/showthread.php/13845-What-does-and-mean-in-Linux-UNIX
Both of these lines assign values to variables. In this case the value is a string that most likely is a path to a file (tpl extensions are most likely template files). When you are using ./ it means on the current folder. When you are using ../ it means on the parent folder. Both paths are relative to the script that executes this code
Fair enough, first time using this subreddit. Will do in future :)
Cracking, thanks.
Gave me the answer thanks
If you want to host local libraries without making them public it's pretty easy to install/configure Satis then add it as a repo on projects that want to use it. If you're not familiar with Satis it is like a static-site-host-your-own-packagist generator Alternatively if you just want to use the VCS option and don't want to commit every change to the library you could also be a little dirty and make changes directly in vendor then commit there and push back to source. Just be careful you don't lose your work ^_^
[Previously](http://en.reddit.com/r/PHP/comments/2e608k/the_most_annoying_phpstorm_parts/cjwi6c8) this was the most annoying thing about PHPStorm according to /r/PHP. And it's now been fixed - which is nice.
You're asking the wrong question. You should be asking "What does my project require from a db server?" Once you have an idea of what is needed, you can then very easily decide on a db solution. Consider the following: Size of DB, transactions. Saved statements. Essentially start to design your tables and relationships, get an idea of the number of db interactions your project. Also, you know, MySQL is a bit old hat but it is reliable and is well documented so 
Uhm, is BigCommerce open source?
We chose Percona because it has been professionally handled for much longer. 
Interesting that you don't want to be tied down to a third party, yet you seem to be tied down to a particular hosting company that only provides MySQL. I agree with others that say that POSTGIS is the way to go for this sort of stuff if you want to do all the spatial processing inside the database. Have you tried doing the point in polygon test outside MySQL. It might be quicker to use MySQL's spatial functions to get all the points within the polygon's bounding box (something that MySQL 5.1 does relatively fast), then test that subset of points in your application against the polygon. Here is a class that will do a point-in-polygon test (and a lot of other polygon related spatial functions) http://www.phpclasses.org/browse/file/10683.html I've used MySQL for many spatial data problems, but most of the spatial functions are performed within my applications, not by the database. Be careful with Lat-Long data though. MySQL will assume a flat geometry but Lat-Long data is used for curved surfaces. Your queries and geometry will only be valid approximations for relatively small areas of the earth's surface (like within a single city for example). 
Several of these checks are also in the [Expose project](https://github.com/enygma/expose) just in a different format. (note: I'm the lead dev on that one). It's a port of the PHPIDS library but heavily refactored. Looks a lot like some of the things here, just handled slightly differently. Expose could definitely use some more custom exception handling though...good to see that in your lib.
This is exactly why I've been using Notepad++ instead 99.9% of my work is on single files for quick edits.
Can I run the EAP builds alongside the regular install without messing anything up?
I'm struggling to understand how "professionally handled for much longer" was a valid reason for you to choose Percona regardless of it being the correct choice or not. Percona was founded in 2006, but MariaDB was founded in 1995 as MySQL eventually being forked essentially in name only in 2009 by the core programmers and founder. If you just compared the years 2006 to 2009 for your decision instead of actually researching which option is best for you, you might as well have flipped a coin. MariaDB being rebranded and forked from MySQL is identical to how Jenkins rebranded and forked from Hudson; both came under problems with Oracle locking down code and trademarks thus requiring a change to maintain development. Fedora even [aliased MySQL to MariaDB in their packaging](https://fedoraproject.org/wiki/Features/ReplaceMySQLwithMariaDB) to expand on the lineage. I'm not saying choosing Percona is a poor decision, but using "professionally handled for much longer" as rationale in this instance is a poor stance.
I don't have very much experience with Maria but both are actively supported. Maria always has a a presence at the Percona Live (formerly MySQL) conferences. Percona's whole business model is offering support and consulting services. If you have a consulting contract (which is not cheap) you can twist their arm to prioritize bug fixes. The fringe benefit of that though is you're still getting both bug fixes and features ahead of the curve of community MySQL.
Funny, how everytime I was describing why I use X IDE and brought the ability to edit single file beeing a must people were telling me how stupid I am and that I ALWAYS need to create a project, push&amp;pull things from VCS etc. and now it's an added feature and everyone is happy with it.
If you're considering MySQL alternatives, you need to ask yourself, "why?" What features do you need that only Percona or MariaDB can offer? &gt; People seems to prefer them over MySQL nowadays. Depends on who "people" is. Lots of large web presences rely on MySQL. Sure, a few have moved to Percona or MariaDB. Some of those even moved back to MySQL. Github, Mozilla, and Facebook in particular have been pretty open with their testing and experiences with MySQL and/or its forks and they've stuck with MySQL. Either way, just because people "seem" to prefer one product over another doesn't mean that product is right for you. You need to understand the differences between each product and judge which works best for you. If Percona has a feature you need, then by all means use it. Don't migrate "just because." I'd advise the same for those considering moving between any other RDBMS or between an RBDMS and a NoSQL solution: don't do it just because you think it's the cool thing to do. Make technical decisions on technical merits. If one excuse is that your OS of choice ships an outdated version of MySQL by default, so you might as well move anyway: Oracle MySQL provides repositories for Debian, Ubuntu, Fedora, and RHEL-compatible distributions - http://dev.mysql.com/downloads/repo/ Disclaimer: I work for MySQL @ Oracle. Opinions here are my own and do not necessarily reflect those of my employer and/or its affiliates.
[/u/phpdevster](/u/phpdevster) made me wonder if the first place to start is the template instead.
There's been a scratch plugin available for a long time :) Good to see it moved to the core IDE though.
Yes. There are two separate installs. 8 does change around some of the files in the .idea project folder, particularly with regards to source code formatting, though. So if you swap from 8 to 7 you'd need to revert those changes.
So was Zend framework 1, symfony1, and plenty of other frameworks. Magento has been significantly slower to adopt much of what has made php better in recent times. 
Mostly....running newer versions does make PHPstorm upgrade the hidden files that hold information about each of your projects. I've never encountered a problem switching back and forth between them, but if there was an issue, and you had a lot of custom settings in a project, losing them might be annoying. 
So was symfony, Zend, and plenty of other frameworks that have adopted the use of composer in the 2 years since it's been released. 
I can see your point. Being tied to mysql is really just that I'm a web developer working for a news paper, to say that my developer needs get overlooked a bit would be an understatement, lol, so talking upper management into giving me a better budget is pretty out of the question, as most ideas get shot down without much consideration. As far as doing this outside of mysql, because of my server options, a lot of my path is already pretty determined. I've done this in javascript before with google maps. The reason I want to do it inside the database is because I'd like the search condition to be done in the query. From looking into it more though, I think this operation will be a one time thing, then the results will be cached. For the accuracy though, a flat geometry should be acceptable. Right now it's something I'm playing with and it isn't a feature request (though I could see it going that way in the future), but since i'm just playing around with it, that's why getting a 3rd party service isn't too justifyable yet. All in all though, it looks like mysql can do it, but it can't do it too quick, effeciently, or with high accuracy. It looks like mysql 5.6 takes more considerations into this, but as luck has it, I'm on 5.5, lol
Postgres?
Been using EAP only for the past 2 years. They are stable enough to be used in production.
Depending on the complexity of your polygons and the number of different tests you need to do you could write a simple point in polygon function as a user defined function. One type of point in polygon test will shoot a ray from the point and count how many of the polygon's edge segments the ray crosses, if the number is odd then the point is inside the polygon. To do this using the spatial operations available in MySQL 5.5 you could create a separate table that stores and indexes all the edge segments as individual lines.This test can be made quite efficient but it will bog down the server if you have complex polygons or if you need to perform the test on large numbers of points. If you use a PHP function like the one I linked to then you would still be doing the test on the server, just not in the database. I urge you to consider this option if your PHP skills are good enough. Why do you want the search condition to be done entirely in the query? Caching the results is definitely a good idea if you think the same test might need to be be performed again.
The package we got from Percona was ridiculously cheap - something like $100/yr.
The hot bug fixes I was referring to starts at 30k/year http://www.percona.com/products/mysql-support/prices
So we got that goin for us. Which is nice. 
I have the feeling any of the 3 tools would do the job very good. Why an alternative? My answer: why not? I'm just wondering which tool I should get, and not choosing MySQL by default without consideration. It's a new project, no "migration" is involved. I don't want to think about scaling right now, because I don't have a problem right now. But Percona and MariaDB have emerged because they perform better. At least that's what they say and what we find when reading articles over the Internet.
I think you get the idea. I'm creating a company and developping a SaaS solution. It's indeed a great opportunity for us to use different tools and test out new technologies. All 3 tools (MySQL, Percona &amp; MariaB) seems to be very compatible (some people told they installed mariadb, service stop mysql + service start mariadb and everything was working the same as before), hence I consider the switch is not a big risk and and I'm expecting it won't cause any major trouble. PS: I'm pretty sure we don't need NoSQL nor AngularJS, at least for now.
If you are looking to expand your knowledge and this is a personal project I'd say give it a go rather than just using a MySQL fork, just use MySQL.
I'll have to check that out. The reason I wanted to do this operation in mysql is because it'll return only the matching results vs pulling a few thousand polygons (some of them rather complex and odd shaped) and testing them all in there individually. Even if the math takes the same time to execute, i'll be losing time on the transfer of data since one only return the matching results and the other returns everything, leaving it to me to discard them. In general, I try to keep the number of steps in my code minimal. lol it looks like this is still a developing area for php/mysql though. And from what I'm seeing, mysql is taking more notice to this with the changes in 5.6. mysql may not be my best option, but right now, it looks like it may be a better option. But as a fact finding mission, given my server limitations, I don't think I have any preferable options infront of me. Caching is where I think I'll go with this though. A one time operation, whether it's done by MySQL or PHP, sounds like a no brainer and I'll just store the results.
yay can finally get rid of a few other text editors and just keep storm open all day long
Friday afternoon in the code mines here, I read that as 'PHPstorm now allows catch fire' 
To be honest, the "idea" of this thread came to me after reading this one: http://www.reddit.com/r/PHP/comments/2ai79z/improving_web_app_performance_with_memcached/ The article was talking about memcached and all the comments say "you should use Redis instead", and pointing out a clear "winner". In my mind, all 3 engines (MySQL, Percona and MariaDB) are pretty much the same and I have no particular reason to choose one over another, so I was looking for feedback before picking the de-facto MySQL.
Is it really worth switching to PHPStorm if I've been using Notepad++ for a while?
If you have the lat/lon points already, one of these will help you display them on the map. There are others too. These are just off the top of my head. http://leafletjs.com/ https://www.mapbox.com/ http://developer.mapquest.com/ 
Although I agree it should throw an InvalidArgumentException, it does raise a warning; http://3v4l.org/Y3t5q 
Fair enough. But just as a point of clarification, I wasn't suggesting returning "everything" just returning the points that are contained within the polygon's bounding box (something that MySQL 5.1+ will do). You'd still have to discard some points, but you'd have done the bulk of the filtering already using a bounding box spatial query. See here for a graphical representation of the difference http://www.programering.com/a/MTNwQjMwATI.html 
ahhhh, I see what you're saying. yeah that's a good approach. lol looks like given my current setup, this is a bit of a pain no matter the approach!!
Or maybe you should start profiling queries and caching.
Fucking finally!
Yeah but when you consider the rest of PHPStorm, there's really no comparison with other IDEs anyway.
No, Percona has been an enterprise grade product since their start. Maria, until recently was a half maintained open source project that couldn't even keep their website up to date. They offer no features that would make it worth taking any kind of risk on it. We did plenty research. 
Double Postgres with a side order of Postgres. Because any question that starts "Should I use My" **Postgres**.
&gt; Frankly,plugins should be totally sandoxed,in any serious system. PHP unfortunatly doesnt seem to be able to do that. Plugins are totally sandboxed. The problem here is the filesystem doesn't also apply sandboxes to each individual component. So, writing a badly done plugin allows people to piggy back on a function that uses the file system. TLDR; Nothing to do with PHP not being able to sandbox properly just a developer who missed something.
It depends on what you need from the database. Both are "drop-in replacements" for MySQL so 99.999% of the functionality is going to be the same. Start with whatever your platform gives you - Ubuntu will give you Oracle's MySQL CE while the other distros like Red Hat, SLES, etc will give you MariaDB. If you're on Windows (God help you) then just download the MSI from Oracle's website. IF/WHEN you need the alternate DB engines or corporate support contracts then you can give Percona a try. But the bottom line is unless you're at the enterprise level handling tables with 600 million records+ of semi-real-time data across 2 database clusters (I hate my life) then none of the edge-case differences will affect you.
Oracle MyPostgreSQLite Server 2012
Opinion trap. Your opinion of the context of a plugin is different than the documentation from wordpress that outlines their definition of a plugin. TLDR; Nothing to do with PHP not being able to sandbox properly just a developer who missed something.
If you are actually developing this with the hope of it becoming a money maker, you really do need to *research*, and there is a very real possibility that the answer is then neither of those three. PostgreSQL is widely held to be one of the best (*the* best) open-source databases available and for good reason. There are still valid reasons for preferring a MySQL derivative but they are few and far apart. MySQL has very real problems, and MariaDB as well because it's so closely aligned with MySQL. I have never used Percona but I'd be surprised if that doesn't also. It's true that Facebook uses MySQL, but Facebook uses it as a key-value store, not an RDBMS. MySQL has proven to scale *very* well for such use cases, but those use cases are also comparatively rare. If you end up needing NoSQL, it will be as a cache-like layer on top of an RDBMS. There are virtually no scenarios in which NoSQL can reliably replace an RDBMS for an extended period of time. Caching can be solved by many tools, most of which are not formally NoSQL (e.g. Redis).
Wow ... all the alternative MySQL hate on this thread is unsettling. From my own personal experience, MariaDB is a really nice fork of MySQL. Not only are the storage engines improved (MyISAM sucks in comparison to the Aria storage engine), but the bloat from MySQL isn't there. ([ibdata1 file issues](http://www.percona.com/blog/2013/08/20/why-is-the-ibdata1-file-continuously-growing-in-mysql/) aren't present either ..) MariaDB is actively developed by the majority of MySQL's former Open Source developers, including the MySQL founder, Monty. Since it's a drop-in replacement for MySQL, it makes perfect sense to use Maria. AS for Percona, there seems to be more of an emphasis on scalability and security for the database, with some added storage engines to help with performance. From a development standpoint, since the Open Source version of MySQL isn't receiving updates in a timely fashion, it might be best to use MariaDB for development. Most major Linux operating systems even use it when MySQL is installed with a package manager (with the only notable exception being Ubuntu). From there, you can evaluate if you need to have any of the features in Percona, or not. For me, the improved storage engines have been a huge plus.
MariaDB is (probably unnoticeably for prototyping) [faster than MySQL now](https://blog.mariadb.org/2014/08/).
[Google uses MariaDB](http://www.theregister.co.uk/2013/09/12/google_mariadb_mysql_migration/). Facebook uses [its own fork of MySQL](https://github.com/webscalesql/webscalesql-5.6), not Oracle's. Before that, it's always had a medium sized set of performance patches it applied. I imagine after Oracle has started closing up the infrastructure for MySQL (bug / security reports / [new tests being invisible to the public](http://blog.mariadb.org/disappearing-test-cases/)) they've created an official fork instead, very much the same impetus that jumpstarted Maria.
I've been using Sublime Text 2 for this. The best part is the scratch files are actually soft-saved, removing the need to keep the app opened. If you want to discard the file, close the tap.
Regarding ditching sublime for PHPStorm now that it can edit files without being part of a project ... a key factor for me in comparing apples to apples is the _slow as molasses_ startup time for PHPStorm vs. sublime/notepad++, which both open basically instantly. PHPStorm takes a good 30secs just to start. If I need to do a one off quick edit, I want something that fires up nice and fast, not wait half a minute for an editor to start like Word 6.0 in 1996.
Oh, yes. Even the basic package is well worth it, though.
While I sympathize: i) I have a 4 year old mac book pro with SSD. It opens any of my projects in less than 5 seconds, and some are not small. Either your machine is rubbish or it could be something wrong with PHPStorm - there have been issues where it re-indexes continually which obviously hurts performance. ii) How often do you change projects in a day? I save way more than 30 seconds an hour using PHPStorm...so even if it was that slow to startup, it'd still be my go to IDE.
No argument at all against being the best go-to project IDE. I was specifically responding to people saying they'd now ditch sublime/notepad++ for quick file edits.
&gt; Clearly the call is missing a constructor parameter.. but that should raise an exception, not silently yield null You should forget any notion of what is reasonable to happen when working in this language. If given the option to tell you that something is wrong, or do something nonsensical to let the code continue to run, PHP will opt for doing something nonsensical.
In PHP, any bit of included/eval'd code has full access to everything and any fatal error will end script execution immediately. There is no sandboxing of any kind built-in.
&gt; A quick look at github would show that the Magento2 rewrite is moving the framework into the modern era of PHP. I'm not sure what you expect them to do to Magento1 without breaking everything. Stop acting like the codebase is like Wordpress, because that's simply not fair I'm not saying its wordpress, I was asked for a list of reasons to avoid Magento and I gave them. I even mentioned that at the time Magento came out it was probably the best vs the alternatives. But that's not an excuse for falling so far behind. Magento 2 should have been released by now, hell it should have been released a year ago. 3-4 years ago, sure Magento was probably a viable option. Now days, why would you pick Magento? Magento2 could very well remedy all these issues I've listed (although I have my own doubts) but Magento 2 isn't out yet. Its not supported and has even less documentation then Magento 1. So if any developer asks me "In the year 2014 should I use Magento" my answer will be "No". And this isn't to say some of the alternatives like WooComerce and OpenCart are any better (I just don't have as much experience with their shitiness as I have had with Magento).
All good points. And you're absolutely right on your points about being able to write good, testable and decoupled code in Magento. However, like you mentioned, the fact that the god object exists and is promoted as the way to integrated into the framework means that every component needs a wrapper around it to be testable. This among other things makes writing testable code more difficult, and so if you aren't starting a new project odds are the previous developer didn't write unit tests or decouple their code. That said this issue isn't unique to Magento, and its still a million times better than rolling your own framework, but I would say Magento nudges your more towards this type of code base than Symfony or Laravel (and trust me I have my criticisms for Symfony and Laravel also).
Rename all files with prefix "off-" or similar. Then watch the complaints in the logs, un-rename step by step. You will also find out where exceptions are badly implemented and if the messages point to the right problems - that's the advantage over the other suggested methods :) - try to do ALL the tests of the behaviour and edge cases you'd expect before saying "done".
He also forgot an opening bracket [
It's even more weird, this is the reverse (i.e. yaml_emit() of $arr = array("baseval"=&gt;array("a"=&gt;44,"b"=&gt;"er","c"=&gt;"xxx"), "someotherval"=&gt;array('l'=&gt;'a13',"x"=&gt;"n","n"=&gt;"www","t"=&gt;"xyz"), "somethirdval"=&gt;array("yes"=&gt;"zzz","y"=&gt;"asd","z"=&gt;"uio")); echo "&lt;pre&gt;",print_r(yaml_emit($arr),true),"&lt;/pre&gt;"; which results in this (note the quoted "n", "yes" and "y") it's definitely intended and appears to take n == no == FALSE and y == yes == TRUE. baseval: a: 44 b: er c: xxx someotherval: l: a13 x: "n" "n": www t: xyz somethirdval: "yes": zzz "y": asd z: uio 
So you're still saying "don't use the ecommerce platform with the largest featureset"? Do you really think a merchant cares how hard it is to develop for? No. They just want a working site, and if they don't have to pay for someone to develop all these features they want, what choice do you think they'll make?
Not since MySQL 5.6 I don't think. EDIT: Last time I checked though MariaDB was on 5.5
Here's the problem: Web Design and Web Development require two completely different ways of thinking, and you're asking for Design-oriented answers to Development-specific problems. This is not an easy question to answer. I feel like /u/phpdevtester did an excellent job of illustrating some of the finer points of what actually *happens* between the time a user types a URL into their browser and the time they see a page pop up, but in the grand scheme of things, this knowledge won't particularly help you when you attempt to actually get your hands dirty and write your own application. The thing about Laravel - and I know that you already know this, but it bears repeating - is that it's a *Framework*. I don't normally like using analogies, but take a look at it this way: If you want to build a house, having the latest and greatest tools and machinery is going to make your life a lot easier than having to build it using a screwdriver and a shovel. You know this, you did your homework, and you've secured the best possible equipment you know can get the job done. But in this scenario, you still have to be handy and have a solid understanding of architectural engineering if you want the house to stand properly. Frameworks give you the tools, but not necessarily the blueprints or a team of handymen to help you with some of the finer details like electrical work or plumbing. And that's why it all seems so daunting: You're standing there with a whole bunch of machinery around you, all these powerful tools and materials, but you never quite learned how to run a backhoe to start digging your foundation. To be quite honest, I never graduated with a computer science degree either. Everything I learned, I learned through nothing but application. This is the best way to learn, and I think you're eager to start, but in my opinion a Framework is not the best way to go about it. Start with a CMS. Hell, start with a crappy one. Start with one that teaches you how to do things the WRONG way. Despite the fact that it's an architectural nightmare, I would suggest to start with Wordpress. The reason why I say to start with a CMS is because CMSs by their very nature are **module-oriented** while frameworks are **code-oriented**. If you don't know the code, then you will fail spectacularly in attempting to leverage the most an MVC framework has to offer (not that this is actually a bad thing either, but it can be disheartening). Going back to my earlier analogy, a CMS will afford you the opportunity to take on the role of a foreman, and you'll be able to simply tell your team of professionals what to do vs having to do it all yourself. At least with a CMS, you'll have the ability to control your front-end with minimal code involvement and focus on the design aspect..... but you will still have to get your hands dirty and write some code. Start with making your own theme from scratch. Don't look into starter-themes or child-themes, just read up on the codex and figure out how to make your own. Once you feel like you're in a comfortable place with the PHP that you do know, try writing your own Framework. You are almost guaranteed to fail at this. I know I did. But still, do it anyway. You will learn a TON about the interactions that happen between the client, server, and the languages that drive all of them.... and maybe even a bit of humility. Once you have that under your belt, THEN try a framework. Things will come much more easily that way, and you'll feel a lot more confident in everything. You'll also know which tool to pick up first before you build your new house.
&gt; ve just parsed the json and checked the php objects for existing properties/objects. Maybe I'm not understanding the problem. json_spec is about to test data stored in json, not schema of responses. For example, you have a rest api, which stores data in mongodb. It this case ID of records always be unique strings, and you can't just check equality of strings. The same thing for time stamps. json_spec allows you to exclude such fields from matching. Also it allows you to match only part of json by given path (it's pretty annoying to specify whole responses for each scenario. Also it's really hard to maintain such tests). If you want to have strict checking of json shema in every scenario, it's not so hard to add such steps or create simple matcher. But it's not so easy to maintain such tests. Anyway, we mostly want to check is API returns correct data for given scenario, and this is where json_spec may help you. Check example of user api spec in README.
Notepad++ is my goto sidekick tool in all my development environments. i use it for smali editing, PHP 'shell scripts' and for search/replace instead of Eclipse
well finally. i have a 'misc_stuff' project that i used for this very reason.
 Except most of those features are just strictly worse versions of open source alternatives that you cannot use with Magento because... it doesn't support composer. Doctrine and Eloquent (although I personally don't like active record) are both vastly superior to Magento's ORM. Same with Magentos templating, Laravel blade, Symfony twig, Aura.View are all vastly easier to use and offer more functionality than Magento's templating. Now what Magento does ship with that the others don't is an out of the box, working ecommerce application. But once you have to do custom development all the time you saved from Magento's out of the box usability is quickly lost (especially with regards to maintainance). A merchant cares about their profit, and since ongoing development is expensive Magento will actually lose them Money in the long run. (Especially considering that if they do switch to Magento2 they will still end up having to pay for a bunch of extra development that they would have avoided by switching to a modern framework). Now if they just need a basic, out of the box shopping cart use, don't use Magento. It tries to be both super customizable and workable outside of the box whereas in both categories there are superior solutions
Any framework can help you make a secure REST API. I'd suggest looking at multiple frameworks and seeing which one you like the most and can work with easily. It's all about preference! I'd suggest starting by taking a look at, the hot favorite these days, Laravel (http://laravel.com). You can easily do REST API's with it, test it and secure it (with Basic Auth - which takes exactly one line of code to implement or OAuth2 - there are a lot of packages available out there for this).
I would personally return a boolean and leave it up to the user to throw exceptions and catch them later if they want to. 
Why not do them all? Set up a config that lets the user choose. Perhaps default to boolean or at least mention that it exists in the docs.
That's a strange one. Is there a compelling reason to do this beyond not typing seven characters? I'm sure others will have differing opinions but this feels like adding yet another Whacky PHP Inconsistency(TM) for minimal gain. Even with the RFC version something like: $username = $_POST['username'] ?: 'Guest'; is still more cumbersome than a solution like: $username = $post-&gt;value('username', 'Guest');
If that's what people want (judging by the recurring `ifset()` requests)... Personally I don't believe it's a good idea to provide a **super-suppression** syntax shortcut. Newcomers in particular are already applying `isset() ? :` too imprudently and then wonder about *silently* appearing empty strings without any notification for absent input. Everyone more experienced is already using input hadlers in some form or the other, which provide both default substitution *and* notice recoverability. Since this is the primary use context (as the RFC also implies), I'm not sure it's useful as general behaviour change.
PDO works this way, but I don't recommend it. Pick a method and stick with it. It's not worth the headache or overhead to implement. Most of the core PHP functions return `false` on error, but I personally prefer exceptions because you can't ignore them. Silently returning false causes a lot of errors down the road and it be hard to track down where they're coming from.
Have you tried CodeRunner? While I typically use Sublime for my quick edits, I find this to work best when I don't feel like booting up my vm server and want to test out some code. Not only that, it will also compile my c# code for work.
Yea. CodeRunner for Mac is a good choice too if you want to make a change without booting up the server.
[Good one, bro](http://sadtrombone.com/)
When you can do &lt;?php echo "hello world"; ?&gt; 
If you are looking for a good book to get some help I suggest this one https://leanpub.com/build-apis-you-wont-hate
Thanks for pointing that out. I agree.
&gt; Should we deprecate in PHP 5.7 and remove them in PHP 7 This never gets old.
can you explain..?
Why not just add two functions, get($key, $default = null) and post($key, $default = null), that will return values of the corresponding key from $_GET and $_POST super global, and return the default value if not present..
It was intended as a joke; other subreddits have fancy colors etc, I was just mocking it. I appreciate the colors. My apologies if it offended anyone. 
It already exists: http://php.net/manual/en/function.filter-input.php 
Trying to compare Doctrine and Eloquent to Magento's ORM is a waste of time, because Magento uses an EAV database structure. If you think Magento's templating system lacks functionality you've clearly never tried to use it to its full potential. I get quite a bit of enjoyment sometimes working out new ways to bend Magento's internals to my will.