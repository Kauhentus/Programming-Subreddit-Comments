&gt; It would be nice if I could wrap some third party API call in a try, catch certain notices or warnings that I care about, do something with them, and maybe let execution resume where it left off. It's been years since I've seen any third party library of framework that triggered a notice or warning as part of it's normal operation. In fact, since it's been common practice to avoid it, I've never seen it. This just isn't a problem in practice because it's always been a bad idea to have notices or warnings. 
Yes, it would help.
Fortunately it's ~~only the wiki subdomain~~ not the main http://php.net/ site - don't know how many subdomains are affected.
Depends on whether you want the property to be inherited by its subclasses. If you do, then protected. If not, then private.
Well, shit. I've been on php.net quite a bit recently. Anyone know which antivirus programs will detect it?
Stop blaming PHP for your inability to comprehend weakly-typed languages.
it should always be inherited, if bot its not a sub class
&gt;Essentially, whoever set hacked the servers and set this up wanted to avoid the site admins themselves seeing it in action, so they didn't set it up to serve every user on every hit. Additionally, if one user is served a malicious userprefs.js, notices it, and then reports it, when the admins check it out, they'll see that the userprefs.js on disk is perfectly fine. Er, no, it's not that. What's happened is that the malware is replacing the JS file with malware every so often. However, the server has an automated rsync job which keeps its files up to date with the official version from git. So the malware would replace it with malware, and rsync would soon enough replace it with the original, then the malware would re-replace it with malware, and rsync would re-replace it with the original, ad infinitum.
They provided a link to a list in the article - [here](https://www.virustotal.com/es/file/816b21df749b17029af83f94273fe0fe480d25ee2f84fb25bf97d06a8fadefe4/analysis/). The ones that detected it as "Tepfer" got it right.
typical weakly-typed behavior is not really a good thing. plus javascript has its saving graces (it can't do damage on the server side, prototype based objects, execution stops when an error occurs, etc) which php doesn't.
That looks like a whole lot of commonly used anti-virus getting it wrong.
that's a pretty stupid statement 
Wow didn't noticed that link, thanks for the highlight
More again information, explainning the how the code affect users with iframe and browser plugins: * http://www.alienvault.com/open-threat-exchange/blog/phpnet-potentially-compromised-and-redirecting-to-an-exploit-kit ([sources](https://news.ycombinator.com/item?id=6610896))
For real. For one, why is that used as a photo for the article, and then besides that, wtf is with that tongue. Ringworm of the tongue? \*shudder\* Edit: Oh god do not follow the wikipedia link.
Cross-domain AJAX isn't possible anymore. Is there a way to block cross-domain iframes in your browser? Or at least ask if you want to allow them?
There are plenty of IO functions that throw warnings to indicate problems, in addition to returning false. Sometimes, these problems are resolvable, if there were a convenient way to capture which warning occurred and then resume. Doing that with error handlers is awkward as hell. Most people seem to address potential IO issues by relying on sanity checks prior to the actual operation. This is an incomplete solution, since it's possible for the situation to change between your sanity check and the operation. I've also seen these dealt with by muting the function's error output and treating any false response as a generic IO error, but this is sloppy. A catchable exception would be the best way to handle these, but there are clearly benefits to not always having these be fatal when uncaught.
php also has goto, it still makes no sense becazse you can access your own properties
Are you a troll, or what?
if ($_POST['word'] == 'word')
you dont always have to use the language gives you, if you want to make things hidden create a new class if an interface where they are protected, because if you cant access your own properties theres something fishy
Thanks man! :)
You're either a troll, or you're ignorant how PHP and OOP in general works, and wilfully so. Either way, I see no point in continuing this. Good bye.
I worked with Phrozn, too. The architecture felt foreign to me and I wanted something that ran and felt more like Jekyll. It didn't seem like it was going to be easy to get in there and hack w/o major changes and I did not want to disrupt Phrozn's trajectory. As for the state of things when I started Sculpin, Composer was just coming into vogue and Phrozn was still heavily relying on Pear and Pyrus. I wanted to start working with Composer more and ended up using Sculpin as a test bed for Embedded Composer. So all in all, there is nothing wrong with Phrozn! It is a fine choice for a PHP static site generator. Both are slightly different in implementation. Depending on your personal tastes you may prefer one over the other.
If you wanted to build a system based on Sir Trevor that modified the static source files it would probably be a pretty good fit. Sculpin itself (the executable) operates w/o any sort of web based front-end so building it into Sculpin *might not* make sense. Hard to say. :)
let's take a code example try { $object = null; $object-&gt;method(); } catch (Exception $e) { echo 'exception caught'; } finally { echo 'finally called'; } if you ran that right now on php below 5.6(assuming this RFC makes it w/o BaseException, you would get a fatal error. If you ran it including the patch you would get the result: exception caughtfinally called If we use BaseException, meaning that EngineException(fatals) are extending BaseException rather than Exception, then it would still fatal out just like before with out any code change. This is absolutely crucial that PHP do this so there doesn't have to be any kind of refactoring for php 5.6's adoption. In a real world situation if a developer was working with a badly designed library that had multiple exceptions but no base exception of it's own(aka you have to do a catch(Exception $e) to cover any exception it may throw) you didn't implicitly say you wanted to catch php errors as well, and with out BaseException you are now doing this. &gt;And what happens if BaseException is added and someone adds a handler for that then in PHP 5.7 some more exceptions types are added? Are we going to add a ReallyBaseException because now they're getting more exceptions that they didn't expect? I don't necessarily agree with this premise here. Catching BaseException in 5.6 means we're catching all exceptions+EngineExceptions. With every php error being converted to some form of EngineException, what else are we expecting to be created that isn't covered by that?
I'm not sure I'd call it non-intrusive, since you're littering instructions all over your code. Your main competitor is xdebug; you should explain why I want to use your tool instead. 
Why are you registering the autoloader on init? Try this: function template_autoloader ( $class ) { if (strpos($class, 'Element') === 0 || in_array($class, array('CustomAdminPage', 'CustomAdminSubPage', 'AdminPageSection', 'CustomPageBase'))) { require_once($class.'.php'); if (!class_exists($class, false)) { throw new Exception(sprintf(__("Unable to load class: %s"), $class)); } } } // register an autoloader function for template classes spl_autoload_register ( 'template_autoloader' );
I had previously tried this and it didn't work. The site just comes up blank. I tried it again with the init removed and it still breaks. I just checked the PHP version...it's 5.2.19. I dunno, it seems like the code above (in your example) should work, but it doesn't. That's what is so odd. It seems pretty straightforward to me. What am I missing? 
Go into wp-config.php and find the rule that says define('WP_DEBUG', FALSE); and change it to: define('WP_DEBUG', TRUE); That will turn on error_reporting and tell you exactly where the error is, that might help.
I wish they'd lower their prices by $50 or so for the non-'intellij ultimate' products. phpstorm 7 looks really slick, but $199 vs Netbeans' free is really hard to beat for me considering my employer is cheap. Here's to hoping they do another sale sometime soon for personal licenses: I created a pipe to track sales via RSS - http://pipes.yahoo.com/andrewk/jetbrains_sales
This is a bit too vague to help you I am afraid.
+100 form me. This should be implemented as soon as possible. I was bitten hard by it while developing my [autocomplete plugin for vim](https://github.com/m2mdas/phpcomplete-extended#phpcomplete-extended). My goal was simple, write a small script that iterates the fqcn=&gt;files maps listed in autoload classmap generated by composer and create ReflectionObject to get info of the class format as index. If creating ReflectionObject throws exception then discard it and move to next file. But in practice the plan failed. It seems that ReflectionObject throws exception only when the main file of the class is not found. It just throws fatal error if one of the class in its class graph(e.g the class that extends/implements and their class graph) in not found in the path. So I had to parse each class to ensure that every class of the class graph exists in the path and after then call ReflectionObject to get info of the class. It was painful :( But at the end it is in workable situation right now. Had this feature been implemented before, my life would be much simpler. 
I know it came from an article about mouth diseases, but it sure looks like a pedobear to me. Hmmm. 
Ok, so I'm not sure what the problem is/was, but I got it working. I thought I'd post back in case anybody runs into the problem, or would like to explain it to me. I used some old school debugging with an echo message to trace the error to the following lines. I was getting a blank page when it hit the first line of this group. When I opened CustomAdminSubPage.php, it was a class defined as below with two functions inside: class CustomAdminSubPage extends CustomPageBase { Since it extended CustomPageBase, and CustomPageBase was being loaded after the CustomAdminSubPage, I just thought I'd try to switch the order. When I load CustomPageBase first everything is now working properly. Also, it did need the spl_autoload_register('__autoload') as well. If you have an insight as to why, I would love to understand it further. Thanks for your help. require_once(dirname(__FILE__) . '/CustomAdminSubPage.php'); require_once(dirname(__FILE__) . '/CustomPageBase.php'); require_once(dirname(__FILE__) . '/AdminPageSection.php'); 
or xhprof.
Nice site. I like github trend which has more that just php data. https://github.com/trending?l=php 
If i remember correctly those channels require a registered nickname in freenode, so try to register one for yourself. I'm afraid i can not post a link with info about that since i'm writing with my phone but a quick search on Google should point you to the right direction. 
hmm ok, my nick is already registered by me, so it should work? :s
How are you connecting to irc?
Interesting. It's a GreaseMonkey script, though. Not something you can use in a stock browser.
You need to also be identified with NickServ. /msg NickServ identify YOURPASSWORD
Bring this one in for sure. Some really fine work (once again) from /u/nikic
I got it now, thanks a bunch. I was using a BNC, wasnt identifying correctly. Thanks for the support! Should i close/delete this thread now ? Im new to reddit :)
All i'd like to know is why attack PHP website? Is it some sort of attack against PHP as a programming language, or the people behing the PHP website?
While it might be intrusive (it really is) this is great for people that don't have the ability to install php extensions. 
The AV I use isn't even on the list. Consumer reports says its the best AV currently. Webroot AV anyone?
or DBG
&gt; If we use BaseException, meaning that EngineException(fatals) are extending BaseException rather than Exception, then it would still fatal out just like before with out any code change. This is absolutely crucial that PHP do this so there doesn't have to be any kind of refactoring for php 5.6's adoption. This is wrong because any code that triggers a fatal error is fundamentally broken. It's not working. Any fully working code is obviously, by nature of it working, free of fatal errors. No existing working code is ever going to trigger an EngineException. There is no backwards compatibility issue here. 
In my experience no A/V software is perfect. At the moment I'm using a combination of MSE and Malwarebytes. No complaints so far.
Ok, bad example however replace that fatal with a notice or warning... The project I work on specifically ignores these errors, chosing to log them instead... Stupid I know but it's valid php code that will fail in 5.6 unless we get BaseException 
EngineExceptions are only for fatal errors. &gt; "This RFC proposes to allow the use of exceptions in the engine and to allow the replacement of existing fatal or recoverable fatal errors with exceptions." For notices, warnings, and regular errors there already exists methods to handle those as exceptions (optionally). I feel bad for you to have to work on a project that ignores warnings and notices but this won't prevent your code from running in 5.6. 
Read the RFC closer the end goal is to replace all errors 
Don't build your own framework, imo. That's an intellectual exercise and if you don't feel super comfortable with even OOP, that's probably going to be an endless pit for you at the moment. Can you describe what type of work you're in and what type of problems you need to solve? Might be easier to provide you some advice. Do you use templating? If you're currently mixing html and php, get away from that. It's a pain to maintain and it's just flat out ugly. Learn something like twig, smarty, etc. Learning the MVC pattern is crucial if you're building a scalable system. Learning how to properly model classes for reusability and separating your concerns into model/view/controller is invaluable. You start to think in terms of reuse quite a bit more frequently and your code becomes a LOT cleaner. Once you understand the premise behind MVC, choosing a framework will be a lot easier.
The entire RFC only lists fatal errors (well except for E_RECOVERABLE_ERROR but very little legacy code is even aware of that). So my point still stands -- this won't affect anything. 
I used to be you, but then decided to try out CodeIgniter - changed my perspective quite a bit and now start pretty much 90% of my projects with it as the base.. actually I started trying all kinds of framework and now produce cleaner code in less than half the time of starting from scratch. CodeIgniter + Bootstrap (CSS) + JQuery has taken my designs from just working to working and people enjoy using it. Once you get a handle on MVC you might also check out something like the Joomla platform, it provides so much built in functionality that you can focus more on creating components built around it instead of spending time getting a basic system off the ground. All of these projects also have a great userbase and regular updates to the code fixing security issues and such.
I learned MVC design by using CodeIgniter - totally changes your thought process for the better. It just makes so much sense. 
True - there have been times where I have caught myself about to write db code in a controller instead of the model - but then I realize it does not make sense to do so - that is the power of the model that you can load it into ANY controller to gain access to the functions it contains. I mainly suggested CI since it has an easy learning curve to get familiar with MVC - the more you use it the more you figure out why MVC is awesome. Laravel and Symfony have a much higher learning curve and might put off someone new to MVC (I admit though that once you outgrow CI then those are you most likely next steps).
It was available
I was told that a model should never be responsible for it's own storage/persistence, so wouldn't that mean that DB code *should* go in the controller?
&gt;If you're currently mixing html and php, get away from that. This is what I'm doing and I hate it. Though only templating engine I'm familiar with is Laravel's Blade engine. Does it work outside of Laravel and would you recommend it to be used as a standalone?
Maybe you can try silex/slim, it will make you programming more cormfort
You really have two choices. 1. Frameworks. There are some good frameworks around. Symfony, Laravel, and (I've heard) Yii are recommended. Frameworks are a really good way to be super productive. There's an argument to be made that you don't really need to know that much of what's going on behind the scenes to be able to use them, but you certainly should know basic OOP. 2. OOP - Some of the basic principles of OOP are what really matter. The patterns (like MVC, which is mentioned a lot) are often trying to achieve what's called "separation of concerns". You can step up to OOP from flat PHP by trying to separate as much as possible. Normally I advocate frameworks, but if you're just starting (or haven't started yet) on OOP, it's probably worth doing a few small projects using OOP. After you start building some classes, etc, you can move up to using a framework.
While I do understand how template engines work, and what they're supposed to solve, don't you lose some performance in interpreting them? I suppose you could use caching techniques if you wanted, though. I don't really mind PHP templating as long as it's done correctly, and it usually is not, to be fair, but setting up some classes which store data from the logic end for access to the php templates is pretty easy. As far as it being ugly, don't know, I don't mind it all that much, but I guess that's preferences. Most frameworks do have template files, though, so I guess it is worth learning. It also keeps people from inserting random logic quick fixes into the template side, so there is the separation. I think if you're working on a big project with many others it should be worth it, I guess. If it's a personal project, though, I probably wouldn't bother.
I recommend this. A microframework will get you started on how to utilize package managers, will make you re-think how you structure your code and ease the transition to larger frameworks.
I actually learned OOP through learning CakePHP. the code i was writing at the beginning was pretty bad, because I was pretty much writting flat PHP within an MVC Framework. As the project grew I started looking into best practices a cleaning up my code, all the while getting a hang of OOP. Now, 2 years later, I feel comfortable in any MVC framework. My advice is, pick a personnal project for practice, pick any well known framework(sugestions: CI, CakePHP or Laravel), and start coding. You will learn along the way.
I was quickly able to abstract the blade engine out of laravel for use in some smaller projects. 90% of it worked, the only thing that didn't was the @master and @include stuff - because that relied on other classes within the Illuminate namespace.
Build something like social network with flat code, then you will see that things going messy, thus you will be forced to switch to OOP.
I'll bite. One of the apps I work on (a hand-me-down) is very large and written procedurally. HTML is placed in PHP files because I think that's what went fastest when this was written. I've added on to it over the years (groan). I like the idea of using templates, but with so little time to actually improve code, I wonder if migrating a huge app to smarty is going to be a major project in itself. Or could it reasonably be done a little at a time? 
In general, I'd say it's good to focus. Stay focused on PHP. Focus on one framework. Focus on one type of application for that framework. If you find a niche, your value will go up. People will pay more money for you to build that thing you just built for someone else vs. build this random new thing I'm not sure you'll be able to build. If what you are focused on isn't useful or valuable anymore, you can always switch. It's not like you stop learning. Specifically, I'd say that there is lots of money in WordPress development. Some poo poo it as a framework, but it works really well for that purpose once you figure it out. Knowing straight PHP before learning WP (just like any other framework) will help you in a lot of ways. As someone with an outside perspective, you'll be a resource to any community you get involved in... although it can be rough. Good luck.
Available? What do you mean?
There was a security hole that they could exploit - nothing more to it.
Why would anyone use that half-baked solution when you have [Twig](http://twig.sensiolabs.org/)?
You could progressively add individual components to your stack. Start with [Silex](http://silex.sensiolabs.org/) and use it only for the routing. The rest of the logic, you can do it as you are used to. When you feel like using a templating engine, add Twig. Continue to develop apps normally. When you feel like you need more abstraction power for your database, add Doctrine's DBAL (and later ORM, more advanced). Then learn PHPUnit, learn how to create testable code, and create tests for every important part of your applications.
Doubt it, or my browser cached something fishy, as I see the same JS attached to the site once in few requests.
Oh... Alright, thanks man.
&gt; If you're currently mixing html and php, get away from that. But that's all the fun in PHP 
It's probably not going to be an overnight thing, that's for sure. And if the application is mission critical, you may want to hold off. Every company seems to have their legacy stuff that everyone hates to support. You pretty much have to do the analysis and determine whether it's worth it to convert it. I'd recommend doing something relatively small at first. Think about a small, self-contained subset of your site that mixes HTML and PHP and doesn't use MVC. Create a branch off your master as a sandbox and create a model that makes sense. Install something like Twig in that environment and try to get it working properly. Then you'll have an idea of what's involved. Honestly, there are certain situations where it's not worth it. I'd just lean toward doing new development in a proper way. However, if you can see a light at the end of the tunnel and have the time, I can't recommend it enough.
Templating engines add a mild performance hit. Let's be honest though...if you have real-time, mission critical concerns, you're probably not going to be using PHP in the first place. You'd do things like that in C/C++ and have thin wrappers on top. If performance becomes a concern, implement a caching strategy if you aren't already. You're going to save a lot more in caching than you would by avoiding a template system. The real benefit is the development time. You can change views without any fear of white screening. You can immediately determine where to look for something you're trying to change (data, html, javascript, etc.). Want to swap for an entirely different data store? Takes you half a day instead of half a month. Don't underestimate it. I'd use templating on anything other than the absolute smallest projects, and I might even use it then. Once you learn it, it's trivial to implement.
Thank you for the advice and *thoroughly* explaining when to use and when NOT to use the protected type.
Thank you. I didn't know if there were any pitfalls from going that route. Time to re-factor and get rid of all these unnecessary database connections!
The easiest way to handle this is a single apache rewrite that rewrites every request to a single router that you can write however you like, from simple (file layout dictates site structure) to complex (dynamically generated routes from app configuration or db models). For a really functional CMS, you're probably going to want your page URLs editable in the interface, so a db model that handles finding routes will probably be needed.
Mostly because when I started working at my company I was assigned to a pre-existing project. Also although my boss stop me from using them he doesn't really like frameworks and templating engines.
Whatever you do, don't do HTACCESS thing, because your app will then be locked to Apache.. Nginx handles redirection differently.., and you should be using Nginx if you're worried about performance. What I would do is use basic routing techniques. Basically just always redirect to a single file where it's sole responsibility is to show what content. Example /articles/hello-how-are-you Index.php job will be to explode the URI... If the first argument is articles, look in articles database for article with the slug name hello-how-are-you, and display it. As for performance, you shouldn't worry. It's pretty fast until you reach a certain amount of articles... Just make sure you index your DB properly. You can always make some kind of cache or something.. 
Learn Symfony. By learning Symfony you will not only learn a framework and a lot of standalone components that actually make up the framework, but also a lot of general architecture stuff that will be useful for you as a programmer. Also, since Symfony is very modular you can reuse your knowledge of components even if you're not using the framework.
You should not be using .htaccess, you should have a bootstrap that takes requests and dispatches them to proper controller/etc for handling based on configuration. There are tons of solutions that already do that, you can also write your own. It might not be a bad idea to have a microframework do routing for your CMS.
Thanks for the reply, this is what I was thinking. I could live with one query per visit on this although I'd rather not. I did make the URLs editable, I have all the data but my missing link is from the page request. Does it make sense to want to avoid using SQL for this or is my pigheadedness just getting in the way? Since URLs don't change too often (for my purpose, not a blog or commerce) it may be safe to write them into the .htaccess file directly? Or write a php config file of sorts with an array instead of calling the database each time (Would the array be faster and less load)? To achieve that I just use a mod_rewrite (much like WordPress') and I use something like $_SERVER['REQUEST_URI'] to find out what the user is trying to reach, look it up, if found yay, if not... 404 :) I know I can alleviate my concerns with something like http://www.phpfastcache.com/ or better yet memcached or whatever. But I'm hard-headed. 
My understanding is to separate the I/O not going between the server and the client into the model. So DB, file, sockets would be done in the model, the controller glues everything back together before loading the view.
If you don't want to use a database then use proper caching, what you're describing is an awkward half-baked sort-of-cache idea but in the wrong place. There are a bunch of libraries and applications available for proper caching. If you haven't done any development in a few years I highly recommend you pick a simple project or three and build them and see where things are at, going into a project like this with no grasp on the fundamentals is the fast track to wasting your own time and building a not suitable for production application. This would be like building a car without having used a screw driver :-)
Oops. For some reason I throught it was a phar. sorry. This is not good for people who can't install extensions :p
Good point, plus I'm going about it in an old/useless way. Maybe I'll look into .NET MVC since I can cache objects easily and can produce something a little more viable. I think CakePHP is an MVC framework too. Edit: I'm going to work with my .NET dev to build a custom CMS based on the specific needs I have, .NET and MVC. Going to be the best route for me as we can plan a better solution. Thanks! 
I'm guessing it is to make it generic, so it is not tied to a specific back-end. It is also easier to parse and check and escape data when the programmer has already split the statement up somewhat.
Well that's good. Safari was also saying PHP.net was suspicious but is no longer.
The article is misleading, because even though it was initially thought to be a false positive it turned out the servers behind php.net were in fact compromised. See: http://php.net/archive/2013.php#id2013-10-24-2 &gt; the php.net systems team have audited every server operated by php.net, **and have found that two servers were compromised**: the server which hosted the www.php.net, static.php.net and git.php.net domains, and was previously suspected based on the JavaScript malware, and the server hosting bugs.php.net. The method by which these servers were compromised is unknown at this time.
Unless you're running very high traffic levels, you don't really need to worry about anything but really large or unindexed queries. Assuming you're using Mysql, etc the query cache removes most of the internal overhead on these types of queries anyhow. I think your confusion is coming from rendering your dynamic content to files before serving them to your front controller. Why not just have the front controller render the content directly and return (echo) it. If performance becomes an issue later, you can either optimize your rendering engine or deploy caching higher up the stack.
Hi, thanks for the reply. I thought about that approach as well. Sort of like SiteCore, I think. And can use an out-of-box caching solution for larger sites. 
&gt;The real benefit is the development time. You can change views without any fear of white screening. You can immediately determine where to look for something you're trying to change (data, html, javascript, etc.). Want to swap for an entirely different data store? Takes you half a day instead of half a month. Don't underestimate it. I'd use templating on anything other than the absolute smallest projects, and I might even use it then. Once you learn it, it's trivial to implement. That's the thing, though. You can do the very same things with PHP. I can make a templates directory, label the files properly and I really don't see the difference. For example, widget.tpl.php, if you want to edit it, go right ahead. If you want to fiddle with the logic, there's separate files in the place where you'd normally place your logic. I'm not advocating sticking everything in one file, I'm just saying if you structure your code properly I fail to see the need for template files outside of it being what equates to a giant "don't stick logic in this file, ever" sign.
I agree with his guy based on my experience on inheriting a couple of company-critical projects. You don't really want to make drastic changes but when you do - start by shifting core code into classes and test the shit out of it before making other major changes. Once it's obvious that you can easily extend/fix the current app it'll make the sell easier for further redevelopment.
you can do mvc without oop and make it look kinda ok and maintainable.
It kinda depends on how you [understand](http://stackoverflow.com/a/5864000/727208) model in context of MVC.
That's one of major fallacies that you have unfortunately picked up from CodeIgniter. Controller is not "a glue between" anything. Controller has a specific responsibility: altering state of other parts of MVC triad based on user input. It does not collect data from model, it does not initiate views, it does not perform authorization checks and it does not send responses to client.
Don't dump a bunch of rules into .htaccess: * You can use a [RewriteMap](http://httpd.apache.org/docs/current/rewrite/rewritemap.html)-- still ties you to apache. * You could create a router php file and with your simple .htaccess. * You could just use the filesystem (either in index.php's or use mod_rewrite to omit the php extension). Based on your architecture, so far, I would guess the last approach fits best. It'll require a bit of attention to make sure you don't give users access to change system files (preferably check a whitelist when saving). mod_rewrite-wise, you'll get *slightly* better performance turning it off (though I don't recall if "slightly" is an understatement or an overstatement). IIRC, nginx doesn't have such a performance penalty.
This is interesting but I notice it's yet another profiler that focuses on memory deltas before and after function calls. I am curious if it can be used somehow to track leaks in "global" state (not global variables necessarily, but e.g. class statics or static variables inside of functions)? Put another way, is there a way with this (or any) profiler to get a snapshot of the biggest objects in memory at any given time? 
Not sure if you are saying the controller cannot collect data from the model, initiate views and perform authorization checks... but all of my controllers do exactly that. They call functions in the model and receive data back from them that is then manipulated and possibly sent to other functions in other models or to views so they can use data from the model as well. I also code Joomla components and the setup there is a bit stricter - but very much the same thing.
In that case you **really** need to start learning basics of MVC. Begin with quick skip-over of wikipedia article (pay special attention to "component interaction" bit) and then read http://martinfowler.com/eaaDev/uiArchs.html That should move you from "misinformed" category to "newbie".
For the lazy: /r/phoenix --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
"Would love to target women/girls" That sounds creepy. "The idea is that it would give experienced developers/programmers an opportunity to give back in the best way they can." I'm not following, why do developers need opportunity to 'give back' to new comers? I might be annoyed because there seems to be 100's of these ideas by 'somebody with a decade of experience', which I might add without context means absolutely nothing as I can be writing Wordpress templates for 10 years. Anyways, there are better groups in that area (Google) that already have a track record in doing things like thing. 
I was in a similar job whilst at, and after, university where OOP, design patterns etc. weren't really considered by the other developers as important. That really pissed me off because maintenance was a bit of nightmare, we had duplicate code all over the place, no design pattern(s) to help with providing good solutions, and generally poor standards all over. That's one of the major reasons I decided to leave and find a better job. What is it that you don't know about putting OOP into place? Like others have said I wouldn't go about building an MVC framework yourself. Well not at least until you get the grasps of it using an existing framework such as CakePHP which is fairly easy to use.
The hate is strong in this one.
Dont force people to use pimple , if object instanciation is complex ,write factories. Doctrine ORM does that , i'm pretty sure that Doctrine ORM is more complicated than yours.
lol no comments &amp; a bunch of downvotes. OP you must have pissed some people off w/ that title :|
Wow - this goes against every tutorial I have read... and I have no idea how this would apply to stateless web design. The reference link uses Smalltalk 80 as a language to apply the pattern - which retains state between interactions. With web development you literally have to do the authentication in the controller - there is no way to directly access the view's or models from once it has been rendered on the client machine / sent to the end user - even if you use Ajax - you still have to access the controller to perform other functions. Is it possible the MVC you are accustomed to is different for MVC used on the web?
Figured as much. The /r/programming comments were bad enough.
Most of the popular template systems compile to pure PHP. Twig and Blade both do. This gives you the advantage of opcode caching as well. At work, we do a bunch of javascript/CSS minification/uglification automatically during builds, which are triggered by commits to trunk. It wouldn't be a big deal to pre-compile changed templates as well, though we don't use any templates yet.
Idk how helpful this will be to you. Take a look at the Taproot Foundation. I work with them in Chicago. They don't train anyone, but they take the same type of experienced professionals you're looking for and have them work on a pro-bono projects in their industry, for non-profit orgs. They deal with lots of stuff like branding and strategy and stuff, but they also deal with web development. Not sure how that might help you, or if you have one of these near your. Same type of people with experience and willingness to volunteer as you're looking for, but maybe also how they are organized - idk. Just saying.
I think it's related to the fact that you can use it in production (non intrusive in terms of performances).
Same. There is more than one valley in the world.
google "call repository from view symfony" (1st hit): http://stackoverflow.com/questions/11754077/how-can-i-access-repository-functions-in-twig-template-in-symfony2 google "call model from view cakephp" (1st hit): http://stackoverflow.com/questions/13396705/cakephp-2-call-a-model-function-from-view Both answers clearly state that you should not do it. Whether you can or cannot is not really relevant IMHO.
Interesting question, I'd like to know the more-or-less right answer too. Or at least what are the better options.
error_log() with tail -f is the smart alternative to var dump. 
Re-thinking things on a regular basis is important, good advice.
I'm not currently developing in PHP, but here's how I use dependency injection in one of the "library" parts of my project: I've designed all the parts of the library, and then I built a LibraryStack class which is instantiated by a LibraryStackFactory abstract class. The LibraryStackFactory class defines a whole bunch of methods - makeFoo(foo's dependency), makBar(bar's dependencies) - and one makeStack(stack's dependencies) method, which instantiates the LibraryStack, and the LibraryStack sets a bunch of properties on itself using the LibraryStackFactory's make*() methods. I then extended LibraryStackFactory and implemented its methods to create the actual objects, so I could have DoctrineBackedLibraryStackFactory, for example. Users of this library then create a DoctrineBackedLibraryStackFactory, call makeStack() on it, and then access your library through the LibraryStack returned from that. As a general rule, most of the LibraryStackFactory's make* methods can be implemented in LibraryStackFactory, while anything that is likely to change from deployment to deployment should be implemented in a subclass. And here's the best bit: because I've written my code with dependency injection in mind, users of the library can easily define their own MongoBackedLibraryStackFactory, or LibraryStackFactoryWithThatOneBitChanged. But if they want to use your library as-is, they don't even have to care that you're using dependency injection. It should be relatively easy to fit Pimple into this design. For example, instead of having a bunch of make\*() methods, you could have a bunch of configurePimpleFor\*() methods, call all of them, then define the properties on your LibraryStack from the pimple object. EDIT: For the record, for my current library, this design is all-in-all under 50 lines of code. Well worth it, IMHO.
Interesting concept... just a couple of notes for OP The source references a debug() function that doesn't exist... It's quite obvious that these are meant to be recursive, so I guess the author wrote the function called debug() and just changed it to var_debug() before publishing but forgot to update these references. Any particular reason this uses debug\_backtrace() to get the filename and line, instead of just using the magic constants \_\_FILE\_\_ and \_\_LINE\_\_?
I like xdebug's version of `var_dump()`: http://xdebug.org/docs/display
Thank you for your comment, recursive calls fixed :-). The __ FILE __ and __ LINE __ give the current file and line and not the invocators AFAIK.
Most decent frameworks will provide good debugging options. Start there tbh. No need to reinvent the wheel. When that's not available or just not working for whatever reason a trick I like to use is to turn on output buffering, var dump whatever and then error log the output buffer contents. It works for xhr or requests that don't ever print to screen unlike a standard var dump.
&gt; The problem with “var_dump”: It may output so much information that it locks up your browser (and your web server thread). While I'm all for finding better ways to debug, is this *really* a valid complaint? I've never had this issue, and I've dumped a shitton of info with it.
So putting aside for a moment how your factory works (though I will certainly be looking at that in more detail), is it safe to say that the package or library can in the first instance be written as a "bunch of classes" that require dependency injection, but don't care how that dependency injection is implemented? Then on top of that factory classes can be written, and so could DIC classes, both of which can sit side-by-side as alternatives that can be used, and either of which can be implemented within the package or within the application (though inside the package makes more sense for reusability)?
[Xdebug and You: Why You Should be Using a Real Debugger](https://jtreminio.com/2012/07/xdebug-and-you-why-you-should-be-using-a-real-debugger/)
dpm() uses krumo, which you could also use without Drupal. 
If your var_dump produces so much output that you need to use that crazy method, you are not properly debugging. 
Women and girls in the development/programming communities are significantly underrepresented in the industry as a whole. As a father of a young lady, I have seen very little in the way of compensating for this imbalance. You don't sound like you have anything particularly beneficial to contribute so why bother responding? Trolls will be trolls.
You being a father has absolutely NOTHING to do with women in technology. You bringing it up is cringey at best and frankly a little pathetic. You went out of your way to separate them out and that's the main problem. Instead of helping 'developers' you want to separate them into groups of women and men by focusing on one group more than the other instead of being equal. So you are creating another stupid barrier, if people want to learn they will come no need to 'cater' to women as (AND THIS MIGHT BLOW YOUR MIND) women who are looking to code are no different than the men looking to code. I'm responding because you posted on Reddit, deal with it or move on if you don't like it. Two way street. 
Google "php png-8 to png-32 conversion"
most common one is scottland I believe
That'd certainly work, and is how I've done it; although the idea is simply to package up the details of connecting everything in your library into the factory class. If you've already developed your code to use Pimple, fine, so long as the applications using your library don't need to know about it. Basically, the factory is the last thing (aside from anybody extending your library) that should know about any details of what dependency injection framework you've decided to use. To clarify: your library code is allowed to know about the dependency injection framework if that makes things easier, the factory definitely should, but the application code definitely shouldn't. You then document your library as if everyone's going to be going through your factory; you don't explain how to instantiate a FooWidget, but how to get a FooWidget from the stack object. Hopefully, your documentation never even needs to mention that you're using Pimple except in the "extending this code" section. Everybody using your library then creates a factory, and from that creates a stack object, then uses the library through the stack object. (Note that I'm using stack here to refer to a [solution stack](http://en.wikipedia.org/wiki/Solution_stack), not a LIFO stack. If you come up with a better name for your particular library, use it.)
I'm in the same boat. One thing I have found that I like is Behat, a PHP BDD framework 
I've found Behat as well, also phpSpec. I would like to see someone build an application with either one; to see how are they actually integrated with a framework like Symfony etc. Both are documented, but a real world, thorough example would be really helpful.
Chrome users should check out Chrome Logger for logging data to the browser's console, it's much easier to work with than var_dump: http://craig.is/writing/chrome-logger
Try var_dump'ing a Doctrine entity and see what happens ;)
Okay, good point. Now I fully understand what you mean. I believe we are both half wrong (or half right). I agree that Symfony does allow you to call model methods from the view and even that such usage is promoted in the documentation. Still I never use the (Doctrine) hydration mode that allows this. In CakePHP on the other hand you pass "dumb" arrays to the view and I believe that what you say is not possible. So in you definition that would make CakePHP MVA right?
What are the advantages of using this language over just using PHP or Ruby? For now, I don't see any reason why I would.
Cake would be MVA is you were **forced** to put only dump arrays into view. Since it's very much possible to pass objects that have methods that contain logic its still MVC by design. However you can turn any framework into MVA if you force yourself to use Mustache logicless templating.
State your question better.
Fuck me. [DRY](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
As one of the developers of Krumo I can't recommend it enough. It's a great debugging tool and under active development: https://github.com/oodle/krumo We're open to suggestions for new features.
I follow the pattern, 1. Service that used by the consumer 2. DI container that setup the service and manage internal dependencies. 3. External dependencies are injected into the internal container for example the logger, database etc. When I use pimple I roll them into the same class. If you download my library you can supply extrenal dependencies and away you go. I don't think you need to get more complicated than this. 
I often feel the learning curve is way too steep and benefits do not pay off. I encountered colleagues taking months to become productive in Symfony and I did not feel it was easy to learn for myself either. Still I want to avoid using vanilla PHP. I often find myself looking for the ideal cost/benefit trade-off. Right now I am building a framework that tries to hit that sweet spot (for me) for a 1-2 day project: http://www.leaseweblabs.com/2013/10/mindaphp-new-php-framework-optimized-learning/
why can't you just upgrade on your own? using linux means this is pretty much mandatory for a lot of things anyway
Is it possible to do without downloading the source manually? (Like PECL, which handles download and compilation for you.)
But this just gives the same output as `print_r`, what exactly is the point?
Same goes for javascript. If you're writing console.logs in your code you're doing it wrong
Yep, and if your application features those console.log calls in production... Institutions with IE without the development tools installed will just stop running your JavaScript at that call.
5.5.5 is in the extra repo on arch. The reason I have stayed with arch is the bleeding edge support and the fact that it hasn't broken yet.
I think we can stop with the arch is unstable fud. For the standard in repo packages it is every bit as stable as any distro I've run. 
My recommendation for you is to use a package manager like apt-get and use it to pull the build dependencies for PHP. sudo apt-get build-dep php5 Will pull the build dependencies for PHP to allow you to compile PHP 5.5 without too much issue. On top of that, you can install checkinstall for Debian-like systems which allows you to create Debian packages in lieu of calling sudo make install which makes it easier and cleaner to remove your compiled version of PHP when the time comes to upgrade it. Send me a message if you need some more guidance in the compilation process. I'd be happy to assist.
Phpfarm is what I use
This is great. I'm building a vagrant machine with PuPHPet, and it only has LTS 12.04. Would that work with this repo?
Debian Wheezy: [DotDeb.org](http://www.dotdeb.org/instructions/) provides a repository with PHP 5.5 Ubuntu 12.04+: [Ondřej Surý's PPA](https://launchpad.net/~ondrej/+archive/php5) provides a repository with PHP 5.5
Compile from source - under Debain/Ubuntu this is super painless. Self plug: https://github.com/magnetikonline/webserverinstall.ubuntu12.04/blob/master/install.md#php
take your favorite forum script (phpbb ,...) and read the source. i'm sure you'll learn plenty of stuffs.
We shouldn't be encouraging people to use references; their semantics generally trip people up. 
Maybe it's just that I live in Silicon Valley - but when I hear "the valley" in relation to tech I just assume is Silicon Valley.
I use debian all the time, but for their stability. Never knew about checkinstall, thanks! Usually use Arch and their ABS along with makepkg. TIL.
You do know that "stability" in these terms means consistent APIs, right? Arch will update you without hesitation to new major versions of software... that makes it VERY unstable. Stability is not about bugs or crashes.
I think you need error handling and guessing you need to replace &lt; with &lt;= in your for loop. This is purely speculation because you didn't post any code. "Numbers Only" doesn't work. Needs a bit of work.
When it gives you the password, it should keep you on the page with the form and display it at the top of the page like "Generated Password:" and it should save your form information in case you want to generate a new one with the same criteria. Being redirected to a blank page with just the password on it isn't smooth.
Also, you need to know that Behat and phpspec is not the same thing. Behat tests the behaviours approaching it from the outside (specifications, user stories, use cases, etc.) while phpspec tests it from the inside (on a class level, just like phpunit). BTW, you can do BDD with PHPUnit too.
- https://github.com/Sylius/Sylius - https://github.com/akeneo/pim-community-dev - https://github.com/KnpLabs/KnpBundles - (Discontinued) https://github.com/KnpLabs/KnpIpsum
I just test it - put **N** number of characters and the result was **N-1**. Think /u/JamesB41 is right about replacing &lt; with &lt;= ... or something like that
If you have $12 to spare, then http://knpuniversity.com/screencast/behat
I know for sure that **ArchLinux** has it - current version is [php 5.5.5](https://www.archlinux.org/packages/extra/i686/php/) 
If you want php feedback why not post the source? Theres only limited feedback that can be given. if you post the source you'll get proper php feedback. Also why not just implememnt it in javascript? People don't like passwords to be sent over the internet...
I haven't been able to use it very much. I've got it on my server now and I use it for a very small project and it seems cool, but I don't have anything else to use it for just yet. But when ever I get another project to work on, I'll be using it!
Thanks for that, I'm new when it comes to BDD. Can I use (or should I use) them together? (Behat and phpSpec)
Thanks, looks nice.
In my experience, clients never write BDD style specs... they just don't do it, even if they understand the benefits and could learn the syntax to write it. The usual response is that our team must make sure that we produce the highest quality code. Usually we just do PHPUnit/phpspec style tests, for large complex projects we write some BDD style feature files and use Mink. 
yea, sure it is framework in a php extension ... it feels great... but if it is **you** and put it in a production env, how you will be able to maintain the new versions, updates, security fixes and issues ?
How does Codeception compare to Behat? Are they used for basically the same thing? 
A quick google brought me here: https://github.com/phalcon/cphalcon/wiki/Powered-by-Phalcon
I made a simpler Javascript one quite a while back - you can just drag the link into your bookmarks toolbar, then it's right there whenever you need it! http://hughiew.co.uk/blog/web-development/password-generator-bookmark
yep, that's my biggest concern about it. I wouldn't have to skills to delve into the code, patch it and recompile :(
I've looked into this framework for 5 minutes and my gut feeling is it's going nowhere.
or just use chrome which has it inbuilt
Its clean and well commented c code. The big risk it carries is that if it is abandoned it may not be easily patched to support newer versions of php. It would be nice to have a php implentation of phalcon as a fallback, of course it would be anywhere near as fast, but at least php devs can patch php code. I really hope it grows a large following. PHP benefits from performance enhancements.
Scheduled downtime or take down one server out of load balanced set at a time. You can pecl compile the update whilst old version is running. Then install and web server restart next.
Great insight. I wish I could determine the worth of a software project with a few minutes and gut feelings.
All I know is my gut says maybe.
Question about BDD. Isn't it basically just TDD funcational/acceptance testing?
The other reason for a fully-compatible php version as a fall-back is that it would be interested to directly compare the performance of phalcon + php 5.5 + opcache vs php-phalcon on hhvm and also it could be used for code hinting in IDEs (I know stubs already exist for this purpose).
feedback/ideas: * submit the form via ajax, dont change the current page. (easy done with jQuery) * let me generate multiple passwords at once * make em easy to select&amp;copy * restful endpoing for automated password creation * use checkboxes for options, so i can mix and match the flags i like * let me get corresponding hashes too (ones i frequently use would be mysql-password/old_password, salted hmacsha512) my guess would be, you're quite new to php, this stuff will keep you challenged a little :)
Firebug is technically obsolete. Firefox has a native console now as well. I don't like the output formatting as much as firebug, but...it's there. 
Fedora 19 is on 5.5.4 right now.
You are not alone, to many websites rely on "plain old php" and hosting too :) hehe Edit: wording stupidity lol
I think this type of release new PHP 5.5 version will more helpful for my group and it's users. 
&gt; All you need to do is buffer your output and send your var dump to the error log. You don't know what they need. Sorry you are so angry.
Not quite yet. The built-in debugger on Firefox is getting there and has some nice features but still can't beat Firebug IMO. That said, I use Chrome for daily dev
I've actually started converting the Phalcon Form builder and validation and other form related functionality into PHP. I like the way they handle forms compared to other frameworks. It doesn't rely too heavily on other parts of the framework, or templating engines. So it fits my needs for framework-less projects in which I need to process forms. Anyway, the conversion process hasn't been that bad! Most of the C code is actually quite simple to understand. It's basically reading PHP as spoken by C. 
make it bit user friendly :),also when you type different characters the schould be same kind of warning and consider same javascript or css :) Also same sort of password strength indicator would be nice like on this site [this](http://password-hash.com)
I was telling you, as in 'You'. And im not angry in the slightest. But it's good to know that you somehow have the authority to stand and represent their needs. in that case, you need to let them know what I said. Barfing out echoes and var_dump's to the view is most retarded, and should not be a thing. There is an error log. Guess what it's for?
Thanks, that makes a lot of sense. I think one thing I am trying to get my head around, is what looks after various instantiated objects. I can create a Pimple object and that can look after all my object dependencies (instantiate them when required, or deliver shared versions when required. But that is where it falls apart for me. For testing, we want to avoid globals. Globals of any type, these days, are bad and should be avoided. Pimple gets around this by putting shared instantiated classes into its own list. This is not global in the application sense, but global in the context of the Pimple instantiation. So, who looks after that Pimple (or other DIC) instantiation in my package? I could make it global in my package, but then there would be only one. I could pass it out to the calling application, but then then that exposes the inner workings of my package that should be kept wrapped up behind the interface. I am probably worrying about details that really won't get in the way of practical use of my package (I could just say, yes, there is one instance of Pimple in my package and that is a global static, live with it) but this is as much about learning how to do things "right", because that is how we move forward. I suspect the answer is in your previous post, which I will go through again ;-)
When you roll pimple into the same class, do you mean you extend Pimple with your own classes?
Then qualify the statement by saying unstable APIs. You do know that using the term "stability" like that implies bugs and crashes. One could also leave the subjective editing out of the description and simply state the fact that Arch tries to run the latest releases of software packages. Lots of people consider that the main compelling feature of the distro. 
Our company recently started a project using it but quickly switched back to Laravel as the docs for Phalcon and the community support for it just isn't there. It was causing huge delays in the project and the app in question didn't need to be particularly fast. In fact all the heavy lifting was done by the neo4j DB, PHP just handled the display/query code.
&gt; I was telling you, as in 'You'. Same to you? What's the point of that statement? &gt; Barfing out echoes and var_dump's to the view is most retarded, and should not be a thing. &gt; im not angry in the slightest This is simply an assumption that you reinforce with...name calling. This is not compelling. The name calling in a technical solution thread indicates you are unable to think clearly or creatively enough to accept there are different environments without getting caught up in your own issues of acceptance or frustration. You should get help. Barring environmental issues (which do exist, despite your irrational insistence they "shouldn't be a thing", whatever that means), a basic example would be unit test suites. PHP Unit and others, output variables. Test Engineering is a thing. More to the point about the error_log, debug statements are simply unit tests while developing. There's no reason not to output them to a browser. What is and is not an error is actually still a rather contentious debate (usually argued in Java/C mailing lists). An error_log is for error reporting, ostensibly. A simple log is for regular expected events (analytics, etc). Your development output ends up in a console or other convenient spot like a debug.log if you're lucky. Unfortunately allowing a separate log like this eventually causes performance problems (lots of writes to different files) that do not help production in any way. Some people find this an acceptable tradeoff for additional documentation in the way of debug. Integration tests will catch (and prevent in the future) your output messages.
Which should be about the same time if not less to upgrade to 2.x -_-
I spent a couple of days trying to migrate my ZF1 codebase to phalcon. I was very enthusiastic at first, but I eventually leaned more towards ZF2. The reasons I decided not to continue: - One you mentioned yourself. Bugs and patches that don't do what they're suppose to do is going to be a major problem, even with a good test-setup. - If you're doing something wrong you're just totally left to your fate and the documentation, which I found was lacking in many departments. Don't get me wrong, they really did their best, but I just ran into alot of errors because I was simply doing it wrong, and doing it the right way wasnt covered in alot of situations, which resulted in just trial and error. Stacktraces are totally useless with it being a C-extension. I was able to dive into it, but if PHP extensions or C is a problem then good luck.. - I eventually got alot of stuff working, but the framework itself sadly doesn't provide enough productiveness. This is no problem ofcourse, there are plenty of glue-type frameworks out there, but this is kind of a BIG paradox in the methodology of uber performance. Bringing over the ZF1 codebase wasn't easy most of the time also, some viewhelpers for instance require a View instance for example. It just felt wrong most of the time getting stuff up and running. - The no-go was ironically the biggest argument that brought me to phalcon in the first place. All the AB tests and 10000 trillion concurrent user tests. This is simply irrelevant. I wish everybody would stop this also. If concurrency is a problem handled by your webserver or all the stuff below it, you're simply doing it wrong. This is a job of Varnish or Cloudflare f.e. You dont NEED your framework to handle 10000 concurrent users. 5 years ago, maybe. - Unlike the previous argument, service-oriented and event-driven design is really the thing that should catch your attention for the upcoming years. Not 1000 concurrent users hitting your backend. This eventually led me to ZF2. 
There was a pretty excessive flamewar about this topic on twitter that I can't find right now. PHP devs sure to love arguing semantics... But the biggest superficial difference between the two is Behat has a specific "Business Readable" DLS and Codeception has more of a PHP themed way of doing things. [Here's a quick overview](http://codeception.com/05-06-2013/specification-testing-coparison.html).
Ok, my initial comment is that while this is neat, it's nothing that anyone should **ever** use. So while it may be a nice demonstration, it's shouldn't **ever** be used for anything requiring even the tiniest bit of security. The reason is audit-ability. The password is generated on *your* server. How are we supposed to know if you are logging the password, or doing other things with it? Additionally, since the source isn't open, we can't verify if you're using sufficient random entropy for a password or not, or if the algorithm is biased. Furthermore, the "symbols" option seems to be using a very small subset of available symbols. Why? (From what I can gather: "&amp;$*%" are the only 4 being used). What about "~`!@#^()[]{}\|,.&lt;&gt;/?'";:" ? You're cutting the possible entropy significantly...
Sad to hear this -.-
&gt; So, who looks after that Pimple (or other DIC) instantiation in my package? The factory does; it creates one Pimple object for every Stack object you create. I've attached a rough example of what you probably want to do: &lt;?php require_once '/path/to/Pimple.php'; // This bit is your library code, you don't need to change any of it // Foo doesn't depend on anything class Foo { function bar() { print "Bar"; } function xyz() { print "Xyz"; } } // Bar depends on foo class Bar { private $foo; function __construct($foo) { $this-&gt;foo = $foo; } function foo() { print "Foo"; $this-&gt;foo-&gt;xyz(); } } // This is the new bit of code // The stack object is the top-level API that applications use to interact with your library class Stack { // Objects can be stored privately, publicly, or not directly at all, depending on what API you want to provide private $foo; public $bar; function __construct($pimple) { $this-&gt;foo = $pimple["foo"]; $this-&gt;bar = $pimple["bar"]; } // Utility functions can be defined on the stack object for common operations function somethingThatDoesSomethingCommon() { $this-&gt;foo-&gt;bar(); $this-&gt;bar-&gt;foo(); } } // And the stack factory is how applications create the stack object // It's split apart because in my eyes, plugging everything together and defining the API are separate concerns, and this makes it easier to maintain and extend your library class StackFactory { function makeStack() { $pimple = new Pimple(); $this-&gt;initPimpleForFoo($pimple); $this-&gt;initPimpleForBar($pimple); $this-&gt;initOther($pimple); return $this-&gt;makeStack($this-&gt;pimple); } // Subclasses can override this to return something other than the default Stack object if they want protected function makeStack($pimple) { return new Stack($pimple); } // Each dependency declaration is its own function, so that subclasses can override them individually protected function initPimpleForFoo($pimple) { $this-&gt;pimple["foo"] = $this-&gt;pimple-&gt;share(function($c) { return new Foo(); }) } protected function initPimpleForBar($pimple) { $this-&gt;pimple["bar"] = $this-&gt;pimple-&gt;share(function($c) { return new Bar($c["foo"]); }) } // initOther is just for subclasses to extend if they need additional dependencies protected function initOther($pimple) { } } // In application code $factory = new StackFactory(); $stack = $factory-&gt;makeStack(); $stack-&gt;bar-&gt;foo(); $stack-&gt;somethingThatDoesSomethingCommon();
I mention speed and performance as ones of the pros - meaning yes this is really pros and cons question regarding phalcon in production. For now the only **+** that I see in Phalcon is speed really, I didn't fall in situations where I lack of documentation, but it is another thing to be consider
You can't do pure MVC on the web for the reason you pointed in your response, you can't control what the user do once the view is rendered. Laravel and Symfony got it right by never claiming they are a MVC framework. I personally like the django approach to it, say that they are a MTV framework https://docs.djangoproject.com/en/dev/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names 
Excellent. I hope you open source your efforts on github so others may continue/contribute.
Author of kint here, thanks for the plug, here's the project page with the stable version: http://raveren.github.io/kint/ Here's the bleeding-edge branch: https://github.com/raveren/kint/tree/1.0.0-wip
With all due respect to xdebug, its variable output is lackluster. That's why I made [Kint](http://raveren.github.io/kint/). [Here's a temporary demo, it *should* go down soon.](http://www.opengluco.com/demo/kint/demo.php) 
Why don't you use Doctrine, it is very stable too. There are some use cases, and architecture details that I don't like in Eloquent. For example, you can't use "where" clauses "to filter from the relationships" (edited to calm down itrulia) :D. http://stackoverflow.com/questions/19635624/laravel-4-eloquent-way-to-attach-a-where-clause-to-a-relationship-when-buildin
or [NotORM](http://www.notorm.com/‎) which is 3x faster than Doctrine in my Applications. YMMV
Have you tried to create a Model Object with NotORM, to use it as Active Record? I tried for 1 week. NotORM is fast, and I like the syntax, but for many purpouses it is a real pain to use on advanced usage.
It's similar in that you can write your acceptance tests using a scenario-like DSL. See the code examples on their site to see what I mean. Honestly I haven't used behat other than reading about it.
ehm Im sorry but you can run where clauses on relationships, what you can not is filter by those where clauses in the relationship (would you just read the stackoverflow question...)
Oh I think its the other way around. 
Hi, if you decide to go with a VPS, I'd suggest checking out my company, [ServerPilot](https://serverpilot.io). We're a control panel service that automates server management for PHP developers hosting their apps on cloud servers, VPSes, and dedicated servers. If you decide to go with a PaaS, I'd suggest checking out AppFog in addition to Heroku. By the way, as your title says "VPS/Dedicated vs Amazon/Heroku," it's important to note that Amazon EC2 really fits into the VPS/dedicated category here rather than the Heroku category. Heroku is a PaaS which means you never really see the server. EC2 is Amazon's cloud server/VPS offering. EC2 instances are root servers that are virtual machines, the same as VPSes from a hosting company or "cloud servers" from Rackspace or DigitalOcean.
Just to clarify one small thing, Eloquent is *not* really based on Doctrine. The Laravel Schema builder uses some Doctrine DBAL components but that's about it. In the normal course of using Eloquent the only Doctrine component involved is from DBAL and it's the connection component, the actual grammars and everything else are strictly Eloquent. EDIT: FWIW I agree, performance aside (no idea what the comparative performance is) I'm not seeing much difference in the functions of this library vs. Eloquent.
My opinion: I would start with a VPS or small dedicated server. Going with most cloud providers just gets you a VPS as well, but with the redundancy, flexibility, better resources, more uptime, etc. You can get a cheap VPS for $5/month. Once you start growing beyond that, you can make a backup, transfer over the VPS to a cloud platform and be up and running fairly quickly on a cloud based infrastructure. Amazon does have a free tier and you could use that and it may be what you need, but be prepared to pay after a year of using it.
Check out [joyent](http://joyent.com) and [digital ocean](http://digitalocean.com). [Amazon's SLA](http://aws.amazon.com/ec2-sla/) is terrible. DO has five 9's and Joyent has a 100% uptime guarantee. If you're looking for something insanely affordable, DO all the way. 
&gt; Joyent has a 100% uptime guarantee No such thing. The guarantee probably means that they'll discount any downtime from your bill.
Rather than logging in using your local computer and copying the cookies over, You can log into the site from your script, and keep the cookies locally for future requests. That way you could automatically re-login so you wouldn't have to touch it.
Maybe if you used "alternative" instead of "successor" people wouldn't fuss so much :)
Hello, I'm very interested in your services. Excuse me if its obvious and I didn't see it because I might be sleep deprived, but I don't seem to find the specs of the server my scripts will be running it. CPU? Cores? RAM? What are the limits. I really like what I see there, but I would have to know those specs. I currently am on a VPS but would be willing to experiment. Thanks!
I thought this said Grandma ORM. I was like... wut
https://aws.amazon.com/free 1 year of free resources.
Hi, we don't provide any servers ourselves. We're not a host or a data center. Basically, if you reimagined hosting control panels as a beautiful, secure SaaS service for developers who have their own cloud servers and VPSes, that's what ServerPilot is. The one requirement we have is that the servers you connect to ServerPilot be fresh 64-bit Ubuntu 12.04 servers. You shouldn't have other control panels or web servers installed on your servers already. Note that even though we only support Ubuntu 12.04, ServerPilot installs the latest versions of nginx, apache, and php on your servers. An important difference from existing control panels is that the only control panel you log in to is the one at [https://manage.serverpilot.io](https://manage.serverpilot.io/#signup). There's no public-facing interface exposed from each of your servers. Not exposing an interface from each server is great for your server's security and also avoids wasting resources on your server.
Hey thanks. I started using Kint a little while ago. I love it.
Might be worth looking at [Pagoda Box]( https://pagodabox.com), which is similar to Heroku, but more PHP-oriented.
So what VPS service provider do you recommend? 
Same. Frameworks really need a LTS on them
The best provider depends a lot on your requirements as well as personal preferences. Most of our users are on either EC2, Rackspace, or DigitalOcean. These are all great choices. EC2 is the most expensive and the most complicated to use of these three. For some users, they need that complex additional functionality that AWS offers. Rackspace is a great balance of functionality, reliable/trusted/established brand, and price. Rackspace is very popular among dev agencies. DigitalOcean is the cheapest, a very new company, and has the simplest architecture/functionality of the three. DigitalOcean has quickly become very popular among independent developers because of the low price and simplicity.
PDO + prepared statements is a perfectly acceptable solution for most small applications.
I use Rackspace. I'm not sure what your service provides over that which Rackspace's service already has.
Digital Ocean give great bang-for-the-buck and they a decent interface for controlling servers. Another alternative is to give Google App Engine and Google Cloud Platform a test drive. PHP on GAE has seamless horizontal scaling and, like Amazon, Google offeres free tiers for their PaaS services. I'd highly recommend using PHPStorm for developing PHP on GAE. I have a few small apps I want to build and the only thing that stops me from putting them on GAE is that GAE doesn't support the [Phalcon PHP framework](http://phalconphp.com/en/) in which I want to write the apps, but Laravel should work fine. Also, Cloudflare's free DNS panel is better than any other service I've ever tried, free or paid for. It would be a good companion to GAE as you can use their "page rules" to get around the "naked domain" problem on GAE. You can also use Windows live domains for free mail @yourdomain.com (outlook.com is actually very good!) now that Google no longer offers a free version of Google Apps for business.
The main difference is that Rackspace provides servers and ServerPilot manages servers for running PHP apps. With Rackspace, you get a server in a reliable datacenter and what you do with that server is up to you. When you then connect that server to ServerPilot, you have an easy way to configure PHP apps on that server, configure databases, deploy SSL, configure a firewall, monitor your server, monitor your apps for errors, have security updates applied to your server, and generally avoid the need for manual server management.
I'd go with a framework like Slim, which is small and easy to pick, and maybe with idorm/Paris for db management. While it should lift up some weight, even the best framework won't take care of all security measures. Edit: given the short time frame, working on this alone is going to be really, really difficult 
Would you bet the fate of your company on an intern's understanding of security? Of course not. So why would you do so with your own understanding of it which you admit it limited? If hiring someone who knows what they're doing is not an option, an online financial transaction system is not an option.
Indeed, but it's a join on the SQL each time it's used. 100 different SQL queries? 100 places to update! Miss one? Good luck! Doing it in the ORM means doing it once. Updates are much easier. Much less error prone. 
I'd suggest the [Community Edition of Magento Ecommerce](http://www.magentocommerce.com/download). You will be able to hit the ground running by using the Admin interface and available plug-ins for those 2-3 weeks you have available. You can add products, customize categories, and have a working store within that timeframe. Then you can slowly learn how to customize the code itself starting with the frontend and eventually learning the Zend Framework underneath. You can try out their [online store demo](http://demo.magentocommerce.com/) or the [Admin demo](http://demo-admin.magentocommerce.com/index.php/admin/).
I'm running a PHP/MySQL site off of a pair of micros behind an ELB with AutoScaling enabled and I'm getting better performance than my VPS and better uptime. OP specifically meantioned being ready for growth later which is what AWS is best at. I don't think any other provider has better scaling solutions.
Yes
Why no namespace?
Seriously, 2-3 weeks. There's absolutely zero chance you're going to make it. *Period*! A trained person could probably get a working prototype up in that time - if it fits reasonably with an exsisting framework/product that person is familiar with.
So basically what all of these other people have said... The only constant in software development is that things always take longer than you think they will, and working against a deadline created by people who have never developed software before is just about the worst place to be. That said, I second the Slim suggestion. If you can get a month or two for the project, using a very small framework may help you keep things organized, since experience won't be your guide here. Do not, repeat, do not fall down the rabbit hole of Symfony, CakePHP, CodeIgniter, Zend Framework, or any of these other larger ones. You'll spend a week or two just figuring out how the framework works before you get to writing your app.
DigitalOcean all the way... 
I just extend my own class with pimple and have public methods that fetch depdencies, or if its really simple library, I place the few methods like createX(), FetchY() on it and call it a day.
Ignore what you have been told to do. Go to shopify.com and sign up for an account there. Use that. It's ludicrous to be solving a business problem in this manner. If your bosses won't listen find another job where there are more than 3 brain cells in the company. It is like telling a med student to perform a bypass surgery. It's theoretically possible he could do it, but he won't and will kill the patient.
what shoudl he be using for medium/large applications?
An ORM like Doctrine, Eloquent, etc. makes interacting with complex models considerably easier in the opinion of many.
This is where it is really important to make sure the framework is an implementation detail rather than your project itself. By this I mean keep your business logic in a library of code that is loosely coupled with the framework. Interfaces are your friend. Edit: grammar
Absolutely. Unless you have a real need to use an ORM, PDO with prepared statements is absolutely fine. We use it exclusively in a very large application.
I agree, mostly. I think a balance is fine.
Of course.
Digital Ocean is what I use. Cheap, simple, and the smallest tier starts at $5.
Yeah, I'm using Digital Ocean and I couldn't be happier with them. :)
Not properly separating your repeated code is your problem, not PDO's. My rule of thumb is the first time I just write the code, the second time I wince, but write the code, and the third time I refactor. I've never had a problem with missing references this way.
Yikes. Site does not work well on a mobile device. :)
No idea. They might *not* be.
Mind explaining what you mean?
What I meant was you need to make sure that you sanitize the data coming in. For example, make sure that the data is actually an integer when you are expecting an integer for that variable.
That's validation, not sanitizing. 
PDO is definitely okay to use. ORM is optional and up to you. I try to separate the database code from the app code for clean design.
I started out with GoDaddy Shared Hosting Plan for the first year and then switched to Digital Ocean $5 tier. I believe in moving up the chain slowly as demand grows, gives me longer runway financially. I am more likely to keep the app alive longer when user growth is less than expected if financial outlay is minimized. There is no reason to over-optimize until you need to optimize.
I'm not sure what happened to the original developer. It appears to have been abandoned so we picked it up and started fixing some of the rough edges on GitHub. We'd love some new skins if you want to work on some. Let me know if there is anything else we can to do improve Krumo.
The only one I know anything about regarding this is amazon's RDS. It handles config for you, there are some limitations people don't like, but they are being fixed as time goes on. That said, you would need to be pretty big to care.
Whats the community opinion of Propel? Is it an acceptable replacement of Doctrine and Eloquent? It's the one I like the most. Well, the one I like the most is RedBean, but I wouldn't use it in a medium/large app
Use PDO. But do not call any PDO functions directly from your database models. Extend it with some class, because in the future you may want to profile your queries or dump them to a session array, or stamp them with application name/filename/line,userid,php session id. If you have a central class that all queries go through you will be able to add this functionality whenever you need it. If you use PDO directly you will not be able to do it. As to ORM I would avoid them. If you have to use one make sure it allows you to run any custom query(has a bypass mechanism).
Going to play negative betsy here, who did your security audit besides the founder? Control panels such as this are giant security risk and even major players get hacked on a monthly basis.
fine ..sanitizing is making sure that unwanted characters arn't present in strings or other data. Preventing SQL injection attacks. eh eh, pretty good right?
Could you elaborate briefly on **do not call any PDO functions directly from your database models** Do you mean put the PDO functions in controllers? What if you arn't using an mvc structure?
Here's what you do to save your hide: Print the [PCI security standards documents](https://www.pcisecuritystandards.org/security_standards/documents.php?agreements=pcidss&amp;association=pcidss), drop those few hundred pages on your boss's desk and explain very slowly that if you don't follow that to the letter the business will be blacklisted by every payment processor in the world and that they will be forced to go cash and carry for ever and ever amen. Best of luck dude.
I see
This is your best option to buy some time and keep your job. I just went through our quarterly audit, its rigourous.
Thanks! There aren't any other companies doing exactly what we're doing. As for the interface, we built it ourselves using backbone.js and coffeescript.
He means wrap the PDO functions in another class so if you want to do other stuff whenever you write to the database, it can easily be added. Example (pseudo-code): class MyDBWrapper { public function write($data) { //Standard pdo call: $pdo-&gt;query($data); //Could do other stuff like this in the future: $memcache-&gt;write($data); $stats-&gt;track(__FUNCTION__ . " : " . $data); $log4php-&gt;info(__FUNCTION__ . ":" . $data); } } If you just called $pdo-&gt;query() directly from the model, you'd have to go search for that if you ever want to change your database implementation or add something. 
dot operator .. however I still am mad that they didn't use an actual dot like every other OO language
Linode is solid, but if budget is a concern I'd suggest digital ocean. I switched over from linode because my needs are modest and it dropped my monthly bill from $20 to $5. Performance and support have been great, and quite frankly the 4 instances on digital ocean you could get for your $20 base at linode are going to over you a lot more bang for your buck. That said, other than digital ocean being a more frugal option, I have nothing bad to say about linode.
I don't presume to speak for others, but I like it well enough. It's the one that feels most natural for me and I especially like the behaviors it offers. It's also somewhat faster than Doctrine and has a gentler learning curve; however for larger applications I'd go with the latter. 
So much doom in this thread. I don't get php people sometimes. I do this sort of thing regularly, and it takes me a month or so. pci compliance only applies if you are handling credit card data, which there is no reason to do, there are many payment processors such as worldpay, sagepay even paypal to handle that side of things. Provided your first concern is security of your php you should be ok. (If I mention words like sanitization and injection you should know what I'm talking about). Having said all this, you will find its far more complicated than you initially imagine, and it will take you much longer than you expect (months not weeks). Another option for you might be to get a pre-built backend like zen-cart or magento and build your front end around this. 
At my last job, they doesn't want to use an ORM like because, the junior Project manager told me it will slow them down ! There is another reason, like the whole app is already build and they don't want to rewrite everything which I understand but I would like some insight from you guys about the ORM thingy. They use java JSP as main programming language and Microsoft SQL server. 
I completely agree with this. My team usually works with WordPress, and most of them don't care about notices. It's really a pain when they install plugins that don't adhere to standards/interfaces/stuff (I'm looking at you, nextgen gallery) (even though WordPress by itself doesn't adhere to standards). Seriously, the amount of notices that is generated makes debugging impossible 
Thank you for your honest words. You are probably right, i am in over my head. I will talk to my boss and will tell him what you just told me :) In your opinion, how long would it take me (with my background) to get this thing done? Remember we are not speaking about a full-blown online shop here. It is more a single form with a few products to choose. 
If I use your service, can I still perform other operations on my server without it messing up what you provide? E.G. Install my own SSL certificate.
PDO is fine for any sized application, the thing to keep in mind is to just use models (or something else) that seperates the queries from the rest of the logic, that way you can let every class do what it's supposed to do without worrying about the things it isn't supposed to do. 
Why not hire a freelancer yourself? The boss doesn't need to know really. I know this sounds dangerous, but if you absolutelly MUST finish this thing in 2-3 weeks it's probably the best you can do.
lol, no.
I've never quite understood why we try and hide SQL so much. It's not like it's a complex language and you can do so many powerful things through it. I've gotta think it's mainly related to portability, but are there really that many apps that need to run on multiple DB backends? That's just never been a requirement for anything I've ever worked on but maybe it is for other projects.
You can also use Doctrine's DBAL instead of the full ORM. I did for some Silex projects and it works great. However I find that in the end I often had to write code that the ORM would have handle for me (CRUD things).
Looks interesting. What are your rules? Maybe include it in README.MD
You should try stackoverflow or the support mailing list
&gt; What would you recommend me in my position? http://i.imgur.com/GVFDERN.gif
Another static offering to the anti-pattern of active record .. Wonderful.
this won't backfire at all
+1 for eloquent
haha that actually made me laugh out loud ! 
haha nice idea! ;)
yeah! maybe is not for purist programmers who lives in heaven. It's usefull, it's small, it's fast and easy to use, it saves time for some kind of use cases... but oh! take a look! it does not follow the always changing "pattern panorama", oh! and it does not follow certain sacred standards!!!!!
I kinda like the idea, mainly for the fact that there is a lot of potential flexibility for the rules you check against. God knows how irritating it can be to remember all the nonsense that goes into a PHP ini.
The readme has been updated with this information.
I have some experience building an ordering system (which took me well over 2 months), and I will tell you this: 1. Which framework to use should be your last worry :), most frameworks simply help you organize your code a certain way (MVC) and take care of miscellaneous tasks (Validation, CRUD operations, XSS cleanup, etc). You still have to write all the functional code. 2. Have your financial processes mapped out on a piece of paper. Have it signed by your bosses. Trust me on this one. 3. Make sure that you understand the requirements, look critically at the paper from #2, make sure there are no loopholes to exploit. 4. Now select a framework that has the functionality to meet your needs or has plugins / extensions to meet your needs. Authentication / Authorization are most important for a project like yours and most frameworks botch that up or make it impossible to work with. 5. Now look at the learning curve of the framework. Think you can swallow and digest it in 2 days? Ultimately, if I was in your position, I would talk to my bosses, show them a nice PowerPoint presentation about why its a bad idea to rush this as it affects customers and the company's reputation. Speak their language, keep it non-technical.
You are mistaken. If you are using prepared statements correctly, it doesn't matter.
I feel your pain. What the boss usually do is to diminish the size of the job so you believe it can be done in two weeks. That's when they start to make changes and you'll begin to wish you've never accepted the job. 
This would be my exact approach, we all started some where, and sometimes there's no better way then to dive into the deep end. In my opinion, a micro-framwork is the proper approach, instead of worrying about a back end a database, make the form send you an e-mail with what the customer has described / requested. Create a view with what you offer, and then a form filling out any more information, then reply to them personally. It's a good excise to learn how to control a web request, and will help you learn more about how requests are commonly routed through code. Of course if you can't set up e-mail accounts or install the required software, a NoSQL or SQLite solution is a quick and easy fix.
The reason we abstract the SQL away is so the rest of the application becomes less dependent of the actual implementation. In other words, if the SQL, the database tables, etc. needs to change for whatever reason, it should not affect the correctness of the rest of the application.
I just made two pull requests. They work together quite well, but individually as well, should you choose to merge in one, but not the other. https://github.com/oodle/krumo/pulls 
That could be interesting, but I could see many folks being hesitant to upload their server configuration to a 3rd party service. While most of the settings in the typical php.ini might be benign, there are some that could potentially expose sensitive info about the service. Even with a disclaimer that the data wouldn't be kept in any way, it might still make folks nervous.
 Does your command-line version parse any includes as well? That would be the potential issue with an online version since most people probably wouldn't think to upload all the includes (and it could be a hassle as well). I think this initiative overall is a great idea, since lots of people don't know where to start in making their php.ini secure, especially if they use any kind of package manager that adds to it beyond the defaults. The current defaults are mostly secure nowadays, but it's easy to change things without really understanding the repercussions, so your tool could also improve the "security by education" by not only pointing out bad practices, but also explaining the consequences of "make sure you understand what this means" settings, such as turning off E_NOTICE or E_STRICT reporting (which a lot of people do in development and then copy/paste into production), or not having error logging turned on. Even if the tool is command-line only, as a potential future feature (sorry to suggest more work to you!), perhaps a web-based interface to review the rules and policies that you are using, and some kind of crowd-sourced voting system to help shape best practices (which would increase trust in the product I think). Eventually you could also add user-submission so people could upload rulesets for modules (XDebug comes to mind as an optional module that has a lot of configuration rules that can be confusing at first), which could optionally be pulled in if the user has a certain module installed. Nice job! 
Good suggestions! Would you mind entering them into the [Issues list](https://github.com/psecio/iniscan/issues) for future consideration? Thanks!
Very useful! I like it. Suggestion: Add a composer.json and publish on Packagist so I can more easily integrate this into whatever I'm working on.
That's the plan! I just wanted to get some initial feedback
I also need to run over the formatting to make PSR-2 compliant
This is an interesting project, but I'm very stupid. Could you explain what problem this is solving, perhaps with an example? What would I currently use to solve this problem, and why is this better? Many thanks!
Inherit**a**ce one isnt that great (typehinting)
I would imagine something like this (in an entity repository) $this-&gt;createQueryBuilder( 'e' ) -&gt;orderBy('e.updatedDate', 'ASC') -&gt;getQuery(); Would produce the desired query. Really, it should just be an `ORDER BY` statement using the field in whichever way you choose to query your entities.
For the record, it wasn't me who downvoted your reply. I wasn't really trying to comment on your code, just pointing out that the feature set seemed equivalent or less than other existing Active Record ORMs. But if you want to go this way.... &gt; But when I tried to move to Eloquent I found that some of the code I wanted to refactor was not possible with Eloquent. So I make Granada. Your code is pretty good, easy to read, makes sense. But I'm going to level with you, I'd personally never use your ORM and here's why. - You haven't defined your own namespace, so I'm assuming you just believe that namespacing is a micro optimization or something, or just don't know any better and therefore ignore it. To each their own but I personally don't want to incorporate something into my project that just throws classes into the global namespace by default. To be fair, even Idiorm and Paris do that but that's no excuse. - You've just taken a copy of idiorm and included it right in your repo rather than requiring it via composer and extending it, overloading what you wanted to and leaving everything else alone. How am I supposed to update it? There are much better ways to do this. - You say your ORM is based on Paris, does that mean you did the same thing, just took Paris and modified it to your liking? If so, why? Just extend it. - You haven't provided me any compelling reason, feature, performance or otherwise to use this instead of another more prevalent Active Record implementation like Eloquent or Propel or what have you. Suggestions: - Namespacing - Extend or even fork idiorm and paris rather than including them directly in your repo - Investigate and provide a feature comparison vs. other Active Record ORMs - Value proposition Overall this ORM is billed as an extension of Paris, but it doesn't actually extend Paris (or the idiorm dependency). I'm just not sure why you created this aside from the old NIH syndrome, that's all. &gt; By the way. Granada does not require any library. Yes it does. Just because you copied idiorm into your repo doesn't mean there's no dependency. In fact you've totally rendered moot the core value prop of Composer, dependency management. If idiorm releases a bug fix or something, now I have to wait for you to patch it into your repo, rather than just letting composer update it and do whatever it needs to do. &gt; If you are using pimple or whatever dic, why would you want to download illuminate/container? "illuminate/container": "4.1.x", "illuminate/events": "4.1.x", "illuminate/support": "4.1.x", "nesbot/carbon": "1.*" This is the whole purpose of Composer. Why would I *not* want to include dependencies in my project? Performance? File size? Because my repo is getting "too big"? I don't commit vendors. This is a totally moot point. Give me a valid reason to exclude dependencies from my project and I'll consider it but just saying "there's a lot of them" isn't a valid reason all on its own. Futhermore, to publish your package in packagist using composer, and then try to say that dependencies are bad is kind of hypocritical. I like the code you've written but to say that I should consider using it is asking me to overlook a lot of shortcomings.
I'm not entirely sure what a "web filter redirect page" is, but you really should filter anything that's coming into the page - especially if it's going to be used in any way in the script (including echoing it back out). Is the point of the page just to echo these values back out? Where does the request come from?
Also why you should use PHPStorm. Not that it's not possible in other editors but the debugging capabilities of PHP storm is awe inspiring. It can even parse and format cachegrind files.
We have a web filter appliance (in education, web filtering is mandatory). When a page is blocked, it shows a page that says the page is blocked, under what category, and a few other details. A very ugly, generic block page comes with the appliance. The appliance has an option to redirect to an external block page, via either GET or POST. I opted to use POST vars since they're obscured, although I certainly don't rely on that for security. So basically my little PHP script gets about 10 strings POSTed to it from the appliance, and I can do whatever I want with them. One string is the URL which was blocked; another string is the username; another string is the category; etc. Ultimately the vars are either a) not used; or b) echoed back to the user. I'm not executing SQL or a shell command or anything. A few vars are URLs, which I validated with filter_var() using FILTER_SANITIZE_URL. Another var is an int, which I validate as well with filter_var(). I agree I should filter as much as possible, but my knowledge of filtering really is limited to sanitizing for SQLI or XSS attacks, which don't necessarily apply here. But I don't know...which is why I asked.
The main difference is having a bit of manufactured type safety.
:) well, you took so much time to answer. You are right respect to what I did with Idiorm/Paris. Let me excuse it: Some of the reasons you give are right. But don't make so many assumptions about other motivations or believes because you loose a lot of authority. The reason here is that I wanted to maintain the original piece of code, because it is familiar for some ppl. I didn't want to extend Idiorm to override it, because I wanted to change some things at the core, and I don't want to maintain Idiorm as is (idiorm stopped adding functionalities so it will stay, mostly, the same). probably I will make more changes on Granada if some ppl is interested and that will be the first (general architecture). It's already a fork, but since I did so many changes and I wanted to pull some request to idiorm/paris I did one more for idiorm and paris. github does not reflect the nature of this because only shows the first fork. Namespacing: yep, it lacks namespacing and probably, since ORM an Model are really common class names, it needs one. I maintained the idiorm/paris way, because I just started to modify it. Step by Step. Feature comparison, etc... Granada is the code I use in production for some works. I did it for me, but I wanted to share it if someone is interested in giving it a try. I left Idiorm/Paris structure for the same reason. If someone comes from there, it will be easy to start using Granada. For this ppl is easy to see what they gain vs Paris. Billed as an extension you say? (" based on Idiorm/Paris.") does not mean extension, it means that it is based on it. (maybe, since I'm not english speaker I fail to see the difference) I forked Idiorm/Paris but as I already said, I changed Idiorm in the core, so it's not idiorm. Again, I left it for easy start for ppl who comes from it. "Why would I not want to include dependencies in my project?" Just to not have COUPLED code. I don't want 5 librarys using different Dependency Injection Containers, or event managers. I didn't say it's bad to have dependencies, I said it's bad to have multiple libraries making the same things in different manner, and if I can get rid of some of them... ( I don't want the laravel facades implementation, or collection, or whatever it is on the support package (a hodgepodge for utilities) &gt;" I'm just not sure why you created this aside from the old NIH syndrome, that's all." well, Paris don't want to add any more functionalities to the code. They didn't want to look at the eager loading, etc I was preparing. I respect that of course, it's a small library and well done. Does it stop me from taking it and modify for my interest and maybe others? No, BSD. As I see, you make a lot of assumptions I will not fight vs the "I'm assuming you just believe that namespacing is a micro optimization" or " to say that dependencies are bad" or "Investigate and provide a feature comparison" (as if I want to sell this small library) &gt; For the record, it wasn't me who downvoted your reply. I wasn't really trying to comment on your code, just pointing out that the feature set seemed equivalent or less than other existing Active Record ORMs. But if you want to go this way.... I must miss something, If you are referring to the comment I did on yours, I just said "yes, you are right" Granada does not add nothing new. maybe is because my bad english if I sound rude or something? If so, please let me know. 
&gt; There is an error log. Guess what it's for? Logging errors. Not debug information. The power of the CLI exists in it's ability to script complex tasks and it's simplicity, not in it's ability to format information for humans. A debugger is even better as it can step you though and profile the inner workings of your program but failing that a browser is far more capable of reducing the signal-to-noise ratio.
which you shouldnt archieve how you did it
If you are dealing with payment and storing user data, I'll say 6 months. But your code will suck. It will work and will seem that is good, but it is going to be shit. If possible talk to your bosses to use a solution like magento or prestashop so you don't have to worry much about security flaws.
Which you can't really effectively get in PHP because of the lack of parametric covariance for classes. You can get it with interfaces, but not classes at the moment.
Not a terrible idea, but when he takes the step into development he is going to have a bad bad bad time. Source: 1 year as full time Magento dev / first job.
what? you can... (works the same as with interfaces)
Or you can try https://github.com/Surt/Granada wich adds some things to Idiorm/Paris like eager loading, lazy loading, overload of collections, etc :)
The problem is still there, how you lock it down to only allow inheritances of a class is not how you should do it. You normally use typehinting as an example: public function example(Example $aExample) you can't even get the phpdoc comments right with your method.
You're correct, there isn't any IDE helper to remind you what you can use in your class. Again, this is so you don't have to write an adapter wrapper to use it. If you want IDE type hinting, you can still write an adapter.
No, that would be stupid because it can't do things like check the permissions of the paths. Take the world writable /tmp directory for example.
You are mardix from VoodOrm! I just saw it some days ago on the latest package releases. Great Work!
I see. I thought it was only looking at php.ini itself, not doing other checks throughout the system.
Since you aren't doing anything with the data, the only thing you would be worried about is xss, and you can take care of that by passing all outputs through [htmlspecialchars](http://php.net/manual/en/function.htmlspecialchars.php). Filter_var would be more useful to validate data submitted by a form, to make sure you have a valid email address for example.
If you offload the CC processing to a third-party (there are solutions where you direct them to the third-party site with the order total, and the third party handles all of the CC/checkout, and will do a post back to a pre-defined page on your site that then you can mark the order as paid for. That removes a lot of the security and complexity. Are you going to have a static list of products or a dynamic product list / management tool that you need to write, same thing with categories. You should sit down and think through every minor aspect of the site, every little detail matters (if you have categories, can a product be in more than 1 category, if so then you need to do your database design in a way that supports that, etc) Hope that helps. And I would recommend a framework, it may feel like a waste of time for a few weeks, but after you get it you will be thankful you did.
Ha! Thank you very much. Someone notices me around here.... lol
Thanks. Actually ran into this issue on my own since I posted this (trying to catch a fatal error) and remembered this thread, Google a work around for catching fatal errors and found a hack that sufficed (at least made debugging it easier) 
I think it gets messy when you try to sort different entities by a similar field name. The quickest solution that comes to mind would be to keep a separate entity/table for the updatedDate fields with the other entities attached and reference that instead, but that's not really a majestic solution. It would probably operate more efficiently for this query, but not for others. To do this without changing the entities you would probably need to use complicated subqueries to get the values from the multiple columns sortable as one column. This is assuming the fields are not related to one another in the database, which would make it slightly easier. That is to say, it's probably easiest to run native MySQL queries for this particular operation, or less optimally pull by DQL/QB and then sort by PHP.
thanks for that, going native was a last resort but I agree that is the easiest option. If anyone's interested I can post the native solution.
Any chance that this could be more then a security scanner? Best practises could also be nice. Some rules depend on the webserver php is running with, is there an option to specify webserver? Or auto-detect? For security reasons it would be nice to disable a list of functions by default. Though that really needs some additional software to check your php project to see if it's using any of those functions...
Change the namespace to your vendor name something like danielgsims\phpcollection instead of Collection\Collection
Good suggestions - mind adding them to the [Issues list](https://github.com/psecio/iniscan/issues) so they don't get lost in the shuffle?
Will do. I'll do that when I get it into packagist
A bit late I guess, but this bug is fixed now, see https://github.com/php/php-src/commit/4218e89f8df4ca3897e3aad595e0c2c9cf4c3aca.
Hi Gabeon, Now i'm not an expert on web security, so don't quote me... however, PHP is a server side language, so for an intruder to access the information you're not returning (for instance db login details, email details) your server security would have already been compromised, leading to far greater problems then an email being hacked... Now, a really useful tool for PHP mail is: https://github.com/PHPMailer/PHPMailer It has been designed for SMTP email, and only requires a minimal amount of knowledge/programming to get it working. If you have any problems getting it to work let me know.
So, let me get this straight... My web files are uploaded and hosted on Dreamhost, so in order for someone to get the username/pw from that PHP file, they would have to hack the Dreamhost servers? That makes me feel better. I tried using the PHPMailer a little, but my limited knowledge of PHP scared me off a little. Do you think I should go with PHPMailer or just put my ftp username/pw in the PHP file for the mail() command? If using PHPMailer is better, I would probably need a little help and I appreciate the offer. Thanks.
Great! Thanks for all of your work on PHP.
Ok. I understand about the blacklist. I'm about to leave for the day, but I'd send you a message in the morning to see if you have time to help me with the PHPMailer setup. Thanks again.
Also big gains over 5.5 with opcache. Sorry about the title.
We cared about PHP 5.3, 'cause our customer is using SESL and they still provide 5.3 only :( And of course we also compared it to 5.5 with opcache, which is indeed a big performance gain against 5.3/APC alone (but not as much as HHVM)
merge the arrays of results and use `usort()` to sort them
+1 for a web service. I don't have Symphony and don't plan on installing it.
A custom module is the long term solution, but if you need a quick fix, you can create a custom page template. Copy your page.tpl.php in your theme's directory. Rename it to page--node--&lt;nodeid&gt;.tpl.php Replace &lt;nodeid&gt; with the node id of the page. If you go to the edit page, you will see the numeric value in the url.
The people stuck on 5.3 do. The current version (at time of writing) of HHVM has a 5.3-ish feature set as well, which makes it a good thing to compare against in this specific circumstance.
but once you start writing custom things the point of doctrine being abstract is no longer true, so why keep it?
Personally if someone had a copy of my php.ini, it would tell them nothing about the services or where it was used. I think there are a lot of people with configuration like this. Just throwing in my 2 cents for a web based uploader. 
 # service php-fpm status php-fpm (pid 2333) is running... # service php-fastcgi status php-cgi (pid 1012 1011 1010 1009 1004 1003 1002 1001 1000 994 992 991 990 989 984 983 982 981 978 966) is running... That's what I'm getting when I run those commands.
np, let me know if it makes sense. I kind of wish I left out the word 'private' when I wrote that lol. I didn't mean to imply that it should always be stored as a private, but at least we got some interesting discussion out of it anyways. FWIW, I completely agree with what Nicoon has to say on that subject.
Thank you for this. I always saw the cookiejar as one of the cURL parameters, but never looked into it. From the example on [this page](http://curl.haxx.se/libcurl/php/examples/cookiejar.html), I was able to create a two-step cURL call and receive the PD-S-SESSION-ID and (most importantly) the JSESSIONID on the second page. Thank you all, again.
Why are you running both php-fpm and php-fastcgi? Choose one or the other. I would recommend php-fpm. 
I'm not. I should have clarified. I put both outputs to show the differences when I have one or the other active. EDIT: Wait a minute. I think php-fpm is starting php-fastcgi. Is this possible? Actually, it does make sense
I'm glad you said this. I just googled a doctrine 2 presentation, went through it, and was of the same impression. Great for simple stuff (well, a lot of code bloat in my mind but I guess I can see the benefit), but I can't see it working with a fraction of the SQL I write.
thanks, makes sense now.
arg! what did you say deleted?
&gt; The people stuck on 5.3 do. I'd argue that a venn of "people stuck on 5.3" doesn't intersect with the "people who can utilize/deploy HHVM" nearly as well as the "people considering php5.5+opcache" bubble.
I created / maintain Laravel. I would be really interested to know where you think the docs can be improved. Having excellent documentation is a huge priority for me. Thanks!
. . .of course it was. . . It's hard to find a bigger boat anchor on the progress of the PHP ecosystem than the fucking devs.
Wouldn't the memory usage be much lower with Phalcon considering the framework just sits in memory once (as a PHP module) rather than a PHP framework being loaded into memory for every request thread? I've never used it, but have been considering it based on this assumption. I'm about to undertake either learning either Phalcon or Laravel. A couple of sites I'm building need to be able to handle a heavy load. Do you think I would just be better off using Laravel with APC? Are you switching to another framework, or just using your own code?
&gt; I don't get php people sometimes Basically everything in the last half of your block of text explains why people are poopooing his idea.
From memory even if compiled in (default is "nobody") - you can still override it in conf.
&gt;Could a rating for say an article be generated indirectly, discretly without the user even noticing. By say monitioring [...] No. That's not how the web works. (I'm assuming you're talking about a social link sharing site, like reddit) &gt;If a article is generating traffic it's either because the content is in someone way positive. Not necessarily. Links which are higher rated will show up higher in the listing (i.e. show up on the front page) and thus receive more traffic. If you're going to base the rating system on the number of clicks an article gets, then the same articles will always receive the highest rating.
I know my ideas aren't perfect, these are just thoughts that would need serious refinement. Howver I will argue here that the down vote button could be combined with the report. If you don't like content then don't vote for it, simple.
How come? Smarty is still being updated, the last release is less than a month old. It's a great tool to make templates more readable and concise, what's not to like?
You could try to use a micro-framework such as Silex, Slim etc. Those won't include so much functionality "out of the box" so you're free to do whatever you like. Learning curve is decent from my experience.
OK, some of this feedback will be my opinion. Some of it will be straight and unassailable fact. Frankly I don't know why people make a distinction between those two things, I think they're the same thing, but whatever, here we go. 1. Use Composer. You have dependancies in your code, the markdown utility, etc. These should be managed with composer, not just dumped in the repo. What happens when they get updated, etc. Composer will also handle all of your includes, which should be done by autoloading, not by require_once, which (for the record) is not a function and shouldn't have brackets. Pet peeve. 2. Learn the Single Responsibility Principle. Every file, every class, every object, should do **one thing**. Not a whole bunch. 3. I don't know how to say this... this is still spaghetti code. Putting things in directories and including them doesn't make them not spaghetti. You have no classes of any kind, no objects, no templates. No separation of concerns. There are SQL queries in almost every file, and some of them have a mix of SQL and HTML. The only functions used are global functions. This codebase is a nightmare. 4. Templating. Don't use header.php and footer.php, these are sure signs you're doing it wrong. When you use an actual proper templating engine, you create a vastly more efficient, effective, maintainable system. Blade, twig, handlebars, moustache, smarty, and simple php based template engines... you need to use them. 5. Standards. $CONFIG = sb_load_config("config.ini"); $DBH = new SQLite3("sporkblog.db"); $LOGGED_IN = sb_loginstatus($DBH, "sporkblog"); $PARSER = new MarkdownExtra_Parser; Absolutely not. Please use at least PSR-1, and ideally 2. It will make your code more readable and portable. This is especially the case if you ever work with other people. 6. Use a framework. Everything you've done wrong in this could have been fixed by using a framework and writing in the same style it does. Something like Laravel you would have a codebase a quarter (or less) of the size, fully OOP, using the MVC pattern, on its way to testable. If you want to do something to learn, you would learn more from implementing a good OOP app than from writing terrible code.
The point of the MVC pattern is to allow you to have *separation of concerns*. This is design principle that says each thing should only have to worry about doing one thing and doing it well. Your M is the model, which contains the basic "objects" of the site. A comment. A post. A user. A product. That sort of thing. The model handles all of the code for how to get its data. All the database stuff, queries, etc, is handled in the model. Each model should be a class of its own, and must do nothing but get data from the DB (or wherever). V is the view. This is the layout, the HTML or however it's presented. Any sorting or formatting of the data is done here and only here. This is the only layer that would have HTML in it. Ever. C would be the controller. This is what handles requests, and returns a response. The controller is the interaction between the model, and the view, so it will request data from the model, stick it in the view, and then return that rendered view back to the user. // Model - Handles database stuff // models/post.php class Post { public function get($id){ $query = 'SELECT * FROM posts WHERE id='.$id; //skipping irrelevant stuff here return $post_data; } } // View - Layout and formatting // templates/post.php &lt;div class="post"&gt; &lt;h2&gt;&lt;?php echo $data['title']?&gt;&lt;/h2&gt; &lt;?php echo $data['content']?&gt; &lt;/div&gt; // Controller - handle what is needed, and // return something to the user // routes.php or index.php $postObject = new Post; $post = $postObject-&gt;get($_GET['post_id']); $template = new SomeTemplateEngine('post'); $template-&gt;set('data', $post); echo $template-&gt;render(); Note that the above is complete shit. I was trying to make it clear, not good, and not secure. The point of all of this is that you know where everything lives. Having a problem with the layout? It's going to be in the view. You don't have to be cluttered by SQL. View coming up blank? Check the controller, see if it's making a valid request. It's much easier, much more maintainable.
Because without it being OOP it's a shit sandwich. It doesn't matter whether you cut the crusts off or not.
To add to this comment, this is a tricky problem to solve... even Facebook is struggling with it and invested some serious money into researching it...
I am also struggling to get the right combination going and the other day I was thinking about what traffic actually means and how something like a controversial article might attract more visitors than a popular article. A controversial article most probably has as many upvotes as it has downvotes above a certain total which would give a controversy rating for example. So its not an easy problem to fix at all but some sites like reddit actually does it nicely IMHO.
Thanks for taking my criticism in a positive way. I'll respond in the same spirit. 1. Yeah, it does. If you have to make modifications... don't. Use a dependency that does what you want. If you look on packagist.org you'll find seven PAGES of markdown utilities. One of them will do what you want, or you can change your requirements so it does. If you go by what's most popular it's probably the best one anyway. KSES I don't really know, but I'm sure you could find a composer package to do its thing anyway. If it's suffering from bitrot, don't fix it, just don't use it! 2. SRP doesn't mean that you can't do more than one thing. It means you can't do more than one thing per object. By all means call things to do the jobs that need to be done. Run the config object. Load the routing object. 3. Pretty much, yeah. Your choices are OOP or spaghetti code. It's something you **desperately** need to learn. It will make you a better programmer and make you write much more manageable code. It will make things easier on you. It's not that hard, let me give you a bit of a tutorial. Classes make objects. Each object is like a robot. It knows its own job and nothing else. It doesn't need to know anything else. Think of it like the robots in a car factory. They're programmed to weld this joint, turn it over, weld that joint, then pass it along. They don't need to know how to put on the doors. Well, one of them does, but you get the point. Each one only needs to know how to handle its own responsibilities. Your objects in this case would be things like Post and Comment. What you want to do is take all the code related to a post, and bung it in a class called Post. Then take all the code related to data for a comment, and put it in another class called Comment. You break that up into lots of different functions, so that your comment class consists of things like public function getCommentsForPost($postId){ // sql goes here. return $data; } In the posts class you'd have things like public function getPosts(){ // database stuff } public function getPostsForTag($tag){ } You wrap all of these requirements in a class, ideally with a logical constructor, and then when you want to get the data you just call the class instead of running the SQL. $post = new Post($post_id); or $list = Post::getPostsForTag($requested_tag); This vastly reduces the SQL clutter. 4. yes, it's smart to separate the parts of the view, the nav, the footer, etc. There's nothing wrong with doing so. I'm criticising the way you're doing it. You could still achieve the same using a template engine while doing a much better job of handling the scope and separating concerns. 5. I don't necessarily like the styles either. But the fact is if you want to work with other people (and professionals do) you have to drop your own expectations and work to a common style. The "prone to typos" argument, btw, is bullshit. 6. you've made it clear that you don't know OOP at all. Using something like Laravel would teach you a whole lot about some of the best OOP practises currently being used in the PHP world. Laravel's standards are excellent. Frankly what you've learned by doing what you're doing here is... things you desperately need to *un*learn. Using a framework isn't the only approach. But frameworks give rapid development and a consistent architecture, providing testability and embedded security. The ability to work better and faster is one that PHP developers foolishly reject. As for "classes and objects". you're wrong. You're just wrong in this one. You need to learn OOP. If you choose in some instances not to use OOP because other techniques are better, that's totally fine. But you should make an informed choice, not one that merely maintains your own ignorance. Grabbing libraries and gluing them together isn't what makes the application. Grabbing libraries and gluing them together gives you a strong base on which to **build** your application. Using twitter bootstrap to get a leg-up on your layout is smart. Using jquery to do your javascript is smart. These tools make your application better, faster. Building within a framework is building smart, providing a better result for your client or employer. I don't think **you** need to use a Framework. I think you need to learn OOP. But I honestly think that not using a framework for professional development constitutes negligence.
The Linux kernel is not written in PHP, and is not relevant. Specifically, the C used in the Linux kernel uses things not available to PHP in order to mimic some OOP patterns and techniques. Pointers, structs, etc. Basically OOP lets you write code that is more reusable, more portable, and more maintainable. It lets you write code that is unit-testable. OOP lets you bundle the functionality for any given domain into one place and work on it discretely, improving the overall architecture. It is more readable, as it separates large chunks of functionality out leaving a behavioural core such as a controller that makes much more sense. Basically, I'll be blunt. It's 2013. Your code is shit. OOP would make your code objectively better. The choice to listen is yours. I'm not going to fight with you about whether you should be shit or not.
I had an experience attempting to use Doctrine in a reasonably complicated project and found it to be clumsy to figure out how to do things like model association attributes and things like that. Basically if you want to do arbitrary joins and pull in columns from each, which I had to do to keep my data sane, it's hard to describe to an ORM. I am also allergic to the idea of having another model that describes the relationship between two other models. This strikes me as superfluous and bloated. Nowadays I like to work from a very lightweight MVC framework base, like Slim or something I create myself, and let the models load data they need from anywhere using straight queries. I do like to separate the queries out into another class for decoupling, but I will write the queries manually. 
To find out if someone has shared the link in an email, you could add an id to the end of the link, and track the number of IPs which hit your web server with that ID. If you generate a new ID every page refresh, you'll know if they forward the email, or copy/paste the link again (two id's generated from the same IP). Also it would tell you if people come back to the site time and again. (very naive, basically trying to develop cookies using server-side db's) Just of the top of my head. Not sure about the Facebook API, but the twitter API lets you scrape a lot of data. You can search for the link in tweets, and semantically mine the rest of the text. http://blog.cloudera.com/blog/2012/09/analyzing-twitter-data-with-hadoop/
It's actually just the Console component it needs, not the entire framework. The Console component doesn't have any other dependencies. The dispatcher is only a suggested install.
Shit.
At least we have Facebook.
My advice is: Try it. function returns_false() { return false; } function returns_blank() { return; } var_dump(returns_false()); var_dump(returns_blank());
I believe, and I am attempting to test, that if you just do function foo() { return; } $bar = foo(); $bar will be null
http://us2.php.net/manual/en/functions.returning-values.php and http://us2.php.net/manual/en/function.return.php : "If no parameter is supplied, then the parentheses must be omitted and NULL will be returned. Calling return with parentheses but with no arguments will result in a parse error."
DQL uses the abstraction you build with Doctrine to do queries. You use the property names from your classes to join/filter/order things, so it still follows your model more so than a relational table. If you drop down to direct access via PDO, yes, you need to be aware of your database. But, in my experience, I've only had to do that a few times in the scope of a large project that was generally accelerated by using an ORM. DQL tends to be fast enough to optimize even data heavy pages, so I've limited using queries to migration scripts.
Interesting side note to add onto the correct answers in this thread: If the function involved returns reference values (ie function &amp;get_value()) then you cannot simply return NULL. A simple work around to this, is to define a null value somewhere, and return that variable. More on this here: http://php.net/manual/en/language.references.return.php
Would love to see the reason on the side of every vote (without to entering the mailing list). What were the downsides?
You could look at how long users stay on a page. If they are staying on the page to read the entire article or copy things from the page (not sure if it is possible to count this) that means they are reading the entire thing and saving snippets to send to other people. This shows that the person found the article worthwhile to read: either they loved it or hated it. The good news is which one doesn't matter, all that matters is that they cared about reading it.
One of my biggest pet peeves as a user is when a computer tries to guess what I want, instead of just asking me and taking the answer at face value. If I'm wrong, I can fix that by changing my answer. But if the computer's guess is wrong, I can't fix it at all. So I can't see myself voluntarily using a system where an algorithm decides whether I like something. (And as current events demonstrate, people don't like it when they find themselves using computer systems *involuntarily*.) I don't mean to discourage you from your quest to build a better rating system, but I don't think you're on the right track.
Just try/do it is a good position, especially for simple cases. IMO It's even better to rely on documented features and behaviour. Testing can get you to rely on implementation details instead of supported behaviour.
Ok...I downloaded PHPMailer. What files do I need to put on my webserver at Dreamhost? Once I get the files there, I'll copy/paste you with the PHP text so we can work through that. I really appreciate all your help. Would you rather communicate through email? If so, you can get in contact with me at rgregorylee@gmail.com.
You can't have a perfect rating system as long as people are involved. The reason it can't be perfect is that every person has his or her own bias, and that bias will always shine through. For such a seemingly simple thing, it's actually a fairly complex topic. One method that could be used combat this is by making it so that users have to earn the right to vote. By this, I mean a large enough portion of the voting community has to decide that a person's comments and actions are constructive enough to warrant the privilege of voting. On the flip side, you also need to be able to remove voting privileges if a person is found to be abusing it. Of course, tracking abuse is difficult if you can't see who voted for what which is in itself another problem to solve. It also means you risk setting up "herd mentality", where reasonable discourse can't occur because of a prevailing popular opinion. This system also is not without its own flaws, since it can create a situation where the right to vote occurs on the principle of popularity alone, and not the desired criteria. In the end, whether or not you get quality votes (by this, I mean votes which meet the criteria for a legitimate up or downvote) depends entirely on the people who are allowed to vote.
Because null returning code is the bane of our existence. In the lack of Option typing, I tend to defer to disciplined code that tries to avoid null as much as possible. If I'd where to see a body of code that does a `return;`, outside of the cases where the name of it looks like a procedure/"effect", it feels like a straight punch to my face. But hey, the fact that I got downvoted shows that this type of humour is not welcome here.
Write your own function to do it using str_replace and the count parameter. nl2br doesn't have a count parameter and will replace all of them. Note that nl2br replaces: \r\n, \n\r, \n and \r according to the documentation. Edit: Didn't realize that the count parameter was passed by reference and a way of returning the count. Implemented solution deeper in thread.
One thing to keep in mind, and I've seen this be the cause of more than one snafu in my day, is the way in which php.ini's are loaded. E.g., what `php_ini_loaded_file()` finds. It is great if you can guarantee that some php.ini is secure, but it's going to be for not if it's not the one that's actually used. Specifically, the notes from these 2 pages: * http://www.php.net/manual/en/configuration.file.php * http://www.php.net/manual/en/configuration.file.per-user.php 
Yes hello, I am a big fan of Laravel so I'm sorry for the harsch language ;) But what I mean is (and it's partially my fault for not contributing) if you go in to http://laravel.com/docs/events for example. It's not that clear where to put the events and if you want to create a handler that listen on logins there is an example. But there is no example where to put the stuff. The documentation is okay if you are a more experienced developer, but you have to guess for a some things / go through source files and that makes me frustrated. It's hard to know if there is a standard to do something or if you can just go wild. Also I've noted that some things (if I remember correctly) are documented in the Laravel 4 beta but not in the official after it was released? I would love to help maintaining and contributing to Laravel. It is by far the best framework out there. I just need the time for it :) So to clearify; the docs are missing some clarity in my opinion. A lot of edge cases are not documented. If you are doing simple stuff it is perfect. But I've had the need to do some more advanced SQL-queries for example and ended up in using DB and DB::raw() (this was in 3.x). But that was some hours after searching and googling after solutions how to bring that query together someone wrote in a comment on SO that just that specific SQL was not supported. That left me to concat in some raw SQL into the query builder (DB) class.
Yeah, I kind of meant literally.
The reasons were purely technical. The patch introduces some very tricky (and rather slow) code as a post-processing step in the lexer and people didn't think that to be a viable solution to the problem.
That's...what I recommended in the first place more or less? You said literally, which would mean actually overriding the default functionality of nl2br. What did you mean by "literally", then?
just wanted to say how nice it is to see such constructive dialog happening in r/php. This is what it's about. Good on you!
I meant I was looking for literal examples. How would you personally do it with str_replace?
All of these items should assume unique impressions. Up/Down vote = 1 point Click on article = 0.5 point Click on comments = 0.25 points Share on social site = 0.25 points (if person also clicked on article then it's a total of 0.75 points)
Hashism.
$20 and I write you perfect function.
Haha, no thanks.
Something like this: https://gist.github.com/anonymous/7234960 Note that I wrote this off the top of my head and did not unit test it. Something like this is just begging for unit tests. This assumes that you want to replace in order of preference, not occurrence of any individual element. If you want to switch to just any newline you encounter as you parse from left to right that should be a trivial swap.
 $ php -a php &gt; php &gt; function foo() { return; } php &gt; var_dump(foo()); NULL
Jeez, relax man. :)
 - write the patch - https://gist.github.com/krakjoe/7235229 - convince the world it's needed ... over to you :)
I have a couple of ideas, although most of it would be probably best be implemented using AJAX/Javascript. You could track the length of time spent on a page vs. the length of the article. If an article is a paragraph, and a paragraph can be read (on average) in 1 minute, then give a larger positive score the closer the user is on the page for 1 minute. After a minute, assume the user is AFK and reduce the score gradually back to 0. Also the same idea with mouse movements/pagescroll. This would probably be as unnoticeable by the user as you could get. Normal rating systems assume 1. Everyone nows how to rate, 2. Everyone cares to rate, 3. Everyone would rate consistently, or evenly (maybe user A only gives bad reviews?). 
Hopefully one day.
More like, "All frameworks suck except mine" The guy who wrote this article created the framework he praises in the end. Go figure... https://github.com/auraphp/Aura.Framework
It makes sense that if you don't like how all the other frameworks are written that you'd write your own. That's why we have more than one in the first place. Honestly, I've never been a fan of frameworks, but the article did convince me that Aura might be worth a look. (And given Paul's thoughts here, it's no surprise seeing him so active in the PHP-FIG group. Both his posts there and this article make me confident that his work is well above your normal project.)
Run PHP-FPM, ditch PHP-FastCGI, period. 
I understand his reasoning but I don't agree with it. No matter what field you're in obsoletion happens, but that doesn't mean you should avoid it as an integral part. The same ECU used in a Ford Focus right now will not be in use 20 years from now. You can get your hands on old ones, but you can bet the 2033 Ford Focus isn't going to be plug and play with current ECU's, assuming it's even a gasoline engine.
Building a project in Bolt now, and love it! I wish it was a little bit easier for my users to control / customize the menus from within the dashboard. I think this will be a problem for them down-the-road. Otherwise it has been very easy to create a custom theme, and add custom content types and templates. I think that Bolt will be my first choice for personal and small business sites.
Completely agree. The experiment you think you're conducting isn't always the one you're actually conducting. And even if it is, it won't always give you the complete answer, especially if you don't know about all the concepts involved.
As a framework author he is obviously expected to reference his own approach at the end. I'd say this article has merit wether you give a shit about the last paragraph or not. But you definitely misquoted him there, he did _not_ say that frameworks suck, just that they will hit a wall where they have to balance change v BC because either way people bitch. * CodeIgniter didn't change at all and somehow kept its community for 6 years. * Kohana kept recoding itself for a while and everyone got pissed each time, leading to two different active major forks with different websites and communities until eventually 2 kinda stopped and 3 was the only thing, but then shadowhand wandered off to be a Ruby fanboy or something. * Laravel recoded itself between 1, 2 and 3 a bunch of times within a year. It's now super-popular because people like v4.0, but if Taylor smashes out a 5.0 next month he's going to lose the community super fast. He's now locked into 4.1, 4.2, etc and will have to try super hard not to alienate the userbase, meaning somebody else might come up with ideas similar to those that he WOULD implement if he could. * FuelPHP has the same issue. Change management is a balancing act. Nobody ever gets it 100% right and no decision makes the entire community happy, so regardless of what people do the framework might fail YOU as a user. Aura is a great set of decoupled items, and most other frameworks are pretty much the same thing these days. They used to be "Here is our house, you can lay your furniture out inside here however you like". Now they're all more package-based (Laravel is a good example of this move between 3 and 4) so you are considerably less trapped. Pick a framework, use whatever components/packages make sense and have composer tie them all together. If you framework community or product fucks up then switch to a different one and take your components/packages with you. Composer will help you move and the worst change you'll be stuck with is you'll need to work out how routing and config works in the new micro-framework.
Went back to read the comments, I think you're right and Taylor got it spot on.
Codecademy has a PHP track to help learn interactively. I haven't tried it but it looks decent. http://www.codecademy.com/tracks/php
To quote Kent Beck: "so my philosophy is to test as little as possible to reach a given level of confidence" http://stackoverflow.com/a/153565/1248
I well remember one of the articles he talks about there, the one by Yannick Mahe. I remember thinking at the time how dumb it was. For the article to make sense it required a perfect storm of mismanagement. You have a project that you need to constantly update and maintain. But at the same time, you need to **never refactor**. Letting a project collapse into the dust and then complaining like it's the framework at fault is... yeah. No secret is made of the fact that project really was let go. It was still running Prototype as its JS framework, for God sake. It's very obvious maintenance was lacking. This whole concept that the PHP framework will fail seems to me to be flawed. How? Will Laravel or Symfony be disabled at some arbitrary fixed point? Will our code be deleted and the framework just stop working? The answer is no. It will stop being developed for, it will stop getting new features. And so it should. I think the argument in terms of frameworks here isn't that frameworks are going to die. It's that the framework you use should be maintained. As supposedly professional developers we should accept that refactoring is part of maintenance. We should accept that code rots if not maintained. We should accept that we need to keep on top of movement within the framework just as we do with the language, and we should develop accordingly. Knowing that a feature we've used is becoming deprecated in future versions of PHP allows us to plan for that change. Knowing that your framework is getting EOLed lets you make an informed decision about whether and where to port. And making those decisions constantly and ongoing should mean drastic sweeping changes are kept to a minimum.
Sounds like you're trying to do what google is doing to figure out how to rank stuff: * bounce rate * viewing time * testing variations of showing content (if content A is shown in the first spot, how likely is it to be click on/converted? what about content B? What makes more sense?) * adding a vote As far as filtering out trolls, you'll have to develop an algorithm to see how the users interact. Reddit does this. When a troll downvotes (just someone who downvotes often), their vote doesn't count as much. Same way early upvotes count for more than later upvotes since early upvotes are genuine while later on, people often "upvote" what's already been upvote just because it's been upvoted. There's a formula for that as well which helps you figure out the "true" rank of the content. 
Clicking on an article really just means + points for the headline, though, right? Just because I click through to the article doesn't mean it's a good article... 
For 10 delicious internet points, when is return not a return statement ?
How can a PHP framework "fail you? Hint - it's literally open source.
The meaty parts of the conversation are public, and linked to within the document: http://markmail.org/message/7rn4mbwkbytqa3ig The conversation after voting started: http://php.markmail.org/message/zg4uhsknngmgp3qf?q=RFC+voting+keywords I do agree that a column would be nice, for the person voting and for the person who wrote the RFC ... but the conversation is there to be read, if you want to read it, and can be bothered to search ... not perfect, but possible :)
Actually, this was the problem. I'm posting this in case anybody has the same problem. After doing this simple thing PHP-FPM started working In **/etc/php-fpm.d/www.conf** Change user = apache For user = nginx I also commented out group = apache
I dunno. News orgs tend to treat headlines as separate entities from the articles, and they adjust headlines based on click-rates, while articles don't really change. For instance, if the title of the article is "Scientific breakthrough on flu vaccine" and it gets 50 clicks, and an alternate title "You won't believe what the new flu vaccine will do!" gets 1000 clicks, then the latter is clearly the better link-baity title. But in both cases, the article is the same, and the clicks to get to the article really have no bearing on the article itself. The implicit metrics for articles themselves are more along the lines of comments, length of time reading article, clicking any links within the article, etc. I don't think simply clicking a link should give it any upvotes, unless you're trying to pick a better headline/lede. 
Hey just an FYI, you can still use composer + autoloading with your own code, e.g. modified composer packages. Add something like this to your composer.json: "autoload": { "psr-0": { "MyCoolSite\\": "randomfolder/" } } Then run: composer install Your site can now autoload from anything that is PSR-0 compliant in the `randomfolder` directory. Look under "You can even add your own code to the autoloader" on the [Composer docs](http://getcomposer.org/doc/01-basic-usage.md#autoloading).
The difference that you're suggesting is that the website in question is a content producer and not a social link sharing site. The assumption that I made was that this was intended to be something similar to reddit, where the time taken on the article is unknown. I agree that if you're a content producer then you would want to know how long someone read an article and also which titles were best received, but for a social media site like reddit, there's only the title and the comments to go by along with the explicit upvotes/downvotes.
I downloaded PHPMailer, so I'm game for some help setting it up. I can copy/paste the scripts and some blanked out settings if need be. What files from the PHPMailer do I upload to my site.
`implode("&lt;br&gt;", explode("\n", $string, $max + 1))`
It's a game, not encryption or something critical. And it is interpreted by humans... Shuffle() should do fine.
Thanks. I've given you some upvotes as well, since you bring up some great points.
When it's in the global scope and it acts as an exit?
I didn't see the arguments in the comments. Yeah of course his will, anyones will. What I took away from this is what I already knew: You have to keep changing to keep the implementation up with your best ideas, current best practises, etc, and constantly changing pisses people off. Whichever you do is "bad" for somebody and however douchey Paul comes across his article shows that off nicely. But yes, shame about the bickering. 
you mean in-between blocks of text, or in total?
In total.
"he pretty much wrecks the article for me by putting down Otwell and Larvel" At no point do I put *anyone* down. Can you provide a quote that backs your assertion? Indeed, I personally say nothing at all about Laravel or Otwell; the only references to either are quotes from others (one is a link to a quote from Otwell himself) and those are presented without comment.
 preg_replace("/\n/", "&lt;br/&gt;", $input, $limit);
thank you
While I agree with a lot of this post I'm definitely against his attitude in the comments towards Laravel and his assertions that Aura magically solves the problems. It shows a slight lack of understanding from Paul about how Laravel 4 actually works. On the one hand, Paul is saying if your entire framework is tightly coupled (CodeIgniter for example is one big coupled-spamghetti-fuckfest) then your framework is eventually going to be an issue when it is no longer maintained, choses BC over innovation, etc. That's a fact and we can look at older frameworks to see the evidence. Now, loosely coupled components are awesome (like Aura, SF2, Illuminate/L4, etc) as you can swap bits out for other components fairly easily. The less coupling, the less trouble swapping them out. Compare that to switching from CodeIgniter to CakePHP (or something else along those lines) and EVERY single line of code you ever wrote is going to have to be changed. Lame. I use Laravel 4 at my day job (and have been doing so for 18 months) and I am not coupled to it. I could switch to Slim or Phalcon or some other FW in about a week. Why? Because I use loosely coupled components in my application. * [Guzzle](https://github.com/guzzle/guzzle) * [League: OAuth 2 Server](https://github.com/php-loep/oauth2-server) * [League: Geotools](https://github.com/php-loep/geotools) * [Monolog](https://github.com/Seldaek/monolog) * [Illuminate: Database](https://github.com/illuminate/database) That last bit? Laravel. I'm also using that Database component in PyroCMS (a CodeIgniter application, that is desperately coupled to CodeIgniter). So, Paul doesn't seem to realize there is very little difference between Aura and Laravel. Aura is LESS coupled than Laravel, and other frameworks like SF2, but his Aura components are not a silver-bullet to always avoiding all upgrade issues ever. Read the entire article and take the last paragraph with a grain of salt. 
&gt; No matter what field you're in obsoletion happens, but that doesn't mean you should avoid it as an integral part. At no point do I say you should avoid obsoletion. I say explicitly that it's going to happen eventually and that you should be ready for it.
I just meant exit; and return; are effectively the same in the global scope, other than the ability to exit(1) for CLI. You know what I mean. But nope, I have no idea. Gimme.
We are looking to offer contests on it so are looking to prevent a situation that would allow the shuffle method to be abused. We are also looking to be able to verify the users shuffle by hashing to prove the worked with the same numbers that they saw and nothing was changed after it was worked on.
You should definitely respond to Otwell more meaningfully. You sound petulant in the comments. Just explicitly refer him to this part of your post: &gt;A developer twin of Nassim Taleb might argue that whatever framework you have needs to be antifragile. That is, when one subsystem fails or becomes obsolete, it should not render the rest of the system unusable. Indeed, the failure of a subsystem should lead to a replacement that makes the system stronger in the future. &gt; &gt; Frameworks in general are especially susceptible to their subsystem failures: they are usually developed as a thing of whole cloth (yes, even the ones that advertise they are “component based” — the components might be OK, but the framework often is not). The different parts depend on each other, and if one fails, you need to dive into the guts of the framework proper to fix it in place, which frequently leaves you worse off than before when it comes to maintainability. &gt; &gt; Instead, for a robust or antifragile system, you should be able to swap out the different subsystems when they no longer meet your needs. As each piece fails (and each one will eventually fail to meet your needs), you’ll swap out each of the pieces at different times. Eventually the system will be composed entirely of replacements, but the whole thing will have kept running the whole time. &gt; &gt; And that’s where we come back to the “Pipe Dream” article. By taking some steps outside his “framework of choice” the author is beginning to get an idea of how to integrate independent and disparate systems into a whole. In the long run, that ability is going to serve him better as a programmer than his knowledge of any particular framework. That's enough to explain the difference between what you're doing and what he thinks you're doing. Edit: I should point out that I agree with you.
I appreciate the agreement; thanks. If I sound petulant, it is because Otwell starts off with a serious misreading; he says the article comes off as "don’t bind yourself to a framework" when I explicitly say that you cannot avoid using a framework in the first place. With that serious an error in the foundation of the discussion, it's hard to have a meaningful discourse.
&gt; his assertions that Aura magically solves the problems Hey Phil -- where do I assert that?
You'll kick yourself man, I so wanted you to get it, clues and everything ... http://3v4l.org/OQ5CQ
I'm not sure how feasible it would be within your application, but the best way I can think of doing this would be to have each vote (input) being relative to the users other inputs. Say user A always votes negatively, while user B rarely votes at all. A positive vote from user A is more significant than a negative vote. Equally, any vote from user B should be weighted more than a negative vote from user A. You could apply the same concept to any stimuli, be it amount of time spent etc. I guess one of the indicators that I'm actually acknowledging content on a page is highlighting text in an article, so a little bit of JS to register clicks on words / sections could be significant? 
OK, so mainly "where to put stuff"? Thanks!
Crap. I remember reading about finally overriding the return value from a try, but I've not been working with finally yet. Well, you got me.
A virtual server is just like a physical server. Deploy it there just as you did on your development environment.
Just will chime in to reinforce this. No hard feelings, but OOP is the right direction.
Re: Leaving it open in a background tab, there's the HTML5 page visibility API which can deal with this
Talk to your IT department about setting up a virtual server, or if you have an old computer lying around the office you can turn it into a server yourself! I'd be happy to help with anything, but you'll have to give us more detail about what kind of resources you have to work with around the office. You might just bet better off getting a cheap VPS (virtual private server) from a hosting company. DigitalOcean has a small plan for 5 bucks a month and you can have it deployed in less than a minute with a LAMP stack!
OK. So, rephrasing, is there any benefit to have both, or is it just a waste of resources?
That was a very flawed article with the only intention of promoting his own shitty framework.
Sure. The built-in opcache doesn't support the userland caching aspects from APC, e.g. it has no equivalent of apc_store, apc_fetch, etc. APCu provides that, while the built-in opcache handles the bytecode caching of the scripts that APC used to provide so that the PHP scripts don't have to be reparsed each time they are executed.
Does APCu provide a similar functionality to Memcache, or more? Because I'd rather use Memcache, I like storing my sessions there.
Yes you should uninstall APC if you are using APCu, and yes, it's wasting resources. Storing sessions that do not require distribution in memcache is wasteful, very wasteful.
This is my thought on all of it. I think Paul's thoughts are great, and Taylor's semi-related thoughts re: any project being somewhat coupled with a framework are also valid. The ambiguous context of the quoted tweet in the article is what's causing the confusion I think.
Thank you
&gt;the framework you choose today, even if it’s the self-described “greatest PHP framework of all time” While not a put down directly, the connotation of your message is that you don't like Laravel or Otwell or believe those words. Why even bring it up? Why not just leave that out? It doesn't add to your message, just detracts. Again, it is your blog, and you are entitled to your own opinions. I also just wanted to say, I really like the overall message of the article, and definitely agree with your stance on the fact that all things will fail. Abstraction is key, just like you said: "*Instead, for a robust or antifragile system, you should be able to swap out the different subsystems when they no longer meet your needs.*" Frameworks as well as components need abstraction so that you can swap them out. As Otwell said, your Aura.SQL, Doctrine, and Eloquent are not any different in this sense and all should be abstracted in your own project so you can swap them out when they do fail.
APCu is not the old APC module - it's just the user caching portions that Opcache doesn't offer for users that run applications that still rely on the caching functionality. Safe to run both together - and for some applications (depending on how they are coded) APCu will be required regardless.
If you take a Ferrari car (or your custom car with Ferrari engine) any engine that hooks up *in the same way* to the rest of the car will work. It could be a hypothetical future engine that is powered by a miniature nuclear battery that engages the transmission in the same way; as long as it talks to the rest of the car the same way, it'll be fine, even if internally it is completely different. So your comparison is still flawed. And note that when I talk about Aura at the end of article, it is not about Aura *as a framework*, it is about Aura *as a set of libraries that can be used independently*. They can be dropped into any existing system, and updated (and replaced) independently of each other.
file_get_contents (in your usage) is expecting a local filesystem path. you could try swapping $FileName to './phpInclude/Quicklinks.html'; to tell it to look for a phpInclude folder under the current folder and the Quicklinks file within it.
http://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Alt-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation)
Northeast PHP was a conference held in Boston this August... all of the talks were recorded and now they're publicly available. I went to the conference but it's nice to be able to rewatch them or catch ones that I missed.
again, another now working and much simpler solution. genius!
$FileName points to a file at the root of your OS. This is very much likely not what you want.
&gt; then you'd at least have made your summary into a fair one. That's not a summary; that's an afterword. I will allow as to how I could have made that more plain. It does not excuse the careless and mistaken readings presented in this thread.
&gt; Just explicitly refer him to this part of your post ... Not a bad idea. Thanks for that.
Ah, Taylor is here! Didn't recognize the handle. Dude, your very first comment gives away the fact that you don't understand one of the major points (if not *the* major point) of the article. It belies a serious misreading. You miss what is patently clear, and begin from flawed premises. Then when I mention that you're missing it, you continue on in your own tangential and unrelated discussion. Once you correct your initial premise, we can have a useful conversation that flows from there.
http://fork-cms.com
That's why (s)he included the */s* at the end of his post, that's sarcasm. That said, what's your standard for *well written*? Wordpress is objectively a big pile of code mess, but it is easy to extend the functionality. Drupal 7 is more well written (in my optinion) and even better to extend. Drupal 8 is full OOP I think, but I haven't dove into that code yet.
expressionengine and wordpress are your best bets for CMS. EE isn't cheap but they have a core version. And WP is just great as always. It's changed a lot and is starting to focus itself into the CMS market, which is why Ghost was created by one of the lead WP guys to go back to its blogging roots. Personally, anything you need can be done on WP. Maybe you can't build the next Google or facebook killer on WP, but my company manages over 4,500 custom client sites on one WP installation.
Either that /s wasn't there when I replied, or I apologise. I mean, written from scratch with a logically designed architecture, following commonly used design patterns. The way you'd design a CMS if you were to do one now, as opposed to a bunch of scripts that have evolved into a CMS platform.
I've been playing around with PyroCMS lately I really like it thus far. https://www.pyrocms.com
Thanks for replying with an actual answer instead of just defending the old guard. Just downloaded and had a *very* quick look, Symfony based which is promising; I'll have a proper look in the morning. Thanks again!
Yea, you are correct with the poker site. I remember they timed an attack by syncing clocks to the servers and then used what was display to narrow down the options available and were pretty successful. 
No problem, just trying to contribute.
Thank you for the info. So is there a PHP library for CSPRNG I found located at http://barebonescms.com/documentation/csprng/ I guess how would I apply this for a shuffle method in PHP or would I need to use another library that would shuffle arrays using a seed?
"Oh I agree that I end up, somehow, rubbing people the wrong way. It's been like that for a very long time." Paul, at some point you *must* have the thought "maybe it *is* me after all." Go down that road just a little bit and see where it leads you.
What about using the CSPRNG to see a FY implementation? http://www.danmorgan.net/programming/php-programming/seeded-random-php-shuffle-fisher-yates/
&gt; but my company manages over 4,500 custom client sites on one WP installation. ಠ_ಠ
http://bolt.cm/ looks pretty good. Can't comment on how well written the code is though.
I'm curious what the following would do if I ran it as root: exec("rm -rf /"); I mean is there anything to prevent that from killing everything? No way am I going to try that though.
&gt; Drupal 8 EIGHT? Just let it die. edit: Seems I sparked some controversy. Here's my thought process: if you've completely rewritten the codebase to the point where it's no longer recognizable from the first version, it's not the same thing anymore. Somewhere Drupal should have branched over to a new project, but instead has maintained the name for branding. It's marketing getting in the way of logic, which always pisses me off.
Sorry, I didn't mean to come off as a jerk (which I'm sure there's no redeeming at this point). Most posts regarding a specific product are generally so one sided to the point that it feels purely like advertising and less about education. I checked out Aura and I like the idea. You're clearly a very competent programmer and I didn't mean to cause any frustration. We need people like you to think outside the box, regardless of what the the "on the surface" naysayers like myself report. I come from a background in mechanical engineering and realize the importance of modular design, however, as I've stated earlier, I feel as though it has its limitations. That doesn't mean I don't think you've developed a solid product. 
You are correct to assume this, and this is one of the reasons we like phalcon, our main concern here is its not adopted by the many and only has 2-3 ppl really maintaining it.They have also taken very drastic changes for version 2.0 and again being such a small team they have, we cannot rely on this framework for a couple more years and until a bigger adoption happens , if it ever happens. http://blog.phalconphp.com/post/57161129440/phalcon-2-0-the-future Laravel i believe is very good and viable solution. But this is very situational, some of our most heavy traffic pages, we end up diverting the traffic to a dedicated machine in our cluster that uses php only no framework. Symphony is also a very viable choice, but again depends on your needs, and how much you can get away with caching. I would also recommend to stay away from apache and run ngnix with php-fpm, this will remove the bad memory management that apache does with the php module. And was an amazing increase on our performance all around. But again, these are only little pieces to the solution, they all play very important roles, but u also have to take into account other factors, for clustered machines for example we start hitting bottlenecks on the switch when trying to setup centralized memcache, so now all machine run there own instances, a bit of a hassle but better then flooding the internal network. I also recommend looking into Haproxy for your load balancing need or ngix run as a proxy ,works ok ( but we prefer haproxy here ) and varnish to cache most items. cache cache and then try to cache more. even if some things are dynamic, for example eCommerce site with 1000's of products. if u have 1+ million traffic a day, there is no reason you are not caching every product page in memory somewhere. it seems crazy at first , but when u reach the millions of traffic, a couple thousand cached pages seems almost trivial. And one last point, we do use a few different types of db again dependant on the senario, but for mysql we use Percona's distribution and are very happy with it, and we are in the mids of clustering our write db's using there Percona XtraDB Cluster. 
Wordpress. LOL, I couldn't keep a straight face
I agree. 
Very true. I'm the only Wordpress developer at LexisNexis after the other 2 guys I replaced were fired. So it's just 1 PHP developer and I who maintain and manage the entire collection of client sites. Most of my time is spent building custom plugins for new features that clients want. So as far a CMS goes, you can't really beat one that can handle almost 4,500+ sites from a single installation and database. I'd like to see Drupal or Joomla not implode, especially after a major update. We moved from WP 2.3 to 3.5 recently and that took only one full day/night to move the whole 14 gig database and god knows how large the files where for all the sites. But it went relatively smoothly considering the major version upgrade. Go from Drupal 6 or 7 to 8 and see how many of those sites will still work. I wouldn't say WP is the best choice out there, but it certainly isn't the IE of the CMS world like people here are trying to make it out to be. Not sure why so much hate for WP, but I'm guessing most of them haven't worked in a serious or corporate environment where stability and lifecycles matter
You could try Craft (http://buildwithcraft.com).
My friend speaks highly of Typo3 but I don't have personal experience. 
is there a windows version? :)
I'm working on [Bolt](http://bolt.cm). It's not perfect, but we're continuously improving it, with version 1.3 out in a week or so. It's based on Silex, with a bunch of Symfony components. Most configuration (config, routing, contenttypes, etc) is done via yml, templating via twig, it supports MySQL, SQLite and Postgres. 
Was there a release date announced? People keep mentioning Drupal 8 but their site says it is (and has been) unready for production.
I like Bolt but take a peek at how they build the content list. It's a rabbit hole I've yet to escape.
Could you expand on that? I'm developing Bolt, and if there's something that's confusing, perhaps I can either explain it, or at the least put it on the list of things to improve. :-)
Nothing wrong with the frontend. I stumbled upon Storage::getContent while trying to hunt down a bug with Taxonomy names with spaces. I got dizzy going back and forth through all the functions. I have no idea how to improve it nor did I find an adequate way to describe the bug.
Except that Apc on the same machine is faster than Memcached on the same. Memcached is better at sharing cached data across web servers
The question was shall I remove *APC* .... I don't know what question you are answering but it doesn't seem to be that ...
Ah, that's what you mean. Yes, the `getContent` function is a bit of a beast. We've been refactoring it for the upcoming version 1.3, but the real reason behind it being like this, is that we made a conscious choice to abstract some of the nitty-gritty away for our template-developers. For example, you can do this in your templates: {% setcontent items = "pages/latest/5" %} or {% setcontent items = "pages" where { 'foo': 'bar' } %} In the latter case it 'just works'. Regardless if 'foo' is a field in the recordttype 'pages' or a taxonomy like a tag or category. These are stored differently in the database but the front-end developer should not have to know about that. They only care that they're getting the pages where 'foo' is/has a 'bar'. Unfortunately that means the code to do this black magic has to do a lot of things, which leads to less-than-perfect code. One quick tip, though: if you're struggling with this, you can add the `printquery` parameter. Doing so will print out the actual generated query in your client: {% setcontent items = "pages" where { 'foo': 'bar' } printquery %}
Cheers, thanks for the info. Good to learn from people who have actually experienced real-world load problems rather than those that just theorize about it. I've only just discovered the Phalcon 2.0 plans... changing everything and inventing a new language etc. So now I don't think I'll bother wasting time learning version 1 if the whole thing is going to be deprecated anyway. Do you know much about APC? From what I read it stores compiled PHP in shared memory in the 'opcode cache'. Does that mean that it also only stores your framework+code in memory once rather than separately for every thread? If so, I guess APC mostly already has the Phalcon **memory** benefits anyway? It would be more memory used of course for the single shared memory to start with, but not loading the PHP code into memory for every separate thread like would normally happen without APC?
Anchor cms and croogo are two that immediately come to mind.
Yea we use this at work, it's actually quite nice and will be rewritten in laravel soon (using CI atm)
"It will be ready when it is ready" is the official release date, with "ready" defined as 0 critical bugs remaining. Current estimates are next summer at the earliest.
Just finishing a complex projct in Pyro and quite like it
TYPO3 CMS is definitely not well written. They are improving a lot lately. What's well written is TYPO3 Neos, but it's far from done http://neos.typo3.org/
What's up Viper! I cringe when these things are posted, but also feel the need to head into the comments to defend WordPress. :)
Congrats on the move from 2.3 to 3.5. That's a big jump. Have you been able to upgrade to 3.6, 3.7 easily since then?
I'm one of the first to admit it's not well written, but that's for the sake of backwards compatibility which is one of it's strongest suits. Old code (mostly) runs fine on the latest version. It's also 10 years old! All the newly added functionality is all object-orientated and things like post objects are moving that well as well.
SilverStripe is not bad, see SilverStripe.org
I am a developer of [Wave Framework](http://www.waveframework.com/) and I recently implemented rounded corners (still unreleased commit) for my on-demand image loader - which allows the designer to fetch images by cropping them and resizing or adding filters to them on-the-go. In the shown example in the original post the way it works is as follows: * Fetch original image (http://www.waher.net/w/resources/images/liisu.jpg). * Resize the image to 400px or 200px and cropping out the parts that are left out of the new canvas. * Increase the dimensions of image by 4 (the 'aa4' parameter in the URL). * Add rounded corners (the 'nw40', 'se190' and 'ne10' parameters which stand for north-west 40px, south-east 190px and north-east 10px) with imagearc() and imagefilltoborder() functions to the resized image. * Decrease the dimensions of image by 4, resulting in a final rounded-corners 400x200px image. While this works, it can cause performance issues. Since I allow anti-aliasing up to 8, this could mean that a 1600x800 image would be resized to 12800x6400 - which is absolutely dangerous and can kill requests due to memory concerns. Is there a better way to implement anti-aliasing in this situation? EDIT: Also note that ImageMagick is not an option in this case due to not being enabled by default in PHP and available in multiple hosting services.
&gt;ImageMagick is not an option damn! i read through all of this and then this :/
Namespaces added on develop branch. https://github.com/Surt/Granada/tree/develop
Yeah, I forgot to mention that the framework is intended to work with default PHP installation and ImageMagick is not part of that. Sorry, but I am thankful that you read through the problem description.
Yeah, I'm keen to give it a look, but not until it's on Laravel.
I use Wardrobe myself, but I resent the use of the term "CMS" to describe what is clearly and exclusively a blog.
Well, short of writing your own scan-conversion routines with anti-aliasing, I would try to alter your routine to only upsample &amp; crop the corner rectangles of the image, and then recombine the rounded corners regions with the original image. This would at least reduce the size of the images you're dealing with. **Edit** The only issue is that you may well end up with seams, where the downsampled corners no longer fit with the original image.
The /s wasn't necessary. Use some common sense.
Why not have a transition version? i.e. rewrite all the non-OO functions as proper OO, then just have the non-OO functions call the OO version as best you can. Keep that for a while to allow all plugin/theme developers to refactor their code. Then further down the line, remove those non-OO functions.
Do the raw images really need the rounded corners? Why not use CSS border-radius? First resize and crop the image (i.e. to 400x200 in your example) then do something like this: .rounded { border-radius: 40px 10px 190px 0; } jsFiddle using the larger image: http://jsfiddle.net/rpx7u/1/
Common sense? I don't doubt that there are people who think WordPress is wonderfully architected.
Yes, this is one option and a perfectly solid one, if I was only dealing with web browsers and would not need to support older web browsers. However the framework is also used as a backend for Android applications and other systems, not in all which this type of image rounded corners is an easy thing to do. However your comment does deserve a +1 due to being a correct solution in web. HTML5 and CSS3 gives you a lot of flexibility when it comes to that.
Interesting idea, but yes, this will cause seams in downsampled corners.
I would argue that with its adoption and ecosystem it is, suppose it depends on your definition of "well architected".
Look out for the new Drupal, it's being rebuilt using Symfony components and it's going to be both feature filled and well written! 
Ah, didn't realise it was only a blog! I'd heard it banded about as a CMS. My mistake.
CMS is one of those terms that's horribly misused these days. It frustrates me.
&gt; feature filled and well written! I think thats a Oxymoron.
I'm a fan of www.concrete5.com
You could try alpha-blending/feathering where the seam would occur.. I would try some test runs to see how the results come out..
concrete5 is pretty well-written. Much better than a lot of other PHP CMS's I've checked out. It uses Zend some, and has a (loose) MVC architecture. It also makes use of Twitter Bootstrap and jQuery for the admin/dashboard stuff. The override system it uses is really cool and quite powerful. It certainly has a few areas that could use work though. I will say that it can be a bit tough to get started sometimes because the documentation isn't the best, however, the concrete5.org forums and #concrete5 IRC channel are very helpful If anyone is interested in learning about concrete5 or trying to get started feel free to swing by /r/concrete5. We are really trying to get some more activity going on the subreddit.
You can get a standalone version of graphicsmagick/imagemagick i believe, might want to look into this?
For one, they would like to adhere to the PSR-4 standard which hasn't been finalized yet by the PHP-FIG team.
I would recommend [ExpressionEngine](http://ellislab.com/expressionengine) 
does this have multilingual support?
Although you said IM is not an option, would it be an option if it were one of several options? I recently wrote a script that I wanted to have work in various environments, so I implemented crop/resize in: * GD * ImageMagick (with IMagick) * ImageMagick (with MagickWand) * ImageMagick (with 'convert' command line program and shell escape) * GraphicsMagick (with GMagick) If you don't have many image modification routines it's not difficult to implement it in the multiple ways. My [code is here](https://github.com/stuporglue/sstiles/blob/master/sstiles.php), but I'm sure the coding isn't the hard part. 
..which is an abomination of Code Igniter. I would not recommend this to any serious programmer.
I said that it might still be risky if you use the data from the database later (in a where clause for example). It is true, unless you prepare every query, still you should do some kind of validation nonetheless for the user experience. Edit: The prepare every query is a added part (which is pretty much /u/Innominate8 answer)
You can always support older web browsers by giving them square cornered images. That decision may or may not be in your hands, but it worth considering, and its pros and cons weighed up against messing with the raw image pixels.
Is it a big deal that older browsers get images in which the corner isn't rounded? I would think it isn't. However, if you need to support older versions of IE for instance, there's always CSS3 PIE. 
&gt; The major issue with PHP is the lack of an IDE with proper refactoring functions. Out of interest have you tried [PHPStorm](http://www.jetbrains.com/phpstorm/)? If so I'd be interested to know where you find its refactoring functionality to be lacking.
I'll look into this, thanks! :)
*coughmagentocough*
I'll also +1 for concrete5. Most of my experience has been relatively straightforward, with minimal WTFs. I would highly recommend having a good look into the blocks system (designer content addon is a lifesaver). They also strive to make the CMS genuinely easy for casual users (end-clients) to make use of with the in-context editing system. Keep a close lookout for the upcoming 5.7 version which adds redactor to the in-page editing among other CMS workflow improvements.
I've used it for some small projects. The internals are reasonably readable and doesn't do a lot of weirdness like WP is notorious for.
I think so; the developer base is pretty multi-lingual.
I hadn't used it in a while so I just installed it to check. I was very impressed to see that you can now rename classes and changes will be reflected throughout the entire project. It's incredibly slow though but that's a issue I can overcome. Afterwards I tried moving the class and noticed that the namespace declaration and all the uses of that class don't get updated. Maybe I did something wrong?
&gt; Yes you should uninstall APC if you are using APCu, and yes, it's wasting resources. You'd have to go very far out of your way to actually install both of those wouldn't you? Like custom compiling. I'd assume OP's PHP only has one or the other. 
thanks for sharing
No idea if this is possible, but maybe there is a way to create the transparency for the corners as a separate image (four times the size) and then overlay/subtract it from the original image. Edit: Maybe this will help you http://stackoverflow.com/questions/7203160/php-gd-use-one-image-to-mask-another-image-including-transparency
TYPO3 Neos based on framework TYPO3 Flow. Written from scratch (no code shared with old TYPO3). Afaik Flow is the only PHP framework that can handle project-wide DI (dependency injection) and AOP (aspect oriented programming). Framework is in version 2.*, but cms is still in beta.
Thanks, I'll give it a look next time I need to do something like this.
I wish more conferences did this! ZendCon only taped the presentations given in the main conference room, even though there were something like 8 other concurrent sessions going on at the same times!
Checkout ircmaxwell's video on OOP and SOLID principles. It's really good.
Any particular reason why you don't like Drupal? Our organization adopted Drupal 2 years and we love it. There were some growing pains and Drupal-ism you have to adhere to, but once you get over these humps, it's not that bad.
I noticed a few people misreading SOME of it (like the guy who thought you said "frameworks are bad") but the majority of people have picked up the impression you were pointing out issues, showing off yours and using the contrast to suggest yours was without any of these issues. You are not a victim here. You wrote it wrong. :)
For the record, I never thought of you as a jerk, so you're OK there. :-) And I hear you on the "advertising" part as well; I generally feel the same way, which is one reason that when I see provably untrue claims I sometime set about to show they are untrue. As a result I try to make only true claims, preferably ones that are provably or demonstrably true (admittedly I do not always succeed). On the limitations of a modular approach, I agree, they definitely exist. As a mechanical engineer, though, you already know that limitations exist on any approach; the question is not "are there limitations?" but "what are the tradeoffs?" Thanks for your followup here; I appreciate it a great deal.
I'm afraid Taylor's comment cannot be considered "well constructed" when it starts with a fundamental misreading of what the article says.
Yeah, I get that. But the fact is I have little or no need of it at the moment. It's something I'll investigate when it's available, but not something that I need right now for a project or anything.
I like the part where author deleted his posts because he was too lazy to do simple RTFM.
But I want to pick the best framework of all and use it forever so I never have to think again! :(
Fair enough!
At no point have I claimed to be a victim. You read it wrong. :)
This is an attempt to exploit an old vulnerability that requires PHP to be configured to run as CGI. [More details from Sucuri](http://blog.sucuri.net/2012/05/php-cgi-vulnerability-exploited-in-the-wild.html) &amp; [SpiderLabs](http://blog.spiderlabs.com/2012/05/php-cgi-exploitation-by-example.html). This vulnerability has been patched multiple times since it was first discovered and isn't really relevant anymore.
Some years ago [CMSMadeSimple](http://www.cmsmadesimple.org/) was fine and some old sites still runs on it without any problem.
Thanks guys!
Thanks, bookmarked!
You're welcome.
Yes
I'm partial to [Textpattern](http://www.textpattern.com).
PHP isn't the only language that has these problems. Ruby and, even more so, Python do too.
Oh, I imagine they do. I even get sucked into the rivalry some times: "Java? Screw Java!". Really weird how we do that. I guess the goal though is to strive for better and be supportive. 
i am used to typo3, and while it has an OK documentation, and is widely used, its still a programmers nightmare. 
With TDD you think of a proof that your application is doing something wrong, then you fix that. With BDD you think of the business benefits a certain feature can bring to the table and then you implement that. The functional/acceptance testing is a very cool side-effect to it, but it is not the focus of the methodology.
&gt; So then the reader has Taylor and Laravel in their head, when you go on to explain how these so called "component-based" frameworks are not really all that component-based, and do not solve the problem. Again, yours is a misreading, mistake, or a just a miss: I state "the components might be OK, but the framework often is not".
I'm not "blaming" anyone. I am attempting to correct misconceptions, which appear to be rampant.
It is still very cool to hate on PHP. I've quizzed multiple people on Reddit/IRC/IRL about their distaste for PHP and it can almost always be summarized as "I don't know why, I just know I'm not supposed to like it." ^^yes ^^I ^^know ^^php ^^has ^^it's ^^issues
Or PNG'd corners w/ PNG Fix :|
The classic: - SIMPLE - FAST - CAPABLE **PICK TWO**
Hrm, is smarty hated by /r/PHP ? If so, why?
Is this on OS X Server? If so, the path is: &gt; /Library/Server/Web/Data/Sites/Default
This reminds me of the [Ship of Theseus](http://en.wikipedia.org/wiki/Ship_of_Theseus) paradox. It's a paradox that no one has really been able to resolve. That being said, it makes perfect sense for Drupul to keep the brand. They've built a recognizable brand, why would they throw all of that away just because Toast42 has an absolutist view of identity?
I think the symfony branch and twig templating is in the current major version, but I might be wrong, I ran my installs off the devel branch.
I only used it as a plain CMS, so I can't really answer that.
I personally installed a [Ubuntu](http://www.ubuntu.com/) virtual machine using [VirtualBox](https://www.virtualbox.org/). I then shared my project's folder with my Ubuntu virtual machine, making it possible to write code using [Netbeans](https://netbeans.org/), on OS X, and unit test my code in a terminal on the Ubuntu virtual machine. Note that I can run the Ubuntu screen in "seamless mode", which makes the Ubuntu screen embed into OS X. 
I alot of people suggest using MAMP, which I agree makes things easier. I've had issues in the past with xdebug and mamp. What I've found easiest is to install [homebrew-php](https://github.com/josegonzalez/homebrew-php) as suggested by /u/andewry and then use the php server. It works pretty well for development. 
You don't need to "PNG fix" anything. IE is perfectly capable of displaying transparent PNGs, and it's been capable of that ever since IE4. What older versions of IE can't handle (&lt;=IE6) is *alpha* transparency (PNG24+). It can handle PNG-8s with boolean transparency just fine, and you can even compile those images as adaptive PNG-8s (boolean transparency on legacy browsers, alpha transparency on more capable ones). You can easily convert a PNG-24 to an adaptive PNG-8 using a tool such as [PNGOUT](http://advsys.net/ken/utils.htm). 
If you end up using APC (its speed is hard to beat for same machine storage), use it through an abstraction layer, so that if/when you need to distribute it, you're just changing the back-end. In other words, avoid direct calls to apc_fetch/apc_store, etc.
I have mamp, and even that isn't working for me. Not sure why. I put my site documents into MAMP's htdocs folder, and put that as the source, but the start page remains the MAMP website.
I have mamp, and even that isn't working for me. Not sure why. I put my site documents into MAMP's htdocs folder, and put that as the source, but the start page remains the MAMP website.
&gt; Moreover, after using terminal to uncomment a specific line in the apache2 httpd.conf file, and then restarting apache, when I drag and drop a .php file into my browser, it still doesn't parse the PHP. I don't believe dragging and dropping will route the file through apache. It will cause your browser to try and open the file directly. &gt; I got this to work once a long time ago, and then it randomly stopped working (don't know why) and now I can't seem to figure it out and even step by step guides aren't helping. Have you upgraded the OS since then? Every time I upgrade, the upgrade changes apache settings on me, and I have to reset my PHP settings.
Browser support is IE9+ so IMO it's good enough with graceful degradation (it's only decoration, after all). Plus there are JS solutions as Nicoon mentioned. Can't think of anything else that will work for your situation though. If all the images were going to be the same size and have the same corners, you could pre-make an overlay (i.e. a white square with a rounded rectangle shape cropped out) then overlay that on the image. Perhaps you could limit choice of image sizes/corners and have 10 or so pre-made overlays?
Can you take a screenshot of the MAMP htdocs folder?
dragging a php file into your browser won't work because you are not using your web server to parse the php file - your browser is simply opening that file as it would any text file. If you are running MAMP, look in /Applications/MAMP/htdocs or find the DocumentRoot configured in /Applications/MAMP/conf/apache/httpd.conf 
Awesome CMS. Clean database. Easy to modify, extend, etc. Solid developers behind it. The are committed to modern php standards and development. Multi-site manager is excellent. One client has 40 sites running on one installation.
I appreciate your comments. I do actually see "framework" battles from time to time. But the point I was trying to make is that it's ok to have an opinion and it's ok to feel passionately about which tools you use, but that it doesn't matter what someone else uses, as long as it's what makes them comfortable and makes sense to them.
If you look up over-engineered in the web programming dictionary, Magento is right there front and center.
If you mean the page that comes up when you start the servers, that's because MAMP fires up its own launch page when it starts up, but that's not inside the web root that its Apache is configured to start at. If you just go to http://localhost/, you should get your htdocs contents.
Dealing with MAMP, etc is a nightmare. Use Vagrant via http://www.puphpet.com/
There are certain cases where it does, though. If they're trying to write a real-time process that is mission critical, they probably shouldn't be using PHP (or anything high level) at all. If there are security problems with a tool, that can be an objective concern, not a subjective one. There's also the issue of supporting things moving forward. If someone really wants to write something in x86 assembler and they're extremely proficient with it, that's well and good...but if they get hit by a bus/quit, it's a nightmare to support moving forward. My point is sometimes you have to be considerate of the group/company as a whole. It's not necessarily that a tool is bad per sé, that's not the point. But if the entire team is using Laravel and they're all familiar with it and you like Symfony and decide to install a parallel framework in all of the environments, that's ridiculous.
Haha well there ya go! WP is fantastic at handling such an unfathomable amount of concurrent users and sites all operating independently yet managed by one installation all while just using php.
&gt; Rarely do I see experienced programmers advocating not using a framework at all in a situation which clearly dictates it. You've got to be joking... I see this **all the time**. Why would I use a framework, PHP is already a framework? PHP has all the functionality I need, what's the point of a framework? Etc, that conversation happens all the time.
xampp
+1 for a VM, though I'd suggest installing Vagrant on top of VirtualBox and grabbing a manifest from http://puphpet.com. Couldn't be simpler. Enable NFS folder sharing and add the VM IP to your hosts file, you can code and test in your host machine's editor and browser.
They were private at first for attendees. Naturally now that the links are on the site this isn't necessary... I've emailed one of the guys to get that changed, so hopefully soon they won't be unlisted.
I pretty much couldn't disagree more with this. The whole "opinions can't be wrong" line is such utter bullshit. I've seen people say the most insanely retarded, provably false, objectively untrue, woefully ignorant, and outright dangerous bullshit. They don't get to be taken seriously because they have "an opinion". It's not a matter of "agree to disagree". They're just... wrong. I'm not talking about which framework to use. I'm talking about how you shouldn't use a framework because they force you to change your behaviour. How you shouldn't use other people's components when you can make your own. How you should put javascript as inline events in your HTML. How you should use tables for layouts because it's easier to read. How design patterns should be customised extensively to your needs. People can be wrong. People can be proven wrong, showed empirical evidence that shows their solution is poor. People's opinions can be wrong.
http://i.imgur.com/EvP2Fue.png http://i.imgur.com/qBj252U.png it's bringing up an old index file that doesn't even exist anymore. the default os x localhost index.
Yes, I did upgrade but I did a complete re install of the OS last night (un related, computer was just being slow and decided a fresh start would be good for it) and commented out the line barring Apache from running in the httpd.conf file like I said. Just trying to get MAMP to work.
look at my reply above to /u/andrewry
You don't have to throw away the branding, but you should more clearly delineate the two. Drupal++ or something to that extent. For example, if you can't upgrade from 7 to 8 (i have no idea if this is true), they shouldn't be sequentially numbered. 
also, tried making Document Root */Applications/MAMP/htdocs/index.php/* to no avail. Apache won't even turn on.
2k files 300k lines of code
Most of these came from a 10+ year veteran.
Surely you understand the benefits of writing better code?
With all due respect: bullshit. "right for them"? What the fuck? Ok. I have two options. I can build a bridge with steel and concrete, or with cardboard and pieces of tofu. Hey man, in my opinion tofu is the best choice. And if it's right for me.... This is just nonsense. You don't need to just stand behind "in my opinion" on these things, and by justifying that attitude you vindicate derp. The problem is that we too often let opinion usurp objective facts and proper decision making. And you're helping that.
Of course, but this wouldn't be writing better code, it would be *rewriting* better code which is far different. Not to sound sarcastic, but we don't live in a vacuum. Time and resources are finite and efforts could be better spent. At the end of the day it's all about the end user first and foremost and they don't care how the code is written. Even the developer comes in second to the end user, although it is a close second. Really it comes down to would it be better to improve functionality, features, and other things like that or spend time rewriting large portions of already working code at the risk of breaking backwards compatibility? As the saying goes, if it ain't broke don't fix it. It may not be pretty but it works well right now.
Nope, I read that, and you said: &gt; The different parts depend on each other, and if one fails, you need to dive into the guts of the framework proper to fix it in place, which frequently leaves you worse off than before when it comes to maintainability. So you're saying there that component-base frameworks rely on a core-framework, which is untrue. You like to quote what you said and try to correct me, but I read your article several times. I know exactly what you said. 
Have you considered Wordpress? I hear that's a "framework" now. /s /wrists
I've contributed a bit to it and I'd like to think it's pretty clean and reasonable. Like allsecretsknown said: they try very hard not to do anything weird or confusing in the core.
Ha! I used to work for one of companies who started fork, and contributed in some small things. Weird to see it here, 'cause not a lot of people use it. I recommend this to everyone as well.
After having had to deal with Drupal, Wordpress and Magento, I would rather work with Magento. It might be ugly and a pain but it's so much better in terms of architecture. Wordpress is awful. "global $wp" everywhere *shudders*
True. And my experience has been that if the company takes that stance or buries their head in the sand, move on. You will likely never change it and if you try, you will be resented. Go somewhere that fosters an environment suitable to what you want to pursue.
Thanks for the reply. :)
I assume you are using [imagecopymerge\(\)](http://php.net/manual/en/function.imagecopymerge.php) at some point to apply the bordered image transparency to the original... if this is the case, could you scale up the dimensions of the rounding image to create the rounded corners then resize it down before the merge allowing you to keep the smoother corners? 
Awesome, I was not aware of this newsletter, but it seems I'm in it :D Thanks, subscribing now!
Oh, I left more than a month ago :)
Ah yeah it will default to an index.html over index.php since it's set up that way.
I went with the CMS at the end because it gives more leeway in the future if I ever decide to expand it. To me CMS is a content management system meaning a system to manage _any_ type of content. 
With all due respect, it's not. It's like saying that you run a toystore, but then when I arrive to buy some lego, it just sells Bratz dolls. "But dolls are toys." you cry. "Shut the fuck up and stop wasting my time." I politely reply. :) Here's a useful tip: if your central table is called "posts", your app is probably a blog, not a CMS. Regardless of what you think it *might* do down the track. :P 
I guess I should have named it wp_posts and it would have been all good. My mistake. :) Other than the domain though the site and everything around it specifically says "A Minimal Blogging Application.". I'm not trying to trick anyone on what it does or doesn't do. 
There's some core security issues in older versions of WordPress though. You really should look into upgrading more often. If WordPress.com can upgrade 50 million sites, then you can do it too. ;)
Very interesting - looking forward to reading it. Medium's big, readable typography kind of fails for this type of article. It would also be awesome if there was some kind of section navigation that follows me down the page, since this is the type of article where I want to quickly jump around, and scrolling and visually acquiring the headings is pretty rough.
+1 for using Vagrant + PuPHPet 
To counter kasp3rito's opinion, I'm building an Sf2 site using CMF and I really like it. The various components are well thought out and very flexible. But I do highly recommend picking just the components you need for your use case and integrating them yourself. I personally don't like the fully integrated stack. But that's the very purpose of a CMF. The F stands for framework. It's not a complete CMS. Pick your components and roll your own.
That video just made me realize that ircmaxwell could kick the living shit out of me in a real fight; so I know if the occasion requires it, I will only shit talk him under anonymity.
Not so much, you could have just had apc installed when you installed apcu, both pecl installs, both on remi's repo I think too ... seems like that could happen quite easily ... 
God damn you are dense. 
Fun fact: I _wanted_ to reply to this and say, cool, but the C version will perform better ... but actually, I _cannot honestly do that_, because the margin is so small it isn't worth mentioning, other than to point out that actually the margin is not so considerable, and you're probably just as well coming up with a nice clean way of doing it ... You wouldn't expect that, I didn't expect that ...
Added to my list of things to play with. Thanks for what looks like a very detailed write up.
Seconded and [LINK](http://processwire.com/) Clean, fast, simple and capable, you can have it all. Became an instant favourite when I built my first large site with it (2000+ pages). By far the most flexible CMS I've ever come across (whether or not PHP).
Sending messages and changing names. Feature-wise it's nothing compared to say IIRC or iMessage. It's not something typically built in just PHP so the boilerplate is substantial compared to something like Node/Socket.io. I think that's what makes it look over the top. Still fun to do in just PHP though... :)
You're welcome.
There is a book format, if you're into that sort of thing: https://leanpub.com/laravel4cookbook
He just needs a hug. The attitude, sarcasm, quoting out of context, weasel-wording and apparent fear of 'being wrong' reeks of insecurity. Paul, if you are honestly feeling misunderstood/misread and struggling this much to convey your thoughts (as is ultimately the responsibility of the author rather than the reader) perhaps avoid publishing them. Otherwise, go ahead but don't cry foul when your peers think you're talking out your ass.
Whats wrong with CodeIngiter?! Imo it's a very good product and it's easy to learn. How do you describe a serious programmer?
Bearing in mind that all post variables are either strings or arrays, you should protect functions that will throw a warning if they receive an array: if(preg_match... Becomes if(is_string($_POST['key']) &amp;&amp; preg_match...
This is related to base64 encoding. In the base64 encoding, it is part of the standard to include at most 2 "=" signs for padding purposes (and the last character before the equal sign may be incomplete). When generating the hash, the salt is base64 decoded, hashed and has its hash appended to it, then they get base64 decoded. The padding concerns are now moved to the end of the string and it appears 0 "=" signs are used since it appears no padding is needed. Someone else answer what those 2 dots are for near the end as I have no idea about those :D http://en.wikipedia.org/wiki/Base64
Got it, so its a buffer... and truncation. The dots near the end are from the example. sometimes there aren't dots (its just the chars that appear) So is there a reason I can't just store 1 char for the "salt" and when I grab the salt and hash do a substr and append? 61 chars seems like its better to store than say 89 chars... I could actually just store the hash and salt in one char(61) right?
CI, as good as it was, is practically abandonware. I wouldn't recommend it to anyone either. http://ellislab.com/blog/entry/ellislab-seeking-new-owner-for-codeigniter
So not a fan of WP or EE. WP's codebase is from the depths of hell and just about every serious WP developer/house I have spoken to is hell-bent on creating those Google/FB killers in just WP. It makes my head spin. EE, as mentioned, is CI and CI, as mentioned, is old as an old thing.
"At the end of the day it's all about the end user first and foremost" Developers drive adoption (beyond wp.com et al.). It takes angry developers, before angry users, to slay a giant like WP. I hope it doesn't happen, but there's always that stinky code lurking...
That's incredibly shortsighted. Better code = easier, faster, more enjoyable development = a better product = more satisfied users.
&gt; evoke some discussion FTFY
I believe the evolution is quite natural. Back in the days PHP was basically a language with which you could build a website relatively fast, with relative ease and a good functionality. So people threw together some files, made it work and thats it. Then someone noted that they'd done the same stuff with very minor variations over and over again. Hey, let's abstract all the common stuff into a framework. That seems like a good idea. So you have your framework and you actually use it, and you put it out there and other people use it and you start noticing that you have to maintain it, or, even better - other people help you maintain it. But they have totally different styles then you. Well, that sucks. How are you supposed to work with code that is all but unreadable? Along come PSR-1 and PSR-2 (and all the other codestyles out there). Now you have a common coding standard, so you can more or less read the stuff from a programmer in Ucraine just as well as one from Austria. But your codebase grows, more functionality is added all the time, and the interaction between these modules can create elaborate and subtle bugs that are hard to find. You know what would be great? If we could somehow measure if our software is still working as expected. What do you say? "Unittesting"? Well, that sounds like a splendid idea, let's do that. So you write tests and tests and tests and you find that you can't really test your flawurble class (or as we call it ZEND_ISL_STUFF_I_MADE_UP_ON_THE_FLY_FLAWURBLE) without also using your shoriuken_class, your brosWillBeBros_class and also your protocolEverythingClass. That testingframework (ha!) you are using has this great feature called "mocking", where you can replace a class with a virtual class that acts like the class but does nothing, but you create your classes right inside other classes. So you rewrite your stuff, so that all the needed classes will be "injected" (now, doesn't that sound like you are a doctor?), and voila, you can mock them and your tests become easier. Then someone comes along and says "Yeah, that injecting is all nice and good, but it's all over the place and wouldn't it be great if we had one point where that was done, let's do it from something we'll call a DIContainer?!" ...and so on and so on. **TL;DR:** it evolves because as software grows it becomes harder to maintain unless you use some standards.
I'm going to get downvoted for saying this I'm sure, but the PHP "world" is a constant battle between people who want to write PHP but want it to be more like competing languages that were truly designed from the ground up with many of the features currently bolted on (OO, exception handling, Unicode support), and those who want PHP to basically remain as it is, a sort of scrappy "get it done" language that does not distract itself with dreams of being anything more. This fundamental debate takes place within the circle of core PHP maintainers and contributors and is mirrored by authors of PHP software as well. The designers and authors of these frameworks tend to fall into the first camp while the users of the frameworks fall on both sides of the fence. PHP is really kind of a weird language and community that way.
Fixed, thanks!
Disclaimer: I am not an author of anything big. but here is what I think about your question. &gt;Is this simply because we, as a community, didn't do our homework properly on software design? Or was there just not demand for them? I think the demand part together with low barrier of entry for php, was a big factor. Clients of php want the projects/updates done fast. If you spend time meditating the perfect design for your work, a kid just out of college will be finishing his quick solution for client and getting paid for it. So unless you are obsessed about the quality of the code you write, the incentive for making durable solutions in php simply didn't exist in the past. Now clients seems to be more concerned about the quality of the code. So I think the situation will improve quickly in the future. 
PHP allows you to be sloppy with virtually no issue. Unfortunately this instills some very bad coding practices in PHP devs, many of whom have no experience in other languages, or on-hand guidance from more experienced developers. As frameworks such as Symfony 2 become more prevalent, the quality of code will be forced to improve. That's not to say bad code cannot be written when using a framework - but rather than the bad code itself will be more isolated and easily fixable than having a clusterfuck, let's see how much we can do with one 20000 line file approach. PHP devs can be lazy. And when laziness is an option, most of us will choose it. 
The author have point. OOP is not always better ... you can end up with a lot more bloated code with it, imo functions are easier if their amount is reasonable. Also pure functions have other advantages 1) they are short to type 2) they are predictable (if they don't rely on some global state) 3) they consume less resources - in oop you must make an instance of the object which is additional overhead 
That true but the github community is still improving the framework right(the latest commit was a days ago)? I think CI 3 will be released somewhere in 2014(https://github.com/EllisLab/CodeIgniter/blob/develop/user_guide_src/source/changelog.rst).
Something is off here. A bcrypt hash consists of a hash identifier, the work cost, and a 160-bit salt value (encoded as 22 characters) followed by the hash value encoded the same way. The encoding for the salt and hash is NOT base64. It's similar, but different. The dots in the string are simply part of the encoding. Where are your salts coming from? It's generally best to allow the hashing library to generate a salt for you, as it'll select a secure value and properly encode it. If these are coming from a library, your library is broken. 
I worry about these sorts of benchmarks. PHP programmers are frustratingly prone to premature optimisation as it is. Seeing decisions made based on benchmarks rather than productivity, maintainability, platform maturity, community support, etc, is a significant risk. In particular, I can see a number of cretins just looking at that top speed for Raw PHP and using it as ammunition for their "here is why I don't use a framework" derpery.
You are over complicating and prematurely optimizing. You shouldn't do that. Just store the hash under one VARCHAR(255) column and everything's going to be just fine. And if you ever want to change the password hashing algorithm, you won't even need to touch the database. That is part of the purpose of crypt() and the string it produces.
Idempotence in HTTP should have to do with how the request is handled on the server-side, not what response it should give. An HTTP response isn't only about the code and the content anyway; it also consists of headers including ones that may change depending on what time the request was made. Would you for your HTTP server store in your local database the exact HTTP response header by header just so you would adhere to "idempotence" if the same resource is requested by DELETE? I didn't think so. Knowing the fact that DELETE is idempotent is great and it should be the client's responsibility to understand. That being said, I think it's fine to respond with 404 if a resource to delete wasn't found. It is extra information that the client may make use of if he wishes to.
Thank you so much. This was incredibly helpful! Doing the install today!
This StackOverflow answer will explain the effects you're seeing: http://stackoverflow.com/questions/16280194/php-crypt-for-password-hashing-blowfish-produces-weird-output/16280909#16280909 In short, it has to do with the fact that it doesn't use the full 22 character salt, but only 2 bits of the last character... Also, why are you setting a salt manually? You really shouldn't be using `crypt()` directly, as it's [pretty easy to screw up](http://blog.ircmaxell.com/2012/12/seven-ways-to-screw-up-bcrypt.html). Instead, it's generally recommended that you use the [new 5.5 API: `password_hash`](http://us1.php.net/password_hash) (and related functions), or the compatibility library [password_compat](https://github.com/ircmaxell/password_compat)...
I would HIGHLY recommend you use a library. If you're not on PHP 5.5 where you can use the new [password API](http://us2.php.net/password), then I suggest /u/ircmaxell's [password_compat](https://github.com/ircmaxell/password_compat) library.
Can't use password_hash since PHP 5.4 is all I have access to. Btw I did read your article on mistakes earlier but some of it is still a bit over my head.
additionally what I figure you're probably the best-equipped to answer... it is *normal* that the salt is appearing as part of the hash though, right?
You *can* use password_hash. The compatibility library supports 5.3.7+, so you can use the PHP implementation that I maintain for it (linked in the original answer). It's a single PHP file (and trivial to install with or without composer).
That's the entire point of the `crypt()` output format. That you don't have to (nor should you) store the salt separately. In fact, it's designed so you can do: if ($hash == crypt($password, $hash)) { In your verification function. There's more to it than that (you want to prevent leaking timing information, check for specific errors, etc). But there's no need to store the salt separately. Not at all.
awesome that's what I figured. I'm trying to understand what I'm doing even if I do (and likely will) implement your library for example.
* Edit: wrote a more thorough response on [my blog](http://evertpot.com/idempotence-in-http/). * Edit2: [A thread on the offical http mailing list, by a microsoft engineer who asks the same question, but subsequently gets corrected as well.](http://lists.w3.org/Archives/Public/ietf-http-wg/2007JulSep/0363.html) The blogpost starts arguing against itself half-way through, probably because of new information. Makes it a confusing read for anyone who's actually interested in the topic and answer. The short version: * Delete is idempotent according to [rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616.html). * Idempotence means that doing 1 request, has the same end-result as doing the same request multiple times in short order. * With end-result we're not talking about the HTTP response. The end-result is the server state. * So yes, this means that the first request will probably return HTTP 200 or 204, but subsequent requests 404 (or 410). * This is identical to a first PUT returning 201, but subsequent identical PUT's 200. This may all seem pretty obvious.. so why is this relevant? Say if you have a resource called : /blogs/last, which always returns the last blogpost. If you call DELETE on it, you'd effectively remove an item from the stack. Calling DELETE more than once would presumably keep deleting the last blogpost. This is a violation of HTTP. The reason for this, is that if say your network goes down, and an initial DELETE fails with a 503 or 504, it may be hard to know for sure wether the delete succeeded. In those cases you can always do an identical request and never worry that running the same two requests will alter the server in a way you didn't expect.
I suspect the primary argument is that we get features incrementally. OOP in PHP4 was very limited, we didn't get public/private/protected until PHP5, late-static-bindings came later, followed by traits. Presumably, a designed language likely would have all of that from the beginning. 
I think the thing that has made me lose confidence in it is that they announced they wanted to drop it before releasing 3; which was supposed to be around the corner. That doesn't leave it in the best possible spot IMHO.
Absolutely not the case. I have read your article and know exactly what you were intending to portray, but it didn't work. You're just not getting it, which is a shame. Obviously linking to was not in itself an issue, but the context. You're smart, you know about context. Do I really have to repeat myself? You are responsible for your post, and you consistently give people the wrong idea, with this article and plenty of others. That whole SF2 v Aura one was fun. The whole "rape apologist" thing wasn't very fun either, but in your defense she was a lunatic. If a substantial number of people continue to "read you wrong", your writing style is probably poor, or at least not working very well. I've certainly improved my writing style since I started having people misread my points. Don't take it as an attack, take it as an opportunity to improve. A LOT of people get annoyed with your articles, and if it is unintentional then it's SO EASY to resolve. If you'd had just said: "Aura struggled with this too, but I do X, Y and Z to make this less of an issue." Or added a summary. Or explained your points better. Or didn't reuse jokes out of context without a nod to knowing its a joke. Any of that would have made your article a better article, but you just ended up pissing everyone off by writing an article that READS like a "fuck theirs look at mine" article. That doesn't impress anyone. /done
I just installed it yesterday using git clone and you're right, it took me a bit to find the page again. They should put a big link at the top of their download page. Tiny GitHub link from this page: http://www.fork-cms.com/community/documentation/detail/installation/version-control
&gt;With end-result we're not talking about the HTTP response. The end-result is the server state. So yes, this means that the first request will probably return HTTP 200 or 204, but subsequent requests 404 (or 410). I don't agree with you. DELETE is idempotent, which in this context means that the end result for the first and subsequent identical requests are always the same (the resource having been deleted). This is implied by the RFC: &gt;9.7 DELETE &gt;The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location. &gt;A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity. &gt;If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. and further corroborated by literature: &gt;Idempotency of DELETE &gt;The DELETE method is idempotent. This implies that the server must return response code 200 (OK) even if the server deleted the resource in a previous request. -- RESTful Web Services Cookbook (2010), 978-0596801687
&gt; I don't agree with you. DELETE is idempotent, which in this context means that the end result for the first and subsequent identical requests are always the same (the resource having been deleted). This is implied by the RFC &lt;snip&gt; This is still true in my example though. The second identical DELETE should return a 404, but the resource is *still deleted*. The server state after request #1 and request #2 is the same. The second request technically fails (with a 404) because the resource is already deleted, but this fulfills the idempotence requirement. &gt; The DELETE method is idempotent. This implies that the server must return response code 200 (OK) even if the server deleted the resource in a previous request. This is absolutely an incorrect statement, and must have been a misinterpretation by the author. To grab PUT as an example again for idempotence. With PUT there is also a case where the same request can be repeated, but returning different HTTP statuses. If we supply an If-Match header with an ETag, and the first request succeeds, the ETag will change and thus the second request should fail with 412 Precondition Failed. This is the expected behavior, but it does fulfill the idempotence requirement. The server state after PUT request #1 is identical to the server state after PUT request #2. Request #2 failing is irrelevant to this. 
Don't confuse the 'no side effects' requirement with 'idempotence'. The term 'no side effects' is only used in relation to the safe methods, such as GET, HEAD and OPTIONS, but this language is not used in the specification in relation to DELETE and PUT.
Of what I can think the easiest would be to create a [cgroup](https://wiki.archlinux.org/index.php/cgroups) for nginx and set there the overall cpu priority.
Under "/ipconfig all" you should see a VirtualBox Host-Only Network. My ip for that network is 192.168.56.1 But if you can ssh into it, doesn't that imply that the network works? Can you ping it? If so then maybe your web root isn't set up right? Probably a bad setting for the doc root maybe? For my generic box, I put the vagrant files in (example) c:\www\vagrant Then for the source I use "../" that way it uses the parent dir as the web root and all my c:\www files are available in the VM under /var/www 
It's probably too mainstream. 
I am not "feeling" anything there. I am *telling* you that you have misread it. Others have read it correctly, and feel no need to comment further; the fact that some will misread it is a natural occurrence, but they should be prepared to receive corrections from someone who knows the true nature of the writing.
&gt;The term 'no side effects' is only used in relation to the safe methods, such as GET, HEAD and OPTIONS, but this language is not used in the specification in relation to DELETE and PUT. Uh, yes it is: &gt;Methods can also have the property of "idempotence" in that (aside from error or expiration issues) **the side-effects of N &gt; 0 identical requests is the same as for a single request**. The methods GET, HEAD, **PUT and DELETE** share this property. [9.1.2 Idempotent Methods](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html )
&gt;The second request technically fails (with a 404) because the resource is already deleted, but this fulfills the idempotence requirement. It's not a failure at all. The effect of the initial request is still in play, i.e. the resource is no longer available. A failure as described in the RFC would be not being able to render the resource unavailable. &gt;This is the expected behavior, but it does fulfill the idempotence requirement. Indeed it does. The request is asking for the resource to be replaced if it matches the E-Tag. I'm not saying that all the responses should be identical, though. What I was arguing was that a DELETE statement shouldn't be returning a 404. Big difference.
I can ping it and I see it in my ipconfig but it still says firefox cant establish connection to the server, Ill try changing folders around
HTTP standards aside am I the only developer that prefers to keep API calls to GET and POST requests for sake of ease?
Read the above edit.
Response to your edit. Are you saying that subsequent identical DELETE requests **MUST** or **MAY** return the same 2xx status code? If your answer to your first question is yes... * Should any DELETE to a non-existant resource return a 2xx status code, or: * Should only DELETE requests to resources that *at one point* did exist return 2xx ? * What if both requests specify `If-Match: *` ? * What if both requests specify `If-Match: "some-etag"` ? 
tl;dr what should a successful DELETE request return?
&gt; copy things from the page (not sure if it is possible to count this) Should be possible, websites have been using JS to add "copied from example.com" to the end of your copied text for awhile now. All you have to do is instead of appending this text, just call some AJAX that sends this data to the server. 
in the vagrant virtual machine try `sudo lsof -i :80` and verify that apache is running on port 80.
Can you elaborate on what you mean with unqualified here? Did you mean unconditional? And did you mean SHOULD as in 'could also not', or did you actually mean MUST ? 
Hi! Thanks for using PuPHPet! If you're getting a 404, that means you're hitting the server, so that's a good start! Do the following: $ vagrant ssh $ cd /var/www/dev $ ls If you do not have a `/var/www/dev` folder, create it. If you do not have an `index.html` or `index.php` file within `/var/www/dev`, create it. Now try reloading your browser.
If firefox can't establish a connection, sounds like apache isn't running or not running on that port. Also, looks like you setup a virtual host as local.dev, have you updated your hosts file to map that to your IP? Then in your browser, you can try loading http://local.dev/
Take a look at the api for string, integer, array, and float. An OO language would have had an OO API from the start.
I happen to be an author of a framework that believes they shouldn't change old functions and no deprecation should ever occur in PHP but I still want more awesome language constructs that allow me to do new things. On that note. My dream would be to be able to mount a file (or partition) truecrypt style and be able to access a partition system inside of it with common file systems like FAT, NTFS, EXT2/3, etc. But all from inside PHP! 
I've done some searching around and I think that apache/php isn't even installed, Ill try to reinstall the whole box
No you're not. In fact, you're the majority.
if you have an /etc/apache2 directory, then apache should be installed, otherwise something went wrong. Instead of reinstalling, try "vagrant provision".
This is why we need to keep humanities majors around. What an interesting philosophical question. "When the spec says that doing delete is idempotent, and idempotent means 'each time you do the same request you get the same end-result,' what, precisely, is the 'end result?'" 
I disagree. The second identical DELETE must return 2xx. 4xx is an error code. 4xx does not necessarily mean that the resource is deleted (there's not enough information to determine if the resource was present or not) In a separate issue, I believe that a programmer SHOULD NOT give a possibility like 'DELETE last' because it breaks the idempotence of DELETE (if the server state is the end result then you're removing something from the server). Oh I see what you're saying here: &gt; The server state after PUT request #1 is identical to the server state after PUT request #2. Request #2 failing is irrelevant to this. and that's a nice clarification. I'd prefer a 200 response or a 204 response. A 4xx response would imply to me that something went wrong, and I'd have to follow it up with a GET to see if the record was actually deleted.
Not sure whether to upvote for agreeing with sentiment or downvote for tone. Staying neutral!
So let me ask you as well: If the second identical delete also returns 2xx, does that mean that: 1. Every DELETE on any non-existant resource must always return 2xx, or: 2. The server must maintain a list of resources that have previously been deleted, so it knows if it should return 404 or 2xx? Also: If you're saying that the second delete MUST return 2xx, what if the request had If-Match: "some-etag"? For the record: I pretty much spend all day in HTTP and HTTP-related specifications, as I'm the author of a popular WebDAV system and do a lot of work with REST api's. I'm absolutely confident you're wrong, but i want to politely point out why. If you changed your statement to "the second delete MAY return a 2xx", I wouldn't be so sure of myself.. but since you say 'MUST', I know for a fact you're wrong.
Even though it's ultimately irrelevant to what you're trying to tackle, there are cases where OOP is not appropriate. There is some overhead involved with class loading and instantiation. It's exceedingly rare where that can be a problem. For the most part with what you're doing (and likely to do in the near future), OOP all the way. Look into the MVC (Model-View-Controller) design pattern. Try to understand the premise behind it before you dive into a framework or you're likely to completely misuse it. If you get stuck with something or have any questions, post them to /r/learnprogramming or feel free to PM me. Believe me, it's a worthwhile investment to learn this stuff and anyone (yourself included) who has to work with it in the future will thank you.
Heh....damn CMS hipsters :-)
Here's the relevant docs: http://redis.io/topics/persistence. If you're worried about data getting lost during a crash, enable AOF and aggressively sync to the hard drive. You will still get good performance and the same data persistence guarantees as a traditional SQL database.
Oh my, people quoting 100 year old RFC standards left and right without any argument of their own. Anyways, ''Violation of HTTP' thing is silly. It's more of a bad API design as /blogs/last is not an end-point that should support DELETE. I agree that blog post in question is ridiculously hard to follow, for API design you can either quote RFC's all day or simply define static resources that can take DELETE and return 20x if they were deleted or do not exist because the API client will not care if resource was 'really' deleted or does not exist and was deleted. Typical API flow is that in order to delete something you must obtain data that you are looking to delete. TLDR: This is not HTTP specification issue, this is an API design issue.
Ah, but that's a misinterpretation of 204, and now it also makes more sense where you're coming from. 204 doesn't talk about the resource, only about the response body. If your response body (ANY response body) normally would return 200 OK, but a Content-Length of 0, 204 is used. 204 No Content does not mean the requested resource has no content, it only means the response body has no content. 204 is not an error code.
You spending time working on HTTP specifications or API's does not really make you right by default. In any /properly/ designed API DELETE will return 20x even if resource does not exist/was already deleted. Your API is performing an operation that user requested, if user wants to delete XYZ and it does not exist we succeeded at users request because the resource does not/will not exist. Returning 404 makes absolutely no sense in this scenario. 
I did not mean that 204 was an error code. 204 is a "success" code. 404 is an error code and MUST NOT be used when the end-result of a DELETE is the same as a success. I'll take what you said about 204 being not-related-to-actual-content though. I wonder if, hm. I wonder if what you're doing (WebDAV) is generally different enough from, say, a blog engine, that "deletion of a file that doesn't exist" COULD be an error. I mean, if I say "hey delete the file that's index.hmtl" ... I imagine that should give me a 404 and not a 200. Maybe you should return the object in the response body (not really a serious suggestion, although parallels the sql idea). Then the length of the content is a clue to the original status. 
If you decided that this was the better design for your use-case, I can't argue with you on that. More power to you. However, you are in a thread where correctness according to the rfc is discussed, your opinion is irrelevant. And please note that my `DELETE /blog/last` example was something I illustrated as a violation of HTTP, and something that should not be done.
Well there is simply absolutely no language in the RFC's that would suggest that a method like DELETE on a non-existant resource should return anything else but 404. And why should it? For the consumer's perspective, it will get either a status-code that tells him that the resource was successfully deleted, or that it didn't exist. The end-result is the same. The end-result being: the resource does not exist after the request.
Which rules do you disagree with in particular?
http://stackoverflow.com/questions/2342579/http-status-code-for-update-and-delete "strictly speaking, a DELETE ... for a request that does not exist is not a valid request" (and thus Daniel Vassalo says it should be a 404. I like the one true scotsman reference though :)
I'm going to fall back on 200 / 204. 204 being "no content" analogous to the sql example- "yes I correctly processed your properly worded request, but the thing to delete has been deleted." This is also similar to 200/204 for PUT requests. Citing this: http://stackoverflow.com/questions/2342579/http-status-code-for-update-and-delete and http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html What an interesting question! Thanks for bringing it up!
I also think the answers there are wrong... I found this thread on the official mailing list, where a microsoft engineer asks the same question, but then subsequently gets corrected: http://lists.w3.org/Archives/Public/ietf-http-wg/2007JulSep/0347.html
I like that the first answer was "it doesn't matter" and down the rabbit hole someone mentions 410. I also like that one of them says "404 is what's used in WebDAV land" like you are. I think you should do what makes sense to you, and end users using your WebDAV API will have to read the documentation if they experience "weird" results. :) 
Request IS valid, since API is handling it for you... 
That's the actual URL. The other submitter made the effort to remove/change it.
Is not valid, because the URI does not exist. GET /posts/112 ==&gt; 404, post 112 not found DELETE /posts/112 ==&gt; 204, - does not make sense, why should this one return a successful code?
Thanks, great discussion! 
Well, I consider an API to be something that should not be restricted to a protocol. HTTP is a great protocol, but it has its flaws. I personally believe that protocol should never be what defines how you build your API. An API is simply a language, set of parameters that is pushed down a pipe and getting a response in return. So why should it even matter how the method of transportation is described? An API for me is just that, an application programming interface. It is not the protocol. I can make the same API handle as many protocols as I like. And in this way, HTTP features such as PUT and DELETE especially serve no purpose - parameter is just a parameter, regardless how it is defined. If I want to delete a user, my API call will be 'user-delete' or 'userDelete' and I can send it over GET or POST or not even through HTTP and use perhaps an internal call with PHP instead. It does not matter and it should not matter. This approach also allows you to easily test your API just over a URL or test it universally, protocol-independent. Restricting your API with a protocol - such as the case with REST - serves no purpose for me. HTTP is a great protocol for API communication, but HTTP should not define how API behaves.
http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html 10.4.5 404 Not Found - The server has not found anything matching the Request-URI. Thus, 404.
No problem, let me know if you need help digging up ancient RFCs. Maybe bring up the HTTP/1.0 specification and claim DELETE is breaking it.
For what it's worth. The same language is in HttpBis, which will be released as modern rfc's and used as the basis for HTTP/2.0. 
Nope. I get a 301 (moved permanently) to the https version when I visit the http link. Firefox. No redirect when I visit with Chrome. 
If you are going to quote the RFC, quote the right one, i.e. http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html: 9.7 DELETE The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location. A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. 
I like the syntax over the older assert syntax, and throwing an exception is nice. I'm wondering why anyone would care though. I rarely see assert used in frameworks or libraries, although I did write a long [Medium post on using assertions](https://medium.com/on-coding/91a066812241), and how useful they can be.
Exhibit A - it doesn't feature in the core library design at all, which is all procedural.
&gt; didn't do our homework properly on software design? Many didn't know they had homework to do in the first place, they just started writing code.
You will likely use his library, not implement it.
&gt; They cannot deploy assert. Of course they can. &gt; The whole point of an assertion API is that you should be able to remove it's impact during production No kidding! Everything you think you just schooled me on is mentioned in the very long post I linked to. &gt; the impact of using assert() is ever present, even during production. That impact is extremely negligible, and the statement from the RFC, "but the actual call to assert cannot be optimized, dragging down production considerably" really doesn't make any sense, because you would have assertions turned off in production, and optimizing code isn't an issue in development. Like I said, I prefer the syntax of expectations over assertions, but no one uses assertions, even though they should, so I don't see a new implementation gaining any real traction within the community.
Isn't this kind of the same thing as bragging that you've never had to read a book after college?
I'm not bragging about it. It's more like saying you've been a professional writer for 10 years and have never made your own ink. It just isn't a requirement or even a general expectation these days.
the analogy is not comparable. the publishing analogy doesn't work because there are no competitive advantages to producing your own medium (paper, ink) as very few consumers would likely see any value added from that process. a **major** difference in linux-based systems is that developers have provided everyday users the *option* of compiling their software directly from source. windows developers don't do this. mac developers don't do this. a better analogy would be a restaurant allowing their customers to cut their own steaks from a butcher's corner in the back. one of the biggest problems in software development, imo, is how bloated and inefficient applications have become because they have to simultaneously work within *all* the most popular hardware/software configurations. the process to make these programs compatible has generally always been poorly planned and managed, especially as consumer expectations for most performance-related issues shift more and more to blaming hardware instead of the junky/clunky software. the advantage of customizing things on your computer to ONLY meet your computer's needs is tremendous. very often the cost-savings to speed and performance is noticeable (especially when the program relies ENTIRELY on YOUR own config file). if all you're doing is apt-getting things on your computer, I question what advantages you find with linux over windows in the first place.
I deploy all my asserts; if an assertion fails it's more often in production rather than in tested development code. Is there even a reason to worry about performance, a few comparisons are nothing. The whole concept reeks of unnecessary optimization. 
This feels like something I always needed!
Do note though that error codes don't necessarily mean that something bad happened. It makes a difference what error code you get for what type of request. In the case of DELETE, the 404 error code specifically should be interpreted as nothing bad happening at all, it's just informing about the fact that the resource was probably already deleted. Now a &gt;=500 error code would mean something bad happened.
Claims one side of the argument. The other side says respond with 404 if there was nothing to delete :)
 &lt;?php // php script to send emails $to = 'some email'; $message = isset($_Post['message']); //&lt;--- Here $header = "From:" + isset($_Post['header']); $subject = isset($_Post['subject']); $name = isset($_Post['name']); if (isset($_Post['submit'])){ mail($to, $subject, $message, $header); } ?&gt; You didn't tell us what exactly wasn't working, but a quick eye scan showed that you have, at least, two (EDIT: three!) errors. **First**, the global variable for POST requests is $_POST Not $_Post **Second**, to get the value of the fields sent by POST, you have to do $var = $_POST['name']; And not $var = isset($_POST['name']); Because in the second one, the value assigned to **$var** is not the content of the field, but rather a boolean that is True if the array *$_POST* has a key *name*, and False otherwise. What you did with **isset** is not *bad*, it's just meant to do something else. You use isset to know if a variable is set. Because if you try to access a variable that isn't set, then you will (or you should!) get an error. What you did, for example, is correct in the case of $_POST['submit'], because you don't care the value of that field, you only care that it is present (i.e. the array $_POST has a key 'submit') **Third**, you are using the addition operator to concatenate strings. That is wrong. It's understandable if you come from other languages, but keep in mind that PHP concatenates strings with a dot. So this is wrong: $header = "From:" + $_POST['header']; And this is right: $header = "From:" . $_POST['header']; Here is your code, fixed. Note that here you are assuming that the values are always present. I put it like this only because my goal is only to fix the code to make it work, but you should definitely never assume the values are always present: &lt;?php // php script to send emails $to = 'some email'; $message = $_POST['message']; $header = "From:" . $_POST['header']; $subject = $_POST['subject']; $name = $_POST['name']; if (isset($_POST['submit'])){ mail($to, $subject, $message, $header); } ?&gt; Chances are, if my assumptions of your code are correct, you will get errors. Undefined variable errors. Here's an improved version. From looking at the code I can tell with 99% certainty that the code is present in the same file that renders the form, which is bad. Also, you declare the variables outside of the *if* block, which is even worse. &lt;?php // php script to send emails if (isset($_POST['submit'])){ $to = 'some email'; $message = $_POST['message']; $header = "From:" . $_POST['header']; $subject = $_POST['subject']; $name = $_POST['name']; mail($to, $subject, $message, $header); } ?&gt; There we go. Now, that code block will execute if and only if the 'submit' key is present in the $_POST array i.e. the user submitted the form. From that certainty, we assume (although we shouldn't) that every other value is present EDIT: I just found another error. You are concatenating strings with "+". Strings are concatenated with "." in PHP
There are plenty of advantages to using Linux over Windows. On Linux, I'm not constantly being attacked by utility software that thinks it has the right to interrupt me whenever it feels like it. I don't have five different updaters competing for my resources while a virus scanner is bashing around like a drunk, and I don't have to wait 10 minutes to shut down because Windows can't figure out how to apply updates safely on a running system. On Linux, I don't have to deal with this disconnect between how filesystems work on Windows versus how they work in the rest of the world. As a web developer, it's nice to be able to copy files to/from a website without worrying about weird conflicts appearing with filename characters, symbolic links, file modes, etc. On Linux, all of my software gets automatic updates through a single interface that I can control on my schedule. It's also super-easy to find and install new software, and pretty much anything I've ever been interested in downloading has been available through that channel. On Linux, when my environment's software maintainers decide that everyone is using touch screens now and "usability" means hiding things from the user (see: Windows 8, Ubuntu Unity, and Gnome), I can switch to a different product within a day (yay Linux Mint!), while keeping all of my personal files/directories and application settings identical to how they were. On Windows, I could... downgrade... for a while... and pray.
A lot of those problems can be solved by better understanding how to use the windows environment. You did list the advantage of your 'free' software being updated, but I would argue that it's usually a disadvantage to the average linux user (of course, that comes down to preference). For the most part, it updates packages whether you actually need them or not. Windows has an updater as well, and many programs notifies you when you need to update. &gt; I don't have to deal with this disconnect between how filesystems work on Windows versus how they work in the rest of the world do you mean how file systems on webservers work? the directory structure is virtually the same with very few differences (sym links, mounting, etc) and the web servers themselves, as well as databases, PHP, et al. are pretty much cross-platform, and the software (browser) that interprets the javascript/html is actually on the clients machine and is therefore server independent.
&gt;Now, my question is, what exactly is said "client"? The browser, and client disconnect happens when you push the stop button in the browser or when you close the browser. This can be used in scripts where anything has to be done to completion, regard less of whether user disconnects or not. An example where this might be useful is payment processing. If user presses the pay now button (or the last button that needs to be pressed in a payment process) and closes the window. You may want to complete the whole process even if user closes the window. You may have to keep this in mind, from the notes section of php.net PHP will not detect that the user has aborted the connection until an attempt is made to send information to the client. Simply using an echo statement does not guarantee that information is sent, see flush(). You can read more about this http://www.php.net/manual/en/features.connection-handling.php
I think Control+C from a terminal will immediately ends the script no matter what.
This is a silly suggestion and might not even be the cause, but did you put &lt;?php session_start(); At the top? Otherwise I don't have an idea of what's happening, but I would consider cleaning up that mess. Why not do this? Its cleaner &lt;input type="text" name="whatever" value="&lt;?=$_SESSION['views']?&gt;" /&gt;
I grew up on DOS, and I used Windows as my primary OS from 3.1 to XP. I tried Linux out of curiosity and found it to be a much more user-friendly environment in general. I don't think this is a matter of not being well enough acquainted with Windows, it's more about the differences in the software ecosystems on each platform. Specifically, the kinds of things people expect and are willing to tolerate on each system. If a Linux app behaved like most of the Windows apps do, people wouldn't put up with it. Regarding filesystems, Windows filesystems are just a mess. When you consider Windows, Mac, Linux, and BSD, only Windows uses case-insensitive filenames, only Windows uses backslashes for directory separators and not for escaping, only Windows has the "C:\" stuff rather than mounting within a directory structure, only Windows is different in how file permissions are managed... Windows has been attempting to become sorta more POSIX-compatiblish since XP, but it's just patchwork. The fact remains that if you copy a directory from Linux to Windows and back, you're going to at least have metadata loss, and some files may fail to copy entirely, due to limitations in things like filenames. I can happily copy files back and forth among Linux, Mac, and BSD systems, but if I have to do something with Windows, well.. better tarball it!
&gt; A thread on the offical http mailing list, by a microsoft engineer who asks the same question, but subsequently gets corrected as well. That's incorrect. The standard specifically talks about the success of the request. You cannot DELETE something that does not exist, making the request a failure.
I did do that, yes. Edit: Tried what you suggested, this is what showed up in the box. http://i.imgur.com/VhhMi5m.png. Perhaps its an htaccess thing? Keep in mind this is an HTML file the form is in. Edit 2: Changed htaccess, still the same thing.
&gt; Your request was still properly handled, you asked for an operation and it was performed. That's false. I requested that something be deleted now. 204 says exactly that. If that's not the case, 204 is incorrect. If their is nothing to delete, than I'm attempting to operate on a resource that does not exist. A GET, which is still idempotent, would return a 404 (or 410) on something that was missing, even if it used to be there. A 204 on a subsequent DELETE request explicitly lies. A 404 or 410 do not.
Seems like you have short tags disabled. Ok, not a problem. Do this, just to be sure: &lt;input type="text" name="whatever" value="&lt;?php echo $_SESSION['views']?&gt;" /&gt; If it still shows blank, fake an array, like $_SESS, and assign something to $_SESS['views'], and see if using $_SESS in the input shows the value you faked. I don't know how to help either if it shows or if it doesn't, but you will be standing in better ground to ask someone who knows
Use this: http://i.stack.imgur.com/whhD1.png On the first request, a DELETE should return 20x (200, 202, or 204). On subsequent requests, either a 404 (non-permanent DELETE) or a 410 (permanent DELETE).
Thank you all very much! Much appreciated. I get the idea. :)
Changed it to what? AddType application/x-httpd-php .html ? 
He said it's in an HTML file. In all likelihood it's not being executed. He needs to rename the file to .php.
The form is in an HTML file and all I want with php on that file is to say the value in the box. Edit: Here is the PHPInfo page, imgur couldn't handle it. http://bit.ly/19Yqtmi
Yes, that is what I have done. It made no difference.
Is any PHP code showing up? Just a simple echo on the page? I always use .php extensions, but that's just me. 
I renamed it to be a PHP file and this happened. http://i.imgur.com/aweHX4q.png Also, when I submit the form now the page was copied about 20 times and so there is 20 of the same form on the page now. [Picture](https://mega.co.nz/#!Ns9EECIA!O-U64woRsvd89Xo96qPx-kI2kiBo0xmUFC4QrryWd_A ) Please keep in mind this is one page, I loaded the page and this is exactly how it looked. Edit: I just had an idiot moment and blanked out the error. Warning: include(http://removed.com/send.php) [function.include]: failed to open stream: HTTP request failed! HTTP/1.1 500 Internal Server Error in /home1/removed/public_html/KyleChat/index.php on line 3 Warning: include() [function.include]: Failed opening 'http://removed.com/send.php' for inclusion (include_path='.:/usr/lib/php:/usr/local/lib/php') in /home1/removed/public_html/KyleChat/index.php on line 3 The things where replaced with removed to protect the test server from attacks.
See my edit
Also, even if you could do remote includes, it would still fail because you didn't put http://removed.com/send.php in quotes (a.k.a. making it a string)
The error didn't show quotes but they were there.
Glad it works. You should still consider keeping your initialization and config code centralized in one file for maintainability's sake.
I don't expect everyone reading will read the whole RFC, so thought it best to clarify why assert should not be used. The impact is not extremely negligible, at all, it's plain to see that you cannot deploy assert without affecting production. "but the actual call to assert cannot be optimized", has a word missing, should read "but the actual call to assert cannot be optimized away", fixed. The benchmark clearly shows that the old implementation of assert has enough impact on an application that it is reckless to deploy it aggressively, such use will drag down the applications performance, but the same amount of pressure on expect will not drag down production or development, at all.
See the opcode section of the RFC. Every time you call assert anywhere in your codebase you insert [at least] 3 useless opcodes (this doesn't count eval'd code during development) into the op array that _cannot be removed_ that are _executed during production_ *even when assert is supposed to be disabled*.
You are confused about what Zend is, easily forgivable :) Zend is to PHP what the JVM is to Java. It is the name of the virtual machine that executes your code, contained in the /Zend folder. It is also the name of the framework making that virtual machine possible. On top of Zend is PHP, PHP is a collection of thin wrappers around third party libraries, such as cURL, the Apache2 Module Interface. PHP is also the name of the code that makes those wrappers possible. Said wrappers are divided by functionality into two groups, SAPI and Extensions. Extensions, like the cURL module, allow the programmer of PHP to access installed libraries. SAPI's, like the Apache2 module expose the interpreter to other services on the system in order to deploy PHP to the world. You now understand what Zend _is_ :) A complex expectation makes no never mind to Zend. The expression is compiled (and optimized and cached where opcache is loaded) with the script. The observations that opcodes are going to change when the statement is complex is valid, in some circumstances; where opcache is not present. When opcache is loaded, and expect disabled (production): opcache optimizes away, completely, the expect statement _including_ the expression statement used in the expectation, the op array looks as if you had never used expect. When opcache is not loaded, and expect is disabled: the VM is instructed to jump past the dead code (expression to expect), effectively making it equivalent to an empty statement. You will notice that there are two kinds of uses of expect in the RFC, there is the preg_match or die kind - these are accompanied with complex expression (or function calls or whatever), and there is the don't get as far as here or die kind. These are not accompanied by complex expressions they only require expect false; When used as intended these expect false calls restrict where the vm is allowed to travel explicitly during development, they forcibly stop it going anywhere stupid and tell you they are doing so verbosely. This is extremely useful, simply not practiced in lower level languages like C, but lifted straight from the Java documentation of assertion, we do it in high level languages all the time. This second kind of use, specific to high level languages is what is shown in the benchmark to show that you can deploy this sort of thing as aggressively as you choose to and it will not impact anything. Should this get in, I'll put much effort into documenting, in the PHP manual (not all over the interweb), how to best deploy expectations to make the absolute most of it ...
Well I wouldn't say that, assertions are commonly complex statements, but they are not complex to compile, they are complex to execute. That's the key. expect is a language construct, just like "if". expect $condition; Is functionally equivalent to if (!$condition) { throw new ExpectationException(); } It doesn't matter what $condition expression is, the two are functionally equivalent. So expect ($condition &amp;&amp; function_call()) || (new Object())-&gt;method(); same as if (!(($condition &amp;&amp; function_call()) || (new Object())-&gt;method())) { throw new ExpectationException(); } 
This is straight from the RFC. There's no question about what a successful request should return.
It's for the client to decide whether it's successful or not. It's bad practise in your code to allow for deleting something that was already deleted anyway.
He asked what a **successful** response should return. This is what a successful response should return as per the RFC. We aren't even talking about subsequent requests here. Stop being stupid.
You sound exactly like me. I'm singing the same MODx tune :(
As someone who's not a die hard PHP programmer but needs to run through some PHP every now and then, contributions links yours are really helpfull. Back to basics.
Ah right you need to catch the signal in that case, my bad.
Kinda related http://dowebsitesneedtolookexactlythesameineverybrowser.com/
Can you post everything in your form markup from &lt;form&gt; to &lt;/form&gt;, or from higher up if you have everything inside a php echo?
yes, unless you try to echo something in between, it should complete.
I tried it locally, copy pasting without changing anything, and the form is submitted. What do you mean that nothing happens? Does it not load the send.php page or is it that send.php doesn't do the job? Although it works, there shouldn't be any spaces between "action=" and "send.php". You *can* expect some weird behavior if you don't make it like that &lt;form action= "send.php" method="post" name="submit"&gt; &lt;input type="text" name="username" value="&lt;?=$_SESSION['views']?&gt;"&gt; &lt;input type="text" name="message" value="message"&gt; &lt;input type="submit" name="submit" value="submit"&gt; &lt;/form&gt;
An explanation regarding how to do this, http://www.tuxradar.com/practicalphp/16/1/1
It loads send.php, but send.php is supposed to write the username and message to a file. It does not do that. Do I need to change the permissions for send.php? Hold on, tried giving send.php permissions 777 and got this: ERROR 500 - INTERNAL SERVER ERROR Edit: Restored permissions, now it saves to the file. Is there a way that I can get the time in UTC using php? Edit 2: spelling. Edit 3: Found the awnser. It works perfectly now. Thanks! For anyone who comes across this, here is the code to get the time in UTC: $utc_str = gmdate("g:i:s a", time()); $utc = strtotime($utc_str);
Apparently send.php had no permissions to be executable. Weird if it was a file you created yourself. Less weird if you created it via, say, SSH with the root user, and tried executing it (it uses the php user if I recall correctly)
send.php has permissions 644 and it works perfectly fine now. I cant really explain what I did but it works now...
nice! I use vcr with ruby all the time and thought how great it would be to have in php but &gt; Disclaimer: Doing this in PHP is not as easy as in programming languages which support monkey patching – this project is not yet fully tested, so please use at your own risk! that's pretty much what I thought when considering how one would even do it with php. 
I have made something this using monkey patching in php. 1. One was something that could measure code coverage of your test with out using xdebug or an extension. I even went so far to attempt to measure path coverage using static analysis of the code and patching it accordingly. 2. Second one was something that could record the execution trace of a php project which logged function calls, passed arguments and return values and an html ajax interface through which you can navigate through the generated traces. Both of them didn't gather much interest and was quickly abandoned (well, sort of). If you are interested you can examine the remains of both attempts https://github.com/sandeepcr529/codespy and http://www.reddit.com/r/PHP/comments/p9hn3/i_have_made_this_amazing_profiler_please_let_me/ Yea, I was a bit desperate back then. In both of these, Monkey patching was done by intercepting include and require calls and patching the files before they were given to php. 
So this intercepts only curl function calls, right? I mean, If I use sockets to communicate using http, will it be caught? 
Have you heard of Node + Socket.io? 
Personally, I prefer to use if($this == that) echo $variable; I don't know that there is a "proper" way to do it. I go by preferential if(truth_condition) { do_something() }, but that's just me. As far as better or faster, I don't see a difference between using either methods. I just go from what I learned in the first place. My advice is use whichever method you prefer. :)
Not really, its the least used CMS 
Yes, I even mention it in another reply. Surely you can manage reading 10 comments/replies before asking that?
&gt; amplify the visitors number by requiring them to Tweet about your page, in order to unlock your content . lol
Can be a good way for something to download or premium content .
That's a valid use-case but definitely not for generating more traffic. I don't know anyone who doesn't immediately run away from a website when presented with a prompt to tweet or post to facebook just to see the content.
I prefer the first option, since it looks cleaner and and you don't need to worry about forgetting a quote, dot or escaping a character in the string. It also has the added benefit of cleanly separating logic from structure which is something your need if you work with others who have limited knowledge of php, like a webdesigner who maintains your templates.
I disagree, and I'll show you why. function setNumber($num) { if (!is_numeric($num)) { throw new InvalidArgumentException( '$num is expected to be a number.' ); } } That is code you are likely to see in any framework or library, and there's nothing particularly wrong with validating function arguments, but it's code that's largely irrelevant outside of development and testing, and has a performance impact in production. The same code could have been written using assertions. function setNumber($num) { assert('is_numeric($num)'); } The same goal is accomplished, but you can turn off assertions in production, at which point calling `assert()` is on par with calling an empty function. My point isn't that assertions have zero impact. In fact expectations have an impact too. They aren't magically removed from the source code when turned off. They simply do nothing in the same way assertions do nothing when turned off, only in a slightly better way. And by slightly, I mean expectations may be a few microseconds faster. My point is assertions are better than the alternative: full blown operations and function calls which which cannot be turned off, which we do see deployed every where. You are arguing developers cannot deploy assertions because of the performance impact, but everyone deploys code like my first example, which has a much greater performance impact. Also, saying that calling an empty function, which is what happens when assertions are turned off, drags down performance "considerably" is lunacy. Despite the benefits of assertions, no one uses them, so I see no point in extending the API with expectations other than the nicer syntax.
I'm sorry I don't know much about it.
Check out one of the frameworks out there, I like codeigniter myself. - http://jonathanmh.com/best-php-mvc-frameworks-of-2013/
&lt;?php if ($this==$that){ ?&gt; &lt;li&gt;My gran can beat you at &lt;?=$that; ?&gt; no problem.&lt;/li&gt;&lt;?php } ?&gt;
f3 templating https://github.com/bcosca/fatfree &lt;check if="@this==@that"&gt;&lt;li&gt;My gran can beat you at {{@that}} no problem.&lt;/li&gt;&lt;/check&gt; 
I agree with the short open tag equals, but not with the braces. When using PHP in an HTML context, it's a good idea to use colons and end* as it's harder to notice ending braces and can be hard to differentiate what it closes if the code gets a bit complicated.
I usually (when not using a template engine like Blade) embed all html in a output variable like so: $ html .= '&lt;li&gt;Your grandma does a lot of things&lt;/li&gt;'; If (???) { $html .= '&lt;li&gt;So does mine&lt;/li&gt;'; } ... //and end the execution with... echo $html; So a lot of people will say that this way is old fashion and bad in a number of ways. And you know what, they are probably 100% correct. But I continue to work like this since I really think that the benefits are much greater than the problems / disadvantages. 
I've never used the alternative syntax, I may try it out, back in the world of braces sublime text will highlight the beginning and end of the brace so you can see where your statement begins and ends though I can see why being a bit more verbose if you are mixing different control structures may help readability
I'd not recommend that blog post. From a quick look it suggests Zend framework is proprietary despite being licensed under the modified BSD license. Also no idea why it would recommend codeigniter when the company behind it is trying to dump it.
MVC = Model-View-Control It is a philosophy on how best to organize your code by separating these three concerns. Google should help you find more. Without templating (ie a quick hack) I have always resorted to caching my HTML and echoing it at the end, so my code would look like... &lt;? $HTML = ""; ... if($this == $that) { $HTML .= '&lt;li&gt;My gran can beat you at ' . $that . ' No problem.&lt;/li&gt;'; } ... echo $HTML; ?&gt;
fair enough, maybe CI wasn't the best jumpoff point, Ive been muckin with laravale lately. *edit: fixed it for jamil.
Makes sense. 644 means that it can be executed.
As far as speed, I agree yours is the fastest.
I still work like this as well from time to time. It definitely has its benefits.
I would use : $html = "&lt;li&gt;My gran can beat you at ".$that." no problem.&lt;/li&gt;"; &lt;?= $this == $that ? $html : '' ?&gt;
My three rules (for ZF/ZF2/Yii/etc/ templates): * Use a some structure, one line statement looks ugly, really. * Use a short tags, they cool. The mix of a php/html so hard to read, avoid *&lt;?php* , *&lt;?php echo* * Do not use some concatenataion, php strings, etc in templates. So, &lt;? if ($this == $that) { ?&gt; &lt;li&gt;My gran can beat you at &lt;?= $that ?&gt; no problem&lt;/li&gt; &lt;? } ?&gt; PS. if () : endif; and foreach (): endforeach; looks useful, but I prefer the braces.
Using PHP for web sockets is silly. It's not meant for that kind of thing. It's like trying to use PHP to control a GUI. 
The top one is better in general. Don't be afraid to space things out, either: &lt;?php if($this == $that) : ?&gt; &lt;li&gt;My gran can beat you at &lt;?php echo $that; ?&gt; no problem.&lt;/li&gt; &lt;?php endif; ?&gt; Readability and flexibility is the name of the game, as well as keeping in one "mode" (PHP or HTML) for as long as you can.
You can also inject the [variable inside double quotes.](http://www.php.net/manual/en/language.types.string.php#language.types.string.parsing) if ($this == $that) { echo "&lt;li&gt;My gran can beat you at $that. No problem.&lt;/li&gt;"; } 
laravel*
that generally is much more of a pain in the butt to maintain though, especially if you are working with front-end people and they don't know php.
sometimes it's impossible to avoid &lt;?php, since it all depends on the server config and if you don't have control over that, you might have to rewrite all your &lt;? tags as &lt;?php. I've found it's best to use &lt;?php to not have to worry about that
&gt;$html = "&lt;li&gt;My gran can beat you at $that no problem.&lt;/li&gt;"; FTFY mind you, I don't endorse your way of doing it, but at least it makes more sense now.
First one if these are the two options. BUT You probably shouldn't be worrying about performance. In that case, templating engines, like twig, are your friend as they make templates way more readable.
If you're looking into a framework, look at Symfony2. It's an amazing rapid development full fetured framework. Very similar to RoR and Django. Zend fell behind and I hear codeigniter is mostly dead (?).
global $dbl, no PSR-0? Good intentions, but it's probably worth sticking with a proven solution already (for something as complex as an ORM). Good job for putting it out there though :)
I... honestly can't tell whether this is satire. I certainly hope it is, but I've seen people actually promoting these kinds of unreadable walls of OOP with a straight face.
Are you referring to the code samples?
Are you arguing the example or the methodology? Do you believe an email doesn't need to be an object? Is [this](https://github.com/laravel/framework/blob/master/src/Illuminate/Mail/Message.php) too complicated?
As the article put it so eloquently: &gt; why didn't we just use the mysql PDO library? After reading it, the question stands.
My guess is he's referring to the fact that it's overkill. This likely isn't something you're going to need to extend and it makes the code a lot more verbose for seemingly no gain (and if anything, a performance hit). It feels like one of those "if you're a hammer, every problem is a nail" applications of OOP. Small suggestion: proofread your blog before you post it. There are a number of typos (even ones in code). Makes me take it less seriously, FWIW.
Its always good to wrap in my opinion. If you go to call a method of a class, like print "Hey today is $date-&gt;format('M jS')"; You will get a undefined property error. Wrapping it in the braces will parse it properly.
I'm self taught so perhaps I'm doing things wrong, but I do things like using PHP to spit out Javascript with HTML in it to create map markers on a google map: &lt;?php for($i=0;$i&lt;$propcount;$i++){ if($props[$i]["lat"] != ""){ echo "createMarker(".$props[$i]["lat"].", '" . $props[$i]["address"] . "',\"&lt;div class='maplisting'&gt;&lt;p&gt;&lt;span class='header'&gt;&lt;em&gt;" . $props[$i]["header"] . "&lt;/em&gt;&lt;/span&gt;&lt;br&gt;" . $props[$i]["address"] . "&lt;/p&gt;&lt;a href='#' class='btn btn-default'&gt;See Details&lt;/a&gt;&lt;/div&gt;\"); "; } } ?&gt; Should I avoid this doing this type of thing and why? Other than having it be easier to read for another developer, is there really a performance issue?
The class was coded purely to illustrate some points. It was just an example. However, I would still respectfully disagree that it's overkill. I would much rather use it than the class at the beginning of the post or the native mail() function. 
Nice article for beginners to grasp the logic but it is a three year old article (written 2010 from what I see) and I believe there are much better practices out there now to handle a "real time" chat room. As an example... using React to handle the chatting and client connection instances; using Redis (Predis) as a quick store/retrieve of the chat-room data and of course Javascript libs to communicate with the React server and serve real-time communication.
 $email = new Email; $email-&gt;setTo('bob@gmail.com'); $email-&gt;setSubject('a subject'); $email-&gt;setMessage('a message'); $email-&gt;send(); This is a pain in the ass? 
I'm not saying your example is wrong, but it doesn't illustrate its point effectively. After all, mail() is used freely throughout the PHP ecosystem in situations where someone just wants their code to fire off a simple email. Therefore, it serves its purpose, and your example doesn't clearly distinguish the benefits of your approach in creating a full blown OOP class to handle what mail does in one line. Something like an event dispatcher class would have been a much more useful example that would clearly show the benefits of good getters and setters.
I thought providing an example class would be useful. Apparently I should have just shown generic methods with no context...? 
The pdo library (on its own) would require a developer to actually write SQL. If this is in place, you have some ease-of-instantiation and ease-of-search without ever having to write SQL. Its hard to believe you read it and missed that. 
&gt; Something like an event dispatcher class would have been a much more useful example that would clearly show the benefits of good getters and setters.
tried to pick something that everyone, including brand new developers, would understand. Guess it was too simple of an example for this crowd
Well, if you're going to do that...do it before you make a post evangelizing an approach. As it's written, I would basically never do it this way, and it would be a conscious choice not to. OOP really adds nothing in this scenario. It also violates the single responsibility principle because it's both a model and it performs "persistence"/sending. At least give people the actual context so they don't have to guess what you're going to do in the future. Not saying I'd even agree with it in that case; it depends on the business rules/use case.
is this? class Email { public function send($to, $subject, $message) { if ( ! filter_var($to, FILTER_VALIDATE_EMAIL)) return false; if ( ! is_string($subject)) return false; if ( ! is_strin($message)) return false; return mail($to, $subject, $message); } } 
This is a pretty good post, OP, and touches on some of the importance of getters and setters. I think your example could use a little work though. Your `Email` class is mixing concerns by acting as both configuration and sender. It might make more sense to have a `Email` class, which represents an email, and an `EmailSender` class, which sends the emails. Then you can specialize the sender class, such as creating `HtmlEmailSender`, `SmsEmailSender`, etc. Also the reasons you give for the existence of getters is a bit manufactured. There's no need to make them appear to be more interesting or useful than they really are. Types should be checked in setters, and you're doing that. There's no need to check the type again in the getter. You have a logic error in your class if a property is meant to be a string, is type checked by the setter, and is being returned as anything other than a string, and the php runtime should bring that error to your attention as soon as possible. When you return an empty string from the getter, you're allowing a bug to march on unnoticed. If anything put `assert('is_string($this-&gt;to)')` in your getter, but that's about it. 
&gt; people are hung up on the example, not the ideas. This Idea is not new. So the way you present it in your blog is all that matters in this context. If you cannot find a compelling example to show the worth of and Idea, then its better not to bother. Because it may cause more harm than good. Apart from that the advantages of using OOP and how to use it to your advantage are very subtle and cannot be really conveyed via a simple blog post...It has to come from experience. So here is my suggestion for you. When ever you come across a new idea, don't write about in your blog right away. Use it in your work for a while. When enough time have passed, you will gain a deeper understanding of the idea. Then you will be able to convey the idea more effectively. Then you can try writing about it. And use a spell checker. I think it was only last week I pointed out a typo in your posts. It seems you have some in this one too. 
I don't think this is a good answer — it doesn't make a good case why writing SQL is actually a bad thing (and I happen to think that NOT writing SQL is a terrible thing :)
Why is it more preferable to mock out after the HTTP request than at the class level? If you can't control that your class under test calls to an external server or not it sounds like you need to use dependency injection so you aren't calling out in the first place. What if your tests run on an external server? 
If you're gonna echo a string and you need to include variables or functions in the string, you should use a comma and not a dot. A dot will concatenate the string before it outputs it to the buffer. A comma will just echo every part one by one. &lt;?php if($this == $that) echo '&lt;li&gt;My gran can beat you at ' , $that , ' No problem.&lt;/li&gt;'; ?&gt; 
Off the top of my head I can think of two ORM's that solve the problems the author has with traditional database interaction. [RedBean](http://www.redbeanphp.com/) and [Eloquent](http://four.laravel.com/docs/eloquent) which is the ORM included with [Laravel](http://laravel.com) but can be used independently.
how many composer packages ship with a IoC container except web frameworks?
I'm sure there are people who can appreciate the academic exercise of using web sockets with PHP. I'm sorry you aren't one of them. Perhaps you would prefer contributing constructively to or avoiding threads you feel so passionately opposed to?
I know you have signed up for github..but, take a look at Mercurial too as an alternative to git. http://mercurial.selenic.com/ you can read a good introduction to Distributed Version Control using Mercurial here http://hginit.com/ Even if you decide to use git, I suggest reading that article. As an alternative to github, you can use bitbucket.org. Free unlimited private repos. Yay!! You will also need to know about namespaces, auto loading, composer package manager etc. 
MVC isn't new, it's been used in software development for many many years. Version control, application frameworks (or what used to be called libraries), etc. aren't going away. You're seeing these tools and methods being adopted by web developers because we are no longer deploying simple home pages or marketing sites. Full-blown web applications are now being built to deliver a huge gamut of services and goods. Our software development team is working on two very large web apps that will help our clients business better organize staff resources and marketing resources. At this point, not learning OOP/MVC/Version Control is only going to hurt you.
This is exactly what I was wanting to know, so thank you. I can tell that the progress we're seeing is causing a big change in the way web development is done, but I just wasn't sure exactly how serious this stuff is. Especially when it comes to stuff like SaaS and PaaS. Just seems like everything I knew, although still being used by many, is slowly being changed by all of these new technologies. I love it, but its just a little overwhelming.
mixing html inside of php is a bad practice because it makes it harder to maintain, especially for the next person working on the project.
I can't find any, but I may be looking in the wrong way. 
Your ideas are actually really nice! I especially like how you highlight covered code in vim. If I had only seen this earlier... first I tried creating a proxy and after that using runkit but include interception works the best and is pretty easy to use.
Thank you!
We get this question a lot. When creating unit tests, mocking classes is the preferred way because the behavior of a class is under test. But in functional tests which usually test a big pile of code working together this changes: * manual mocking becomes a lot of boring work * responses from external APIs can/will change and mocks become brittle As an additional benefit PHP-VCR brings you: * inspect requests and responses your app makes * easily find out when and why an app issues requests * re-recording interactions and then diffing them against the files in version control makes external API changes obvious
[php.net](http://php.net/manual/en/install.php) has a pretty extensive list of installation methods thats covers next to all platforms or you could use something like [XAMP](http://www.apachefriends.org/en/xampp.html). For getting started with php i probably recommend [Codecademy php course](http://www.codecademy.com/tracks/php). 
I'm guessing you're on windows, in that case just download and install WAMP, it will install apache + php + mysql for you in one go. However I'd recommend switching to Linux for PHP developement, its pretty easy to install and use and much faster + secure than windows. /r/linux4noobs if you need help
By all means take a look at Mercurial, but git is the far more widely used and more likely to be useful to you if you're working with / for someone, or you want to find/use/contribute to an open source library.
This is pretty old. Using polling or long-polling is really unnecessary now. We now have proper real-time communication systems like WebSocket which are much more ideal.
Wouldn't this be slower? Since it will have to parse every double quoted string to check for variables. With single quotes it has no need to do this.
Someone sent me a message about the same thing but said that method gets a lot of hate, without explaining why it does.
Not necessarily a performance issue, but you have to realize that readability and maintainability are absolutely essential, and will not only make the lives of other developers easier, but also your own. Always try to write code as cleanly as possible, no matter whether you think it's important now or not.
No prob. I'd still recommend trying Linux though ;)
One reason for a lot of people being stuck with 5.3 is related to server security; for instance I have a server running Ubuntu server 12.04 LTS, and if you stick with the software updates provided by Ubuntu for this distro, you only get updates on the 5.3 branch for PHP. If you want to upgrade to 5.5 you have to add a new possibly unsecure software source to apt-get or manually update it yourself. Maybe the next 14.04 LTS release will include PHP 5.5.
I know, but it is not such big problem as it apears. With my 4+ years of php it wasn't problem. Ask you server admin to enable short tags. Or use normal hostings what allow short tags :)
I thought 12.04 had 5.4?
 'host' =&gt; '192.168.56.101' is likely your problem. by default puphpet/vagrant manifests don't open the mysqld server to the world. change the value to 'localhost' and amazing things will happen.
And if you're not on Linux, get on Linux and learn that first :-) Only partially kidding.
As I said, I tried localhost, 127.0.0.1 etc..
nope, just checked and the last version update from Ubuntu was PHP 5.3.10-1ubuntu3.8 on Sept 4, 2013.
If it is you wouldn't even notice. Its faster to type and won't piss off your co-workers
|web designer who maintains your templates God help us
Have you tried to connect with a simple: mysql -uroot -p123 What error are you getting?
is this database in the root app/config directory or did you branch it off into a sub-dir? (this is usually done to have different config files per environment). if so, you'll want to define your environment with --env=dev (or whatever the sub-dir name is).
Thanks, yea ill have to see how serious I am for learning it. Trying to code some of my startup considering the cost if I was to export EVERY line of code
Maybe I was thinking of 12.10.
you would issue this command whilst on a terminal shell of the vagrant host. it's the same place you'd issue the php artisan migrate command.
Fuck I'm retarded, so I can't call artisan commands from windows path, instead I must run them from vagrant's console. Welp it works now so thanks!
You can see the versions available on each release [here](http://packages.ubuntu.com/search?keywords=php5).
On Ubuntu: apt-get install lamp-server^
Oddly enough I switched to PHP 5.5 for security reasons on an e-commerce production server. Trustwave PCI kept pushing back against 5.3.3-22 (or w/e) for RedHat ES due to an issue that RedHat specifically said they had no plans to address. That's fine, I switched to Debian and 5.5 and since then I haven't had to deal with disputing almost 100 or so security "issues" a month.
&gt; In fact expectations have an impact too. They aren't magically removed from the source code when turned off. Actually they are, that's why their impact is null in production after the first compilation of the file if the op code cache is activated; on compile time, if expectations are disabled no opcode is generated for them in the resulting bytecode. Assert on the other hand adds several opcode, even when disabled. I do not know why they can't make the same change to assert instead of creating a new syntax and I don't care enough to check, but it makes a huge impact if you are using a lot of code full of checks and not simply a 10 lines benchmark.
Yes, there will be a minuscule performance hit, but it's so tiny that the increased readability outweighs it.
This concern is a micro optimisation that's not worth the time over building what is more maintainable, readable code, and, consistent conventions. Any differences will be dwarfed by orders of magnitudes for db or other resource interactions
Ah, indeed it was 12.10 I was thinking of.
If you would want to update PHP you can do it with some minimal effort. There surely are PPA's available, and if you want 100% trust you can compile and package it yourself.
&gt; I'm wondering if this stuff is really here to stay. It isn't. And it is. The PHP world, just like the web world, is a constantly evolving thing. Things change and grow and advance. But they don't just spring forth out of nothing. They build on what came before. Frameworks like Symfony 2 are built on the original Symfony. Laravel is built on components of Symfony 2. Composer uses Git. Laravel 4 uses Composer. Fortrabbit uses composer to use git to install Laravel. Laravel 5 won't be drastically different in this respect. Git won't change a lot. There may be new tools, but they'll build on the existing knowledge of the community. None of this is actually as hard as it seems. Only because your skills are well behind the curve and you have to learn the entire ecosystem. I've been there. It's hard because you have to learn so much to make anything work. &gt; it's such a huge change from the days of uploading some .php files into a directory via ftp and reloading the page Yes, it's a vast improvement. We do better a better job. &gt; Signed up for Pagodabox and Github. Github is the shit, but I can't recommend Pagodabox. They do some kind of weird things (their quickstarts, box files, etc) and I've found them horrifically unreliable and with pathetic stats, and ended up bailing. I strongly recommend Fortrabbit. 
Don't yell.
Because the SQL has to be maintained. Large amounts of related functionality can build up a not insignificant burden of almost identical queries, each of which requires propagating updates when changes are needed.
As long as you are absolutely sure that every parameter you pass to the template needs to be escaped, which is usually not the case. BTW, your function is simple enough, but it will run htmlspecialchars() on every item in the array. This means that you cannot pass object/array to the template. 
Very much agreed. I would rather use something like Eloquent. It's established, documented, etc. I appreciate the effort to make something new, but I'll also stick with what is established.
&gt; Trying to code some of my startup considering the cost if I was to export EVERY line of code ????????????
Canonical don't bother keeping anything up to date.
wrong, the actual command is sudo rm -f /
The specifics may change but the concepts won't. Learn git. When it gets dethroned by something better, most of the concepts will transfer. 
My point is, PHP has its purposes. This isn't one of them. 
&gt; I do not know why they can't make the same change to assert instead There's no reason to change assert. Adding thousands of `assert()` calls to your application degrades performance by an unmeasurable amount. I say unmeasurable because I'm unable to detect even a 0.001 microsecond difference after adding a couple hundred calls to `assert()` to a real work application. OP's assertion (pun?) that calls to `assert()` drags down performance "considerably" is ludicrous. Maybe he would be happier programming in assembly if 0.001 microseconds of performance is that important to him. I think OP would have an easier time winning people over (getting yes votes) on expectations by pointing out how much it sucks to pass code as a string to `assert()`. You lose the code completion and highlighting provided by your IDE.
You could initialize the properties as strings instead of null, and avoid the type check in your getters. The only real reason to initialize them as null is so calling code can tell the difference between "not initialized" and "initialized to an empty string", and in that situation your getter probably should return null. That's just my opinion though. I'm not sure there's any "hard science" on how getters should be written. Beyond the hastily thrown together example, I think those here saying your example is overly complicated should probably pay attention, or go back to functional programming. They're missing the key principle of OOP, which is configuration. I should be able to configure and pass an instance of `Email` to another object without that object knowing how to configure the `Email` instance itself. The other object should only know `Email` contains a `send()` method, and nothing more. In fact the `Email` class should implement an `ISender` interface which only defines a `send()` method. The object receiving the `ISender` instance should not know or care what happens when `send()` is called. Maybe an email is sent. Maybe a sms message is sent. Example: interface ISender { public function send(); } class Email implements ISender { private $to = ""; public function setTo($to) { $this-&gt;to = (string)$to; } public function getTo() { return $this-&gt;to; } public function send() { mail($this-&gt;getTo ...); } } class SMS implements ISender { private $phone_number = ""; public function setPhoneNumber($phone_number) { $this-&gt;phone_number = (string)$phone_number; } public function getPhoneNumber() { return $this-&gt;phone_number; } public function send() { sms($this-&gt;getPhoneNumber() ...); } } class PasswordResetter { public function resetPassword(ISender $sender) { if (!$this-&gt;is_password_sent) { $sender-&gt;send(); } } }
OK, sure, it can be improved a little depending on use-case, but you really don't need to use a full templating engine most of the time.
If you want access to your database outside of localhost you need to change what MySQL will listen on. Read more here: http://www.howtogeek.com/howto/mysql/switch-mysql-to-listen-on-tcp/
Man... lots of posts about personal coding style preferences, zero posts that actually profiled your code to see which ran faster. [Here's a quick and dirty way to profile it](http://pastebin.com/YSbeVXrj) Running on Windows 7 x64 with PHP 5, what I found was that one method was not reliably faster than the other. There would be a difference of fractions of microseconds between the two and sometimes the first method was faster, sometimes the second. Could it be that the interpreter acts similarly on the back-end under both situations? I'd love to hear input from someone familiar with the interpreter's inner-workings on the matter.
Could you elaborate a little further? We're running PHP 5.3.3-23 / RHEL 6.x for a client and have not had issues with PCI compliance.
I don't recall exactly, this was a couple months ago. Had something to do with SOAP cache, which this website requires - and I disputed at least 5 times elaborating that this was not a shared host and that it wasn't an issue. 
Is professional-grade software development in PHP here to stay? Absolutely.
Yeah, I had trouble initially, too. Though I'm not a huge supporter of Pagodabox, I do think it works. But Pagodabox (like Fortrabbit) is part of an ecosystem that has a bit of conditional knowledge. Knowing Git and Composer, by the way, should absolutely be baseline skills now.
I did not mean anything against the Smarty project. I just don't like having too many dependencies on a web application.
But... but... but... clock cycles! Milliseconds! Everything has to be "optimised"! If you do benchmarks and one of them is a few milliseconds slower at artificial actions you should totally use that!
Please don't forget bzr! It works great on every major operating system and is **very** easy to use, especially compared to git. I use bzr personally but am forced to use git at work, and let me tell you, even after 6 months of using git on a daily basis, **Everything** takes 2-10x longer and requires reams of notes compared to the utter simplicity and straight forwardness of bzr. You really should learn bzr and/or mercurial before you stumble into the byzantine world of git, especially if you're new to VCS!
You've got to consider that it's only been a couple of years since PHP5.3+ found its way onto the majority of low-end hosts (i.e. almost all of them). You'll probably see another shift when 5.4 becomes widely available and people start making everything intro traits and using short syntax everywhere foo()[1] etc. The jump to 5.3 brought some significant features which in retrospect have led in a roundabout way to a lot of good things we have today; case in point Composer only really works because of native namespacing (yeah you can use underscores but life is too short to write $foo = new Symfony_Config_Recursive_Yaml_Reader_Factory_Abstract more than once).
Haha! This is exactly what I'm talking about. The mods ban good people and let the trolls run. Look! An abusive sockpuppet deriding the concept of sockpuppets. Is the hopeseekrisascammer operator schizophrenic, or what?
&gt; Symfony or Laravel I took a short look at Symfony - so far it seems awesome! I'll check Laravel out as well. I think going with a framework is a good compromise between modification and writing from scratch. 
I guess writing my own with a framework is a good idea.
Last time it was silex. Would love something that's a bit more specialized though =)
This is one of the weirdest spam accounts I've seen.
From what I understand, [you can disable caching to avoid that exploit](http://stackoverflow.com/questions/303488/in-php-how-can-you-clear-a-wsdl-cache).
I meant if I export the code aka hire someone it would cost me a ton. Also I am learning this to work on my startup! 
[lots of handy stuff to know](http://www.phptherightway.com/)
IMO you'd be almost dumb to not use a framework..it will literally save you 100s of hours of work.. I use Yii a lot and my buddies like Laravel
Things have changed. There's an entire ecosystem of technologies and techniques that interplay. Don't be intimidated. Take each one on its own and investigate it. Don't try and learn and work everything together. Git. Composer. Frameworks. ORMs. Vagrant. Namespaces. PSR. Take them one at at time. They're all useful.
I would like to give my vote to [Perch](http://grabaperch.com). It's a small CMS that does it's best to stay out of your way. I work in advertising were I have very highly stylized comps to work with and Perch just allows you to do what you need to do. Plus, the owners are a cute couple from Britain who attend their own meetups and do all the support themselves. I met them in Toronto. It's really cheap also at $80 per site. I love being able to support a small company who has worked to provide a great tool for people.
Another option, which separates the variables and the grammar/language being used in the printed text... if ($this == $that) { echo sprintf('&lt;li&gt;My gran can beat you at %s No problem.&lt;/li&gt;', $that); } Done in Twig... {% if this == that %} {{ '&lt;li&gt;My gran can beat you at %s No problem.&lt;/li&gt;' | format($that) }} {% endif %} 
Read http://phptherightway.com. That's an order and should be a requirement for any aspiring PHP programmer. You can ignore the PEAR section, but everything else is a must. I also link to a comment of mine from a few days ago in AskReddit. You probably would like to play a bit with the language before getting into this, though. http://www.reddit.com/r/AskReddit/comments/1poo0n/programmers_of_reddit_how_would_you_sum_up_a/cd51fdt 
Eventually you will end up with your own half baked templating engine. So why not start with a good one?
My favorite favorite PHP book is "PHP Objects, Patterns, and Practice 3rd Edition" by Matt Zandstra. Chapter 3 sums of the heart of the language really well. I also enjoyed Lynda.com's PHP videos. They have a basic and advances series. They also walk you through setting up your coding environment (WAMP). * PHP is better than it used to be. * If you are at all concerned about syntax, don't be. Basic logic and control structures look very similar to C and Java. * PHP is very "loosely typed". Be weary of this and be explicit whenever possible. Check your data types when writing classes. Learn the difference between the "===" and "==" comparisons. * Focus on classes/objects and not just scripts. Learn how inheritance works in regards to methods and variables. It's simple and powerful. If you are duplicating code in different files, consider writing a class. * Learn to love SQL as much as PHP is you plan on doing database work. Learning to fetch your data efficiently will save you a lot of PHP logic. * Google everything. Stack Overflow combined with PHP.net can get you where you need to be. PHP has an army of native functions to do basically everything.
I'm finding this very helpful: http://www.codecademy.com/tracks/php
MVC is not always the answer, but when it is, it is!