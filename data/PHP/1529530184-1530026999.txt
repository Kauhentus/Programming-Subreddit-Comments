Buffer and Memory Management is located here: https://github.com/phpsci/phpsci-ext/blob/master/kernel/buffer/memory_manager.c
As pointed out, use [Docker](https://docker.com). I can recommend [Docker for PHP Developers](https://leanpub.com/docker-for-php-developers) by [Paul Redmond](https://twitter.com/paulredmond). 
"instead, create your own project use your project it to experiment and try things out" This! Shitty code becomes very obvious when you start small and then add more features. You learn best from mistakes and grinding on code. I'm writing a size project. In short order i've learned having smart class definitions, non repetitious code and secure methods are not just "nice to have" they become hugely important in keeping your sanity. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Just curios. So we have prefix type hints and also have postfix for return types (rational of which were conflict with `static`, which could be referred as type). I wondering, why don't you mention why prefix form is chosen? It is because it would be easier to get some sugar like this: public function __construct( private Foo $foo, private Bar $bar ) 
&gt;With strongly typed languages, you wouldn't necessarily be able to unmarshal JSON data without having structures that define the schema strictly. You definitely can in any non-trivial type system. To borrow from Rust's `serde` enum Value { Null, Bool(bool), Number(Number), String(String), Array(Vec&lt;Value&gt;), Object(Map&lt;String, Value&gt;), } Any valid JSON can be represented with that type without needing to know anything at all about the schema of the JSON before hand. Now you can do let json = serde_json::from_str(some_json_str)?; // propagate the error up the stack if it's invalid json let some_key = json["some_key"]; // library will default to a JSON `null` if `some_key` doesn't exist let some_other = json.get("some_key").ok_or(Err("schema fail"))?; // get the key or propagate an error about a schema fail 
This is extremely detailed and thought through, congratulations and thank you! There are a few ‚Äúbold choices‚Äù if I may say (uninitialized properties for example) but it all seems to make sense and go in a great direction for PHP.
Well, you are just using properties on the objects and using the default dtor, so the objects themselves will be freed by PHP. However, you're allocating a single big stack there. You add to it ... add to it .. and add to it, but never reuse them. PHP has no knowledge of your stack and can't clean it up for you automagically. You'll have to free (i.e. maintain a free-list of) not used carray structures. This is as simple as just keeping a pointer to the current head of the list and have the pointer within the stack always point to the previous free list entry. So each time you stop using a specific carray struct, you'll have to add it to the free list. Otherwise, obviously, your memory consumption will explode over time.
I was skeptical of the 7.3 vs 7.0 performance claims so I ran my [php-benchmark](https://github.com/scottchiefbaker/php-benchmark) scripts and got ~25% increase. PHP Version: 7.0.30 Serialize | JSON Encode | var_export() +----------------------------------------+ Serialize | N/A | 104.32% | 519.21% | JSON Encode | 95.86% | N/A | 497.73% | var_export() | 19.26% | 20.09% | N/A | +----------------------------------------+ Serialize = 535,348 iterations per second JSON Encode = 513,197 iterations per second var_export() = 103,108 iterations per second PHP Version: 7.3.0alpha1 JSON Encode | Serialize | var_export() +----------------------------------------+ JSON Encode | N/A | 109% | 580.1% | Serialize | 91.75% | N/A | 532.22% | var_export() | 17.24% | 18.79% | N/A | +----------------------------------------+ JSON Encode = 656,464 iterations per second Serialize = 602,278 iterations per second var_export() = 113,163 iterations per second and PHP Version: 7.0.30 trim | rtrim + ltrim | regexp | find + substr +-----------------------------------------------------+ trim | N/A | 114.52% | 326.91% | 629.89% | rtrim + ltrim | 87.32% | N/A | 285.45% | 550.01% | regexp | 30.59% | 35.03% | N/A | 192.68% | find + substr | 15.88% | 18.18% | 51.9% | N/A | +-----------------------------------------------------+ trim = 2,543,741 iterations per second rtrim + ltrim = 2,221,139 iterations per second regexp = 778,110 iterations per second find + substr = 403,839 iterations per second PHP Version: 7.3.0alpha1 trim | rtrim + ltrim | regexp | find + substr +-----------------------------------------------------+ trim | N/A | 130.49% | 369.82% | 663.7% | rtrim + ltrim | 76.64% | N/A | 283.41% | 508.63% | regexp | 27.04% | 35.28% | N/A | 179.47% | find + substr | 15.07% | 19.66% | 55.72% | N/A | +-----------------------------------------------------+ trim = 3,601,850 iterations per second rtrim + ltrim = 2,760,279 iterations per second regexp = 973,959 iterations per second find + substr = 542,693 iterations per second
Thank you for your reply, At the moment we host on shared hostings, so don't need to set-up environment. Looking for something simple and reliable(that can't suddenly break). I was looking into ansible, but it's more complex tool than Capistrano/Deployer, so [more like to break from time to time](https://www.reddit.com/r/ansible/comments/739zdr/is_it_just_me_or_does_working_with_ansible_kind/). 
How does it compare to Deployer?
&gt; I would consider moving away from shared hosting to a VPS Great suggestion, we are considering this for a while, it will be cheaper too. But out current hosting(nexcess) don't give us any reasons at the moment. No downtimes, always help(install SSL), etc. So for now will stay on shared.
&gt; I realized I had no way to step through an observer class I had written You've tried XDebug right, it works really well and will trigger and allow you to step through your observer, unless your observer is never triggered..
Generics come in handy when you encounter a wrapper like this: class Cache { public function __construct($client) { $this-&gt;client = $client; } public function __call(string $name, array $arguments) { return $this-&gt;client-&gt;$name(...$arguments); } } $m = new Memcached(); $m-&gt;addServer('127.0.0.1', 11211); $cache = new Cache($m) $cache-&gt;set('foo', 'bar'); Where valid clients can beMemcache or Memcached or ThirdPartyHomeMadeMemcached or TestingCache where the implementations are similar enough that using any of these makes sense. Without generics I don't get any code hints and $cache-&gt;set() will be a magic method that could horribly go wrong. If instead It looked like class Cache&lt;T&gt; { ... } // ... $cache = new Cache&lt;Memcached&gt;($m) $cache-&gt;set('foo', 'bar'); Hot swapping the client would be much more robust. *Source:* [*https://www.reddit.com/r/PHP/comments/6ee1jm/what\_the\_hell\_are\_generics\_and\_would\_i\_want\_them/*](https://www.reddit.com/r/PHP/comments/6ee1jm/what_the_hell_are_generics_and_would_i_want_them/)
Off topic but anyone know how to convert MySQL to MySQLi?
Yup nice, [phoronix.com](https://phoronix.com)'s benchmarks are usually spot on. 
Not sure what your complain is, it's far from being Laravel specific. But yes I would fail there: there is already an entity with that ID and it is not acceptable. How you handle this failure however depends a lot of your situation.
Really üëè good üëè
Yeah, that‚Äôs what I‚Äôm using currently. It‚Äôs just really finicky to get setup to interface correctly with phpstorm from what I‚Äôve experienced. Works some of the time but not always, just like Magento
This method is eloquent's implementation for handling the failure of inserting duplicate records, already. Yes, in the real world you will typically have a unique constraint already, but adding it to OP's example will still have an unintended outcome. Calling firstOrCreate should always give you back an instance of the model, whether it's a new record or an old one. Adding a unique key to OP's case would cause the consecutive jobs to throw an error instead of selecting the existing record, when it should return the already created instance.
This looks awesome, a ton of effort and thought has gone into this RFC. It's stuff like this that keeps PHP moving forward!
Thanks for undertaking this RFC! I really hope this passes. Such a huge missing feature in PHP.
And `array_keys()` is being used here to duplicate the function of the proposed new functions. The new funcs are basically `reset()` and `end()`.. He apparntly has a performance crucial use case where he cant use `end`. I honesty would like an example 
I actually really like that approach - it solves one of my major irritations with non-nullable properties in e.g. Swift, by trading a touch of ‚Äúpurity‚Äù and a runtime error (instead of a compile-time one) for a lot of usability. At least in theory. I‚Äôve only read the RFC, not actually used the code in practice. 
He just have big arrays and using array_keys() create a new big array of keys, consuming extra memory. You seem to don't see the fact array_keys() creates a new array. The point of the proposed functions is to get the first and last keys without having to create an intermediate array.
&gt; The point of the proposed functions is to get the first and last keys without having to create an intermediate array. http://php.net/manual/en/function.reset.php returns the first value of an array http://php.net/manual/en/function.end.php returns the last value of an array I'm 100% aware that `array_keys()` creates a new array. This whole thread using array_keys() began as an exercise to avoid `reset` and `end`'s side effect of moving the internal pointer of the array. My question. When is that an issue?!.. especially in the context of the "tight loop"
Reread the thread.
His concern was: &gt; You shouldn't need to copy the entire array just to get a single key/value from it. He is not talking about reset() or end() but the usage of array_keys()
https://www.youtube.com/watch?v=P3ALwKeSEYs I'll leave this here.
Looks extremely good. I think it handles some painful edge cases, particularly around initialised properties, very well. Fingers crossed we get to see this in a future release.
Yes
This looks great, really addresses most of my remaining gripes with holes in PHP's type system.
### Recap: &amp;nbsp; OP: Here's an RFC for a function function to get the last value of an array without affecting the array's internal pointer ME: That can be accomplished with $keys = array_keys($array); $key = end($keys); $value = $array[$key]; "He": That creates a temporary array I need lots of performance in a tight loop Me: "Can you give an example of a tight loop where you're getting the first or last value of an array and reset or end are unacceptable?" You: ARRAY_KEYS()! This thread is about array_keys!
The handling of types seems inconsistent with what PHP already has. In this proposal: public float $foo = 42; // OK public float $foo = 42.0; // OK public float $foo = "42"; // TypeError public float $foo = "foo"; // TypeError If this were an argument type without strict types: public float $foo = 42; // OK public float $foo = 42.0; // OK public float $foo = "42"; // OK public float $foo = "foo"; // TypeError If this were an argument type WITH strict types: public float $foo = 42; // OK public float $foo = 42.0; // TypeError public float $foo = "42"; // TypeError public float $foo = "foo"; // TypeError
The same way you print everything else - use the echo command...
echo what?
tell me the full code echo "?????????"; ?
&gt; If this were an argument type WITH strict types: &gt; public float $foo = 42; // OK &gt; public float $foo = 42.0; // TypeError &gt; public float $foo = "42"; // TypeError &gt; public float $foo = "foo"; // TypeError This is wrong. First, I think you swapped `42.0` and `42`. Secondly it's wrong. See https://3v4l.org/0ak7S
I did swap 42.0 and 42, indeed. Fixed in the original comment. As for the other... so we can use integers as floats, but we can't use round floats as integers in strict types... TIL. This... is why I don't use strict types.
echo $password;
have you ever used curl in php?
for check if the password is right if ( $password == $password) { echo $password; } ???????????????
Love it! They really thought about all the edge cases here. 
&gt; "He": That creates a temporary array I need lots of performance in a tight loop &gt; Me: "Can you give an example of a tight loop where you're getting the first or last value of an array and reset or end are unacceptable?" As I said your question is unrelated to his concerns. 
Such an amazingly detailed RFC. Thanks /u/bwoebi and /u/nikic A few questions are coming to mind. With the addition of `uninitialized` for typed properties, wouldn't it make sense to make the behaviour of untyped properties the same. Now they are `null`: https://3v4l.org/FFAZs How will uninitialized properties behave in checks? For example: public int $val; // .... if ($this-&gt;val) {} Will it evaluate to `false`? Throw an error? Does it make sense to add an `is_uninitialized` function? And last, can `uninitialized` be compared to JavaScript's `undefined`? Does it make sense to choose `undefined` as a name?
The easiest way for me was to install two versions of xampp one for 5.6 and one for 7. So you can easily switch between the xampp environments with the individual control panels. https://stackoverflow.com/questions/45790160/is-there-way-to-use-two-php-versions-in-xampp
I prefer `public static function` since then the access modifier is before the stuff describing how the function works. However, since both approaches are correct it is more important that you and your coworkers stay consistent throughout your code base.
COME ON, why on the Earth would you write something like `if ($a['value'] ?? null === null) {`?! And even if you do, why don't you consider operator precedence first?
IMHO I think the access modifier `public` should be first because that helps me as a reader of the class to easily identify the API of the class by scanning the first word of each method definition.
Aside from it being the accepted standard across multiple languages (not even just PHP), [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#1-overview) says `public static function`.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**PSR-2-coding-style-guide.md#1-overview** (master ‚Üí 7297fab)](https://github.com/php-fig/fig-standards/blob/7297fabb4428799861a642e29859ff52266a80c8/accepted/PSR-2-coding-style-guide.md#1-overview) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e11di7g.)
 üëè üëè üëè RFC üëè üëè üëè REVIEW üëè üëè üëè 
https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md#46-abstract-final-and-static &gt;When present, the abstract and final declarations MUST precede the visibility declaration. &gt;When present, the static declaration MUST come after the visibility declaration.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**extended-coding-style-guide.md#46-abstract-final-and-static** (master ‚Üí 7297fab)](https://github.com/php-fig/fig-standards/blob/7297fabb4428799861a642e29859ff52266a80c8/proposed/extended-coding-style-guide.md#46-abstract-final-and-static) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e11dkcf.)
If code hints is the _only_ legitimate use for generics in PHP, I'd argue we don't need it in the language and that it can be done in other ways like code annotations using docblocks or similar. I'm not arguing against it - I'm simply asking for examples where PHP would _legitimately_ benefit from generics.
If I remember correctly the first proposal &amp; implementation had severe performance costs. Is that fixed?
Don't forget to KYS yourself.
First of all, awesome RFC! I can't wait to see this implemented! Two minor points though: \- The callable thing, just disallow it for now and solve it at a later point, however, do so in the same PHP version please. \- This RFC doesn't mention private write, public read, but that would be a great addition as I don't want to have my properties being modified from a public context (which reduces the usefulness of this RFC by like 1&amp;#37;). However, I believe this issue should also be solved in its own RFC.
No shit. Had to develop plugins for it once. I still can't get the taste of ass out of my mouth and this was eight months ago
Because some developers are drawn towards using new shiny things even when they are wildly inappropriate for the application at hand?
Why function Foo() :int{} instead of function int Foo(){}?
Sure but the underlying problem is concurrency. The problem will remain even if you change `firstOrCreate()` for your own method/function. Adding a unique key is not here to solve the issue, but to guarantee the data integrity. Now an eventual fix could be to catch unique key constraint violation with `firstOrCreate()` and do a get again when met (but maybe that's what it is already doing?)
When \`$a\['value'\] === 0\` it evaluate to false in the if statement so it is perfectly normal the if block is not executed. \`$value = $a\['value'\] ?? 'default\` is a shortcut for \`$value = isset($a\['value'\]) ? $a\['value'\] : 'default';\` so I dont see the problem here.
[PHP RFC] Replace PHP syntax with Java.
Apart from the fact that isset() is a function call which is marginally slower than a conditional operand, sometimes code are ported from another language and it is more of a direct port than replacing all the code with isset(), so no, it is not just a shiny new thing.
&gt; function call which is marginally slower OMG
And yet, if(isset()) seems so much more readable.
What the.. okey, lets concentrate on the topic only :) There were several times where I nearly did the same mistake, but then after thinking about it.. the coalescing operator is just doing a `isset` on the value, so you still need to use shorthand for quite often times. The one fact that is overseen very fast. `null`ing or `unset`ing or not declaring at all is enough that `isset` will return false. Empty string `''`, zero `0` will let `isset` return true. So you have to be careful and think if you want to do a `isset` or actually a `empty` check.
This and generics is something I really miss in PHP. I'm totally in favour of this RFC.
Literally wasting several microseconds here! ^/s
Now that, is awesome.
\*nanoseconds
isset is not even a function. it looks like a function but it's a built-in language construct. https://3v4l.org/KUF6Z Please don't talk about performance if you don't know these things.
Don't know why, but i can't help but feel that "nullable" should be what this RFC calls "uninitialized". If there is no default value, it can be null. It just feels redundant to include a nullable type for properties.
Don't know why, but i can't help but feel that "nullable" should be what this RFC calls "uninitialized". If there is no default value, it can be null. It just feels redundant to include a nullable type for properties.
One simple answer: http://php.net/manual/fa/language.operators.precedence.php Since null coalesce is shorthand for the ternary operator, the `!==` precedes `??`.
Exactly, it's interpreted as `$var ?? (null !== null)`.
This is explained in the original RFC: https://wiki.php.net/rfc/return_types#position_of_type_declaration &gt; The former position has been proposed in the past and the RFCs were either declined or withdrawn. One cited issue is that many developers wanted to preserve the ability to search for function foo to be able to find the definition for foo. A recent discussion about [removing the function keyword](http://marc.info/?t=141235344900003&amp;r=1&amp;w=2) has several comments that re-emphasized the value in preserving this. &gt; &gt; The latter position is used in several languages; notably C++11 also places the return type after the parameter lists for certain constructs such as lambdas and auto-deducing return types. &gt; &gt; Declaring the return type after the parameter list had no shift/reduce conflicts in the parser.
&gt; With the addition of uninitialized for typed properties, wouldn't it make sense to make the behaviour of untyped properties the same? Now they are null: https://3v4l.org/FFAZs Ideally yes, but practically this would be a huge BC break. The value proposition of doing this for untyped properties is also rather minor. For typed properties this kind of null initialization would essentially make all property types nullable, which is famously known as the "billion dollar mistake". For untyped properties null is always a valid value anyway. &gt; And last, can uninitialized be compared to JavaScript's undefined? Does it make sense to choose undefined as a name? It's not really comparable. Undefined in JS is mostly a "normal" value like null. Interacting with it does not generate errors. Contrary to that, accessing anything in uninitialized state results in errors of varying level in PHP. For typed properties it is a hard TypeError, for many other things (undefined variable, undefined array offset, unset untyped property) it's usually a notice.
And Enums.
Changing the behavior of untyped properties would be quite a large BC break. There's a lot of code assuming that an unassigned (but declared) property will just be null, without warning. undefined - no, you cannot assign "undefined" to an arbitrary value (just properties, by explicitly unsetting them), nor compare uninitialized typed properties against something. In Javascript you can pass undefined around, have it implicitly cast to empty string (if appending to a string) etc.; the uninitialized property will throw immediately upon access. It's a much stronger guarantee here.
Something like C# allows would be bananas, but I think that's kinda out of the scope of typed RFCs and duty for a different RFC. For context, those that don't use C#: ``` class Example { public string Name { public get; private set; } } ``` This would allow to get the "Name" property from anywhere in our code and limit the update of that same property's value to the class "Example" itself.
The callable thing is disabled. However unlikely we'll solve it for 7.3 - but it doesn't matter, we can implement a solution anytime without any BC break. There have been quite some proposals for property accessors in the past (or just a readonly attribute) - but as you say, it's out of scope of this RFC.
[PHP RFC] Bring capabilities which nearly every typed language with classes has into PHP, with similar syntax to them all.
By the way, default values of properties are _always_ subject to strict types, no matter the strict_types setting, in accordance with function parameters.
If for nothing else, it's definitely a great tool for static analysis and optimization - you can just know after reading the property, that the value is an instance of X. You possibly can then elide a lot of checks and runtime fetching. Additionally, it tells you "the value was never assigned" instead of "somehow this value is null - was it reset somewhere? was it never set? I don't know."
What is the difference between Numpy and [Judy](http://php.net/manual/en/intro.judy.php)?
Thanks for the great work to the both of you! I love it and really hope it passes. I think this it what many people were waiting for.
Indeed, it \_can\_ be solved for any other version. I'm not sure if it's worth adding this whole feature as a rush to 7.3 without the callable fix though. I personally don't really mind it too much, I'd love to see this feature in php by yesterday! The property accessors should be easier to work out now that typed properties might become a thing.
Imagine if people read the documentation before complaining about "quirks". StackOverflow would be a deserted wasteland. I find it funny that OP deleted his post and account.
The callable issue also affects function parameters and return types, albeit in a bit more minor way. Hence we're looking forward to solve that in a completely different RFC and now concentrating on the main typed properties RFC. Fixing the callable issue will require a lengthier discussion and it may, in the absolute worst case take years until we find a solution everyone can get on board with. I don't really want to make typed props dependent on that, and it's neither essential for it.
haha awesome :D
The concern: getting first/last value of array with performance in mind and not moving the internal pointer., supposedly the new array_value_last() func saves the day. how is my question : "can you provide an example where `end()` won't work please" not related? I maintain that array_value_last(), and my inefficient implementation using array_keys is a solution in search of a problem.. Show my that I'm wrong
The discussion is all about performance of getting the first/last **key**. Nobody cares about the first and last value because as it is trivial.
OK... example of when you'd need the first/last key when `reset($array); key($array);` wouldn't work
I agree this one is a good solution.
Reading the discussions on PHP and its RFCs always makes me boil up with rage, for some reason. Far too often, the initial response is "I don't see the benefit, let's keep it how it is".
So you don't use strict types because it's strictly typed?
I stopped hoping to have generics someday with php. My new take on this: PHP does not have this feature so I just don't care, put a descriptive docblock and don't try to find an approach to validate an array of values. Eventually throw a descriptive exception when the code execution fails because of an array value having the wrong type.
If you follow the logic of my mistake, they're actually less strict than I thought. Thing is there's no rhyme or reason to it. You can use (int) 42 as float, but not (float) 42 as int. You tell me how that makes sense.
Played with it today a bit (was using symfony) Seems really quite promising so far. Hope that this project will not die but will be adopted by php community like composer was before. Also what is nice, that it is rather fast ( for simple hello world app I am constantly getting \~4ms respond time. Does anybody now, if there is some documentation page, which shows every possible options that can be used in .rr.yml file?
Hi, right now example file shows all the possible options for .rr file. We will be adding more down the road. Documentation is coming as well (we have to dedicate some time to build a website and etc). Regarding dying: this is not a personal project but the engine baked by our company (we are using it in production), we are not planning to abandon it and ready to maintain this version it for couple years at least, the same way as we do with our PHP framework.
It's not really that hard. Old: $db = mysql_connect($hostname, $username, $password, $database); $result = mysql_query($sql); New: $db = mysqli_connect($hostname, $username, $password, $database); $result = mysqli_query($db, $sql); Or: $db = new mysqli($hostname, $username, $password, $database); $result = $db-&gt;query($sql);
I hope this makes people more inclined to initialise properties inside the constructor. I view property initialisation independent of the constructor to be an antipattern, although that may just be because it‚Äôs impossible to perform timely static analysis otherwise.
I see, thanks for feedback. It is really great to hear that you are using it in production and it is not just another homebrew tool. From your experience, do you have any tips what usually can go wrong when migrating php application from ngingx/apache to RoadRunner (like loss of database connection or something similar) Also what is your opinion about adding it, maybe, to packagist so it can be installed via composer? Cause from what I've checked, this https://packagist.org/packages/spiral/roadrunner only downloads source files and not binary, ready to use tool. 
\&gt; Additionally, it tells you "the value was never assigned" instead of "somehow this value is null - was it reset somewhere? was it never set? I don't know." But from what I read in the RFC, a value could have been assigned and then cleared using \`\`unset()\`\` if it is "uninitialized".
1) Database connections and any pipe/socket is the potential point of failure. Close all the connections after each iteration. 2) Consider calling gc_collect_cycles after each execution if you want to keep memory low. 2) Watch memory leaks - you have to be more picky about what components you use. Workers will be restarted in case of memory leak but it should not be hard to completely avoid this issue by properly designing your application. 3) Watch state pollution (i.e. globals or user data cache in memory), again, with PSR7 it is much easier to avoid. 4) Make sure that you are not using RR to serve too many static files (prefer using it for APIs). RR can handle it without any problem but it is always better to use nginx at top of it (in proxy mode) since it has been optimized for such tasks. 5) Streaming content from PHP is not supported yet, so avoid sending large files to the output (until the next version is released), again, it should not be a problem for the APIs. 6) Make sure NOT to listen 0.0.0.0 in RPC service. 7) Connect to worker using pipes for higher performance (unix sockets just a bit slower). 8) Tweak your pool timings to the values you like (right now it's 60 seconds to allocate worker = request timeout). 9) A number of workers = number of CPU threads in your system. We are not planning to deliver binary file thought composer, I do not think this is a great idea. You can install RR globally and use it on multiple projects. We build RR custom for each of our projects (with some intense logic moved into Golang in a form of middleware/service), it's actually pretty easy to do: 1) install all the deps (`vgo` or `go get ./...`) 2) put https://github.com/spiral/roadrunner/blob/master/cmd/rr/main.go into the root of your 3) run `go run main.go` or `go build` This way you can really achieve the best possible results by dedicating part of infrastructure or business logic (like service discovery, logging, WebSockets) to Golang.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [spiral/roadrunner/.../**main.go** (master ‚Üí fe514d8)](https://github.com/spiral/roadrunner/blob/fe514d88ac711afd64e2d730449b737df15f3c80/cmd/rr/main.go) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e11swjk.)
Correct, however properties being unset() is quite rare. (At least currently it is.) Possibly that changes in future - still, trivial to spot locations where a property is unset with a simple grep.
https://www.youtube.com/watch?v=bYMUbavj9uE&amp;t=37m35s
This was really substantial answer, thanks. Regarding content streaming, so you do have plans to implement it in future releases, correct?
Ok, I've been trying to understand this for a while now and I finally found the reasoning behind this. This is basically only for public variables, right? Because with accessors the type is already hinted and will throw an error if its anything but the expected type. class Example { public int $number1; protected int $number2; public function getNumber2 (): int { return $this-&gt;number2; } } $example-&gt;number1; // Uninitialized as per the RFC $example-&gt;getNumber2(); // TypeError, cannot be null I've basically never worked with public variables so I must admit that I didn't think of this. My argument against this would be the fact the tedious `= null;` everywhere, but if given `public ?int $var;` would default the property to null, and not "uninitialized" it would benefit and go inline with PHP as a language. `public int $var;` would be a special case and only this would be "uninitialized".
Yes, it's 60% complete. We simply have not met the use case when we need it.
I'd like to see Structs too, (mainly for my silly personal project)
To be honest it sounds like a great compromise to ignore callables in this RFC. `Closure` type already has a plenty of advantages over the more generic `callable` type. It exists and can be typehinted as function arguments ever since PHP 5.3. If anyone wants to instantly benefit from new features, then it's not that hard to convert callables to closures where needed in the codebase: // since PHP 7.1 $closure = Closure::fromCallable($callable); // since PHP 5.3 $closure = function () use ($callable) { return call_user_func_array($callable, func_get_args()); }; In this case wouldn't it make sense to focus new features only to the Closure type in the future versions of PHP, and ignore callables? That way callables will die organically, along with their legacy weird stuff.
Tbh, a typing system that forces you to write float literals with .0 at the end would be kind of ridiculous and inconvenient. Even strict and statically typed languages do not do this, instead quietly casting to float or to a higher precision - whether by arithmetic operations, by assignment, or by setting a return value. (The one exception I can think of is Haskell, where it would complicate the type inference.) There's a stronger case against auto-casting strings to numeric types.
It's about the fact that you don't need such implementation. Notice I used null-coalesce to mimic your "ignore non-existing keys" behavior, which probably creates more bugs than it solves actual problems. $lastVeggie = end($array['veggies'] ?? []); $firstFruit = reset($array['veggies'] ?? []); $firstGroup = reset($array ?? []); $veggieCount = count($array['veggies'] ?? []); $firstGroupCount = count(reset($array['veggies'] ?? [])); Code like yours is basically why some people hate PHP. Userland implementations that take a problem and make it more complex than it actually is. Notice how my calls also use less characters in total for each line.
Facebook is reading this thread and crying. 
you're accessing the array directly, that's cool. I'm passing a dynamic path string Do people like Symfony? https://symfony.com/doc/current/components/property_access.html https://github.com/symfony/property-access 
I somewhat prefer static public, since static stuff is such a special (rare) case in my code that I want to see it right away. That or put it just right after constructor. 
You're not "passing a dynamic path string", think a second what you actually do. You introduce additional function call overhead, additional memory required, you copy arrays multiple times. Try to understand what your own function does compared to the _short_, _native_ version of it. PropertyAccess has a completely different purpose than your little function and a much broader use. Its primary use is Symfony's expression language than can do a lot more than count/reset on arrays, you can introduce whole functions to it, you can do comparisons etc. It also integrates into the Doctrine DQL and it's there to resolve Twig variables. It also doesn't abstract the language itself, it only abstracts the concept of getters/setters/issers and makes array/object access more "JavaScript-like". It's more an optional lazy-loading-mechanism. And in the end, you'd still do something like `count(array.veggies)` in Symfony expressions. I'd not go as far and compare your function to Symfony's PropertyAccess. PropertyAccess solves an actual problem (e.g. will `someObject.firstName` respect `getFirstName()`? Will `order.active` respect `isActive()`, which might depend on another value?), your function doesn't solve a specific problem.
An idea is to have autopromotion of callables to Closures - so anything callable would be accepted to the callable variable/property/return and a subsequent access would return an Closure accordingly bound to the callers/assigning/returning scope. But that's just floating ideas, I'm not sure how viable this is, perhaps it's also too much of a BC break. We'll have to determine that.
&gt; PropertyAccess has a completely different purpose than your little function and a much broader use. yes. PropertyAccess also works on Objects.. it also &gt; introduce additional function call overhead, additional memory required, you copy arrays multiple times and is their implementation, that much different? https://github.com/symfony/property-access/blob/master/PropertyAccessor.php#L249 if ($i + 1 &lt; $propertyPath-&gt;getLength()) { if (isset($zval[self::REF])) { $zval[self::VALUE][$property] = array(); $zval[self::REF] = $zval[self::VALUE]; } else { $zval[self::VALUE] = array($property =&gt; array()); } } &gt; "ignore non-existing keys" behavior, which probably creates more bugs than it solves actual problems.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [symfony/property-access/.../**PropertyAccessor.php#L249** (master ‚Üí e497246)](https://github.com/symfony/property-access/blob/e4972469c892e4d0308399b9b03a49c829f0decf/PropertyAccessor.php#L249) ---- 
But does your function solve a specific problem? PropertyAccess does add overhead, but for a good cause (I‚Äôd prefer it just being plain PHP Syntax, but the community seems to prefer JS-style access, there‚Äôs that). You can‚Äôt have the same functionality as PropertyAccess on just a few lines of code. There is no easy, native replacement for it. But you can replace your whole function with code that is essentially shorter, easier to read and doesn‚Äôt add any overhead. I‚Äôve given you code samples, it does the same thing, it‚Äôs shorter and it doesn‚Äôt require a full 50-lines function to operate. Tell me if you can do the same for PropertyAccess.
&gt; But does your function solve a specific problem? Yes, I prefer `$bar = arrayPathGet($array, 'something.__first__.foo.bar');` over $something = $array['something'] ?? []; $first = reset($something); $bar = $first['foo']['bar'] ?? null; also PHP 5.x doesn't have the null coalescing operator
Why would you want to left publicly accessible variable not initialized after object instantiation at all?
And if someone uses PhpStorm/Idea Ultimate, Php Inspections (EA Extended) (https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-) has "PSR-compliant modifiers order" rule with a quick-fix covering this case.
Exactly. Which is why I don't get the uninitialized state at all.
Without the piece of code we can't really tell if it's really a bug...
Close your IDE, quickly 
This is an amazing addition. I‚Äôm with PHP since beginning of PHP 4 era and this is one of the best addition to the language syntax I‚Äôve seen.
Everyknows how to do the db, but what if you have a the whole code in sql?
I use Wamp Server with Win 7 and 10 and have several version of PHP running in different vhosts. I used the instructions at this link to get started: [https://commaster.net/content/installing-php-fastcgi-and-zend-opcache-wampserver](https://commaster.net/content/installing-php-fastcgi-and-zend-opcache-wampserver) For my setup, I then override the FcgidInitialEnv PHPRC setting in each vhost to point at the desired PHP version.
Are you sure, like "I triple checked the my code and the documentation and this isn't the expected behavior? It would be great if you could tell us what you found or shared a phpt file so others can replicate it. Otherwise, if you did find a bug, you need to report it: https://bugs.php.net/how-to-report.php
You‚Äôll have to be a little more specific.
MySQL and MySQLi are different so when running it on xampp which only supports a new version of PHP there will be errors.
Show your code or it didn‚Äôt happen.
Right, you have to replace all of your `mysql_*` function calls with `mysqli_*` calls. Usually the functions are the same except mysqli requires a $link identifier as the first argument. So it's mostly a matter of doing a find and replace. I can't make it much simpler than that.
[Probably a feature](https://geekwhisperin.files.wordpress.com/2009/09/bug-vs-feature.jpg)
There's no reason to get emotional at all. PHP is written by people, and people make mistakes all the time. Yours is not the first and won't be the last bug. Bugs are part of this show. Please reduce the offending code to a minimum and verify that it is indeed a bug with the latest stable release of PHP. Then go to [https://bugs.php.net](https://bugs.php.net/how-to-report.php) and search if that bug was already reported. If so check if you can contribute anything valuable to that existing bug (me too is not helpful). Otherwise write a bug report yourself. Just follow their template to give them a minimal example, the expected behaviour and the actual behaviour. Thank you for your contribution.
you could replace the functions or use mysql-compat package https://github.com/mattbit/mysql-compat
[https://bugs.php.net/bug.php?id=76505](https://bugs.php.net/bug.php?id=76505) I posted a question on StackOverflow and someone else filed it as a bug.
I wouldn't expect ansible to suddenly break unless you run into a BC break from upgrading. But any deployment can break. It is only as good as you set it up and keep the implementation up to date with the environment it targets. Apart from upgrading and operational mistakes, ansible is very reliable. Imho deployer is a joke. 
You can also just de-reference $something = $array['something'] ?? []; $bar = reset($something)['foo']['bar'] ?? null; Also notice, reset doesn't create a copy, it works by reference (regarding your second comment in your code) Based on the fact that this uses basic PHP functions (and exactly one of them) and you use a userland function that needs to be understood first, this is surely more "readable", or rather, understandable. &gt; also PHP 5.x doesn't have the null coalescing operator Then it is time to upgrade. No excuses. http://php.net/supported-versions.php But I don't care man, really. You've been asking what's wrong with it, I named a bunch of reasons, if all you want to do is defend it with all you got and find, do just that, but my reasons were valid. You are free to use whatever coding style you like and you're free to bloat your code however you like, that's the nice thing about programming. &gt; Are these really necessary? The functions coming in this RFC are exactly what you've been asking for, one-liners to do the exact same thing your function tries to achive, just in a normal, native way where there is no string-parsing or some kind of special access syntax required, where no one has to check the function and its code first to look how it works, what the valid keys are etc.
the new rfc functions don't do what symfony's PropertyAccess class or my function do: get nested value from path string.. I shouldn't have brought the arrayGetValue() helper function into the conversation &gt; Also notice, reset doesn't create a copy It returns by value, not by reference 
I'd recommend reading https://wiki.php.net/rfc/typed_properties_v2#property_initialization. I've extended it a bit to talk more about the nullable property case. The TL;DR is a) making all property types nullable destroys the type-system and b) even for nullable properties, you still want to force explicit initialization. Most properties are intended to be initialized in the constructor, and having implicit defaults hides cases where this is not happening correctly. &gt; My argument against this would be the fact the tedious = null; everywhere Do your objects commonly have no constructors, or are not fully initialized by the constructor? That is rather unusual to me. If you have proper constructors, then there is no reason to use `=null` defaults. In fact, you are strongly encouraged not to.
And take a look at phpcs/phpcbf. Use a stricter ruleset (Doctrine, Slevomat Coding Standard) to learn best practises. Publishing code in 2018 without return types is a no-go. And why is the class name small caps, `dbcomms::Disconnect()` CamelCase and `getRow` pascalCase? 
&gt; the new rfc functions don't do what symfony's PropertyAccess class or my function do: get nested value via path string (ie "solve a specific problem") I already explained the _vast_ differences between PropertyAccess and your solution. It seems you simply ignored them. You can get nested properties natively. It's called array access. $array['look']['a']['very']['deep']['value'] and you can also dereference freely $array['look']()-&gt;here('be')['really']()['deep']['abstraction'] Symfony's PropertyAccess came into existence long before we had stuff like array de-referencing. If it wasn't for millions of applications already using them this way and millions of people already knowing them this way, they could, in fact, just as well use native PHP expressions these days (except for Twig, which simply has its own syntax overall) and it wouldn't be needed at all. The only actual problem it solves (other than your function, which, again, solves none) is the resolving of setters/getters/issers, which allows for some nice lazy-loading mechanisms. The property paths themself often have to be passed as configuration values for e.g. form values, choice labels etc. which is a thing that will only be solved with arrow functions, as simple closures have a too bloated syntax right now and would be the configuration unreadable. &gt; It returns by value, not by reference That it does. &gt; You don't use a framework or any libraries? no helper classes? if it ain't native, it's crap? perhaps you write in op-code. To each their own Now you're simply exaggerating. I am not a "hardline native code defender" or whatever kind of image you got there right now, but we don't have to abstract just for the sake of abstraction. What you perceive as "readable" might be absolutely unreadable for other people. But PHP code has to be readable, as it's the skill required to do PHP at all. It's okay you like to read your variables in the form of a string-based property path. I prefer reading PHP code. My IDE does, too. Pretty sure your IDE doesn't know what it's retrieving there. And in this case the PHP code required to achieve the same result is less and more readable. Let's stop it right there. To each his own. You are free to code however you like. I just wanted to point out some flaws of your approach. If you don't see them as that, good for you. I do. Have a good day
&gt; You can get nested properties natively. It's called array access. and sometime you might have a configuration path or something stored in an database like 'look.a.very.deep.value' [end](https://media.giphy.com/media/4pMX5rJ4PYAEM/giphy.gif)
Great work! We need this yesterday :) Quick question: Would this only apply to classes or functions as well? Eg.: function f(): void { int $x = 0; }
PHPStorm also supports 'pubsf' macro which is a shortcut for 'public static function'. More here: [https://gist.github.com/JohnD-EE/536ef8c95e7dfbb9d521#code-generation](https://gist.github.com/JohnD-EE/536ef8c95e7dfbb9d521#code-generation)
I think maybe you're thinking of the 'array of type' rfc? 
Dramatic
Wanna talk about what you feel went wrong? Maybe we can propose some areas to study to help you better prepare in the future.
I simply had no answer or negative answers to questions that i was asked. Like where is session stored or what class types there are combined with never worked on linux etc. So much i still got to learn
/u/nikic is there any reason this is stopping at class properties and not also getting applied to all variables in general? I like that you'd get a type error when assigning a value to the class property, but right now function arguments can be reassigned with a different type inside the function body and it doesn't complain. Having all 3 cases handled would be fantastic :)
Best advice I can give you is quit focusing on how the event made you feel. Rather distill the feed back and turn it into something useful. Did you not know the answers because you lack experience? (Seems likely since you are applying for an internship). Did you not know the answers because they centered on a system/methodology/framework/pattern you were not familiar with? In essence, why were you not equipped to answer the questions this time around.
I wouldn't expect an intern to know the details of how sessions are stored in PHP. Plus, it depends on your PHP configuration anyway.
Thanks. I think my problem is trying to learn too many tools before i get to know php from a to z. The questions were mostly about plain php and sql and i should have known most of them
Should have doesn't get you anywhere. There is always more to learn, always more to know... Look at it as feedback on where you should continue your studies :-) 
I won't focus much on PHP or any language, but instead the logic, patterns and concepts to some problems.
Take a moment to reflect on your comment: ‚ÄúThe questions were mostly about plain php and sql and i should have known most of them‚Äù First of all how do you know that? Second, regardless of the first being true join a GitHub project othat peaks your interest and contribute. You will learn a lot, there is no substitute for hours of frustration 
Don't worry- i have hired interns based on enthusiasm alone. As someone recruiting people starting out in their career we don't expect you to know everything. 
There is always more to learn but I wouldn‚Äôt have known that for an internship either. You‚Äôre gucci man don‚Äôt beat yourself up about it. 
It is true i want to learn more about the things i never knew before now
Hey man I bombed my first four interviews. Learned a little something from each one ... and I eventually got hired. Just keep trying. You'll get there
Just the same as me! Every interview = experience, after few, next one is easier. Finally you'll get a job/internship. Just keep learning and don't give up, and you'll be fine. 
Once I bombed a php coding test for an internship because I forgot variables start with a $ (was in uni, hadn't written it for a few years!) and wasted most of my time working out why I got what felt like cryptic error messages but probably told me exactly what was wrong. Remembered a minute after the time ran out. Shit happens!
I interview people regularly for developer positions. The person or people interviewing you don't care about what you don't know and can't answer beyond some simple things. We care about what you DO know and CAN answer, and we care about your ability to be honest and not attempt to bullshit us. Especially for an internship, they should be looking for a culture fit and a willingness to learn over anything else. Now, if I ask you: "What are the basic control structures that php supports?" or "What data types does php have?" you should be able to answer those. If you can't tell me what while, for, foreach, if-then-else, try-catch, or switch do or what a function is or how to define and use objects, then you don't know enough about php to be making money working with it even as an intern. You'd be surprised how many people fail those sorts of questions, so if you can answer them you are in better shape than you think.
He doesn't "need" to do anything, jeez. He *may* report it if/when he has the time and will to write a lengthy report and argue ad infinitum with rhe devs about it.
There are quite a few extensions to PHP's current typing capabilities that can be made -- this RFC covers property types, but other common requests are array types (or more generally, generics), union and intersection types, as well as typed local variables. While it is important to keep the overall picture in mind, all of these topics are largely independent of each other and quite complex in themselves. It is best to discuss them in separate RFCs, rather than trying to combine too many things into one. While typed properties and typed local variables have some surface similarity, with both enforcing types on storage locations of some kind, the specifics and the implementations differ. For example, for typed local variables an important issue to resolve would be how it interacts with existing parameter type annotations -- after all, we can't just switch these to disallow reassignments for backward compatibility reasons. From the implementation side, typed properties take care of some parts (in particular everything relating to references should be directly transferable), but full support for typed local variables would require some additional major engine changes.
This would be usable for structs, though, wouldn't it? Or are you thinking of arrays with predefined and/or required keys?
And if you are like me, you are weary of anyone interviewing for an intern position that CAN answer the super tough, challenging questions. Why are they only going for an intern spot, and not a full time engineering role? Are they going to be doing intern level work, or are they trying to pad a resume with work experience with a company that gets name recognition and can put some buzzwords in your experience section? Or worse, did they rote memorize some answers from a website? I know I don't want to bring a convertible intern up to speed just to have them bail for the coasts (I'm in the Midwest) in three months. Realistically I haven't seen much of this but it's something I do keep in mind.
I wonder if PHP would optimize the looping of large arrays of Arrays with the same structure, or arrays of &lt;struct&gt; in the way V8 does
Happened to me a little while ago, I feel for you. :( 
Fair enough. I'm not really in the habit of reassigning to a different type in general, but it's a topic of conversation that keeps coming up with some of my purist friends.
Sounds like a shitty company that you're better off not working for. Go kick ass somewhere else and come back to do a dance on their failing business.
Please tell me what you know about [this pattern](http://freedesignfile.com/upload/2017/07/Fabric-pattern-ethnic-vintage-styles-vectors-04.jpg).
&gt; Once I bombed a php coding test for an internship because I forgot variables start with a $ Happens to everyone. I once bombed a coding test when I forgot how keyboards work.
Technical details you can learn. Don‚Äôt worry about that - the lesson here is if you come away from an interview feeling that shitty that‚Äôs a failure on the interviewers side. Antagonistic interviewing will get you plenty of sociopaths, entirely random if they really have the skills you want.
Nope, typed properties http://php-news.ctrl-f5.net/message/php.internals/93858 
It happens to everyone . One time I froze up when they asked me what the difference between an Abstract Class vs an Interface was. Another time they asked what my phone number was and I literally could not think of my own phone number. It was a very long and awkward amount of time, until I eventually had to look it up. It all passes.
&gt; The rule is that multiple adjectives are always ranked accordingly: opinion, size, age, shape, colour, origin, material, purpose. I submit that `public` would be an origin, and `static`, in this case, would be a purpose. `public` should be before `static`.
lmao is this an internship or a mid level SE job
Don't sweat it. I bombed an interview for a company that scoffed at the idea my bookshelf wasn't full of programming books and my name wasn't on a laundry list of open source projects. It was for an entry level 40k position. They didn't even ask the normal "tell me about yourself" questions. But I learned from the interview and remembered a lot of the tough questions. Now I'm more prepared the next time they come up.
Email them and say that you'd like a copy of the questions they asked you, then find the solution(s) for them in your own time. That's what this profession is all about; to figure things out even though you have no previous experience in that particular area. This won't give you the job but you'll have a better chance at the next one. Good luck!
I think I've been asked abstract vs interface in 90% of my interviews. It's a question I would recommend being comfortable answering.
Don't feel too bad. I had a technical phone screen at Facebook and it went really well. I solved the problem (create an ASCII to integer converter} and still got passed over. Sometimes it doesn't matter how good you are. Don't sweat it. Do some more interview prep, pick yourself up, and try again. You can do it!
Yep and you can bet every time after that I was ready. The point is, OP, don‚Äôt worry about it, it happens to everyone. You will get past it.
That a new JS framework?
For what it‚Äôs worth, being a good programmer and a good interviewer are two completely different skills. Even if it didn‚Äôt go well, it could easily be on them for not asking good or useful questions. 
If you get the job, then awesome. If you didn't, then you now know where to focus so you can learn enough and get that/a similar job sooner than if you _didn't_ interview today. It's like dating -- if you never get rejected, your standards aren't high enough.
Or a company that has choices, a company that got ordered to hire an intern, and so on..
Answer to the session question is "it depends". It's fair to ask a basic session question, but they needed to word it better. The class types question is weird. Like abstract, static, etc? I'd have needed to ask for clarification on that one, personally. Unless you're interviewing for a systems engineer internship, you really only need to know about basic Linux stuff imo. Like permissions, basic commands, etc. These folks seemed to really hardball you, which always makes me wary that they were going to work you as a junior dev but for intern price.
And yet when I interviewed for an internship I was expected to write memcpy and account for overlapping memory addresses.
Sessions are typically stored in a small file on disk. Check your php.ini files.
I would likely have walked out. That's not an internship level question. I know senior devs who would struggle to do that (myself included).
&gt; These folks seemed to really hardball you, which always makes me wary that they were going to work you as a junior dev but for intern price. Bingo.
You obviously never used an actual Java ecommerce solution. It is absolutely worse than anything Magento does wrong. I used fucking Vignette 10 years ago and let me tell you something: It would make you love Magento.
It looks ethnic. Definitely vintage looking...
It looks like a fabric pattern. Something similar to a vintage or ethnic style... 
Bunch of circles layered on top of one another. The image os mirrored.
&gt; Bunch of circles You're hired.
We'll call you.
Thank you, we'll contact you.
Thank you, we'll give you a call if we pick you.
I recently hired an intern after interviewing a number of prospective people. For each applicant, I asked basic questions regarding whichever language the applicant had the most experience with. That portion was maybe 5 minutes to make sure they had learned something in the past. The rest of the interview was centered around the candidate‚Äôs personality and what they were actually interested in. There were several applicants with low-level/hardware experience, for example, who I turned down because it wouldn‚Äôt be a good fit for either of us. The candidate I ultimately chose demonstrated enough knowledge to not need hand-holding, but also showed a desire to learn and grow. His main motivation was to be part of a team, contribute something useful and learn from us. Long story short, an internship should be mutually beneficial, and the interview should be more about seeing if the candidate will be a fit, not if they know everything there is to know about everything. Also, I distinctly remember bombing my first interview. I forget exactly, but they asked me something along the lines of figuring out the amortized time to sort a doubly-linked list of numbers and the best way to accomplish it. My 30 min phone interview lasted probably 12 minutes? But hey, now I‚Äôm accomplished and I hire people. Keep your head up, it‚Äôll get better.
The best thing to do in that case is answer honestly by saying that you don't know. Perhaps explain anything you do happen to know about those topics and how you would approach finding out about them. It could be they just wanted to gauge your process for addressing a problem. As someone who has hired before I'd be happy with that kind of an answer.
I don‚Äôt know JS but I‚Äôve written a lot of jQuery 
What would you think of the following answers... 1. Sessions are stored on the server. 1. There are regular classes, abstract classes, and interfaces.
The only thing I know about abstract vs interface is that in abstract classes you're allowed to use logic, but in interfaces you cannot. 
I've see a bunch of resources on &lt;insert programming language&gt; interview questions. Perhaps you can check them out for knowledge and confidence building 
Seriously? Php.net
Surely, this is a joke.
There is no ‚Äústandard‚Äù for folder structure however if you use Laravel there is some structure already in the default layout (github.com/Laravel/Laravel) Composer will pull in dependencies and allow you to map namespaces to folders and list files that are auto loaded. With Laravels default layout you will get ‚ÄúApp‚Äù namespace mapped with the app directory in PSR-4 style.
[removed]
Don't worry son, success can't get reached without failure. The most important part for this and your future life is to `learn` from it! Take EVERY experience you got and make value out of it. Side question: Do you really need to do a interview for an internship? For my electrical engineering diploma (It seems like there is no translation for it.. I didn't study it.. in Germany it's called Fachabitur, it's like an extra 2 years of specilitation into a direction) I needed an internship for 1 year in a company. At this stage of my life I knew I would love to do someting with IT, but hell I was green behind the ears of doom! I did know NOTHING, less than Jon Snow. I went to a company another friend of mine found.. went there with another friend just with our graduation certificate in our hands. The managing director opened the door and was like "o.O hi?" and we without self-confidence just like "uhm.. we.. wanted to ask if we can do a intership in terms for our school". It was obvious that we had little to no knowledge at all, but he said yes. Did I learn things about electronic only? Actually very little was themed with electric at all.. the only thing was to install lights for an company.. You see.. life is complex and things happen in special ways. Don't feel too bad. Just always give 100% otherwise you can't expect to receive 100%. You can't know whats on the other ways if you don't go this ways. As someone that needs an internship, people (at least should) expect that you make mistakes or have little to no knowledge. Their responsibility is to teach you while you try your best to learn, do many mistakes and learn from them! Good luck and success!
Why bother with PHP 7.1 when you can use PHP 7.2 today? 
For the lazy: http://php.net
[removed]
[removed]
Symfony is one of the best right now. Laravel uses Symfony as well.
I would jump immediately to 7.2 To see if your code is compatible, you can use phpcs with PHPCompatibility. See https://www.sitepoint.com/quick-intro-phpcompatibility-standard-for-phpcs-are-you-php7-ready/
You might want to take a look at [Comparing ‚Äúbetter‚Äù and ‚Äúbest‚Äù](https://english.stackexchange.com/questions/57216/comparing-better-and-best). 
Its already fixed. If you want to know how common bugs are by the way, just sign up for the linux security updates lol.
Learn a framework. Symfony preferably. It will not only show you the proper structure but also make apparent how your tinkering with raw PHP manually is outdated, despised and deprecated. Start with this old article that will help you to grasp the idea, [Symfony versus Flat PHP](https://symfony.com/doc/current/introduction/from_flat_php_to_symfony2.html) And then to [this tutorial](https://knpuniversity.com/screencast/symfony), to get into the most recent version.
Is there a reason you can't simply use Xampp with PHP7 and only use this? Xampp has everything to work with. Or virtualise a unix distribution and use nginx. 
That's looks like something from my mushroom trips.
I definitely agree with this. If you don't know the answer to something just say so. Better yet, ask about it. You're an intern, so we expect to have to teach you stuff. I'm looking for things like honesty, enthusiasm, will fit in well with my other developers, likes to learn new things. I will ask technical questions to gauge your knowledge, rather than fail you. You may have done better than you thought.
Sometimes it's worth to read the question body, not only the title ;)
Cliche moment: success is getting up one more time than you get knocked down. Get up! You‚Äôve got what it takes and if it doesn‚Äôt happen here, so what?
Well, you probally can't find sources for that, because that's not PHP7, but simply PHP. That's probally your confusing point. What you need to research for are namespaces in general `php namespaces`, something like `php Pdo tutorial` etc. For folder structures there are no standards, but there is a [Package Skeleton](https://github.com/php-pds/skeleton) from /u/pmjones. I saw that structure in many projects and this is the structure that natively comes up in my mind even if I never took time to "learn" or remind that (usually I forget things that I can read online). It's intuitive, easy to understand and well structured. The main project structure, which you have within your /src, shouldn't be that complex. 
They have nothing to do with each other. Judy could be at most a building block of a NumPy-like extension.
&gt;My question is, do I really have to create an "destruct" method calling efree? or PHP garbage collection can handle it and prevent unused matrices from keep using memory. Your data types with custom resources should be wrapped within classes with proper resource / ownership management (destruct, clone...). Zend Engine GC will do the rest.
This must be a joke. If it isn't, it is a request for /r/PHPhelp. I'll assume that you already knew that http://php.net is a think. Maybe you're having trouble understanding the docs. If that is the case this page may be useful: http://php.net/manual/en/about.php
Symfony
Given that it takes hardly any time to setup phpMyAdmin these days, why would you just not use that? The user interface for Adminer, looks poor, cheap and like the developers don't have time for the TLC something like that needs. Use phpMyAdmin, if you must use anything at all.
I find phpMyAdmin soooooooo slow, Adminer is way better for my use. Then again, I don't have it installed on production, only on my own machine
I don't think it would help. It's just a fundamental problem with how adminer works.
&gt; Given that it takes hardly any time to setup phpMyAdmin these days, why would you just not use that? I'm clearly missing something here that you and the OP are doing. Why is a production database accessible remotely from such tools anyway? If you're going down that route then surely you should be setting up a SSH tunnel into your production database server and then using a local tool like Workbench, Heidi, Dbever etc? Allowing access directly to a production database server with such tools like phpMyAdmin/adminer you're just asking to fail.
&gt;I use GitHub for my public code, BitBucket for my private code, CircleCI for CI, and GitLab for my registry Yeah its certainly worth looking into when GitLab can do all of those things under one interface in the free tier.
For your basic questions about classes etc I would have a read of this book [https://daylerees.com/php-pandas/](https://daylerees.com/php-pandas/) it's free to read and covers OO basics very well. &gt; never worked on linux Maybe not so much an intern level requirement but Linux is the dominant player in the server market so I can see why they would expect you to know at least a little. I would certainly install a Linux desktop (maybe in the virtual machine) or get yourself a Mac and get used to the command line. A lot of the tools crossover with each other that you need for development. Not only will that increase your server management knowledge, it will help your development flow no end. I can't even imagine trying to develop on Windows again, you have to constantly jump through hoops on Windows to get things working that simply just work on Linux/Mac environments.
Just got to upvote this for the last sentence - It is so true that spending a couple of hours glaring at a piece of work going "How the hell is this meant to work?" until you finally get the lightbulb moment is a great feeling and experience, and each time, the lightbulb moment turns up quicker.
Don't shoot the messenger ;) &gt; Why is a production database accessible remotely from such tools anyway? I guess because there is no warning on adminer/phpMyAdmin website that explicitly discourages to put it on a prod server and because these things are popular with devs. Just saying people are doing it, and yeah they are a bad idea in general.
Here‚Äôs a great read that approaches most relevant topics about modern PHP. https://www.phptherightway.com
In an interview, if you don't know the answer to something. Stop, think for a moment (just in case you do know it), and if you really don't - then admit that you don't know it, and show that you know how you would go about finding out the answer. Provided you can break a task into its component logical steps, being a **good** programmer isn't about being able to hold the entirety of a language in your head, its about the problem finding skills and ability to get out there and find the answers, not about being a walking dictionary. Being a **fast** programmer is where holding more of it in your head comes in, but that comes only with experience (or an eidetic memory). When it comes down to it, if you can break a task into its logical steps (if this, then that, else the other), you can google the rest of it.
You are looking at the wrong things. PHP 7.1 added void return type and class constant visibility. What you are missing is the modern php in general, if you call PHP 5.3 modern PHP. As I have done before here on this subreddit, I still recommend pmjones book (https://leanpub.com/mlaphp) and PHP The Right Way web site. Once you are caught up, new phone versions (7.1, 7.2, 7.3, etc) won't be intimidating, but rather welcoming.
I'd have to relearn/rebuild my CI though, so perhaps the tidy-up is for new projects only. I heard that GitLab were straining under the load of folks fleeing GitHub too, so I'll see how that pans out first `:-)`. 
In other words; "don't leave your window open".
Not sure things on your company blog should be reasons to not employ said company... but well done?
I bombed my very first coding test because, despite having studied three separate sort algorithms, couldn't figure out how to sort an array for my life.
People still use phpMyAdmin? ü§î
Yeah, this was a stupid reason. Replacing `function` with the return type would've been *extremely* beneficial to php and set a consistency with other languages and php itself.
Also Devdocs.io makes everything easily searchable with fuzzy matching, and also available offline.
In 2018 It's stupid to look for the best Framework. You probably should ask what's the best framework for the projects I'm working on. I'm working everyday with CakePHP that's a great framework to go in production quickly. The scaffolding is very powerful and the main thing with CakePHP is "Convention over configuration" Sometimes I have to work with Symfony, I'm really confused by all things you can do with yaml or XML or php otherwise It's a great framework as well. 
From the official site's homepage, you can also download a trimmed down version of adminer that only supports MySQL.
As someone that has hired a lot of developers, if you \*really\* want to work for this company, this is my advice. Figure out the answers to as many of the questions as you can. Write the hiring manager an email and say: "Dear Mr./Ms. Smith, thank you for the interview. I really enjoy X, Y, and Z about ABC, inc. I realize that I do not have the strongest technical background yet, but as an intern it is my goal to learn. Here are the answers to the technical questions that I had trouble with." This shows A: you like the company, B: you don't give up easily and are self-motivated (VERY IMPORTANT!), and C: you are eager to learn. To me, those are much more important than technical knowledge for an entry-level position.
hello @iamrootnotgroot the question might be the most stupid of its kind. This is because it's hard for me as a beginner to really understand from [php.net](https://php.net) Thanks.
Hi @dinnerotast I'm so sorry the question is that stupid but it isn't a joke. I have trouble understand from [php.net](https://php.net) Thanks for the links.
Thanks.
Hey u/zilltine , You are being too hard on yourself. Think of this as a learning curve, take a break and have some rest. once you have enough rest take some to write down the aspects where you went wrong, now think of those aspects from an employees perspective and this will give you an idea of what they expected from you. I have given you some tips below to assist you. 1. Research the company, ensure you know enough about the company before considering an interview. 2. Research the position, ensure you know everything about the position and whats required of you. 3. Use the internet, there is tons of interview questions available on the net that you can use to train yourself for the interview process. You can only get better from now, I wish you all the best and hope you get your dream job :-) 
We'll... contact you. Probably Friday.
&gt; I have trouble understand from php.net What are you having trouble understanding? We can't help if you say what you're struggling with. Php has some of the best docs out of any language I have ever used, I really can't understand what you're struggling with?
For the brave: http://git.php.net/?p=php-src.git;a=summary
[removed]
&gt; when I run Xampp Firstly it's pointless adding extra layers of complexity ike XAMPP with zero advantages and will be totally different to your deployment environment. You can install multiple versions of PHP as standard, nothing extra needed just apt-get install and the php version. To switch between them simply use a2enmod and then the number of your PHP version.
1. Is what i said, but was asked where on server. 2. Didn't know about interfaces or abstract classes a thing.
Hmm.. without testing.. I would guess it is 8. 
So I suppose the title is intentionally misleading. It doesn't make it any better though. To answer your question one have to know by heart what is the operator precedence for the type casting operator. Suppose it's higher than subtraction operator, the result should be 8.
https://3v4l.org/5fJep I don't understand the point of threads like these.
If you really feel the need/desire for phpMyAdmin/adminer/whatever you can handle it in a reasonably secure way. Only make it accessible from a private network that's behind a VPN/SSH access for example.
8.
Lol yeah definitely a waste of time. 
because it's a single php file you can put anywhere and has no setup at all
Thanks!
Thanks!
Thanks!
I'm sad to say this, but: yes. Although not on a regular basis, but sometimes it's the only way. E.g. at the company that I work for now, devs can access only a read-only slave server via pMA.
That's 2 more than I have to spare. Please share this alleged exploit.
Mark Focus Presents his work to Putney Swope https://youtu.be/aWoFqbYBo6M
&gt; Is what i said, but was asked where on server. That seems oddly specific for this kind of interview. If you were to ask me right now I'd say `/tmp` by default only because I remember seeing a bunch of oddly named files related to sessions there before. It's not any actual information I've ever had to use. If a scenario came up where I had to know more about it I just refer to the PHP docs or straight up google it.
Is it any way I can scale it down drastically. 
Internship is 4 weeks theory training and 4 weeks assisting in their projects. Company went from 3 to 320 employees in 7 years so i do not think they are looking for cheap labour. Free work with little assistance is what i am doing right now actually
If I were ever in charge of hiring I'd forgive consistent errors like that. Maybe just because I spelled develop "develope" about 19 times on the written portion of the SAT.
Please do share it, because this honestly sounds like bullcrap.
What's estimate if I did the scaled down version for my prototype on my own? 
I'm not by any means saying you should have either Adminer or PHPMyAdmin open to the public but I wonder how much Docker would alleviate this? The vulnerability would still be there but only within the container that is running?
You clearly haven't used Adminer much and if you're going after looks? PHPMyAdmin looks dated, Adminer is clean and simple, it is functional over visuals and is far more powerful than PHPMyAdmin. It also doesn't require a million files, it is 1 file.
Fair enough, I'm not saying my intuition was necessarily right, I was just giving you my gut reaction based on your account. Regardless, those questions were too demanding for an interview at the internship level.
&gt; this honestly sounds like bullcrap. So you think that this MySQL based auth it comes with by default is a good idea to leave exposed to the public?
No, it shouldn't be on the server. But I do not believe you that you found an RCE exploit that was really easy to find.
It's not an exploit. I think it's working as intended, because it is not meant to be accessible to the public. But they never warn about this on their website. So because I saw it happening a couple of times that somebody uploaded it thinking it was secure, I thought I warn others about it.
I couldn't agree with you more on the Jira comment. Don't have much experience with Confluence, but I'm not surprised.
Wow, a fascinating greading! I wonder if anyone would write a history of PHPLIb development and making it merge into PHP4.
yeah I'm thinking about some kind of vm with lamp stack to work in a more similar environment
It's not worth to move all the old projects to the new wamp, I will set php to 7.1 and add new projects only to xampp or maybe switch to docker
Thanks! This works for new code only, if I not mistaken anything. So if I need to tweak existing codebases, we don't have built-in tools, or? 
Laravel is not good? I was fiddling with it
I didn't knew about this site and somehow google didn't bring it to my attention
&gt; I was fiddling with it That's the problem exactly. It is not good to fiddle with, teaching you rather bad practices: https://medium.com/@marinithiago/an-eloquent-story-7ebecf5adfcd However, it has a lower Learning curve, just like PHP itself, and easier to pick up. So it's a good choice too.
I can maybe see a use for this sort of thing on a development server where devs can check queries, maybe? But surely its easier to allow them limited SSH access rather than putting in giant "screw me over" banners on any publicly accessible server? 
It's not really a vulnerability I'd say. And the file accessible are limited to what the http/php user can read... So not that much, but /etc/passwd, /var/log/boot.log or all your php files which can contain the real password to the database...
I'm the author of Adminer. I agree with the overall sentiment to not make Adminer accessible publicly if not necessary but reading arbitrary files shouldn't be possible. Please share the details with me responsibly via email or by making a private bug report.
The answer to this is "it depends". Native Sessions are handled based on php.ini settings. Some frameworks use a relational database. Others still use something faster like Redis. 
with that level of ramp up, it may have been your interviewer's first time interviewing. 
I second this. Engineers are going to encounter unknown problems. We want to know that when that happens, you don't just throw up your hands. How are you going to solve tough problems?
Right, maybe I was assuming context of the question too much. To me just asking 'where on the server are sessions stored' would relate to the expected 'default' with no frameworks or custom setups.
And what exactly are you doing? If you aren't even disclosing that information to the devs, they won't be able to fix it - if you are telling the truth that you found something.
80&amp;#37; of all websites run PHP? Isn't it a bit too much? I'd have imagined something like 20&amp;#37;, or 30&amp;#37;, no more... Can someone explain this?
Done.
it's because of WordPress.
Thanks.
The explanation is simple, 80% of those 80% are wordpress-powered blogs. Beside Enterprise, Web is almost entirely runs on PHP, due to its simplicity and availability. 
I'd suggest to take an existing project (best with tests) and to try migrating it to PHP 7.1: parameters and return types are almost like in Java these days + some BC breaks will popup. See also http://php.net/manual/en/migration70.php, http://php.net/manual/en/migration71.php. And if you are using PhpStorm, check Php Inspections (EA Extended). Ince the project language level set to 7.1, "Language level migration" group inspections (with quick-fixes) will spot new syntax sugar and incompatibilities. That's for the language itself. My proposal would be to ignore all frameworks and experimenting with well known codebase - you'll be able to focus better ;)
In 1997, When Andi Gutmans and Zeev Suraski decided that they were going to use PHP for their ecommerce shopping cart, what were their alternatives?
I‚Äôm not 100% sure, but I believe that‚Äôs taken from a source that states 80% of website *with a CMS* use PHP
I think IBM's NetCommerce might just have been available in '97 but Perl would have been the main free alternative in Unix land. 
Perl would be the most similar in a lot of ways. But pretty much any language could be used under Apache with [CGI](https://en.wikipedia.org/wiki/Common_Gateway_Interface) or ASP (Active Server Pages) under IIS. ColdFusion was also around. I am not sure the exact timeline, but server side includes (commonly seen with .shtml extensions) where a way to embed some executed stuff in static HTML pages. So you'd see things like: &lt;!--#include file="header.pl" --&gt; HTML BODY &lt;!--#include file="footer.pl" --&gt; The first blogging platform I used was perl scripts that rendered out HTML pages.
Assuming most people leave the `expose_php` option enabled, it wouldn‚Äôt be difficult to tally a decent number like 80% based on the `X-Powered-By` header. Now imagine all of the sites that do disable that header. So it‚Äôs not unreasonable to assume the number could be higher than 80%. Then there are those intranet websites that we‚Äôll never reasonably know about. 
I highly doubt it is near 80%, much less above it. Maybe 5 years ago but a lot of pages today are completely static or based on API calls only and those API calls are implemented in a wide variety of languages, certainly to a lower percentage PHP than the server side generated pages before that trend were. And of course there are still other languages for server-side generated pages too.
We had sessions stored on /var/opt/rh/rh-php70/lib/php/session (Centos 7, it will vary for other distributions) but then we had to move them to directories in home because we kept losing permissions to that directory on the managed virtual servers. 
[83.5](https://w3techs.com/technologies/overview/programming_language/all)
&gt; PHP is used by 83.5% of all the websites whose server-side programming language we know. From your link. Obviously none of the static websites I mentioned will return any data for the server side language in use. Nor will a certain percentage of APIs and server-side generated HTML sites. Sadly your link does not mention the percentage of known vs. unknown.
&gt; based on API calls and you could write APIs on PHP. And many developers do that. And since PHP is very popular in the world, it's not surprise that at least 20% of all APIs are running on PHP. And I really doubt that SPA+Api represent some significant part. So yes, probably 75%-80% of all web runs on php. Sorry.
Sounds like you might have just had a rough interview. I've bombed them before, even after successfully holding jobs as a developer for a couple years, because they were asking questions that did not come up in the day to day duties of my job at the time. Try not to sweat it. Now you know how it feels to bomb, which at least in my experience makes me less nervous going into interviews. Doesn't really get worse than that, and in the grand scheme its not all that bad. Best of luck on your hunt, get out there and try again :D
You can write APIs in PHP but fewer of them are written in PHP than years earlier. Mostly due to a greater freedom in language choice on the server with the rise of cheap virtual server hosting. Nobody is forced to write stuff in PHP anymore because that is all shared hosters support. Let us say 10% of web pages are totally static (e.g. a lot of small companies have those, restaurants and similar businesses). There are dozens of programming languages out there that have one or often multiple web frameworks. Enterprise software is often written in something like Java or C#, even on the web. Many people used Ruby on Rails, NodeJS, various Python web frameworks,... Do you honestly think all of those combined make up just the other 10% or so? It would make a certain sense that PHP would show up in statistics more too since it is one of the few that uses the direct integration into the webserver while many others have a built-in webserver and are commonly deployed behind a reverse proxy that also handles the static files (e.g. Apache or nginx).
&gt; pages are totally static And contain small contact form on php) &gt; There are dozens of programming languages out there how do you think, which percent of projects are written from scratch, without any sort of CMS and so on? I mean not only wordpress, but joomla, magento and other stuff. I really don't understand why you can't belive that most of the web is running on PHP.
Hey, fesor, just a quick heads-up: **belive** is actually spelled **believe**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Take a look Ansistrano https://github.com/ansistrano Ansible deploys made easy ;)
&gt; I really don't understand why you can't belive that most of the web is running on PHP. I absolutely believe most of it is. I just think 60-70% is closer to the truth today than 80% or even more than that. In terms of number of requests 80%-85% might even be true since a lot of larger sites do run PHP but in terms of number of websites I highly doubt it.
Hey, Taladar, just a quick heads-up: **belive** is actually spelled **believe**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
A good portion of the SPAs I know of are backed on to PHP. They use stuff like Vue.js for the frontend.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [A Discord for PHP specific talk since \/r\/webdev Discord is setup in a way you get roped into channels by default and using @here notifies everyone - including non-relevant people (and it's not a good thing)](https://www.reddit.com/r/webdev/comments/8t4ng9/a_discord_for_php_specific_talk_since_rwebdev/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
What I mean about Discord is people specifically denying the usage of tools it gives you to reach people. When people are careless or ignorant about the server notification settings they can customize with a few clicks or joining a server and wanting no notifications from that server by default - it is just stupid and makes no goddamn logical sense for me as a developer who excercies binary logic every day of his life for work. I do undestand it's not all work, but c'mon - when you deal with developers, you do not really expect irrational behaviour in the professional field.
&gt; The moon landing was faked, vaccines cause autism, and the earth is flat. 
I can highly recommend Lando is these situations. https://github.com/lando/lando
&gt; when you can use PHP 7.2 today? [The Futuru Awaits You](https://i.imgur.com/iuXKlST.jpg)^Yeah^I'm^bored
I know Intel runs there website on WordPress. ü§î
Because it's about how many websites created are powered by PHP, not about how popular or how much traffic those websites get. If you take every personal blog or portfolio that averages less than 100 hits per month, and are probably powered by Wordpress, 80&amp;#37; isn't unreasonable.
PhpMyAdmin is so absurdly slow. Adminer is crisp, clean and fast.
[http://php.net/archive/2018.php#id2018-06-21-2](http://php.net/archive/2018.php#id2018-06-21-2)
And that being the case there's a huge irony in the pervasive bitching by "real" PHP developers about Wordpress' poor code. It might indeed by poor but would the future of PHP be as healthy as it appears to be if not for the massive footprint of Wordpress? 
Slack uses PHP for their backend 
I'm not sure I understand your requirements but Redis is by far the most popular key-value store. Predis is the php client library you can use. 
I'm currently profiling Predis as an alternative to the C phpredis extension which has a bug when using persistent connections that still hasn't been fixed after many years. Unfortunately it seems Predis is about 2.5x slower than phpredis. However, these are network / socket based and I am looking for something much faster - something in-process shared only between requests in a single php-cgi instance as I need to hit it a few thousand times per second.
Probably not, still doesn't make WordPress enjoyable.
try this: $this-&gt;assertTrue($entity1 === $entity2)
Not sure I fully understand your requirements but Predis is pretty fast. Does the php://memory stream suit? http://php.net/manual/en/wrappers.php.php
&gt; I've spent a few hours playing with a method of using opcache ... but the performance of it sucks compared to the in-memory performance of wincache. That part doesn't make sense. since opcache is also in memory. AFAIK, Opcache only caches the exact output of the file meaning that unserialize is being run each file, ruining your performance. If you do something like: $data = '&lt;?php return ' . var_export( [ 'expiry' =&gt; time() + $ttl, 'value' =&gt; $value ], true ) . ';'; You should notice an increase in speed, but if you caching objects, you'll need to implement the `static function __set_state(array $an_array) ` for them.
Yeah, I did a test: $large_array = []; for ($i=0;$i&lt;1024;$i++) { $large_array[] = random_bytes(1024); } $cache = new OpcacheCache(); $cache-&gt;set('foobar', $large_array, 10000); $start = microtime(true); for($i=0;$i&lt;1000;$i++) { if ($cache-&gt;has('foobar')) { $cache-&gt;get('foobar'); } } $end = microtime(true); echo $end-$start; WIth serialization: 1.0297560691833s Without: 0.011908054351807s
Heidi through an SSH tunnel.
`assertSame`? 
I'm not entirely clear what you're trying to accomplish. Are you trying to compare a manually-constructed object versus another one which was independently constructed from database-retrieval?
Better products are a bit debatable. They are good enough for most people though. 
This is the behaviour I am a used to. I'm a full time Java dev, and normal practice is to create an override method for equals, which Junit normally uses when calling assertTrue. I'll go down this route for now I think, thanks
[removed]
I'm assuming that you mainly need it for testing, and that in regular usage Doctrine's identity-map will ensure that you should never have two different objects of the same type and primary key.
&gt;sting, and that in regular usage Doctrine's identity-map will ensure that you should never have two different objects o Yes this is only for testing, I'm working on writing class that uses reflection to compare the actual properties of each object being passed
That roughly matches the kind of numbers that I've been seeing. I'm still digging but it looks to me as though wincache stores copies of the actual zval's in a shared persistent hashtable for certain types, but still relies on internal serialization for objects.
What is the purpose of this assertion? Do you want to assert that - you are dealing with the same entities - none of the properties of the entity have changed ? When concerned with the former, comparing identifiers might be sufficient. 
I wrote a simple bash script some times ago, for switching between PHP 5 and 7 versions under Apache web server, since I was working on different projects using these versions... This scripts works good under any debian/ubuntu distro since it using "update-alternatives", and maybe with others distro by using extra compatiblity functions. In alternative, you can use an ide like netbeans, set the correct php version of your project and let the ide know where the interpreter is, and use its internal web server... https://gitlab.com/snippets/1727407
Comparing properties. Saving one entity to the database, turn getting another by using the generated I'd and comparing properties are the same
I remember starting out with SSI and then discovering PHP. Damn, what a time to be alive.
&gt; C phpredis extension which has a bug Out of curiosity, could you link to the bug please?
Will send a PM
perl, python, asp classic, anything CGI and a bunch of proprietary solutions like web objects. 
Well, why not compare properties with expected values, then?
You can use phpiredis (different extension) with Predis. Works great for me.
You are right. I usually tell people to use what they "feel" is better for them. For me they are because they run faster (better performance) while working with big files. I don't have to launch a different app for a different formats (both Photo and Design can open and save raster or vector or switch between them). You can even use pixels on vector files and the other way around. They open all Adobe files perfectly and they save me tons of money. I'm not a graphic artist but for casual work, Affinity works fine for me. I can do things faster than with Illustrator or Photoshop. And time is money, being more productive is something I value.
ASP wasn't a thing in 97. Python may have been an option, but I couldn't tell you what the state of python on the web was back then, Java could've been another option.
If you‚Äôre checking that one retrieved by ID is the same (data equivalent) as the one you just saved, it *should* be the actual same object (=== same) - there‚Äôs all sorts of internal caching to ensure that. Unless I‚Äôm not quite following what you‚Äôre asking, which seems more likely given the problems you‚Äôre having. Of course there‚Äôs the general issue of interacting with a database in PHPUnit, but that doesn‚Äôt invalidate your question. 
What advantages would Banshee give me over Laravel? 
That depends on what you're looking for. Not saying that Laravel is bad, but with Banshee it's easier and faster to build a website. It's more of a hybrid between CMS and framework. It's what they call a CMF: Content Management Framework. It has ready-to-use modules like a forum, weblog, photo album, webshop. Although they're all functional, some might think they're only basic. But that is intentionally. It's not a real CMS, so coding is required to adjust it to your needs / taste. And it's very, very secure. So, no worries about someone hacking your website. Banshee comes with a script that you can use to verify that the code changes you make are done right. It's the only framework / CMS I know that has provable secure core. Not convinced? Give it a try at [https://demo.banshee-php.org/](https://demo.banshee-php.org/).
But laravel *is* bad. You're not making any sense.
In that case, you should really give Banshee a try. üòâ
Bear in mind that some people exist, who are able to read your source code and review the heart of your security practices. This method hasn't changed in 5 years. /* Scan file dummy function * * INPUT: string line * OUTPUT: - * ERROR: - */ protected function scan_line($line) { } The framework looks like a stranger brother of CI 2, without a vendor directory.
Sure, go ahead and review the code! Why do you want a vendor directory?
The official answer is [Private Packagist](https://packagist.com) but search around Github and you can find repositories of Docker images for it's predecessor, Toran Proxy, and if you just want a static version, you can checkout Satis. With both of those, you can just point your repository to one of those and they will have the specifics on each individual package.
Looks like I wrongly focused on a method of an abstract class. The method should've been declared abstract too. If you want it to be popular, check Composer, PSR2/PSR4, and add some tests. Regards.
We're using Satis already, it's now of an issue that we're using an SSL cert on it from one issuer now, and will be switching to another issuer in the future - we'd like to set up our composer.json files to handle both to avoid any deployment issues when it finally switches over.
lol, audit script is a bad joke, phpstan, phpmd or other basic tool can do much more and I wouldn't event try to say that app is after this kind of audit secure. No types? We have php7. No psr4. No test. Like 5y ago a would say it's cool but that's long time for web. But hey we're all doing what we like, so keep going but I would suggest to move code closer to modern php. Also I would be more humble about security.
I'll go out on a limb and assume you're using a framework like Symfony or Laravel. Regardless the answer, you should populate an entity with defined values, store it into the database, get the ID, and check each property as you would set them. Here's a really light example: //init var $name = "bar"; //populate Foo $foo = new Foo(); $foo-&gt;setName($name); //stage and commit to db $em-&gt;persist($foo); $em-&gt;flush(); //get the stored entity from the db $queryFoo = $em-&gt;getRepository("BundleName:Foo")-&gt;getBySomeDefinedRepoMethod(//...); //check if the stored value is equal to the value $this-&gt;assertEquals($name, $queryFoo-&gt;getName()); This wasn't exactly the answer I wanted to hear at the time, but it's considered best practice to do it property by property as the whole reason you create these tests is to make sure that the properties that exist now don't suddenly disappear later. Just my two cents, stranger.
I'm not trying to be disrespectful to the author but I have to agree with you. This looks like a legacy code and having no tests in 2018 is a no-go. Also any audit you're doing yourself is absolutely useless even if you're a security expert.
&gt; And it's very, very secure. So, no worries about someone hacking your website. This is a _very_ confident statement for a project with no test coverage and a non-existent community.
Sure. But prove me wrong.
Don't go that way when no one was unrespectful, taking in mind that the code is really old/bad.
The code is not old and 'bad' is just a matter of taste. And saying something is bad without any substantiation is unprofessional. Unless you substantiate your statement, I'm going to ignore your post.
No tests, no namespace, no psr, xslt by default instead of html, [this as an idea of security](https://gitlab.com/hsleisink/banshee/blob/master/security_audit), next to no docs, lots of classes wether you need them or not, and the list goes on... There is no good reason to learn or use this instead of Symfony/Laravel/Cake/Yii/even Codeigniter, really. --- From project home page &gt; Secure &gt;The main focus of this framework is to be secure. Banshee is protected against common attacks like SQL injection, Cross-Site Scripting, Cross-Site Request Forgery and session hijacking. The framework takes care of authenticating users in a transparent and secure way. While many other frameworks claim to be secure, Banshee is one of the few consisting of provable secure code. Even after you change to code. I'm pretty sure that script has major loopholes. It's basically a grep of what you thought bad code would look like written in php... Yeah, won't work. The rest, every major framework has it. &gt;Fast &gt;Although Banshee offers a lot of features and has everything a modern framework needs, it is very fast. Its lean MVC design and usage of XSLT for the view, result in very fast page generation. While it has an internal caching system for improved speed, it is still fast without it. Banshee has built-in support for Hiawatha's cache system to offer the same speed as a static website. All frameworks are MVC nowadays. XSLT for views, really ? Redis/Varnish/Whatever symfony or laravel uses as default cache ? [Hiawatha](https://gitlab.com/hsleisink/hiawatha) &lt;- op's custom created webserver. Same speed as a static website &lt;- like you can't do it with any apache/nginx server. &gt;Easy to use &gt;Ready to use modules like a forum, photo album or weblog will save web developers a lot of work when creating a new website. Easy to use libraries for e-mail, pagination, HTTP requests, database management, images, cryptography and many more are also included. Where possible, Banshee creates a transparent layer on top of the default PHP functionality. For example, you can use $_SESSION as you are used to. The Banshee session library takes care of the rest. Nothing that doesn't exists in major players either.
Your post describes very well what's wrong with PHP development these days. Most developers can't think for themselves. They all follow what's mainstream. Composer might look cool, but it's not. It's so easy to drag all those libraries. But no one simply questions what they're dragging in. Is it solid? Is it secure? Is it stable? It's so easy to include a 10MB library while you only use a few functions of it. Composer is evil. Yes, a composer.json in present. But it's only included after too many requests. It's the first thing I delete when I build a website with Banshee. PSR4 means nothing. A piece of PHP code that uses PSR can still be crap. Banshee's code is very well readable and that's all that matters. No tests? What kind of tests do you want to be included? Banshee's code is tested, but you don't want all sorts of testing code in your framework when you use it to build a website. So, not test code is included, because it doesn't belong there. I don't have to be humble about Banshee's security, because my claim is true. Don't believe me? Prove me wrong.
Because Banshee's style is not what you prefer, doesn't mean it's legacy code. Its code is short and efficient. A self-audit can be perfectly useful. Otherwise, debugging your own code would also be useless. So, your comment makes no sense at all.
Why would you come up with a custom function using PBKDF2 to hash passwords instead of using `password_hash()` as recommended by best practices? Why not have the encoder follow an interface so developers can use their own encoder instead?
A lot of flaming and bashing, with no substantiating. Ignoring.
Can you give me a single good reason to *not* follow PSR-4? Or *not* include proper tests and their sources? These are both modern *standards*, which means you need to actually be able to argue against what other people are doing if you want to say they are bad or useless, not just say "A piece of PHP code that uses PSR can still be crap. Banshee's code is very well readable and that's all that matters."
Yes, Argon2 might be a bit more modern and will be used in the future. But PBKDF2 is still secure enough. So, no issue there. What encoder are you talking about?
Why do I need to adjust my coding style to someone else's preference? My code, my style. I don't blindly follow the herd. I'm not a cow. And tests may sound like a good idea, but what does that prove? Good testing is hard. A proper test involves more lines of code that the code it tests. And do you really think developers will actually look closely to all those tests? Of course not. Including tests gives a false sense of security.
Do you think you are smarter or better at writing clean code than the groups, individuals and teams behind these standards? The herd in situations like this is both more experienced and smarter than you, sadly. Developers that plan to use your code in any serious way will absolutely look at your tests and the quality of those tests to judge whether they can use the code or not.
Yes, I am a better developer than most other people.
Sorry, I was referring to your `hash_password()` function as an encoder. Argon2 and BCrypt aren't the future, they're here today and yesterday too. I don't mean to imply that PBKDF2 is insecure, but it is easier to brute force than Argon2 or BCrypt. It just seems an odd choice of setup for a framework/cms who's primary focus is security.
Is that why a lot of your code is out of date, generally messy and unstructured? Big parts of this code look like it was written a decade ago. Look at the list of people that worked on, voted on and approved a lot of the PSRs ‚Äî if you genuinely think you are more skilled and experienced than that entire group of people, you are delusional.
&gt; And tests may sound like a good idea, but what does that prove? Good testing is hard. A proper test involves more lines of code that the code it tests. And do you really think developers will actually look closely to all those tests? Of course not. Including tests gives a false sense of security. This tells me everything I need to know about you as a developer. I would never recommend your 'framework' based on this stance and other responses you've given in this thread. Your insistence that composer and external libraries are somehow detrimental to your project means that you have developed everything independently rather than libraries that have been tested in countless applications and have reviewed, patched, and secured against known vulnerabilities. They are easily extensible and easily imported because of things like PSR-4, so developers don't have to write some kind of abstraction to get it to work with their project. Your use of opinion and baseless attacks (*composer evil*, *you don't want testing code in your framework*, *my code, my style*) shows that you are terribly immature and should avoid development altogether.
I would not specify creds for the S3 client like that. Don‚Äôt specify them at all. The SDK will pick up environment variables will or aws config files or ec2/ecs metadata. See https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/guide_credentials.html
&gt; no substantiating What about my entire first sentence ? This entire thread is everyone telling you this has HUGE issues and you dismissing it by saying "I'm the best coder 3v4R". Keep your ego in check. I hope I never inherit a codebase you wrote.
Software quality is something objective and not subjective, as can be measured with external tools. It's not bad because someone does not like it. In addition to all the ones you've already been told, I've found: [https://gitlab.com/hsleisink/banshee/blob/master/controllers/newsletter.php](https://gitlab.com/hsleisink/banshee/blob/master/controllers/newsletter.php) ¬øAre you really executing javascript from the controller? ¬øWhy controllers have business logic? You say that this framework follows the MVC pattern, I see that the components have mixed responsabilities. This happens in all entire project. [https://gitlab.com/hsleisink/banshee/blob/master/controllers/demos/googlemaps.php](https://gitlab.com/hsleisink/banshee/blob/master/controllers/demos/googlemaps.php) High coupling with external classes Banshee\\\*. Also aplicable in other files. [https://gitlab.com/hsleisink/banshee/blob/master/controllers/weblog.php](https://gitlab.com/hsleisink/banshee/blob/master/controllers/weblog.php) ¬øWhy you need to inject css and js from the controller? [https://gitlab.com/hsleisink/banshee/blob/master/libraries/api\_controller.php](https://gitlab.com/hsleisink/banshee/blob/master/libraries/api_controller.php) Someone forgot that PATCH can be useful somtimes, like when you want to modify an entity. Other stuff: \- Inconsistent use of namespaces. \- Handling exceptions, not even a single try catch. \- I don't see any design pattern, but doesn't suprise me. \- I hope you validate your input request and the values passed to the view. But hey, if you are cool with this code, the devs doesn't care about quality, mantainability, reusability and so on, go ahead and make money :-)
Hey, carnau, just a quick heads-up: **suprise** is actually spelled **surprise**. You can remember it by **begins with sur-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Whatever. My framework has been used for several high profile websites, audited thoroughly by security companies. No issues found, websites remains secure for many years. No hacks or issues ever. Those are facts no one can‚Äôt deny. You can flame and bash whatever you want. I don‚Äôt care.
&gt; the right way How it is "right"? Maybe "common"? I really don't know why people still prefer to use vich upload bundle... Maybe somethig changed from the time when I used it last time, but... don't think so. Also why not flysystem? I found it much easier to use.
How it would do that if your application is isolated inside container? Event in case of ECS.
Does this use STS (Security Token Service) to generate a single use credential for uploading to S3? I had a hell of a time getting a single use session to generate, and the AWS support staff kept telling me to do something different. One tech told me to do A, then next said to do B, and the last said to do C, which was to use the HTTP Post Form using Signature v4. That, though, doesn't use a single use token. It also can't pass back the upload progess, unlike the Javascript version. Ugh.
If it's an EBS deployment, you can create a folder that contains the credentials, but I've had trouble actually getting it to work, so I've just stuck with defining it in a config file within the application.
ECS has its own metadata service that the SDK will use if it sees a special environment variable that ECS sets.
No, it doesn't use STS. Credentials are generated only once.
You are "right", common may be more accurate. Vich upload bundle provides useful features and is very easy to use with Symfony as well. Flysystem is probably easier to use than gaufrette. As we were already using gaufrette in our project we kept it. I agree with you, I would recommend to use Flysystem on a new project.
\&gt; The SDK will pick up environment variables Am I missing something? He is pulling the creds from the environment variables. The only difference is the library is getting them from the environment and including them when it calls the s3 object. The alternative is to leave them off and let s3 get them from the environment vars. In neither case are they hard coded in.
The sdk has a chain of creds it tries. When credentials is in its config array, it only uses what‚Äôs there and does not use or try anything else. Means in production you have to provide credentials the same way rather than relying on something like the ec2 metadata service. The only thing that‚Äôs accomplished here is making things less flexible and shortening the environment variable names.
Oh, I see. I took your comment to mean that there was something insecure about this method.
It's 83% ish of sites whose back-end technology is known; big difference. It's still a big share but it's not as big: https://w3techs.com/technologies/details/pl-php/all/all
&gt; easy to use with Symfony as well until it's not.
I wrote a guide about what I think you‚Äôre trying to do: https://chrisguitarguy.com/2018/06/16/s3-javascript-uploads/ The backend examples are JavaScript, but you should be able to translate them to PHP. If not, hit me up, I‚Äôll send ya some example code.
You can *make* environment variables insecure (by passing them into a docker container via the `-e` or `--env-file` flags, for instance). But definitely not insecure by default. Sorry for implying that! I edited my original post to clarify that if you're running your app on AWS, the example in this article is not the way to do things. Running your app elsewhere, it's a fine way. I'd still probably use `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` for the environment variable names and let the SDK do its thing and pick those up without any additional configuration.
Cool, I'll check it out. The AWS docs are a bit all over the place at times, and even wrong. I pointed something out to them, don't know if they fixed it though. Paying the $100 a month for support lead to a string of techs telling me 3 different approaches to solve the problem I was facing, and each suggestion moved away from my original goal.
Hah, love it. This has been a pretty popular refrain for years, I know. 
Could you elaborate on why passing env vars using -e into a docker container makes them insecure? Currently, during the build, my build process does a search replace into a php file that is included everywhere and sets all my secrets as globals. But this is cumbersome, and I was wanting to start passing all the secrets as env vars with -e upon docker run. Then in my scripts, I would use getenv(). Is this a bad idea? If so, what is the preferred method?
Don‚Äôt feel depressed. It‚Äôs absolutely normal that your abilities don‚Äôt compare to someone who‚Äôs made a carreer out of it. There are also cases where beginners tend to code without a good understanding of MVC, or have a bad syntax, or struggle with OOP. For most new people that come on board, it is almost easier to start from scratch and rebuild everything. Take the opportunity to learnwhat the developer is doing differently from what you would do, and ask questions. Don‚Äôt beat yourself, it‚Äôs a normal process. You may have taken on a project that was too big for your current abilities. We all started there, and we are all progressing. There‚Äôs a guy called John Papa who does great videos you can find on youtube and one that talks about code readibility.
When you're starting out, write code knowing that your projects are going to be scrapped. It puts you in a better state to learn. Judging your future based on this one situation is the only problem I see here.
If you were honest with the startup that you had less than 1 year experience in web development, it would be ridiculous for them to expect too much from someone who is having to architect the whole platform starting from scratch. As for the other developer saying your code is bad and messy, you are new, so he's probably right. But also note that almost EVERY SINGLE DEVELOPER says the same thing about any new code base that they take a look at and many times they want to rewrite it. That's just the nature of developers coming in on a new project. It's not done they way they would have done it, so it must be wrong.
"I've been doing this for several months now, why am I not a senior yet?" You need practice, learning experiences, and more practice. And your employer deserves those problems for letting juniors run projects unsupervised. See what the expert does differently, find out why, learn from it (but don't cargo-cult his advice or style). Wait until this project of yours gets to maintenance stage, see which parts are difficult to maintain, think "in hindsight, how would I do this differently?", pose the same question to other developers, learn from it. Learn the principles of SOLID. Consider contributing to an open-source PHP project to get more feedback from other developers. 
This is quite messy a confession. Choose a part what troubles you most and concentrate on fixing this particular issue. &gt; started learning and working with PHP 7 months now (part time, still doing my masters) So you had literally not time to learn doing your masters *and* trying to program a . &gt; No wonder. Imagine you were tasking to build a car in your garage in a few months, without required knowledge and tools, only having experience in building toy cars, part time doing your masters along the way. What would be the result? Do not underestimate the science of programming. While people tend to think they can build a dating site with a half-ass effort, they have to realize that programming a fucking science, all the same just like surgery or electronics or anything else. You need **years of dedicated education** to undertake such a project successfully. &gt; it was bad and messy, and said he will re-do everything from scratch himself What else would you expect? Without proper education, without experience, going all the way by yourself, not even being employed in a software firm where you can learn from experienced colleagues? Seriously? &gt; I'm afraid that I will be replaced in a heart beat here And for the good, both for the startup, which money you were wasting, and for your consciousness. &gt; Seems I'm just not cut out for projects longer than 6 months. Does it mean you don't know how to design such big applications? Yeah, that's the part of education you are yet to learn. Software engineering is a fucking engineering all the same. A complex software application is no less complex than a plane. Don't be fooled by the fact that you were toying with planes as a child. A real plane is not a toy just bigger in the size. The structure is completely different. A complex software application is not a silly home page you were tinkering before just bigger in the size. If you still feel the passion for the web-development. Sober up, finish your masters, keep toying with small projects and doing self-education along the way. After finishing apply as a junior in the established software firm. Thus you wiull get a priceless experience in doing real things. After several years you'll be like that guy who rolled in. 
&gt; Any advice or tips on how to be a better programmer in PHP? Write as much code as you can to practice. Write as little code as possible in production. Make use of libraries that are well-documented and well-supported, and that are under current development. There is no reason to write a site from scratch right now, unless you just want to play with it. Certainly not for a production site that other people will have to support. Even if you write the best, cleanest code in the world, anyone who comes in is going to have to learn it all, whereas if you use a framework, they can look for people who know that framework. 
It does no good to just write a code. There are zounds of PHP-tinkerers around who are writing tons of code, without any bright part in it. When you're a junior, it is essential to have your code supervised. This way one would learn at a great pace. While boiling on its own, they could do very little progress actually. 
If you want to discuss web development/PHP outside of work then feel free to send me a message. I've been doing web dev on and off for 14 years (6 professionally) mainly focusing on PHP/JS.
Everyone has to start somewhere. Do not feel bad about your skills, learning, or progress; feel bad about your code. At all times. What organization strategy will make it easier to work with? What programming language feature is causing you to write unnecessary crap? Does that feature maybe exist in this language and you don‚Äôt know about it? What do you wish you would do with the code if you had fewer timelines? In other words, don‚Äôt just output code- think about code, be critical of code. It‚Äôs quite likely that this new developer simply knows the available frameworks in the ecosystem better than you and intends to use a drop-in solution. It‚Äôs also quite likely that he‚Äôs a jerk with an inflated ego. A better developer would attempt to be more diplomatic and mentoring. Going back to my first point, if you are always critical of the code you write, which you should be, it is easy to be over-critical of others‚Äô code. What‚Äôs not easy is explaining why- and that‚Äôs not a reflection on you but him.
PHP is like life, there is always going to be someone better than you at that X thing. The best thing to do is learn from the better person. Ask this new coder what he thinks should be improved, most good coders will offer advice (we all started with "hello world" !). As for the speed he's turned around the code, he maybe using a framework or reusing code he's built or refined over years of coding. 
People often don't like to work in the code of others. So just double down and ask specific questions on what isn't right and why he would want to waste time starting all over again.
Nobody knows his exact situation mr I know it all. Stop goofing around, this guy is trying his best so stop hating him for it. 
It is not a waste actually, but saving A LOT of time. We all know how one-year-experience-code looks like. There is nothing to salvage. Not only the code itself but - more important - the structure, when a bigger application is built by means of just *multiplication* of the existing code. With just one year experience there is no way to learn software architecture and code reuse. The current application is just breaking under its own weight (which is the part of the OP's lament). MVC has been invented on purpose, to keep the code at bay, making it possible to create a scalable application. It's for good that a usual spaghetti will be rewritten to a structured and manageable code.
I could also imagine a *database architecture* as well. Not normalized, without a proper relational model, with enumerated fields like param1, param2, param3... It could be only rewritten from scratch.
Look at vlucas phpdotenv. 
You need a good mentor. Maybe he can be your mentor.
Don't worry about it. If you are serious about programming, you need to give it some years before you can make a self assessment like that. Do you think that guy had that ability when he had been doing it as long as you? 
The expert is probably replicating ops work with a framework, or at least using some framework parts. Op is butthurt but the move to stop a bad codebase right away is shrewd. 
Very few people write clean code right away. Mostly code is made to work. And the refactoring is afterward. If aomebody sees bad code and says he can reproduce it in 1 week. You have to know. He has your code base. The fact he understood what you did is good. But he might want to add design patterns you didnt think about or add other smart stuff, an good programmer learns everyday and knows he will be learning a lot over his career.
&gt; yeah I'm thinking about some kind of vm with lamp stack to work in a more similar environment I would certainly look at giving Linux a try even if it's just in a VM with virtualbox or something similar, as it's all free then and costs you nothing. If not then look into docker for local LAMP stacks on your Windows machine 
The other dev will probably replace stuff with the most advanced code he can muster just to show off. 
I've been working professionally with PHP for over 10 years now and I've been in your situation more than once. You'll always find someone that knows more than you and will think that your code is shit, but the best you can do is to take that chance to ask "why?" and learn more. I reached the point that when this happens I get happy instead of sad, because I know that I'll improve. It takes a lot of time, code and mistakes to become a good developer, so after 1 year you should not worry about your code not being good, is totally normal, keep it up and you will improve. https://www.phptherightway.com is a good place to start learning some good practices. And remember that you'll always have something new to learn, and that's one of the things I love about being a developer. 
No tool for database access should be public available on production systems. And Tobe honest, don't use adminer. Due to some lack in the code it doesn't have good implementation and therefore some security problems.
 &gt;There are also cases where beginners tend to code without a good understanding of MVC, or have a bad syntax, or struggle with OOP. For most new people that come on board, it is almost easier to start from scratch and rebuild everything. Hell, I look at code I put together 3 years ago and generally curse the monkey that pasted those stack overflow answers together. 
Don't beat yourself up OP. You're only 7 months in, you have a lot to learn - quality code will come with experience and perseverance, keep at it. I look back at some of my older projects and cringe! As has been said before, ask questions of the senior coming in - you could learn a lot from them.
 &gt;Now the startup recently hired a remote part time PHP expert to help speed things up. This new guy took one look at my code, said it was bad and messy, and said he will re-do everything from scratch himself, in under a week. I'm surprised more people haven't been skeptical over this to be entirely honest. If I were you then I'd eagerly await how much he delivers in one week; but my expectations would be low and I'd be genuinely surprised if he managed anything of the sort. I would say that in 99% of cases it's very difficult - if not impossible - to take one look at a codebase and understand the plethora of decisions and business rules behind it. (If it was, then the code must be well documented and clean IMO) I'm always skeptical when someone walks in and decides they can't work with something someone else hasn't written; in my experience this is often - but not always - a flaw with the new developer. &gt;Any advice or tips on how to be a better programmer in PHP? Outsider Syndrome is too real here. Seems I'm just not cut out for projects longer than 6 months. My main bit of advice would be to relax; *it's still early days!* If you've been dumped in to the development alone whilst learning, then it's not surprising that you're struggling too. These things take time; you've clearly got the right attitude and that goes a long way. 
Also bear in mind that nearly every developer on the planet seems to have this attitude, where they will put down the codebase of whatever has already been written (especially if it isn't based on one of the big open source frameworks, but even then if it is not *their* open source framework of choice). The person is trying to make a name for themselves with your client. Unfortunately, the biggest thing isn't your inexperience (although that contributes), its that they dedicated solid time to solving the problems. Full time beats part time multi-fold, exponentially even. Jumping in and out of an old project can be incredibly time wasting.
We're three months on, and a tutorial at this site _still_ has a serious security flaw. Is it yours? Why do you not answer?
stop whining, see what you can learn from the more experienced dev. if you just have been learning for 7 months, part time, then you are a junior dev, who still needs to learn a lot, thats nothing to do with "not cut out for" its "you haven't learned yet". 
_maybe_ that's true about the framework, but I feel like there's been a general move away from heavy framework addiction lately. It's a fine way to start a project, but we're valuing good DI and standard interfaces (defined in PSRs, usually) a whole lot more. It's pretty easy to throw on composer, start installing modules to do what you need, and be off to the races. 7.1 adding the `iterable` so I can typehint my arrays, custom collection types, generators, etc the same way has been pretty huge for that too. Even if the underlying code sucks, as long as it's consistent and works (mostly) it's pretty easy to go in and refactor things piecemeal ok to be better organized. I can take a pile of directly-accessed files, and turn them all into routes by automating writing Slim GETs around includes of those files. Check which ones read from $_POST and put those in post routes. Find remote `file_get_contents` and use a GuzzleHttp promise instead. Namespace the entire codebase (eg `MyApp\Legacy`) so it's cordoned off where it won't need to drag down the rest of the codebase. There's still a lot of work that's happened even on a shitty codebase, mainly all the company review of the features.
I'm a new developer with 18-19 months of experience. PHP was my first ever language I tried to learn. I'm a mechanical engineer but I had been working on my startup whose CMS was based on PHP. So I dived in PHP development. Initially I wrote an advertiser portal for my website which was completely procedural. Natural way of thinking for any new developer is procedural programming. But I kept on learning things and realised that things should be kept in functions for better usability and clarity. With this learning I changed my codebase in functional programming. It was clean and readable but it was still very confusing. A lot of variables and functions were connected and everything was very confusing to manage. There were just too many variables and functions to handle. Then I read PHP MANUAL and got to know about OOP. Boy, it was a drastic change. I changed my codebase completely to OOP and kept everything in classes. Functions changed into methods and variables became class parameters. After this, codebase was so clean and easy to follow. Few more things that I learnt during the development are - always put comments, learn security basics of the language you're learning, before implementing any feature - always search for good practices used e.g. how to create a secure login system or how to create a secure private key etc., keep practicing and ALWAYS ask for help despite people making fun of you. I ask a lot of stupid questions in this community. If I don't know, I don't care what people think. I just post it here. People downvote it, make fun of me but 2-3 people who reply, always give good advices. Right now I'm contributing to an old CMS which has been restarted by its old developer. My main point of focus is security and I've contributed a lot in it now.
From the opening post we can definitely say that a code doesn't work. Besides, not every code is salvageable. For example, without decent knowledge or experience, one's database design would be outright wrong. And after shaping it back to sanity it's impossible to keep the handling code. Being in charge for the task, I'd ditch the existing code completely and start over. 
Code fearlessly. Try new things. Write some own open source libraries and deal with the feedback. But most importantly: Don‚Äôt restrict programming to work only. If you want to be good, 8 hours a day won‚Äôt exactly get you there quickly. Think up some own, smaller private projects, pick up a framework (Symfony, if you want to learn full SOLID) and then don‚Äôt let go of it, sit at home and work on it. There is no shortcut to becoming a good programmer. It took me 12 years up to this point, I am sure I can do anything these days and I still, I basically learn a new thing every single day. This will never stop. If you don‚Äôt feel like you‚Äôre learning new things, you‚Äôre going to stay behind quickly. Things always evolve. If you need specific help on some topics, feel free to PM me.
Sounds like a bad work environment, though maybe that's a bit more normal for a startup with less structure and employees. I work at a large software company, and we'd never give someone new a large project like that to do alone. It would be planned out as a small team with progress continuously discussed each day so there would never be any moments of surprise in terms of "oh this is only how much we've got done so far?". The code would never get too messy since you'd be reviewing each others work as a team and improving it collectively as you learn from more experienced coworkers. It's also usually a smell when someone new comes in and starts taking about re-writing everything since often that's a developer's natural instinct but usually not the right business decision. For all you know he may simply not like the framework you chose or something trivial like that. But the point is that you shouldn't blame yourself since it sounds like you tried your best and the startup clearly isn't a great workplace match for what you need to successfully grow as a developer. 
You gave it your best. Stop whining and learn something from this. Whenever the new guy does something different from what you have done, ask him why he did it like that. Compare advantages/disadvantages with what you would have done (readability/easier to understand or extend/uses X design pattern/whatever). We learn more from failures than from successes, so cherish the fact that you can fail without much fallback (except to yourself) :-) I work on an online shop, if I mess up badly, ~200 factory workers lose their jobs. So keep calm and learn from your mistakes and if possible - from other peoples mistakes.
Absolutely spot on, that one line show's the OP's flawed thinking. In all skilled professions it takes longer than "several months" to become good at what you do. Programming is no different, it's a skilled profession on many fronts; * Language / Syntax * Framework / Architecture * Tooling * Platform/OS knowledge * Collaboration * Maintenance To become proficient in all of these takes years of working in the field commercially and learning from other experienced devs. As someone who has worked commercially for around 10 years, I'm still learning new stuff every day and always looking to expand my knowledge and improve upon everything I do. 
It‚Äôs a turn of phrase. Not a command. Lighten up.
look at other peoples code (eg on github) but prefer bigger projects where many devs are working on it. Then practice, practice, practice. I can also recommend you a book called "the clean coder" - it is not a php related book, it will show you how you can become a good developer.
Here is the `Go` version of jsonq: https://github.com/thedevsaddam/gojsonq
The primary goal is to not bundle secrets in your image(s) at all. If someone were to get ahold of an image, they would have all those secrets -- doesn't matter if those secrets are in a file or set via an `ENV` stanza in a docker file or passed in via `-e` with docker run. Try this: run a container with `-e` (and with a `--rm` flag). Find it's ID with `docker ps` (or otherwise). Then run `docker inspect` on it. You'll be able to see the environment variables set with the `-e` flag even after the container has been stopped. I use [this approach](https://chrisguitarguy.com/2017/12/23/secrets-in-dockerized-applications/) to fetch secrets from a parameter store into memory when the container starts. 
Yes, this `Go` package was inspired by this package. You will find `JsonQ` on `gojsonq` readme
This does make more sense, I'm used to Java where an object never gets or loses properties. Is there anyway to tell phpunit to use a custom method? If I write multiple tests with the same object I'd like one place to set all the properties to test, less chance of missing a field in a test when I add more properties to the object in the future. Really appreciate all the feedback
&gt;to take one look at a codebase and understand the plethora of decisions and business rules behind it You may be giving way too much credit to the existing codebase, assuming it's actually functional. One week of 30-50 hours from an expert using modern tools/libraries/frameworks can yield far more than someone who's learning as they go, part time, over the course of several months. Some initial thoughts: * Is version control being used? * Ignore whether tests are written or not, is it even in a position to be tested? I often run across code which is practically not possible to be tested in an automated fashion (unit or browser). * Is this OP using mysql\_\* functions()? * Are they using PHP 5? Is SQL injection easily spottable (an expert can often spot than in 10 seconds with a quick code scan). * If libraries are being used, are they remotely up to date? * Any tools or scripts to automate deployment? \&gt; .. decides they can't work with something someone else hasn't written; in my experience this is often - but not always - a flaw with the new developer. It's often not worth the time to dance around all of the issues that have been created by a beginner. I was brought in on a recent project. I've worked with this client before. They'd had an intern write a small registration system. Screen 1 - enter your name/contact info/background info Screen 2 - select classes based on semester from screen 1 Screen 3 - confirm classes Screen 4 - confirm all info Screen 5 - thank you I was asked to add a payment process to this. Had this process been done in any modernish framework which enforced a separation between templates and logic and library loading, it probably would have taken a few hours. I \*usually\* recommend to rebuild from scratch with the lessons learned. In this case I didn't. Instead, several hours were initially spent * upgrading from 5.4 to 7.x (this was written between 2016 and 2017, IIRC - PHP 7 was definitely out, and 5.6 was latest PHP) * separating out \*some\* code to be reusable (because it was needed in the payment process) * setting up some autoloading * setting up a test environment (to allow for test payments, and test credentials for db, etc) * setting up version control * all code is owned by root running under /var/www/html - trying to undo that while being mindful of downtime (because it was a live system and \*only\* a live system) "just set up a dev system!" Well..., they're not allowed another server right now, and DNS changes take a long time to request to add another A record (long long story). So... couldn't I just write "[foo.site.com/test](https://foo.site.com/test)" instead of "[foo.site.com](https://foo.site.com)" ? Nope, because the site was littered with hardcoded redirects (sometimes to full domain name, sometimes to hard paths). I regretted not saying "let me just rebuild this from the ground up". I ended up spending several (probably more than 10 overall) dealing with dozens of little "gotchas", having to read through thousand line files (because the HTML and PHP are intermixed in dozens of places), cringing at every SQL injection possibility, finding multiple repeated - slightly different - SQL queries, etc. In the end, if you're going to need info about a student record, just write a 'getStudentInfo($id)' function to query and give back a object or array. Do not do something like &gt;$name = select name from student where id=$id; &gt; &gt;// print name &gt; &gt;$email = select email from student where id=$id; &gt; &gt;// print email &gt; &gt;// etc In the end, I patched some of it, but told the client I did what I could, and the payment stuff is in, but the entirety probably should be rebuilt sometime soon because of the problems found, but there simply wasn't enough time to fix/test everything. Using modern tools from the ground up eliminates (or at least greatly reduces) some classes of problems. So yeah... it's possibly something "wrong with the new developer", but... they may have a deadline to hit. Or may be told they're responsible for the code/project/issues now. You have no idea of the state of the OP's code. And yeah, it's hard to believe much can be done in 'a week'. And often that initial 'week' estimate may be wrong, but it's often wrong because a) a piece of functionality or business rule is completely unclear and b) one can't get a straight answer to clarify.
&gt; This new guy took one look at my code, said it was bad and messy, and said he will re-do everything from scratch himself, in under a week. This dude sounds like an autistic asshole. Don't ever, ever aspire to be like him, no matter how "good" he might be. Saying your code is bad and messy is typically asshole programmer talk for "it's not how I would have done it, therefore it's shit". Oh, also, I work(ed) with someone exactly like this. His work was legitimately shit (by consensus of the rest of the team) and he was fired for being non-collaborative. A good programmer will give constructive criticism and bring you into the solution they may want to deliver, not just say "your work is shit, I'll do it on my own in a week". &gt;I'm afraid that I will be replaced in a heart beat here. If that will be the case, then the company isn't worth working for. They should have been able to gauge your progress much sooner than the drastic action they had to take 7 months in. It should never have come to this. &gt; and that the past 7 months of learning PHP was for nothing. Learning is never for nothing. &gt; Seems I'm just not cut out for projects longer than 6 months. Large projects of that scale are rarely meant to be done by one person in a silo. There should be basic oversight in place, no matter how small the company is. Even if it's just to keep you on track and focused.
Thanks for the reply, I think I just took the hit too hard, rather than having the mindset to learn from this. I found some resources for MVC and OOP best practices, and will continue my learning journey.
Haha, yeah I may have done that too much as well.
You've got that spot on. I truly wish I could be fully immersed into the project and work full time. But I need side projects that pay in order to keep the lights on. I feel that I may be stretched too thin and can't spend the time I'd like to for learning and progressing with PHP.
&gt; carreer 
I do my best to manage their expectations of my less than 1 year experience. Until now, it seemed sufficient for the project (it's not overly complex). My worry is not that they hired someone new to help (I've been advocating that they do), it's that the new hire is remote, so learning from them is difficult. I realize it's up to me to learn and grow from this experience, your perspective that everyone goes through this really helped get my confidence back, thank you :)
That's a good way of putting it. I think it's the state of not yet receiving this guy's code and not knowing what it will be like that is making me worried. But how this post was received by the PHP community definitely put a grounded perspective on this experience.
There's probably a lot of work to save the code that I wrote, I'm starting to realize that it may have been the better move to restart because there wasn't much there to begin with. When we were interviewing for an expert PHP developer, 9/10 of them said we should build this with Laravel. Wondering why to many developers rely on that framework for such small projects.
What got me from the remote developer, was his lack of questions or inquiry into the code. He just outright said to scrap the code without seeing all of it. He didn't looking into the database architecture. I see that I have muuuch to learn.
Now you have the attitude I wish I could have upheld during this experience! I had hoped that the new developer wasn't remote, so I could directly learn from them and know what I did wrong to improve. The communication just seems that he will swoop in and fix things, then fly away. He's pretty active on Skype, so hopefully we can video chat often. Thank you for the resource! I'm excited to learn and grow as a PHP developer, responses like these really help with the journey :)
Maybe think of it like this: you should be very familiar with the problem domain by now. So if you get to look at the code that the other guy is going to deliver, you may be able to learn a lot from that.
You are absolutely right, I'm (lower?) than junior at this point, and should take advantage to learn from those with more experience. I agree that this problem wasn't anticipated on some level, it sadly took longer than expected to get a senior PHP developer for the team. I had hoped that the new hire wouldn't be remote, so I could learn directly from them. Video chat will have to do. I will definitely look into SOLID, thank you for that resource.
&gt; Wondering why to many developers rely on that framework for such small projects. Less work, quicker results.
You learn the most when you work in a team I can tell from experience
Do you have sample code that we can give you hinters against?
This definitely puts my situation into a better perspective. It's amazing how much I still have to learn, and I should have been more humble with what I don't know. I'm still slightly worried that not knowing enough gets you the boot from the team, but I will just have to demonstrate that growth mindset and remain positive. I'm excited to learn and grow as a PHP developer.
Hmm, never thought of that before. That seems like a good mindset where you're not married to the code you write, helping you be more flexible and adaptive.
Check out Laracasts.com
There are two kinds of ready made modules incorporated in a full-featured framework: ones you already have an idea of - like authorization, access privileges, form handling, email handling, data validation, application architecture; and modules which are essential but you are yet to learn their importance - logging, debugging, maintenance, database abstraction, templating, routing, job and message queues, HTTP request handling and many, many more. All this code - mind you - already written, tried and tested. So you can tell that a framework already have 90% of code you need. And this code is much better than anything you can roll up yourself, simply because it is written and constantly updated by many people, not just one developer part time. So that's why developing without a framework is out of question nowadays. 
I've made a career in PHP, I'm working with it for 15 years now, and the only way to get better at it (or at anything in life) is time + practice. You have a good opportunity to learn with someone with more experience, sease it!!! Don't give up, if you're really into programming with PHP. You'll get there ;)
Thank you so much for this in-depth reply, it really puts things into proper perspective now. I had been advocating that I'm only junior at best, and that it should be lead by someone with more experience. The kick was a remote hire, so learning and collaborating from them has a few more hurdles. Your analogies were really helpful, especially the planes. You'd make a great professor. The replacement comment was a harsh truth, but one I needed to hear. I'm excited to continue my journey of becoming a decent PHP developer, and things won't always go the way we expect. Seems like my attitude and expectations needed some re-adjustment.
If you don't look at your code you wrote a year ago and ask yourself what the heck you were thinking, you haven't learned anything.
This is a great reply, thank you very much! I do believe the remote developer is re-creating the platform using OOP. That is definitely something I need to brush up on and learn more. Flying solo on a project with a junior level skill, I believe this situation was anticipated on some level by all of us. We just had hoped the new hired wasn't remote, so I could learn directly from them. But all these comments re-emphasize that my expectation and attitude need to be adjusted. Your comment definitely puts things into better perspective, thank you.
I do need a mentor, here's hoping he can help with that. How long have you been working with PHP?
Wow, thank you for the offer! May just take you up on that :)
&gt;don‚Äôt just output code- think about code, be critical of code. Well, you were spot on with how the project was progressing. Working on this part time, I didn't dedicated nearly enough time to be critical of what the code would be. Just thought I always was playing catching, and output was the best way to throw things together. I guess this bridge was built too fast and too flimsy, and has now collapsed. Talk about a learning experience here. Thank you for this comment, I definitely need to ask more questions.
Very true. I need to stop taking this personally, and take it as a great opportunity to learn and grow as a developer.
That makes a lot of sense. My code was probably garbage at best. I hope that I can continue to contribute to this project, it would be much better in the hands of someone more experience that I could work off.
That's true. Least there wasn't much to begin with, so starting from scratch is probably the best way to go.
That's an excellent question. This guy most likely had a similar situation as I did when he first started out. I'm just hoping that despite him being remote, we can still collaborate and I can learn and grow from his experience.
Thank you, that really means a lot. I know there's a world to learn, and I hope this new hire is a great mentor I can learn and grow into a decent PHP developer.
Often coworkers will end up rewriting other's code. It's normal though it's annoying. My boss likes to refactor code, ALL code. He's known for this by anyone who works with him. Sometimes doesn't really understand the code he's changing. A lot of times he's breaking things, sometimes badly. I do learn from it, even if the changes he makes was pointless. Sometimes the changes he makes actually severely reduces the functionality of the design because he never understood it. So it happens to even developers who've been coding for years. Being a new coder, you actually have a chance to learn how to do it better by seeing what he writes. It sounds like the new guy is somewhat of a jerk though. He could easily have been far more polite about it.
I am excited to see what this developer can deliver in under a week. I would be happy if he can do it, and get things up to the point it's at now. My only concern is he may have used off-shore developers to whip something together, and he didn't ask many questions on what to rebuild. I remain cautiously optimistic here. Thank you for the perspective, you are absolutely right, these are still my early days, and I still have a world to learn and grow. I feel especially lucky that I can already do what I love every day, and having difficult times is where we can take the opportunity to learn from.
My code was probably garbage and it was a good call to re-do it from scratch, as there wasn't much to begin with. My code sounds similar to the issues you were talking about. I definitely have so much more to learn, I'm just hoping that this new hire is a good mentor and is willing to teach me a thing or two, rather than just swooping in to fix problems and fly away. Either way, it's up to me to adjust my attitude and push forward through difficult times.
Those are all great points, especially if I'm not learning something new, I'm probably falling behind. I've been so caught up with trying to deliver specific things, that I haven't dedicated nearly enough time to learn new things. That may be my biggest mistake here. I am excited to learn new things, I just need to give the time and effort. Thank you for the PM offer, just might take you up on that :)
The startup situation I'm in is definitely unique from traditional development environments. I wish I had the expected junior role where my contributions are minimal, and my learning stems from the experience of the seniors. However, I'm learning that nothing ever goes as planned, I need to adjust my attitude and expectations. 
The corp I work for is underwater with technical debt, because they hired a very talented but completely inexperienced programmer, and let him go at it alone for 6 months. He later rage quit, because even he couldn't even fix the problems he caused without complete rewrites of major functionality. So be happy! You could have had your first try actually get to market unchecked, a fate I would wish on no developer.
Thank you for the book resource! I'm definitely going to read that one, seems like a must for every aspiring developer.
That's a good way of putting it. I wish I was able to spend more time on smaller projects to try out new things and learn as I go with a variety of projects. I definitely need more practice, just typing this out re-ignites my excitement to learn and grow as a developer.
That's the main thing that went wrong with my situation, a junior's code went on too long without supervision. The little kid got in the driver seat and drove the car right into the garage door. I'm sure starting from scratch was a good call by this new developer, I'm hoping to learn a lot from them.
I read the first line as "PHP is life", haha. But seriously, you make some great points, I should definitely ask more questions and learn from this experience developer. I'm excited to continue to learn and grow as a developer, this set back was an opportunity to learn something new about code production, that's for sure!
Just stick with it. 7 months of learning is not much time, I'm surprised you even had a paying job with it yet.
You're absolutely right. This isn't about my skill level, but how I react to this situation and learn from it. I definitely need to adjust my attitude and expectations.
You‚Äôre right, sorry, typing on my phone and autocorrect disabled.
That's a good point I hadn't thought of. While my code may not have been great, perhaps there is a silver lining to having this new guy start from scratch. I can now learn from them on how to properly code this project.
I hope that's not the case! I'm cautiously optimistic that he will explain his new code in a way that helps me learn what it takes to build a functioning and stable environment.
That's a good point. I haven't learned much in the past few weeks, but this experience was something I learned a lot from. Here's hoping the remote developer is a good mentor that can teach me new things, and help me grow as a developer.
That's a good point. I cringe at my early day code, despite still being in my early days of code.
That's true. I'm cautiously optimistic that I can parse through the new code (once it's delivered) and learn from that. It would be a bonus if the developer teaches alongside the code delivery, but I'm going to rely on myself to learn and grow, not expect someone to hold my hand every step of the way.
There's a reason this is a high-paid, in-demand field, in spite of not having a lot of barriers to entry, risks to safety, startup costs, etc. It's hard. Don't believe all those cliches about brilliant wunderkinds who are instantly awesome at everything -- most of that's marketing that capitalises on that whole "my grandkid's so good with the cyber" nonsense that old people fall for. There are some people who have made popular things very quickly, but it's usually a combination of focusing only on one thing, and the good luck of being in the right place at the right time. Ever read some of the \[early source for facebook.com\]([https://gist.github.com/nikcub/3833406](https://gist.github.com/nikcub/3833406))? It's total spaghetti, and this is the code they had running in-production after rolling out internationally. You can imagine how bad it must've been in his first iteration -- not something you'd expect from the character of an eccentric genius played by Jesse Eisenberg. Programming is a craft that takes years of dedication. As a new dev, keep learning and accept that it's going to be a long time before you're \*\*good\*\*, and instead concentrate on the more immediate goal of being \*\*not shitty\*\*. I hire juniors and interns all the time, and some may show great promise and I believe they'll be great developers someday, but I care far more that what they write isn't shit. In programming, good code and shit code don't exist on the same line, but really in parallel, where you can solve the shit-problems much more easily than developing good programming skills. So what can you do to write code that isn't shitty? * Use a styleguide. Any major styleguide, really. Either what's on the project, or pick literally anything common. PSR4, Pear, even goddamn WordPress are fine. People have all kinds of opinions about which is best, but above all being \_consistent\_ is what matters. You'll find plenty of good devs who prefer spaces to tabs or tabs to spaces for indentation, but nobody thinks that sometimes using tabs and sometimes spaces is good. Same goes for every other style decision. Every codebase I've inherited that didn't have a consistent style, I instantly disliked the previous devs for. Install phpcs and run phpcbf on everything you have. * Use composer. If you're installing other people's code by saving it directly into your project tree, you're making a shit project. * Avoid globals at all costs. If you need something to be accessible throughout your project directly (e.g. a database connection handle), that's what static class properties are for. Polluting the global is awful, and \_very\_ hard to clean up automatically. * Don't \`echo\` things unexpectedly! You should never suddenly echo without it being very explicit. Nobody wants to say \`$name = $user-&gt;getName();\` and mysteriously find output inside the page html.
That's true. But do you think someone with my low level of experience should dive into a framework? Doesn't that develop a crutch for it if I were to start a new project?
That makes a lot of sense. I've heard that using a framework for early learning isn't the best because you then rely on it for basic things. Just curious when is a good time to jump from learning the basics by hand, to furthering your learning with a framework. Not sure if I'm there yet.
I'd love to chat/help you learn. Send me a pm with your discord or skype if you're interested.
That's a really good point there. Yes, it sucks when others straight up tell you your code sucks, but then again, there's a silver lining here. My code was probably garbage at best, probably a good bet that it's starting from scratch. Definitely the kick in the pants I needed.
&gt; my phone There's your problem.
Wow, thank you for the PM offer :) Very kind of you.
Thank you for all these tips and resources! I like the way you put it to not be shitty, rather than striving to be good as fast as possible.
Seems like you've got most points spot on here. Although the new developer is remote, I'm hoping that once the new code is delivered, he will explain and teach me something new. I do realize how much more time I should be spending on learning and growing as a developer, rather than just outputting code. While this was a set back for the team, I definitely learned a great deal from it and all these great comments.
I hear that. It's been tough flying solo with my experience level. Hopefully this new developer will not only give us great code, but also be a mentor for the team.
I can share some of the code with you, it won't be of the actual project, but of one that I coded in a similar fashion. I'm also prepping myself for some harsh comments, so don't hold back, haha. 
This link is great! Thank you so much! Will definitely watch these videos.
While it's a short comment, this really means a lot to me, thank you. It excites me knowing how much out there I can learn and grow as a developer. My expectations and attitude needed an adjustment, and this experience and these great comments helped with that.
This makes a lot of sense, I should treat this experience as something I can learn from. Glad we're all in a similar boat that we can collaborate and all learn from.
Thanks, concise yet effective. I'm excited to learn and grow as a developer, this was a great learning experience, I'm coming to realize that more and more.
Learning basics is one thing and building a real life app is another. You are tasked for the latter so you have no choice actually. Either way, given you already have finished small projects, it's perfectly OK to start using a framework
That's kind of a personal thing. If you're not constrained by time, I think it pays off to first try without so you get an idea of the problem domain. Then, once you thought in depth about it yourself and have formed some opinions of how to go about it, you take a look at how the big guys do it. Others may think that you're just wasting time and should just start with a framework right away, so you have guidance in the right direction from the start.
Why can't posts contain a body here? Anyhow, here's what I wanted to write: I'm building a market place with auctions. I need to end auctions preferably at the exact second they are defined to end according to their record in the mysql database. I know about CRON jobs and I'm currently running a CRON job every minute to execute some script which checks if there are sales that should end. However this sometimes means that an auction ends almost a minute too late, which is not acceptable. Does anybody know how to make this more accurate without putting a lot of load on the server? For example I wouldn't want to run a script every second to check if sales have ended.
[For a reason](https://i.imgur.com/DK1ckG8.png)
FWIW, none of this was directed at you personally. And... while it will be good if this person is a good mentor as well, I can say I've struggled with trying to do both adequately, especially under deadlines. I can make it work correctly, or I can make sure someone else is up to speed, but not necessarily both at the same time. You definitely need to ask questions, but make sure you find the answers elsewhere if this person does not give you what you want. Actually, go verify the answers elsewhere too. Much of programming at this level has some opinion to it, so getting other views and finding some consensus will help you a lot.
Those are fine reasons to use mature, developed _modules_, but it does not follow that you need a "full-featured framework". While laravel is excellent, and studying it can give you a good idea of the sorts of things that go into a web app, there's a lot it does that violates the D in SOLI**D**: abstractions should not depend on details; details should depend on abstractions. When you have a monolithic framework, that often (but not necessarily, and as far as frameworks go Laravel is better about this) requires that you use specific implementations for everything to work. e.g. the kind of Controller method you'd pass to a class in Laravel they document like: public function update(\Illuminate\Http\Request $request) What's bad about this, is that you're type-hinting on the specific implementation of an Illuminate-library's idea of a Request. Slim, on the other hand, looks like: function (Psr\Http\Message\ServerRequestInterface $request) Which uses the standard PSR7 request **interface**, not class. Any request type that implements this interface can be passed in, and more importantly passed along to any other libraries that accept PSR7 (e.g. graphql-php, GuzzleHttp, etc.). If you use laravel, it's very easy to be forced into doing things the laravel-way everywhere. That might seem fine, or even desirable, at first, but it severely limits your ability to integrate with other modules (including your own), and ages _very badly_. You'll be stuck on this same framework, dragging along any dependency it has, for a long long time. I have Slim for routes, Phinx for DB migrations, my own logger (needed to integrate with the old system) that implements PSR3 so it can be used with other modules, lcobucci/jwt for securely using a 3rd-party auth server, etc. If we decide we'd like to make a change from any of those things, we can easily move without throwing out the baby with the bathwater. We've already been through a similar transition and disillusionment with big-frameworks in the JavaScript world. People used to love huge frameworks like jQuery, angular1, and even well-implemented ones like lodash. Lately more devs feel trapped than supported by these frameworks, and when possible we simply install the modules we like and use those.
Gee, you're really being helpful
This^^ saying all the existing code is shit and you can rebuild it yourself in a week with *insert framework that is superior because you know it best* is pretty much standard operating procedure. Usually it's an exaggeration, but if this was your first project it's probably true (and that's ok). This is actually a great opportunity for you, you'll learn a ton getting to see how an experienced dev rebuilds something you already know, and then after they rebuild it you'll be the cheaper dev that already knows the business. Also, even if you're an experienced developer looking at your own code, pretty much every project is going to need a rewrite at some point, often more than once. The first go at it is guaranteed to be a draft, and I find it's best just to accept that from the start: move fast and figure things out. Throwing out the first code base doesn't mean you wasted time, it's how you learned what you need to build. Even if not much of its text survives, its spiritual foundation is what allows the always-alluring v2 be so grand
Keep with it, you'll progress and gradually more and more of your side projects that pay will be teaching you, it snowballs
What you care about is that no actions can be performed on the item after it has ended. If the item has an end date associated with it, just check that the current date is less than the end date before you perform any action.
First for all, this sub is for PHP news articles, techniques, stories etc, but not for help. If you want to check it down to a second, just do a if statement on the query or in the php, that `if status=ended or time_now&gt;=expired_at` then the auction is ended. Either a query, or just the php code check it when you need it.
agree
I recommend this: https://laracasts.com/series/php-for-beginners Basically, go through all the series here: https://laracasts.com/skills/php
I would be happy that you are willing to learn and that your company is willing to improve existing code. The company I work for right now is one of the largest in my country and we are using PHP 5.6, no unit testing, mysql_* functions, no version control just like mgkimsal has mentioned. I am a newer hire, the lead developer has been there for 8 years and the second developer who is almost as modern as me has been there for 4 years. There have been no attempts to modernize, even with a brand new website we are making. It's making me a bit sad, but I know I'm going to be out of here in a year or two. 
You're being really """REDDIT""".
No worries! By the way, read this, it's spmething I've suffered from on my way to becoming a senior dev: [https://medium.com/learn-love-code/developers-how-to-overcome-imposter-syndrome-48edee803cf4](https://medium.com/learn-love-code/developers-how-to-overcome-imposter-syndrome-48edee803cf4)
Good to hear. And let me reiterate, a developer coming in and claiming that the code is a mess, is not just for code created by newbies. It's for every project. From yours, to WordPress, to Magento you can read all day long about how "terrible" the WordPress codebase is. But just keep reading and updating and fixing your code. I never really learned from other developers I worked with. I learned from stack overflow, articles, books and videos online. Search for specific solutions to what you are working on. You will rarely be the first to do something similar. And don't reinvent the wheel. If you aren't already, start using a framework like Laravel and learn to use Composer. I wish I had started using composer years before I actually did. It can really speed things up and help keep your code modular. 
I am a PHP developer with over a decade of experience in PHP, C, C++ and C# before that. I still am learning new things every day about PHP and more importantly about Clean Coding, OOP and TDD. I would recommend you become a student of Uncle Bob's clean code series. Regardless of what programming language you use, if you don't do TDD and clean code, you are just building a one off that will be thrown away as time rots your code. I work with many young coders and the biggest problem I see is short slightness. They think the end goal is write lots of code, some what adding the features needed by the users. While that can provide short term value, it is a long term liability. The end goal of coding in the corporate environment is code that can evolve in harmony with it's dependencies and new feature requirements. The way to do this is to follow good TDD and Clean Code methodologies. Five years from now a new version of the language you code in will have been developed. A new version of the framework you code uses will have been developed. The libraries your code depends upon will have been upgraded or abandoned. How will your code evolve in concert with these changes? How will you keep your code relevant in a changing environment? The answer is automated testing. How do you keep your testing automated, by starting with the automation, not just the code. That methodology is TDD. Every line of code is a liability, that will have to be updated, read by other developers, modified to meet new requirements. Only the features provided by the code are assets. This is the key to becoming a true Software Engineer.
&gt;You'll always find someone that knows more than you and will think that your code is shit It's worth noting that "good code" is highly subjective. Sometimes two developers that are equal will do things different ways and think the other one is doing it wrong. It's arguable that usually in that scenario someone is "more right" even though they're both "right". The point is developers are highly opinionated usually.
Cheapest here: [https://bitpress.io/docker-for-php-developers/#packages](https://bitpress.io/docker-for-php-developers/#packages)
Ha, nice!
A framework isn't a crutch. It's a layer of abstraction, allowing you to focus more on what the application needs to do and a little less on how to do it.
It may develop a crutch but it's not necessarily bad. Being able to understand how a framework works and being able to work with a framework is a skill all in it's own. You may be a great developer but if you can't wrap your head how other people's code and code that follows different principles than your own then you're going to have issues eventually (usually quickly actually since companies generally don't hire devs to start from scratch). If you're going to have a career as a developer you need to be able to work with all types of code. Working with frameworks is good to jump start projects, also a lot of companies use them, you should also be able to understand and deal with spaghetti code, OOP code that uses no framework, etc..
My advice exactly. Results talk, bullshit walks. The primary deficiencies of "pretty good" coders are that they mis-attribute a lack of ability to read code, and the related ability to read their own code as "my code is better". They then almost always underestimate the time needed to accomplish the same task.
Just to reiterate- your goal, as a developer, should be to generate as little code as possible. Each line of code is a liaithbility; some poorly written lines spread like cancer across dependencies, in an exponential manner. Technical debt has to be paid in maintenance, bugs, and efficiency of adding new features. When you are writing something new from scratch that is going to be a platform, you should always keep the ramifications in mind and make sure they are balanced with business objectives. Unfortunately, php, historically, has a tendency to be easy to learn but difficult to curb poor practices. I would encourage investigating how things are implemented in more strict languages, such that you have better habits when you write in php. PHP is great for a lot of reasons, but in a double-edged sword kind of way. And with many of the new language features, they added better, more resilient options while leaving the old options available. When you find solutions online, you should try to make sure they are the best currently available recommendation in the language version you are using.
You're welcome. Here are my 3 favourite sources for writing good PHP code: 1) https://www.phptherightway.com 2) http://php.net/manual/en/index.php 3) https://paragonie.com/blog These will cover the most best parts for writing good and secure PHP code.
Try a more efficient framework: Here is a good and free course - https://www.udemy.com/web-apps-with-php-and-atk/learn/v4/overview
I agree in the fact that 2 devs that are equal might have different approaches, it happens all the time, but different solutions is totally different to bad code. IMHO bad code is for instance having hard dependencies, not following some code standard within a team, don't write tests and so on. Every time you need to solve a complex problem you'll have multiple ways to do it, 99&amp;#37; of the cases with pros and cons with each solution. As long that you can stand for your decisions based on good practices I wouldn't consider that some code is bad, even if it is different than my approach. Currently I am working in a big company (over 1000 devs) and they write really bad code (for example singleton EVERYWHERE), when I try to discuss about it with my coworkers, explaining them why something is bad, the usual response is "That's how we do it here"; That is what I consider a bad developer
Get better, there's no other advice. PHP is especially friendly to newbies, and lots of people have been writing it for a decade, so it's very easy to have a better outlook on things than a guy who just picked it up. Get used to it, that will happen again in your career. Don't take offense, take it as an opportunity to learn how \_he\_ does it.
You really shouldn't worry. You have the opportunity that many developers dream of, being able to learn from somebody that's been in the industry for years. Observe what he does and try to understand it but also don't be afraid to make your own suggestions. Now is the time for you to really learn and get all of the questions that you have about the nonsense of php answered.
Tim?
WordPress is woefully behind the times in every possible industry standard. You will have to roll your own system. Some people I've worked with have just sideloaded other frameworks for maintenance tasks like migrations.
I was afraid of that..... Thank you for your input though! 
Great! The teacher Jeffrey Way is awesome. One of the pioneers in PHP right now.
Also don't forget that programmers are usually self centered egoistic assholes. They'll say your work is crap many times when it isn't :D Don't be that guy and try to no be affected by not constructive comments ;)
After a while, I've learned to laugh at some of the silly way I wrote code. Even code from a year ago.
I‚Äôm a dev and have worked with WP on and off over the past 6-7 years. Honestly, I don‚Äôt suggest it. These sites get hacked, get bugs, have outdated plugins. Setup is very easy, but maintenance and performance is 100% guaranteed to be a bitch. I will only use WP now if it‚Äôs a very simply content driven site, and I will only use plugins that have long-time/invested companies backing the plugins. Otherwise, I‚Äôll build the site/app/functionality in any other number of ways. However, it‚Äôs good for job security because there will always be problems XD
This might not help in your situation, but for my most recent Wordpress client I migrated their site over to wpengine.com. Whenever I do work I just use their tools to copy an image of the live site to staging, make my changes, and then copy staging to production. Working with Wordpress is like time traveling to 2008. Best of luck with that.
Thanks for your input. I normally wouldn't use Wordpress, but this for a charity (one my girlfriend is significantly invested in so it's hard to decline working on it) and I'm just trying to use what's given to me. I'll just look for plugins that allow me to keep some semblance of order in my workflow. 
You want to build robust systems but that doesnt mean they need to last, your code, your project is going to be either rewritten or binned eventually and replaced. All you need to care is that you are learning and putting an effort in to follow best practices *as you understand them* at that time. There no way I would expect someone with a years experience (degree irrelevant for now) to do anything more than support, feature addition, and code optimizations. &gt;Seems I'm just not cut out for projects longer than 6 months. This here, bullshit. You are cut out for this, in fact your the cunt that gets annoyed he isnt better, and tries to get better. As long as you dont burn yourself out or realize when you are suffering from Imposter Syndrome then you are going to be a fucking master at this. Maybe not soon, but you try, and you improve and thats all someone can ask of a guyt in their team. Are you ready to build a big system from the ground up? Probably no, so dont let anyone expect that of you, and dont go selling anyone false promises. But could you? With time and research? I bet you could, but we dont get that kind of time in this business. We get the time we can fight for, and even then it isnt always enough. But you have a guy who waltzed in, shot your code to pieces and is ready to rebuild in a week - no problem, that shit happens. You know what is positive though? Your work said roll with it. They didnt say "fuck this guy then, he is out". Take this time to ask the guy what the problems are, where he thinks you can best improve and then self evaluate them. Because they might be wrong. Know how many people Ive caught talking shit about a project only to fail at understanding the first part of it? When you help train/help a lot of devs you learn quickly who has the god complex or a chip on their shoulder constantly needing to validate themself. Just relax, take it as it goes. 
Burn it.
Would be great if you can share what is your workflow? What do you use? Especially if you have worked with ecommerce. Thanks. 
More important than the programming language itself is knowing programming techniques and paradigms. It's more important to know what, for example, Dependency Injection is and when to use it than knowing how X or Y works in one specific language. This will automatically make you a better Software Architect (sounds a lot better :P) and make you think different while solving problems. Furthermore, it's always nice to take a look at GOOD code like Symfony components to see what qualitative code looks like. Don't stop to work on yourself and always have the will to optimize!
I've been coding professionally for 30 years and I still frequently feel like I know virtually nothing. Don't worry, you'll have this experience regularly throughout your career whenever you try something new. Only difference is as you get older the domain of things you do know increases so you're in the opposite position from time to time - BUT don't get cocky about that either - I'm convinced over the last 30 years the ratio of what I don't know to what I do know has been increasing (and accelerating). Also, I think it takes about three to five years of coding professionally full time to learn how to code competently (the idea that you can learn to code in a few weeks of intensive training is simply snake oil). Don't be hard on yourself, you're still at the baby-steps stage. If you love coding you'll learn.
Does anyone know how it compares to Percona online schema change? I've been using it and it's not easy to get the right parameters to prevent locking from happening. Thanks for sharing, I didn't know about InnoDB Online DDL: a native solution is most welcome!
While I agree WordPress is lacking in modern standards, there's no reason why you can't implement more modern practices into your theme/WP workflow. For example, u can use composer to manage your dependency, Twig for your templating. I'd suggest taking a took at the Timber plugin, which makes working with Twig abit easier. I'd also checkout WP CLI if u like working via the command line. In terms of syncing your changes WordPress does have an import and export, which might be useful. We use the ACF PRO plugin for development which makes developing functionality extremely easy. If you create a acf-json folder in ur theme, ACF stores the field groups as json files. It's a simply process of FTPing / deploying this folder and syncing ur changes in production. One nice advantage of this approach is your field groups can be stored in GIT.
WordPress is something of a horrible hacky mess, especially if you know better. And yes, you have to go down the plugin route to do anything cleanly, although take a look at Code Snippets (https://wordpress.org/plugins/code-snippets/) and Simple CSS and JS (https://wordpress.org/plugins/custom-css-js/) as plugins which allow you to add code more cleanly. However, if you do have the option, and as you're experienced with Laravel, then I'd highly recommend seeing if you can persuade them to move to October https://octobercms.com/ It's based on Laravel, but is much more a platform to build a CMS in. Great documentation, really nice and well thought out code. Well worth your time. 
Thank you. I'll defiantly look into this. 
If you're not bound to MySQL (e.g. using WOrdpress or anything else requiring legacy depedencies), consider giving Postgres a try: It is able to have DDL queries in a transaction. This way, changing your schema can simply be put into a DB migration script on the next deploy. If anything goes wrong, the changes are rolled back. It's a pleasure to work with.
All your assumptions are correct when using modern PHP frameworks. For WordPress though... try thinking like your 16 year old self and you may find the solutions you are looking for.
Most of these answers are decidedly unhelpful, so I'll do my best to offer up some of the things that I use: &gt; So my first question is this: how can I make changes to my local database while making it easy to update my production one? The web framework I'm most familiar with is Rails, and Rails uses ActiveRecord, which is essentially a ruby script that is ran and updates the database. Is there something similar in Wordpress? Look into [Wordmove](https://github.com/welaika/wordmove). It's a command line utility that allows you to declare your environments in a YML file, and it supports migrating both the filesystem and the database. It's made my life MUCH easier. Using it will require a recent version of Ruby if you're on Linux or OSX. If you're on Windows, then you might want to look into their [Docker Container](https://github.com/welaika/docker-wordmove) to get it to work a little more seamlessly. There's an [Alpine suggestion](https://github.com/welaika/docker-wordmove/issues/6) that I started a while back that has an example version that you can build if needed. Otherwise, they [have one in the works](https://github.com/welaika/docker-wordmove/issues/3) if you're not in any rush for a lightweight image. &gt; Also, is there some way to view all the plugins within a project? Like a composer.php file? Should I even be doing manual PHP coding for a Wordpress project? Almost the entire project was made using plugins (according to someone at the charity). Kind of. If you're used to working with Composer and .env files, I would highly recommend [Bedrock](https://github.com/roots/bedrock). It makes working with Wordpress feel a little more modern. Plugin management is done through Composer, wp-config options are set as .env variables, and there are a few must-use plugins it comes with out of the box that do a few extra simple things (like forced disabling of search indexing on non-production sites).
If you are comparing entities, you have two alternatives: 1. `assertSame($a, $b)` - if two entities are the same, in doctrine they exist only once per identifier in a single `UnitOfWork`. You won't get a different instance unless you are clearing and re-loading everything. 2. `assertSame($a-&gt;id, $b-&gt;id)` - two entities are the same if their identifiers match. This is applicable if you are not writing a test specific to entity state mutations. `assertEquals()` cannot be guaranteed to succeed, because when you get a lazy instance, `get_class($yourExpectation) !== get_class($theFetchedObject)` due to implementation details of the ORM. If you are verifying object *state*, you can use something like `zendframework/zend-hydrator` (or write your own in ~20LOC) to extract property values and assert on those manually. Again, if the graph is recursive (associations), then you encounter the same problem as above with `get_class($yourExpectation) !== get_class($theFetchedObject)` for every association.
Look into the bedrock package in the roots team repository. They make deployments, testing and CI/CD much easier. Basically, they restructure the folder structure of WordPress and use composer to auto load your dependencies. This is widely accepted, supported and an active repository. They also have a theme with a Webpack setup (sage) and a deployment repo (I‚Äôve never used it but it‚Äôs called trellis). They make deployments, testing, CI/CD so much easier (even if u don‚Äôt use trellis or sage). As far as database seeding, there isn‚Äôt anything I‚Äôm aware of, but I‚Äôd be very interested to hear from someone who knows of some goodies. Also check out generatewp for stubbing common WordPress assets (custom post types, taxonomies, meta boxes, etc.) As long as you know WordPress‚Äô limitations and what it can do and also what it shouldn‚Äôt do, it‚Äôs not as terrible as everyone makes it out to be. The terrible part is dealing with the clients since the obvious reason you are using WordPress Is because someone who knows nothing wants all the control possible. Let‚Äôs just be honest and admit that is the worst part.
Every piece of code you write should be considered disposable. Everybody has different criteria for what should be considered 'good code.' For some, it's a matter of appearance i.e. formatting - which can be easily solved by an auto-format plugin. (personally format nazis are not to be taken seriously) Others like to see terse, overly clever algorithms where complex solutions are solved with a one-liner - when working on an enterprise scale team, is a logistical pain in the ass because the next guy that will be maintaining that part of the code will be have to waste time learning your code. My own criteria for 'good code' is pretty much this: 1. Are unit tests easy to read? 2. is it easy to update? 3. is it easy to replace? 4. does it contain easily identifiable highly coupled dependencies? And if it does, are the reasons well documented? 5. and least importantly, does it look pretty? (I think it should be noted that I'm talking about in context of working in an enterprise/large team environment, as you will be handing off your code to someone else in the future. This cases like this readability and maintainability takes precedence over clever, pithy solutions) That being said, it is good practice to pay attention to cohesion and coupling of your code. You will get better at this over time. One thing you can do is simply not look at your code for a while, and when you forgot about it, take a look. If it is difficult to follow, that is a good indication of how others would see your code - and then figure out what you can do to improve it. Readability is a huge factor when working with teams. Every once in a while, you will encounter a piece of your own code, you'll take a look at it, and think, "Wow, this code that solves this particular solution is amazingly elegant. I wrote that??" Once you reach this point, see if you can improve it. If you had to rewrite it, can you think of a way to make it 'better'?
A great example of a reason why people hate on PHP development is the amount of times FTP can be seen in this thread. SFTP, rsync and automated deployments are all great ways to sync content across environments. I realize not all files are synced in version control, but let‚Äôs leave FTP back in 2005 where it belongs.
Those plugins are for script kiddies. Adding code through the admin, storing it in a database so it can be spit out in the head isn‚Äôt ‚Äúmore cleanly‚Äù. Learn to use the framework rather than just skin on top of it and you would be surprised. On the other hand, that‚Äôs nice to hear good things about October cms, I check back in on it every once in a while but have never heard any reviews on it. 
You've been programming part time in a language for a few months. How many years has remote PHP dude been writing? Let's be honest, there's probably just a huge difference in the amount of experience you and him have. It takes many years to master a skill. If you have a chance to learn from him, take it. Obviously the startup you're with likes you enough to hire you first. 
I believe that under the hood they're doing something nearly identical, but unfortunately I can't give a comparison between the two as I'm no longer working at a company where using either is necessary, and when I was PT-OSC was brand new (in fact we were Percona customers) and the native stuff in MySQL didn't yet exist. I always found PT-OSC to be a tremendous pain to get right, even with helper tools. With something like e.g. Phinx I'd expect the native stuff to be almost set-and-forget.
I've never fired a developer for writing bad code however I've fired a few for refusing to learn how to fix their bad code. Learn what you can from the senior developer but also don't treat his word as gospel (in a few years time you'll probably figure out he was wrong on a bunch of things too). Even if you get nuked you would have improved your development knowledge and will be better prepared for your next job. 
I host a number of Wordpress sites as a legacy of once having my own Web/PHP business. My very, very strong suggestion /u/a_masculine_squirrel is to ensure that plugins are kept updated. I use a tool called https://infinitewp.com/ to manage the plugin updates. It is very good when you have multiple sites to maintain. I also suggest installing the https://www.wordfence.com plugin to keep your security tight. Wordpress has some very strange ideas (I hope you like globals) but it is very successful and here to stay. On the plus side, the Docs are very good. 
Well fair enough, generally my dealings with WP are to fix minor items for a client of mine who are web designers to SME types and just need a few minor adjustments to some template or plugin functionality - and they suffice. However the underlying architecture of WP seems to me to be so problematic that whenever I've been tasked to write anything CMS like that does require substantial coding I've just headed for October - or something else - instead. I'm quite prepared to believe that there the WP framework can be used more elegantly, just seems to me doing so is a bit like trying to break the sound barrier with a prop plane - when the better choice is to use a jet.
Yes, also dealing with the ‚Äúa little fix to this plugin here‚Äù and also ‚Äújust a little fix to the theme here‚Äù requests from clients are terribly annoying. Nothing like patching everything into oblivion rather than fixing underlying problems - similar to your jet metaphor. People (clients mostly) bloat their sites with plugins and BS, then expect everything to magically work. If this is the case, run far, far away learned my lesson early on that one 
The .org or .com site? /s
Should I learn and focus only on php or basic javascript then continue with php i already know css html.
&gt; This new guy took one look at my code, said it was bad and messy, and said he will re-do everything from scratch himself, in under a week. Lol the amount of times that I've heard this is insane. It's also probably never true.
3-day-old account, -56 comment karma, deliberately antagonistic toward people for no reason. Yeah, you're really contributing to the community, here.
&gt; i already know css html. Most frontend work today includes some work with Javascript alongside with CSS and HTML, so I'd be a bit surprised if you're not already familiar with Javascript? Anyway, I don't there's a _correct_ answer to your question. You could easily start with PHP alone, but continuing working on a project involving both backend and frontend you'll probably still end up doing some Javascript at some point.
i would love to see a \`strict\` version of PHP, just like XHTML, with unified function names, and rules for writing code correctly. The main criticism for PHP has always been that it's too forgiving and that it's not consistent.
This doesn‚Äôt address the primary problem the article does which is long locks when schema changing large tables. I‚Äôm not a pgsql expert but I think it suffers the same issue MySQL does in this regard. 
That's an interesting idea. Are there examples of where that's worked well or backfired?
If you're a rookie and they don't give you a mentor then it is their fault. They likely just wanted a cheap PHP guy to get rid of some tasks. Best thing to do is move on.
Well perconas online schema change has a few options to balance and react on load. You can also delay the actual table swap for a reason. It is simply a bit more flexible. Not sure how it is different from the mysql solution. I don't know what it hard to get percona running? We usually use it without any balancing and replica detection and it is a breeze. 
You are aware that xhtml was a huge failure? 
That doesn't mean it was a bad idea. More like a bad execution of a pretty good idea.
i just had 'Go' in mind when i wrote that comment.. or other languages that kind of prevent you from falling to bad practices 
Model = Services + Entities + Value Objects? Is something like observer in laravel is a service?
And I'm going to have to downvote this because I think this is one of those times where an internals conversation isn't really suitable for consumption by those who don't regularly follow internals. As a TLDR, this is a very broad, very early discussion on when the core developers should start work on PHP 8, whether they even have enough (breaking?) features to justify / qualify as a major version (and whether a major version needs breaking features to justify it) and whether or not there should be a more formal release cycle when it comes to major versions. There's a number for features such as JIT and async mentioned but I don't recall seeing anything recently on these on the lists. It's probable that some of the core devs have been working away on these silently in the background and just haven't had enough to show properly yet - Zeev mentioned an email he plans to send this week with more info which should prove interesting. Far more interesting right now is the (traditionally, dangerously late IMO) flood of RFCs targeting 7.3, the discussions around possible feature and extension deprecations (particularly "memcache" vs "memcached") and the possibility that 7.3 will be delayed for typed properties.
Is IIS a hard dependency? Try running Linux+nginx and give APCu+opcache another try.
At my previous school that is how we were taught to interact with mysql
&gt; And I'm going to have to downvote this because I think this is one of those times where an internals conversation isn't really suitable for consumption by those who don't regularly follow internals. I'm upvoting to balance out your downvote. It makes no sense to downvote a topic like this.
Not sure why people are downvoting an opinion. I think PHP would benefit greatly from this.
Completely different scope: HTML is to be served and executed by hundreds (thousands) of different clients, and it is supposed to be a bunch of strings slammed together. XHTML was not a viable solution because somebody (somewhere) would have screwed it up, leading to an entire un-parseable page (due to client or server bug), and that's not optimal for a webpage. PHP is (supposed) to be evaluated on the server, under controlled environment, of code that was tested/verified.
I get your point. I am a lurker of the internals list, and see Reddit as the place to discuss the things said over there as the platform for "non-officials". You're of course right that people who don't follow internals might interpret it wrong, but I hope that the Reddit community can help those people explain what's actually going on. In my opinion, it's a requirement for every professional PHP developer to stay up to date with the internal developments of the language they use on a daily basis, and PHP 8 is an interesting discussion. When and how it'll come, I think it's better to be well informed beforehand.
For now it is yeah. I'm planning a move to fully containerise on Linux within 6 months but there are some historical dependencies that are tied to Windows at the moment.
I thought about creating a project that would be all the functionality of the latest Zend PHP version, just re-written in a way it would be if it didn't have to deal with the "legacy php" problem, but that's not too different from what Facebook's "hack" language and HHVM is, is it?
Reddit is a very special thing. People are coming here for memes and an occasional glance to something else. A mass of uneducated folks coming for entertainment would ruin any sensible discussion.
That's not the language my friend. Every time you jump a language you have to familiarize yourself with the basic semantics. Concatenation, math etc...There's an avalanche of tutorials explaining what's a PHP variable and the possible shorthands for it. I don't mean to be offensive or condescending, but an error like that could be made into any language. 
It was wrong for me to assume, just because all the other languages I have used have used += I just didn't even think to check because it was such a minuet thing and I figured some other logical issue was the culprit or something. I have only been using php for about two months and had never come across the issue before. I have nothing against the language at all, I honestly have been really enjoying it. Just thought it was funny.
It's funny because you're not wrong. Yet Javascript is exactly the same in that aspect and yet it doesn't get half the shit PHP gets :D
&gt; The primary deficiencies of "pretty good" coders are that they mis-attribute a lack of ability to read code, and the related ability to read their own code as "my code is better". They then almost always underestimate the time needed to accomplish the same task. Boom. This is right on the money; I think I've worked in 5(?) companies in the past year that have either (a) been screwed over, or (b) let contractors go, all because someone has walked in without the ability to comprehend others or to understand legacy systems, and they've decided that they can do better quicker. It's a very slippery slope.
http://php.net/manual/en/language.operators.assignment.php#40084
&gt; My only concern is he may have used off-shore developers to whip something together, **and he didn't ask many questions on what to rebuild**. I wouldn't be too worried about the prospect of off-shore developers; there will be a few tell-tale signs as well. (The level of English in comments - does it feel "*native*"? Similar for variable names. Ironically, code quality *may* also be an issue.) The bit I've bolded is the real issue I'd be concerned about though, and one of the points I tried to highlight in my original post - there's no way you can walk in to a new company, take one look at the codebase - *and not ask any questions* - and feel well equipped enough to undertake a rewrite. You need to understand *how the system works*, and if the code quality was as bad as claimed (i.e needing a rewrite) then I fail to see how he would've achieved that without asking questions. Hell, even working on "*nice*" codebases I always ask quite a lot of business domain/usability questions.
I've had very educated discussions on Reddit. I want this sub to change for the better, and the only way I can help with that is by changing the things I do. But, say Reddit is doomed; what platform do you suggest to have educated discussions about the programming language you work with every day?
PHP wouldn't. You, as PHP developer, would. But for PHP as the whole, it would be a disaster. 
My PHP 8 Wishlist: * Generics &lt;3 * All functions-as-closures, including class members. * Typed-everything * Official templates for a php\ namespace. * Primitives as objects "hello"-&gt;substr(0, 2) 
I don't know any. Reddit is not entirely doomed. It's just a very strange thing. The same link could get downvoted and upvoted and nobody could tell you why. The more upvotes the post picks up, the stranger people are coming to comment. Reddit is suitable for entertainment, for the things you don't care to miss. But not for any productive discussion, I guess. But again, I don't know any better platform.
\&gt; assertSame($a, $b) - if two entities are the same, in doctrine they exist only once per identifier in a single UnitOfWork. You won't get a different instance unless you are clearing and re-loading everything. My understanding for is for Doctrine to write to the DB I must call flush() and then when I try to get the saved object, a new unit of work is created. So they are different instances for the purposes of this being a DB saving test. It's looking like the only option is to check each property on the object, unless I've missed something?
Well at least you've learned a valuable lesson, should you choose to extend into another language. Trial and error my friend :D That's how people learn best. 
Why would it be a disaster? You could leave the old function names in a legacy mode so it would not break any applications.
Except hhvm had shit compatibility with php. I tried it on two occasions, and ran into relatively basic compatibility issues within the hour each time. If you start from the php codebase and maintain BC of the good parts you wouldn't have that issue.
Absolutely correct. Postgres does allow a great number of schema changes to take place as metadata only (making them almost instantaneous) - including the upcoming release which will make `alter table...add column...not null default xxx` not require any data changes. But you absolutely do have to know exactly what operations take which locks and how long you can expect them to be held. In fact, although it's an amazing tool, transactional DDL can even make this worse as any locks acquired at the start of the transaction must be held until the end. So this means that even the order in which you perform multiple schema changes within the transaction can mean downtime or not.
&gt; PHP 8 is an interesting discussion While PHP 8 will be interesting at some point, this particular discussion really isn't unless you're a core developer. It's far too early - there's only vague notions as to what might be included in PHP 8 and when work might start on it as a definitive branch / version. The email Zeev mentioned may provide something more interesting, but right now there really isn't anything to PHP 8 at all. At this point we could still end up with several more feature releases for 7 before we get close to 8 being anything substantial. As others have mentioned, the user base on Reddit is too wide for this sort of thing. There are too many people who'll jump the gun and start publishing blogs claiming that PHP 8 is just around the corner and will include every feature even hinted at in that discussion before they've even been discussed as RFCs on internals. It's not exactly hard to follow internals, and there are frequent enough other threads on active RFCs which are much more interesting if you want to follow what's "coming soon".
I suspect you're going to be sorely disappointed. I don't think I've seen anything substantial on Generics or "Typed-everything" recently (while we're slowly headed in that direction, there's still a lot of work that needs to be done). Primitives as objects is not likely to happen and the core developers seem to be content with claiming the root namespace for their own, despite the downsides.
knowing php is a start I guess?
Ok thanks, I'll take it into account the next time üëç
I am not sure if any. I can imagine already now there are some apps and developers who added function like html_special_chars() wrapping htmlspecialchars() only because they wanted to have consistent naming. And imagine PHP 8 adds the same wrapper. There will be a lot of things like that if you mess with supporting older versions. 
That‚Äòs why there should be a legacy mode that just keeps the names as they are now. But for new applications, it would be very nice if we could have consistent naming.
Yes I'm a bit familiar with Js
&gt;I report people's account history
- `isset()` should be `is_set()` - `gettype()` should be `get_type()` Purpose is to make APIs consistent. There is `is_null()` but not `is_set()`.
Thanks for sharing the Link..Its useful..
I think he was referring to having a standard mode and a strict mode. I think everyone agrees that it would have been better if PHP was more consistent and a little less forgiving, the question is do we break compatibility with every existing application for the sake of consistency ? The idea of having two different versions would solve that problem, but that would create another : You'd effectively end up with two different languages, with apps written for "legacy PHP" and apps written for "strict PHP", with the "scrict" version not really adding anything that can't be added with an IDE and/or a static analyzer. I think a better approach would be to gradually eliminate inconsistencies by adding alternative functions (or objects with methods) to replace the ones that are inconsistent, then deprecate the older ones and start throwing warnings when someone uses a deprecated method or does something that wouldn't work in a stricter language), and then removing inconsistent methods and overly forgiving behaviors in the next major version. That's what happened with mysql -&gt; mysqli/pdo functions for example. It took time but it was a pretty smooth transition.
My wish list is (in order of preference) - Function autoloading - Inlining for reduce/map/filter performance - Tail call optimisation - Union types/pattern matching
It's probably because people don't have many other options for a client side programmng language. Not that I'm justifying the hate on PHP, but most people who hate do it because they prefer X language in it's place.
Wishlist for PHP7.4: - add `isBindable` to: http://php.net/manual/en/class.closure.php as now it is guess work - support `foreach` iteration over keys only, something like: `foreach($a as $b =&gt; void)` removing a lot of overhead / rewriting - `token_name` returns `null`, `false` or throws exception for unknown id and doesn't return the some magic value 
&gt; Typed-everything Do you mean something like this? // ... class UserResource { protected Acme\Repository $userRepository; public function __construct(Acme\Repository $u) { $this-&gt;userRepository = 42; // throws error } } ... instead of just type hints? That would be awesome.
&gt; Javascript is exactly the same in that aspect and yet it doesn't get half the shit PHP gets It gets twice the shit PHP gets. PHP doesn't get dumped on in user comments to news magazines and Slashdot, for example. And tooling around JS is significantly better than PHP imo. DISCLAIMER: Node/React dev here.
The problem with TCO is that it can destroy backtraces. As in an imperative language most of the "heavy lifting" looping constructs are iterative not recursive, so does TCO really buy you much in terms of performance or stack space?
Typed properties have an RFC under discussion and, unless someone spots some blocker, quite possibly will make it into 7.3 (delaying 7.3 explicitly to fit in this feature has been discussed, despite the fact that they're already cutting alpha releases), but there's no sign yet of typed (local) variables or typed arrays.
Also: https://wiki.php.net/rfc/case_insensitive_constant_deprecation and https://wiki.php.net/rfc/continue_on_switch_deprecation.
&gt; If we‚Äôre going to 8 can we please fix the ternary operator now??? Oh god yes please
You can solve that with namespaces. 
Obviously someone with longer experience will have a different look on someones code that just started. It's different for all, but as a self-taught developer I would say that even 10+ years of experience is still not enought. I can code nearly everything, but I am "never" satisfied. I always look at my code and feel like "Damn I could do this better.. I could move this there.. I could do this and that.. wtf did I here? I must have slept there.. Oh god nope.." There is also something called "Imposter Syndrom" which can also lead to a bad feeling about your own skills. But since you just working with PHP less than 1 year, you simply have not enough experience. Experience take into account doing like BILLIONS of mistakes. Doing that and knowing what you did wrong, which can be done better or optimized, is a KEY part of getting better. Knowing the little go-to's and "beginner mistakes" and preventing them, is a major difference between a junior and a professionel. Everything more, like learning technical and theoretical things like design patterns and several other deep insights experience will lead you to become a senior. Don't feel bad. There are indian guys that act like they invented PHP with their bullshit PHP skills, which 99% is copied and the 1% is WordPress itself, who doesn't care at all to act like you will be very happy hiring them and just wasting your time. At least they "just" want ~200$ for a full (trash) page, which is actually bad for the competition since someone that sells real gold for 4 digit prices will sell less gold against someone who will sell aluminium with gold color on it for 2 digit prices.. and then make the customer angry, make him lose trust which is VERY important in the IT and will give you less time since there was wasted a huge bunch of time. My advice would be not doing big projects, but rather small ones that are not to complex and not too imporant or having a deadline, which also can allow room for mistakes. Also use up your free time to do some investigations, learn more about in-depth material and also code a lot! Code, code, code. Learning by doing. Try &amp; Error. Without mistakes, you can't get better. You need to do mistakes to learn from them. I remember in an online game where the Korean Team was very, because the skill range with them against the 2nd placed team was SO big and the competition was so low, that they couldn't improve in skill since they never get into the situation to doing mistakes or adapt into new strategics. So should you feel shamed that the "more experienced" developer wanted to re-code everything instead of fixing your stuff? To be honest: No. When I look back to my code with 1-2 years experience.. I feel ashamed and face palm my self every few second. I am asking my self how stupid I was and wtf I was trying to archive on some points when I simply could replace 10-20 lines with one in-build function etc. .. Also since I like to help many other beginners.. I saw so many "inexperienced" code and from other posts within other boards.. it's simply the amount of not-optimized code that would make everything horrible harder to fix rather than just re-coding and doing it the "optimized" way. Look at the finished code and try to understand whats different. Why he does something a specific way rather than your way. There are billion of beginner traps and mistakes that can be overseen, so try to learn from it. Don't feel ashamed. You will think the same with +10 years of experience and a +2 year experience tells you that somethink is better.. just that you will be confused for 10 minutes and then realize that the person is talking bullshit :-)
Maybe an underscore _ instead of void like most newer languages would look nicer. 
Elaborate for those not in the know 
Yes, this is under active development by Nik https://externals.io/message/102333
I assume he's referring to its awkward left-associativity. Some explanation here: https://stackoverflow.com/questions/20559150/ternary-operator-left-associativity
Ah, yeah I use parenthesis out of habit and forgot that was a bug. 
Although I have never personally encountered code containing the continue / break complication, the fact that it even exists is borderline maddening. 
Ah I wasn't aware of that limitation but it makes sense, it's more a exploratory feature for me not particularly important in my day to day With backtraces I assume it's possible to persist some of the backtrace just not all of it because it's been discarded?
[domain model](https://martinfowler.com/eaaCatalog/domainModel.html)
&gt; when I try to get the saved object, a new unit of work is created. No, the `UnitOfWork` context is the same unless you called `EntityManager#clear()` somewhere.
You could dedicate an entire PHP release to a consistent API
People still do this? I can't remember the last time I wrote `?&gt;`
Same, I fell absolutely in love with php as a kid
Custom interpreters for DSL would use a giant switch block with breaks and continues.
Paradoxically what PHP is lacking today is better support for procedural programming, even though it has it's origins in procedural world. OOP works pretty well in PHP, apart from minor annoyances (e.g. too verbose when creating anonymous classes), however writing procedural code is a struggle. Both functional programming (Erlang) and procedural programming (Go) have had a huge comeback in programming last few years, unfortunately neither paradigm is a pleasant experience in PHP. Just a few points of the top of my head # Functions does not have their own symbol Meaning you have reference them by strings. For classes it works fine because you have the \`::class\` constant. # Function autloading You can't autoload functions like classes, so what you do instead is to create static methods in classes. This makes functions i namespaces not that useful. # No support for parameter signature for callables And no support in phpdoc either. You have to resort so hacks like using \`@see\` in phpdoc. # No support for variables in namespaces So what you do is a static class. # No pure immutable class/struct
Because tons of non-strict code would break when you introduced strict dependencies. You don't need to break language BC in order to break the community/ecosystem.
Not closing the PHP tag in files containing only PHP code is described in PSR-2. https://www.php-fig.org/psr/psr-2/#22-files
&gt; PHP doesn't get dumped on in user comments to news magazines and Slashdot, for example. Probably because javascript is having its moment in the limelight. PHP devs have been catching shit for nearly 20 years.
Not one knows, the trick is being able to know what to search and learn quickly
Yeah and it makes me mad. Just bought sendy and he still closes tags
Good because every time I tell someone they don't believe me
I somewhat disagree. Don't get me wrong, I'm all for strictness that's why I always invoke PSR standards and force my teams to follow them and attach an analysis tool like SonarQube or CodeSniffer to verify, but I do enjoy the fact that php is not opinionated in this regard. But having that flexibility to allow my team to follow, for example, 90% of what PSR says but define method names the way *they, the team* are used to rather than forcing PSR down their throat is more productive, imo.
&gt; I also remove them from all kinds of libraries I download, waiting to destroy my headers Umm, this is retarded. Either you're not using composer or you're not updating the libraries.
I referenced this, &gt;A new Unit of Work is implicitly started when an EntityManager is initially created or after EntityManager#flush() has been invoked. A Unit of Work is committed (and a new one started) by invoking EntityManager#flush(). Taken from https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/working-with-objects.html I read that as being once you flush your entity manager, a new unit of work is created. That besides, I got it to work though. I was creating a new entity manager each time I made a call. Doh Thanks for your guidance
TBH, at this day and age, with an IDE being always there for you I don't see php's inconsistency as an issue it once was.
Nobody gives a fuck.
So essentially something like JavaScript :)
&gt; And tooling around JS is significantly better than PHP imo Not from my experience. NPM is laughable compared to Composer. The package-lock file doesn't do what a lock file should. 1. Git clone (pulls down lock file) 2. NPM install 3. Lock file changes O_o That's like a padlock whose combination changes after you open it......... Nothing in JS is standardized. There are 20 competing solutions for everything. Building an NPM package? Better compile it 8 different ways so that it's usable in different codebases. Want to test an NPM package locally with NPM link? 1. Make change in package 2. Package build watcher fires 3. Host project watcher also fires 4. Race condition o_O. Have to stop the host project, compile the NPM package, then restart the host project.... I don't mind programming JS and TS, but I fucking hate the tooling.
Luckily PhpStorm warns about it
My wishlist: -Keyword params. -Operator overloading -friend classes -method/function overloading
Just to add on to the comment about compiling/transpiling, that‚Äôs what makes javascript kind of aggravating to me (I do work with React a fair bit but bear with me). The only bearable way for me to work with JS projects of any size is to write with the most recent iterations of ES, which of course you need transpiling for. Everything else just feels hacky and reminds me of the early days of PHP cowboys heh.
In all honesty I think async &amp; jit should take a backseat as there are still "core" language features missing: - short closures that actually close over their parent scope - function/method references - typed properties &amp; locals (long shot) - typed arrays and/or full generic support (long shot) - function interfaces (long shot, probably requires a generic Closure type) 
&gt; I liked Rust's ownership and lifetimes concept very much. Definitely would like it in future versions of PHP. But why? Rust has it only because it doesn't has a garbage collector and it's trying to keep references and objects separate. I think it's actually making writing and comprehending the code much harder. It's ok for lower-level language like Rust, but I don't think it makes sense to have this in a garbage-collected PHP.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Reading this post is time that I will never get back :(
It‚Äôs three sentences. Did it really cost you anything?
What are the top php spammers in the world?
Yes I was talking about the left-associativity. It‚Äôs literally 100% useless. 
Imagine PHP in a world without nikic ü§î How awful üòñ
I been working with php for 6 years 
Hmm, yes, that wording is probably incorrect. Maybe you can suggest some improvement that makes this more clear to the reader? See https://github.com/doctrine/doctrine2/blob/master/docs/en/reference/working-with-objects.rst
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [doctrine/doctrine2/.../**working-with-objects.rst** (master ‚Üí 2726636)](https://github.com/doctrine/doctrine2/blob/2726636e55fdbdf6fb1ed466f22d34de116fb8f9/docs/en/reference/working-with-objects.rst) ---- 
&gt;Not only was the declaration of a clashing constant permitted, but it effectively changed the value of the FOO constant. Dear god
You'd have the stack frames for any functions which weren't called in the tail position, but any that were in the tail position would never have the frame created in the first place. I've run into it a bunch of times going through kernel oops backtraces. You follow the calling logic just fine and then it's like a brick wall - suddenly the next function in the trace is never called anywhere in the previous function. So you have to examine every function call in the tail position and read _its_ source code to see if it's possible that _maybe_ that was the route the execution took. And if there's more than one such function then...sorry. Or if none of those functions call the expected function either then you've got to go through the same process _again_...
I have to say, while I read the first part of the continue_on_switch RFC and was all for it, the implementation I am not super happy with. What was the reasoning for deprecating `continue` inside switch instead of switching it to the straight c-like behavior?
That would have been a breaking change in respect to current behavior, which is REALLY undesirable.
Nothing valuable 
Since when?
I love the comment about redhat. &gt; RHEL 7.5, the latest version of RHEL, still ships 5.4. Much like the backward thinking about PHP6, there's still some strange cultural belief that external tooling process should drive technical process.
Can you elaborate on this a little because I would say it depends a lot on the position?
This so much. PHP programmers reach for classes straight away as they are the easiest tool to use, even though when they are not the most appropriate. Being able to define and use functions as easily as classes would allow people to choose the right tool for the job. 
I thought in w3 schools they close them?
I understand that motivation, but isn't this what a breaking change is supposed to do? This is not something I really would hawk upon, but I feel if we are making such change, let's make the code clean while we are at it. From the point of view of new code, this change is suboptimal, to make the breaking change a little less "breaking". It's definitely a tradeoff, and I guess me personally, I am more on the other side.
No
&gt; NPM install [...] Lock file changes `yarn --frozen-lockfile` &gt; There are 20 competing solutions for everything I don't encounter this in my work. There are a number of back-end frameworks (Express, Koa, Hapi, etc.), but that's true in PHP-land as well. Build tools are undergoing rapid development right now, but I think that will stabilize and each new generation (i.e. rollup gaining now; webpack; gulp/grunt) has brought a new approach and new ideas. Generally when I need a library there is a single or couple of libraries that have wide usage. &gt; compile it 8 different ways I can't wait until ES includes become standard across the board, and we move away from having CommonJS and AMD packages to deal with. I'd like to move to Rollup from Webpack, but can't because so many libraries haven't moved yet to the ESNext syntax. &gt; the constant compiling/transpiling Not an issue for me at all. Most of my current projects use Webpack with watchers and hot module reloading. I don't have to reload in the browser on code changes (unless the change is to Webpack's config), other assets are automatically compiled (CSS, media assets, etc.). It's a pleasure to use imo, especially against C/C++. I transpile PHP anyway to use macros. &gt; Package build watcher fires [...] host project watcher also fires I think excluding the external dependency folder (`node_modules`) from the project watcher is the common approach. I have enough memory in my workstation to not worry about it, but the memory usage from watching dependency folders is unnecessary and hurt before I upgraded my system's RAM this year.
&gt; how can I make changes to my local database while making it easy to update my production one The dbDelta function hooked into register_activation_hook. - https://developer.wordpress.org/reference/functions/dbdelta/ - https://codex.wordpress.org/Function_Reference/register_activation_hook &gt; Is there some way to view all the plugins within a project? `wp plugin list` - https://wp-cli.org/ &gt; Like a composer.php file? WordPress is composer compatible but since you are "adding features for a charity's website" I'm going to guess it's not setup like that. If you want to start from scratch though: - https://github.com/composer/installers/blob/master/src/Composer/Installers/WordPressInstaller.php - https://github.com/johnpbloch/wordpress - https://roots.io/bedrock/ &gt; Should I even be doing manual PHP coding for a Wordpress project? Almost the entire project was made using plugins That's exactly normal. (Plus: writing plugins is actually a way to bypass WordPress conventions and use modern ones) http://kizu514.com/blog/wordpress-as-a-development-platform/ Regards,
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [composer/installers/.../**WordPressInstaller.php** (master ‚Üí 5d15e4e)](https://github.com/composer/installers/blob/5d15e4e9aab1da3a622678bdaaa4f7d57d150923/src/Composer/Installers/WordPressInstaller.php) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e19ix5g.)
Remove them?
Thank you. I was looking for something like this. 
Symbols are immutable strings. Hopefully, generics, callable types, modules, ... will be added in future versions. 
If i'm not mistaken **ctype\_alnum** behaves like strpos, it is: if non-string is passed, it will be converted to an integer and interpreted as an ASCIIcodepoint. This behavior gave me some headache recently. Can you consider to deprecating all similar conversions?
As the other comment mentions, that would be a BC break. It's generally better to turn something into a hard error than to change how it behaves. But also importantly, I think the PHP behavior is the correct one, especially considering it has multi-level continues and breaks. It would be distinctly odd if the same break/continue level referred to different loops if there is a switch involved anywhere.
I definitely agree with the thought of having a 7.4, 8.0 still feels distant as hell to me. Love the ambition though, it's exciting :)
God bless Nikic!
Technical debt is very difficult to price. I‚Äôve never had to go through such an upgrade, but here are the questions I would have: - while the upgrade won‚Äôt change our current business, is the lack of upgrade preventing the business from offering industry standard solutions? Then you can see how you‚Äôll either have to price below the market or lose customers - are there security risks to not upgrading? If so; what would a breach cost? - is the system due for major refactoring anyways? Has the code turned to spaghetti or is unusable? Then you might as well transition to a better system rather than doing it twice - what is current workload for the dev team and what is management‚Äôs willingness to spend time and money? If you won‚Äôt get the dollars or time allocated necessary, you‚Äôll rush to production and probably output code that will be hard to maintain. Those would be my first questions or angles to convince or investigate the issue
Literally thirty seconds of it, but I felt it was worth the time.
Thank you! Your comment about the levels of break vs. continue made me realize what you mean by the correct behavior. This indeed makes sense.
&gt; PHP programmers reach for classes straight away as they are the easiest tool to use ...I'd also say in very large part because there's a _very vocal_ subset of Kool-Aid-drinkers in the community who believe that anything other than Bob Martin style OOP is ipso facto hacky spaghetti.
It's a tough one. Non technical people rarely see the point in things like this! If management are afraid of burning too much time a good compromise may be upgrading from ZF1 to ZF2 and then potentially ZF3. I know ZF2 is technically EOL now, but if memory serves it only become EOL at the start of this year. You will still get some performance boosts from the upgrade. There's an official guide as well: https://framework.zend.com/manual/2.4/en/migration/overview.html You could then take it a step further and go from ZF2 to ZF3. Although Symfony is extremely good, ZF3 isn't terrible by any means. There's an official guide for this as well: https://docs.zendframework.com/zend-mvc/migration/to-v3-0/ Good luck!
you mean TypeScript, JS doesn't have strict typing, generics, or namespacing.
Presuming that "the company" does not mean "the developers" ... &gt; My company is considering upgrading our stable &amp; clean ZF1 application to a modern version of Symfony. ... can you say what the company's motivation for doing so might be? That is, what does the company expect to get out of it? (Tangentially, my guess is that this would not be an "upgrade" from one framework to another. It would be more like a "rewrite." That makes it a very different kind of problem.)
Sure, give me an example scenario where you think the proposed functionality might be useful, and I'll explain what alternate data structure you should have used in the first place.
w3schools is not good
Glad you thought it was helpful. Here's 3 "sideload your own frameworks" approaches that you might find useful if you are going down the path of no return: Use Laravel's Eloquent with WordPress: https://github.com/corcel/corcel Use the WordPress REST API, write Ruby of JS instead of PHP: http://kizu514.com/blog/wordpress-rest-api-quickstart/ Instead of sane data structures and SQL best practices, leverage WordPress types and taxonomies (everything in WordPress is a post, extending these will leverage built-in features): https://github.com/johnbillion/extended-cpts Enjoy?
What I'm reading here is a case of "nothing I really care about". These are seem like weird corner cases, I don't have any problem with these deprecations.
What I'm reading here is a case of "nothing I really care about". These are seem like weird corner cases, I don't have any problem with these deprecations.
I like the idea of 7.4 being the final release of the 7.x and not containing new features, but just existing to give the deprecations more time to sync in.
Will greatly depend on the company then the position. I got my first PHP job by being hired as a designer. They found out I had some background in programming and decided that I was no longer a designer and would now be doing PHP development. I had never touched PHP. Where I work now doesn't hire inexperienced devs. Doesn't matter what your education is - you have to show experience and that you know the language. And I feel even that has changed. I don't think I could get hired here now with the same experience I had then. We have upped our standards over the years.
Not sure if this applies to Zend1, but there is typically better built-in tooling for the developer in newer frameworks, enabling them to get things done much faster. This is true even within the framework roadmaps. Take a look at feature differences between major versions of Symfony and Laravel. At some point finding resources who want to work within Zend1 is going to become scarce and expensive.
I often have to tune manually batch size / transaction time to get the best results under load. But it's very easy to install and run, indeed.
No. Read the other comments. 
Well, having a breaking change in a minor release like 7.3 would be pretty bad, since you would break (pun intended) people's code easily. We could maybe argue for that change in PHP 8
I was being snarky. I don't really like them even though I know a lot of dev do.
Yeah. Answer from nikic below helped me see how it's good to maintain level parity between `break` and `continue`. I haven't considered that one before.
As someone who heavily uses PHP processes that run for a few seconds to several hours to process massive amounts of data, I wholeheartedly approve of performance improvements for non web uses (even though I have no idea if JIT would improve our use case).
I really want to see lambdas - they are so incredibly more readable than writing out `function` and `return` every single time you want to do anything remotely functional. Also (and I know that this is not gonna be popular), I'd love to (at least optionally) be able to not use semicolons. I've been writing JS without them for quite some time by now, and I enjoy reading code without them a lot more.
One thing I particularly enjoy is how constructive all those discussions are (for now). Remember the PHP 5 times‚Ä¶ This is great!
I've done a lot of ZF1 and it's an OK framework. In fact many parts can be kept as it since a lot of libraries are totally independent of the MVC framework itself. I don't think ZF1 applications, if coded correctly are that hard to maintain. The framework itself is extensively documented.
I think you'd be happier with another language. Maybe Swift or Kotlin or something of that ilk. I like PHP because its a messy, forgiving language that lets me move fast and actually implements real object oriented programming. 
I think we've had a point release more or less every year on the 7 branch, with 7.3 likely coming by the end of 2018, so as I don't think it's realistic to plan a stable 8.0 release in 2019 there's probably room for a 7.4 in 2019 with a couple minor features and as many deprecations as possible in order to get a clean 8.0 release. Of course if the devs are confident that they can get all the deprecations they want in 7.3 and release 8.0 in 2019, then by all means go for 8.0 right after 7.3
The same that reading your sentence
Reported. 
What?
Why are we discussing PHP 1 at this point?
Worth considering the ability to hire talented developers as well. I can‚Äôt imagine there would be a huge number of developers jumping for the chance to work with a framework which has been unsupported for 2 years.
I would be very hesitant in upgrading from one unsupported version to another. Though the idea of migrating to v2, then to v3 could be the path of least resistance here. It is difficult to advise in situations like this. If the existing code base is low quality then upgrading the framework doesn‚Äôt really solve any problems. A full rewrite though is very time consuming and without strong technical leadership is likely to lead to delays or falling into similar pitfalls as the first version.
&gt; I like PHP because its a messy, forgiving language that lets me move fast and actually implements real object oriented programming. Most of us in the professional / enterprise space hate that it's messy and forgiving nowadays. If we say we want &lt;x&gt; to be &lt;x&gt; and then it turns out to be &lt;y&gt; then we want it to complain most bitterly about it, rather than &lt;y&gt; getting passed through and completely screwing something up further up the stack.
¬øWhat?
Totally.
Then you want a different language.
I'm planning some intensive off-line data processing, myself, and +1 this message.
I'm pretty indifferent on the 7.4 thing, but doing more with long-lived processes is *really* interesting for me. My packages for handing daemonization and forking are my most-starred on Github (for whatever pointless metric that counts towards), and it's pretty clear that TTFB can be drastically reduced when serving from a long-running process that's already loaded resources. From an end-to-end ecosystem standpoint, I would love to see increased support for native tooling. On every new project, the first thing I do is install and configure PHPUnit, PHPCS, and PHPStan. While the former makes sense as a standalone library, the static analysis tools could really be improved by having stuff better than `token_get_all` available (maybe this just means that the AST extension becomes bundled by default; that's really the only reason I use PHPStan over Phan), and some level of native support for the Language Server Protocol. To me, that means: * The ability to do a soft/sandboxed `include` of a file: conceptually, it would give an array of `Reflection(Class|Function)` objects, and not do anything that introduces side-effect (but that may not be sufficient). Way easier said than done once you factor in typehints and autoloading * A less-clunky way to find and traverse source code files (better than `glob` and/or the `RecurisveDirectoryIterator` stuff) * Native functions have a way to expose their documentation (avoid the need for [this](https://github.com/felixfbecker/php-language-server/issues/611)) I'm sure I could think of plenty more ~~distractions~~ ideas but as someone that writes a lot of PHP to make writing PHP easier/safer/better, those would make my life a lot better.
I like the idea of there being a deprecation release to prepare the way for 8.0, but feel no need for it to be 7.4. Could be 7.5 or 7.6, depending on timelines and the RFC process.
Imagick can convert PDFs to images. There‚Äôs an imagick extension for PHP.
2014's greatest hits: https://medium.com/@joaomilho/festina-lente-e29070811b84
A few years back we upgraded an app from ZF1 to Symfony. We considered ZF2 before that, but the changes were big enough to amount to a nearly complete rewrite anyways. It took a bit longer than previously calculated to migrate but in the end it was definitively worth it.
My 2 cents, it's worth the expense if don't do it manually, but automate it. E.g. with Rector: https://github.com/rectorphp/rector It can be much better argument, than "it will take hundreds of hours and thousands $ to change the code, but will look the same" :)
Why not using coding standard tool for this?
 You'll need to know: + How to chain the Laravel, Symfony, and Slim dependency injection classes together to make one all encompassing super duper DI class. + How to write a Pecl extension in C. + Hot to test using Behat. + Server side CSS. + that Singletons are evil so use `globals` instead. + How to compile PHP using GCC Feedback-Directed Optimization (FDO). 
what about `break` in switch statements? 
There are two aspects of **Test Driven Development**. 1. No logic in code is written without unit tests. 2. Tests are always written before coding and coding is just done to pass the test. **Benefits** 1. Lesser bugs after development 2. Better documentation for code is possible. Please check this Step By Step TDD guide. https://www.youtube.com/playlist?list=PLsAF2pGFyHinAKCQXgnZzhFjL_AB1bBxE
I personally dealt with a lot of shit for almost two years after we bumped the Joomla minimum from 5.3.1 to 5.3.10 to be able to sanely use the random\_compat library and deprecate MD5 password hashes. Because so many Linux distros used 5.3.3-fork-whatever-42 as their versions and we weren't supporting those anymore. End user demands are painful.
Okay. I never really realised why people don't, but I do now. I'll stop. 
If you have a low level of experience, the smartest thing to do would be to use a framework. Frameworks offer a lot of "convention over configuration" advantages. Starting with nothing to me reminds me of Carl Sagan's quote "If you wish to make apple pie from scratch, you must first create the universe". While I'm taking that quote out of context, why create the universe as a PHP developer when you can stand on the shoulders of giants? Granted, if it's a tiny project, maybe it doesn't make sense to use a framework, but the larger number of employers out there will probably ask you about frameworks that you have experience with.
There are two aspects of **Test Driven Development**. 1. No logic in code is written without unit tests. 2. Tests are always written before coding and coding is just done to pass the test. **Benefits** 1. Lesser bugs after development 2. Better documentation for code is possible. Please check this [Step By Step TDD][1] guide. [1]: https://www.youtube.com/playlist?list=PLsAF2pGFyHinAKCQXgnZzhFjL_AB1bBxE
who even does this? was this ever a "Required thing"? 
&gt;Umm, this is retarded. Either you're not using composer or you're not updating the libraries. this. 100% this. Learn composer
"Break" is pretty much universal for "jump to next instruction after the end of this control block" where as "continue" is "start again at the top of this control block". Within a switch there is no starting again, therefore having continue in it makes no sense unless it's targeting a loopable structure it's contained within.
Well I wondered if that was the case but then thought no one would be that silly ;) Seriously though what don‚Äôt you like about them? IMO they‚Äôre much cleaner than if/else all the time. Plus we have the `?:` and `??` versions, the latter of which I‚Äôm using constantly now. 
To stakeholders, you could put it simply as "to continue to reliably provide services in the future". Also consider these points: * Future PHP versions could break ZF1 * Needing to attract future developers as a ZF1 shop vs. ZF3 I updated my work's environment from CodeIngiter 1 -&gt; 3 and PHP 5 -&gt; 7. Feels pretty good for developer morale too, surprisingly.
PHP 7.2 added [parameter type widening](https://wiki.php.net/rfc/parameter-no-type-variance) but I'd like to see the opposite, parameter type narrowing, e.g. : interface CommandHandler { public function handle(Command $command); } class FooCommandHandler implements CommandHandler { public function handle(FooCommand $command) { // where FooCommand implements Command } } Stuff like this could be extremely handy when writing interfaces for command handlers, event listeners... Is there a reason something like this doesn't exist? I haven't even seen many people talk about it. 
You know that old bug that never got fixed...
He is a good teacher but there are a few gotchas that you have to look to the forum for work arounds. Recommended by me.
So many concepts I can relate to... 
The first time you do this and run into the header issue is the *last* time you will ever do it.
I can recommend: * Zandstra, Matt. [***PHP Objects, Patterns, and Practices 5th ed.***](https://www.amazon.com/Objects-Patterns-Practice-MATT-ZANDSTRA/dp/1484219953) The standard OOP PHP book and still the best. * Jones, Paul M. [***Modernizing Legacy Applications In PHP***](https://leanpub.com/mlaphp) Not an introduction to OOP, but full of examples of why to use good OOP practices. * Lockhart, Josh. [***Modern PHP***](https://www.amazon.com/Modern-PHP-Features-Good-Practices/dp/1491905018) Not much OOP in here (coding to an interface, traits) but lots of best practices every PHP developer should know. A lot of the best OOP literature is written for other languages. A few don't really have a PHP substitute: * Metz, Sandy. [***Practical Object-Oriented Design in Ruby***](https://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330) IMHO the very best introduction to OO design in any language. * Fowler, Martin et. al. [***Refactoring: Improving the Design of Existing Code***](https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672) or [***Refactoring: Ruby Edition***](https://www.amazon.com/Refactoring-Ruby-Addison-Wesley-Professional/dp/0321984137/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1529957521&amp;sr=1-1&amp;keywords=refactoring+ruby) * Weisfeld, Matt. [***The Object-Oriented Thought Process***](https://www.amazon.com/Object-Oriented-Thought-Process-Developers-Library/dp/0321861272) Thinking in OOP, with an emphasis on programming to the interface. 
&gt;PHP 2^3 This guy belongs on Reddit with that kind of intellect.
No love for `&lt;?= $user-&gt;getName() ?&gt;`? Guess we don't really need to anymore when separating the code and the templates - using Twig or similar.
making the language more strict will destroy the ecosystem and render obsolete huge amount of old code if people want mass extinction of old software this it will be like killing all dinosaurs, big horror, but glorious to watch :) 
[Really? on the decline? ](https://w3techs.com/technologies/details/pl-php/all/all) 
[Here are 2018 statistics. Uptrending...](https://w3techs.com/technologies/details/pl-php/all/all) 
It comes from the time when PHP was injected into HTML files to create variable and reusable portions of HTML. As a leftover of that time, it made its way into some class definitions but was soon spotted for causing problems. I hope one day we can get rid of `&lt;?php` too for files that are solely PHP code, I.e. everything with a `.php` extension. Then if you‚Äôre mixing PHP code inside another file type (e.g. HTML), you‚Äôd have to be explicit about parsing files of that type for PHP code. It maybe isn‚Äôt such a big saving, but it would allow PHp to move inline with all the other ‚Äòserious‚Äô programming languages like Ruby, C and Python.
&gt; Within a switch there is no starting again, therefore having continue in it makes no sense unless it's targeting a loopable structure it's contained within. No that makes sense, I just thought your argument was about getting rid of all uses of the `break`. And I mean, most people "return" from a switch statement, but sometimes we break too.
I know i've seen `&lt;? ?&gt;` in wordpress a lot and in html, but in `.php` files I have never seen some one close a `&lt;?php` tag
1: It took you 20 days to debunk that. Dead threads much? 2: "if you listen to the internet". People have been saying shit about PHP for as long as I've been aware of it.
My wishlist: - mb_string and phar support to be part of the core 
It took me twenty seconds. For some reason I don‚Äôt get this subreddit reliably in my feed. So I come around from time to time to see what‚Äôs up. I guess your answer is that, I do ‚Äúdo dead threads‚Äù! I am sure you don‚Äôt mind that I took the time to post a factual link? And ‚Äúif I were to listen to the internet‚Äù for as long as I have been on it, mid 1990‚Äôs... then I would have thought that Wordpress was dead, Laravel was a fad, and PHP 7.0 would never come. But then again I am not interested really in all this back and forth. What I am interested in is making things that work. Which means I am usually using a PHP based solution. But I tend to be biased against JS, like PHP and love Python. My co-workers think I am too old to get JS, my peers outside of work also, so even though my bias comes out every once in a while, it‚Äôs probably because JS is apparently beyond my understanding which I suspect is true for anyone spreading false information about any subject including PHP. So dead or not, new people read exchanges like this, and I felt it was worth a few seconds of my time to just link it. And you? Why did you stop by this ‚Äúdead thread‚Äù? 
I just don't think they are inherently intuitive. 
&gt;most notably ReactPHP and more recently Swoole He cites React and Swoole and neglects to mention Amp. That's fucking awful. But at least his heart is in the right place; PHP desperately needs native async support to regain relevance. It may already be too late, but better late than never.
Sure, if you're using PHP for templates, thats a must. I've been using Twig like you said, or just been using PHP to write an API and develop a front-end SPA using Angular.
Awesome. Thanks.
Wouldn't 2^3 top out at 7 in the binary world?
I'm not sure what you mean by _regaining relevance_ and being _too late_. PHP runs 80% of the world's websites. Facebook, Wikipedia, Tumblr, WordPress and so on all use PHP. It is still holding its own. 
&gt; Thankfully, the availability of resources in 2018 is infinitely better than it was in 2000 so new devs aren‚Äôt necessarily churning out the monstrosities they were then (and if they are they have little to no excuse). I think that some how we (PHP developers) start to care about proper development and things got better, but now we have some monstrosities being formed due to some of the tools that have been becoming popular. (Tools: Certain frameworks aimed to lower the bar by ignoring all the things we were striving for in development.)
&gt; PHP runs 80% of the world's websites. A meaningless statistic; one grounded in the past, not the present nor the future. CTOs do not see a future developing greenfield projects in PHP any more.
Give it some time. Coercive STH was already brought up.
My view on semicolons are this, they are like periods on a sentence. They just feel natural to me and tell me where the end is. =)
agreed :) you can use https://github.com/FriendsOfPHP/PHP-CS-Fixer with `no_closing_tag` to remove all unneeded (so safe) close tags from your code (might safe you some time so I thought to throw it in)
The solution to "it's broken" is "fix it", not "use something that isn't broken". The latter is what you do when you *can't* fix it, and that's certainly not the case here.
It think it's because if you narrow it down, it would refuse to accept an object thet the interface promises to handle. Widening does not break that promise, if you drop the type in your implementation it can still accept a `Command`. 
Its not broken. It has the set of properties I want in a language. You are the one arguing to make it broken.
Let me google that for you ;-) * [https://arjunphp.com/convert-pdf-jpeg-php/](https://arjunphp.com/convert-pdf-jpeg-php/) * [https://stackoverflow.com/a/467805/1461181](https://stackoverflow.com/a/467805/1461181) * [https://github.com/spatie/pdf-to-image](https://github.com/spatie/pdf-to-image)
[removed]
I do kinda understand that - but after not using them for some time I found that I understand code just as well without them, and less characters is always better for readability (if it does not irritate you, which it might).
You‚Äôd be amazed how many PHP devs I have met and worked with who have never heard of the PSRs. 
No?
The answer is 8 - why should it top out at ?
Which frameworks are you talking about? Personally I feel like things like WordPress and Drupal (I haven‚Äôt worked beyond 7 so maybe 8 is better) are big time contributors to the bad image that remains. I know they aren‚Äôt frameworks but gone from vanilla php to WordPress/Drupal to Laravel/Symfony and then back to the middle the issues are very pronounced.
Binary starts off at 0. Bring up a calculator with binary support, enter 111 and switch to decimal mode. 
And the problem with 1000 is?
I'm learning Laravel, and that is one of the frameworks that choose to be "Quick and Easy" for the end developer. To achieve that, they had to ditch some of the "rules". Statics all over the place, globals, and from what I've encountered on my own, several violations of "S" in SOLID. 
Those "devs" would never have even gotten past the HR screening anywhere I've worked, for exactly that reason. Keeping yourself up-to-date is not optional, folks.
That would be 2^4, giving you 0-15.
1000 is 8 2^4 is 16.
That‚Äôs the thing. While I have worked with brilliant and genius problem solvers they just seem to not care about such things. I ain‚Äôt no senior but even when I said we should follow the standards I got shrugged off. And yeah it got to the stage where even I didn‚Äôt care anymore. Little old junior knows nothing right? At least I moved on
When talking in terms of binary, not decimal, 2^4 would be 4 bits, giving you 16 possible values, which converts to range of 0 to 15 in decimal. A simple 8-bit (2^8) computer processor can only calculate to decimal 255, not 256. 
What a hero.
While I appreciate the point you're making, I don't appreciate being told what I should and shouldn't find interesting. That's for each person to decide for themselves.
This is something you can manage - to take an example from Python: there's the `__future__` module that lets youor python code opt in on a *per-module basis* to things that would break backwards compatilibity. IE it lets you opt-in to new features in new code you're writing even if you can't afford to upgrade across the board to the version of the language that makes the new behaviour the default. I'm not familiar enough with PHP internals to say I know how hard it'd be to manage something comparable, but it certainly can be done in theory even if it might be more hassle than it's worth. 
Same here. We have several very long running PHP processes that (hopefully) JIT could help \+1
I do it. It allows me to easily concatenate PHP files into a single file. For this to work I also have to do some other things people don't usually do, such as using `{}` with namespaces. A lot of PHP files won't care about this use-case. That's fine, and for those files please leave off the closing `?&gt;`.
It would be great if `php-ast` were bundled in as part of the build, but it would need to include statement-level additional metadata (e.g. `startFilePos` and `endFilePos`, statement-level docblock elements) to be usable by non-Phan static analysers. The gap is *expertly* filled by PHP Parser (by the same author) so it's not a huge issue. The big time-suck is not generating the AST, though - it's traversing it and drawing inferences. That's where JIT improvements could be amazing.
It has a *really* different use case. If I had to build an asynchronous service from scratch, needed it to be lightning fast, and I had the inputs and outputs specced out, I'd choose something like C# or Go. If, on the other hand, I had an idea for a partially HTML-based service and knew I might be iterating on it for the next year, I'd choose PHP. Every language has its strengths, and you shouldn't spend your time trying to make a language do something that another language could do far better. 
I have looked into that before. But the readme recommends not to use it in production: [https://packagist.org/packages/vlucas/phpdotenv](https://packagist.org/packages/vlucas/phpdotenv) Mostly because of the performance cost of reading and parsing the .env file every time php is loaded. I also don't like the idea of it putting all the env vars into the $\_SERVER and other globals. Makes it easy to access them, but also easy to accidentally leak them in an error message or even a rogue phpinfo(); that usually outputs the globals.
What a jerk 
Thanks bro! So, instead of creating a garbage collection from scratch I can create a __destruct method and ever time PHP GC destroy class X, it will call it __destruct method and from there I can "efree" the related matrice right? Or, you think its better to use the same code from "get_defined_vars", and, if a matrice UUID is not instanciated I free? (Tell me if I'm too confusing, my english sucks)
Thanks a lot! I was thinking about using "get_defined_vars" internal code to check wich of the allocated matrices are actually instantiated at runtime and them free those who are not. But someone below told me __destruct is called during PHP GC cleanup. Do you agree? Or its better using "get_defined_vars" or writting the collector from scratch (sounds hard to me)?
__destruct would call carray_destroy(CArray target_carrar) and thats it
I don't personally see the point of Twig. PHP has plenty good syntax for templating and it's not another thing to force people to learn.
This is php's fault not the developers.
Know any good articles on php templating? Do you mean just building strings of html?
Oooo scary
Output buffering??
Interesting, I wonder what makes such a big difference between the two.
Dunno, sorry. I generally roll everything by hand.
I don't know how viable that is in PHP since PHP treats everything loaded like an inline include.
Found the guy that uploads bit shifted malware. 
Does nikic get paid to work on PHP? It‚Äôs amazing that he contributes such high quality work to PHP.
Reported! 
LMAO
Might help in some cases but won‚Äôt solve the newline or other whitespace from showing up in the buffer anyway - and maybe your application is generating an output format which won‚Äôt be forgiving to added whitespace (eg image data)
Interesting. Our application never has any issues with open or closed PHP tags or white space at the end of files. We use output-buffering from the start to end.
If you want a language with broken properties, then you want a different language.
Yeah no, I picked the language I need properly the first time. Apparently you picked wrong. There are plenty of languages that have all that clutter and shit in them if you need the training wheels or whatever. Stop pushing in this pool and go find one that suits you.
You can't fight progress, bud. Change with the times or time will just pass you by.
Cargo culting dubious features from fad languages is hardly progress. 
How it possible for 353 assertions to take 42 minutes?! I have to assume these integration tests and not unit tests...
Those stupid kids and their loud devil music really need to get off your lawn.
Know nothing script kiddies 
lol @ "fixed by not giving a shit". Truth.
PSR is a guideline not a requirement. My previous job had a company wide style guide that applied to all code (not just PHP) and most definitely was not PSR compliant. I knew that inside and out, but only know PSR-2 in passing.
2.4 irks me. I‚Äôd rather code be consistent (tabs or spaces, pick one and stick to it for the whole project) but don‚Äôt try to force one or the other on other coders. There‚Äôs no right or wrong answer between the two.
Already works with declare(strict_types=1)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
ZF1 is no longer maintained and hasn't been for a while. Staying on it means you are now also supporting a framework which you probably know little about internally. Upgrading to newer versions of PHP will eventually break the framework requiring you to fix it. I'm currently migrating from ZF1 to Laravel with the team I'm on. The concept can be the same for any framework you migrate to. Put a pre-router in front of the old and new framework. Then migrate one piece at a time telling the pre-router to route newly finished actions to the new framework. In my scenario I've replaced entire Zend models with Eloquent models that are botstrapped into Zend and then called from the controllers. I've then migrated those controllers to the Laravel framework. Sometimes the Zend model just a functions replaced with ones acting as wrappers to call back to the Eloquent models. Point being. You only need to sell the time for initial setup of a dual framework solution. Then commit to making all new or updated features in the new framework. Eventually you'll have it all migrated. 
Not familiar with the usage of `declare` - if it's called and then another file is `include`'d/`require`'d, does it not apply to anything inside that file?
Is there a package-gist for this so I can be lazy and composer require it?
Delightfully grumpy interview about the misunderstanding many devs have about PHP's sophistication.
It was a recommendation even in ZF1.
353 tests, 1402 assertions. That being said, yeah, these are almost definitely integration tests.
Good one.
stop using gateways for your spam. reported
So, Joe said, "PHP is a general purpose language". I wanna ask what other things we can make with PHP beside using in websites?
I don't disagree with a lot of your points - but one correction - you can namespace functions and autoload them without stuffing them into a class.
- Desktop apps - Databases - IoT control scripts/servers - Minecraft server mods
I get why it doesn't work at the moment, I was more wondering if it could be made to work, if there are technicalities or good reasons why it won't work.
Oh, didn't knew this at all... I'm a junior btw. 
That's ok! Welcome. :) Here are a few links for strange things I've built using PHP: - https://www.sitepoint.com/modding-minecraft-with-php-buildings-from-code - https://www.sitepoint.com/procedurally-generated-game-terrain-reactjs-php-websockets - https://www.sitepoint.com/php-arduino-and-minecraft-connecting-an-arduino-to-php - https://www.youtube.com/watch?v=B5FJQPAunxk Hit me up on Twitter if you'd like help recreating any of these things...
How? Is it the static class hack?
"report is being **loaded**"
Some one did this in our 10 year old codebase...somewhere...among the 2MM lines of code. It'll never be found :(
wow, great. I'm actually interested in learning websockets in php. I have tried examples but I want to make a private chat. I am not able to find any tutorial. You know a good source?
If you‚Äôre working on a group project, simply implement PHPCBF into your continuous integration process. Can‚Äôt merge without passing all checks which include tests/coding guideline adherence that you‚Äôve setup. Super easy and it‚Äôll help you keep your codebase looking uniform. 
[Highcharts](https://www.highcharts.com/demo) / [Highstock](https://www.highcharts.com/stock/demo)
Follow/tweet me on twitter and I'll send you a book.
sure
What a blatant blogspam. Even spammers from Bangalore are more creative, posting although shitty but at least OC. But this is a new level of shamelesness, just copy-pasting a release announcement from php.net. Reported. 
It sure is, but it is also way less stable: I can't count the number of projects for which it crashes and doesn't work.
Xdebug memory usage 94MB phpdbg memory usage: 6652MB I would guess the xdebug configuration was being forced to GC much more?
Huh, could be. Maybe xdebug makes assumptions and does things to use as little memory as possible at the cost of execution time too.
Python wasn't designed for science stuff and JS wasn't designed for ... well ... everything.
Probably because of the way you explain it. *Waaaaaaaah. It's a per peeve of mine. Waaaaaaaaah.* Not a very compelling argument.
Both debuggers have to (at least) override the zend executor in order to instrument code: The zend executor function contains the vm loop that cycles through your instructions ... I copy/pasted both executor functions and then turned them into psuedo code, without removing information about the complexity of the instructions being executed, and adding frequency annotations ... The phpdbg executor function is modelled on the function is overrides (ie, it contains the vm loop): [gist](https://gist.github.com/krakjoe/589b2b99fb41d864fd91d75e1264daad#file-phpdbg-c) Note that, given an environment where you have no breakpoints set (as is the case when collecting code coverage), there are no unnecessary branches entered, the only additional instructions are some pointer comparisons (single instruction neq/eq) and some bitwise math (again, single instruction). The xdebug executor function doesn't contain the vm loop, but rather dispatches to the function that does after instrumenting the current frame: [gist](https://gist.github.com/krakjoe/589b2b99fb41d864fd91d75e1264daad#file-xdebug-c) I did give up making it into psuedo code, and the rest wouldn't really look much different, it's not necessarily complicated code with mystery constants or anything of the sort, there is just a lot of it. I think the differences made apparent here, and their implications don't need to be explained further. Another difference you can find is in the opcodes being executed under different environments. Given the following code: &lt;?php function test($a) { return $a; } test("Hello World"); ?&gt; Here are the opcodes that phpdbg will execute: krakjoe@fiji:/opt/src/xdebug$ phpdbg -np* test.php function name: (null) L1-8 {main}() /opt/src/xdebug/test.php - 0x7f0bbba780c0 + 5 ops L2 #0 NOP L6 #1 INIT_FCALL&lt;1&gt; 96 "test" L6 #2 SEND_VAL "Hello World" 1 L6 #3 DO_FCALL L8 #4 RETURN&lt;-1&gt; 1 function name: test L2-4 test() /opt/src/xdebug/test.php - 0x7f0bbba83000 + 3 ops L2 #0 RECV 1 $a L3 #1 RETURN $a L4 #2 RETURN&lt;-1&gt; null Here are the opcodes that xdebug will execute: krakjoe@fiji:/opt/src/xdebug$ phpdbg -dzend_extension=xdebug.so -np* test.php function name: (null) L1-8 {main}() /opt/src/xdebug/test.php - 0x7faecd86a780 + 9 ops L2 #0 EXT_STMT L2 #1 NOP L6 #2 EXT_STMT L6 #3 INIT_FCALL&lt;1&gt; 96 "test" L6 #4 EXT_FCALL_BEGIN L6 #5 SEND_VAL "Hello World" 1 L6 #6 DO_FCALL L6 #7 EXT_FCALL_END L8 #8 RETURN&lt;-1&gt; 1 function name: test L2-4 test() /opt/src/xdebug/test.php - 0x7faecd884460 + 6 ops L2 #0 EXT_NOP L2 #1 RECV 1 $a L3 #2 EXT_STMT L3 #3 RETURN $a L4 #4 EXT_STMT L4 #5 RETURN&lt;-1&gt; null Those additional instructions help xdebug instrument code, their handlers may be very lightweight, but nevertheless it represents a not insignificant difference in terms of workload over an entire codebase. In addition, while phpdbg calls the zend defined handler for every opcode, xdebug installs an override for every opcode which dispatches to the zend handler after possibly outputting code coverage information. TL;DR phpdbg makes every effort to execute code with near-zend efficiency, xdebug is focused on providing a very full feature set ...
Couldn't you just write another script that goes through the php pages. Opens them. Reads the last 10 or so characters and checks if it contains the closing tag followed by something.
I also agree with PHP 7.4 as the next minor version. PHP 8 should provide JIT support and async functions.
&gt; Really? Don't you end up having to write call to htmlspecialchars() far too many times if you use php as templating language for html? Ok you can wrap it your own function called e.g. h but then you're still writing &lt;?=h($foo)?&gt; instead of just {{ foo }} 
It wont work because it would break the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle): you should be allowed to do the opposite, widening (but not removing) the type, so the child class would be able to accept MORE stuff than its parent. The opposite rule is valid for return type: you could narrow the return type, because that would not break the parent's contract, but not the opposite. Google covariance and contravariance to know more on this subject.
Google Charts [https://developers.google.com/chart/](https://developers.google.com/chart/)
https://github.com/xdebug/xdebug/blob/07dc8ba6c40a123cf35998a5b7248ff08a0f1c37/xdebug_mm.h This means that the vast majority of the additional memory that xdebug allocates is not included in the numbers reported by zend, because it's requested directly from the system.
No, it only applies to the code from the file it's declared in. &gt; Strict typing applies to function calls made from within the file with strict typing enabled, not to the functions declared within that file. If a file without strict typing enabled makes a call to a function that was defined in a file with strict typing, the caller's preference (weak typing) will be respected, and the value will be coerced. [PHP: Function arguments - Manual](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict)
This "get_defined_vars" approach - I would avoid that, if it's called too rarely, it keeps memory allocated for too long. If it's too often, it's slow. __destruct() or using a dtor (which then calls the default zend_object_std_dtor) directly is ultimately having pretty much the same result, though the latter is the native way of doing it ;-) But yeah, "that's it".
Holy crap! No wonder there's such a difference! Thanks for the explanation. So if I'm getting this right, it's the fact that phpdbg is meant for a limited use case which happens to be what most people would probably want while integrating it into their general business workflow, while xdebug is meant for you to be able to break down absolutely everything. 
&gt;I don't know how to do a text search You're never going to be a very good programmer.
Thanks for the explanation! I understand the Liskov substitution principle but in the example I made, it doesn't really make sense: you would need a specific implementation (at least to get typehinting etc). Currently, you would do class FooCommandHandler implements CommandHandler { /** * @param FooCommand $command */ public function handle(Command $command) { // ... } } Lately, I've felt more and more that whenever I have to add a docblock to get typehinting on something, it's because I'm missing a feature in PHP. Scalar typehints and return typehints have done a lot and I'm really excited for the new typed properties RFC. Now if we could just get generics...
I can't recommend it enough. SOLID programing principles and SOLID package principles. One of the best (PHP) books out there. https://leanpub.com/principles-of-package-design
&gt; Desktop apps &gt; Databases I honestly don't ever see PHP as being used to write any serious desktop app nor database server application, so I'd argue that's far fetched.
I just want a replacement for apache. Swoole is amazing but sometimes it gives you weird errors. If Swoole became more stable.. my god. It would be heaven on earth.
You can't properly inter-line align with tabs, and some - for odd reasons - prefer spaces for indentation, so there we have it - a mix. Golang, for example, (or more correctly, `gofmt` - the golang formatter) dictates tabs for indentation and spaces for inter-line alignment. It works well, but then again I don't really care about whether it uses tabs or spaces for anything, as long as it looks fine visually.
What header issue? I've not closed my `&lt;?php` tags for _years_ and had exactly zero problems regardless of whatever was being output, be it HTML, JSON, image data, streaming zip file, etc.
I've seen people understand Twig better than PHP for templating - for themers, who are usually not developers, it's _much easier_ for them to not fuck up escaping values, as Twig does it for them.
`phpcbf`, jobs' done.
That's a nice thing to do &lt;3
It's rarely the fault of _language_ that people abuse or misuse it, except in cases of bad documentation, and one thing you can't blame PHP for, is to have bad documentation of the core language.
As others have said before, these changes are almost always gradual and can be easily disabled with a flag, like old versions of php have done before, using the ini file
You could say that ... I prefer to think of it as phpdbg being focused on the task of debugging (with an eye on internals developers), while xdebug is focused on .... just about everything under the sun (with eyes everywhere) ... Make no mistake, the ecosystem needs an everything-under-the-sun debugger ... phpdbg was never intended to replace xdebug ... A (possibly interesting) note about how code-coverage support came to exist in phpdbg ... actually it is almost completely accidental; Optionally logging instructions in a verbose way was a feature of phpdbg from the start, part of disassembly facilities (the ones you see showing instructions in previous post), and aimed at internals developers mostly. It so happens that it can be used to provide test code coverage information and so a driver for phpunit (and some work to phpdbg iirc) happened. phpdbg and xdebug are very different animals, and while there is some overlap, phpdbg will never be your primary debugger; It is an advanced tool aimed at advanced users, xdebug is for *everyone and everything* ...
I have never seen you make a serious point, so I'd argue you're far fetched :P
It's generally unusable on any larger project - way too unstable for anything bigger than a library with a few classes.
We're strangers, so naturally you have not - would you argue that PHP is suitable for writing desktop applications? If so, why would you not use something with proper bindings to fx. GTK, Metal/Cocoa (Apple), Qt, etc? I don't even know how you'd make native Windows applications; let's not ignore the fact that you can't really compile/package PHP to a binary executable outside of PHAR, which still just contains the source files and requires PHP-CLI to run.
php-cs-fixer ?
[https://twitter.com/AzJezz/status/1011559773467299850](https://twitter.com/AzJezz/status/1011559773467299850)
I honestly never managed to get it working on any project for a reasonable period of time :/
Things like extending an existing template are much simpler and cleaner in twig
This made my day
&gt; If so, why would you not use something with proper bindings to fx. GTK, Metal/Cocoa (Apple), Qt, etc? Something like [libui](https://github.com/andlabs/libui)? If so, [PHP's got you covered](https://github.com/krakjoe/ui) &gt; let's not ignore the fact that you can't really compile/package PHP to a binary executable outside of PHAR You can always use [Bambalam](https://github.com/xZero707/Bamcompile).
I can't recommend it enough. SOLID programing principles and SOLID package principles. One of the best (PHP) books out there. https://leanpub.com/principles-of-package-design
Relax, fellow. I was merely jesting. The nugget of truth, inside the jest was; just because you haven't seen someone build a serious database or desktop application doesn't mean it hasn't happened. Furthermore, the comment I was originally responding to only asked _what_ could be made using PHP, not whether the more popular _other_ uses were from the land of PHP. 
I'd say even making "websites" has evolved _way_ beyond what anyone would have understood that term to mean back when PHP started. In the late 90s, this mean PHP was a cgi_bin module that could directly render HTML. If I'm now processing graphql queries, rendering an image, sending it to some AWS service, etc I'm already going way beyond a "site". We also use console based php tools all the time: composer, phpunit, phinx, phpcs, etc.
A linter that enforces this or a nice IDE could help you: [https://s8.postimg.cc/g333b22zp/phpstorm\_reduntant\_closing\_tag.png](https://s8.postimg.cc/g333b22zp/phpstorm_reduntant_closing_tag.png)
Here: https://packagist.org/packages/villfa/invert-color
I've written a desktop app with PHP (via PHP-GTK). It was a pretty good experience; nothing in the language hindered me - the issues that I *did* encounter were caused by the flakiness of PHP-GTK due to it being not widely used.
Another vote for highcharts. The flexibility is, quite frankly, a bit mind-boggling.
I would argue that PHP is on the right path already. They've been responding to features that other languages benefit from and cleaning up security issues since at least PHP 5. The problem with any radical change in core functions is that the language is simply too widely used to change that quickly. We might be able to slowly address some of the bigger issues, but to be honest, a good IDE should mitigate most of the confusion over inconsistent arguments in core functions. So, I think the language is unarguably getting "slightly better" already.
I'll pitch in and add that once PHP 8 is out with the promised JIT, you'll be able to write some quite amazing PHP desktop apps. It already outperforms Java on WEB, so I wouldn't be surprised if PVM did better than JVM.
&gt; Relax, fellow. I was merely jesting. Oh look it's le Super Funny """Redditor""" :\^)
How dare you go against the herd?
Exactly. People hate on PHP too much. PHP can be so clean and elegant if written well.
May I ask why you choose PHP and not a better suited language with strong typing? I _love_ PHP for web-development, but I cannot imagine writing a desktop application in it. One example of something that's difficult in PHP is threads. I don't know if GTK takes care of that, but how'd you go about something simple as unzipping a file while displaying progress visually without it tied into the main loop like: while (read zip data) { handle_zip_data(); update_visual_progress(); } I can easily imagine doing this in C++, Golang, Java or similar (I don't know Java, really, but I imagine it's not difficult), but not in PHP.
&gt; I said we should follow the standards I got shrugged off I guess your referring to PSR standards. Remember PSR standards are self elected 'best practices' that a small group of developers have put together. There is no saying their decision on things is any better or worse than the senior devs in your work place. I personally follow PSR if the job permits but a lot of places also have their own 'style guides' and/or 'best practices' this is something very common in places that use multiple languages (everywhere I've worked). As long as there is a standard then it doesn't matter what it's name is. [editorconfig.org](https://editorconfig.org) can help your team standardise.
What would be intuitive in your view? (If anything) Plenty of stuff in programming isn‚Äôt really that intuitive - for example short closures in JS and other languages. 
There are many reasons behind acquiring Magento platform as shown by [adobe](http://news.adobe.com/press-release/corporate/adobe-acquire-magento-commerce):- 1. Entered into a definitive agreement to acquire [Magento Commerce ](https://www.softprodigy.com/hire-certified-magento-experts-india) 2. The Magento Platform is built on proven, scalable technology 3. 
Obviously PHP is continuously improving. PHP 7 was a big step, and I am really happy there's lots of talk about long running processes and async for PHP 8. I think the IDE argument for not fixing the inconsistencies is quite weak. If I want to send a developer a snippet of example code on Slack, I shouldn't need to open up the PHP docs or my IDE to check something that I should be able to easily infer from convention. I also shouldn't need use mental capacity processing IDE autocomplete suggestions whilst writing trivial code statements. What about if I am code reviewing someone, or looking at a git diff? Sure tests will help there, but don't you notice a pattern of having to consistently fight the language? The view points from people I've spoken to about this topic are quite similar anyhow. Most people are either: * It's bad, but it's too difficult to change * It's bad, but it's possible to change My opinion remains that [scalar objects](https://github.com/nikic/scalar_objects) provide a really, really good opportunity to fix a large part of this problem properly. The wheels for PHP 8 have been set in motion now, so if we want something like this before PHP 9 - it's time to start talking about it! 
I think I found the guy that sits in my computer and counts arrays
Im still learning php and sort of just bumbling through it are there lots and lots of guides? If so which one/ones should I follow? Im really worried ive already picked up some bad hobbits!
This made me snort
It's 42 minutes with Xdebug + Code Coverage enabled on Travis CI. Running the *same tests* without Xdebug is 2.5 minutes on Travis CI. Even faster locally on a better CPU. [I'm using the WP testing framework](https://github.com/WordPress/wordpress-develop/tree/master/tests/phpunit) which does things like create temporary MySQL tables instead of mocks. I also do a fair amount `of ob_start ... ob_get_clean` to get return values. I'll admit the line between unit and integration is blurry here, but I think 2.5 vs. 42 for the same tests is a problem either way.
4 days old account and already you're at -40, keep it up buddy!
Modernizing Legacy Applications in PHP is a great book. I inherited a lot of legacy apps when I got my first job and it saved my life but also taught me a lot about OOP and build good applications. 
Ah maaaan, I guess I'd better quit my 20 year career and go raise chickens instead.
Le super smart """Redditor""" values his karma above all else :\^)
What can I, as a random John Doe developer, do to help make this happen?
&gt;You need to really understand two things to be a programmer, SQL and JavaScript. &gt; &gt;SQL because it teaches you how to talk to data. JavaScript because no matter what language and project you are working with, you can think to yourself "At least I am not using JavaScript." \- Some old grumpy developer I used to work with
&gt;Exactly. People hate on PHP too much. It's a Shame, because the truth is that, people don't hate PHP. People hate the Code developers from the 2000 \~2010 have written in PHP. Most code I have seen in Github in PHP totally rocks. We have nothing to envy from other languages :')
If I get good feedback from this post then I'm planning on raising this with the PHP internals mailing list. I think it first needs to be proven that this is something the PHP community wants, otherwise I'm doubtful that they'll take the suggestion very seriously. In terms of people can do to help, there's a tonne of discussion that will need to happen around this if anything is ever going to happen. There's numerous approaches suggested (namespaces, scalar objects, just a straight rename). Have a read of the suggestions that are out there, check out the criticism, see if it can be addressed, contribute to the discussion, blog about it, tweet about it, talk about it and share it. A critical reason for [scalar type hints](https://wiki.php.net/rfc/scalar_type_hints) passing was that lots of people were talking about it and letting internals know that it was something everyone wanted.
What PHP 8 needs: - Some way to not have to start an all-code file with &lt;?php - Some real async. Threads would be great, but async lambdas or something similar would help. - Clean up the stdlib! The people that everyone is so worried about breaking BC for are still running php 5.3. They're not upgrading. No one who upgraded to PHP 7 is going to not upgrade because array_walk is going away, and there's nothing saying that we can't have array_walk and $array-&gt;map at the same time. 
Yes! There's no true boolean datatype in MySql: &gt; [BOOL](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html), [BOOLEAN](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html) &gt; These types are synonyms for [TINYINT(1)](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html). A value of zero is considered false. Nonzero values are considered true:
Don't, since it's a bad idea. The better approach is already in the system and is evolving other ways. A few swapped variables orders is an *obvious* sub-optimal situation that every junior dev picks up on and freaks out about. It's not an *actual* issue. If it chaps your hide so much write a shim object, order the params however you see fit and stop trying to create unnecessary refactoring work for old, stable, functional codebases.
No semicolons is a terrible idea. I need it for custom indentations.
I'm an experienced C++ dev, but our team size and deadlines precluded C++ as being feasible - the productivity benefit from using an interpreted language is huge! Additionally our team was already familiar with PHP meaning that the training ramp-up was in learning GTK's APIs. There were only a small number of scenarios where the single-threaded nature of PHP was an issue (e.g. receipt printing) - in these cases we simply spawned a new process to execute these tasks. 
I hope PHP makes a serious push to get native support on serverless platforms. Lack of AWS Lambda support is the main thing driving me away from PHP development at this point. I feel like reliance on compiled libraries is the main thing holding it back at this point.
&gt; the productivity benefit from using an interpreted language is huge! If that is the only parameter that's important, then I can see why PHP looked like a good choice - it's one of the reason I like PHP for web development - it's super quick to build something, but in my opinion it also comes at a cost because of the inconsistencies in the language and the lack of strong typing (which is something I really like). I'd probably make it on Golang these days instead; the GTK bindings are not 100% complete, but they are _decent_.
is there a reason to have a boolean data type in mysqli bind_param() ?
yeah, differentiate, for instance , a professional(company) buyer from an individual(civilian) buyer
- Security - Faster future development time (highlight *specific* areas of cruft) - Easier to find resources (no one who learned PHP in the last few years is going to know ZF1) Also, try and be clever about your approach. Understand and be able to convey to management the Second System Effect, but also offer an approach that can be phased. This is often as simple as doing terrible things to one of the platform's routers. Upgrading to Symfony from ZF1 should be pretty cut and dry. They're both "modern" frameworks.
I consider it extremely unlikely that PHP will get native parallelism. Non-blocking I/O, yes, and that's planned for PHP 8.
The header issue: You close your script with `?&gt;` but leave trailing whitespace, which PHP interprets as HTML output and stops headers (i.e. session cookies) from being sent.
you are probably not entirely realize what mysqli bind_param is for. there are no buyers to be used with this function. 
Non-blocking IO is node buzzword crap. In 2012 PHP was trying to be Java, now it's trying to be JavaScript. It needs to just try and be PHP.
no , what i mean is that in my case,i prepare an insert, and in the insert, the argument that relate to the buyers status is either 0 or 1 , one mean profesional and 0 mean civilian, so i need to bind the var to my prepared insert
0 an 1 aren't boolean values, it's integer values so you should use i type
&gt; The problem with any radical change in core functions is that the language is simply too widely used to change that quickly. Wat? What do you mean by radical change? Core function changes are function changes. Like anything else a signature change requires search and replace and allows for optimizations (in some cases) where the core functions are truly strange. 
&gt; The problem with any radical change in core functions is that the language is simply too widely used to change that quickly Who said anything about doing it quickly? We can add new functions with correct parameter orders and alias the old ones without a BC break. Then in 5 years time deprecate the old ones, then in another 5 years (or even 10 or 20) remove them.
PHP needs to do LOTS a cleaning up, if it ever want to be a sane language to use. Really, PHP will be a complete new language it it would clean up and remove all the madness. Then the questions would be: why even use PHP? Theres lots of better options out there. That said, PHP is still a good pick for websites with small dynamic behaviour. For real apps, use something else
A regular ```if``` statement. I know people like them - just not my jam.
How is being sub-optimal not an ‚Äúactual issue‚Äù?
&gt; Some way to not have to start an all-code file with &lt;?php Why?
I totally hate PHP... and Java, Go, C#, Python, JavaScript, Rubg, VB, and more than I can name-- but they all still have their strengths. They all still have advantages and disadvantages. The question for me isn't "What don't I hate?" but rather "What would I hate *the least* for this task/project?"
&gt; May I ask why you choose PHP and not a better suited language with strong typing? &gt; I love PHP for web-development, but I cannot imagine writing a desktop application in it. Many people are using Electron these days. 
array_map's signature has to be $callable, $input because it's variadic it's more accurate to say the signature is $callable, ...$input it's not possible to do ...$input, $callable Then consider array_filter's signature $input, $callable well in reality it's signature is $input, ?$callable again you can't do ?$callable $input For those functions their behaviours do not allow compatible argument orders
Haha, I'm not proposing PHP's non-blocking I/O implementation will be anything like Nodes. Non-blocking I/O is just a way to maximize (i.e. minimize idling) processor usage without actually parallelizing code. Sure we may end up using libuv as it is stable and battle-tested as the underlying event-loop, but for everything else, PHP will do its own thing here. By the way, it is not node who coined the term of non-blocking I/O - they've just partially misused it as buzzword. Look up when the O_NONBLOCK flag had been added to the Linux kernel, some loooong time ago.
In a high level language like php, I'd expect for it to remove places for me to stub my toe. I'd rather fix the pothole, than put a traffic cone next to it and call people deficient for driving over it.
If you would like parameter order problems to go away then advocate this feature:https://reasonml.github.io/docs/en/function.html#labeled-arguments Then it won't matter what order you want, just reference it by name
The function names are what get me the most. I know this might get a lot of hate, but I went through a list of all PHP functions I could think of and listed what I felt *really* needs to exist, and renamed a few here and there ([gist here](https://gist.github.com/leemcd56/674e87ddecde2dadec8a13c930fc9dda)).
Sounds like you should find a new profession ;)
Why instead of that integer that nobody knows anything about you don't change it to enum so every body sees "profesional" or "civilian" and knows what it means?? üôÑüôÑüôÑ
While your points are technically correct they do not *need* to be designed this way. Take a look at `array_map`, for example. Note that its behavior differs if there is a single array or more than 1 which indicates it probably should have been 2 functions. Make sense?
&gt; but don't you notice a pattern of having to consistently fight the language? No. Not really. I've come to the conclusion that if I'm fighting something in code there is a good chance I'm doing it wrong. 
What the hell is this : https://twitter.com/php_net/status/1011620880982663170 ?!? 
&gt; Then the questions would be: why even use PHP? There are billions of lines of code in PHP that are still in use today. Do you really think switching away is so easy or simple?
Ah, it seems it's not an official account. 
I would venture that these days I write 4-5 code files to each template file, and most template files aren't even PHP anymore. It's just something that could go away. 
What do semicolons have to do with indentations?
With the introduction of scalar type hints and strict types in PHP 7.0 the type system in PHP got a lot better. See here: https://stackoverflow.com/questions/48723637/what-does-strict-types-do-in-php
Tooling vs work. I don't have to like the hammer to like working on buildings.
What do you mean? What exactly would have to change in PHP itself to work on that environment? A causal search shows that it is possible to run PHP in AWS Lambda..
As part of the [consistent_function_names](https://wiki.php.net/rfc/consistent_function_names) RFC there is a big list of mis-named functions.
The thing that gets me about that post, is they call the map variable uppercaseFruit, but do a `strtolower` on it
But if PHP would be refactored to be more sane, there would be some much BC breaks that all this code would never work...
What I'd really like to see is a brand new standard library that lives along side the current global functions. Should be possible if the new std lib is nicely name-spaced (could be used within the scalar object functions too), and would allow for fresh start without having to worry about backwards compatibility. Once the new std lib is mature enough the old global functions could be deprecated and removed in the next version, so probably php 10-11 if it were to be added in php 8. That would hopefully give enough time for most of the projects that care about staying up to date to migrate, and having the two libraries live side by side would allow a devs to migrate their code overtime instead being forced to do it all at once.
This seems like the correct way to do it to me. I don't know the severity of having ~1000 function aliases and how that would impact performance, and/or the size of the interpretter. I do think it would be a good thing to start now, and slowly deprecate old functions later.
&gt;The question for me isn't "What don't I hate?" but rather "What would I hate the least for this task/project?" Mi love for things start right where your hate start. I prefer to say: "Love the most", instado of "Hate the least". People put a lot of hard work to make PHP better, they deserve a bit of love from us &lt;3
So, how is Perl6 going?
Good spot, I'll fix that!
pipe operator is way better approach that turning all scalars into object-like shit
It's simply not a defect. It also does not lead to any unexpected behavior when used correctly. The existence of an inconsistency in the API parameters is therefore sub-optimal vs. an actual issue. There are other ways to express this, but it's basically not a bug, it's just something that would be more clear in documentation if it were different.
And good thing you shared that, too... I completely forgot string functions!
my train of thought was something along , why store a string when i can store a 0/1 value and that i'll go through an algorithm that can tell and replace the 0/1 by civilian/profesional anyway
Enum stores an int üòÅ check it
I'm amazed how many people that have a hangup on the standard library, sure, it is not perfect, but it works. There are so many more important things to implement &amp; change before this. Designing a standard library is hard to get right, really hard. It is a high probability that a new standard library design will have huge warts as well. Also writing a RFC for every change is extremely tedious. It is much better if the community designs a standard library. That can evolve, change and have multiple implementations. If the proposed features (JIT, preloading, FFI) are added to PHP 8, then it is feasible to do a community implementation without sacrificing too much performance. Remember that it exists way more PHP developers than core developers. Don't waste core developers time with things that have very little gain apart from alleviate OCD. 