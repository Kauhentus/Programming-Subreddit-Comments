Fair, `array_column` is new (and honestly does way too much stuff and its name isn't very good). The trouble with array_map and any function that will likely take a lambda/closure is that inline functions have sooooo much boilerplate: $names = array_map(function ($registrant) { return $registrant['name']; }, $registrants); This is actually a few more more characters and looks more cluttered than doing a foreach loop. This is one reason I really want a successor RFC to [short_closures](https://wiki.php.net/rfc/short_closures) to pass; the functional code *should* be better here but it's not really better. I have an RFC in the works but I'm trying to figure out the best RFC that Internals can agree on. If it looked more like any of the following then I'd be happier: $names = array_map($registrant =&gt; $registrant['name'], $registrants); $names = array_map($registrant ==&gt; $registrant['name'], $registrants); $names = array_map(|$registrant| $registrant['name'], $registrants); 
My good friend is one of those people. He loves functional programming and thinks it's better than OOP.
I totally agree. 
 array_column Internally PHP performs the same kind of loop. You are just hiding it under the rug, not eliminating it.
&gt; I don't see much PHAR use in the wild You haven't seen Composer in the wild? I'll be honest: Composer was actually the first time I had even heard about PHAR files. I can't really think of many other examples of PHAR being used as frequently as I see Composer, but there are other fairly ubiquitous packages that make use of them (Guzzle, for instance). That said, I think it's important to note what the author was saying: PHAR is *great* for compression and archiving, but if you plan on executing its contents from within an application, it would be best to extract and run everything directly. That doesn't mean PHAR is "over". Just that its place isn't necessarily best in production web applications. I would say that I could see more use for it on the command line than a general web project, but that's me.
Of those, only reflectors have a valid reason to accept any/all objects. The others appear to be examples of some pretty gross design flaws. I mean, what does a "generic factory" even do?
It actually is a bad practice most people don't think of their url's but i would recommend to read: https://www.w3.org/Provider/Style/URI.html It's a bit outdated but read the part of the cgi / perl scripts. Sure you can rewrite all your old url's but it would be better to have clean url's in the first place so you won't have to make a giant rewrite list if you ever need to migrate / rewrite the app.
&gt; switch (true) { &gt; case $shape['sideCount'] == 3: &gt; echo "Triangle"; &gt; break; &gt; case $shape['sideCount'] &gt; 3: &gt; echo "Some polygon"; &gt; break; &gt; case $shape['sideCount'] &lt; 3: &gt; echo "Not even a shape"; &gt; break; &gt; default: &gt; echo "Maybe it's a line?"; &gt; break; &gt; } .... Let's see how many lines of code I can save with an IF. if ($shape['sideCount'] == 3) { echo "Triangle"; } else if ($shape['sideCount'] &gt; 3) { echo "Some polygon"; } else if ($shape['sideCount'] &lt; 3) { echo "Not even a shape"; } The latter is much more readable than the former, from literally every point of view. *Just because you can, does not mean you should.*
I tried to keep it simple. 
good points! This article was already really long as-is so I had to keep it to just the top issues.
&gt; The latter is much more readable than the former, from literally every point of view. That's entirely subjective. I personally think switch statements are much easier to read than a bunch of if/else if's.
Sure! Take a look at the key management portion of our documentation: https://www.crypteron.com/docs/#key-management This goes into detail on how we solve that problem. I hope that helps! Keep in mind that Crypteron's Community plan is 100% free so, if you're still on the fence about our approach, just try it out for yourself.
Thanks! I spent a lot of time on it. Factoring in a trade off between security and implementation resources happens a lot, especially with low-risk data. There's no one-fits-all solution. When we built our encryption and key management platform we tried to remove this trade off by making robust and pervasive encryption and key management as easy as a few minutes of integration time. If it fits your project, give it a whirl. Our Community plan is 100% free. Right now we just support .NET, Java and Scala but we have a PHP edition in the works.
Sessions can absolutely be hijacked by threat actors. Though it would require some kind of MITM attack. Though I'm not aware of the best way to mitigate that threat. 
If you stay with PhpStorm/IdeaUltimate, I'd recommend you to check my plugin out plugins.jetbrains.com/plugin/7622?pr=phpStorm - it has a bunch of educational checks and pitfalls checks (which are pretty annoying when working with PHP after Java). That's really an advice (not promotion) ...
I'm not sure why the creator of Laravel saying "you don't have to replace every array with a collection" is getting downvoted. You can't get much more definitive than the guy who built the class for intended usage, IMO.
Sorry about the default, I was in a hurry but in a structural sense is using a Switch bad? I honestly believe it to be easier to read but apparently it's not up to standard?
We're support EC on curves NIST curves P-256, P-384 and P-521. Mostly for Suite B compliance so we can protect all workloads ranging from US DoD to a 2 person startup in Financial services. You sound like you'd be familiar but NIST SP800-56A, FIPS Pub 186-4 and 180-4 go into detail. Within those supported curves, we're using P-521 (secp521r1 to be specific) ourselves because it arguably exceeds Suite B Top Secret requirements and the performance overhead is only marginal. If an enterprise customer wants something different, we work to make it so for their instances. Disclaimer: I'm a Crypteron co-founder
I'd be the first person to tell you that event sourcing everything would be the worst idea ever :-) Everything should be done for a good reason.
I prefer foreach because in PHP an foreach loop is much faster then a map closure. http://stackoverflow.com/questions/18144782/performance-of-foreach-array-map-with-lambda-and-array-map-with-static-function http://www.phpbench.com/ 
I don't think it's "defunct" (obsolete), but you are correct that php7 out performs HHVM. But as always it's just a matter of right tool for the job 
There's nothing inherently wrong with switches by themselves, but in your case, you're using it incorrectly. Switches are intended to provide cases for literals, not entire expressions. If we rewrite it like so, it would be better, but still not great: foreach ($shapes as $shape) { switch ($shape['sideCount']) { case 1: echo "Maybe it's a line?"; break; case 0: case 2: echo "Not even a shape"; break; case 3: echo "Triangle"; break; default: echo "Some polygon"; break; } } As others have said, never use `switch(true)`. Switch blocks become much easier to manage when you're dealing with more than a handful of cases (the exact number is completely up to your preference, but I would personally say &gt; 8) If/else is perfectly readable on its own, and allows for more complex comparisons. /u/geggleto's example is probably the preferred way in your specific case: if ($shape['sideCount'] == 3) { echo "Triangle"; } else if ($shape['sideCount'] &gt; 3) { echo "Some polygon"; } else if ($shape['sideCount'] &lt; 3) { echo "Not even a shape"; }
&gt; An attacker as root on your webserver is bad but not game over with Crypteron since the security manager/developer/CISO can log onto their Crypteron dashboard, go inside their registered App and cut access, decoupling the crypto layer from the data layer. You're assuming that I can't just: 1. Slurp `/proc`, `/dev/shm`, `/dev/mem`, `/dev/kmem`, etc. 2. Pilfer the access keys from the XML file and/or binary blob of the application that connects to your API and then request the encryption key before the breach is detected. And then: just decrypt data, I already have the key. Shutting the door does nothing after you've already been raided and sacked. &gt; Also, this works especially well if you lose SSH access into the original webserver instances and/or database instances. In practice, this can dramatically reduce the fallout. As the resident cryptography nerd and security engineer, I don't see how userland software can hope to protect against kernel exploits (which is typically how `uid=0` gets achieved).
Agree! Support the pipe operator! https://wiki.php.net/rfc/pipe-operator :o
https://www.facebook.com/home.phpdicks
In case you wanted a real example of `min_by()`, I figured I'd introduce `array_reduce()` $lowest_paid = array_reduce($employees, function ($min, $employee) { return min($min, $employee-&gt;salary); }, reset($employees)-&gt;salary ); It takes `$employees`, and runs a function that compares the current employee salary to the minimum salary stored throughout. It is initialized with the salary of the first employee as a starting point to compare against. Edit: To return the employee itself, and not just the lowest wage (because it was bugging me): $lowest_paid = array_reduce($employees, function ($min, $employee) { return $min-&gt;salary &gt; $employee-&gt;salary ? $employee : $min; }, reset($employees)); If two employees have the same salary, it'll keep the current minimum rather than overwrite it with the newest compared employee. Change the `&gt;` to a `&gt;=` in order to make it overwrite the current minimum whenever an equal-salaried employee is encountered in the set.
Yes, I have. Sometimes I still wake up screaming.
A complete non-argument against what exactly? No one said anything about auditing or claimed that our library is open source. The point is that we don't use a proprietary custom encryption library. We use a standard and open implementation of AES-256-GCM. Data is encrypted within the application itself so your sensitive data never leaves that circle of trust. This makes auditing easier since you don't have to trust third party data store providers with your sensitive data.
We need a PHP version of this copypasta haha.
&gt;but is there anything that Hack can do that PHP7 can't? HHVM's [native] multithreading/async support comes to mind...which would definitely have a case for "right tool for the job"
Some people didn't like `~&gt;`, some didn't (and probably still do not) like implicit variable/value binding, some didn't like that it was bound by value instead of by reference. And many others who did not voice their opinion. However it still gathered 22 votes for it, so the feature itself seems to at least have some following even if if some details are wrong.
Haha duh not sure why I didn't remember that...
Why are you putting hashtags into the title of your post?
it was the same for me, but I grew into the style and now largely prefer array_column way. Try to remember the first time you discovered a new language (php, js, sql). I'm quite certain you didn't feel comfortable at first too.
Does it? I didn't know that, actually. I don't typically use PHAR on my own much, but that's good to know.
`switch` exists to handle different `case`s of a single enumerated value. Think about it grammatically - depending on which type of thing you get, you handle it differently. A separate boolean expression isn't a thing. Good switch: $item = Item::SOMETHING; // from db, whatever switch ($item) { case Item::TYPE1: // logic break; case Item::TYPE2: // logic break; default: // logic break; } or: $pid = pcntl_fork(); switch ($pid) { case 0: // handle being child break; case -1: // error case break; default: // handle being parent break; } While PHP's language grammar allows you to switch on a non-value to replace if/else, it's a bad idea, an anti-pattern, and heavily frowned upon. Generally speaking, if you either can't handle all values of something (e.g. a list of constants, known good values, etc) OR a fallback case doesn't make sense (handling only a subset of those values, and treating everything else the same), `switch` is the wrong language construct to use.
I would guess most purists about these things haven't actually spent a lot of time creating non-personal projects for production servers. I love array_map, array_filter, etc., but in some cases they're funkier than a simple loop, and many of the more functional built-ins become useless when the array's keys or indexes matter. Sometimes foreach ($collection as $key =&gt; $value) is clearer than the alternatives and gives you easy access to the index. And then there's recursive functions, which are beautiful but very dangerous in PHP code running on a web server. I bet I'm not the only one here who learned this the hard way. I don't know Laravel, though. Maybe it provides workarounds for PHPs troubled functional bits. 
Well it can actually provide some useful methods, such as getClass(), and hashCode(), it need not to be solely an empty object for type hinting purposes. My own Root Object class right now declares a few very useful methods that every subclass can use, including the two I mentioned at the beginning. 
No it's not. If he can't be bothered to read a for loop he should find a new job.
Apart from the good feedback here already, if your senior developer deserves his title he should be willing and able to explain this to you! 
I mean, this is true, but using `array_filter`, `array_map`, and `array_reduce` is not the same thing as bringing out a full-blown collection library as an external dependency to do something simple, which is what OP is concerned about. OP is talking about `$collection = new Collection($array)`, not `array_filter`. If you *already* have a collections library freely available to you, and using one has little cost, then fine. But if you're going out of your way to pull in a collection library to do what you can do with the standard library, then something is amiss.
I would even go as far as considering a switch statement a code smell that tells me I should improve the object architecture. A switch can almost always be improved with something more elegant, like in your example.
I wouldn't go as far :-) It's about trade-offs and choosing the lesser pain. Factoring everything into plenty of little classes has its own drawbacks, but when my code becomes a 1000-line art study into creative use of switch...case, I know it's time to refactor.
When you see an overly long, incredibly complex function that claims to "sanitize" your data, **run the fuck away**: https://github.com/bcit-ci/CodeIgniter/blob/4b94152a48d8053ab72669278abfec18e1793310/system/core/Security.php#L323 Ritualistic massaging of data through tons of filters and regular expressions will never be truly safe, and will frequently damage correct (and otherwise safe) data in ways ranging from subtle and undetectable (until it's too late) to mangled beyond recognition. It's a hallmark of people who have no idea how to correctly encode their data for a given target (be it HTML text, SQL value or identifier, etc.).
 // Is the string an array? if (is_array($str)) // Remove Invisible Characters $str = remove_invisible_characters($str); I see that Captain Obvious wrote that function. I love that guy.
The late (now closed source) phpfmt used to be shipped with phar files. 
Just don't listen to these devs. They just are excited they discovered a new bloated way to do something that's done more efficiently in more standardized ways. This was already done in PHP in it's first stages of SPL and collection iterations. This is not new concept, just another way of doing it. Too many keystrokes and bits for my tastes though. Stick with foreach, but also look into ArrrayObjects in conjunction with iterators. Very handy stuff and less long-winded.
&gt; This makes auditing easier since you don't have to trust third party data store providers with your sensitive data. I don't think your definition of auditing is in line with mine if data living inside a closed source application makes it "easier".
No you can't match with the logged in user because someone can simply create the URL, and trick the actual user to load that URL (src attribute of an img tag for example). Browser will send the request, and your site will think the user actually intended to delete that post. Basically, CSRF.
This is actually a good advice. If I find myself using switches or several if/elseif/else blocks, I get the subtle hint that I'm coupling things that could have been decoupled somewhere else.
Nice! While we are there, we could over-engineer by using Reflection to inspect the SIDE_COUNT const of each class, and then create a class of that instance, avoiding the switch block.
Sorry was in meetings most of the day, just getting a moment to catch up on the threads .. &gt; You're assuming that I can't just: &gt; 1. Slurp /proc, /dev/shm, /dev/mem, /dev/kmem, etc. &gt; 2. Pilfer the access keys from the XML file and/or binary blob of the application that connects to your API and then request the encryption key before the breach is detected. And then: just decrypt data, I already have the key. &gt; Shutting the door does nothing after you've already been raided and sacked. Yes, you can do that (and more) but the keys auto flush (couple of minutes) which reduces the window of opportunity significantly. Also you'd only get the encryption keys present in memory at that time - not necessarily all the encryption keys (potentially 1000s or 100Ks) that could be used across a large application. So the fallout can be limited. I've been told by a banking customer that just as multi-factor authentication makes it *significantly* harder to break it, Crypteron forces attackers to mount a multi-factor hack instead of your traditional hit and run hack. Perfect security is asymptotic, but you can go very far with us. &gt; As the resident cryptography nerd and security engineer, I don't see how userland software can hope to protect against kernel exploits (which is typically how uid=0 gets achieved). It doesn't and that's not the claim. The claim is that even if you lose access to the VM/host (e.g. SSH access) the userland platform has some controls to neuter itself (not the host). Finally, our trust model DOES trust the app compute, so we do recommend good practices there like patching etc.. I mean at the end of the day, we could all the fancy crypto (or some scifi bit-teleportation from Andromeda ;) !) - the clear data is present on those compute instances in order for it to do something useful with it.
When you use loops, you emphasize on the mechanics *how* you want things done. If you use functional constructs, you emphasize on *what* should be done and you leave the mechanics to the library. For me, this makes code more readable because I can just glance at the predicates to know what's going on without needing to fire off a PHP interpreter in my head, manually keeping track of loop state. 
Loop or conditional statement is fine. It'll start to get bad when you have more than 1 indentation of this conditional logic. It's hard to keep track of things and the code will become buggy. Understanding refactoring with collection gives you additional tool to make your code more readable as it is easy to read them at a cursory glance.
There are tons of vulnerable plugins out there, made by people who really should know better. Many Wordpress shops just cram in tons of plugins to "enhance" their client's website, and it just results in a slower website and tons of security holes. Same goes for other CMSes.
All programming languages do memory allocation too, but PHP hides it internally. An `if` statement is just some transistors in the CPU doing a comparison function and conditionally fiddling with some bits in the program counter. A language is used to express ideas. This goes for all languages, including Swedish. We can express details or we can convey a bigger picture. We create abstractions in our language so that we can easier talk about that bigger picture without bothering about the details. Here's an example using the language English: &gt; Move your left leg forward, then put down your foot. While maintaining balance you move your right leg forward and put down your foot beside the left foot. Bend your knees followed by moving your arm in front of you, still leaving the arm hanging. towards the ground. Position the arm so that your fingers are around the circular metallic object. Grab the disc by pushing your fingers together. Using abstractions we can instead say: &gt; Take one step forward and pick up the coin from the ground. If all your program is doing is looping over data you might be fine with expressing the loops explicitly. In some cases it makes sense to do it, for example if the loops have some important details or side-effects that you want to be upfront about. On the other hand, if you maintain a program that processes payments, dispatches e-mails and sets up tournament brackets; then you might be more interested in the interactions between these different parts. So you create abstractions to hide the details.
Of course there is. Imagine a page that collects data from third-party APIs for a keyword given in the URL - perhaps querying ten different APIs to collect some related data, e.g. operations that are time-consuming, even if the result they eventually yield is NULL. In this case, that NULL value was very expensive to procure, and you don't want to repeat that operation for every request, so you would need to cache the NULL value to indicate that nothing was found and that you shouldn't look again soon. Of course, as others have pointed out, it's very easy to design around that use-case even if your cache doesn't physically store NULLs - for example, store an array of results instead, so you'd be able to distinguish a result like [] from a result like ["foo"]. (in some cases, that's cleaner programming anyway, since you don't need if/else-statements, but can instead loop over the results unconditionally.)
Be aware that the switch condition evals the same as == and not === so if you do this: switch ('some_string') { case 0: echo "wrong"; break; case 'some_string': echo "good"; break; } It will echo "wrong". 
Saving lines of code is not a good rule about code quality, readability is. The switch/case is the perfect structure for reading state-machines, and your computer being a state-machine, it's the best structure to make your code readable in many cases. if / elseif/ elseif /elseif /else are mostly visual pllution. Code needs to breath, litterally, you need whitespaces between lines and indentation to make your eye more comfortable with what it's reading, the if structure does not highlight the compared value and does not breath while the switch statement does. Fewer lines of code is often wrongly taken as a sign of quality, but it's mostly sign of people not putting the form in the code. I mean, did you ever read any book with no whitespace at all?
Let's take Reddit for example, what does it do? It simply doesn't accept user-provided HTML. In the majority of cases, this is the correct solution. HTML is notoriously ambiguous to parse, and has an endless set of continuously growing features that can trip you up. Do you *really* need to give this power to a user? No. Give them a DSL to make their text bold, italic, and post links. You can even have a WYSIWYG for it, but that WYSIWYG doesn't have to send HTML to the server, just because it uses HTML *for preview purposes* in the browser. Now, let's say you are reckless and you want to accept HTML anyway. What should you do? It's an essential security principle: don't blacklist what you don't want, but whitelist what you want. Because you can never have a full list of what you don't want (even if you did, when Chrome updates from version 53 to version 54 under your nose... it'll add something funky to HTML and you don't have a full list, again). And the only way to reliably whitelist, is not to *filter* content through half-assed regex and what not and hope the result kind-of makes sense, but to follow these steps. 1. Parse the input content to DOM. 2. Any node type, attribute name, value format that's not in the strict whitelist? Don't filter. Reject. Regular users wouldn't submit non-compliant content, or would correct themselves after rejection. 3. Rebuild into compliant markup from DOM. You have to rebuild because parsing HTML is *ambiguous*. One browser can see JavaScript XSS into a piece of "just so" formatted HTML, while another won't. So rebuilding ensures that "just so" formatting is not a factor. But it doesn't stop here, because HTML/XML is complex enough that some parsers are vulnerable themselves. It's such a complicated monster. So you need to be sure that the parser you're using is battle-tested for use with possibly malicious and malformed input (HTML Tidy and similar libraries are created for this purpose). So, **TL;DR**: 1. Accept the simplest input you can. HTML is not simple, it's the most complex input you can possibly accept. 2. Don't blacklist, whitelist. 3. Don't filter, reject. 4. If you insist on HTML, don't "ballpark" the processing of a string with regex, use a compliant safe parser for your input, and rebuild clean markup from DOM. So, **TL;DR;TL;DR**: 1. Don't accept HTML.
I'm still trying to figure out what a "heavy" router is these days. That said, one thing is for certain, if a router is so lightweight that it has no way to easily modify or inject a controller resolver and dispatcher that enables me to do DI on instantiation/invocation, then it's a no-go.
Not to mention that callables use additional memory (which hopefully is limited to the scope but can leak when miss-used)
I know some one who is a rails programmer and hates OO. They only use functional programming and it's concepts. Recently I've been learning rust and the way the community uses functional programming. I think there's room for both and I think it's wise to learn both. How ever, I think with Php being a OO language it makes more sense to use OO concepts. Not saying basic loops are OO though. With JavaScript and other non OO languages (one could argue that because ecmascript has classes now that it's OO) functional concepts make some sense if not more. 
https://github.com/borislemke/nodejs_vs_php Is this a valid benchmark? I guess he didn't use PHP 7 opcache. What are your thoughts? I also read about haskell, but don't know if that would be another competitor.
https://phpschool.io/ is a really good way of learning hands on
Multilanguage support is something you don't want to reinvent on your own. Just use an existing, proven library. Symfony gives you a few hints: http://symfony.com/doc/current/best_practices/i18n.html If you don't use a framework already supporting i18n, then you might use intl and gettext: http://stackoverflow.com/questions/11505496/are-there-any-library-for-i18n-on-plain-php-without-any-framework
I'm using vanilla PHP, no framework. Is my way of thinking wrong? I mean, there's not much to it so how is it any different from other ways of implementing this? Also - I don't need time zones, different currencies etc. I only need strings in different languages. Isn't "intl" for example - an overkill?
What /u/AhmadTibi is describing is one user acting on another user's content aka. horizontal privilege escalation. CSRF tokens do not stop you from e.g. modifying hidden fields.
You gave a wrong link. Symfony translation component is framework agnostic http://symfony.com/doc/current/components/translation.html . Use this component, because all problems that you will encounter during development of you custom translation component are already solved here.
Are people actually still using this train wreck that is codeigniter? The devs attitude towards the OP's security report is pretty disgusting in a public forum as well
&gt; So, TL;DR;TL;DR: &gt; Don't accept HTML. +1 there is no excuse to accept HTML as an input 
Great talk on topic about if's and swithes https://www.youtube.com/watch?v=4F72VULWFvc&amp;list=PLKxYePINkYhRZtRuWTfgHeqXSFoElAba0&amp;index=1
&gt;Laravel community They are not laravel 'community', they are french web *artisans* because of which PHP is cool again. Either be like them or die. 
I also use vanilla PHP, arrays and sprintf() :) 
I gave a correct link to some hints about i18n. This one to the translation component is a good addition and suggestion for a good library to use.
I don't know if anything suddenly changed in the last 4 months, but last time I had to work on a WordPress site (that was up to date), the core's code was in a pretty sorry state, full of globals, and the odd poorly factored class here and there. I'm glad they're improving, but they'll have to break BC quite comprehensively to really fix their architecture.
Why a customised version? Why should I trust you? What's wrong with the official PHP builds for Windows?
Composer checks these conflicts whenever you update.
Or you could create a Factory class to ease creating your bot while clearly exposing your bot dependencies
In spite of the negative karma of this post, there is something to be said for following in the footsteps of previous implementors. At my work, we do use a database back-end for internationalization, and we did consider the flat-file "gettext" approach at one point. We really need the database now because we are an organization of about 200 software engineers who want to be able to add and change strings, and off-shore translators need to go translate them. The best way to manage that lifecycle is in the database. However, we still need to be able to serve tens of millions of page views per day, so we heavily cache the translations; first in memcached, and then again in local APC (we use the uAPC extension or whatever it is) cache. I don't think our website would stand up straight without APC in between; there are simply too many translation queries per page. My point in all of this is that building your own internationalization table and storing the text there is fine. Deal with scaling as it becomes an issue later on (always a good problem to have), and don't overthink it.
ITT dude is too lazy to set up composer, others downvote sane suggestions
&gt; I think the idea of functional programming is to make it easier to read. Whaaaat?!
The same reason everyone started eating Kale and not eating bread. Its a fad. Hopefully it won't stick around. That being said, I do prefer: defined('ABSPATH') or die(); to: if ( ! defined( ‘ABSPATH’ ) ) exit; It just sounds way cooler...
Piwik
The SQLite website itself uses SQLite (though not through PHP) and it gets a little more than 425,000 hits on a typical workday. About 80% of those requests are for static content, though the other 20% hit one of several databases (via the Fossil version control system running as CGI - https://www.fossil-scm.org/fossil/doc/trunk/www/index.wiki). Each of those CGI pages does approximately 200 SQL queries. SQL writes happen, but most transactions are read-only. The website runs on VM which is a 1/24th slice of a real machine (it is a Linode 8192) and the load average as I type this message is 0.04. Seasoned website builders cringe when they hear that a single page requires about 200 SQL queries to construct. This reflex comes about because on client/server databases each query requires a round-trip to the database engine, which normally involves an exchange of multiple TCP/IP packets, which gives each SQL query a lot of latency. But with SQLite, a query is just a function call. So it is no problem at all for SQLite to be used in "chatty" applications that make dozens or hundreds of small SQL queries in the course of generating a single page.
I will assume you don't really know what is functionnal programming and what are its benefits. PHP is not functionnal, and no matter how hard you try, every attempt will just be syntactic sugar with more or less overhead; but in the end, real functionnal programming worth the shot only if you are using a functionnal language, and a functionnal vm that can and will parallelize every move you make. Speaking about functionnal programming without speaking about immutability and call-by-value makes no sense. Functionnal is a very different paradigm, and a simple each() function, or working on collection abstraction is NOT functionnal, it's just a different API. This is not about you, and don't take it personnal, but most people in here are using the "functionnal" word just to speak about closures, it's so wrong.
So having a different opinion means being wrong? 
Likewise.
can you talk more on that? what do you mean site will think the user actually intended to delete that post? what i was trying to do is that it will only delete where session username = :author. how can someone play with that? (excluding mitm attack and session hijacking) 
I do this as well, and i use English as a base language. translations.php $languages = array( 'en' =&gt; array( 'hello' =&gt; 'hello' ), 'ru' =&gt; array( 'hello' =&gt; 'whatever hello is in Russian' ) ); script.php require_once('translations.php'); $output = sprintf('&lt;h1&gt;%s&lt;/h1&gt;', $languages['en']['hello']); $output = sprintf('&lt;h1&gt;%s&lt;/h1&gt;', $languages['ru']['hello']); Optionally I require a language file based on the desired language en.php $languages = array( 'hello' =&gt; 'hello' ); script.php require_once('en.php'); $output = sprintf('&lt;h1&gt;%s&lt;/h1&gt;', $languages['hello']);
Prefer PHP Based Open Source CMS has been the chosen application as it provides complete solution for data and information handling.
How do you deal with translating into languages which have different rules for pluralisation?
For the question specified, that doesn't include "vanilla only" requirement using a library is the best option 
Don't let your dreams be dreams, little string. With enough dedication you too can become an array!
&gt; in general all basic uses of loops and conditionals, functional approach is definitely not an improvement Oh boy I know some people that are so enraged over this.
* npm install * gulp build: * Compile scss files * Combine and uglify js * Generate cache busting hashes During development, gulp watch combines, but without minification and also generates source maps. It also watches templates scss, and js, and automatically injects changes into the page via browsersync 
You could use GNU gettext for localisation, which is available as a PHP extension.
1. Disable unused modules - **irrelevant**. 2. Unexpose PHP - **bogus**. Security through very silly obscurity. 3. Disable Remote Code Execution **so-so**. In fact, it is not *remote* code execution that is dangerous but *user-controlled* code execution. If you allow to run a file of user choice - you re busted. Even with remote execution disabled. 4. Log PHP Errors - **good** 5. Limit Resources such as execution time and memory limit - **so-so**. Good in general but security? 6. Disable Dangerous PHP Functions - **OMG**. There are no "dangerous" functions, there are only dangerous programmers. And what's wrong with curl_exec? The word "exec"? I see the author is a sure security pro. 7. Upload Files - **stupid**. What if my app requires upload? 8. Keep Things Up to Date - **good** 9. Use open_basedir - **good** 10. Control the POST Size - **duplicate**. Should be a part of #5. Conclusion: it's actually only 3 not-so-top security related tips 
There's nothing bad about either approach. They both have merits. And you can certainly have a preference. But don't dismiss various approaches because they don't fit your philosophy or preferences. At the end of the day, we're all just trying to do a good job and build some good software. We end up reading code far more than we write it, so do what helps you and your team understand your code best. But from time to time, take the opportunity to learn new ways of approaching problems, like using these "collection" functional approaches. Like me, you may find them enlightening and extremely helpful. And if you don't, at least you're knowledgeable and versed in the drawbacks you found when using it.
I used SQLite for the Laravel forums for several years and it was fine.
You shouldn't add your dependency in a phar unless it's not meant to share an execution environment with 3rd party code. This is actually not specific to phar.
Welcome to /r/php
&gt; The devs attitude towards the OP's security report is pretty disgusting in a public forum as well They **do** actually have a point.
Protip: GNU make still works great
I don't care. I'm not encouraging you to download anything.
[WPScan](https://wpscan.org/) could probably be of some use if you have a Wordpress site.
A reply from sqlite. Awesome. This is why I love reddit. 
there is no auth system. it is single file database not server.
Same conclusion for me. I would add that if any sysadmin does what this article says, there is no modern PHP application that will ever be able to run on this setup.
I checked and you can't use prepared statements with column names, correct me if I'm wrong.
I like http://robo.li/ Lets me write my tasks in PHP instead of making me switch contexts. It does great at integrating with whatever tool I thought I needed at the time the project was built, yet provide a common entry point for Jenkins to kick off my build process.
adminer is a phpmyadmin alternative. Navicats PHP connector allows your app to connect to an sqlite instance across the network.
The problem is, as a library author, there is no single value that makes sense to store as null. What if i actually want to store an empty array, different from null? Edit: I'm not actually sure you fully understood my viewpoint. I fully understand the value of being able to store null, and am an advocate of allowing it. It's just not easy to do, if the PSR doesn't allow it. 
&gt; Good in general but security? I guess it can help mitigate DoS attacks?
Laravel collections don't recurse. They are just thin wrappers on top of PHP functions. The main advantage of collections is the coherent interface.
Cool, thanks! BrowserSync is the part I always have trouble with, but I'll figure it out eventually :)
I'm in a unique situation where the company I work for built their original system in classic ASP and later ported to PHP, so the platform has been through a lot of churn. To our credit, we continue to make it better and continue to make more money. In this sub, it is not always clear which goal the poster is interested in. To quote Dan Milstein, "There are two kinds of start-ups in the world. There are those who have gained some traction in the market on a codebase that everyone who works there is vaguely ashamed of, and the ones that failed." When starting a new business or site, I would encourage reuse of third-party components if they are easily composable. I haven't used Symfony's translation component, but the Symfony framework has a good reputation. I would also consider something from Aura or Laravel, depending on the situation. But then again, it depends on the motive. Are you optimizing for speed-to-market? Then use an existing component. Are you optimizing for learning how to build things? Then build your own thing. Either way I think there is immeasurable value in evaluating existing components so that you have a frame of reference for what you are doing.
You do realize that I am not suggesting that this array/translation system in any way complete? It fits nicely if your needs are basic. Even third party libraries will encounter difficulities if you throw complex linguistics at it. I am not fond of the idea that one tool solves all cases. I rather investigate what suits my needs, and then apply the tool that is best suited. Sometimes it is something I can put togheter myself quite quickly, sometimes it is a third party library. However, for Norwegian and English, that sentence works out quite nicely. I do know that this is not the case for all languages. I do want to say that in case of such a sentence I probably would opt for a differnt solution. Both *Twelve elves live in eleven houses* and *Tolv alver bor i elleve hus* printf('%s %s %s %s %s %s', $language[$numberOfElves], $numberOfElves &gt; 1 ? $language['elves_plural'] : $language['elves_singular'], $language['lives'], $language['in'], $language[$numberOfHouses], $numberOfHouses &gt; 1 ? $language['house_plural'] : $language['house_singular'] ); In order to keep this example simple, I've avoided the case where either $numberOfElves or $numberOfHouses is 0, but it should be quite trivial to apply. Edit: I very rarly have the need to build sentences like this, come to think of it I do not think I ever have. I try to keep it to simple words and complete sentences.
Case in point :-)
25 seconds is more than enough to exploit. 
All the good third party libraries have solutions to this type of problem already - these are some of the basic things that are needed in a translation system that have already been solved. If your translation needs are purely translating very simple sentences or single words, then you can do it in almost any way. However, any good localization library will have solutions for these kinds of common needs already baked in.
Nope, it shouldn't be. You see, it's not a private matter between the two. It's a matter of their behavior towards *other operators.* You may read my old answer on SO, explaining useful exploits of different precedence: http://stackoverflow.com/a/15320411/285587 (starting from "On the syntax") 
The static web pages are generated by TCL scripts using information from a variety of sources - such as comments in the SQLite source code and separate documentation files. The source code to the documentation is at https://www.sqlite.org/docsrc/timeline - We build the static web pages on a desktop machine then use rsync to push them to the website. Most of the dynamic content comes from Fossil (https://www.fossil-scm.org/index.html/doc/trunk/www/index.wiki) which is written in C. But a few things like the Search feature on the menu bar are done with simple TCL scripts. A custom webserver is used. (Sources at https://www.sqlite.org/docsrc/artifact/c3a749450a2f) The webserver and all the CGIs run inside a minimal chroot jail. A new althttpd process is started (via xinetd or stunnel4) for each inbound TCP/IP connection.
Nice one, thanks! So, if i write something like this `if (some_heavy_function() or some_other_heavy_function())` it will execute second function only when the first one returns `false`, and `if (some_heavy_function() || some_other_heavy_function())` will execute both?
Is 8.2 stable enough?
Nope. Both will execute only the leftmost one if it would return TRUE-like value. That's a different trick :) Sorry I didn't make myself clear. Here we are talking rather of this kind of operation: $variable = f1() OR f2(); $variable = f1() || f2(); Given `f1()` returns a `true`-like value, in the first case the `$variable` will contain this value, while in the second case `$variable` will contain a boolean `TRUE` You see, it's all about relations with other operators.
Oh, I see, now your answer about `mysql_connect() or die()` totally makes sense to me :) So, inside `if` statement it appears that they are equal, right?
This is why you should love Sqlite more! I have used Sqlite with Java, Android, C and PHP, and it just fucking works everywhere. No hassle anywhere. I have seen many questions on many forums pop up about Sqlite, and about 15 minutes later the main guy, Richard Hipp, is there attending to your worries. If even a few more software guys were like those sqlite guys I would start believing in the future of the mankind, again.
You definitely don't want to be using SQLite if your app is write heavy. A read heavy DB that doesn't depend on its writes to work (i.e. caching) is perfect for sqlite. Seasoned website builders use the best solution for the specific job they're working on.
yeah, personally, I think I would do away with the abstract class and just have the classes and interface. The abstract class could be useful if you want to do other logic but the interface already requires the getters, so why not just have the methods in the actual classes? **EDIT** https://gist.github.com/haydenk/a3e6e6e487875abc0b2b86ec3ef9a1c6
I could go either way on it. I set it up as an abstraction to DRY up everything, but it may be more appropriate as a Trait. The language involved with `AbstractShape` felt more natural to use rather than what would have been implemented as a trait, so it was more of an aesthetic decision than a functional one.
In IDE settings: Plugins. There will be a button "Install plugin from disk" above plugins list. Click it and select the downloaded PhpInspectionsEA.jar file, restart IDE as it asks. That's it.
https://www.pluginvulnerabilities.com/2016/05/31/aribitrary-file-upload-vulnerability-in-wp-mobile-detector/ Is from May 31, this year, ie 4 months ago. So no, this isn't breaking news. It's a demonstration of what this class of vulnerability looks like.
I'd been looking at Fossil for a unified software project manager over Github and I'm really relieved to hear an outfit as sizable as SQLite found it suitable. I'll never hit those numbers. Thanks for the deep insight into the systems in play.
I've been using SQLite for a lot of websites those past few years. I only use mySQL where I know I might want to have multiple DB servers. The biggest use was a product database containing millions of rows, with a few hundred added each night from a crawler, and it performed really well. I used SQLite as the only storage backend in Garradin, a free software non-profit management software (in French): https://garradin.eu/ And I use it to store everything from files (then cached for the webserver to make things slightly quicker) to accounting, wiki, user accounts, and I have thousands of instances of this software on an Atom server, each reading and writing to its own SQLite server, serving about 100,000 hits every day, and it works really well. It came to a point that I'm considering abandoning mySQL altogether for all my projects, as SQLite is just easier to manage and has better performance, plus it's so easy to backup: just copy the .sqlite file and you are done.
Ah, that makes me feel a bit better. I thought I'd totally lost it there for a while. Thank you!
Then SQLite is the wrong tool for the job. Per [their website](https://sqlite.org/whentouse.html): SQLite does not compete with client/server databases. SQLite competes with fopen().
Indeed, but if there's an empty array with your solution, then the lowest paid employee is $0, which might make sense if you have some volunteers and/or someone forgot to enter a salary. PHP_INT_MAX at least jumps out as a suspicious number. But in either scenario you should probably just put a special case and avoid the array_reduce altogether.
It's not me "suggesting", it's PHP. Your snippet is different
[Salt rock and flavor leaf](http://cube-drone.com/comics/c/how-it-feels-to-learn-javascript-in-2016).
Good question. You know what? I think it was ruby. Thanks for the tip, I will look into that. 
Can recommend [this](https://www.bookdepository.com/Domain-driven-Design-Eric-Evans/9780321125217) book, might be a bit older but still very relevant.
And if you really want to implement your own solution (I did), just look at the code of gettext ;)
I've done some SQLite over NFS, and it's clunky and unreliable. Also slow. Go local or go home.
&gt;production-ready data store Many applications (including some which I have built) use SQLite for storing of configurations and database data locally. Much better than binary files. Android uses sqlite, for example.
UML is sort of a nice idea, but it has little practical value. You're better off brainstorming on a piece of paper (by yourself) or a whiteboard (in a team), then writing a prototype for your chosen interfaces and trying them out.
the problem is when you deal with clients and there are contracts. UML is important so everyone knows what needs to be done and have a timeline on how long it will take.
Your clients require mapping out the project in UML? I'm not saying it's a bad idea to plan and so on, I'm just not quite sure UML will help you much. It's a tool from another era.
usually clients are oblivious about what they need and ask, usually they ask what they don't need and they obviate steps which are crucial for a developer. Thats why UML is important. If you know any other better tool I am all ears
Thank you for your replies, it's really interesting reading. Yesterday I read an article "SQLite As An Application File Format" https://www.sqlite.org/appfileformat.html and it reminds me that it's time to abandon old habits and cliches and start to use SQLite also for web projects :) 
We just released 2.0.0 of php-school/cli-menu : https://github.com/php-school/cli-menu Couple of interesting new things: * Being able to display confirmations and message flashes over the menu. Useful for feedback when an action is performed. * Modifying the style of the menu while it is open * Toggling the item extra while the menu is open * Add and remove items while the menu is open * Redrawing the menu at any point * Various api improvements and cleanup Since 1.2.0 you can also disable menu items and sub-menus which will dim them in the menu and make them un-selectable. Full changelog: https://github.com/php-school/cli-menu/releases Let us know what you think! 
&gt;Generic factories? Dunno, I copy pasted one top answer for which I can see what 5 out of 6 of the items are. &gt;Serialization of any object of any class, ever (what you're declaring with an object typehint) requires knowledge that a "generic serializer" simply does not and can never have. Sure it can have it, via Reflection for example. To continue on the example of the serializer, your argument make sense to a certain extend, but there is also a lot of cases where having more generic and a bit configurable which cover most of the common use cases and avoid you to have to create one dedicated serializer for each class. For an hydrator if you have an array of data `['foo' =&gt; 'bar']` to which you must hydrate and instance `$dummy`, you can easily guess that `$dummy` has a `foo` property with a mutator `setFoo()` for example. Sure there is cases when that's not the case and you have to create a custom hydrator, but the goal of the generic one is not to cover all cases, just to avoid you the most common ones. If the serialization of my objects can be done at 80% by a generic serializer and a bit of configuration for contextual serialization, I'm all up for it. If I need something more custom or more performant, I can always write a custom one. I don't see what's wrong with that or with this kind of abstraction. &gt;Yes, I am an ORM author, and have been architecting code at this level for over a decade. But let's keep the discussion about the designs/proposal and not our resumes. I didn't have any intention to switch the conversation to our resumes. I asked because it is an example where such scenarios can be quite useful. But as you're an ORM author yourself, I'm even more confused by your stance, which is why I would be more curious to see examples rather than just hear "it's a bad abstraction".
Make your life easy (and your collegues') by being specific. Just use () braces to manage precedence, so both "OR" and "||" have the same result. You might know the difference between OR and ||, but the next person might not: "I'm so cool that I know about the or/|| thingy, so I 'correct' it everywhere!!" You're a douche. The first junior/medior that comes along will create a bug. But with this bug being so subtle, people will notice this after months. If not years. "But I TDD!!1". Have an upvote, $karma++ or whatever you like, but did you test that weird OR/|| ? I bet you didn't... Just use: ```$result = (($var1 == 1) OR ($var2 === 2));``` It's the same as: ```$result = (($var1 == 1) || ($var2 === 2));``` Problem solved...
its not about locking down the project, its about having a document stating exactly what and how the each millestone will be developed so the customer doesn't try to add any 'quick fix' request to it without us finding out and properly charging about it. Currently we have a client which the process was pretty much exactly what you did, but that client is pretty much oblivious about its requests and they keep changing at every millestone having to rewrite 50-80% of the previous millestone. So we need to have a document to s ay "you requested this a week ago, we can redo it but it will cost you". Having it on email/whiteboard pics/screenshoots have not worked because the client think "its just a button"
I don't know what to tell you from a description this abstract. The problem may be with the client, or the problem may be with your architecture, which should always have some leeway for change. Or most likely it's a bit of both. I also don't see the problem. Again, you are under contractual obligation only one milestone ahead. The rest is speculative and should be left relatively open. If your customer changes big features from milestone 1 to milestone 2, you'll have the chance to negotiate this and get paid when you sign the contract for milestone 2. I don't think any superfluous technical documentation will convince a client that it's not "just a button". I've had these situations on a project where midway both sides realize we can do something in a much better way, but it might require some work to be redone. We sit down with the clients and talk. It doesn't have to be in technical terms, but just in plain English. And we figure out should we change course or not. Then the change is either a bullet point in the next milestone or it's not, based on our decision. The way to get your client to understand why something is slow and expensive is not through providing more documentation. An utterly complicated change might require just one sentence in your contract, as a feature description, and this is fine. Just sit down and talk. If they don't agree, then there's no trust between you and them, and they won't get that feature changed or they can go hire someone else. It's basic business. When you go fix your car and the mechanic tells you your engine is busted and it'll cost a lot, getting him to print you a lot of schematics of the engine won't convince you that he's right. Either you trust him after a conversation or you don't. If you don't, you can go fix your car elsewhere.
I was going to use it in a project, but I heard it starts to suffer from large amounts of dynamic calls and simultaneous users(which I plan.. or should say hope, my project 'suffers' from :) ).
&gt; again, we need to find a proper way to specify what each millestone will be about, otherwise the contract is meaningless. I thought I was clear above that the contract specifies deliverables in clear succinct language based around a list of use cases, features and attached UI mock-ups. The contract doesn't need to attach UML diagrams or other low-level implementation details. I don't think this makes sense. When you order a cake, you want a tasty cake that matches the picture on the menu. You don't request an exact list of ingredients, a recipe and a video of the cook making it.
I'm actually not much of a fan of `open_basedir` as it's [a performance loss](https://bugs.php.net/bug.php?id=53263). Frankly if your php runner permissions are set up correctly you can do without it.
No, it's like ordering a second cake. Remember, milestone 2 is not negotiated yet. In any case, I don't work waterfall style. I've tried it, and the results are mediocre to inferior. Look at any large software project disaster of the last few decades, especially those built for government institutions. If you want to do things waterfall style, I wish you all the best luck, as you'll need it.
UML doesn't really have anything to do with the technologies you're using. You might want to look at using Sequence Diagrams to communicate the flow: https://en.wikipedia.org/wiki/Sequence_diagram 
I don't know where you draw the line of "enterprise software" but we communicate backend projects in terms of the APIs they implement or consume. The way many small companies like Google, Netflix, Uber and Amazon do. And GUI clients are communicated with GUI mockups. 
and the client can argue to not pay the first cake and not order a second one and lawyers get involved. And here in México, the courts will side with the client because indeed the brand of chocolate was not agreed and the best we can get is to get the contract nullified so no one pays and we lost the money invested in development.
I don't understand how to be more clear: - Milestone 1 is negotiated, contract is signed, both sides are under obligation - Milestone 1 is delivered as contract says, and client pays as contract says. The change happens after Milestone 1, and for Milestone 2, not during Milestone 1. And there would be no strong pressure from the client to make changes *during* Milestone 1, because milestones are kept short, both for your sake, and the client's sake. Is this hard to figure out? The situation you're talking about can't happen in this setup. Clients not paying does happen, unfortunately, but then lawyers would *definitely* not side with a client who got precisely what he signed he wants. Sometimes a milestone can be renegotiated, and both sides willing the contract may be adjusted midflight, but this should be rare.
And so you think: if I deliver classes that match a UML diagram, the clients have no way but be happy? Ok, good luck with that.
Yes. A Sequence Diagram is a UML diagram. But just because you use "a" UML diagram doesn't mean you're "doing" UML. I.e. every cow is an animal but not every animal is a cow. If you want to do UML, start here: https://www.amazon.com/UML-Distilled-Standard-Modeling-Language/dp/0321193687 
Function call overhead is quite large in PHP and in array_map it has to call a function on every iteration. If you compared it to this: $result = array(); $fn = function($number) { return $number * 10; }; foreach ($numbers as $number) $result[] = $fn($number); } You'll find quite different results. But of course in this case there is no reason to write it like that. But if the thing you are doing in the foreach loop *is* a function call: foreach ($numbers as $number) $result[] = sqrt($number); } Then it is a more apt comparison. 
its always a war between those groups. Last time it happened hundreds of keyboards were slaughtered. 
is there a listing of the major changes/additions in 7.1? I can only find the granular patch notes.
I'm probably just going to get it and make it play fight with my Laravel elePHPant. I'm super mature.
What exactly is wrong with it?
Why not generalize the function and turn the year into another argument to pass into the function?
That code is pretty naïve and amateurish. I want to say that if the person codes that way AND is immature/close-minded, there is no hope for you. They'll be very defensive about it, you won't change their mind and you'll become a threat to them (they'll see you as an enemy). That being said, if you guys have a decent technical director, you should definitely explain to him (or her) what you've seen while also talking about the difficulty of approaching the person about it yourself. Code reviews or things of the like certainly are mechanisms that allow for criticism of code quality without seeming like you're trying to make someone look bad. Same goes for code style conventions. Edit: Beware that this might create a bad environment for you if it is not handled with care by your TD. Office politics really suck. In the end you always have to choose your fights. If you feel like this (bad) code is more than just code smell and does put your codebase in danger, maybe its worth a fight. If not, live to fight another day friend.
You're basically asking the same question as OP here. He didn't write this code.
Decline the pull request 
I don't think people should downvote you for not understanding what's wrong with it. That's pretty rude.
 public function scopeQueryByYear($query, $year) This would be a more appropriate method name, if you ask me.
I'd refactor the code and make sure it passed all the tests and then never mention it until it was brought up. Not sure if you can get away with that 
I'd fix it on another branch and put up a PR. Let the quality speak for itself. 
scopeAwardYear($query, $year) or, depending on your style guide, scope_award_year($query, $year)
&gt; /r/phpstorm Just tumbleweeds over there
Besides. This is the response the OP would dream of getting from his colleague. There is nothing worse than someone who won't take feedback/criticism/explanations or advice seriously. You should always ask if you don't understand. You should always explain as best you can, to someone who wants to understand. 
We use SQLite to state complex queries on CSV files. Load the files into SQLite in memory and then start querying. Works wonders!
I really don't like this. The point of a query builder is to build queries. Usually in pieces based on various criteria. You've taken all the flexibility away by forcing us to call the methods *in order* and then you've thrown in useless methods like `where()`. You're also quite light on details. `-&gt;equals('id', 1)`. What is the thing on the right hand side? Is it always a value? What if I want to compare against another column?
No, SQLite supports concurrency.
I like to name my scopes relative to their query they perform. personal preference :P
[removed]
You don't know who he is. But he does. And this is reddit FFS. Think for half a second how you would feel if came across someone posting your very, very smelliest code on Reddit, with no context or explanation, and talking shit about you behind your back. I'm not ignoring the possibility that the co-worker is genuinely terrible at coding and a mean, grating, smelly dimwit, to boot. But he could have just made a text post asking for advice. He didn't here. [Or here, for that matter](https://i.redd.it/5jr5w6cag2sx.png). Sorry. I'd not hire him. I wouldn't hire Linus Torvalds for the same reason. More happy coding. Less angry drama.
Thanks for the feedback. The way it works at the moment was for building up a query string programmatically. I do see see your point about removing superfluous methods and not forcing a strict order, and I might look at reworking it to solve that problem. The documentation is a little rushed admittedly, the left and right can be either values or any valid SQL string.
What?! You don't do validation in the query, you do validation in the middleware or controller (if your lazy). And PDO::MySQL is very secure, with using the Eloquent wrapper. Im not sure you understand the context of the code?
No, its not bad practice or a security risk. its just a move to pretty URL's Tell me, Do you prefer reddit.com/user/$username/ or would you rather reddit.com/user.php?user=$username
Thanks! That shouldn't be so hard to implement - and I think we could possible do it without breaking BC. I did consider it before when writing unit tests but then realised I could just grab the output from STDOUT. I didn't consider the case of virtual terminals. Do you mean a bit like how symfony/console can use different streams for output? Maybe you could create an issue and we can look in to it from there?
I would recommend the [PHPCoord](https://github.com/dvdoug/PHPCoord) package for handling this. The formula for doing this (or at least one of them) is the Haversine formula. As an aside, there's a trick you can use for getting "all points within a radius" from a database: * Use the Haversine formula to calculate the extreme points of the bounding area (the highest and lowest lat/lng values, basically creating a box which will include "corners" outside the desired area) * Select all points within this area from the database * You can now run Haversine in your PHP code to filter those that lie outside the actual radius. This removes the need for complex SQL (I believe it actually requires creating SQL functions to get MySQL to run Haversine fully in the database), while limiting the number of points you need to compare.
Very cool! Definitely gonna give it a try later and throw something together for shits and giggles.
Yes they **do have a point** and I agree that the disclosure should have been done in the correct manner but when you have key project figures talking so harshly towards someone who raised a valid and serious flaw in public I think it speaks volumes about the project. *"Thank you for highlighting this serious flaw to us, please in future reports can use the official channels documented in the readme file."* **"Your profile suggests that you'd know better"** There's the difference 
Nice. You throw out the frustrated and keep the blinkered shit coders because they kept their head down. I can see where that project is headed...
Welcome to Reddit. 
Wait a second. You want to spend £35,000 of donated money making plush elephants? And you're selling this as charitable? This world has [children sleeping in sewers](https://www.google.ro/search?site=imghp&amp;tbm=isch&amp;source=hp&amp;biw=1916&amp;bih=956&amp;q=aurolaci), but that's what you want to spend charity money on? Perhaps £35.000 worth of computers and PHP books donated to a school in the middle of nowhere would be a better way to improve the world we live in? You demagogues could make an actual impact in someone's life.
Depending on the use case, you may need to consider the Earth's circumference, too, which varies. It is larger at equator and smaller at the poles. Altitude may also play a role. A hands-on example are the pylons in the Great Belt Bridge (Storebæltsbroen) in Denmark, which aren't that far apart ([1.624 metres](https://www.storebaelt.dk/omstorebaelt/fakta)), but - because of the curvature of the Earth and their height - they are 8 centimetres futher apart at the top compared to their distance at sea level.
If... IF what OP says is true, I'd be inclined to sit down with the blinkered shit coder, who isn't here to defend himself remember, and tell him to stop being a selfish idiot, learn what compromise means, and start upping his goddamned game. But the bigger problem in my opinion is that OP didn't just cross the line, he vaulted over it and spiked the landing -- TWICE. Not on my team. I'm not talking about 'loyalty'. I'm talking about basic human civility and decency. Again: what would you do and how would you feel if someone you worked with posted some of your smelliest code from the last 3 years on Reddit with a healthy side of smack-talk for good measure. All that said, my larger point is that OP should seek out a place of greatest happiness. If he keeps running into brick walls and hissy fits with his current co-workers or he's too afraid to take his problems up a level, he should find a job elsewhere that can tap into his energy and build something better. Life is too short to spend years working in a place you hate. But whatever. I'm a shit manager I guess. My bad.
Accidentally a word?
TL;DR anyone?
It's not passive aggressive until he forks it and starts deploying the fork and only tells the intern 2 years later that none of his code was ever used.
Framework stuff.
Man, why are in full-blown dick mode again. Do you ever run out of dick mode? Do you walk around with pockets and bags full of dick mode in case you run out? Is there a kind, gentle /u/colshrapnel deep in there crying to get out?
&gt; The documentation is a little rushed admittedly, the left and right can be either values or any valid SQL string. This is troublesome because you know that people would be passing strings on right, thinking their values are encoded safely, while they wouldn't be. Query builders should be optimized for common sense everyday activities and should be as safe as possible. If you want to include raw SQL, be explicit, a few possible approaches: -&gt;raw('foo = 2') -&gt;equals('foo', new RawExpr('NOW')) Where "raw" can be replaced with whatever terminology you like, ex. "unsafe", or "sql" etc.
Imagine if he's racist too. public function skinColorIfBornInNigeriaNineteenNinetyFiveAndMovedToNorwayTwoThousandSix(){ return '#c6b79f'; }
Why does the QueryBuilder need an implementation specific Adapter? Query builders should never need to know what your DBAL implementation is. They should simply build queries. Look at Aura.SqlQuery as an example. As others have said, this doesn't seem to offer anything not already available from any existing query builders, or even really offer any advantages over writing raw SQL The lack of use of server-side prepared queries, and worse still, lack of proper escaping is terrible and inexcusable in this day and age. (I down-voted this post for this reason - nobody should be using this in production) Missing features from what I can see (mostly based on glancing at tests): * server-side prepared queries - let the DB handle escaping where possible! It (should) know everything that needs to be escaped (which may be version specific) * table / field aliases * subqueries * support for functions on either side of comparisons * support for functions / operations (eg. field = field + 1) in assignments * support for assigning one field to the value of another field * support for upserts (on duplicate key update / ignore) * escaping of field / table names (while technically this shouldn't really be in the query builder, the fact that it's not possible in the DB layer using prepared queries makes it a desirable feature)
If you're willing to write an infinite number of functions, you don't have to update them daily. public function ageIfUserIsBornOnSeptemberFirstNineteenNinetyFiveAndItsCurrentlyTwoThousandSixteenAndIsNotYetSeptemberFirst() { return 20; } public function ageIfUserIsBornOnSeptemberFirstNineteenNinetyFiveAndItsCurrentlyTwoThousandSixteenAndIsSeptemberFirstOrLaterInTheYear() { return 21; } Bonus tip: Write a script to emit all this code, to save on typing.
ChromeOS runs on linux, offers tons of apps. short search on google reveals that web-servers are a part of those apps. short search and this is what I found: [ultimate guide for Web Development on Chromebook](https://medium.com/@martinmalinda/ultimate-guide-for-web-development-on-chromebook-part-1-crouton-2ec2e6bb2a2d#.yk9vy3trm)
Fucking what. buahaah 
Holy that architecture
That's an odd name. I'd have called it: chazzwazzers($query, $year)
Great explanation, right on point. &gt; cargo cult I'm using this!
What's the advantage of calling those on the object itself?
There's lots of decent-ish web IDEs around like Cloud9 and CodeAnywhere which are great for what they are (if a little sluggish and no good on a slow connection)
Oh jesus o_o
My thoughts are "sigh, Laravel".
Are you just fucking high or stupid, I'm finding it hard to tell.
Maybe something like this? scopeAndGroupQueryByYear() No need to not have descriptive names with modern IDEs.
I think you meant scopeQueryByYearAndGroupByYear() I think you know where I'm going with this. Why not scopeQueryWhereYearByYear() ? Also, what happens when you have 'group_by' column in your database table?
What the fuck is this bullshit? A virtue-signalling plush dust collector? &gt; we all benefit from a Diverse Community and from Inclusivity at Conferences. But Diversity means more than just acknowledging and/or tolerating differences. Simply tolerating those differences doesn’t make a workplace or Community where people feel comfortable expressing different views. Simply silencing intolerance creates its own tensions that are counter to what you’re trying to achieve. Diversity is the exploration of our differences in a safe, positive, and nurturing environment. Yeah, right.
I'd say that code like that will need updating every year and over time as you get more projects under your belt you'll be stuck at Christmas every year updating them all. It's better to spend a little time right now getting a list of the relevant years based on the current date to save your future self from that drudgery.
Sad answer: The bad method's been in core for five years. Sad irony: Until September 2015, it wasn't exploitable because the method triggered a fatal error long before processing the data.
This is why I don't use wordpress, or why I create my own plugins when I absolutely HAVE to use it.
Sounds like he's barely a junior dev. OP: Might be time to freshen up the ol'CV/resume and make a choice or give your employer a choice.
There's also a valid explanation in that thread on why they reacted that way. They're tired of people NOT following security guidelines and act as superior to everyone else because they found a security hole, doing 'the bad thing to do' to either generate pressure on them or to ridicule on purpose. I'm not saying it's the correct way to handle it, but I would, too, get really angry at someone exposing super publicly a security flaw in a piece of software that potentially hundreds of thousands (or even more) projects will be affected by. The ' reporter ' should have known better. My 2 cents.
https://www.reddit.com/r/PHP/comments/59tga2/the_phpdiversity_rainbow_elephpant_kickstarter/d9b8afy/
 public function generateRandomNumber() { return 17; }
- Excuse me, I'd like to apply for the data-entry position. - Sure, read `man idiot` to start the application procedure. - But it says... Oh.
I was hung up as a self-taught developer in a similar way. I started working more with javascript which gave me a better understanding of what objects are. After that I spent some time in Java to get a better understanding of how objects are used in an application. The biggest improvement to my structures came from a design patterns book. The book is "Head First" book but I was surprised about how easy it was to follow and apply to modern PHP. Best o
Talk to the lead or bubble it up higher. Good devs raise quality issues.
Do not trust user input. DO NOT TRUST USER INPUT. **DO NOT TRUST USER INPUT.** Let this be a reminder that we all need to code as if there's an army of vindictive hackers trying to break everything for funsies. Which there is. ...it's not paranoia when they ARE out to get you, shut up.
Context: /u/mbabker was a Joomla core contributor. (I don't know that he still is. He sounded really unhappy with the culture there on Twitter the other day.)
Jokes aside, it was a case of code being abandoned somewhere during development of a version over 5 years ago living in the code for far too long and an innocent bug fix from a first time contributor making it exploitable. Talk all the shit you want about Joomla's security (hell, I do it too, and I just inherited the lead role on the security team again). But that's really not an example of how Joomla handles security.
I ran into a similar thing. I was using PHP back in the early 2000's - all procedural. I changed jobs and lost touch with it for several years and when I finally came back around everyone had moved on to OOP. I had no concept what objects were and how they were meant to be composed. I kept looking for sources to help me out and landed on "PHP Objects, Patterns and Practice". The first few chapters talk about objects and polymorphism (which may lose you initially - understanding that I think was my first "Ah HA!" moment). Then I came to learn about SOLID. Nettuts, now [tutsplus](https://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074), has some okay write-ups on it. Usually what I would do is make their example work by actually typing the code. Inspect it, and find another application for it - just a simple, does nothing, application of the principle. The next stage for me was obsessing about patterns and solid to the point where I was trying to find where a pattern might fit in my applications, abstracting EVERYTHING, and that slowed me down a bunch. There were times I was "afraid" of typing code because it would just be bad... there HAS to be a pattern for this. Eventually I figured out there were only a couple of patterns I needed for most of what I was doing at the time. Adapter pattern, decorator pattern, and maybe a factory. All of the patterns have their place, but just don't obsess over them like I did. Once you get comfortable with OOP - not good, just comfortable - maybe dive into a framework. The two big ones you'll see a lot are Symfony and Laravel. I'm only recommending this because they will show you application structure and also they are terrific with lots of intuitive APIs that really speed up production. Also this will give you chance to learn about composer.
I appreciate the link to SOLID/tutsplus. That is a new one for me so I'll check it out. I also appreciate your advice on waiting to dive into a framework until I am more comfortable with OOP. I completely agree, and it's why I still haven't touched Laravel or Symfony even though I have been concentrating solely on PHP for a while now. I do have some experience with composer to use things like guzzle, but not much else. Thanks again. SOLID seems like a good concept.
This should be higher. The scope functions cannot take other arguments. There is some magic involved. Sometimes that's pretty OK, not here though. 
Well the calling object method way is more elegant than calling a function by passing an object, it means the object has responsibility of getting the class name and hashcode of itself. From a design point of view, its more correct and reasonable. It is also consistent with the other OO languages such as Java, C#, Swift, etc. 
We were learning PHP at school and our school decided to change their website to Joomla. We incidently started learning about CMS and stuff. I tried the default password. It worked. I was nice enough to change it and contact the webmasters (when webmaster was a thing)
&gt;You should look at Silex/Slim. He's using Lumen, which pretty much has the same performance as Slim.
 static public function createQuery() { return new \Query(); } public function scopeByYear($year) { return self::createQuery()-&gt;where('award_year', $year); }
I like to stick ```// TODO: ``` comments in my code where ever I need them so that PHPStorm screams at me that I have TODO something somewhere in my code that I may or may not have forgotten about. Example, I have TODO updating logic here: https://github.com/JABirchall/NimdaTS3/blob/master/app/TeamSpeak3Bot.php#L312-L315 every day I'm reminded of it, and every day I leave it because... (I had a plan to have some auto-updating handling for the database and plugins but...) I have yet to release an update which requires the auto-update feature to work, Until then I guess I'll procrastinate some more. 
15+ years of programming experience. I written in C (C++, Objective C, etc), Perl, PHP, Python, Javascript, LISP, etc.. All programming languages are pretty much the same. Async vs Sync, Static Type vs Dynamic Type, Curl Brackets vs Tab spaces, etc. Making programming fun and easy: - Knowing and how to use design patterns will help you in any programming language. - Working on a project you're passionate about - Do something else beside programming - Stop worrying about how crappy your code
What about a different point of view? Procedural or oop or functional or the famous "all in one spaghetti blob"? They all might have their place and usecases. Maybe you want to chance your focus slightly: Why don't you just try to write code with "test driven developement"? Write a test with phpunit that fails and then do something to get the test passing. For me it was very suprising that I started to write a far more clean and organized code. Because if you want to test something you have to program in a very modular and distinct way. You will struggle with dependency problems and class loading and finding the solutions might give you the kick I needded back then, like you seem to do. ;)
I'm not sure, I think it adds a little something : )
The only argument you can make to the CEO is the time / productivity cost, but that opens up a can of worms. What's more is this particular instance is right on the verge of still being maintainable, even though it's completely wrong. In reality, it would only take someone about 5 minutes to add new methods for new years, which to this scrub of a developer and the CEO, might not seem like a big deal. Unfortunately, it makes YOU look like the anal/picky one *even though you're 100% correct* Sucky position to be in. [It's quite possible your colleague works for the CIA](http://www.businessinsider.com/oss-manual-sabotage-productivity-2015-11).
This is... a little strange. How about: &lt;?= join(" ", ["how", "you", "doin'"]) ?&gt;
There are some dependency injection euphemisms all over the place here... Edit: i feel like they wont help you here, however. 
Perhaps you're right, but HTTP is, for a lack of better word, most natural way for PHP to transfer data. And it makes them easier to test.
Benchmarks shows that Lumen is even faster than Silex and Slim. But it's still needed to reinstantiate apps on every request. It would be cool if PHP had something like bottle.py.
Agreed, these are tried and true design patterns that don't really age. I'm sure there's conflict on where they are useful or not. 
Write your code up the way you can. When you have it written up in a procedural manner, try to split some off into other classes / objects and think about where that object can be reused. For example, say you get a one-page / one-class blackjack app written up. Think about what's in there that can map to a real world scenario --like, think of what's in there that a "dealer" would do. A dealer shuffles, a dealer deals. Then make a dealer class and call the shuffle and deal functions from an object. Then think about maybe a "bank" class. A bank collects money from the player, gives money to the player. Make a bank class that you call those functions from. (This isn't a perfect casino, it's just practice mapping real-world things into classes / objects and reusing those objects.) If you get a main app class that calls functions from other classes, your code will be easier to read and maintain. After that, maybe look up MVC for PHP and do some of those tutorials. 
How about using cronjobs? I don't really see a valid use-case for microservices here...
Well, any such tasks, it'd be a very bad idea to run them in your webserver's process, that's for sure. So good thinking about that. So you'll have one process outside the webserver. But I'm not sure you'd need more than one. Depends on the specifics of your projects. If you do a lot of async work, maybe I'd actually tell you to check out Go and Node.JS, because they're better suited for this. Effortless concurrency and asynchronous programming, especially with some tooling like TypeScript in the case of Node.JS. If you insist on doing async work in PHP, maybe check React.PHP but keep in mind it seems a bit under-cooked (as in features, otherwise, it works fine). But I'd probably have one Node.JS process doing all those heavy/async tasks, and do the "front end" as in controllers and page templates in PHP in the webserver. At least based on what I know so far about your project.
~~So this is an entire article nagging the author of "Design Patterns — PHP: The Right Way" for not making his Singleton example work right with inheritance, due to a bug in their code (for this use case).~~ ~~Then the article author "corrects" the problem, by introducing, unknowingly, another bug.~~ **EDIT:** God damn it :P BTW "Config" and "Database" are awful examples of a situation where you'll use a singleton. Maybe you could find a good example, if the goal is to be educational to beginners? And yes, there are a few good examples of using a Singleton, although they're so obscure, a beginner would never need them.
&gt;she hasn't replied. Probably because: &gt;I'm at a PHP convention all day and night. And your code pickup line is quite cheesy, btw. Maybe it's just me, but communicating in code or pseudocode like that is kinda like the programming equivalent of /r/fellowkids. Should have asked her if there were any good speakers on the conference, if you were genuinely interested. Now tell her you're sorry for the last message and that you did not follow the PSR.
Commenting is the much better approach in that case. That way we can use it to discuss and educate people. Down-voting is not a disagree-button. I now received "bad karma" in this community for merely participating in a constructive manner, by trying to suggest *one* possible way to solve OPs problem. Instead of a healthy discussion about __call() pros and cons I get buried.. not cool.
Small steps. - Think how would you split your functions in groups, based on what they're responsible for doing for you. - Make them static methods - each group as a class. - Now think what global state do these functions have access to? Try to keep the lines outlined before, no shared state between classes. - Move the global variables to protected class members at the respective classes. This is just the start, it gets interesting when you don't make them static so you can create multiple instances, each with its own configuration and state. But just those humble steps above would get you far. OOP is about splitting a large problem into many smaller, standalone problems, with the simpler, standalone solutions. Then you can use some of those smaller solutions to solve different bigger problems. It's... in a way really not much more than this when you draw the bottom line.
Symfony's biggest competitor.
Great article
It may help to refocus: With OOP you aren't just solving the immediate need, you're also building a fault-resistant toolkit and mental-model for understanding and approaching similar problems. That's why OOP correlates with bigger projects: The classes you create are a way to categorize things and communicate them to other developers... Including that weird ignorant stranger known as "myself after doing other things for six months" -- that guy always needs help.
If there's interest, I'm planning on following up with improved docs + posts for the various libraries docs.hhvm.com uses or that have been split off from it.
The two are so closely linked in this context I don't know why you're trying to split hairs. This is the kind of code someone who doesn't know how to code, would write. Yes, professionals can write shitty code as well, but this is not *just* shitty code, this is straight-up rookie level.
&gt; The two are so closely linked in this context I don't know why you're trying to split hairs. I'm not. I give up. I said, lets agree to disagree and move on. 
Nothing wrong with the inheritance, just change static to self for $instance. class Singleton { private static $instance; public static function getInstance() { if (null === self::$instance) { self::$instance = new static(); } return self::$instance; } protected function __construct() {} protected function __clone() {} protected function __wakeup() {} } class Config extends Singleton { public $config; public function setConfig($json) { $this-&gt;config = json_decode($json); } public function getConfig() { return json_encode($this-&gt;config); } } Config::getInstance()-&gt;setConfig( '{"dsn":"mysql:host=localhost;dbname=test","user":"test","pass":"test"}' ); echo Config::getInstance()-&gt;getConfig(); -- $ php test.php {"dsn":"mysql:host=localhost;dbname=test","user":"test","pass":"test"} Edit: Not sure why the downvote. The issue the article discusses has nothing to do with the Singleton pattern, since it works, as I have demonstrated. The issue is that the original author apparently did not know the difference between `self::$` and `static::$` (as well as not testing code before publishing). I suspect the original author most likely tested the code, then noticed he had `public` and thought "Let's go ahead and change that to private, for encapsulation." 
And adding singleton behavior through class inheritance is just mind warping wrong anyway...
See OPs comment. (Hint: He was not asking for a coding solution.)
`self::$instance` is where the variable is stored. The type of the class is determined by `new static()`. The only thing with using the pattern in this way is that you can only have one instance among all things that extends Singleton. An array will be necessary for an instance of multiple classes. 
Hack is a fine language, but it lost the fight to php7. If only they had ide support back when hhvm had the lead in performance. At this point ,even if you do use hhvm, using hack features is a liability because it locks you to it. 
Also as a rule of thumb: only do microservices if you absolutely have good reasons for it. The cost of microservices is fairly high, not just in terms of latency due to multiple requests and PHP overhead, but they increase complexity tremendously: you now need to run each of those services, get them deployed, monitored. Most likely you want high availability. Now you need to coordinate releases between the different services. How do you handle those dependencies? Developers need to have all the services running and keep them functional. Changes often involve multiple services, so it's multiple commits, multiple PRs, etc. Without knowing much more about your particular use case, I would recommend what other have before: write your application in whichever framework you prefer, and then add workers (with a queue) that handle the asynchronous tasks. That way you can still separate everything but don't have to pay the price upfront. If you structure your code well, it should not be too hard to rip out specific pieces as you have the need to run them as microservices. 
PHP7 catches up on performance, but doesn't really compete on language features; async, the type checker, and co/contra-variant parameter and return types do a huge difference in practice. PHP7 is a good competitor for HHVM, but it definitely isn't for Hack.
Haha, yeah why not Symfony.
This is pretty much what everyone else said but it sounds like you don't need microservices or at least should do a bit more research before diving-in. The major one is that you are moving from a single-thread share-nothing architecture to an distributed one and distributed computing is not easy. That transaction you have, just became a distributed transaction. That bug, just became a cascading failure taking out all your services. That slow aws instance, just slowed all your upstream services to a crawl. That timeout you set, was way too long everything has failed... There are many other challenges such a monitoring, tracing and logging to name but a few :) If you are set on using microservices though, you also have the choice of using any other language for each service, so if you have performance issues with PHP, maybe there is another stack that would perform better for certain services. Some microservice related projects to checkout: https://github.com/Netflix/Hystrix https://github.com/odesk/phystrix https://linkerd.io/ (https://twitter.github.io/finagle/) https://github.com/Netflix/ribbon https://github.com/Netflix/eureka Information: http://martinfowler.com/microservices/ https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing 
My project works well in server one. I bought a new server recently. The same project with all the same files is working only in parts in server two and works well in server one. Project have mysql codes(not mysqli) and i think those queries are the ones which is creating the problem. Is there anything i should do to the MYSQL database settings to make mysql queries work? i'm using godaddy for both servers.
Page View Path: templates Css File Path: pubic/source/styles Image File Path: public/source/images JavaScript Path: public/source/scripts Model Path: user/Entities Controller View Path: templates (all my views/templates are in templates) Controller Path: user/Controllers Some Framework Module Path: user/Auth/UserProvider.php (example, but basically all my project specific PHP is in user)
 5. Use common sense. 6. Keep in mind: "One million flies can't be wrong. Eat shit!" 
Please see my [comment](https://www.reddit.com/r/PHP/comments/59xbek/how_to_screw_up_singletons_in_php_the_danger_of/d9chl0x/) explaining the issue with multiple classes extending it. My purpose was only to show that it's still possible to extend the Singleton class without making the variable public. 
Couldn't you add python's multiprocessing library to that list?
You see, you are doing many assumptions without actually seeing the full scope yourself. Do we know this is built with a controller on top of it? Do we know this uses PDO? Might be, i dont know. Just comparing two code snippets where one is "an improvement" yet introducing potentially security issues or bugs.
It is just how it works actually. Maybe I'm not a really good developer but I'm not an idiot also.
I would say "no". About a quarter of the PRs I get are from first time githubbers who only joined to fix an issue they found, before crawling back into the woodwork.
Inheritance is the wrong tool for this job. Singletons are a pattern used in creating a class. They're a common feature of your classes, not a common ancestor. Should all my classes with getters and setters inhereit from GetterSetter, despite being completely unrelated in function? Should all my classes with a __toString method inherit from Stringable? Even ignoring the confused class hierarchy this creates, it messes up the responsibilities. Why should your Singleton implementation have to keep track of every class that uses it? Those uses should be completely separate. This isn't a job for inheritance, it's a job for traits. Traits are compiler-assisted copy-and-paste, which let you reuse code between classes without a common ancestor. Importantly here, you would end up with a static variable to hold the instance that belongs to the class which is a singleton, rather than hiding in the shared implementation of the singleton pattern.
[removed]
The null coalesce operator on its own is also enough reason for me. I hate a nested mess of null checking.
So ADR = Model-View-Adapter where Responder is adapter and Action is application-level service? Oh no... Action knows something about HTTP so I can't use it from CLI of MQ for example... And I should wrap domain with another layer.... or make "http" requests from within different interfaces... Or what should I do with different API versions for example? different actions for different versions? Add some mappings in front-controller/middleware? I once tried ActionBundle and... it doesn't brings any profit if your controller's actions are 2-3 lines of code each. But the idea of reusable responders is pretty interesting. But if action knows something about responder, then we just move code to other place but doesn't reduce coupling. p.s. I working only with http API so maybe for web this would work.
That was the advice. Get it running on 5.4 minimum first (without log files full of warnings), then the move to 7 should be easy. There are a few gotchas, but they can be highlighted for you by the linter and static analysis tools.
Why did we put up without this for a decade and a half?
Because PHP developers have no self respect, of course :P
Agreed. php 7 loads client sites about 50% faster (by eye, not measured). WHM updates allow multiple versions of php to be run on the VPS and you can switch back and forth easily, so it's easy to spot the difference.
&gt; And now I see that code is removed in master. You link to a fork and not the main repo. Why the fuck? [In the main repository the change is there.](https://github.com/joomla/joomla-cms/blob/staging/components/com_users/controllers/registration.php#L137) 
No: at the moment, the type checker can't fully parse PHP. There's ongoing work to change that (referred to as "full fidelity parser") - once that's done, this might be practical.
on another code I reviewed, there are some one who actually write this: .... $user_id = $this-&gt;user['id']; $user_author = $_SESSION['user_id']; ... // some query to model ... $user_id = $this-&gt;model-&gt;get_user_by_id($user_id); $user_id = $user_id['id']; well, that was amusing...
$_POST is an empty array, not null, when there is no POST request. So you can check whether $_POST === array()
It looks like their use case is testing if they're in a post operation, rather than whether nothing has been submitted. So the test for this context, assuming they don't care about a post method with no params, is: if ($_POST) 
Or empty($_POST)
Checking on empty(array()) will do the work. More elegant solution is working with NULL objects. This is slightly different than null value. It is easier to explain with an example. class Post { public function hasData() { return filter_input_array(INPUT_POST); } public function getClientId() { return filter_input(INPUT_POST, 'client_id', FILTER_VALIDATE_INT); } } Edit: hasData() was hasPost()
You should rather do `$_SERVER['REQUEST_METHOD'] === 'POST'` to check if a request is using the POST method.
I have some FuelPHP tasks that take up to 60 minutes to finish which I'd like to speed up using threading. Beside that it seems to be a good way so speed things up in general.
In what way would you speed them up? Are the problems parallelizable? Can you do the work in separate processes instead (easier)? Threads are not a solution to speed up things "in general" (there is no such solution), so concrete use cases are needed.
It's indeed for parallelizing. Right now I'm already working with different processes, which I'd like to get rid of. Beside that learning new things is always a good idea. 
If you're already parallelizing it into processes, threads won't probably help much (though of course I don't know the actual details). But I agree, learning is good.
Well, it won't get better in terms of speed, but in terms of code. This way I can ditch the system() calls or seperate calls of the same files via cron. It looks like it isn't a trivial process anyway, since there seem so less ressources about the way to enable threading + zts in the latest version. I'll keep trying to compile it on my own and use the special version just for cli tasks I think.
As the story goes, being the Joomla Security Team Lead is the fastest route to burn-out. As the JST Lead, you have: * Abandonware code to wrestle with, AND * A community with some extremely entitled and incompetent members who rally against improvements, and behave like shits to the person who's trying to stop their site from being hacked You couldn't pay me enough to take that job. I think /u/mbabker is severely underrated. When I posted [this chart](https://paragonie.com/project/airship), he was quick to: 1. Point out that Joomla actually didn't deserve a checkmark that I had given it, erroneously, and 2. Build a new feature to make the next version of Joomla actually deserve the checkmark I deducted. That takes a degree of character that I doubt many in the community have had the (unfortunate) opportunity to express. He deserves a degree of respect and, more to the point, deserves to be *at least a little pissed off* at implied accusations after the past week of dredging through the Joomla sewers while being spat on. Yes, it would be *better* in the long run if he chose a less hostile form of communication, but how many people could have dealt with all the BS he's dealt with and still kept their cool? Demanding empathy here would be an ironic statement, for in effect you would not practicing it.
The author is a member of a project team dedicated to informing users of security issues with extensions. And is publishing content intended to question the integrity of the project's development team. That is why I am so frustrated with this author. There was no lapse in quality control with this patch. Anyone familiar with the Joomla code base could very easily read that patch, realize "oh shit, this really is broken", and accept it at face value. Nobody stopped to ask "wait a minute, where's this actually used?", so if that's an indicator of a lapse in quality control, then so be it. Had anyone done that when the pull request was opened, it would have resulted in a different outcome most assuredly. Had the pull request been submitted for truly malicious purposes, I doubt anyone would have waited a year to exploit it. Based on our team's data, there were no known exploits of this issue until this release was published.
Huh, that's interesting. How much of PHP's syntax is forbidden in Hack? I didn't realise it excluded enough that that would be a problem.
Not trying to bash the ADR pattern here, but why does the solution to a fat controller seem to be the ADR pattern instead of just making the controller slim? Couldn't you do the exact same with a traditional MVC pattern? maybe u/pmjones can give his opinion on this?
This one post on its own hasn't been a major issue, but as Scott's eluded too, let's just say I haven't had a very good week. I've personally had to respond to individuals on three different Joomla project teams questioning the information our security team has put out, so I'm honestly not in a great outward communication mood and it's showing.
Only the bad ones. Which accentuates the problem. 
Some points to consider: &gt; ADR = Model-View-Adapter where Responder is adapter and Action is application-level service? Not exactly; in fact, I'm not sure that MVA maps directly to ADR at all. Action is definitely not an application-level service; however, the Domain element might well be an entry point to an Application Service or Service Layer exposed by the underlying domain. &gt; if action knows something about responder, then we just move code to other place but doesn't reduce coupling. ADR is a user-interface pattern, where the user-interface is the HTTP request and response. So, it is intentional that the Action (and the Responder) know something about HTTP. 
I don't mind critiques. :-) &gt; why does the solution to a fat controller seem to be the ADR pattern instead of just making the controller slim? ADR doesn't solve "fat controllers" per se; it solves a not-as-good separation of concerns in (what we think of as) server-side MVC. One way it does this is by recognizing that response-related work is its own concern, and puts that work in the Responder. "Slim controllers" (indeed, trivial controller actions) become a byproduct of then pushing domain-related logic into the Domain (where it belongs) once all response-related work is in the Responder. &gt; Couldn't you do the exact same with a traditional MVC pattern? Which "traditional MVC pattern" would that be -- the one from Smalltalk-80, or the one from Sun's Model 2? (Sorry could not resist ;-) More seriously, you *could* do it with what-we-think-of-as-server-side-MVC, but then you'd be adhering to same separation of concerns as in ADR -- at which point you might as well call it ADR.
I wrote this, but I'm a ruby developer by trade. I had to cobble together a few SO answers to figure out how to do this, so put it in to a blog post. Happy to get any feedback you all have! :)
Typical tragic blog-spam garbage. I don't have all day to pull it apart but just straight from the top: &gt;generators are functions False, generators are iterators. &gt; that provide a simple way to loop through data without the need to build an array in memory False, that's just one use case, not a suitable general definition of a generator. &gt;Still a bit confused? You should be because you're reading a whole load of horseshit.
I've reviewed your review and am awarding you 5/5
Well, when the language itself uses said terminology incorrectly, it's like throwing stones in a glass house. Most functions in PHP are not functions, they're procedures. And generators are iterator constructors. And arrays are ordered maps, not arrays. And so on. To be pedantic means to use terms completely different than what you see in the language itself, and then the only audience you're left with that would be able to understand what the hell you're talking about, is people who don't need your tutorial for beginners to start with.
You're not just wrong, you're also being a complete jerk about it. I don't really understand this hyper aggressive response. Where does this come from? Do you think this is an acceptable way to communicate with people? Would you respond similarly if the article came from someone you see on a daily basis? I can relate to being strongly inclined to point out errors after reading an article, but try to be a bit more civil. I'd like to think that you're just having a bad day, but a quick look at your comment history tells me that you're just a very angry person. I hope you're ok.
If you have to build a collection of 10K items and process each of them, it might be better to build them and process them one by one, rather than building a 10K items array and then iterate over it to process them. The first approach has a much smaller memory footprint.
jerk
True. It was nice that this article got my attention and i noticed that there generators after php 5.5... not in my legacy code i still working with :-) But I actually understood what is generator after php.net and article at sitepoint.
I have some experience with it but not with large amounts of data like this..
I was not 100% sure about INNER JOIN or an array. That is why I asked. Thank you very much!
Well, I asked if opcache was enabled. He said yes. Do you mean that he should allow more than the 4 default worker processes of nginx?
I would have something similar to **Match** (match id, match_data) **Player** (player_id, player_name) **MatchData** (md_id, match_id, player_id, key, value) Then you can e.g get average kills per game by selecting all matchdata where player_id = the id for every match
I recommend Mint. I have been using it now since version 17 and it "just works". Before Mint I was on Kubuntu, and overall it was OK, but Mint has been way more stable. I found Ubuntu being stable and good too, but I never liked the Unity change too much so I went to Kubuntu-&gt;Mint. 
You're looking for `@var`: https://phpdoc.org/docs/latest/references/phpdoc/tags/var.html `/** @var Translator $t */`
 /** @var Translator $t */ $t = include("data/config/translation.php"); But please... no. Why would you do it in that way? PHP is not node. That code structure would be at PHP 3 level, disrespecting most ideas we had about OOP, DI and IOC. There is not even a reason why you should wrap the $translator into a closure, just because they are there. edit: Ah you wanted it to have it in the include... I dont think that PHPdoc does support that, as return values from files are not supported. You could also remove the whole closure, just include the file and have a $t var at root level and annotate that in the included file, no need for that closure. 
Thanks for your feedback. :) I am just playing with ideas here. I do use all this "up to date stuff" at work for years now but I wonder if there are other ways of doing things. Thinking about your advice: If I define a var in index.php and then set it inside the included file I would get auto completion in phpstorm but I would also create a locked bond. The index.php can no longer decide where to put the instance - the included file decides it. (I wonder if there is a way to use an include and submit some kind of parameters by reference so you can place your instance on that pointer... ^^) 
Is using an iterator the same benefit as using a generator, or would combining them in some way be useful?
Tip: When debugging DateTime values, always use the format string "c" - this shows the date and time with timezone information. You can also use DateTime objects to change the timezone of any value. For example: ( https://3v4l.org/cOWA2 ) $dt = DateTime::createFromFormat('U', $timestamp); $dt-&gt;setTimeZone(new \DateTimeZone("America/New_York")); Sidenote: DateTime objects created with a timestamp use UTC as the timezone by default, regardless of the global default 
Depends on your hardware and preferences. If you love traditional desktop panel, use Linux Mint. If you would want some unique desktop experience, use Ubuntu. If your hardware not decent enough, use Xubuntu or Linux Mint XFCE. I'm using Ubuntu.
I have already recommended a few students with university email addresses to make use of this offer last year. Thanks for the reminder, will promote again on our next meet up.
Singletons have valid use cases... but just not in php ;)
I realise this isn't a php specific question but what's everyone using to handle image uploads to s3? I'm basically looking for a super user friendly way to add images to an object. I'm currently using dropzone.js as it's fairly straight forward but wondered if there were better alternatives. 
Also: https://education.github.com/pack Curated list: https://github.com/pokemonmegaman/awesome-students
Do you work on an OpenSource project? If so, they will give you a license also.
They're very related concepts, and certainly you can write Iterators to achieve most of the benefits Generators give, but the syntax for generators and their conceptual model can be pretty straightforward and simple: A quick example (that uses recursion, which might not be a great idea in PHP): https://3v4l.org/ZVD8t It's trivial to make a similar iterator that generates this sequence, but before anonymous classes it would be hard to do it inline neatly.
[removed]
When I say aesthetics, I mean in the context that a foreach loop that is a built in construct is not hard to read. If anything, the foreign construct is less recognizable to the developer not familiar with the library. The context still needs to be deciphered. I generally gravitate to "raw code" because it does tend to be faster and generally more readable for PHP developers.
The article is technically correct on that point while still being wrong in practice when you're processing large datasets. The examples here are all isolated - no interaction outside of the PHP script itself. That's not useful because most of the time you're doing something with the results of the data processing function. Any gains you'd get performance-wise from using a generator are nullified a few times over if your results need to be saved into a database, for example. You'll bottleneck on a SQL database pretty quick if you put an insert query inside a loop and you've got anything over 100k lines to process out of a CSV. Generators are a good practice to keep your memory usage down in general, but if you're working with big datasets, you've probably got other concerns - like getting your results in a minute or two instead of an hour, and not completely hosing your database in the process. So batch processing it is, and you just have to keep a handle on how much memory each batch is taking up.
&gt;I would like to tell this person to fuck off. OK, but are you actually going to, or is that just something you'd like?
Give it a rest. The 7 previous post submissions you've made on Reddit have all being making fun at your co-workers work, it's becoming tiresome. http://imgur.com/a/r2rdJ If I was a potentional future employer and I saw your account history here, that would certainly make me disregard your application.
The desktop, but it just a matter of preferences. Linux Mint is still using "traditional" panel desktop, which is bottom panel with start menu, taskbar, notification bar. [Like this](https://youtu.be/NSKzbLfgVT8) While Ubuntu's desktop is a bit different, with left-side taskbar panel, top panel global menu, and also menubar on window's title (Locally Integrated Menu/LIM), etc. [Like this](https://youtu.be/WHeGDDnL56U)
Not only null, but `isset()`. It really comes into its own there.
SQL queries in the html? Ugh
epic
This stuff is awfully outdated, with numerous security, architectural and design flaws. 
Hahaha top marks @twiggy.. Romans is an incredible Jerk. FACT!!
Thanks, no that wasn't a test! I must have copy-pasted the wrong version when writing out the code examples for the earlier steps. Thanks for the other feedback too :) 
Seems nice. How does this work in terms of creating migrations and models? Seems like you do everything via the admin interface, but when I push that live the site isn't going to have the stuff I created. 
I've needed PHPstorm for developing in such a long time and now I can get it! Thank God
&gt; In most APIs you only need "bulk" operations on reads, not writes. Says who? It really boils down to how much you care about your users and their time. I wouldn't be comfortable knowing that in order to update 10 records, my users would have to click edit and update 10 different times (20 clicks in all) to get their job done. They should be presented with one interface where they can make all of their changes, click a save button _once_, and get on with their lives. That's two clicks, one to enter "edit mode" and one to save their changes. It's 2016, let's raise the damn bar already. And sure, import utilities are great. If a user has to update dozens or even hundreds of records, sure, let them export a spreadsheet, modify their data in Excel, and then import the changes.
&gt; Not exactly; in fact, I'm not sure that MVA maps directly to ADR at all. Digging in your description, indeed. Its much more like MVP (since in your scheme and in MVP there is only one presenter, and MVA considers that there could be a chain of adapter between model (application) and view. &gt; ADR is a user-interface pattern, where the user-interface is the HTTP request and response. Just like any other MV* patterns. And this is great that you describing ADR this in this way (and not as application architecture like many others). What I found interesting... is how ADR corresponding to SRP. For example we have Actions, which acts like GRASP controllers or adapters of http request to application, and Responders, which is just adapter of application state (which is also retrieved by action) to HTTP response. So we have here 2 responsibilities for actions: - converting http request to "domain" (I more like to call it application), just as method call for example; - Retrieving data for responder So if responder will need some additional data in order to fulfill need of developer to make some changes is view, do we also need to update action? Of data could be retrieved directly from responder (which makes view actually active). If responder can't act like this, then we have two reasons to change for action. Am I correct?
Three things: 1. What you're talking about is completely out of scope for a basic tutorial with no dependencies. 2. Depends on the record list containing all information that's editable. It's often not the case (the record list only shows a summary). 3. UI mechanics are not directly related to the API mechanics (as in "clicks" and so on). You can be saving records as users type, with zero clicks, and still have a "submit one at a time" API for making writes.
Ok... BTW, the reason I talk about APIs is probably out of habit. I've not done an admin interface that's "static" (i.e. server side generates HTML) for years, precisely because it's not a great UX. Instead it's JavaScript driven, and interaction with the server happens through APIs. Also the summary view vs. full view problem stands. Editing directly in a multi-record table, i.e. "data-grid" style is nice, but sometimes there's no way to represent and fit all the data that's editable in a data-grid. Or at least not in a comprehensible way. Because if we care about users, we can't just reduce everything to text boxes, check boxes and combo boxes. UI is far richer than this, but it may need more dedicated space. In any case doing a "CRUD" UI the way it's expected in 2016, would certainly make this tutorial at least 5 times longer than it already is, and drag in a dependency on a modern JS UI library (with data-grids and so on), like Ext JS.
&gt; Editing directly in a multi-record table, i.e. "data-grid" style is nice, but sometimes there's no way to represent and fit all the data that's editable in a data-grid. Or at least not in a comprehensible way. Because if we care about users, we can't just reduce everything to text boxes, check boxes and combo boxes. Are there edge cases that require highly customized UI's? Sure. But there's also a great deal of tabular data that would reduce down to text boxes, check boxes, and combo boxes quite well, and in these cases, I'd prefer to present my users with a batch edit UI. This editing/deleting one record at-a-time nonsense for basic tabular data is just ridiculous. 
Super slick, I love it. I'll probably end up creating a pull request: You should give your users the option of accessing the administration panel from a route prefix of their choosing, rather than something as obvious as "admin". This can be set up pretty easily as a config option.
Yes! I have been using ultimate and pycharm a lot with these licences
Cool one :)
If it uses the storage facades like it should be, then that should be happening automatically as long as your file disks are set up properly.
Oh for fuck's sake.....
Guessing you're talking about the book published in 2009. PHP has change quite a bit since then, but I don't know what kind of content the book has. People like to link http://www.phptherightway.com/ for today's standards. 
This looks great. Well done!
Just the motivation I needed to continue working on a side project of mine. (slim framework 3 though)
Despite the hate for PHP, there's still a very good job market for its developers.
Try fedora, best among all. I've tried others they ain't got that feel.. 
How stuck are you exactly ? If OOP basics are your main issue, here's a very practical and easy to follow suggestion: find a short youtube video, around 1h long (can be shorter, shouldn't be much longer) with decent comments (so that you know it's not bad or obsolete) and go through it step by step, writing down all the code as well as your own notes and observations. If you fail to understand something, still follow the video but write down in your notes that that concept/method/idea could use some clarification and should be researched further. And that's basically it. The video you choose doesn't have to be perfect, it just has to get you started. By the time you're finished with it, you'll be introduced to the main concepts such as abstraction, encapsulation and inheritance, you'll have some OOP code (however basic) that you've written which used them in practice and your own little guide written in your own words. After that, you can repeat the process with a similar video to reinforce your understanding of the basics or start googling for answers and clarifications about some of the things that still weren't too clear. Once you feel you've repeated this cycle enough times and understand why and how you should be using the basic OOP approach, you can start applying it to some of your smaller projects, researching more complex concepts and so on. Here's a starter video I can recommend because I used it in a situation similar to yours: https://www.youtube.com/watch?v=w3XUG6oyINI and https://www.youtube.com/watch?v=qlF1MuHlZ4Q sounds good enough for a first video as well. Let us know how it goes and if the advice helped you get unstuck.
Gotta export that database schema in PDF format. This made my day.
It looks nice, but what really bothers me is that there are no tests whatsoever. Considering that Laravel does not follow SemVer I will not be able to easily, automatically asses how this will break in a future version without going through the hassle of clicking through it on a test system (and possibly missing something). You make heavy use of Authentication and Authorization features which were changed before and are likely to be updated in future releases again. Some Traits are renamed between versions. All this will render the admin interface for users unusable. Pulling this as a dependency will mean that I can't safely distribute my app, because customers will not be able to (safely) upgrade. Just a set of high level tests which test that things are accessible even after an update would mitigate this and also aid you in fixing things after breaking changes.
The built in "database builder" IMO should be a separate plugin. That way the base admin CRUD/BREAD stuff are not bloated with database building functionality out of the box. It will also allow the development of the builder stuff to focus on what is important for database building, such as migrations.
Awesome work, really! Love it! Edit: why the downvote?
Try deferred rendering. It's incredibly easy to do (basically you just have your server output a JSON representation instead of DOM data), but it speeds Datatables up so incredibly much. https://datatables.net/examples/ajax/defer_render.html I have successfully had Datatables with roughly 30k entries without lagging a little bit, even the filtering etc is pretty much instant.
I am looking to rewrite my c# webpage and was wondering about new zf3. What do you think about it? My page is using a lot of rss reading and from reading the documentation, the rss reader is built in zend framework. Any opinions or alternatives? I am .net guy, but the server prices are too damn high for a simple page:)
Try something original? 
I would like to know where you are getting this number from. I have very recently went on the hunt for a new job and my experience does not match with your report. Granted that I am in Canada... I did extend my search to the US. In Canada an average PHP Developer can expect to be paid 45k -&gt; 85k. Avg: 55k. Source: PayScale In the US an average PHP Developer can expect to be paid 51k -&gt; ~100k Avg. 87k Source: Indeed So how is it that my quick 5 minute google search has better information than your "article"?
I would probably skip that book since it is so old now, the version of Zend Framework is outdated and the whole language has moved on a bit since then. Recommend picking up [Modern PHP](http://shop.oreilly.com/product/0636920033868.do) by Josh Lockhart instead if you're looking for a physical book.
+1 this sounds like a task for GO rather than PHP
- SQL Injections everywhere? https://github.com/the-control-group/voyager/blob/master/src/Controllers/VoyagerDatabaseController.php#L93 - Eval? https://github.com/the-control-group/voyager/blob/master/src/Controllers/VoyagerDatabaseController.php#L110 - What? https://github.com/the-control-group/voyager/blob/master/src/Controllers/VoyagerBreadController.php#L37 - Incomplete traits? https://github.com/the-control-group/voyager/blob/master/src/Traits/VoyagerUser.php - No RESTful interface? It's interesting to see that a nice layout gives you more attention than clean &amp; solid code.
I think a lot of new developers get scared of refactoring. They think it is some risky, yet needed, operation, especially with legacy code. When it is really not. Only thing missing is the obligatory disclaimer about having tests, or maybe I did not see it.
I just thought people should know about this. Easy to install, sane file structure, lots of PHP versions available. I dropped Xampp and Wamp years ago after I found this.
Are you looking for "Reverse SMS Billing"? I will not suggest any service, as I don't know any good ones, but that's what you want to search for. I know that google play store can charge users directly (subscription via phone bill), but that functionality varies wildly depending on country/provider.
Refactoring in Storm (or all intelli j products for that matter) is fantastic. The single reason which made me make the conversion from a simple text editor like sublime to a full blown ide. Great article.
Using this i found the right term. Carrier billing. One of them is: https://fortumo.com/
&gt; It's interesting to see that a nice layout gives you more attention than clean &amp; solid code. Always!
This post might finally put me over the edge.
It is really worth it. To get used to storm I just rebound all the keys to Sublime esque. Over time I learned the default bindings when i would pair with other members of my team who were using storm, but with the normal key bindings.
Why not just put all your images in `https://my-site.com/images/toast.jpg`? **EDIT** It sounds like a permission issue for it to be coming up forbidden instead of routing /api/v1/user/toast.jpg through index.php, so it wouldn't necessarily be fixed in apache.
Looks like that within the last 15 minutes or so, integration with some testing providers is being started. Hopefully your message was seen by the developer.
I just switched to PHPStorm 2 weeks ago after using Vim for years, I don't think I'll go back. I use the ideavim package which gives me almost all of the vim features I want. The refactoring tools, code hints, and autocomplete have made me much more productive. I urge anyone on the fence to just give it a shot.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I am consistently disappointed by PhpStorm's lacklustre refactoring capability. It may or may not be superior to NetBeans' at this point but it fails on the simplest of tasks. "Extract method? I don't know where to put it!"
If you can move your DB outside of webroot, this post is not for you :) Anyways database is in this case protected on the same level as source code of any other PHP file and you can't download it. What should and what shouldn't be used is not important. It simply works. This post doesn't solve where the database should be. Just how to protect it if it is in the document root. Is that hard to understand?
Thank you for your theoretical effort but in reality, as far as I can tell, you never have bar executed first in the foo or bar statement.
My biggest problem with ideavim is that the macro engine is terribly slow, compared to vim.
Hi, can someone reproduce this bug in PHP 7.1? Any RC. http://goo.gl/AHzUDH
Do you mean refactoring is not risky, or not needed, or both?
Cool. I liked Yii 1, even though the endless chaining of methods got annoying. Such as `Users::model()-&gt;findAll()`. Though I guess that's a workaround for the lack of late static binding in PHP 5.2. Haven't used Yii 2 in a commercial project yet, but I like it. The docs for both 1.1 and 2 are great. The ActiveRecord pattern used in Yii is pleasant to work with, as well.
Er, I think you missed the part about it being a `pattern`. The key part of that pattern is that fact that your using a static function INSTEAD of __construct to check from an instance of the object already before creating a new one. Why are you extending it? The issue you are having is that you have extended the Singleton Class and then calling Database::$instance which does not exsist. Either call Singleton::$instance or static::$instance and it works. The only time I can think of someone needing to use a singleton in phpland is when they wish to abuse an IoC container. Not sure why only allowing once instance is important when you have a single threaded script that will terminate itself once it's complete.
It is not risky if you do things in small increments and have good tests. Also it isn't like we are refactoring in production. The process also calls for iteration throughout. It is most certainly needed. I spend all day, everyday refactoring BS code. That helps a lot in shaping my confidence in the process. Creating/maintaining good tests and ensuring proper coverage is a crucial part of the refactoring process. That's where the developer gains their confidence in their efforts.
I thought it was a decent first post! It was short, sweet, and to the point. Had decently explanatory examples. Without going into just copy-pasting all the documentation, you could also hint at additional keywords in DateTime, like `+1 month` or `-2 years`, etc. Just to demonstrate they can do more than just days. Also actually displaying the date would be handy too, so showing off the `format()` function and example uses, even if it's just using the constants like `DateTime:ATOM` rather than explaining all of the formatting syntax. So other than those extra need-to-know tidbits for users using DateTime, it's a perfectly good digest of some basic DateTime functionality. Maybe in the future, have a sequel blog adding more DateTime things, like Date Intervals, Immutable versions (like /u/ntzm mentioned), and such. But those are separate topics that don't need to clutter your currently-concise blog post now.
I never really got into using macros so that's not a problem for me.
Not exposed by the engine (yet), but /u/nikic has a great userspace AST parser that works in 5 and 7. https://github.com/nikic/php-parser
All the time, and very slow
Also, when paired with xdebug it pretty much is an integrated debugger environment (as well as an integrated development environment).
Unless I'm missing something, *every* ide makes use of or may be configured to make use of a debugger heh.
8 minutes.. must be a data-dump to 1 table. I had a much smaller file (around 60k rows), but that data had be placed across many tables with relations.. luckily it was a 1-off and then just insert/update new records. Anyway that was around 10-15 minute process (slowish machine at the time).
True! PHPStorm can be slow as shit, but after many-years of using a text-editor for PHP... I switched to using PHPStorm, used the Code Inspect and found decade old bugs within minutes. It's worth it, IMHO.
All languages are prone to runtime errors, it is a matter of being well tested quality code. PHPStorm in this case does refactoring just as well if not better than competitors. Maybe what you are looking for is an option to auto-run unit tests after the refactor is complete, and rollback changes if a test fails. However, I think between version control and reverting if needed, and running the unit tests manually works just fine.
The SQL Injection is... wow. I looked at a few files and it feels like the developer is using best practices from 2007 to write this package. While it's a nice idea, it needs very thorough reviews to get it up to scratch.
Imho. Php unit tests are used to exercise code paths. This helps to trigger runtime errors where $myfnction is typed vs $myfunction. Its mind numbing and is common to non compiled languages. If i have loads of unit tests, which i find an annoying but neccessary for PHP then i trust refactoring more. Before anyone jumps on me for "doing unit tests wrong", then i would challenge them to address tests used to test purely functional results and the number of times it exposed runtime issues that a linter/compiler might have found.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Firstly, apologies if I'm mistaken and it's something obvious - I'm new to Laravel and MVC in general.. I was impressed by the slick layout of this (credit to the developers, I love the interface) and so I started to look through the code to try and gain some understanding of what good code looks like. The thing that stood out for me straight away was the [Routes](https://github.com/the-control-group/voyager/blob/master/src/routes.php) file. Am I right in thinking it's very bad practice to include requests for data and various loops in this file? Also, is there a reason they are defining each request rather than using Resources?
Intelli j stuff rocks. Try out stuff through their [experimental access program](https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program) for free.
First things first. Scaling is an art. Finely tuned servers; load balancers; perfect queries; caching services. Getting all these perfectly tuned is a whole career in itself. From the sounds of it, you will be able to handle it yourself. You might not get it perfect, but you can definitely do it in a way that's stable, responsive, and performant. That said, your ideas of scalability are good, but you're thinking one server. You should be thinking several servers potentially. Having perfect code, on a perfectly tuned nginx install, with the right php-fpm settings (or apache and apache-mod) still might not be enough! Sometimes your server is just not strong enough. If you're server is some freakshow, 64gig, 16 core monster, yeah, you're odds are good you'll be able to handle a shit ton (industry term) of traffic. If you have a 1 gig, 1 core wimp, you're screwed. Now, here's the wonderful part. Load balancers! This is where real scalability comes in, imho. Yes, you should write your code, siege it, test, tune your server, tune your queries, use memcached, etc. All these things help in a scalable application, but, at the end of the day, if you're app servers are weak, it might not be enough. Load balancers really help because you can grow and shrink with your need. TLDR: load balancer gets traffic and sends it an individual server that's free, or free-ish (sorry, if you already knew that; wanted to make sure). Take AWS. You can set up a load balancer to receive all requests, then send the request over to a server that can currently respond in an effective manner. Let's say your servers can only handle 1k req/sec, but you start getting 10k. In this scenario, you can spin up 9 more servers, and you'll be able to handle the load! Then you can scale back when you don't need them. More specifically, to answer your questions: 1. Here's a good [article](https://kinsta.com/blog/hhvm-vs-php-7/) on PHP7 vs HHVM (which is hiphop). You'll see that it really depends on the app. Wordpress is the same on both, but Drupal works better on PHP7. Unless you got time to have your app written in both, I'd suggest picking one and sticking to it, until you find time. 2. mod_rewrite doesn't really affect it. This isn't something to worry about unless you have some really weird, complicated rules that map to other rules in the configuration files. Simple is good. 3. This I am not sure on. Hopefully, someone else will be able to speak intelligently to this. 4. Read the giant thing above. Scalability is just a step in the architecture process. They're decisions you need to make while building an application. E.g: caching, SQL vs No-SQL implementations (or a combination of both), language decisions, server setups, etc. It's a whole thing. **Personal opinions and preferences**: Use PHP7 with nginx + php-fpm. Throw memcached (or some caching) in front of your datastore. Use a load balancer. This really should be More than enough you. I hope I didn't overwhelm you, and I really hope this helps!
Hey, If you don't have a suite set up to benchmark these activities yourself, you'll never really be scaling anything. Mostly, you will be reading articles written by people who have have read articles about scaling. Everything you hear is going to be guesswork at best, and implementing it will basically be cargo cult behaviour. Unless you have a strong background in this field or are willing to do the hands-on investigation yourself, I would just stick to best practices: install nginx + php-fpm, let them autoconfigure, try not to write bad code, and hope for the best. 
It may work, but it's not intended to, and there are better ways how to approach this, e.g. adding couple of lines to webserver config file (or .htaccess if you are using apache). Masking the database as php file can bite you in the ass when you later want to find or replace something in php files, slow down starting of IDE and very likely have some other unexpected consequences.
Then write them
You don't say what kind of load you are expecting in the future. Is it in the hundreds of page loads per second or the thousands? For hundreds you might be able to squeeze quite a lot out of a single machine (scaling up) while thousands probably should be modelled on multiple machines (scaling out). In either case you should throw out Apache. Yes, Prefork is the worst mpm, but the only one you can run with mod_php. With Prefork you get a full Apache process per TCP connection, which takes a huge toll on both RAM and CPU, and a crappy experience for your users because you can't really offer them KeepAlive. First thing is to move to FastCGI or FPM, so you can use something other than Prefork. While you are doing that you might as well switch to Nginx. Make sure you have an opcode cache configured in PHP. Either APC or Opcache should be fine. If you run MySQL I assume you choose InnoDB, in which case you should configure the buffer pool size. Now start thinking about your usage patterns. Is it an interactive website where visitors interact with your content, or is it a news website where content is read much more than written? In the latter case you can consider a microcache, where pages are cached in RAM for a few seconds. A microcache kicks in and pritects you on peak load, when lots of visitors wants the same content at the same time. Why render the page hundreds of times per second when you can render it once every five seconds? We run the MMA news site www.kimura.se on a two-core Linode VPS. We can peak at thousands of requests per second thanks to Nginx and a ten second microcache. The last UFC we managed just fine with 20 PHP processes. Compare that to your Prefork Apache where you have 20 processes for 20 visitors. It's nothing fancy, all packages are from the Debian Stable repositories (except Nginx which comes from Backports). PHP7 will ramp up performance by a lot but I'm fine with the current PHP version in Debian Stable.
If developed properly, what would be some reasons not to do this? I am trying to think of the downsides. Performance, I guess, but if it's done right it should be fine. Dealing with scroll issues if you're currently in the middle of reading an article down the page?
Thanks for the kind words, ignorance now cured after following your amiable advice. Still thinking a PHP code snippet would have been better than a HAML _with PHP_ would have been better though.
php7-fpm + nginx if you must apache then apache + php7-fpm I held out so long, but nginx really is faster. I had it explained to me this way. nginx only does five things, but it is the most important five things and it does them multiple times faster than apache-- which I have found to be true.
This sums it up pretty much perfectly, scaling out is probably going to go a lot further than optimizing the server, though it rarely hurts to optimize as you go. If you're new to scaling AWS has a lot of great videos on youtube and I'd strongly recommend checking out their video on [scaling up to your first 10 million users](https://www.youtube.com/watch?v=vg5onp8TU6Q) it covers the broader strokes at each level of scaling and how to plan for the future. It won't explain exactly what to do but it will at least give you some search terms so you can learn more on each topic. Also, it seems like you're a tinkerer so you probably won't end up using this, but [AWS ElasticBeanstalk](https://aws.amazon.com/elasticbeanstalk/) is honestly a pretty convenient way to set up a website to scale with minimal effort or thought and can handle as much traffic as your wallet will allow.
There's something even cooler when changing method signatures. You can click the button with 3 squares above the preview. This will allow you to see each call point, and their call points and so on. And it allows you propagate the signature change however you see fit. 
I fixed it adding `RewriteRule ^api/v1/user index.php [L]` right after `RewriteEngine On`
you're welcome. your comment was superficial and very arrogant. effort returned in kind. 
Hi, yes, you have two options: * PsySH: http://psysh.org/ , which is a very nice REPL. and... Jupyter-PHP , a simple application to integrate PHP into Jupyter (the IPython Notebook successor): * Jupyter-PHP : https://github.com/Litipk/Jupyter-PHP * Jupyter_PHP Installer : https://litipk.github.io/Jupyter-PHP-Installer/ the problem with this option is that it's not feature complete, and has some bugs. I'm not very good attracting people to collaborate on the project, so it's stalled because I'm a little bit discouraged. 
thanks :) I'm not a very good writer, I find I babble a bit and english was never my strongest subject.
&gt;PHP 5.1 Don't do it.
Good points! might have to do a follow up post!
Yeah I definitely should of gone into a little more detail with `format()`, I think a follow up post will be on the cards. I aim to write one blog post a month at a minimum so expect one soon! 
I agree with the single query and iterate over the results. I tend to find most PHP developers seem to think its ok to loop through results and doing another query inside that loop... which is horrible... I recently spent a heap of time creating a single query that pulls down a table and all of its relationships, then using `array_map` and `array_filter` and it works amazingly! 
You don't have a screen for each of your favourite websites so you can see instantly when they update? Get one of those clamps to hold your eyelids open, no delay. Revolutionary.
&gt; Aside from boolean operators
AKA "Yet another list of commands with defaults to set up LAMP, plus some copy+paste from composer and laravel websites." $installXFrameworkOnXDistroBlogPostsCount++;
Don't worry about that. It's not a performance issue and it's not a security issue. If it does what you need, I don't see a problem there.
/u/ForeverAlot So, PhpStorm doesn't *automatically* detect PSR-4 namespaces, but once you *tell* it about your namespace, it'll handle folder structures and resolutions a lot better. If you go in to `File -&gt; Settings -&gt; Version Control -&gt; Directories`, mark your sources as a `Sources` folder, and it'll show up on the right in blue. on the right of that, next to the `x` button, there's a `P` for Prefix. Click it, enter your Namespace for that folder and then PhpStorm will forever remember that that folder uses PSR-4 with that namespace, and it'll remember that for children folders that don't exist (So, for example, if you refactor a class to a child namespace that doesn't yet exist, PhpStorm will also create the subfolder in the right place for you). Also do that with Tests, I find it helpful
In the ”Directories” settings panel there is an option to register a `PSR-4 root`, and from then on PHPStorm understands PSR-4 perfectly. https://i.imgur.com/hV9XLMU.png
It uses methods that are not declared in the trait itself.
a point to be made regarding Refactoring in PHPStorm is that it becomes very useful once you learn how to refactor by using keyboard shortcuts, without touching the mouse - especially in trivial cases, using the mouse/touchpad to start refactoring might take longer than actually doing it manually. so learn the keyboard shortcuts and you'll become a lot more efficient.
This is entirely client-side and has nothing to do with PHP. In Javascript (jQuery) it's as simple as: $('form').submit(); 
If you're pointing the finger at everyone, maybe it's time to look at your own attitude, *sweetie*.
Because you're a fucking PHP developer that should judge a project by its PHP code instead of a shallow GUI. Saying "Awesome work, really! Love it!" only because it has a shiny website, but horrible code (see top comment), is so horrible wrong. It even tells us what wrong priorities you as a PHP dev have.
can you tell me what SGD is?
Just because you can use it as one doesn't mean it's supposed to be one.
&gt; Because you're a fucking PHP developer [...] Well, I never said I was a good one. But thank you for explaining. &gt; Saying "Awesome work, really! Love it!" only because it has a shiny website, but horrible code (see top comment), is so horrible wrong. It even tells us what wrong priorities you as a PHP dev have. Actually, my priority is not shaming someone for making an attempt to contribute to something, even though the first (or 10th) attempt doesn't satisfy the masses. I actually think it's an awesome contribution - and with the feedback from the skilled people here, it will hopefully get better. Thumbs up for the shinyness.
No thanks, sweetie. My behaviour is a reflection of who I'm responding to. 
&gt; The present hosting is on t2.micro instance and if web traffic increases in future, I want to make sure that I've tried to optimize the present instance to utmost before telling the client that an upgrade is required. As a side note, keep in mind your time is not free. Client needs to balance the cost of increased hosting vs. the cost of micro optimizations. I'm not saying to write shitty code, but it may be more efficient to step up a couple levels in hosting.
I hate these is server x better than server y, in almost all cases it depends, it depends on how your app is coded, it depends on your architectural set-up and it depends on how you've configured the server software be it Apache, Ngnix etc. * Your use case seems an obvious and standard one, PHP7 is a no brainier, I wouldn't bother with hiphop as the gains compared to PHP7 are minimal and in some cases worse. * No there shouldn't be any performance loss using it (nothing of note anyway) * Prefork **is** an MPM I'm not sure what you're asking here? You can't really compare prefork to MPM as they are the same thing. **Point 4**, if your worried about cost I would move away from AWS as my first move, the costs are astronomical compared to other services and dedicated servers. Take a look at online.net or OVH for dedicated servers, if you want to stick with 'the cloud' try Digital Ocean or UpCloud. **Optimisations** * First thing to look at is your own code, lots of speed gains can be achieved here with simply refactoring, optimising queries etc, refactoring is vital to the performance of any application. * Cache everything, cache your DB queries using reddis or memcached if your'e dealing with simple strings (I guess you are since you're using something basic like codeigniter). * Cache your HTTP and static content with Varnish * Load balance your database servers and HTTP servers, using ngnix here is a good choice. * Have at least 3 database servers behind the proxy all in a master-master config, maybe take a look at Percona for this. This should get you started, the beauty of this is everything can scale individually rather than having everything on one box like you currently seem to do.
I agree, I also appreciate it very much when people contribute code to the community. Huge fan of that. We need more of that, definitely. However, you as the publisher are responsible for the code you share and if it's full of vulnerabilities it should be fixed immediately or taken offline to protected the people that see only the interface thinking "great project I will use it" and start using it although it's full of security issues.
I don't know an article that explains it. It's common sense for me. When you define mixings/traits that use some kind of dependencies (in this case a method on the same object `$this-&gt;hasRole()`) you should add `abstract public function hasRole($name);` to the trait, so it throws at bootstrap directly an error message and not only when the method is actually used (since it would then throw 'unknown method' errors and you need to debug runtime errors).
I would enjoy seeing a slow mod_rewrite that was not a complete misunderstanding of what it is for.
&gt; I […] recently hosted […] on amazon aws Well, then it's a no brainer. You should have already a loadbalancer with an autoscaling group of at least 2 instances in separate data centers (AKA availability zones) set up, as you are certainly concerned about [availability](https://aws.amazon.com/de/message/65648/). Scaling that architecture is only a matter of adding scaling policies. OTOH if your instances share a common dependency (e.g. database) you didn't build with scalability in mind and you're kind of screwed to rebuild substantial parts of the system.
Thanks, I'll try that.
thank you, I am blind
I'm not really sure why they gave this advice but more than that why aren't you using a class? In my experience the valid reasons for using stdclass are limited to interfacing with exchange formats such as JSON (and not even necessarily there).
There's so much fucking spam on this sub. Jesus christ mods sort it out
&gt; Artifactory – The Open Source **Maven** Repository Manager - JFrog AHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH No. /goes off to have urgent shower after thinking about Maven. 
My perspective is more from the developer's point of view. Yes I read the release notes and articles like these. Some changes are easy like using [] instead of arrays. But for enhancements like dereferencing? Maybe I'm just getting old but it's going to take me a bit before I understand where they become useful in the context of a php application.
I would guess the next step in scalability based on the information you have provided is a reverse proxy + cdn. Implementing a reverse proxy puts you on the path of having the architecture to scale to multiple web servers. If you think in the near future you will need many web servers I would probably look at HA proxy right out of the gate, if your growth is going to be more gradual then you may want to consider starting with nginx. Nginx handles being overloaded more gracefully than Apache2. If you are talking about scalability then you aren't really talking about what a single component can handle what you are really thinking about is the ability to add resources in parallel to keep that single component from ever becoming overloaded. Putting an n-tier architecture in place (probably consisting of proxy + web + database servers) where each tier is planned so that you can add more servers to it. So if you are planning for multiple web servers working in parallel with a reverse proxy/load balancer in front of them then the web server software running on the web tier isn't a huge factor. For example I currently run apache2 web servers but they sit behind an nginx reverse proxy. Adding a reverse proxy is also great for caching, requests for static css, js and image files rarely even hit my application server. In addition to this you should make sure your OP Cache (or APC or whatever you are using for php application cache) is appropriately configured. You can also design your php application to take advantage of Redis or Memcache. Finally make sure your database is appropriately provisioned. While writing a web application you should build it in a way that avoids having to go to disk while minimizing web requests (ie cache resources and consider how you will expire that cache, aggregate files, offload to proxies and CDNs, utilize Redis!). edit - You may not need "scalability" at this point, make sure your servers are tuned properly first. Out of the box with no extra config the Drupal site I am currently working on was getting 4-6 second page load times (from local network), after a significant amount of tuning the page load times are about 500ms (from local network). When comparing stress tests this resulted in the web stack being able to handle about 20 times more traffic before it started falling apart.
Sometimes, doing interactive experimentation can be very interesting. But IPython/Jupyter is interesting in many other ways: - it's easier to prepare (shareable) workshops - you can use it as place to save class notes - it's a very good tool to work in data analysis, since you can mix code with data tables, plots, markdown... 
What about daylight savings ... Time management is trickier, and [DateTime](http://php.net/manual/fr/class.datetime.php) with [DateInterval](http://php.net/manual/fr/class.dateinterval.php) does a lot of work you don't want to do and sometimes don't know. If you know about daylight saving and other time fuckery, for god sake add a note in your gist, if not, you should not post that gist, read about it and learn about the flaws of your snippet. **I am sorry for those who want a quick copy and paste way to do the job, but it doesn't work like this whith date and time management.** A better general purpose snippet would be : $date = new DateTime('@'.$timestamp)-&gt;add(new DateInterval('P1D'))-&gt;getTimestamp();
N+1 has an performance advantage of being able to satisfy everything from cache, though. If you're storing to cache via some `model_&lt;ID&gt;` key name schema, you can do the initial query on the database and do all the other N queries on your cache instead.
If you're working with a timestamp daylight savings doesn't make a difference? What scenario can you imagine in which this would cause a problem?
You're incorrect.
&gt; You're contradicting yourself. I don't think so. This is my idea: $ids = fetchIds(); // for example, [1, 3, 7, 9, 11, 13, 15] $content = cacheMultiGet($ids); // returns everything except 13 $missing = figureOutWhatMissedCache($ids, $content); foreach ($missing as $missingId) { // N = 1 $content[$missingId] = fetchSingleItemAndCache($missingId); } Yes, you can probably replace the the `foreach` with a single query, but then you need to mangle everything after the fact, cache separately etc. Sure it's doable, but you'll have a **much** harder time doing this in an existing application. In a N+1 app? Not so much. &gt; In any case, go ahead and write your application as you prefer. Likewise. &gt; Writing apps in an N+1 fashion is certainly easier, but good luck trying to prove that O(n) should be faster than O(1). If `N = 1`, end proof. :) &gt; If performance is your primary goal, then you should not be optimizing for ease of implementation. In your typical webapp your typical cache hit rate is 90%+, even with user generated content. It might even be 99%. The `$missing` array is going to have 0 or 1 members the vast majority of time. You should **definitely** look for ease of implementation if you're looking for performance because you "implement performance" as easy as anything else. Difficulty of implementation has no relation to good performance.
But it doesn't do this automatically afaik
It only tried to allocate 54 bytes. I'm guessing it's just trying to define a variable in an infinite loop. Look for loops where the condition is not certain.
when do you see the error? During a common public event? Or once a while rare event that may only be triggered by yourself? If former one, you'll need to find a way to fix the code. So many things could be happening, so many approach to the solution as well. If later one, just set memory limit to unlimited for that particular action. 
Oh nice, this might work. Yeah I just want to get an idea of what my server can handle traffic wise so then I know when I need to start worrying about balancers and whatnot. Thanks!
This was one of my first lessons as a newbie: Iterating through a table with 10,000 entries with a query for each row earns you sighs and headshaking from your local sysadmin. I had asked him if he could increase max_execution_time above 60 seconds on our server and he had answered "What have in god's name have you done *now*?" Data analysis?
Didn't know that, thanks for the info
Thanks !
Man my Google-Fu is weak today. Thanks!
TIL
No, the ORM depends on it, but it does not depend on the ORM, you are completely free to use it independently.
Oh? Will take another look at it later then.
I just purchased that book and it read it back-to-back. I learned a lot and much of it could truly be implemented in minutes. However, it is a little out of date and could do with being updated to discuss PHP 5.6/7 and MySQL 5.6 to reflect InnoDB and full text for example.
&gt; Unfortunately, managing several thousand htaccess files on large scale web servers is very time consuming Sysadmins that have to manage servers at that scale will not want to depend on a one-off php script to handle their production configuration. That's what tools like puppet/chef/ansible are for.
It is so weird. Before php5 I tried to handle arrays as references everywhere. Not even for performance reasons, maybe just because it was smarter. Now I am really happy with the array semantics, I can pass them around and hardly have to think about side effects.
When constructing objects purely to json_encode() and echo that as a REST API response, what is the recommended course of action?
Experience teaches us to think functionally and separate data semantics from object semantics. It's happening across the industry as well. 
Posts are auto-removed after 3 reports by users.
Associative arrays and stdClass objects are treated the same as far as json_encode() is concerned. https://3v4l.org/UqOQo So if that's your only reason..... No. Don't be silly.
Thanks for the input!
Additionally: applying these configuration changes at scale isn't something you do with "several thousand" individual .htaccess files. _You don't need to._ Inserting the appropriate directives into the web server configuration once at the VirtualHost level is sufficient; they don't need to be repeated for every directory. And a lot of the directives given as examples are just plain dumb… RewriteCond %{REQUEST_METHOD} !(GET|POST|HEAD) [NC] RewriteRule .* - [F] This is an inefficient and unnecessary way of implementing the `AllowMethods` directive. By rejecting `OPTIONS` queries, it will also cause certain types of AJAX requests to fail. RewriteCond %{THE_REQUEST} !HTTP/1\.[0-1]$ RewriteRule .* - [F] Literally the only thing this will do is cause havoc for HTTP/2 clients.
[removed]
The best? Nope. "The best" the writer's perspective perhaps. Most if not all other frameworks have those things as well. - Blade: terrible syntax and extremely confusing, not to mention that Laravel exposes the container in here (LOL!) - Eloquent ORM: Active Record is still inferior to a Data Mapper if you ask me. As long as Symfony exists, I see no reason to use Laravel.
It was around ~20 years to have a PHP CMS that is build *from the ground up with security in mind*. At least as far as I can tell. Some may not like Airship's component naming, look or whatnot, but one thing is sure: Airship should lead with example and inspire more CMS software to have the same kind of security mentality. 
Couldnt agree more with this. Most of the Apache vs nginx benchmarks are unfair, because they test mod_php vs php-fpm, so it is natural for nginx to use a lot less RAM. If you serve your static content through a CDN, there is not much of a difference there. I have a site with Alexa rank less than 10,000 running peacefully in a 1GB VPS with Apache with fcgi, CloudFront for static assets, and a cache hit ratio for web server at 70-80℅. Edit: I meant to say Apache with fcgi, but wrote mod_php.
The documentation for UI is pretty.... minimal. It's currently mostly method signatures. http://docs.php.net/manual/en/book.ui.php
Report it. Violating someones license is one thing, taking something someone else made, claiming it as your own and selling it is a dick move and he knows it. Generally all it takes is someone knocking up an 'intent to sue' letter and thats normally enough to stop people being assholes.
Getting really tired of Indian companies spamming the sub.
I will not use a CMS with such crappy renaming of what I am used to. Can you imagine if every library, framework and CMS used their own themed names for everything basic? bridge means extension management? cabin is what symfony calls bundles and joomla calls components? motifs is templates? barges are extensions? hull is unknown. and more. After not using this for a few months then I would have to relearn the jargon again if I wanted to do anything... no thanks, I would rather not use it in the first place. This feels more like a joke. 
The thing is, how would I go about reporting it? I was thinking of contacting the original owners (two of them), but there is a concern that the emails they left for contact are not checked on frequently at all. Should I contact a lawyer myself, or maybe creative commons themselves (since the terms are covered under their license)?
He is going to put in on-site transactions and plans to sell the source later when he gets more attention to it.
Feels like thats what this sub is for lately, blog promotions, advertorials and clickbaits
Reported as spam. 
Creative Commons is not a policing authority. You need to contact the authors. It's up to them whether they take action to enforce the licence they've used for their code.
Thank you. I will try my best to contact them.
I was trying to love PHP-GTK but the development stalled and there were too many edge cases which caused segment faults. Its this looks like this is a much easier transition, as your not stuck with the dealings of the gobject system (porting). It's amazing how many language ports there are! You are godsend, and thank you pthreads!
You agree with me and yet you run mod_php (and mpm prefork?)? I have to assume that your PHP scripts return quite fast so you can keep down the number of processes? How many PHP hits per second are you handling in Apache? How many Apache processes do you have? My rule-of-thumb is that a PHP process consumes about 40 MB of RAM, so you would not fit more than about 20 processes. Do you also use your CDN as a reverse proxy for connection handling or do your visitors connect directly to Apache?
Why would you contact a lawyer yourself? It's not your code. You have no right to take legal action on this "Steve" guy in the first place. Also, there are many variations of the Creative Commons license. Which one is the original code shared under? You say: &gt; I do not want to be that guy, but this is the work of others he is going to claim as his own, and I can't just sit around and knowingly let him do this... But based on your comments you obviously DO want to be *that guy*. The code isn't yours. What "Steve" is doing isn't hurting you. If you really care that much, the most you should be doing is contacting the original authors of the code and giving them an FYI. If they choose to ignore it and not enforce the license they chose, that's on them. To be blunt, it sounds like you have some beef with Steve and/or are bitter he's not sharing the code with you. 
TLDR; - Steve is an ass and I hope he burns in hell - You cannot do anything except raise the flag to the original owners and pray they have the funds to sue Steve into the stone age.
Try jQuery DataTables with AJAX sourced data. https://datatables.net/examples/data_sources/ajax.html
The difference is that I don't say it's the best, it's just my opinion. Luckily a lot of appreciated design patterns agree with me.
&gt; creative commons license Yep. https://creativecommons.org/faq/#can-i-apply-a-creative-commons-license-to-software &gt; We recommend against using Creative Commons licenses for software. Basically, the original authors of the software made a big mistake if they actually licensed it under creative commons. It could be that they licensed the documentation under creative commons and the actual source code under a different license.
&gt; I have a friend, who we will refer to as Steve. [...] is there any means of reporting this behavior Are there the smallest, thinnest quotes around "friend" up there, or are you using this word in a new way? Anyway, I'd propose you warn him clearly that you'll contact the authors about the violation if he proceeds. Don't try to speculate to scare him or read moral to him, or talk about penalties. Simply state what you'd do, and if he proceeds, do it. If he's your friend, the least you owe him is your complete honesty.
Will do
Do you mean open source instead of Creative Commons? Others comments have covered the difference, but it's a pretty important piece of this question. If it is open source it also matters what type of license it is licensed under (GPL, MIT, etc) Generally, large projects have an organization or foundation behind them. In the case of Drupal which I work with, this is the Drupal Assocation. They typically have legal resources and part of their mission is to protect the open source requirements of the project. If you can't find an org like this, you could also reach out to the Gnu foundation. They could probably connect you to resources. 
As an ex-game dev, a simple snake game should be in the realm of a few hundred frames per second. 60fps for something so simple... is well. trash. I am kinda torn with this sort of project work, it gives me the heeby jeebys thinking that PHP is slowly marching towards Java-land. 
Personally I find ORMs to be horrible, in the sense the added extra layer of crap which might breakdown on complex queries. Why not just learn the query language? SQL isn't that hard, and there's lot of stuff on line if can't think of how to do something.
&gt;If you're server is some freakshow, 64gig, 16 core monster, yeah, you're odds are good you'll be able to handle a shit ton (industry term) of traffic. Just make sure your Apache/Nginx and php-fpm is configured for it. I can't believe I have to say this. But if you must know, I have seen places where they never bothered to tool Apache for their expensive, badass hardware.
&gt; As an ex-game dev, a simple snake game should be in the realm of a few hundred frames per second. 60fps for something so simple... is well. trash. GTK is not a game development engine, and the maximum frames per second are actually determined by the compositor and monitor. 60fps is what the software determines my hardware can handle, and is what Javascript game developers aim for ...
[ELK](https://www.elastic.co/webinars/introduction-elk-stack) could be an option. You can just get logstash to run through all your logs and send them to elasticsearch, and search through them with kibana.
be *that guy* steve needs it. steve sounds like a bro. steve is that ass that copied my test in physics. steve hit on my girlfriend. steve egged my car. i don't like steve. 
Are YOU Steve and testing the waters here? Either way, just give him a heads up, if you guys are friends, and tell him that you are going to send the original creators a message. Other than that ignore it? It's kinda non of your business. 
If you are really Steve's friend you shouldn't report him. 
As others have noted, CC is a very uncommon (and inappropriate) license for software. Are you certain it's not some more other, more appropriate license? What Steve is doing might actually be okay (or not), depending on the terms of the license. 
How is that SQL injection? Laravel query builder uses parameter binding.
We have CentOS (I prefer FreeBSD), MySQL and PHP 5.5. It's enterprice application. We have never encountered performance issues with PHP because PHP does not generate HTML pages, it only generates JSON. The only issue is with MySQL when the table exceeds 1 million rows and there are several joins. So you may want to study MySQL tuning but I would'n spend my time until slow queries start appearing in slow query logs because it is very broad topic.
Not worth reporting.
It's more complete than parts of the Intl extension, at least. :p
Fuck you.
1. /r/phphelp 2. Joins aren't for silly table splitting. Keep everything in the same table. 
I, of course, have not forgotten our exchange, but that wasn't what prompted this decision. Today I recalled a conversation with Enrico Zimuel about the new Hybrid encryption in ZF3 and-- despite having worked on the ZF2015-10 patch-- he had forgotten the importance of specifying OAEP in an early draft. Enrico is one of those developers who can probably get away with writing his own cryptosystems without creating a slew of vulnerabilities most of the time. (From a cryptography researcher, this is more of a compliment than it might sound.) And yet even he forgot about it. I looked on Packagist; others were just as guilty. The solution to me is clear: Fix the tools that developers are using, rather than blaming them for using it insecurely.
The original version of this post contained what looked like a real IP, username and password. If you really posted your real credentials, your in deep trouble. Go to the DB Server and change the password RIGHT NOW.
You're posting an array. There's zero chance we can tell from this array how code elsewhere will interpret it, but chances are you can't add a backup host just like that. You'll need to find where the host is interpreted, and patch that feature in, then go back and change the array.
At least proves the post title is correct.
 SELECT rating / rate_count AS avg_rating FROM artikel_rating ORDER BY avg_rating DESC LIMIT 3;
It works, not sure how I didn't come up with this myself.
Boy, I really hope somebody got fired for that blunder.
If people gave me specific and actionable criticism, I would listen to it. What do I get from people? * It's ugly. * I don't like an irrelevant decision that doesn't affect how it's used (naming). Great, none of that tells me **WHAT TO FIX**. More importantly, people who have never even *tried* Airship make sweeping vague claims about its usability. Then when pressed for specific things they found difficult to use, I get radio silence. You can't call something unusable if you can't demonstrate what's not usable about it. These discussions have become a huge waste of time that I'd rather spend making the project better. As in: talking to people who *have* provided specific actionable suggestions for improving UI/UX.
If OP gets fired, then the next in line in order of competency will be here, posting logins and asking questions, and then getting fired. It'll keep going this way until eventually the cleaning lady, the last surviving employee, is tasked with adding a backup host to that array. So moral of the story is: never let your single developer get angry and quit.
For the fun of it, I tested the performance of the following: 1. json_decode('{}'); 2. new StdClass(); 3. (object)[]; "new StdClass();" was the most performant, followed by "(object)[];" and finally "json_decode('{}');". Not that this comes as a surprise, really... Nor would it (I hope) make much difference in the general performance of your server....
If I may add my own corollary, stay single and stay angry; a great way to ensure job security
With a very cursory test of creating an object in each variation 500,000 times (on the same hardware under the same conditions): 1. Averages to about: 0.65 real 0.49 user 0.13 sys Ranging between: 0.60 - 0.74 real 2. Averages to about: 0.42 real 0.28 user 0.13 sys Ranging between: 0.41 - 0.45 real 3. Averages to about: 0.53 real 0.34 user 0.16 sys Ranging between: 0.50 - 0.57 real The performance gains are pretty marginal, when all is said and done, but measurable. It's pretty much a nice spread between them, so if you want "moderate performance" (not too fast, not too slow), 3.'s your guy. :)
You can't just change the host, you have to move all the old data over too (and keep the two servers synced) 
Phew! I won't have to write a procedure change.
Not necessarily. `openssl_private_decrypt` could try OAEP padding first and do PKCS1 padding second. If PKCS1 padding is detected it could issue an E_DEPRECATED but still decrypt until PHP 8, at which point, you'd need to specifically specify PKCS1 for it to decrypt PKCS1. There's no way to make `openssl_public_encrypt`work in the same way, however. Two other possibilities: 1. Create a new function - `openssl_set_default_public_padding`. Set it to PKCS1 if you want all subsequent calls to `openssl_public_encrypt` / `openssl_private_decrypt` to use PKCS1 padding by default. If you don't call that new function OAEP padding will be assumed. That function could be deprecated on introduction and removed in PHP 8. Or not removed and not deprecated if the PHP core devs would be okay with it staying. Once that function is introduced devs moving to the new version of PHP would need to add that one line to some sort of config file but otherwise it'd be a smooth transition. And if that line would need to be added to a bunch of files you could do `auto_prepend_file` in php.ini / .htaccess. 2. Create two new functions - `openssl_rsa_decrypt` and `openssl_rsa_encrypt`. As is RSA is the only public key algorithm OpenSSL supports that supports encryption. DSA and ECDSA don't encrypt - they just do signatures. ElGamal supports encryption but I don't believe OpenSSL supports ElGamal . `openssl_public_encrypt` / `openssl_private_decrypt` could then be made deprecated.
We'd have to set the default to a new `OPENSSL_PKCS1_UNSPECIFIED` constant, which would behave like your comment outlined. &gt; There's no way to make `openssl_public_encrypt` work in the same way, however. Simple: Default *that* to OAEP.
I've been meaning to contribute more to Symfony and Laravel, but the year is nearly over and I haven't found the time to do so yet. (I wish e-commerce sites, namely ones built on Magento and OpenCart, would stop getting hacked already.)
This learning app thing is going to end up with some e-commerce features, so it's definitely something I want to do well...
&gt; We'd have to set the default to a new `OPENSSL_PKCS1_UNSPECIFIED` constant, which would behave like your comment outlined. I like that!
Sure! I've never worked on an RFC before lol. Do you have a wiki for the RFC started yet? I guess PM me more info! This'll be a good learning experience for me :)
Well, this question is in no way related to PHP in the first place, but OP already got his answer so whatever.
Because you need more practice and experience.
Sure, but you are still a terrible engineer! What engineer would accept under-performing code in their codebase?! ;)
Our default setup at AWS: - Use CloudFront, assets are loaded from S3 and use proper cache headers for requests that hit your own webserver - Use ELB with AutoScaling group, make sure your webservers (at least 2) are in different zones. Configure it to spawn extra servers when it gets busy and remove those webservers again when it's quiet again - Usually we have Redis (ElastiCache) available, it has way more features than Memcached. Make sure you turn on the "Multi-AZ" option if you need your data to be persistent (database instead of just cache) - On the webservers itself we use nginx + php-fpm + php7 You can also use DNS load balancing and setup the above at multiple regions for extreme availability. Of course this can mean you have to keep databases in sync with each other... And one that's not related to performance but what is very useful: - Use a VPC for added security
Yup, luckely PHP/Webdevelopment is only a minor thing in my study.
They are different tools for different things. Hence why you have polyglot for instance. On my end I do deal with Mongo MySql and Neo4j, each one is good at its thing, and I use them for their thing. (not in the same app though)
I posted a comment that you actually shouldn't use PHP native DateTime due it's conceptual errors and deficiencies. Instead it is wiser to use the Chronos wrapper around it: https://github.com/cakephp/chronos Then you can also more easily use immutable and quite a few other useful methods on top.
Thanks for mentioning airship. I'll look into it. 
I probably wouldn't factor a query object in the precise way OP is doing, but notice you're doing a bit of circular reasoning there, which goes like this: - How can I set more SQL query features on that query like offsets, limits, joins? - By adding offsets, limits, joins, isn't this query becoming just an SQL query? Do you want a rich SQL-like featureset or not? I'm confused. &gt; Also, if the extent of the "repository" is literally that exact query format and that single search() method, it's a bit of an odd abstraction. It's called CQRS :-). Of course the assumption is you have multiple query classes, not just *one*. While SQL is not CQRS, it has almost the same interface as well: you have exec() and query(), and what happens depends on the query passed. So if we do "command query responsibility segregation" then we end up with two objects, one having just exec(Command $command) and the other one having just query(Query $query). So "search()" is just another name for the query method. &gt; For that matter, the $query object isn't really a query object since it has little to do with the actual query that gets constructed. No, it is precisely a *domain query*, because if it contained any implementation details for the SQL query constructed it wouldn't be a *domain query*, it's be just an *SQL query*. Those are in two distinct layers in the architecture. It says right in the title that this tutorial is defined in the context of CQRS. It's indeed possible that at a lower level you'd have a SqlQuery object directly rendering itself to an SQL string, or whatever it needs to directly accomplish its goals, but if you only have *this* in your architecture, then at no point do you implement CQRS. You don't want a CQRS read repository to accept *SQL* after all, you want it to accept *domain-specific queries*. Think about it like this: imagine the repository is on another server, so queries have to be serialized. What makes more sense, rendering that query in the client and sending SQL to the repository, or sending a domain query and validating it and rendering SQL (or whatever) out of it at the repository? If it's the former, then your repository literally does nothing, it becomes a thin wrapped around PDO. You've not exactly "seggregated" anything, you're simply allowing clients to run arbitrary SQL through you. The latter brings the responsibility of fulfilling queries into the read repository, and clients simply build and send queries as DTO, so the architecture of assigned responsibilities is maintained. A query doesn't have to be an object, by the way. It can be an array, or even a string (example: GraphQL), but the key trait is that it doesn't contain any *query fulfillment implementation details* but only *the abstract query definition*.
Love to see some examples or info on the errors you have encounter, im yet to encounter any and find ot quite easy to use DateTimeImmutable. Very interesting though will def check out the chronos library. 
Seems like the coupling between UserSearchQuery and SearchUseRepository is way to tight. Just not sure what the value is in having a separate query class. Instead of: $query = SearchUserQuery::forOwner( $this-&gt;request-&gt;get('first_name'), $this-&gt;request-&gt;get('last_name'), $this-&gt;request-&gt;get('role'), $this-&gt;request-&gt;get('order_by') ); $users = $this-&gt;users-&gt;search($query); Why not: $users = $this-&gt;userFinder-&gt;forOwner($firstName,$lastName,$role,$orderBy); Internally the finder can still do all the validation and what not. I know it is often difficult to show the value of added complexity in a short article. A link to a full application using these principles would help.
If you strip them out you're changing the nature of the user query. Instead you should escape them with a backslash (in MySQL at least, I don't remember for the rest). This means you need to basically str_replace('%', '\\\\%', $firstName) before you splice it in. Ideally the DB driver would provide these escape functions, unfortunately most don't.
Escape them (it won't become an usability issue then).
The coupling _should_ be tight because the repository only accepts instances of `SearchUserQuery`. &gt; Why not: ... Because if we ever modified the `$userFinder` it would necessitate refactoring every single usage of it. By allowing for different variations of `SearchUserQuery` (via named constructors with different parameters), we can (mostly) isolate changes from calling code.
Some support it for alternate characters, say SQLServer. Granted I don't know this by heart, so I just put such functionality into my DB wrapper.
SO Easily!
Hmm. I guess this is where seeing an actual working app might come in handy. Any links? Seems like if you define a UserFinderInterface with forOwner and forEmployee methods then the refactoring issue goes away. Or to put it another way, how would you add $email to SearchUserQuery::forOwner without refactoring your app code? Add another named constructor? How would that be different than adding another method to UserFinder? Besides refactoring, is there any other value in exposing the query object to the application only to immediately pass it on to the repository?
On top of that, having a *domain query* object allows you to use non-sql backends, like elasticsearch or some mongodb and stuff.
It is a matter of separating concerns, see https://en.wikipedia.org/wiki/Single_responsibility_principle There is no need for a repository to be aware of the business logic. Its job should be fetching objects based on a given criteria. SearchUserQuery is that criteria. Also, by separating the SearchUserQuery into a DTO you can easily serialize it into a session, or save it into a database as one of the predefined filters. Also, when you start paginating results you don't have to carry all of the search parameters in the URL (although this has downsides as well, like not being able to share a search page URL with the search parameters already set).
Oops, totally missed that. Will update. I also created a [PR for EasyDB to add an `escapeLikeValue`](https://github.com/paragonie/easydb/pull/28) method.
1) Software that is CC-licensed is stupid. CC even makes it clear themselves to use an Open Source license. 2) If this is occurring in a corporate environment you need to inform your superiors immediately. They will get Legal involved, evaluate if "Steve" can do such thing under Company Policy (and discipline accordingly), and if they can assume liability if the original maintainers should they choose to act 3) If not, contact the original maintainer, and the Software Freedom Law Center (https://www.softwarefreedom.org/) and ask for their advice.
I don't have anything that is open source, sorry.
Neat. :) Maybe you can suggest to the authors they should have a similar function for REGEX.
Good to know, thanks. I guess, given Stallman and his religious view on GPL vs other free licenses, I'm not too surprised.
You should post this on r/laravel . r/php hates Laravel for reasons I haven't figured out yet.
you have the beginnings of the League of Steve Haters. let it be know. 
It just strikes me as something easy to catch people out. On the other hand, I suppose you'd pick up on it pretty quickly if you ran your code in say, 7.2, and it suddenly broke.
You can find just about anything on Packagist.com, so you don't need to use a framework just because it has a RSS reader, just use any RSS reader out there. And while you're right that PHP is more practical for a simple website, have you checked if the features you use are supported on the Linux distribution of .NET? Mono? A VPS is $5/month and you can install anything, so if it could save you effort in porting code, it's worth checking out.
Eloquent, and difficult upgrades, are the top two complaints. 
You could see if there's a way to override the library functionality in his own application instead of modifying the library itself. That wouldn't be a violation of the software license.
What's the objection to Eloquent? I could nitpick about the syntax until the cows come home, but it seems reasonably usable overall.
I don't know of a direct solution to this, but you may want to do Markdown Parser -&gt; HTMLPurifier and limit the markup in the second step. Not perfect if you want to preserve the original markup though. Assuming this is from user input, you probably need to hit a purifier anyways because I believe the Markdown spec allows you to embed HTML and thus a compliant parser would leave it alone.
I just don't like the how "hipster" the wording is: "Crafting your application....web artisan" etc. Just show me documentation. But that's just me.
IMO, you should always think in database terms. 
I personally dislike Eloquent because it essentially combines the data model layer with the persistence layer and I believe they should be separate.
I'm not sure it will really be all that much faster, but you won't be wasting space or bandwidth on data that you don't have for a particular record since empty columns actually do take up a few bytes per row.
Honestly you haven't told us anything about how the data is going to be used. Normalization is great, if you need it, but if this is just for a project that is gonna have a hundred rows or something it may make sense to keep it simple. Although this could also be a good time to learn normalization via practice.
Yeah then this would be a good time to learn it. Definitely read up on the subject if you can... it's a very analytical concept that is important to how data is treated within web development. I have been working a lot with Javascript frameworks lately and a lot of them prefer the NoSQL / document type of databases (ie non-relational) but prefer normalized relational databases because they work better for long queries. Best of luck!
Sounds like NotORM. www.notorm.com
^this. You can join 15 different rows but they should all join off of something common... Also a big question to ask is this "how many things might yield more than one result?" For example - phone numbers... Rather than having home, cell and work columns you can create a second table that ties by client_id and also labels what the phone type is (with minimal data). This means for people w/ 1 phone number there's not two empty fields... for people with 8 numbers, there's not a shortage of info
For me is really strange that most of these markdown parsers doesn't have complete options what to parse and what not on user level. :) OK, simplest (and ugly) solution is to use say Parsedown and then remove unwanted tags using strip_tags function. Ex: `strip_tags($val, "&lt;strong&gt;,&lt;ul&gt;,&lt;li&gt;,&lt;p&gt;,&lt;br&gt;,&lt;br/&gt;") in my case.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
How are your ratings stored? You can probably group by a field (product id), then cache that for how often you want it to update (five mins?) and serve the list from your cache. 
Thank you for replying but actually I am not an advance level of PHP programmer.I do know basics of PHP programming.Do You know where i can learn to make such rating system with and displaying them with the help of PHP?
I disagree with the one about long functions. If something needs 345 lines to work properly, then it needs 345 lines to work properly. Splitting the function into smaller functions just means you'll have to read the 345 lines in multiple places instead of all in one place. Why not just add comments to describe what is happening in each section of the function?
if it was too long, maybe it just doing too much, and better to split it
That's just not true. If a method needs 345 lines to do something then you need to rethink the method, maybe even the whole problem that you want to solve. Of course adding comments to that particular method would help, but you should never have a method that big. Usually in that case a method is doing too much things at once and they can all be split up into classes and methods probably.
https://github.com/cakephp/database
The post starts good, giving alternatives and stuff. After a few paragraphs it starts reading like someone throwing a tantrum. Arguably all these points you mention are good, but you give almost no arguments for them. Why are long functions bad? In which cases are switch cases preferred? Etc. I feel your pain. I have a team mate who does a a lot of these things. My favorite is `if ($num_rows &gt; 0 &amp;&amp; $num_rows == 1)` 
This isn't a PHP problem. It's more about how to store the information. I suggest looking for an existing plugin for your e-commerce platform. If you can't be persuaded to use an existing system, look at *any* examples. The architecture of a rating system is not dependent on the language of the application.
When there is absolutely no clear way to separate a function without just arbitrarily splitting it, then maybe don't do it. I could see this being the case when working on an graphics-related code. This is not the case 99.999% of the time.
Here, let me emphasize the relevant part of the quote. &gt; So before you get overconfident that you know the right way to do things, **consider** that you're arguing against things that 2 very successful developers encourage. 
Which means you missed their point and I encourage you to do some research on your own. And your comment about Jonathan Blow is bullshit. The dude's a millionaire and the author of his own programming language. Don't disrespect his achievements just because he has a belief you disagree with.
&gt; ## Slow PHP built-in functions &gt; ### isset vs is_null &gt; Function isset is 20 times faster to check whether a variable is null compared to is_null function. The speed difference is so small as to be unnoticeable in the vast majority of circumstances. In this kind of scenario, choose which makes the code clearer and correct, not which is microseconds faster, unless you've profiled it and this is very hot code where calling `is_null` is taking a lot of time. Also, at least if you fully-qualify it (`\is_null` not `is_null`), the `is_null` function is much faster in PHP 7 (though I don't know if it's faster or slower than `isset`), which erases the function call at compile-time and replaces it with a type checking opcode. &gt; ### isset vs array_key_exists Again, the speed difference doesn't matter at this scale. But also, these two constructs do different things. There are circumstances where you wish to check for a key's existence and whether it is null is irrelevant. &gt; ## Wrong function / class name casing Sometimes doing it the “wrong” way can aid readability. A good example is the Gd functions, e.g. `imagecreatefromgd2part()` (the canonical name) vs. `imageCreateFromGd2Part()`.
Being a millionaire is not a qualification of anything. There are plenty of examples of self made millionaires making their cash the wrong way. Also take a look at Github, a lot of people have started creating their own languages. While I applause this, it doesn't mean they are qualified experts.
I wanted to say pretty much the same thing as you did, but you managed to phrase it a lot better than I would. Haven an upvote. Felt exactly the same way. promising start, that turned into a pointless rant after a few paragraphs. "I don't understand this" is not an argument for bad coding, it's an argument a bad coder makes... 
Imho there's a small but vital difference between "they code ineffectively and I want them to do it better" and "I don't like their style, they should do it my way" If you insist on "that's my style, do it like I say", you will piss of your underlings pretty fast. But if you honestly offer advice on best practices and talk them through how their version causes problems yours doesn't, you might be able to guide them towards working more in unison. My personal suggestion would be to talk code through with the developer that wrote it. If you find constructs you personally don't like, ask them why they did it the way they did. Offer your opinion on how you would have done it and why. This might cause you some extra work early on, but if the points you are making are good, the developers will use them and the need for you to interfere will be less and less over time. In the end, they work for you and they have to deliver the product you want. Just make sure that what you want is reasonable and communicate it as good as you can. 
That's also the point that I meant. Of course there are situations where it's appropriate to do those kind of things. However in most cases it's usually a sign that one method is doing way too much. A lot of algorithms, for example sort algorithms are like 20 lines max.
&gt; If something needs 345 lines to work properly, then it needs 345 lines to work properly. This is only allowable because you're new. If you'd been programming for a number of years and you said this you would be inexcusably wrong.
Step 1: save the ratings. Usually done in a UserID,ProductID Couple to prevent users from voting more than once on a product. If you accept anonymous votes too, you might do it a bit different though. Step 2: Create View in DB that shows ProductID with Count() of Ratings. Step 3: make a query on the view, ordered by Count Descending. Print out as many products as you want. 
Then you miss the point as well. It isn't just about understanding a single algorithm, it's about being able to see the mutation of the state happen explicitly. If half of it's in a function, you don't see it. There's an infamous memo that Carmack sent out in which he talks about inlining some code and catching several bugs as a result. he didn't inline it because it was all a single 20 line algorithm, and he didn't fix the bugs because the only value of a long function is in it being a single algorithm. If you don't get that, you missed the point.
But I did, so let me hear you explain why we shouldn't listen to carmack. I mean, carmack is also a millionaire, so lets hear it.
Because apparently "is superior for understanding" doesn't fall under "readable and maintainable" if you're writing "business code".
I'd like to add on this and say that isset and is_null purposes are entirely different. Sure you can check if it's null using isset, but at the same time, what happens if you really need to know if a variable is now null? isset with a string inside will return true, breaking everything below because you depended on having that variable a value of null.
I think I already did. A millionaire or founding developer of a programming language does not equate to being right all the time. You're telling me you agree with every single thing that DHH has uttered? You think Lerdorf did it absolutely right the first time? No. The second? No. I am NOT saying that these figures don't contribute in mammoth ways, or that they shouldn't be listened to. What I am saying is It is okay to have one's own opinion and disagree with such personalities.
I think I'm going to quote what I said at the start so you stop with this strawman. &gt; So before you get overconfident that you know the right way to do things, **consider** that you're arguing against things that 2 very successful developers encourage. And just in case it wasn't clear. **they're millionaires off of the software they wrote**, hence... successful.
He lost me at "unnecessary casting". In a language with type coercion that appears to rely on the PRNG to determine whether a given value should behave as a string, an integer, or a small Ukranian housecat, I'm going to be real forgiving of programmers who hedge their bets. 
Make sure it is in some sort of version control. Tag it as a semantic version the first day you inherit it. Do a deep dive code review. Document all the things. Write tests. Start with your most commonly used pieces that perform the heavy lifting of your business logic. Solicited feedback (pros/cons) from your stakeholders (internal/external.) Document these and create issues. Refactor your biggest pain points. Using a profiling tool like Blackfire will help identify these. Iterate, iterate, iterate.
That's all well and good, but do you think that as the only developer there he'll know how to do most of that? That will take quite a bit of research on his part, and you just know that the company is going to start asking questions along the lines of "Why is feature X, Y, and Z taking so long?"
Totally agree, pull request/code reviews are great tools for getting a team pulling in the same direction. The team learns from each other and it means the team is responsible for code not an individual 
&gt; These categories never change In theory they won't, and in theory we don't need security belts in our cars, but if you plan on using this in real life, assume that they might. With example 1, if you need to change a category name you have to update all records. It's possible to let errors slip in because nothing enforces that all fields use corresponding name. This could also be seen as an advantage if you want to update a category name for a single post without side effects. However I've seen several of these tables end up with inconsistent data. `category A` vs `CategoryA` vs `Category a`. So I'd say: avoid it if you can. Example 2 has the advantage of having a single source of truth, which makes it easy to rename a category across the app by editing one single field. The added complexity is minimal. I'd also take good note that even then, it still has a limitation where a post cannot belong to 2 categories simultaneously (which could be solved with a join table). [You can learn more about Database Normalization on wikipedia](https://en.wikipedia.org/wiki/Database_normalization)
Use Git as much as possible to keep track of everything you do, but also because your clients will change their minds asking to remove features and restore them. Also try to enforce usage of a project management and a ticket system to report issues and ask for features. Try not to making any change to existing code base without grasping the whole impact of it. How would it impact reporting systems, ETLs, how nontechnical people read and understand new changes, etc. Do not work or start project in a freestyle fashion. Do it in a structured manner with roadmaps, list of requirements, or better, with [Behavioural Driven Development](https://en.m.wikipedia.org/wiki/Behavior-driven_development) which is meant to make you inline with what non technical, technical and programmers say and understand. Keep track and minutes of all what is said in meetings. You are mostlikly the only one who has a clue about programming, so you will have freedom to work however you please. But you should be good at managing people. These are all problems I am facing because I am a junior, single developer at $EMPLOYER. Have I said it? Keep record of everything. Edit: in the first days, try to solve problems quickly to give a better impression of yourself. This means you can probably start fixing the smaller bugs or implementing simple features.
Thanks for that useless piece of information. 
Hi. Terminology nazi, here. All tables are "relational". A table row is referred to as a "relation". It doesn't mean two or more tables are connected via foreign keys.
Tables with a "relationship". Even native speakers confuse these terms, so I'm simply spreading the word, no worries.
That's a very amateur move, using your own custom casing for a defined function name or class... 
That's, like, their opinion, man. There are more ways than one to skin a cat. 
in addition, there are many cases where you cannot replace this with a switch statement.
I mean for, for instance, showing a message when there are no results for a query result or what have you. 
Too many parentheses and brackets? Although I suppose it's possible, I've never seen parentheses or brackets do anything but make the code more readable.
&gt; I actually spent the best part of a year building a point of sale application with PHP-GTK, 'back in the day'. Here are some screenshots I uploaded a while back That's actually not a bad looking thing ... I'm annoyed that I'll no longer be able to say I don't know of anyone who deployed PHP-GTK :) It wasn't me who experienced the crashes, just fyi .... &gt; The documentation was basically crap The amount of effort required to write good documentation easily exceeds the effort required to write good code, I'm not excusing crappy docs, I'm just trying to explain why the authors would go to all the effort of writing the code, and fail to document it to a decent standard. It's also kind of expected that the community will come and fill in the documentation ... I have spent a bunch of time on documentation already, and intend to do examples with screenshots, having just found out it's okay to put images in the manual. &gt; In retrospect it probably wasn't the best choice of tool Everything (that I know of) that has come before this suffers from some serious problem, either it is extremely complicated (and so fragile), or it is extremely resource hungry (and so not viable for deployment), or it is limited in some serious way. Driven by the ethos of andlabs themselves, to create a simple library, and aided by the marvellous environment that is PHP 7, this extension is none of those things. What we have here is unique among it's competitors in php-land, in it's usability, it's simplicity ... I'm really quite excited about this extension ... it's not obvious from the four paragraphs I wrote about it, but we do have something here ...
It did. I'm 39, and I could retire if I wanted. Just sayin'
What do you expect how long you will work on this project? If it is a long term project you should try to work on quality measures like code reviews or pairing. You can end up working a decade with that code and peers, so you should try to prepare for it. If it is a prototype or just a contract one shot I wouldn't mind that much.
My best advice here would be *learn how to interactively debug* php using a proper IDE, it will help you to understand things under the hood and going to the point [of completing tasks] in your new duty. I mean learning to use a ["debugging tool" besides "logging" and "printlining"](https://github.com/braydie/HowToBeAProgrammer/blob/master/en/1-Beginner/Personal-Skills/01-Learn%20To%20Debug.md) as stated there. The code base has not been written by you so you won't be comfortable with it. I don't know if it has been written using a framework, but chances are it's not the framework you're comfortable with, or no framework at all. And anyway, sometimes the logic of any program turns 'funny' if it's not been written by you. People complaining about "this code is unreadable" comes to mind. Sure, there are fellows that sometimes code with their feet. But "probably" the code is inside a function/method. Stop bitching and start debugging to get the job done. Fight on practices later. So just [don't be afraid of other people's code](http://www.phpthewrongway.com/#being-afraid-of-other-peoples-code). Learn. To. Debug. Today. Depending on the setup, you'll have to learn to do "remote debugging" (project not hosted locally for many reasons, but you'll be able to have php 'talk' to your IDE). My two cents.
Can you justify why?
Yup. Code review for technique. And use an automated style bot like StyleCI to correct style.
You need to learn very quickly how to manage business interests with your time. They are going to hassle you to do stuff quickly, and you need to learn to set some reasonable timescales for the things they ask you to do. Good luck.
well, comments should describe *why*, not *how*. so you may still need a comment.
I think it all depends a lot on what is wanted or needed. I could imagine a system working on a view of posts-table being reduced to distinct category-names. In small projects that might suffice for a category-listing. But of course, every implementation brings other risks with it, so you'll always have to assess them in regards to your current situation. 
&gt; Or, knowing it's php, count will probably have some weird side effect. foreach. It will throw warning on non-arrays. Probably, this check is better done with is_array(). But in case, if there is some code before or after foreach, that must not been executed on empty array, usage of count&gt;0 is righteous.
I've never found a (mysql) way to enforce a maximum number of telephone numbers (say 4) other than via a stored procedure or some business logic code in the app.
Sure, but they're commonly referred to as memes. 
By this logic if your program does something, then all its code is neede so it must be in one function. In your 345 lines function you will be easily see parts which do some concrete part of the work, which can be factored out to separate function and if you name it properly you will not lose clarity, but it will conveyed by a single name of the function not ten lines of code with implementation. See this: https://www.youtube.com/watch?v=8bZh5LMaSmE She uses Ruby in her talk, but it does not matter, it's ideas that matter.
bro I'm 40 and I could've retired at 20.
Weird, I didn't know that any of those guys were web devs. TIL.
&gt; Can we possibly get over memes? http://i3.kym-cdn.com/entries/icons/original/000/007/423/untitle.JPG
&gt;Why are long functions bad? He touched on it: They are generally harder to understand. A function should aim to do one thing and do it well. If you are writing 1000 line functions then chances are you are not following good DRY practices and are going insane with your [possible execution paths](https://en.wikipedia.org/wiki/Cyclomatic_complexity). I aim to get my functions to fit within my viewport. If I can't do that then I see if there is anything that can justify being broken out into reusable helper functions or refactored to be simplified. Does a long function *always* mean this? No, but most of the time it does. &gt;In which cases are switch cases preferred? My general rule of thumb is if it's 3 or more ifs checking the same variable it should be a switch. There is no technical reason behind this other than a switch statement is more semantic and easier to read for what is being done in that block of code.
Implement git hooks to automatically format committed code. It won't matter what style they use then.
 If ($var === null) Why is there a function for that anyway? 
I've seen something like this happen because of redis going out of memory and started to randomly evict keys.
You're a meme.
You could give https://github.com/phpro/grumphp a try. Its a nice quality control addition to any project.
Are users actually inheriting sessions or could it be a server cache? Maybe you could post your phpinfo so we could get a little more info?
In addition to the other comments: are you running Php-fpm? We had the issue of it happening due to pools being reset/flushed
Server is using suPHP. It's a WHM installation running easyapache 4 so I could only use suPHP and CGI handlers.
Not on the same IP. It just happens randomly from what I can tell so far. It happens on completely different sites. One is a vbulletin car forum, other is a porn site, and both sites got reports of the same problem. 
He's such a cute little fluffball, I think the original owner named him [Paamayim Neko-Dotayim](http://php.net/manual/en/language.oop5.paamayim-nekudotayim.php) :P
You mean preventing someone from adding 100 numbers to their account in some sort of CMS or profile editor? If you want to cap things, you can include a cap in the table table name... there's weird hacks you can do...
You need to stop posting these. Learn about modern design patterns and best practices before making any new videos. No one should be encouraged to write code like this. http://www.phptherightway.com, http://knpuniversity.com, and https://laracasts.com are all great free or low cost resources to get you started. Please take this advice to heart and don't just reply with LOL like you've done before
Isn't that the whole point? Checking against `count($var)` is a bad idea, you should use `is_array($var)` instead. 
Are you using standard sessions, or something custom? Have you checked the session settings in php.ini?
Standard sessions and php.ini has default settings from what I could tell when checking.
Teach them English. Then teach then PHP.
You said you've got multiple sites running one on server. Are there multiple php installs sharing the same file system location for session storage? Also, it could be something as simple as over aggressive HTML caching if you're using that. But if you said these users can actually create forum posts on other accounts that points towards session collisions or some other session problem. 
Agreed. There's nothing I hate more than reading in-line conditionals, especially when the instruction is quite complicated.
You can choose between PSR-0, PSR-1 and PSR-2? That doesn't make much sense. PSR-0 is an autoloading standard, and PSR-1 and PSR-2 are not alternative standards, they're two parts of the same FIG coding standard.
Just want to re-iterate what others have said - you need to use pull requests and code reviews. The key is to be a coach and a leader - don't simply dictate what the revised code should be, you really need to take time to explain *why*, so that your juniors start to understand. You also want to make sure you have a linter, because nothing is bogs down a code review more than comments about formatting and code style. A linter should enforce the code style so that you never have to talk about spacing or where the opening brace of a function should go. Further, you have to be sensitive to the motivation loss that *will* happen as a result of code reviews. Juniors are often proud of the work they do, and a code review (no matter how polite or tactful) will obliterate that feeling of accomplishment and suck any sense of ownership out of that code. This can hurt their productivity quite a bit, because they'll be worried about writing code that will pass muster during a code review, and may feel like anything they write will just be changed anyway (or they'll start bugging you for your advice/recommendations on every little thing). It's really important to be mindful of this, and limit your comments to fact-based issues (e.g. security, performance, bugs etc). It may be good to bring up code clarity if the code is really hard to understand and could be dramatically simpler, but that gets into a gray area of stomping on code style, which is what can suck motivation out of your developers.
&gt; These categories never change Famous last words...
Well, there are three possible reasons: * 'Consistency', something we know PHP isn't known for. But, again if you have is_int, is_bool, etc. it makes sense. Makes reading a bit easy on the eyes as well I think * Squeezing performance. Though we're talking in a 0.002ms difference, even though that's bullshit and doesn't matter, is_null is faster on PHP7.0. 7.1 seems to be slower for now. (PHP &lt;= 5.6 is_null was 4 times slower than ===) * You never know when is_null might perform some extra operation or optimization under the hood, that's something that could change in the future, or not.
Technically speaking, [they are.](https://www.youtube.com/watch?v=HV9WEqLeBuo) edit: grammar
&gt; or could I get away by just using the strings? The biggest issue in this thread is that by using strings, you're developing bad habits. Strings will be just fine for your blog... but your next project is going to be a little bigger, and the next one bigger again, and for every project, you're going to think, "I wonder if this project is big enough that I should do it the **right** way." If you do it the right way every time, from the beginning, you'll never have to wonder. And when everyone else is making shitty code, you'll know that yours is lean and efficient. Searching databases for numbers (especially integers) when you have an index on the field, is about as close to instantaneous as you're ever going to see. Searching strings as in: select id from posts where category='category a' ... is about the worst, slowest, ugliest thing you can do. The database has to compare "c" to "c", and then "a" to "a", and then "t" to "t"... all the way to the last letter. Moreover, there's no reason for it. You're doing it wrong so that... what? You can save yourself 15 keystrokes when you're coding the site? Someone pointed out that additional relational fields makes the code harder to read. You can build stored procedures on the database table itself so that when you SELECT the id NUMBER from the table, it automagically looks up and returns the NAME of the category instead. Code readability is not a good reason to do it the wrong way. There will be times to break the rules and do things "wrong"... but this isn't one of those times. Another person said that "categories never change" are famous last words. This is not only true but it's also another good habit to develop early: realizing that no matter whether you're building this for yourself or for a client, plans made early on change VERY often. Put another way: the time it takes to fix a lazy design decision is always about 20 times longer than it would take to do it right from the beginning. So, yes, for this project, strings are just fine. But don't do it. 
I trusted this was going to be fixed two years ago. Guess I was wrong.
We had the same problem a few years ago. Turned out caching was at fault. We had a couple of sites on one server (Drupal6 multisite setup back then) that were connected by a SingleSignOn Mechanism. We served images from the different domains after login, so each domain could set a cookie. The url to the images also included a "session id". Due to the caching all users were served the same images for a few minutes. Every login was served the same "session id"... Maybe your problem is not PHP5.6 related, but related to changes in server or site settings?
This is a shot in the dark, but is `session.entropy_file` set to `/dev/urandom` and `session.entropy_length` set to a value &gt;= 32?
Blow and Carmack both develop games where you constantly have to solve (complex) math problems, not write business logic like "give me these variables and I will render a template for you" like that smarty code. It makes perfect sense to extract parts of that into private methods like `findTemplateDirs()`, `findTemplateInDir()` `replaceParametersInTemplate()` and stuff like that instead of cramming it all into one big method, because then you don't have to look into these methods to understand what render does. They _tell_ you. Do you have to look into the php source to understand what `array_merge()` does? No, the function name tells you and you can stay in your code and move to the next line. In the rare cases where you want to delve deeper you have another small function that's easy to grasp. edit: since you already had the argument about how their methods still apply. In game you write code that's optimized for performance and especially if it's deep in the game engine the requirements won't change as often, as in web development where you deal with a constant barrage of business requirements that might conflict with old decisions. That's why it's a common tone that you write code that's easy to reason with and easy to replace should change come. If you consider that example from smarty: instead of rendering from a file on your filesystem your business decides to move templates into an S3 bucket so that different apps can share them (for whatever reason, let's say it's a template for generating invoices or a letter head) You now have to go through 345 lines of code to find where the data is fetched from the file system, how it's done, if everything still works after your changes. Instead of having your 2 small functions `findTemplateDirs()`, `findTemplateInDir()`. It's arguably quicker to change and as long as input and output have the same type you don't have to worry that the rest of the code is borked. You can even introduce a new abstraction for filesystem or s3 and let those methods use that instead. Now you can easily test those abstractions against filesystem or s3 and your render will be able to fetch your templates as long as those adapters work. Splitting up a large function into it's smaller parts just makes things easier. You might still end up with larger methods in some places, but those should be very limited and have very little logic. Factories and Builders can grow when you deal with larger object(-graph)s and splitting them up might not make sense there and it's all pretty much all assignments so it's easy to see what happens despite the size. Going for smaller functions in web development surely has it's benefits and saying "I will keep this 345 line blob because John Carmack does so in his code" is probably a bad idea, because I bet you can split that into smaller things with a nice name instead.He can't because it's part of the mathematical problem he solves and it's probably necessary to understand what happens in that part of the equation and if you have to change it, it probably affects the bigger problem as well. That's why their methodology makes sense in their niche, but is usually inappropriate in web/business context.
Can you explain that technique in a bit more detail? How does changing a table name enforce a database rule?
Same here, and I tend to use $desc for "descriptor" or less, $cfg for "config". 
PhpStorm
Yes. JetBrains or nothing. 
Can you update your post when you find a solution, please? I would love to know what is the reason behind this issue.
Thanks. Do you think eclipse is generally a better IDE than netbeans for php programming?
You can also see they don't use the class, because the constructor is private. They could still instanciate it with reflexion, but anyway.. I don't know why an interface over a class, or vice versa. I have one theory, which i never tried the implementation, so it may be false. It goes like this, if you have an interface of constants, you maybe can implement it in another class and overwrite these constants, for anyone who would access this class `MyImplementedClassOfThisInterfaceWhichHadOnlyTheConstantsYouTalkAbout::foo`, which was set to `bar`, but now to `BAR`, all caps lock!! So maybe, just maybe, it is to mentally ensure that these constants will stay constant across every dimension of their codebase. By adding a "final" for the class, a "private" for the constructor, and a "const" for the constants (instead of static for example)
But then you would use the class for getting the constant, but if you would still continue using the interface for constants, would the problem you described exist only when using self in the context of the class who implemented the interface 
The site probably uses [PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) to "fix" the code, which categorize its fixers into the levels PSR-0, PSR-1, PSR-2, symfony and contrib.
It depends, if you want to have the option to override the constant use an interface but if the constant should never be changed then use the final class
Create a `final class` and mark it as a [static class](https://github.com/ScriptFUSION/StaticClass) with `use StaticClass`. This creates the most correct semantics because the class cannot be extended nor instantiated; only its public constants can be accessed. An interface can always be implemented which is not what is intended here.
&gt; override the constant I don't think you understand what is meant by *constant*.
Ctags is the basis for this functionality. Any ide that will let you use ctags via a plugin will work, including sublime text, atom or any other modern editor/ide. Trigger local association via docbloc, comments etc
Netbeans does support this, but sometimes it struggles to introspect property references on `$this`. There are two possible solutions: 1. Where `$load` is defined, or in the controller where you use it, add this just inside the class definition: /* @var $load WhateverClassThisIs */ This would probably be nicest in the CodeIgniter core, so if you find this works please submit a PR to the project (assuming they are maintaining the current version). 2. I tend to think of property usage as a bit messy anyway, and much prefer getters: /** * @return WhateverClassThisIs */ public function getLoad() { return $this-&gt;load; } You will then be able to do `$this-&gt;getLoad()-&gt;library('utils');`. 
It's a cache or cookies issue. Check cookies first as that should be simple to do, then check your cache setup, how often it's refreshed etc. Also look at server space on the new server, if it's ran out/running out of space, this may be causing your problem.
Extending a class allows you to overload the constant value.
I have to assume they don't use an interface because the interface could be implemented and the constant value changed. The Symfony implementation **is** the OO alternative to `define`.
You seem to have misunderstood. The general advice in pgrogrammer culture is a function that does only one thing (even though the actual guideline is one *responsibility*) - something you yourself have echoed. If you follow that rule of thumb to its logical conclusion, a function with 10 data transformations or validation checks or what have you, becomes 10 different functions. I've seen this in many different code bases, and was guilty of it myself at one point. So my point is simply general advice to the broader community that simplifying functions doesn't come for free, and that ***blind*** pursuit of "do one thing" causes more problems than it often solves (and not just infrequently either - it should be the norm that you DONT extract code, and only do so when there is clear benefit)
You want /r/PHPhelp 
Alright, now I have something I can Google at least, thanks thats ag reat start, if any other have info that might help out too please let me know :)) &lt;3
Not a PHP question.
Thank you very much!
I don't have a lot experience in netbeans so I can't give competent answer. But Eclipse definitely good _for me_ because I am not pure PHP programmer. I need support for C++, Java, D, PHP, web stack including Javascript, database management, and some less popular things (for example, sometimes I work with diagrams in .dot) and "One IDE to rule them all". For example, right now I am porting my old PHP code to D project. Huge amount of extensions for every case makes it convenient for such cases.
Blackfire will help finding problems much faster in my experience. The graph view is pretty amazing to visualize code flow and the colors instantly tell you which part is consuming time (darker is longer). It will give you time spent on each part more accurately and easily as well as find callers/callees without digging through the whole xdebug tree. It also gives you info on networking/curl calls, SQL, etc. Not to mention Blackfire can be left "on" in production and won't impact performance by a iota as opposed to xdebug causing trouble (so you can find bottlenecks that might only appear in production). It's all-around a much nicer tool and in my case it paid itself in no time. The only thing I wish it had is better IDE integration, but that hasn't proved problematic at all in practice.
So when I want to create limited numbers, I could store the max number in the name... phone_numbers_04 and then to reference the number, you always go back the last two chars and convert them. It's a bit convoluted but it works. I personally keep info like that in another small table so I can update them if i change my mind... better than hard-coding
Is it actually using memcache then? Default is file. What are these set to? session.save_handler string Set to memcached to enable sessions support. session.save_path string Defines a comma separated of hostname:port entries to use for session server pool, for example "sess1:11211, sess2:11211". 
Just stating what the language allows, not what is good practice. ;)
I have been using NetBeans for PHP for ages (7 years I think). Last month I've tried PhpStorm and it was instant love. After a week or so I've bought a license for 199€ (not cheap). It's my second paid license ever after Winamp. 
A function should only do one thing, but that doesn't literally mean one operation per function (inb4 mozilla). It means if your function is supposed to pull a data record it shouldn't also be updating that record. If your function is compiling a list of all a given user's assets it shouldn't also be responsible for the authentication flow for the 3rd party social media integration. BUT, given your two examples (data transformation and validation), I would argue those should be standalone because things like that are prime candidates for code reuse... unless the function doing the transformation and validation is the "getFancyRecord" method to begin with. Take a look at this https://github.com/OpenHUE/bsb002-lklm_qca-nss-ecm/blob/master/frontends/nss/ecm_nss_non_ported_ipv4.c#L1712?again This function doesn't do much. It's almost a thousand lines long and highly repetitive. You're arguing something like this is more readable than breaking each distinct group of logic out into a clearly named, parameterized, and documented function of its own.
8 pillars and something like 32 variations. Its just a big bucket of buzzwords. Would be nice to have some details, it feels like a school paper.
Strings are great - perfect in fact - for tons of situations. I can't exactly list every time it's right and wrong, you'll get a feel for it. Fortunately, you already know how to create and use related tables so you're way ahead of the game already. To show you what I mean by, "you'll get a feel for it", here's a few examples of good, bad, and when you might want to make an exception. 1. Good uses strings: people's first and last names. Their email address. The words that they want engraved on the vase they're buying from your site. 2. Bad use of strings: Something that is frequently used as a search field AND the text should always be spelled exactly the same to avoid confusion AND you can mostly define the list up front. 3. When you might make exceptions: If you wanted people to be able to creatively express themselves by spelling their car's name any way they like: Chevy, Chevrolet, and Chev-roll-it-away, then you'd want to use strings. (Of course, in that case, it would be unlikely that people would be using it as a search field anyway - it's really more of a description of what they think of the car.) But a web site like AutoTrader.com *couldn't* let people spell Chevy any way they want because then the searchability of the site would be broken. So you have to make a judgement call. 4. Another time you might make an exception. Cities and states. For states, there are only 50 and they are only 2 characters and if you index on the field it will be super fast so a string would be ok. Towns *could* be done as ID numbers in a related table but the problem is that you'd have to acquire the list, it's a huge list, and since you don't search on that field very often, it's probably not worth the effort. There are 19K towns and your site might only use 600 of them so it might not be worth the effort. Of course, if you're Amazon.com, then you might decide that there's enough benefit to enforcing consistent spelling (and storing each city's sales tax) that it *is* worth the effort. Judgement call. It's just a matter of practice and experience. When it's not too much extra work, it can't hurt to do it the right way. In the case of your blog categories, this does not create much extra work for you so, in my personal opinion - the way I would do it - is to create a related table. 
Canvas might be a good fit. http://canvas.toddaustin.io
I'll add that we've seen updates to the language consistently focused on making namespaces nice to use outside of for classes only. 5.6 introduced `use const`, which is a really handy way to define your constants. It works really nicely with your autoloader, so devs don't need to know which exact class/file you've put all your constants in, and could instead do e.g. `use const MyProj\WebService\ENDPOINT_URL;`. 7.0 gave use the ability to group, which is really handy for constants, since you'll often want to import a bunch from the same place, e.g. `use const MyPRoj\WebService\{ENDPOINT_URL, API_KEY, TIMEOUT};`.
I thought it was because the "includes" approach gave people brain cancer for being so awful to attempt to follow and look at?
Nah, not brain cancer. Performance.
Can't you make one without any fancy frameworks?
Because he missed the date by 7 years?
This may be the most important, number 1 good piece of advice for any beginning or intermediate programmer. I can't tell you how much easier it is to understand a new system/piece of software when being able to step through every single line of code as it is happening.
&gt; In game you write code that's optimized for performance I stopped reading here. Both of them have talked about finding bugs and increasing understanding of the code by inlining functions. That's applicable no matter what you're doing. Nothing you say will change that. 
count($a)
To add to this, best practice is generally to count the elements outside of your loop condition and store them in a variable to avoid count() being called every time the loop is run.
https://en.wikipedia.org/wiki/Foobar Sounds like the assignment wants you to define a function named "foo" that multiplies a value n times.
You know what happens then? "We use platform X, so now, we want our blog on platform X. So make the platform have blogging capabilities. Even though it is an ecommerce engine."
This test sounds stupid, because your function satisfies the requirements. It sounds like they want you to use recursion, but aren't being clear about it.
Everyone was a beginner...
I use plupload. 
It's pillars, not an in depth tutorial. And What buzzwords? Those are all real concrete things that you can look up and find tutorials on. I think it's a pretty good article.
How about a static site generator. See [www.staticgen.com](https://www.staticgen.com/)
Hey Guys, Starting to add some tests and merging in Pull Requests. First off, I'm really happy with the response that Voyager has gotten. Second off, to the people who have nothing but negative things to say about the project, if you think you can do better go ahead and do it. Or, if you want to help make this project better then thank you, we can all create some cool stuff together. Bottom line is I started creating this project about 6 months ago and instead of trying to make profit from it, I thought it would be cool to release as open source. Yes... It's not perfect and I'm hoping with help and some constructive (and polite) criticism we can make this project even better. Thanks to everyone who has already submitted pull requests to improve this package. I really appreciate the help and I'm excited to see this project grow :)
Is there a best practice that says this? I've never heard this.
Actually, no. `file_get_contents()` is a convenience function that takes any [stream](http://ru.php.net/manual/en/ref.stream.php) and returns it's contents. It works fine with any of the [supported protocols](http://ru.php.net/manual/en/wrappers.php). [edit] Equivalent to `fopen()` followed by `stream_get_contents()` and `fclose()`.
&gt;It supports URL's, but should only be for testing and basic scripts, not in an actual application. . &gt;file_get_contents() is a convenience function that takes any stream and returns it's contents. It works fine with any of the supported protocols. Thats the point. There are better, more obvious solutions.
As /u/plectid says, `file_get_contents()` is a simple wrapper around a common set of stream I/O operations. Streams a perfectly fine tool to use for any kind of I/O, although the naming convention in this case is perhaps not great. While the traditional _C_ functions on which all the `fopen()` etc. functions are modeled after are most definitely for files, PHP has completely abstracted this away. The streams layer is more than competent enough for low-level UDP/TCP/UNIX Socket/File communication. Even supporting the ability to multiplex them for parallel communication. Furthermore, the streams layer has the ability to filter content transparently, and the ability to define custom stream handlers and filters — making it incredibly easy to write transparent I/O transports that anyone can use as drop-in replacements for standard file I/O. **Having said that**: I love curl, and would highly recommend it, as well as Guzzle :D 
You might like [AnchorCMS](https://anchorcms.com/)
http://php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen This is likely turned off on the server, easiest solution is just to stick to curl for http.
The objection to your comment is that you imply that it is a bad idea/choice/solution to use `file_get_contents` for this problem and that just isn't the case. The consensus seems to be that people `like` cURL with guzzle as a solution better but that doesn't mean one solution is actually better than the other. Liking one solution over another doesn't mean that one is inherently is `better`than the other. They are both valid solutions to the problem.
Not really, thats why Lumen exists.
"best answer in any php context"
Can't say (NDA), but probably very soon.
As someone who is stuck developing for various "vintages" of CentOS, the Remi repos have been the only things that keep me sane. Thanks!
Hmm. Maybe it's an HTTP/1.1 issue?
About damn time.
The Remi repos make Skibby a happy employee.
Consistency and functional programming.
Surely you mean XmlHttpSender.
Thanks. I'm familiar with how it is supposed to work. I have tried the .htaccess file that comes with Laravel. It did not work. I had not thought of using WordPress to figure it out. I will give that a look.
Just use wkhtmltopdf
Wut?
I heard someone point out that it currently doesn't allow variance in inheritance (i.e. if you say `: object` in a parent class, you can't narrow to `: MyClass` in a subclass), which is unfortunate. Hopefully that can be fixed still; generally we try to have covariance and contravariance supported where it's not too difficult to do.
While we appreciate the effort, this is not the place for beginner tutorials.
This is already the case with normal parameter typehinting, isn't it?
The main reason from my experience, is putting function names or class names in a hash map, perhaps for whitelisting or preprocessing purposes. If you aren't consistent you could run into problems when isset is called on the hashmap; the casing must be exact or it will be considered a different key. Class autoloading strategies also come to mind. 
Will the following packages also be available with PHP 7.0.10? (showing the 5.6 package names) php56w-pspell php56w-mssql
* What is a good way to learn about MVC using PHP??; while looking for it i found that everyone does their own thing and im just completly lost on what is at least a correct way to do it. * Do i only have to do logic on the Controller? * Does this mean that the only use for classes is on the Controller/Model ? * How do i manage Autoload with and MVC enviroment? Im sorry if this just feel like really dumb or weird question but since many resources i have found about MVC have so many approaches i don't know how i should manage all my classes/autoloader + the Architecture , Hell i don't even know if they are right or not.
Ahh sorry, it hadn't crossed my mind that you'd take care of it on a subreddit level. 
yes for pspell, no for mssql as this doesn't exist anymore in PHP 7.0 (and RHEL/CentOS don't have freetds). Notice, I don't consider webtatic is a good solution. RHSCL is an official and supported repository. If you want to use a 3rd party repository, with more extensions, see "remi" repository which provides nearly everything you may want, see https://blog.remirepo.net/pages/PECL-extensions-RPM-status and "remi" is upstream for Fedora/RHEL/RHSCL and so of most other 3rd party repo)
More information: About pspell: https://blog.remirepo.net/post/2016/04/17/aspell-vs-hunspell-in-PHP About SQL server: https://blog.remirepo.net/post/2016/09/20/Microsoft-SQL-Server-from-PHP
If it works only in object context, why not use a trait? https://gist.github.com/mlebkowski/d203ba1bfb0fe8e54adfed5217d32fa9 `private $once` can be changed to `static $once` to avoid issues with serializing the object.
Wow. Is it April the 1st already? Kudos for taking the time to put this together.
And FYI, remi repo have 5.5.38 with security fix ;) (all for now, probably only "moderate" and "critical" ones in the future)
[removed]
First read the github account as"whizpalace"
I recently updated my EMysqli package on Github (https://github.com/noahheck/E_mysqli/) to offer better functionality. The premise of the package is to output a version of a parameterized query with the bound arguments injected into the query string which will facilitate easier debugging, logging, etc. I created this project in response to a request I received on it's sister project (E_PDOStatement: https://github.com/noahheck/E_pdostatement), which provides the same functionality for the PDO extension. Feedback Request I don't have any production quality code for working using the mysqli extension though (all of my work uses PDO), so it's hard for me to come up with any actual, relevant situations to test my extension. Any feedback you can give will be greatly appreciated. Thanks!
Wait, if I defined a constant outside of a class in the same class file, would it not enter the symbol table (from composer's autoloading) and be accessible?
Depends what you mean by “normal”. Classes and interfaces are invariant because the checks needed for covariance are too complex. But other types aren't; you can replace `iterable` with `array` in a subclass.
Oh in that case the htaccess file from WordPress probably won't work either. Are you testing on a live server or localhost? If local maybe you haven't configured Apache or your vhost to allow . htaccess file to work.
Both. It works on local, but not on the remote.
Misleading title. This is not "middleware", it's "allovertheplaceware".
Of course !
I doubt I'd use it, but I like the way that it tackled a general solution, with small code footprint and a small, easy to understand usage. I can appreciate it without thinking it's good for prod
Is there any security issues with it? To me I'm not sure that it's worth it. I mean this function call looks expensive, and I suspect more expensive that calling the function again in most cases. And if your function call is that heavy, you easier messed up somewhere or it would be preferable to have a proper cache layer. But I'm curious to know if there is other implications. 
The interface is compact and elegant, but the only possible implementation is very inefficient, slow and inelegant. In other words, Laravel as usual I guess. No security issues I know of. 
It is not me, and also I just noticed that the author is effectively eliminating the native prepared statement support. So I deleted the link. From what I can tell, it doesn't support NULL values (while it should) and doesn't support ORDER BY clause (and it shouldn't). As of LIMIT, there is only limited support, through bindValue method.
Seconded. The implementation and edge cases are just way too bad for such a weirdly specific function. Also, doesn't look like it handles null return values.
&gt; When an object is destroyed, its hash may be reused for other objects. &gt; http://php.net/manual/en/function.spl-object-hash.php GL dear artisans. Oh wait, we don't have to drill that deep: &lt;?php $code = new stdClass; $code-&gt;artisan = 'sure'; var_dump(spl_object_hash($code)); $code-&gt;artisan = 'nope'; var_dump(spl_object_hash($code)); string(32) "000000004e52f5fe0000000063ecdadf" string(32) "000000004e52f5fe0000000063ecdadf" I don't think that people would expect that memoization will **not** consider object state. Arguably it doesn't even makes sense in an oop heavy environment.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Also, did PHP 6 actually calculate lengths properly for non-BMP codepoints?
And. . .no.
About time since base CentOS installed PHP 5.4
Fair enough, I support this logic. I mean, I was writing my site in notepad and file manager on geocities in 1998... I really haven't evolved since.
Does you main app currently render custom data for each user? Or, is the login basically just to gain access to the website?
Do your pages set appropriate caching headers to avoid being cached? Some users are behind aggressive transparent HTTP caching proxies that can result in them seeing pages destined for other users of the same ISP, if you don't set "no-cache" or "private" cache-control headers as needed. EDIT: Yeah, that's your problem. Look at the headers you're sending! http://i.imgur.com/I0nAxpD.png On the same response that you include a Set-Cookie, you also include Cache-Control: public! People's ISPs will happily cache the page and cookies for you and serve them to other users of that same ISP, even if Cloudflare itself doesn't.
Sorry I didn't answer your question properly, the login is basically just to gain access to the website but it is not connected to the main app yet. At the moment the only login credentials are test ones I made in a phpmyadmin database. The main app just stores text from 4 boxes into a database but the added login feature would help. Ideally the user would be able to register, giving them a unique identifier (email and password) and any values they input into the text boxes after logging will be able to be retrieved by them whenever they wish.
What are the objections that people have to this? It seems harmless and very useful to a well defined set of use cases.
Ok, the easiest way would be to check if a session is opened before you fetch the data for the 4 boxes from the database. If there's no open session, redirect the user to the login page. If there's a session open, get the user's id from the session cookie, and use that to fetch data from the database. https://www.formget.com/login-form-in-php/ https://www.tutorialspoint.com/php/php_login_example.htm edit: wrong first link
Eugh. Not sure I'm keen on that - it practically writes its own entry on a php-bashing site: &gt;PHP parameter and return types are invariant. Except if they are primitive types in which case they're contravariant and covariant. Technically this is a (slightly) more powerful system than making everything invariant, but I'd argue that consistency is a more important feature. Shit, you could even make a decent argument that invariance is the only intuitive-yet-typesafe way of handling types under inheritance, irrespective of implementation limitations. That said, I love that we're living in a time when such a discussion is even relevant to PHP :)
I like that you took the time to reply and answer the actual question, as opposed to just linking a laravel or other framework as an answer. Yes yes, hurray frameworks, don't roll your own logins, etc etc. Sometimes it helps a beginner learn things, though. Anyway, my random thanks :)
yeah I wasn't going to go through all the gobbeldy-gook as soon as I saw how bad it was, yuck. You're the real MVP
Thank you so so much! This session concept is what I needed - if the user logs in, it will create a new session and call in my original app. That's what it sounds like to me but need to investigate it further. Thanks a million, just started with PHP last night for a college project so it's all really new to me!
Why not just make all classes extend from stdClass by default?
As mentioned before, this is a much needed functionality for libraries: * repository abstractions * data mappers * reflectors * hydrators * serializers * identity maps * code generators In domain code, you will not need this, but it's a clear :+1: for the use-cases in infrastructure-oriented code.
`object` is NOT a reserved keyword yet... you can make a `class object {}` in user land right now... so some people are against introducing this in a minor version sidenote, `object` actually is on the reserved keyword list since 7.0 but it does not produce an error when used.
&gt; you can't autoload constants. https://getcomposer.org/doc/04-schema.md#files This is not "auto" load, but you will not have any issue with that.
If you want to do really fancy magic in PHP, I recommend taking a look at AOP - Aspect-Oriented Programming. There is a PHP extension for it, [AOP-PHP](https://github.com/AOP-PHP/AOP). It can be used for so-called cross-cutting concerns, such as logging, caching, authorization or transaction control, that is actions that you want to take on many unrelated classes and functions. This page of the manual provides a nice overview of what you can do with AOP-PHP. https://github.com/AOP-PHP/AOP/blob/master/doc/Contents/chapter2.md It's in my opinion better than (ab)using `debug_backtrace()`, but I would still be very, very careful with this. I think the code could get absolutely incomprehensible if used in a wrong way. Edit: It has been some time since I last looked at available AOP libraries in PHP and AOP-PHP seems unmaintained anymore. This library is newer: https://github.com/goaop/framework http://go.aopphp.com/docs/ But it's written in client-level PHP, I'm not sure about the performance.
Well, he practices YAGNI: &gt; Implement things when you actually need them, never when you just foresee that you need them. He'll fix it after he gets hacked.
But... co/contra-variance should be explicitly specified. I'm not sure why one (typically co-variance) is assumed to be the correct default in these situations. Consider a base class called ListOfObject. When I extend to create ListOfPdo, according to the Liskov substitution principle, I should be able to add any type of object to ListOfPdo. But if the typehints for manipulating items in the list are co-variant, I won't be able to. They have to be invariant or contra-variant.
1) yes, they are my clients that give me money. 2) deliver good work and they'll find you. Good devs are a lot harder to find that you'd think. 
&gt; I'm not sure why one (typically co-variance) is assumed to be the correct default in these situations. Because of the Liskov Substitution Principle. Contravariant return types don't work, nor do covariant parameter types.
Facebook and Twitter make it really easy.
got it, thank you!
Clocks in at 0.00ms on my machine. Every once in a while it comes in at 0.01ms. I'm not sure I would use it myself in production but I don't think it would bomb out your server or anything. Also, this isn't part of Laravel.
People I work with I maintain relationships with. Ex coworkers I'll talk to occasionally. Don't actively maintain those. 
Can't you widen your inputs in subclasses (and loosen outputs; both in accordance with LSP)? I haven't played with that kind of thing in a while and could be wrong, but I could swear that was allowed. Even if that were the case, narrowing inputs on the subclass wouldn't be allowed since that *does* violate LSP. Return types should be fine in principle though.
But then you run into issues where you can't extend any other class
[The code behind this](https://github.com/laravel/framework/pull/16267/files) is deceptively simple. Nice work there!
Occasional get-together with a cup of coffee or tea also keeps relationship healthier. 
[Yes, you are absolutely right. A template engine's render-method must be over 300 lines long.](https://github.com/twigphp/Twig/blob/73e2c68dddd73009f9eec08fe4e1d2c8a4c007cf/lib/Twig/Template.php#L370)
It's nice, but I still prefer Symfony.
Please don't actually use this in production code.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Yes you can achieve similar results regarding the graphs but with more work. 
Agreed. I wouldn't want the 2nd example in my code base. This would be more readable IMHO: `$employees-&gt;reject('retired')-&gt;each('sendPayment')`.
$date [is not documented as public property](https://secure.php.net/manual/en/class.datetime.php), you should not try to access it directly.
One comment on that bug report says: &gt; How I worked around the problem: &gt; &gt; ... &gt; $dt=new DateTime('2016-07-06 00:00:00'); &gt; $tmpObj = (array)($dt); // Only for circumvention, without this line $dt-&gt;date return null. &gt; $dtx = $dt-&gt;date; &gt; echo $dtx; // display: 2016-07-06 00:00:00 &gt; ... What's the need for converting the result to an array() when its already available using `DateTime::format()`?
I don't like relying on strings like `reject('retired')`. "retired" means nothing. It is not a scope, not an enum, nothing. I would do it like this without involving too much magic. $employees-&gt;reject(function ($employee) { return $employee-&gt;isRetired(); })-&gt;forEach(function ($employee) { $employee-&gt;sendPayment(); }); but to be honest, I would take `sendPayment()` out of my employee model because sending payment has nothing to do with employee. I'm sure some people will find this PR handy. It is just a bit weird relying on a chain of attributes to do basic array filtration. 
nice
There's still too much magic for me. Although you could argue that eloquent had the something similar where `-&gt;where('retired', 0)-&gt;get()` is the same as `-&gt;whereRetired(0)-&gt;get()`. Even then, I still try to avoid using this magic. I personally prefer `-&gt;where('retired', 0)`
There are PHP 6 specific applications?
Will this trace/find declaration properly in a good IDE like PHPStorm? I can deal with magic if it doesn't dead end dev's ability to read the code.
&gt; No security issues I know of. If you use it in a security context and you run into the hash collision /u/JackOfAllFates pointed out it could lead to a security issue.
+1 for Git and tracking issues - the two most important things IMO.
Lmao, gold
"Always code as if you want the guy who ends up maintaining your code to become a violent psychopath who will bend over backwards to find out where you live."
well was it retired?
Middlewares. It's all middlewares now.
I added the tests myself and cleaned up the code myself when I pulled down the PR to play with it. 👌 I often do that because I have to merge or close probably 9-10 PRs a day just to break even and not let them start to pile up. 
I wrote the unit tests and cleaned up the code when I pulled down the PR. 
This is the bug https://bugs.php.net/bug.php?id=49382
Ah, ok, I see you work differently than what I'm used to. You merge fast and then you rewrite the incomplete code directly in the master branch. https://github.com/laravel/framework/commit/2b7ab30e0ec56ac4e4093d7f2775da98086c8000 https://github.com/laravel/framework/commit/e276b3d4bf2a124c4eb5975a8a2724b8c806139a We review carefully, write tests, squash commits and only then merge. Whatever works for you, I guess.
No need to take it personally. Your framework is obviously very popular, but I think what you do is quite dangerous. However, as I said: Whatever works for you.
The code behind this doesn't look like this anymore, it's been rewritten in subsequent commits. But you cannot see it in this pull request.
Yeah, real dangerous to add tests literally 2 minutes after merging PR on a branch that won't be released for months. 👍
So, like, a browser ... which is the middleware between the web server and the user? Seems legit.
God to hear that! If you can, I think others would like to see a comparison between 7 and 7.1 as well. 
I'm now at work. I already wanted to do something like that with 5.6, 7 and 7.1 with the same vagrant boxes. But i have to find time first. I only was so surprised and blown away that i had to post this.
Benchmarks are often tricky. You really need to setup a vagrant env for 5.6 before the comparison becomes meaningful and make sure things like xdebug settings are identical. A small config change can often cause huge differences.
So shouldn't it spit out a different error, a fatal error even. 'Cannot access private property'
What is said the configurations aren't identical. And i'm not sure about. I posted this more because i was blown away by the results. - A quick look, i don't have xdebug on my 5.6
Terrible. Relies on heavy php magic usages and totally not IDE friendly... Let alone programmer friendly.
Here are a couple of more or less framework neutral articles that may help: http://symfony.com/doc/current/introduction/from_flat_php_to_symfony2.html http://symfony.com/doc/current/introduction/http_fundamentals.html Instead of MVC focus more on the Request/Response nature of web applications.
I'm still undecided how I will vote but if I vote no it's because of this reason. I am sure there is quite a bit of `class object` out there. I am otherwise for it.
butt hurt teenagers don't laugh all the way to the bank, which should be the case
PHPStorm now has a monthly license subscription like Adobe products. I believe it's about $20/month.
Exactly. 
- Nicely written, comprehensible code - Well commented - I would add class docblocks - I would avoid public properties where possible (in `EMysqliStmt`) - I would format everything according to PSR-2 (spaces instead of tabs) - Well tested - I would move protected methods after the public test methods - Not sure about the use case Good luck.
There's a typo in the "before" screenshot. The variable $invoice is not defined.
Let me get this right. You replaced foreach with three layers of abstractions so that lazy 10xers who don't have snippets in their editors could type less keystrokes?
Damn you seem mad about a feature that is entirely optional and makes code easier to read. Also *fewer keystrokes
&gt; would be a major BC break to start with. Really? I was unaware of that. Can you give an example where this would be a breaking change for someone?
&gt; ps: the test difference isn't tested in an identical environment but i think it still keeps value. 5.6 is tested with wamp on my local laptop. 7.1 is tested with vagrant on the same laptop. I'm afraid your test is flawed. Windows has very different performance characteristics for PHP than any *nix environment. Even if you test two identical PHP versions between Windows and *nix it's not out of the questions to see 5-6x difference in performance (in favor of *nix). One thing I've noticed is that function calls (even empty functions) on Windows are way more expensive relative to other operations, compared to *nix. This alone can distort any benchmark beyond belief. Lesson is: if you care about performance, don't run PHP on Windows.
His 5.6 test is on Windows. PHP is really slow (in some particular ways, like disk I/O and function/method calls) on Windows.
Imho vote yes. If it really is class object, it should be a piece of cake for anyone to replace that across the board with something else.
without any special Laravel plugins (and then still probably with a lot of mis-matches) your IDE cannot properly resolve this as it relies very heavy on the internal "magic".
Depends, what ecosystem are you in? If you like Laravel, Lumen is second nature in how it works. Symfony has Silex. Slim is another popular one. No one is better than the others because they all have unique ways in which they work. It's more what you're comfortable with. I personally use Laravel for a large portion of my projects that require quick turn around so I like using Lumen. But most of my work is geared toward rapid development. For longer term stuff I use Symfony and Silex. It all depends on what you're doing and how you want to tackle the problem.
When I see stuff like this, I just wonder if some people hate programmers and this is their revenge.
The biggest selling feature for a framework is supposedly "common conventions" across a team. When an optional feature is there and someone on your team likes it, it's now a mandatory feature, because you'll have to read, understand and modify code using it.
No, I'm not butt hurt by their comments at all. Why the fuck would I be butt hurt by some no-lifes on Reddit when I literally get up every single day and do whatever the fuck I want for the rest of my life basically? *They* are the ones that are butt hurt because I didn't merge this PR exactly up to their specifications.
I understand when you use parenthesis. It's taught in grade school. My [other comment](https://www.reddit.com/r/PHP/comments/5b9s9y/php_dos_and_donts_aka_programmers_i_dont_like/d9nwbzu/) goes over this. My example was all addition specifically because it means using () is pointless. That was the entire point: Too many parenthesis that make the code harder to mentally parse without actually doing anything. If the parens are doing something then they are not superfluous. With regards to the `($a)`, I am a consultant and see a lot of work from a lot of developers. It happens. Generally it's the result of lazy refactoring. `($a + $b)` and then `+ $b` gets removed so we're left with `($a)`.
First reaction was a bit negative, but I think it's just PHP's ugly syntax that made it look a bit janky! Good work. Implementation is nice.
How do you feel about Service Objects outside of the "normal" framework? Something like Interactors (PHP/Ruby have some good libraries) or custom objects that exclusively deal with the Business logic (like Trailblazers Operation classes and PORO/POPO objects). In past projects, I have worked with "God Models" and "God Controllers" and even some terrible monstrosities as "God Views", where one layer gets bogged down with too much business logic. I have had a much better time using something like Service Objects/Interactors/Laravels "Repository" pattern(?). Still not sure what the best long term solution is between different MVC frameworks.
I wrote this simple [benchmark class](https://github.com/scottchiefbaker/php-benchmark) to help compare version. It has HTML output, and CLI output. I've used it before to compare 5.6 to 7.0, so it should work for you too.
*faster than
Despite I'm very "OOP" in my approach to programming overall, when it comes strictly to *data*, I just use arrays, so the answer for me would be "nested arrays". Eventually some complex values can be presented as immutable value objects, but one should be careful not to overdo it and start boxing every separate field in its own value object type. The value of value objects is in creating generic, reusable types of values. If you use arrays, then foreach-ing, filtering, transforming, serializing, deserializing, and otherwise processing this data are questions that answer themselves, which is the beauty of the approach, i.e. leave data be data. Encapsulating data in objects is a necessity only when you need that abstraction level, i.e. the freedom for this data to be stored and fetched in an opaque to the "external world" ways. When you constantly serialize data from object to send it over the wire, or to persist it, and then back, it's worth a thought if the abstraction gives you something in return. A honest assessment would be "no" in many cases where your object is just data, and no behavior. You need to be more specific in your questions to give a more specific answer. I'll just say - if the data source you query is remote, then sending queries one by one for each nesting level would be highly inefficient. To solve this you can specify the entire data tree you need, look at how GraphQL does it (you don't need GraphQL, but the approach can be applied in general).
There was an ad here on reddit a couple weeks ago for www.honeypot.io I haven't tested their service, but it seems to be something that you might be interested in. 
Ideally your domain services would be completely independent of the framework. In PHP when we speak of "the framework" typically we're talking about a framework that handles the HTTP request-response cycle. Things like routing, controllers and responses (with template engines and so on). The domain should be built independent of the type of clients using it, so therefore it doesn't stand to benefit from most of the framework's facilities, and not to mention frameworks and clients go out of fashion quickly, but your domain should be able to stay around forever, because it's critical to the organization using it. So short answer, keep your service objects outside the framework if you can.
I work hard to maintain great relationships with recruiters in my region (300+ miles) in the hopes that they call me first (which seems to be working). Most people seem to shit on them but they are just trying to find work. I've taken a few out to lunch, sold them on my skills, and underbid other contractors in order to be at the top of the list. It's starting to pay off. And frankly, if you're starting to get hungry for work, what can it hurt to have someone else looking for work for you? 
I've never heard of "short closures" before in programming, is this a PHP specific term?
too much magic. 
Thank you, will be checking them out, but what do you mean by request/response nature? I get what you say but don't get what you mean.
I like this kind of threads because I can ask the most stupid thing and don't feel so bad about it; so here goes another one. Why is it that the Model should have the Business logic isn't it the Controller the one that manipulates the Model?. Again, I'm sorry if this question is very dumb.
Pretty straight forward. In a web application, a request comes in, the app does some processing and returns a response. Easier for me to wrap my head around than all this MVC stuff. The second link explains it better with pretty pictures. By the way, the best definition I have seen of MVC is that you take three things (does not matter what they are), draw some arrows between them (the number of arrows or direction is irrelevant) and presto, you have you very own MVC design.
Same. It's one less DSL to have to think about. I even define all of those field names as constants right on the model so that if the column name ever changes, I just have to update the constant, rather than every place the string `'retired'` appears in a query.
You sound like someone who has NO idea what they're talking about. LESS/ SASS is not a 3rd party library, and is greatly beneficial to modern project development. And they were right, you shouldn't worry about such things. If you hire people, trust their judgement over your non-developmental judgement. 
&gt; Business Logic should be inside a Model. I'm not objecting to this as it's a very popular interpretation of a "model" in web frameworks, but I wish we'd call it "services", because the model in MVC really is at a different place - it's closer to a data skeleton of the page to render, than of your domain's state.
Being a solo freelancer doesn't mean you can't adopt the "EULA approach". Leave prominent copyright marks on code that is yours, and print the license and let your customer sign it *on paper*. On the obfuscation side, I wouldn't recommend you invest in this, simply minify the code and pack it in a PHAR, if you want a light and easy to distribute file. Note that if your customer is paying you to create the code, by default this is work-for-hire, and you *do not own the copyright* to this code, your client does. So any parts that are not produced under the assumption of work-for-hire should be negotiated explicitly and made clear to the client (through said signed license). Anything else means you're basically giving up on your rights over that code.
Obfuscation is the most stupid thing ever. And not letting a customer to customize the app is the second. I were such a customer and this thing always drove me crazy. So I'd rather unobfuscate/decode that stupid app rather than submit to a whim of yet another paranoid user. Or just throw it away in favor of a way better free version. In my experience, the encoding/obfuscation is used mostly to cover the utter ugliness of the code. Ok, if you are so strict, why not to keep the app on a server of your own? Leasing a service is a sane approach. used all over the net, starting from Gmail. That's different matter and nobody would complain.
Compile your code as php modules which are in C. You'll get performance boost as well. https://github.com/phalcon/zephir
I wouldn't. If they want to change it let them. Chances are they can't because it's too difficult. Then you charge them 150% of what your original offer was for continued support that they waived because it was too expensive. Minify at best. That is unless they own the source code as others are mentioning. 
these make more sense $employees-&gt;filter($e =&gt; !$e-&gt;retired)-&gt;foreach($e =&gt; $e-&gt;sendPayment); $employees-&gt;filter(not(Employee::retired))-&gt;foreach(Employee::sendPayment);
Does Code Igniter even require further obfuscation?
Oh, you.
Don't bother with DRM, etc. Signed, Resident cryptography nerd. ---- EDIT: OK, if that was *too* brief, let me elaborate: * Legal concerns should be enforced by legal means (i.e. license agreements), not technological means (i.e. obfuscation). * If you can execute a PHP script, you can read it. * Even if it's just encrypted opcodes. Reverse engineer the binary blob that decrypts the opcodes, you'll be able to trivially reproduce the source code (within reason). * [Hiding your white-box designs is not enough](https://eprint.iacr.org/2015/753) ([slides](https://eprint.iacr.org/2015/753))
To be fair, without an actual contract/license that says I cannot, I would too...
Ask an cheap offshore development house to rewrite it in PHP 5.1. No one will ever be able to understand what it does or modify it.
Well if you take a look at his other questions you'll realize that he *is* a cheap offshore development house. In fact, nobody else ever asks how to encode/obfuscate their code. 
Just use CakePHP
this sort of thing would never happen in AdamLang...
It costs money. And those devstrers eager to protect their million-dollar-unique-project are never to be found to afford $200 for a commercial encoder.
Sounds like you butt hurt mate.
Programming is just a bunch of ifs and whiles :) 
Really? Because from your post it kind of sounds like you think this is not ok.
With a licensing agreement and keeping control of the infrastructure. Otherwise get over it, you're selling them code not the right to wear house your first born.
doe's the codeingiter license even allow you to use the framework in this manner?
Super small addition (maybe more for mikey but for OP) but to get all mp4 files you could just use "glob('/path/to/mp4/files/*.[mM][pP]4')".
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You don't explicitely say it, but it is confusing that you want variance to be explicitely specified (what would that even look like?) but also seem to agree that variance of types as imposed by LSP is useful and correct. I might just be misinterpreting some of your comments.
how is it not? that functionality is not there by default, you have to install / include them in your project.
that depends where you live. Also it's likely if they are doing anything non-trivial they are using someone else code or wasting client time re-inventing the wheel, so it's questionable if a single coder should ever seek to stop others from updating their code. What happens if the product becomes a success, or they need someone else to work with? That person would spend much time unpicking their pickled code, unless they source control pre-pickled code... It all sounds like a PITA and honestly I'm a fan of charging for anything that is a PITA, I can't charge myself so I wouldn't bother.
Q: How can you tell that a video is just SPAM intended to snatch a few move views on YouTube? A: The code that is bluntly copy-pasted from another example, identifying a user by their *location*.
There needs to be better outreach on this to new developers. Like before anyone writes a line of code, be like &gt; "This code you are writing in is accessible to you because of decades of sharing and open-ness and people not keeping their cleverness to themselves. DBAD, share your shit or learn to code in binary!" It's really hard to retrospectively apply that kind of logic to your work, and I'm not sure just saying "be open" works.
warehouse... sorry but `wear house` makes no sense
CI projects are by and large the easiest to pick up and play with. It's not crap because it's hard to work with. It's crap because AFAIK no autoloading, weird take on DB's and testing and not enough hooks and integration. CI was a champ though. Especially 2.x for it's (I'll work 90% of the time but really F you when I don't) routing.
Correction, this RC is scheduled for general release on the 10th of November and if nothing major comes up it'll be the latest RC before the GA release.
Why would you care about source code modification. Your client paid you for the code, you give them the code. If they go and fuck it up, that's on them not you.
Anyone got a link to the changelog, please ?
The best strategy is no to do it.
It doesn't matter you still have to include the license and copyright so obfuscating this will invalidate your agreement with CI
Oh no, you have to tweak your obfuscator to copy/paste the comment headers.
No idea about Symfony, but I've developing over Silex, and I love it. I guess I can learn to love Symfony too. Good work
I love Silex for little projects where the entire feature set of Symfony might be overkill. Any fun projects that you've been working on with it?
You could try IDEA (maybe IDEA Ultimate) from IntelliJ it combines all platforms with the use of plugins, although they do warn you that a plugin might be out of date compared to the program's counterpart.
Any good mvc skeletons out there that you recommend?
Well right now, the API I'm working on is basically to process information from different sources/sensors, and provide the results as a RESTful api. I love the way I was able to organize everything, it's very easy to understand how to find each piece of code. But the real fun is that this API is working with a Oracle db which has a table with 900 M rows, and can eventually grow up to 4 tera rows. I never worked with something that big, and is as scary as exciting. Also learned a lot about messages brokers, right now using rabbitmq, and fucking loving it.
While I agree immutability is a good thing, I find it to be quite difficult to work with in PHP specifically. There are all manners of ways to abuse objects in PHP. The fact that you can modify certain parts of an HTTP Message w/o triggering immutability just seems weird. Immutability and DIC don't go well together, and I guess that is my biggest complaint... PHP is such a different language than Java and others, that while in general we try to implement certain language constructs ... I think this one doesn't make any sense. --- Where is the best place to start to learn Symfony. I ask as another dev who uses other frameworks [ Slim ]. I am starting to branch out for some projects because I can't be arsed to setup a whole big framework on Slim. Laravel seems so backwards to me, so I was looking at Symfony as a more sane solution.
So true. 
The standard way to call a function is **not** `function( $parameter )`, it's `function($parameter)`. http://www.php-fig.org/psr/psr-2/
Having to make multiple requests to a source that takes 5ms to respond frankly doesn't seem fast, at all. But it all depends on your actual project and uses cases. &gt; I wasn't sure the best approach to turn it into an object either (is serializing with something like Doctrine what you'd do for that?). You don't need Doctrine, all you need is a constructor or a static public method on the class in question that accepts state (in the form of scalar/array values etc.), and returns an object instance holding this state. &gt; Maybe just keeping it simple and as a giant associative array is the better approach! I assume you just have to eat the cost of looping everything if you want to reach something at the bottom. I did mention GraphQL, which doesn't have this cost of looping everything through multiple requests to reach something at the bottom. Check it out. As for the giant array... it depends what it contains and how giant it is. Even though I stick to arrays for "pure data" as I stated, I don't collect this data in some central place as a giant array, typically. Instead, I send focused commands and requests to my services, and they deliver precisely what I want on the first roundtrip. You need to share more details about the project, if you want a detailed advice about your situation.
Right, well, my apologies for appreciating parts of something that you deem as not worth liking any of it. I thought I could go ahead and appreciate the simplicity of the usage, but apparently not. Mayhaps you have a list of things we're allowed to appreciate without being called shit developers?
Any advice on how to learn symfony?
I'm currently using Jenkins + Elastic Beanstalk. When I commit to the repository Jenkins pull it down, runs tests, and if everything passes it gets deployed to Elastic Beanstalk.
Most of the time I scroll to the bottom of the page to check all the memes, without reading anything else, and leave.
I'd suggest http://knpuniversity.com/ there are some free some paid
Symfony Standard Edition is what I typically start with. There's also Symfony REST Edition (https://github.com/gimler/symfony-rest-edition). Is that what you mean? 
Yes, build a basic CRUD app like a Todo app. It doesn't have to be fancy. I learn best by doing so I like to pick something small and run with it. Do you have a development environment that you can start learning on? Do you need help getting to a starting point?
This is the closest thing that I could find to what you're looking for but it doesn't appear to be maintained any longer: https://github.com/Abhoryo/APYJsFormValidationBundle/blob/master/Resources/doc/simple_example.md
All fair criticisms of PSR-7. I started learning Symfony with 1.2 and I learned everything from the Symfony docs, specifically the Jobeet tutorial which I don't believe exists for Symfony 2/3. There are Symfony courses on Udemy if you're short on time but have a continuing ed. budget of some kind: https://www.udemy.com/symfony-development/ There's also the Knp University Symfony track: https://knpuniversity.com/tracks/symfony
I'm currently migrating to AWS and find it incredibly confusing. What strategy would you recommend to learn the concepts?
I would ask you how important is maintainability to you? How important is it that you are able to bring in somebody to work on the codebase who can understand the architecture quickly because they already know the framework? How important is code reuse to you? Do you want to build a platform that is part of a larger ecosystem of libraries that are easily installed and configured? Those are a few off of the top of my head. Does that help?
Cool. So you're using the same starting database for every test method in the test case class, even if some test methods don't require all that data? How do you ensure that the data in the database is reset to its starting point after each test method? I mostly use Laravel, and it comes built in with model factories, and in simple cases it's fine to start each test method with a few calls to factories to populate the database in the test method. I like this because each test methods has the specific, minimum amount of data needed for that test. But as our application has grown, in order to set up "the world" using model factories in each test method really adds a lot of noise to the tests (sometimes 40-50 lines of model factory calls in a test just to set up necessary relationships etc) and I've been thinking about switching to loading in a single fixture in setUp and have all tests use the same data to keep the tests as small as possible. The only downside I see using fixtures is the when looking at the test for the first time, its not obvious at all why a test is asserting `$fooRepository-&gt;getCount()` is `14` (you inserted the 14 rows in the fixture file, which is obviously a separate file). What are your thoughts on this?
&gt; /r/forhire I just created /r/forhire2 - an alt forhire subreddit. If you're a coder, feel free to utilize it. I disagreed with some of the policies of /r/forhire. They said my site had "we" on it. I said to them that they must not understand the survival nature of today's freelancer. Today's freelancer has clients sometimes that expect a "we". And, to be honest, there are times when it's suitable for me to outsource some portion of a project to a third-party under strict NDA because they might do it faster or better than I can, or because my current workload at a given moment might be so high that I need to outsource. I have a few freelancer colleagues, and a few use "we" also on their websites for the same reason as me, and also do outsource sometimes. The /r/forhire mod tried to push me to another subreddit that few will hardly use. So, I decided to create another alternative subreddit. Feel free to post on it.
It's actually really sad because even for me, considering I've been programming over PHP for about 10 years, and worked over plain php, zend framework, silex, and even developed my own pseudo-framework, and I still keep learning, for example a few days ago, sem_* functions completely blow my mind. I was always doing some file related check for concurrencies and now I feel like an idiot, having such functions at hand. Long live PHP
Have you got any examples projects out there on githib/anywhere? If love to read some of your code :)
They record one's screen every so many minutes? Yikes! No thanks. Sometimes life happens. Don't need an Orwelllian 1984.
What is your development environment? 
I support the idea of components providing their own "mocks" for testing, but this is different than saying a framework should "support testing". Well designed code is testable, because the same conditions that are required for testability, are also required for configurability, ease of composition and reuse. The class you're linking to does almost nothing, it simply embeds a client and a crawler on a class extending PHPUnit test case. The client and the crawler are already available as standalone components, performing an identical role. Maybe some people have no idea where to start, and this is providing them with the training wheels to start testing. But it's certainly *not a requirement* for the framework to do this, in order to enable you to test. Especially if you're not completely new to the *concept* of testing. BTW, talking about this example you're linking, I wonder how often you write tests like these: $this-&gt;assertCount(1, $crawler-&gt;filter('h1:contains("Contact us")')); $this-&gt;assertCount(1, $crawler-&gt;filter('form')); Maybe this is not representative for the class and its purpose, but I'm simply shaking my head, while reading it.
Isn't Laravel heavily based on Symfony?
Is there any reason to use silex since Symfony has micro kernel mode?
For local development on my Linux box I use Docker and I've been fairly pleased with the performance. On my MacBook Pro though, Docker shared folders are just too slow so I use Vagrant + NFS.
I'd say that it depends on the use case. If the project does not require third-party Symfony bundles that do not have a corresponding service provider for Silex then Silex may be a better choice but you may be pigeonholing yourself. http://symfony.com/blog/new-in-symfony-2-8-symfony-as-a-microframework#comment-20170 According to Fabien: "Silex and Symfony MicroKernel are not related at all. Silex is an implementation of a framework on top of the Symfony components (done in a very different way than Symfony, the full-stack framework; Pimple, ...). Symfony MicroKernel is a "just" different way to **configure** the Symfony full-stack framework, but shares everything else (caching, bundles, ...)."
[removed]
ubuntu with docker with php7, rabbit, redis etc...
of course 
&gt; to have a base class with implementation shared by all specializations. I don't know how many ways I can put this. ListOfSubTypeOfObject is not a specialization of ListOfObject. They are invariant. &gt; monstrosity What I wrote out are the types that would be implicitely defined by generic types. No, it ain't pretty. This is why languages have generics added to them. Or if they don't why we drop the T part of the typesafety when writing generic code. I'm just showing you what the correct typesafe way would look like because in your example you are doing it incorrectly.
Epic comment 😂
The LiipFunctionalTestBundle extends the functionality of the WebTestCase object and provides methods for loading fixtures for each test case as needed rather than using a single fixture for all tests which could cause problems. https://github.com/liip/LiipFunctionalTestBundle#database-tests
I used to use Alice but I found that it fits only for very simple cases. For more complex applications it is hell to maintain it. Currently I use doctrine data fixtures with some restrictions: - Never use references, make fixtures as independent as possible; - Try to reuse existing code to populate data (for example I have "handlers", some object which responsible for implementing use cases. For example "RegisterUserHandler" contains all high level logic to register user. Your data model is just an implementation detail so it's not so handy to use it directly in fixtures. Especially if you have some complex relationships and you don't want fixtures to populate inconsistent data. Or you could use some builders/factories. Especially for entities, then you could use it in your unit tests; - Use random data as much as possible (faker may help you a lot). This allows to increase number of covered test cases; - You can have different sets of fixtures for different test cases. This increases maintainability of fixtures. For example some sets of fixtures can be used in integration testing and some - in functional one. When you are dealing with one large set of data you may have problems in cases when different scenarios needs different data; - Use constants for ordering fixtures. Something like `self::AFTER_USERS`. This makes fixtures a lot more easier to read. 
On my project everything more than 500ms considered to be very slow. What do you do so your have that numbers? Maybe you just need more powerful hardware?
I have not but I'll certainly check it out. Thanks for the heads up.
I wish I could help more on this one. Is it hitting the disk a lot?
Annotations or YAML? I notice most examples use annotations but it's just feels so wrong having important stuff in comments!
For sure. Thanks for the tip :)
&gt; How would you notionally go about this? What I wrote was an insanely simple script that will do precisely what you asked for. I would normally use a framework so I could properly handle page requests, abstract away things like commands such as "airplayer play", leave myself room for growth/expansion, and a lot of other things. A framework provides a common base which allows you to quickly add work others have done already. For instance, you mention it's for your family. Perhaps later down the road you'd like to add a login ability which would allow someone to see their favorite files/folders to continue a show binge. In your case, such as small project would warrant a smaller framework such as Slim, Silex or Lumen (pick your poison) that allows you to quickly add work from others. Others have already created methods for logging in which you could use and/or learn from. The reason I don't explain further is because within what I said are numerous amounts of concepts and topics that I do not have time to explain :)
You mean this isn't your first time making pancakes?
It's probably because this is legal at least as far back as PHP 5.3: class boolean{} function foo(boolean $x){ return get_class($x); } echo foo(new boolean()); // OK: Instance of boolean(class) expected, instance of boolean(class) given echo foo(true); // Fails: Instance of boolean(class) expected, non-class of type boolean(type) given I guess nobody thought to make `boolean`, `integer`, etc. reserved so that classes cannot be created with those names.