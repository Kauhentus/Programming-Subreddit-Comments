Maybe "Query Service" could be a better name.
&gt; for AJAX calls where you won’t necessarily see that the call failed in your browser. JFYI, there is a dev console where you can see not only that the request failed, but also the full output and even some debugging information
Everything is written in my comment above. Just pay more attention to it
These queries are (like repositories) services too. The name "Query Service" could be a better name. To prevent repositories from becoming too large (SRP), I would recommend to create many smaller module-specific repositories. To achieve this, you have to organize your folders and classes in a module-oriented way.
Curious though, why is Laravel listed as tool? It's a framework.
Does it work with docker?
No, by community standards, I'm talking about folder naming convention. If we put all entities in the same folder, we reach more than 2000 files. Even for Linux, it will be more difficult to index.
As /u/geggleto said, creating a domain/feature folder between your concept folders allow you to split your code in micro-service, and as I said, allow your developer to think about feature first. So, yes, we have many controller folders as we have features. `src/User/Controller` without the final `s`, but it's another story :)
It's not the technology that scares me. What scares me is when the guy who imagines an average [php code like this](https://i.imgur.com/UdAgujK.jpg) tries to write async code. ( image is from my local facebook group, posted yesterday )
Laravel is still a tool though. Just because it's a framework doesn't mean you can't label it a tool? It helps you developer faster for example, just like a spade makes you dig faster. It enhances your activity. 
The libraries and ecosystem are immature. Hardly anyone uses them in production. I do, but I regret the choice.
PHP
This is probably the biggest reason for me as well.
* How do I get started? * How do I create a connection pool with an arbitrary limit, e.g. max 10 async connections, to avoid unintentionally DDoSing the target service? * How do I test async code with 100% coverage to make sure it's working correctly? * I worry about trapping myself into an immature async world where support for anything other than HTTP is seldom offered. For example, how do I consume a SOAP service with async?
Then how does it integrate?
it will happen eventually when he feels like learning node.js, the funny thing is that he will probably read some tutorials and write better code, but he will still find a way to write stupid async code
&gt; If we put all entities in the same folder, we reach more than 2000 files. No you don't, you use subfolders like I already said.
In my personal experience, this style of structure lends itself very well to maintaining a functioning application - i.e. when you need to go in and change little things, or add a new module. However when it comes to application-wide features and architecture changes it can quickly become a confusing mess. It certainly has upsides but the downsides are nothing to scoff at. Again this is just my personal experience - but I prefer to work with the more "standard" architecture.
I think I can expand a little bit on where I'm coming from by adding that this module-based layout actually has little to do with grouping code by its *actual* function but rather groups code by its *apparent* userland function. As in the example given - ProductService and ProductRepository probably actually have very little to do with eachother, they likely just manipulate and handle Product entities. Whereas ProductService and BasketService probably have similar functionality and use-cases from a programmer's perspective.
Sorry, didn't see the subfolder part. The main problem here is you won't be able to split in micro-service, or a more simple case, you can't easily remove a feature from your codebase. You'll have to search for all subfolders. Btw, the main objective here, is to fit with **your team mind**, and not with what we do. But keep in mind that it can help because this idea has been tried and tested by many teams.
Exactly, here is the reasoning you missed from your original post.
Thanks for the tipp with: PDO::MYSQL_ATTR_FOUND_ROWS =&gt; true https://gist.github.com/odan/4efe37e5b552b2bdf29b172b056f3645
javascript noobs jumping ship and kicking PHP back to the state it was &gt;5 years ago: an ecosystem full of bad practices, poorly written code and the accompanying bad reputation. The horrors of a language with a low barrier of entry :(
found the shitty developer
&gt; To prevent malicious data being stored in your database, you can use functions like htmlentities() and filter_var(). 1. That is not correct. `htmlentities()` is used to output data (e.g. html template) and not to prevent SQL injections. The `filter_var()` function is used to pre-filter certain user input, but this must not be used to protect against SQL injections. 2. This code is vulnerable to SQL injections if the data should come from a user input. &gt; $inArr = [1, 3, 5]; &gt; $clause = implode(',', array_fill(0, count($inArr), '?')); //create 3 question marks &gt; $stmt = $pdo-&gt;prepare("SELECT * FROM myTable WHERE id IN ($clause)"); 
What are tradeoffs of using async PHP? ^^ would be so much nicer title.
Good observation, this seems to be a "one man show". But looks great. Good job!
I guess that's a good point, but I wouldn't call most of our libraries immature. But we have a chicken and egg problem here. If fewer people use it in production, fewer people will try it out. I know that our libraries are used in larger deployments, but there are only a few public statements about that.
If that's business logic, then I have no idea why AddPermissions is not in `src/Permissions/`
I guess it's a common misconception that async can only be used in CLI scripts, that might need a blog post or something like that. Doing parts async and others with blocking I/O is totally fine in a traditional environment, it doesn't have to be a full-async application server. You're serving your users in parallel, yes, otherwise it would be horrible. But you could still reduce the latency if your different components could be done in parallel and then combined and sent to the user.
That'd be a good title for a blog post, but not so much for a discussion IMO. And your title seems to target existing users that know the tradeoffs instead of new users that haven't even touched the topic.
All *X in X folder is not "standard". Or else it would follow that only small applications are "standard" and everything bigger is "non-standard". Could you provide example of some change to code where *X in X folder is better then *X in * folder ?
I'm not talking about SQL injection, I'm talking about Persistent XSS, which I why I mention sanitizing and validating inputs. Not the main aspect of the article, but felt it was worth mentioning. Read the sentence right before. &gt; While you are safe from SQL injection, you still need validate and sanitize your user-inputted data. 
Don't know what to tell you, as I reread you posts a few times and all I see mentioned is stuff like: &gt; Again, don't think at the level of a single database interaction Please just keep it simple. I'm willing to listen, but sorry, I honestly see no mention of you specifically talking about *how* to omit try/catch blocks with a single database interaction, which is what I care about. Where would the echoed json go `echo json_encode(['status' =&gt; 0, 'msg' = &gt; 'Failed to send message'])` (like my example)? Maybe some code example of what you're talking about.
&gt; **use a single global try catch instead** 
/r/phphelp
PHP is unlike some other programming language runtimes in that it is designed to be embedded into servers, rather than being a standalone application. There are several “server APIs” (SAPIs) PHP supports, and these have their own binaries. Examples include: * The command-line interface (CLI) “SAPI”. This is the `php` executable you know. * The Common Gateway Interface (CGI) SAPI. This is the `php-cgi` executable. CGI was originally the only way to use PHP. The CGI SAPI also supports FastCGI. * The FastCGI Process Mananger (FPM) SAPI. This is the `php-fpm` executable. It implements FastCGI only and spawns worker processes to handle requests. * Apache's mod_php. This embeds PHP into the Apache 2 web server.
I'm willing to remove anything that's incorrect, but I need to an explanation for *why* it is. I respect ircmaxwell's opinion on security and even he said you're safe from SQL injection (obviously you still need to sanitize/validate, but for persistent XSS). I also agree that you should undoubtedly use prepared statements (no reason not to), which why I strongly suggest it. But there's a difference between knowing something is possible and actually doing it that way. I'm not a fan of "theoretical threats", so if my explanation above is wrong, please explain why.
I don't know. Maybe through a composer package?
Link to a link to a content I recall reading quite a while ago. :\
That switch is fantastic
2 things stopping me currently: - How to test async php code? - Lack of documentation / examples / tutorials about using async PHP to speed up webpages. I see lots of info about using it to write servers etc. but what I want is a way to understand how to use it in web pages normally so that I can call lots of different external resources required to render the page. I'm not interested in writing a chatbot server or suchlike. What I would like to learn is how to half my page load times.
Assuming async / threading libraries use pthreads, PHP.net clearly warns that it will not work in apache. Http://php.net/manual/en/intro.pthreads.php And logically this makes sense. Pthreads aren't real threads, they're forked processes. Apache already does pre-forking and load balancing.... 
It's on the "You're probably thinking that I'm an idiot" part.
Like I said, I learn by examples. I tried looking up how to correctly use a single global try/catch, but see no mention of how to use it to give *specific* messages. For an AJAX page to send a message, I'd have message like 'failed to send message'. On an upload page I'd do 'failed to upload file' for instance. Please just keep it simple man, all I need is a simple example to know what you're talking about.
Use PHP 7.1 instead of HHVM, read the release notes for each version you've missed.
But please explain yourself. Being vague only makes me assume you don't know the answer yourself (maybe you do, but it's hard to tell with no explanation). My point on that is that SQL injection is about user-input. This is a server-side variable. Of course there's other checks you should do on `SESSION`, but if you can't trust your server-side variables, don't you think you have my much bigger issues to worry about? Like I keep having to remind you, provide a concrete explanation and I'll be glad to be educated.
Good to know I've been treated like one for almost 4 years, before realizing I'm being robbed of my money! xD
I think you've wanted to like this idea so much that you overlooked some libraries that do exactly the same thing, probably with better outcome like https://github.com/corcel/corcel that enables you to access all the needed db query objects, but with Laravel ORM models. 
Just to be clear, I do like what you guys are building. I think I have said that before. Regarding gaining traction; if I were you I'd try to get someone like Taylor Otwell or Fabien Potencier to build a simple application framework atop Amp's components which appeals to your average web developer. Most developers who are doing paid work need to be able to create working applications quickly. Furthermore, Taylor knows what people want and is good at getting people to pick up new tools, and I'm sure there are others you could reach out to who also have those skills and possibly a similar following.
&gt; but Corcel required deployments if i needed to make changes. Can you be more specific? I'm not getting why you don't need deploys for what you've done. I've always thought that corcel is a nice try with this kind of problems.
I think that this is the real base of why Wordpress is good. At least I don't know other admin as good as Wordpress from editor's point of view-
That it will not be optional. That in some cases I'll have to work around async to do the same thing. I've written a JS app in Cordova once. All the DB calls were asyns (with no proper way of making them sync) same for ajax. It was as a mess.
What do you mean by "async PHP"? As a general concept, I don't use it because the concurrency in PHP isn't as easy as in, say, Go. If there's some specific part of the standard library or PECL extension you're talking about that makes it easier, I don't use it because I don't know about it (and I'm not sure that adding the complications of it would be worth the benefit, even if I did.)
But PHP 7 was released 2 years ago. 
Use PHP 7.2 (will be released in the next days) and have a look at docker4mac
I have almost never had a use case. And the use cases I've had would've been better solved with a queue. (my use cases are sending emails and push notifications and doing other third party requests that need to be done, but the user shouldn't have to wait for) 
&gt; Pthreads aren't real threads Wut? Where does this knowledge come from?
[Code from an actual app...](https://github.com/asyncphp/helpfulrobot/blob/6268425d1b7f5a924ec080e23268a82dbb23d661/app/Action/User/RegisterAction.pre#L8-L46)
This is a convenient overview of the best new features. If you're interested in comprehensive release notes, here they are: https://github.com/phpstan/phpstan/releases/tag/0.9
As senior you can target above 60k. Source am German and had immigrant coworkers. One average dev from Poland had 70k. It's all about your negotiation skills. Berlin and Munich have excellent demand, I dunno about HH. Though rental market sucks hard.
Async mostly uses non-blocking I/O to achieve concurrency, no threads. Threads can just be used additionally and are totally optional, see https://blog.kelunik.com/2017/11/06/magic-behind-async-php.html.
That's because HH has higher salaries as average Germany.
Yes! Certainly happy to consider that a bit down the road. We’re already working on HIPAA compliance for or other product (geocod.io), so it should be trivial to put our learnings from that, into this product. 
Interesting! Thanks Chris! I assume I need to open a websocket for this, right? 
Which company?
Good question! It was just an example of things that Trunk Alert plays particularly nice well.
Yes, it definitely will!
where is it being transpiled to make async/await work? or is it HHVM code?
What exactly is "New REST client interface"?
Are you familiar with "Postman" -- it's basically like that, but built into PHPStorm.
anyway to disable or change the color of this hideous line https://imgur.com/crMOO7N 
If going the docker route try https://phpdocker.io/ to generate a docker compose file. It's just a start and by no means the end of configuring docker.
It might be coughing up blood but the auto-wire debate is not quite dead yet. Give it a couple more years. The basic problem is that the term "auto-wire" is misleading. A better term might be "hybrid-wire". Auto-wire implies that your dependencies are automatically injected as needed. And indeed they are as long as there is one and only one instance available to meet the dependency requirement. So non-objects such as strings and parameters need a manual service definition. With the Symfony container, you can automatically inject some dependencies while manually injecting others leading to the best (or worse) of all possible approaches to service definition: a hybrid approach. And of course it is not just parameters. If more than one instance that fulfills a dependency requirement exists then auto-wire fails. This can lead to some rather amusing cases where, for example, your app starts with one logger and everything is great. You install a third party bundle with it's own logger and boom, auto-wire fails even for the objects that were working just fine. Fun stuff. It's also quite common to need to use a factory for creating certain instances. No way auto-wire can figure out a factory is needed based on a type hint of the produces objects. More hybrid wiring required. The optimist claims that auto-wire will cover 70,80,90 percent of the cases. The time saved by auto-wire will compensate for the time spent in dealing with the failure cases. Those of us who are more "glass half-empty" sort of folks are concerned that the 10,20,30 percent failure rate will significantly increase maintenance costs and perhaps hinder the overall adoption of the technology. I see a constant stream of questions on sof from developers who don't understand even the basics of dependency injection. Giving them new functionality that sometimes works and sometimes doesn't? Hmmm. Lots of rep to earn at least. Time will tell.
Not for this particular example. The [global db functions (shudder)](https://github.com/asyncphp/helpfulrobot/blob/6268425d1b7f5a924ec080e23268a82dbb23d661/helpers.pre#L65-L107) use [amphp/mysql](https://github.com/amphp/mysql). The async/await stuff is from [a preprocessor](https://preprocess.io/). I can't imagine not using the async/await keywords and still doing a substantial amount of async work. The boilerplate without is just horrible. Necessary but horrible.
In Settings: Editor &gt; Color Scheme &gt; General then select Editor &gt; Guides &gt; Visual guides and change the Foreground color
You wouldn't want them to be synchronous. JS is only single threaded, so your application wouldn't be able to respond to other requests or UI inputs during the 50ms or whatever it takes for that call to resolve. That being said, nodejs and many browsers now support async functions, which look and feel synchronous.
But it's a cordova app. It doesnt need to support more than 1 request at a time. And my complaint was about writing sync code while async is optional. 
So all async is opt in? Then i'm fine with it
Why bother with it at all when Node.js is more mature, faster, and designed with asynchronous operations from the start?
Didn’t inquire further. Got a bunch of unsolicited offers on Xing/LinkedIn a while back. Some went as high as 95k.
I see. I don't give them much credibility.
[Here](https://blog.jetbrains.com/phpstorm/2017/09/editor-based-rest-client/) is their blog about it
Even though you have "more than 480,000 downloads" it would still be nice if you'd include a short description of what it is.
Wow. Keeping it classy I see. 
In case you've never heard about PHPStan: It's a static analyser for PHP that focuses on finding bugs in your code. You can find out more about its basics in this [introductory article](https://medium.com/@ondrejmirtes/phpstan-2939cd0ad0e3).
Thanks, fixed for the newcomers :)
I would love a sync php. Just for simple things like sending emails with phpmailer. I’d like people to be able to hit send and move on to the next page rather than have their browser pause while that action completes. I’ve thought about storing mails in a database and having a cron job come along every minute or so to send them out, but that seems like an extra moving part that should be unnecessary. 
I definitely can see the use case for a PHP based WebSocket server, but I would like some more info about Amp/Aerys's abilities like how many connections it can handle, security and testing. I also would like to see how other developers integrate an async WebSocket server with a synchronous Symfony or Laravel app. I have questions like "Does it require Redis?" "How do you setup a Linux server in that scenario?".
Remember to use real classes, and use those class types for parameters and return values, rather than just sticking everything in anonymous arrays/stdclasses.
&gt;But PHP 7 was released 2 years ago. And huge numbers of servers are still running PHP 5. Not everybody gets to scrap and rewrite their company's products.
But PHP 5.6 was released 3 years ago. There's no reason to run 5.3
Oh, thats actually really cool. I got "outdated" noficiations from mine, because it is dropping chrome support, and I didn't want to install it on my pc.
Great one, I will try that! Also, I used voyager for a project that is in production and was in need of a really simple admin. it wasn't as good as I expected, issues with cruds with relationships and such. didnt try corcel though.
Yeah, this is probably how I'd do it. There're variations between the versions but nothing you wont say "Oh right, yeah, makes sense" to.
You can also choose to disable showing it completely. Personally, I like it but it has to be very faint.
PHPStan is clearly one of the best things that happened to PHP this year. Thanks for the great work, /u/OndrejMirtes If you have some sort of CI on your project, you absolutely need to give PHPStan a shot! And if you don't have CI (continuous integration), set up one (Travis, Gitlab CI, there are tons of options out there) That being said, I have my own set of PHPStan extensions to migrate... Let's go! https://github.com/thecodingmachine/phpstan-strict-rules
The PHP solution has been to use message queues for "async" processing. So, there's not as much demand for a more native solution.
Same for me, but just 2 years... Hey, at least it's more than the 18k I had in Italy 😜
Yes, and I said that. I just think queues add a whole layer of additional complexity and moving parts which could be accomplished another way. Like output buffering is handled: async_start(); .... code that you don't need to wait for call backs from async_end(); Alas, I'm not a C developer, so all i can do is relay a wish rather than helping contribute to a solution :)
Focus bug in Search everywhere is still there :(
That is still wrong. Input isn't malicious by itself. It's the usage and output that is the problem. **Don't** try to handle a specific totally unrelated context (HTM output) when inserting data into your database. It's totally useless. You cannot know in what context you will use the data in your database so you cannot prevent anything at time of input.
Yes, I agree about using htmlentities() *after* the database retrieval, but I think it would be wise to validate *before* it is inserted, like using `filter_var()` for emails. I concede that sentence seems misleading.
Damn that sounds rough!
Intersection types is a much-anticipated feature as for me. You saved my day doing it. Thank you!
Now that I think about it, I think you are correct I could use the same logic and probably get the same information. But I don't think that Corcel would add any advantages, a quick glance it doesn't look like Corcel supports the returning of the entire ACF meta object. Still Corcel is what I would use to bring an external blog into a Laravel site.
Postman still has a place in my toolbox. I was excited for this, but it is pretty bare bones in comparison. Looking forward to how they evolve this part however!
JS becomes a completely different language once you stop pretending it has synchronous IO. You need to realize that what you did before was *wrong* in a JS context. Synchronous ajax? Really!?
It's not a misconception for me at least, I just don't see the raw utility, but maybe that's a result of my application design over the years. I very rarely have a scenario where a user is waiting on my code to execute a whole bunch of I/O bound requests before content is returned. What are some examples of actual use-cases where async IO is viable in a normal HTTP request-based approach (where a user is waiting on you to yield results)? I feel like most examples are going to be contrived ones where my response will be "well, if you had a decent application design in the first place, or proper database indexes/efficient SQL, you wouldn't need to do that" -- I'd love to understand some recurring use cases where it's helpful. I've used curl_multi plenty and I've even used MYSQL_ASYNC (via mysqlnd) occasionally, but again a user is never waiting on that to happen in real-time so it's mostly irrelevant to the point you're making.
A fun thing about queues is that you can use them to implement the actor model, one of the most powerful concepts in concurrent programming. I would choose the actor model over event-based IO any day :-)
Is that material color scheme?
Yes thanks. I like it much better like that. Although I want to nitpick about using `htmlspecialchars` over `htmlentities`, because that's what people want in 99.999% of the cases, but it's all good :) Thanks for the edit!
indeed it is 
At least his code has karakter.
Oops, no you're correct. that's a very good nitpick. I always usually `htmlspecialchars`. Changing it now, thanks for the help :).
https://www.getpostman.com/
You do have more than 1 "request" at a time. Blocking the single thread in that case means you are blocking the UI.
How does this differ to or what benefits does this have over using New Relic?
In my app I don't.
I read that, and although i'm not a complete newb, i'm not sure how to use it or how it can help me. I know what an API is, or at least I thought I did. I'm sure this can be useful, but i don't know how it can help with my workflow. I guess I don't really understand what it does.
&gt; And of course it is not just parameters. If more than one instance that fulfills a dependency requirement exists then auto-wire fails. This can lead to some rather amusing cases where, for example, your app starts with one logger and everything is great. You install a third party bundle with it's own logger and boom, auto-wire fails even for the objects that were working just fine. Fun stuff. If a 3rd party library has its own logger, then probably we're meant to use their services through their service locator. I've actually never had a problem with this. 3rd party libraries' classes that you are meant to instantiate always are instantiatable without any constructor arguments, I swear. &gt; It's also quite common to need to use a factory for creating certain instances. No way auto-wire can figure out a factory is needed based on a type hint of the produces objects. More hybrid wiring required. For those cases you can override the service definition. I've never had a problem with this. Same thing with 3rd party libraries in the worst case if you really would be expected to pass common dependendies to the constructors yourself. &gt; Those of us who are more "glass half-empty" sort of folks are concerned that the 10,20,30 percent failure rate will significantly increase maintenance costs and perhaps hinder the overall adoption of the technology. I see a constant stream of questions on sof from developers who don't understand even the basics of dependency injection. Giving them new functionality that sometimes works and sometimes doesn't? Hmmm. Lots of rep to earn at least. This is the one argument I find merit in. True that it's a "new" concept and it can be abused, but so was the concept of containers in general that has led to many bad "service location" anti-pattern practices in the beginning. But as the PHP community evolved, people started avoiding the bad patterns and started doing the good patterns more and more. I think that what's right is to move forward, and maybe there would be some bumps on the way, but in the end people would get used to the new concept and start using it correctly more and more. At where I work, most colleagues don't even realize that there's auto-wiring in our big project by default, and they may sometimes forget to create factory definitions for services and not even realize. The problems with auto-wiring have been nearly non-existent. But have enabled those who know about it to prototype new changes way quicker than they would be able to if there weren't auto-wiring. Just my opinion.
And so is the extend selection inside js script tags. I wonder if they'll fix it or we have to wait till 2018.1
It’s a more lightweight version of New Relic, tailored specifically for PHP. The major difference is pricing. (New Relic’s pricing structure is pretty ridiciolous for small our medium sized projects)
We use it as glorified shared bookmarks for dev purposes. Does the job well - except for it raping performance from my shit laptop
&gt; Assuming async / threading libraries use pthreads Async != thread, core async support (the event loop / reactor) has nothing to do with multi threading. &gt; And logically this makes sense. Pthreads aren't real threads They are, of course, real software threads as provided by pthread library. https://github.com/krakjoe/pthreads/blob/2645c78154c87b390908a8e8e1f59b99c8dfb30a/src/object.c#L396 &gt; Apache already does pre-forking and load balancing.... AFAIK apache offers both thread pool &amp; process pool for running PHP. 
It's great for testing authentication and walking around the api checking out structure/architecture/endpoints etc. Especially testing scenarios. I use it all the time when dealing with any api. I'm pumped that phpstorm now has a rest client built in now.
Postman can be useful for testing HTTP endpoints, i.e. make HTTP calls and inspect the request/response payload such as HTTP headers etc. I used it for many years. It's functionality (user experience) has steadily declined over that time. Recently I was force to upgrade my version and was then required to create an account. Everyone has to make a living I guess, but I passed. I now just write Grunt tasks instead of using Postman. It's actually much better since it's version controlled, etc... 
Come on, &gt; To help prevent persistent XSS, you can use functions like filter_var() to validate before inserting it is a complete nonsense. you are validating an email not not to prevent XSS but just to make sure that email has the proper format. While to prevent from xss you still have to bulk escape your output, no matter is there an email or not. It's just irrelevant matters. Offering filter_var to protect from anything is a common misconception, seeing it mentioned you can tell for sure that it's just an empty rant which is not helpful at all. Simply because it's an open ended suggestion, leaving the decision on the user. While any security measure should be certain and unambiguous, and generally applicable, like "use prepared statements for the any data literal added to the query dynamically". "Use filter_var" is just a pointless sermon without any practical application for the security.
Check out [Insonmia](https://insomnia.rest).
I agree with you, I like they being there, mine looks like [this](https://imgur.com/a/TvHvc)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/MZlY9VR.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dqiuwm4) 
Another example of queues being a fine solution to said problem. Async just seems to be an unnecessary complication.
I try so hard to leave storm for sublime/vscode/atom but now it replaces Postman too!? Jetbrains the real MVP
Not defensive, just curious - why would/should I use insomnia instead of postman/ alternatives?
I find it much easier to use. And it looks good. 
Yeah I'm sold enough to try it just from the nice ui
Ahh. The good ok’ “this is how I’ve always done it, it couldn’t possibly be improved on”. Got it. 
I can see how this can be misinterpreted. For the XSS part I really meant for the htmlspecialchars() part. Using `filter_var()` is certainly not a pointless check in an if statement before being inserted into the database, and I doubt many people would agree with you. I'd be happy to modify or clarify anything in the post and I take every suggestion seriously. Thank you for your input.
Running PHPUnit with specific data sets is nice, still needs some minor improvements the filtering doesn't work quite right if you select data set #1, you get 10, 11 etc A way to see what the data is in a data set would be nice too. Submitted a bug and feature request.
I suppose it reads that way. And I'm tempted to hold on to that opinion, at least for the time being. I suppose there is a future where the web might not be stateless. But until we get closer to that age, trying to force asynchronicity into use in PHP seems like moving away from what it was intended for. There might even be a new technology out there for when the time is right, which is better suited. Or PHP might adapt to time. Hard to say since it's all speculations. Anyways, that's just my take on it. I'm ready to embrace change, and if someone can prove me otherwise, I'll happily swallow my words :)
I'm personally familiar with a mission-critical app still running PHP 5.3 due to some incompatibilities. \*shudder\*
Really liked your comment. I'm an advocate for something very similar. Im currently writing a blog post about it :) But where do you put the UI (the controllers and templates)? 
I find Insomnia very slow also it takes forever to open. I wish I could export to postman everything...
Pthreads in PHP *emulate* Unix pthreads but internally use process forking IIRC.
I'm a big fan of [Paw](https://paw.cloud/).
Sauce?
I got you [covered](https://i.imgur.com/MFeiTke.mp4)! 
But if we do it that way, does that mean that both the catalog and product management features contain an adapter for the ORM inside their infrastructure namespace? I think there would be no difference between such adapters, so we would duplicate the code? Then I would create a unique infrastructure folder with the adapters which would be used by all features. But if I put it side by side with the catalog and product management folders it is misleading because it is not a feature, it is an architecture concern. So then I would do Src ........Component ................Catalog ................ProductManagement ........Infrastructure I disagree with Uncle Bob on this. I agree with him in that organising code in the traditional controllers/entities/database is not good enough anymore (it was probably good enough 40 years ago), and we should instead organise the code per feature or component. I don't think we should forget about reflecting the architecture in the code organisation.
Implementation details. If we are talking about controllers that handle the Web's Request/Response mechanism and Web UI's, I would place these concerns in a Web directory in the Infrastructure layer. I would try and place all Web framework related code under Infrastructure. The idea here is that the rest of the application is decoupled from implementation details. For example, instead of through the Web, you could drive your application by Console commands or Messaging. These will all talk to the same application services (or command/query handlers using use cases) that provide orchestration for the Domain and Infrastructure as that would be talked to when using Web-related Infrastructure concerns. 
Mac only :(
&gt;I suppose there is a future where the web might not be stateless. Node.Js is already here, and interesting applications are being built with it. &gt;But until we get closer to that age, trying to force asynchronicity into use in PHP seems like moving away from what it was intended for. Same could have been said when people first started adding features that extended PHP beyond being a templating language. I don't know - I think there's a clear need. There's also demand, as we're seeing other platforms offering it already. The question is, should PHP devs start working on it now, and have a stable implementation ready whenever the next major release comes. Or should they be forced to rush when the demand and need is even clearer. But beyond that, what tools are you use for queues?
I see. So you feel the controllers are the same as, lets say, an text search adapter for elasticsearch? And you also feel the controllers are related to the framework? I would argue against both ideas. As I see it, the infrastructure adapters implement an interface and wrap around a tool effectively adapting the tool to the application core, while the controllers wrap around an application service effectively adapting a delivery mechanism (http, cli, ...) to the application core. So I don't think it is an implementation detail, its structural, because the dependencies, roles and technical design is different. Furthermore I think the controllers, and templates, are a fundamental part of the application so I am strongly against having controllers that somehow depend on the framework, like the default symfony way which makes the application controllers extend the symfony controller. (Symfony is my favorite framework nevertheless) The way I am currently doing is Src ....UI (as in the hexagonal architecture primary adapters) ....Core (as in the onion architecture Application Core) ........ComponentA (DDD bounded context) ............Application ............Domain ........ComponentB ....Infrastructure (as in the hexagonal architecture secondary adapters) Me and my teams feel this makes everything very clear and the code easy to find. :)
Nice article. At work we have been walking the same path. :) The way we are currently doing is Src ....UI (as in the hexagonal architecture primary adapters) ....Core (as in the onion architecture Application Core) ........ComponentA (DDD bounded context) ............Application ............Domain ........ComponentB ....Infrastructure (as in the hexagonal architecture secondary adapters) We feel this makes everything very clear and the code easy to find. :) I'm also currently writing about this, will post it here when I publish my blog post.
It's useful for testing third party APIs before building implementing them in your PHP application. It's also useful for developing/testing your PHP applications API.
Hooray for fuzzy search! Looking forward to trying this out. https://youtrack.jetbrains.com/issue/IDEA-112841
They had a tweet that said it wouldn't be fixed in 2017.3 and only *might* be fixed in 2018.1. Really upset about that since it's been reported for years.
Use `[phpbrew](https://github.com/phpbrew/phpbrew)` to manage multiple PHP installations.
They already had a GUI tool to test AJAX requests, but they're a bit annoying to use in a GUI with separate text fields everywhere - lots of fiddling around with the mouse (or hitting tab / shift-tab). [Now you can do it in a text format](https://www.jetbrains.com/phpstorm/whatsnew/img/2017.3/rest_editor.png) - similar to how you can execute SQL queries in the database plugin I guess, haven't tried it yet. Should be much less annoying to use.
You know 95% of statistics quoted on the internet are made up.
I am not saying these things are the same. I am saying that all these kinds of infrastructural implementation details go inside the Infrastructure layer, but can be grouped by the role they fulfill. Web-related stuff under `/Infrastructure/Web`. These can contain Controllers and ViewLogic for the Web (they are irrelevant for other internal or external ports of the application (such as Cli Commands or messages from a MessageQueue). Perhaps templates could go in a resources or assets directory that goes besides `/src` in your root, but I would still apply an infrastructural grouping in the asset directory. I agree that controllers and views are important, but they are also implementation specific: they can apply to a web interface but also to a complex commandline application. That is why imho it is purely infrastructural. I also would not wrap application/orchestration concerns in a bounded context as I see bounded contexts as primarily Domain related (within a certain context, X means Y). The core of this architecturally significant layered style is that each layer has its own concerns and there are dependency rules that govern interaction between the layers (like ports and adapters on an inter-layer level). The three layers are clearly separated in responsibility and it simplifies reasoning about concerns and designs in my experience. Component or module based designs tend to get messy and difficult to enforce from an architectural standpoint. I would like to close by saying that it is more important that you think about these things and stick with a standard, rather than that there is one true way. 
That we seem to mix the concept of multi-threading and async and that is seriously affecting the direction of php. We don't need async. Simple as that. We have nodejs for that. I don't mind having it in php but not at the expense of what we really need. What we need, what we desperately have been asking for, for years, is an easy, developer friendly, maintainable and core-to-php way of running code in a new thread in PHP. And I don't need a fucking event loop to do that. I think that a lot of the community desire for async is acutally a desire for decent multi-threading and the performance improvements that may bring. And thats driving massive development into event loops that is way overkill for what the average developer is asking for. Until we get this right I don't know why we would be using event loops. An event loop completely changes the way you write code. All mature php frameworks are suddenly useless. Whereas multi-threading can be done in laravel with no other changes. 
&gt; Editor-based REST client Oh yes please yum yum
I’m just starting to switch to Insomnia myself. Postman has this unreproducable but extremely annoying bug where cmd + enter after alt tabbing wouldn’t trigger send. Having to take my hands off the keyboard to click send was a huge dealbreaker. I think I like the Insomnia UI a little better. There’s a lot less noise and I don’t use half the things Postman offers. 
Compatibility / Ecosystem You need to adapt anything that does IO to async. That can cause a lot of additional work, tough work. You practically render any existing library/framework useless if you go for async. How do I even write to stdout? I have to create an evented output stream and cannot use "echo", I guess? How would mysql work? Can they interleave multiple queries or I have to sync them? Garbage Collection / Cleanup You need to carefully cleanup everything you open/create, not the default for the average PHP user. PHP isn't even great with gc itself because it was simply never too necessary. If the gc is too bad it is a killer for it. Callback Hell vs Simplicity Many popular languages have lexically scoped closures and even there working with closures to solve async isn't the funniest thing you can do. PHP is slightly worse. Closures in PHP are useful, but not fun. It is also much easier to reason about synchronous code. Average PHP apps are complex enough. Side Effects Anything global with an extra twist. Yeah globals are bad, but still everywhere. Needs extra care and discipline by the programmer. Nothing new for async coders but PHP users need to adapt here, the hard way. Testing I wonder about it, in php. Even 2 years ago a friend experimented with his own testing strategies in node. How bad can PHP be? Performance Ok this is purely speculative. But my experience (with php 5) is that network IO is usually 1/3 of a request and PHP is the remaining time. A web app has of course lots of bootrapping overhead. If you want to profit from async the baseline overhead needs to be a tiny fraction of a normal request. There is also a good chance of the misunderstanding that concurrency == paralellism. I also wouldn't wonder if people start to complain about slow async because they happen to use a synchronous call. Humm, I guess I can find synchronous calls with strace. Scaling PHP memory consumption can be wild and hard to control. If you exceed the memory limit you kill the whole process. If you serve multiple requests you kill them all too. The only way I see to counter that a bit is to apply limits everywhere, i.e. truncating textfields you retrieve from a database. But keeping memory consumption always in bounds is pretty hard in a complex app. Sure that is always a problem but serving multiple requests makes it worse. The only safe option is to never serve multiple requests. Vanilla is good enough With all the drawbacks, it simply is. If I have a serious async use case, I'd pick node. If I want borderline optimization, I'd try go. There are a lot of alternatives if you're not IO bound. Adding varnish is 10x more productive. Application perfomance optimizations are more productive. If you can do 100ms response times with all that, then async needs to be 10ms to be worth to be considered (currently). Honestly the performance thing is a huge pain in the ass for me. Everybody complains and is looking for the silver bullet, but not for the bottleneck. Which is usually wrong configurations everywhere and carelessness on application level. And neither will be fixed with a switch to async, it will only be worse (in PHP).
Been using this for almost a year now, any idea how to update the IDE without downloading a .dmg file every time? Feels like I'm doing something wrong... updating should feel more seemless.
As someone who hasn't used PHPStorm in years, can you explain the bug a little bit? That sounds pretty disappointing.
Definitely better than nothing, though! It is a step in the right direction for sure.
Wow, that is actually really good.
Minor releases should prompt an upgrade and download the patch file and install it.
yeah this is exactly what i use it for (developing my own API in PHP) and it allowed me to finish developing my server before even starting to develop the client
&gt; Signing up for a college degree will be the best for you if you are anticipating becoming a professional programmer. I am sorry what? &gt;learning to become a professional will require you to start with C And Becoming a professional drug addict requires you start with crack. Who wrote this article? These two statements made me take this article as if it was a joke. I mean they had some actual points after this, like kids programming and game making - but in reality, these two statements make me laugh harder then I ever have - in fact I think I pooped a little laughing that hard.
Hitting double shift brings up the dialog but most of the time it doesn't have focus, forcing the user to either click with the mouse, hit double shift again to hide it and do it again to bring it back (and more often than not, not have focus again), or alt-tab to a non-PhpStorm window. I've had it happen to me like eight or nine times in a row before just using the mouse. It only seems to affect Linux users, though. I'm on Linux Mint, but there are reports for Ubuntu, Arch, elementary OS, Fedora, Red Hat, etc. You can see the issue in their tracker [here](https://youtrack.jetbrains.com/issue/IDEA-124160). Seems to be in the IntelliJ platform and therefore filters down to all the "children" applications as well (PhpStorm, WebStorm, CLion, PyCharm, etc.) Here is [the tweet](https://twitter.com/clion_ide/status/926047528273043456) where they say it won't be fixed in 2017.3 but are "hopeful" for 2018.1.
Ah, I see. Well, at least they are acknowledging it and saying that they are hopeful for 2018.1, that is a step in the right direction rather than sweeping it under the rug and completely ignoring it.
Memory leaks. 
I've always know the phrase "for fun and profit" as very tongue-in-cheek and never meant to be literal - in fact, quite the opposite! I certainly took it that way when reading and didn't presume the author meant anything nefarious by it. But I guess that's the difference between me and you.
I installed it, then after a few consecutive posts, everything froze and I had to force quit. And the nag screens about registering and other 'offerings' are annoying too.
&gt; I try so hard to leave storm for sublime/vscode/atom Any particular reason why? 
In the taskbar there is a "About" tab, expanding it should show a list of items, on bottom of the list there should be one called "Check for update". Click it and it should update automatically. 
Sculpin or Jigsaw, one of those for me. Think you can find more suggestions in this list: https://blog.zipboard.co/how-to-start-with-static-sites-807b8ddfecc Also check out https://www.staticgen.com . They have almost every possible SSG listed, I guess.
I experience it at home, but never at work. What's funny is, that it's the same os and phpstorm version... At least I'm not the only one... 
in egypt you get 100 ~ 150 dollar a month :(
&gt; I would like to close by saying that it is more important that you think about these things and stick with a standard, rather than that there is one true way. Pure gold! Totally agree :) In my previous company some devs seemed to think i was crazy for thinking about these things. Its good to see that more ppl is walking the same path. :)
It is all opt in, but it's also easy to do something blocking by accident. It's also not something you can control well inside a web server env. Good async PHP apps run as daemons. That introduces a different set of constraints, much like building a NodeJS or Go web app. From that point of view (running the web app as a daemon) it becomes opt-in-once-opt-in-everywhere.
I recommend using the Jetbrains Toolbox app to maintain and manage the install. It saves you from having to download a new install file every time as updates are handled by the Toolbox app: https://www.jetbrains.com/toolbox/app/
Debugging js with WS and Chrome is better than ever 
I subscribe to r/unixporn 
more bugs, less features, even more broken syntax parser ? :)
Very good write up. Didn't knew that trick with telling MySQL to use BINARY instead of VARCHAR.
I am using the latest postman version without needing an account (though it did recommend that I do so). AFAIK the account is only necessary when you want to use the cloud syncing and collaboration stuff, which makes sense.
I was thinking the same. I have a project that can make use of this. Also, I didn’t realize the difference in search times was so dramatic, though it makes sense. Long story short: integer ids when possibles, optimized UUIDs when required.
Wonder if it would be possible to use native UUID data type in Laravel if the database supports it, like in Postgres?
&gt; So non-objects such as strings and parameters need a manual service definition. They have tackled this in a way: [Local Service Binding](https://symfony.com/blog/new-in-symfony-3-4-local-service-binding) - basically, it allows you to specify that a given parameter name should always be injected with a specific scalar. It may not be true 'auto-wiring', but it's a lot better than having to add a definition for every service that might need to use a parameter.
I just tried PHPStorm 2017.3 on Ubuntu 16.04 with Xfce 4.12 DE and I do NOT get the search everywhere focus issue. Neat.
Nodejs (+ typescript) exists already with an even bigger ecoystem than PHP. There is absolutely no point using async PHP, something that never have been battle tested and that is not compatible with PHP synchronous ecosystem.
Postman is a very good way to test APIs. There are some very nice tools available in the app that allow you to change tests from local domains to staging and live if that is the kind of thing you're looking for. I found a tutorial of how to use it https://scotch.io/tutorials/write-api-tests-with-postman-and-newman Be aware that Postman is not longer a Chrome app (I think all Chrome apps are discontinued) So skip the installation step and use one of the methods here https://www.getpostman.com/
&gt; As you might know, normal UUIDs are stored as VARCHAR(36) fields in the database. This has an enormous performance cost, because MySQL is unable to properly index these records. Since when? We have indexes on many varchar columns and MySQL handles it perfectly. Sure, binary columns may still be faster, but that doesn't mean there's something seriously wrong with indexing varchar columns in general.
I remember facebook doing some pretty advanced static analysis tools for php before they switched to hhvm &amp; hack -- what was that and why it didn't take off with php developers like their Flow for Javascript kinda did? Can their work be re-used to help these new projects (phpstan and the like)? 
&gt; normal UUIDs are stored as VARCHAR(36) fields in the database Why in the world would anyone store fixed-length data in a VARCHAR field?
The blogpost linked from this one has more in-depth information: http://mysqlserverteam.com/storing-uuid-values-in-mysql-tables/
Actually it's `CHAR(36)`, that was my bad. Thanks for pointing it out
"hm... this seems to be a text... with fixed length... probably this should be varchar"
Remember, the bit-shifting of UUIDs only works if you're using UUIDv1: &gt; So it makes sense to re-arrange the UUID, making the rapidly-changing parts go last, before we store into id_bin. Again, note that this idea applies only to UUIDs of version 1. Do not use this against UUIDs of any other type (especially not UUIDv4!). Just storing the column as binary (and putting the UUID in as binary) is sufficient for most use cases.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I tried using pthreads to sleep for 1 second with 10 different threads with the hope that the end result is sleeping for 1 second rather than 10 seconds. It slept for 10 seconds, so I concluded that threading doesn't work with PHP. I might have been doing something wrong, but this discouraged me from trying to do async stuff in PHP. It was a lot more straightforward in JavaScript.
Yes, this is major reason why re-sorted time based UUIDs should be under consideration when picking a version for IDs that are stored in database primary keys.
IMO, UUIDv1s have a very narrow usage, even when sorted well. Most people want/need UUIDv4 generated using a CSPRNG. The fact that some UUID generators in some frameworks give out "v4" UUIDs that are actually v1 UUIDs with a weak RNG source doesn't help matters.
Why not convert to integer IDs instead of binary? The graph at the end shows they are far more performant. 
a UUID is a 128bit value, in the case of MySQL, an unsigned BIGINT is only 64bits- meaning a pair of ints would be required.
Also because of the two reasons mentioned in the blogpost: - Truly unique IDs over the whole database, not just one table. - Not exposing information about the amount of data in a table.
Everyone seems to be focused on APIs but Postman is more general than that. It simply allows you to run HTTP requests. You can add parameters, postdata, cookies and the like. Useful for testing forms and stuff without having to constantly re-enter data. 
In case upgrading to 7.2 is not obvious. 
Remember PHP 5.6 and 7.0 ends security support in 1 year http://php.net/supported-versions.php
What character set do you use with CHAR? It's still not optimal but ascii should do a lot better than utf8mb4.
&gt; Truly unique IDs over the whole database, not just one table. Fair point, though in my experience it’s rare that you need unique IDs across tables. Chances of a collision using BIGINT is practically 0. &gt; Not exposing information about the amount of data in a table. IDs don’t do that either. You’re thinking of AUTO_INCREMENT. And doesn’t the way you suggest using UUIDs (with the timestamp) expose information?
Release announcement: http://php.net/archive/2017.php#id2017-11-30-1
[Changelog here](http://php.net/ChangeLog-7.php#7.2.0) for those not up to date on it.
&lt;3
A bigint holds over 18 quintillion values, more than enough for 99.9999% of use cases. 
procedural sagas?
point being storing UUIDs in ints instead of binary isn't feasible.
&gt; procedural sagas? What do you mean? &gt; Term "pipeline" has so many meanings and ways how to achieve that, why you name it like this? of course there are may way to do the same thing, and each of them has small differences... as Anthony Ferrara show in one of his presentation https://docs.google.com/presentation/d/1Or4waGYMCP0keLDEPU26yPk5j2TC-RX4yVa79HHGzhY/edit#slide=id.g26ae1877f_0118 (slide 22 especially) many of the most common design patterns can be seen as a single one with some variations. Call them pipelines, middleware, filters, in the end the result does not change... except for few details 
There are options for keeping php 7.1 as fallback (if file compilation fails with 7.2, 7.1 would be used in next attempt). If you know how to do that on Ubuntu, it would be nice addition to the guide.
You did not explain how you wire everything up. Do your objects implementing the OrdersWhereInvoiceWasNotPaidQuery have a repository as a dependency, a query builder, entity manager or a database connection? Or we have to get the book to find out? :)
upgrading framework should be as easy as composer update but it doesn't seems that way with laravel.. you can even make business with helping others upgrade laravel (laravel shift).. haha
phpDoc will have it's own AST in your tool? Good. Is that AST implementation existing in dependency? If not, could it be extracted? (Is it two way already?)
Yes, of course, it's a separate package 😊 https://github.com/phpstan/phpdoc-parser There's no README yet, but it's being created in a branch: https://github.com/phpstan/phpdoc-parser/tree/pr/wip
Migration guide http://php.net/manual/en/migration72.php
👏
Integer Ids have their own pitfall, and UUID could be generated by client code, but integers need to be assigned by DB, so round trip is required if we need that identification. So it's read vs write trade off.
Nice work everyone!
&gt; Disallow passing NULL to get_class() &gt; Warn when counting non-countable types I am looking forward to the awesome bug reports / screams of outrage from people where their code is only working by coincidence, and these two changes 'break' their 'working' code. 
It seems to me there is no need to this "additional overhead" caused using UUIDs. Fetching, say, 16 bytes from random_bytes() will do the trick. It is simple and clean and won't have any drawbacks.
I've got this issue because Laravel 5.1 (the LTS release) attempts to pass in `null` to `count` in a number of places within the ORM. The upgrades to Laravel are going to be a fun few months.
any idea if that behaviour is also in 5.5 ?
This is the issue I created for 5.1 - https://github.com/laravel/framework/issues/22162 - it looks like a number of the properties within that class are still initialised as `null` so it's possible that the issue could crop up, but the problem I had seems to have been fixed in the trait - https://github.com/laravel/framework/blob/5.5/src/Illuminate/Database/Eloquent/SoftDeletingScope.php#L55 It's not an ideal fix IMO since you'd have to remember to perform the cast to an array everywhere.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [laravel/framework/.../**SoftDeletingScope.php#L55** (5.5 → dc4925f)](https://github.com/laravel/framework/blob/dc4925f7e711dec2986c249ca25e053fd16747c4/src/Illuminate/Database/Eloquent/SoftDeletingScope.php#L55) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
thanks!
It's a common fallacy that you don't have time to write tests. What you're doing is offsetting debugging time later by writing tests now. Personally, I've switched to TAD (Test After Development) for fast moving projects. That way you don't waste time writing tests for code you'll ultimately throw away. 
Looks like Taylor wants to improve 7.2 support in 5.1 (https://github.com/laravel/docs/pull/3889)
Did you miss the "UU" part? With random and only 16 bits, a collision in more than probable.
Yep. At the risk of sounding cynical, even more magic is exactly what we need in our code. Hopefully, everyone uses globally unique constructor variable names in their code. I never found that adding a manual service definition to be much of a pain. And having the definitions to review later was often very helpful. But we shall see. Hopefully the Harry Potter Container will be a great success.
- make a comparison table with competitors, enlightening the strenghts points of your tool over the competition - drop the free tier - if you put laravel in tools (should be frameworks) you should add other major frameworks as well Symfony, Zend, Slim etc
Not 16 bits, but 16 bytes (128 bits). No collisions.
Also very useful in distributed systems where data is created in multiple points but eventually ends up in one central database. 
Or you could just use PHPBrew...
&gt; for duck-like anatomy Did you know ducks have harpoon-like penises which they can launch from their body?
This comment point out a good use case: https://www.reddit.com/r/PHP/comments/7gk8tp/optimising_uuids_for_better_performance/dqk3q7f/ Seems to me that when using binary IDs to support these cases, you're actually writing a lot of the UUID logic yourself. So why not use an existing format?
You're correct. MySQL is properly able to index VARCHAR columns. The text in the article is misleading. The misunderstanding comes from the *small* difference (though measurable) between a binary comparison and a collative one. Indexes done on VARCHAR are built using the colation and hence are "less efficient" than a binary index. However we're talking percentage points, not "enormous performance cost". I'd expect that the VARCHAR vs CHAR (or VARBINARY vs BINARY) would have a bigger efficiency gain than the switch from char to binary. Indexes are a red herring there...
You cannot guarantee "no collisions" without using a UUID lib (or something equivalent).
Always makes wonder, why do people hate PHP so much?
I'm studying PHP for 3 months, I covered all it basics and OOP features. I'm also learning how to use Laravel and I'm already able to create basic web applications and do the CRUD with my database relations. How can I practice my skills? Where can I find any project breakdown to study and practice? 
https://github.com/ramsey/uuid/issues/80 ;) With a CSPRNG (like PHP's random_bytes) collisions won't occur if the length is great enough. 128-bit output is more than enough.
I've realized recently that socially, programming languages are less like linguistic languages and more like cities. Doesn't matter how good Cincinnati/DC/Austin/whatever is, there will always be a vocal group hating living there or dismissing it from afar. Case in point, I live in Orlando. Like PHP/JS/Java, it has its faults and quirks. Locals will have you know how much they hate the transportation infrastructure and at least a quarter of reddit will point to our neighborhood hero Florida Man. In reality, neither are as bad as they seem and the food is awesome.
"The clod"? FYI, we're slowly moving away from resources everywhere, eventually that'll include files as well. They're just a useless, miserable little type.
Gratz on the release! What's next? php 7.3? 8? When 7.1 (and even 7) was released, there was already some discussions about 7.2. But I saw absolutely nothing about the next version (not that I looked very hard). 
&gt;Since PHP5, objects have been the preferred structure for wrapping internal data, however **some clod** created the hash extension to use resources. This RFC seeks to rectify that error by migrating the Hash extension to use an object implementation for hash contexts instead of a resource. 
Sara Golemon according to the original header of the extension....but the author of the RFC vote is the same Sara Golemon. Just making fun of herself, I guess?
Because PHP 4. The people who hate it haven't used it since then, and only remember the language PHP used to be. Or they just say they hate it to be a part of the bandwagon. PHP is kind of the Nickelback of programming languages that way: There's nothing *wrong* with it in particular, it just fills a particular niche, and it's not really "cool" to appreciate it for what it does well. It also doesn't help that all those "PHP tutorials" out there are almost always made up of completely terrible code.
 If you don't have time to write tests, then later on - most likely after deployment - you'll have a support ticket come up with "this is broken". These tickets will always arrive during the most pivotal time on another project. This is what your tests are stopping, or at least that's the reason they're there; as well as confirming stability when making further changes - that should never be forgotten. Make time for tests, it __will__ save you time in the long run. It just doesn't feel like it at the time. If the client is pushing and complaining with the usual "we'll test it as well, don't worry" simply don't tell them that you're writing tests; it's part of the __development phase__ after all - end-user testing is entirely different.
Well.. your answer helped me a lot! Thanks for clarifying everything :)
I know that bug very well, it was OpenSSL+Apache faults, it was using same seed for concurrent generation. Also, I think that lib migrated to random_bytes now, so...
As someone who *doesn't* subscribe to r/unixporn, I have no clue what that response is supposed to mean.
Here's a sneak peek of /r/unixporn using the [top posts](https://np.reddit.com/r/unixporn/top/?sort=top&amp;t=year) of the year! \#1: [\[Kindle\] Debian on my Kindle!](http://i.imgur.com/Nxb8R0X.jpg) | [318 comments](https://np.reddit.com/r/unixporn/comments/6a4whs/kindle_debian_on_my_kindle/) \#2: [\[Shitpost\] r/unixporn starterpack](https://i.redd.it/yu0auhxk5nyz.png) | [118 comments](https://np.reddit.com/r/unixporn/comments/7dptzf/shitpost_runixporn_starterpack/) \#3: [\[GNOME\] They said Linux is for IT people only: My desktop PC running Ubuntu in my office. I'm a physical therapist.](http://i.imgur.com/5otzCMo.jpg) | [190 comments](https://np.reddit.com/r/unixporn/comments/6vjua2/gnome_they_said_linux_is_for_it_people_only_my/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I use Uuid4 on my Laravel (I think 5.2) project that is using Mysql as the database, with all UUIDs stored in the database as binary 16. I could do a write up of how I did it if there is any interest.
To be honest, for 99% of PHP's usage, I think async is more an annoyance than a possibility. For simple process HTTP request in, HTTP response out, non-blocking code is just more difficult to handle. I've worked on some Node projects, and they ended up being littered with callbacks, promises, and async/await just to work around the fact that in JS one instruction might finish executing *after* the following one. On frontend apps (or any other UI-driven app) this makes sense, but for classic backend stuff, async is just not worth it.
because of the low barrier of entry, a lot of people who can't really program have worked with it, so there's a lot of shit code floating around
You Think The two statements about the college degree and the C Programming were not appropriate compared to the kids type of programming and the game? Just wondering why is so funny...lol
lol
The issue has been discussed previously here: https://github.com/laravel/framework/pull/20258
After a few projects doing TDD, i think i'm actually developing at the same speed or close, but with a lot of extra confidence on my code, maybe because i write more integration tests than unit.
What did you blood work revealed? 
I've seen a few mentions of 7.3, though I'm not convinced either.
Do you already know "Xdebug Driven Development"? That doesn't mean you're debugging code after you deployed it and your customer reported the bug. No. It's about debugging the code as you write it and not just when it's too late. During the development you go through every new line with Xdebug and check the stacktrace, the variables and results. Do that for everything that has changed. It could also be called "manual code coverage" ;-) XDD increases quality without compromising the deadline. As soon as the time (and the budget) allows it, you should definitely write unit tests for it.
The official NEWS file for the master branch confirms the next version as 7.3. Alpha 1 is already in development: https://github.com/php/php-src/blob/master/NEWS
I've compiled my usual list of installation instructions for many popular OSes: https://www.colinodell.com/blog/201711/installing-php-72 If I missed yours (or you see an error) please let me know and I'll update accordingly. Hope this helps someone!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php/php-src/.../**NEWS** (master → 2454226)](https://github.com/php/php-src/blob/245422653c97cd1fb6bcd6de725574b37b4b639b/NEWS) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
php X
&gt; Also, I think that lib migrated to random_bytes now, so... This brings us back to my original point: https://i.imgur.com/e6CqXJt.jpg
Have you _read_ php-src? :P
Not indexing. The real problem is using them as pk. A simple join on two tables using char pk/fk is a huge problem performance wise. 
Because if you look at the two statements they state of you want to be a serious professional programmer 
God's work? You're doing it.
&gt; I've written a JS app in Cordova once. All the DB calls were asyns (with no proper way of making them sync) same for ajax. It was as a mess. Why would you want to make them sync? 
I see, and that discussion looks good. I think the interesting thing here is that a couple regular contributors thought 5.1 shouldn't deal with these new issues, but Taylor wants them fixed. 5.1 is ancient (by Laravel standards), so I think this shows a lot of maturity and goodwill.
&gt; I just wish I had the option of doing it synchronously rather than being forced to do it async all the There is no reason to perform IO operations synchronously in JS.
legacy barbage
Symfony sure knows how to create a good hype! I've been looking forward towards this version for the whole year!
Symfony... where i finally failed. Back when MVC frameworks were starting to get popular, I learned CodeIgniter. I did well with it, but I learned it was pretty lacking. So I looked into powerful alternatives. I couldn't ever learn symfony, I gave it many months at trying to make it work, but it was too much for me. I'm not saying it's a bad product, in fact, it seems to be one of the most robust. I just couldn't hack it. Every time I see something with symfony in it, I am reminded of this. Don't do webdev, kids. Stick with drugs, they are way more fun
&gt; The entire idea about the repository pattern is more of a theoretical idea than a practical one. You will not be able to easily swap out your implementations even if you use the repository pattern. &gt; That's because Laravel is using an Active Record ORM. 
I can't get over the use of -&gt; instead of . 
caca boudin
There was a great comment on HN this morning along these lines. &gt; The modern ecosystem (Symfony 3/4 especially) and practices enabled by 7.0+ are good, but all the old horror is still lurking behind the curtain, and there's not much to prevent naive coders from writing garbage like it's 1999. It's not that dissimilar from the Javascript situation, where you have some people still writing spaghetti jquery in random globally-namespaced places and some people in basically a whole other world writing type-checked and compiled modular code. [source](https://news.ycombinator.com/item?id=15815337)
&gt; I just couldn't hack it. Could you describe which things was difficult to you?
Hm, Well, This was back when it was Symfony 1.x, and i think eventually 2.x came out and I also tried with that. Hm, I think it was just the abstraction. Code has evolved into so much abstraction it's really hard to follow unless you have someone that can sit down and explain it to you directly. I watched countless videos, symfony youtube tutorials, but usually some command wouldn't work when setting it up and so I'd get stuck trying to find out what to do, and I didn't have a firm enough grasp to really understand where to look myself, so I relied on others having the same issue as me and finding a solution, but that frequently didn't happen. So the crux of the issue was trying to wrap my head around all the abstraction and not being able to debug stuff myself due to that very lack of knowledge.
Go away already 
* Don't go for 100% code coverage, it's a loss of time (except maybe when you are developping OS packages). Better focus your time on complicated stuff. I remember Martin Fowler and Kent Beck saying some of their project are in the 50% code coverage range. The point of TDD is to give you confidence. Some part of our code are so obvious, it's a waste of time. * TAD is a thing. Might work better for you. TDD is not the only way forward^tm * Experience to choose what to test thouroughly and what to test quickly (or what not to test at all). * Integration test over Unit test. You loose precision in the error messages when things break, but ultimately Integration test more per line, and it's not that hard to have 100% unit test passing, and a broken app anyway.
*laughs bitterly over mission-critical PHP 5.3 app*
Thanks for posting this, I work from home in a high-stress job and routinely question my sanity. I have an extremely short temper and my social skills have definitely declined over the past 5 years of I think due to physically working solo with only online communication among my professional peers. Chat, reddit, hacker news, etc loses a lot of nuance and people (including myself) can turn into total assholes in ways we'd never do that in person. It's definitely unhealthy and I'm seeking help. This article convinced me to finally set up an appointment with a therapist.
Dropping Netware Support?!?! You motherf****rs! /s Just kidding. I haven't targeted a NLM since the late 90s. It's ok to bail on it guys.
It's up to you, use whatever makes most sense for that query. In the book (and at work) I use Doctrine DBAL for most of my query implementations :) 
This is exactly how I structure any large project!
The nice things about abstractions is that you don't need to understand how everything behind it works. But if you couldn't even set it up it sounds like it was mostly a documentation problem?
But . is the concatenation operator so it wasn't really an option.
If we were planning PHP 8, you'd already know about it. :)
get a life :D
Thank you for the advice. I don't do webdev anymore, but I often get requests for it still, and Symfony is still on my "to-learn" list, simply because I don't like having failed. If I do take up another webdev job, I will give it another whirl. I'm sure things have changed a lot.
Cracking it right now
I think you are not really getting the point I'm trying to make here, I'm well aware that eloquent is an AR style ORM. My point is that if you try to abstract those details away using a common interface with the repository pattern (which is essentially the same for doctrine and eloquent) you will have a problem. You can't abstract it away in practice because of other usability issues that you can't just ignore 
When I started PHP in 2000-2001 I bought this 5” thick PHP book that showed you all the magic of things like sessions for user loins, form processing, etc etc. It wasn’t until the end of high school in 2003 that I was introduced to how badly that book had led me down the path of “your code is going to get completely molested by even the noobiest hacker”. RIP my first resume collection system :’(
Isset on array indexes with null values.
I'm drinking a beer now to celebrate! 
The most important think I did to help the transition was I ended up changing a lot of the keybindings similar to sublime. The ones off the top of my head are: - fixing indent from tabs to cmd bracket (storm default is tab and shift tab) - cmd p to find a file (storm default is cmd shift o) - cmd shift p to open/switch projects - cmd d to select the next instance (storm default is ctrl-g)
I think most of the hype lies in how damn stable symfony is. Usually a new symfony version brings a whole lot of goodies without any extra headache. 
I sometimes have that, sometimes not (using Debian/KDE) - I have also had it that after opening a file with Search everywhere and trying to close Search everywhere it has meanwhile lost focus but is still around, meaning it needs to be clicked again just to close it. PHPStorm sometimes does have weird issues.
 It was pretty bad in 5.2 as well. 
This is a great article for us working from home and I’ll definitely be trying some of the things he put out. On a side note this article kinda humanized Taylor for me, especially since I’ve mostly seen him as the guy who just closes my PRs.
Because they reference an article from 2012 to prove it's bad. That's about as much brain power they can scrounge together for an argument.
&gt; You can't abstract it away in practice because of other usability issues that you can't just ignore We'll agree to disagree then.
I think 1 thing to get used to in PHPStorm is the interactive context menu. you can do everything with it. I found this site by /u/nikush http://phpstorm.tips/ shows some useful small tips in phpstorm. And laracasts has a series on optimising workflow in PHPStorm https://laracasts.com/series/how-to-be-awesome-in-phpstorm
For docs you can take a look at http://rollout-docs.grandappstudio.com
&gt; $userRepo-&gt;deactivateUserId($id); &gt; How exactly is there anything wrong with this? &gt; Ubiquitous Language is the term Eric Evans uses in Domain Driven Design for the practice of building up a common, rigorous language between developers and users. This language should be based on the Domain Model used in the software - hence the need for it to be rigorous, since software doesn't cope well with ambiguity. https://martinfowler.com/bliki/UbiquitousLanguage.html
Can someone please explain why this is a major version release? The article only mentions bug fixes.
I used detectify.com to run a web app scan on our wordpress site at work. Needless to say I have a lot of work to do in our next sprint :sigh:
It usually even relieves headaches. And prevent some new ones. 
That is a great comparison!
Totally get what you're talking about having started on 1.x and did a bit of 2.x as well. Just so complicated compared to basic PHP or a framework like CodeIgnitor. I gave up on frameworks at that point and just made a mini framework of stuff I needed for myself. Worked fine. Frameworks are for sadists who like to upgrade every year at the whims of other people deciding to release a new version and change all the APIs on you. Learn the base core language of PHP and you can do far more.
Some good crypto improvements in this release. Well done.
Mental health among programmers seems to be one of the most overlooked health hazards of the job. Sure there's lots of talk about [imposter syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome), but not about most of the daily challenges Taylor talks about. It's great to hear an article about those challenges and how they can be mitigated.
It demonstrates a commitment to LTS meaning more than what might have originally been intended, which I generally take as a good thing.
I believe that's only the changes since the last release candidate to the stable 4.0.0. [This might be a better guide to the changes.](https://symfony.com/4)
I've met many of the guys behind RIPS, at various conferences, and they are the *real* deal. One of the principals has a PHd in Static Analysis, and they know PHP inside and outside, on a very deep level. Their product is really cool and I recommend it for anyone writing security sensitive PHP.
To be fair, the needle haystack inconsistency is lame. Tell me more about this integrated development environment, sounds interesting. 
I have found developers to more likely hide mental health problems. Most of my coworkers seem 100% on the spectrum but would never admit that. I have aspergers and feel like it's kinda taboo to talk about it. This is great on Taylor for speaking out!
Your web server is missing the MySQLi PHP module. Options: Have the server sysadmin install the module for you. Use the old/outdated mysql functions instead of mysqli.
I set mine to use the NetBeans keymap. File-&gt;Settings-&gt;Keymap You can make your own keymappings.
Maybe you need a good IDE. Also, check out Uncle Bob's clean code videos. They're weird, but they have some really good information. 
I've often referred to https://www.percona.com/blog/2014/12/19/store-uuid-optimized-way/ for UUID storage.
I mean, Red Hat has your back till like 2020
Yup. Could just use a randomly generated 64-bit value (or hell the first half of uuidv4) and store in a single bigint column.
They always release the new major version at the same time as the last minor version of the previous major version. So, this time it was Symfony 3.4 along with 4.0. Symfony 4.0 is roughly the same as 3.4 - deprecations. This means you can easily update to Symfony 3.4 for the features, fix the usages of deprecated functions when you have time and finally upgrade to Symfony 4.0 without any issues.
Thank you, I believe this is the problem. 
Smyfony 4, PHP 7.2.0 and IntelliJ IDEA 2017.3 all in one day? What an awesome day for software and development!
Oh, wow, that does seem pretty substantial. Nice. 
I would recommend to just read his book. Even Bob considers his videos as boring, that's why he started to cosplay star track characters.
&gt;Frameworks are for sadists who like to upgrade every year at the whims of some company deciding to release a new version and change all the APIs on you. Symfony definitely does not do this. Version 4 is the first version to contain significant BC breaks in a few years.
Use an IDE and never worry about needle/haystack order ever again. Write more explicit code instead of using empty. If you want to check if a string is empty, use `=== ''`.
When I switched, I changed the keybindings that I used a lot. For the other I printed out a cheatsheet to learn the PHPStorm ones. Took me a couple of weeks to really get the hang of it, but that was one of the best time investments I've made in my dev career.
Build a real application. That's the best way to learn (and looks great on your CV). What you do might depend on your skill level. If you need some ideas: - Todo List - Blog - Social News site (like reddit) - Social Network - Forum - Online Shop You don't have to build out a fully featured site right from the start. Pick something that you find interesting, narrow it down to the minimum features and get started.
PHP is developed by the PHP Group and its contributors, ZEev and aNDi are both parts of the group; PHP is build on top of the Zend Engine (since PHP4). Zend as the company that Zeev and Andi founded provides resources for the PHP Project, and offers Products around PHP (Zend Server, Zend IDE, Certification..)
&gt; Symfony... where i finally failed Don't be too hard to you. A framework's purpose is to make your life easier. If the framework was too hard, it did a poor job.
Symfony 1 is not really comparable to what exists now... It was really a pain :D No composer... Singletons... Propel... Documentation... If you really want to learn it anytime soon: Use php 7.2 with symfony flex / composer and maybe docker. Should be a pleasure to work with.
What are the advantages over [Wiremock](http://wiremock.org/)?
Except the concat operator could have changed to something else too. Like `,`. (It would still be possible to keep `echo`'s behavior with `,`. For example `echo ($a, $b), $c;` could have resulted in a concatenated string of `$a` and `$b` while $c would have been printed without concatenation.)
Don't see it as a failure, just see it as an experience that you learned from and then it won't seem like such a hardship. I will say that Symfony has come a long way and it's now a pleasure to work with.
I'm suffering through the exact same fate, friend. Quit my day job and started freelance programming since 2013, and been in the exact state you are describing since then. From experience, I can say that more than therapy, its the habit of meeting more people in the physical world that we should cultivate. Somehow, it seems that we are biologically programmed to feel psychologically better when we meet and/or communicate with someone. All your angst and frustration will vanish the moment you meet a like-minded individual and have a chat every now and then.
Yep me too. I get night-time anxiety when I perform the amazingly stupid feat of viewing my life from the POV of my death-bed, and realising that I will have spent the majority of it sitting silently in front of a screen. I believe we're social animals and that this is *exactly* the wrong way to live life. Co-working spaces can help a bit...
well, this time, not only. Fabien explained that in post, that "Symfony 4.0 = Symfony 3.0 + all features added in 3.x — deprecated features + a new way to develop applications". And that "new way" is Symfony Flex. Of course, with "legacy" app upgraded to 4.0, it will be just "standard" Symfony 4, the old way.
Here's a good getting started guide with example console output: [http://php5.laurent-laville.org/compatinfo/manual/5.0/en/getting-started.html](http://php5.laurent-laville.org/compatinfo/manual/5.0/en/getting-started.html)
Yeah that’s Symfony Flex. Although it can also be used with Symfony 3.4.
&gt; Seems to me that when using binary IDs to support these cases, you're actually writing a lot of the UUID logic yourself. So why not use an existing format? UUID's may have some usecases, but simply just using (proper length, say 128-bit) CSPRNG output you don't need any format. Just plain random_bytes() output. It has all the benefits, always quaranteed unique, not leaking information and it is very simple solution. I mean, UUIDs may be a good solution here, but CSPRNG output instead of UUID is even better (better overall security margin and less "moving parts").
1.5.4 even... fixed regression
keep in mind that detectify does not check for 0day vulnerabilities and only reports publicly known issues, afaik
symfony is not too hard though...
&gt; his post will be updated once the **official** 7.2 Docker release is available. Can anybody help me understand what "official" means here? Is it released by PHP.net, if yes then how can i verify that?
And by doing that you will probably make all the mistakes frameworks prevent you from doing. Frameworks evolved so much in the last couple of years so I really suggest you give it a new try :)
no it couldn't. `-&gt;` was added well after `.` was already a thing so there would have been a big breaking change.
If you work with Symfony (Framework) or not... I think everyone has to agree SensioLabs influenced the world of PHP in a very positive way. Props to them :)
Maybe it is now for you, but it wasn't back then for OP.
The Docker image linked to the above article is for the official PHP release approved by Docker. See here: https://github.com/docker-library/php
The "official" Docker images are primarily maintained by a team sponsored by Docker Inc. More details about that program can be found here: https://docs.docker.com/docker-hub/official_repos/ P.S. 7.2.0 is now available in that repository :)
Well thats make sense now :) and thanks for the link.
Depends on composer rather than gradle
yep, all major frameworks use something from symfony.
takes longer to make a project though
Our boss really likes the videos, so he purchased the whole clean coder series. It's actually upped my game quite a bit, but yeah, his book is basically the same information. 
Its not the frameworks fault
1.5.5 even, another regression fixed
&gt; During the development you go through every new line with Xdebug and check the stacktrace, Uhh, OP said they don't have time for TDD, what makes you think they'll have time for this nonsense? lol
I know that this is not perfect, but a manual (and quick) test is better than no test at all.
That is a really cool idea. There's a lot of work on ensuring code will run on older versions or on letting code specify the version it expects, but being able to take arbitrary code and find out what you need to run seems pretty novel!
It's useful to have people who can talk about these sorts of issues and raise them to peoples 'public' awareness. Some people have these same feelings, but don't always think they are valid or even relevant and definitely not for public consumption! I lost a well paid but stressful programming job through drinking way to much for to long. Now I've not had a drink for years and help run a group for people with addiction problems. It's useful to have a place where I can vent about the crap I'm being asked to do as well as help others going through similar problems. Hardest part though is trying to decide on a new career...
Comes with Sodium extension check here some basic examples: https://github.com/jedisct1/libsodium-php#examples 
Ahh, we got one of them self-hatin clods.
Whats the advantage over openssl for the things that you can do with both?
[1.5.5](https://github.com/composer/composer/releases/tag/1.5.5) Another regression fix. Probably gonna be 1.5.6 at this rate. :P
in before 1.5.6
is there a point of publishing this here? I mean I get publishing new PHP versions or major framework releases. But this minor fix (3rd today) is just pointless... Anyone's doing `composer self-update` anyway.. right?
More modern and safer cryptography e.g. Argon2, ChaCha20, Poly1305, proper AEAD scheme etc.
So what I see, and correct me if I am wrong - is that you are taking the logic to get A, B and C and hiding it else where, in this case in a static method call.
In combination with reading tutorials and best practices, even implementing some of the features or patterns frameworks are using you can't go too far wrong. The added bonus is you know the code inside out and can debug it. Good luck debugging someone else's framework.
Doesn't it get updated pretty regularly?
Ok, you're right. It's OP's fault.
Exactly this. I can easily deploy this to our CI server.
Yeah, well the guy that developed us should be fired for writing such a mess in the fucking first place.
Unit testing HTTP requests is not a thing. Unit tests only test a small piece of the code. If you need to mock a web server, you are doing end to end testing. https://d2h1nbmw1jjnl.cloudfront.net/ckeditor/pictures/data/000/000/158/content/typical_pyramid-1024x938.jpg
It's not for unit testing HTTP requests. It's for unit testing things that *make* HTTP requests - namely legacy code largely where I cannot inject Guzzle or such without a total rewrite. So for example an actual simple test I use this for in my codebase with names obscured /** * @expectedException \NameObscured\Exceptions\ResponseException * @expectedExceptionCode 2 */ public function testGetObscuredThing_noData() { $endpoint = self::$webserver-&gt;getUrlOfResponse(''); $ar = new NameObscured($endpoint, 1010203); $ar-&gt;GetObscuredThing('fake-name', 10, NameObscured::LANG_CODE_ENGLISH); }
New features?
there is no static method call involved in resolving these dependencies. all static method calls you see in the example are constructor calls. you could rewrite ProductsRequirement::All() to new ProductsRequirement(). It's just a constructor for the Requirement. The Requirement is fully decoupled from any kind of logic.
The DB of defined symbols is fantastic! How did this stay under the radar for so long?!
There is some detail on their web site - their tool is finding code defects rather than system exploits. Whether a system exploit existed or not would depend on other details of the setup. For example, a file upload tool that is for uploading "images" but lets one be called "blahblah.php". Can that file be somehow run by an attacker - that would depend on other problems in the setup.
Oh... hahahah, yeah, I forgot about the RFC wording. :D Yes, I was that clod.
One does not simply /read/ php-src
I usually won't have to since most bugs were found by others, fixed by others and documented by others ;) I don't see any reason to waste so much time on work that's already been done in a far better way than someone would be able to do on his or her own.
I just discovered this today, which breaks in PHP 7.1: $var = ''; // ... a bit later ... $var[] = 'whatever'; Obviously $var was supposed to be declared as an array but this slipped by until today.
Just because a change could break code shouldn't be the only consideration whether the change should be introduced or not.
Still 1.5.5 😉
153 commits in a day...
This entire idea seems like a ridiculously inefficient approach to avoiding simply writing SQL.
I can see your point. However some of the bigger frameworks are run by other companies and they end up increasing the size, scope and complexity of the framework often beyond what is needed for small-medium size custom applications. Some frameworks I really liked as a library. Zend Framework 1 worked well as a standalone bunch of libraries. Probably some of the newer frameworks can work in the same way. I haven't been back to PHP since ZF1, SF2 days, been doing front end development mainly since then. Things have probably improved and I hear Laravel is the new hot framework. However with time it will probably bloat up too.
I’m not worried about the static call I’m more worried that this just hides logic
What we found when we looked into Detectify a few months back is that they are adding a [fairly limited amount of tests for publicly disclosed vulnerabilities in WordPress plugins](https://www.pluginvulnerabilities.com/2017/09/29/detectify-doesnt-do-a-good-job-of-protecting-wordpress-websites/), so the value provided for WordPress websites is going to be somewhat limited. That also looks to be true for websites based on other software as well, based on the number of vulnerabilities they claim to have tests for. It also should be more efficient to check if a vulnerable version of a WordPress plugin is in use instead of trying to exploit the vulnerability, as their service does. For checking WordPress plugins for security issues more along the lines of what is written in the RIPS post you can use a [new tool we created](https://www.pluginvulnerabilities.com/wordpress-plugin-security-checker/). We still have a lot of improvements in the works to catch more issues, but the check it does for PHP object injection vulnerabilities like the one that was mentioned in the post, has been used by us to find quite a few PHP object injection vulnerabilities in WordPress plugins already. 
I'm continually amazed at the lengths people will go to avoid writing SQL. SQL is a declarative language (you express your requirements) and the query planner figures out how to optimally fetch what is needed (it resolves those requirements).
a "requirement" is an indirection and therefore of course "hides" logic. but most more advanced patterns like "query objects" aka "Criteria-Pattern", specifications, CQRS, ... does the same. the reason is simply abstraction. it's quite easy to support different data sinks, refactor code, ... a requirement is nothing more than a data object that needs to be resolved. like a future / promise. the main difference between this pattern and futures / promises is that the resolver knows all requirements at the same time, which allows you to rewrite queries/requests to resolve multiple requirements at the same time. for example if you've a page with 10 widgets, you could collect all requirements from all widgets. than the requirement resolver would figure out the fastest way to resolve all requirements at the same time. if you would plain SQL this wouldnt be possible. 
how ever could an sql optimizer optimize something like GraphQL Requests? for example take a look at https://dev-blog.apollodata.com/optimizing-your-graphql-request-waterfalls-7c3f3360b051 the Requirement Resolver Pattern tackles this issue. it also has nothing to do with sql. consider you've 20 microservices and one graphql api that gives the world access to your data. the Requirement Resolver Pattern would allow you to create requirements from the GraphQL query and optimize the way how you collect the data from your microservices.
But then you'd have to check if it exists first. *empty()* and *??* have been my favourite additions to PHP so far, but I would never use them on strings or numbers that can be zero.
You wouldn't by sending a GraphQL request to a relational database. I'd suggest you do something novel: You write GraphQL and let the GraphQL server parse it, and handle the underlying API requests, as that's quite literally its job.
&gt; and handle the underlying API and this can be quite complicated for nested GraphQL Queries. consider you've such a query ``` user(id: "1") { name height, friends { name } }, user(id: "2") { name }, timeline { foo } ``` if you're using a sql database, may the most efficient query would look like ` SELECT name, height FROM users where id in (1, 2) SELECT name FROM users where friend_of in 1 SELECT foo FROM timeline where ... ` when you've really large and deep nested queries it would become very complicated to create these kinds of queries. it would be even harder if (for example) the timeline isn't stored in an SQL Database at all. May you need to load it from another data sink? a microservice for example. and may some of parts of the query will overlap, for example a friend of user1 could be user2, so there would be no need, to resolve user2 multiple times. this is a very hard problem. the requirement resolver tries to makes it as easy as possible to help you to find the fastest way to fetch ALL the required data. 
After it is done, it outputs a cute little thumbs up emoji. I've been asking for this for years.
&gt; if you're using a sql database, may the most efficient query would look like SELECT name, height FROM users where id in (1, 2) SELECT name FROM users where friend_of in 1 SELECT foo FROM timeline where ... Oh, you don't understand realtional databases / SQL. That actually answers almost everything. 
GraphQL has nothing to do with how you load this data from your data sinks. it helps consumers of your api to query data but if you provide an GraphQL api it's on.
Well fuuuuck. I am still in beta on a large project using it as our back end API server. Guess I'll watch this thread with great interest for alternatives. 
It sucks, I liked Silex more than Symfony stock because I mainly write microservices. All the front-end is done with Angular,React or Vue so I have no needs for Forms,Twig or even Doctrine ORM. Silex was really well thought,especially as the developer could easily write middlewares, unlike Symfony, and combine controllers in a logical way. Did you check Lumen? maybe it has more users than Slim or other "micro" frameworks. Frankly, the fact that one could write complex apps in minutes with Silex made it really worth it.
I'm so sad
&gt; The nice things about abstractions is that you don't need to understand how everything behind it works. &gt; Well you do actually. It's not like PHP does encapsulation very well(no private classes), so everything is leaky. You can't use Symfony without understand how its core works, and it is complicated. The forms are complex, the evented kernel is complex, the DI is complex, the bundle system is complex as well. PHP developers try hard to emulate Java but I'd argue Java strict typing makes it often easier to navigate a foreign codebase, PHP mix between strictness and dynamic typing, excessive use of arrays that are also hashmaps often make code difficult to decipher.
Ah, yeah, Lumen would be an option, too.
Symfony has had a micro kernel option for a while now, so it seems like the end of Silex was inevitable. I've used Silex for many projects in the past, but recent projects of any size simply use Symfony and I haven't missed a thing. 
can it help, Maybe? https://symfony.fi/entry/symfony-benchmarks-microkernel-silex-lumen-and-slim
If you hit me up on Slim's slack, I will gladly try and ease the transition for you guys; idk if we can do anything with 3.x; but with 4 we should be able to do a lot to welcome you guys into our community.
Symfony has a micro-kernel option for a while now so with Flex out you have the stripped down version of Symfony by default unlike Symfony Standard Edition. &gt;Frankly, the fact that one could write complex apps in minutes with Silex made it really worth it. For the point above, this was inevitable. Really Silex doesn't have much to offer (even in terms to simplicity) anymore. For APIs Lumen is good but I would recommend you to take a look at API-Platform.
Symfony 4 copying Silex... This was a bad move, just call it something else, it's so different now I wouldn't even call it Symfony
The benchmark is even more skewed now with Symfony 4.0 and the stripped down version. Most of the overhead you see in those benchmarks comes from the autoloading (the more files the slower) and Symfony SE was definitely too bloated out of the box to be compared to Slim, Silex and co. for benchmarks.
Rather than making Silex EOL it might have been better, from a strategic point view, to actually release a new major version of Silex that would have been basically a Symfony micro-kernel set up and to THEN (after a year or whatever) make Silex EOL since you're basically just using Symfony at that point. I think there are a lot of Silex users out there who have mental block when it comes to using Symfony and this could have helped them realising that Silex and Symfony micro-kernel are basically just the same thing. 
Thanks.
See also this: https://leftontheweb.com/blog/2017/11/17/Silex-is-almost-dead-long-live-mylex/ With Bolt we're going that route: Port our fondation to SF4/Flex. It'll be a substantial amount of work, but it's already showing great promise. Much faster than Silex, even. 
They never fixed the fact that you need to do unsafe things to instal lit
&gt; as the developer could easily write middlewares Silex middleware is just syntactic sugar for putting listeners on a standard Symfony event dispatcher. You can _easily_ replace your Silex `-&gt;before()` and `-&gt;after()` with an [`EventSubscriberInterface`](https://symfony.com/doc/3.3/components/event_dispatcher.html#using-event-subscribers), and because it's all `HttpKernel` (even the events being dispatched are the same!) you'll be one step closer to running Symfony 4 (or stackphp to run Silex and Symfony side-by-side, etc. etc.), without sacrificing anything except the need to define a class - heck, with anonymous classes, the difference isn't even another file, it's just one extra set of brackets!
I'd really like to see something like this. Reminds me of what the community was doing with "Symfony 1.5" for a while.
The purpose of Silex was to provide a lightweight alternative to full-blown Symfony. In 3.4/4 symfony fixed the initial problem that led to creation of Silex - coming with billion things out-of-the-box. Yes, transitioning isn't super easy, but the most major change should be the container - which should be easy if you did your code correctly
What are the changes coming in v4?
for us personally it was easier to migrate to symfony 4/flex than to slim 3. it took us 3 days for the bulk of the code and another couple to iron out the kinks. s4 is really quite good 
Definitely. I find myself getting very isolated and tense sometimes, although I do prefer to work in a solitary environment. Does a lot of good getting out and talking about what bothers you.
Well...as I think Laravel is very bloated I'd advice to stay away from it. Symfony 4 with Flex on the other hand is made to be modular.
It's almost like you've paid for an enterprise level Silex SLA.
What about Pimple? Silex itself is just pimple plus some helper functions, and I do prefer pimple to pretty much every other DI I've come across...
Just so people would know, that's all 🙂
I find symfony.sh to be too incomplete. Not all of the alias are listed and there is no way of searching for what a certain alias will resolve to. Now I saw in the source code that the PackageResolver of flex uses aliases.json. I hope you guys all have a json-viewer in your browser.
?: fuck up 
Hey Reddit - hope this can show you some new ways to work with your SQL data. I'm still quite new when it comes to "sharing my work" so please tell me if I'm doing anything wrong.
There is also original publication of his principles (before SOLID became SOLID, 11 principles instead of 5): http://www.cvc.uab.es/shared/teach/a21291/temes/object_oriented_design/materials_adicionals/principles_and_patterns.pdf maybe this could be interesting for anyone. I found it much more clear than older definitions.
psr15 support, removal of pimple as default dic, splitting out http into its own package, refactoring framework bootstrap ... few more things :)
What di are you using? 
We are leaving it open for our users to pick one; otherwise slims dependencies will be initialized with an array
array_key_exists exists :D
95% of these issues can be fixed with forking and pull requests...
So can any other issue.
&gt; So what can go wrong? Basically require-dev which has some limitations. I got another one. Having an optional package in `require` instead of `suggest`, and having it cause a requirements conflict.
mmm but you don't make them for basically no reason, that's my point.
If that package is in `require` it's no longer an optional dependency is it?
Would you mind developing your point?
Well putting a dependency in `require` doesn't make it suddenly necessary for the module to function, does it? It's the other way around, isn't it? And **optional** dependencies belong in `suggest`, instead of fucking `require`, don't they?
tl;dr: Throw away the service provider that makes up 90% of silex and figure the rest out yourself! *sigh*
This is presented like a big change but only the installer changed. The framework looks similar (still the ugly $this-&gt;container-&gt;get('doctrine') inside the default Controller trait) They speak about autowiring enabled by default (which is awesome) but it doesn't work : public function __construct(\Twig_Environment $twig, FormFactory $formFactory) Will throw an error and you'll have to set edit your services.yaml Symfony\Component\Form\FormFactory: '@form.factory' Why twig is autowired by default but not the formFactory (even if form.factory is registered by default) ? No idea Finally you have this option public: false # Allows optimizing the container by removing unused services; this also means # fetching services directly from the container via $container-&gt;get() won't work. # The best practice is to be explicit about your dependencies anyway. Set this to true, and look your app explodes (not very explanatory for newcommers) Cannot autowire service "App\Kernel": I was expecting a big change with this new version but I get they need to make the migration easy for people (changing everything means breaking a lots of bundle / project). This is the thing I hate and like the most about symfony.
Thats the point of `require`.... The word literally means "to cause to be necessary"
&gt; Well putting a dependency in require doesn't make it suddenly necessary for the module to function, does it? No, but you make it required to install your package which makes little difference. Your module could live without it maybe, but by butting it in require it will _always_ have it so it's no longer optional. &gt;And optional dependencies belong in suggest, instead of fucking require, don't they? Yes. But `require-dev` is different. For example in the case of a library, the dependencies you are putting there will _never_ be installed when a user require your package. So it's a "safe" place to put an optional dependency if you want to test your library integration with it.
That's one meaning of [require](http://www.dictionary.com/browse/require?s=t): for instance, the state requires that all motorists have a license, number 5 in the link. If I understand you correctly, that's the one you're thinking of. But there's another meaning which is the other way around, you might require something *because* it's necessary, like requiring a special screwdriver to undo a Torx screw - number 4 in the link, which is how I've always understood the meaning in Composer. Perhaps with two examples I can explain what I mean better. Let's say I write a module that needs to talk to Redis and I need `predis` to do it, then my module might `require` it. Because my module won't work without it, because there is a hard dependency in my module on it. The other example is what made me post my top-level comment is for Magento 1 modules, because Magento 1 is not Composer ready out of the box so they need an installer, and there are Composer modules that let you do this. However, there are a few different ones, so writing a Magento 1 module and `require`ing a single one with a specific version may cause a dependency conflict and is not the way to go, but unfortunately it happens now and again. See a better explanation of what I mean from the author of a widely-used installer [here](https://github.com/Cotya/magento-composer-installer/blob//8e4554c5e3333448cc3f0e99bddaab77a665004f/doc/FAQ.md).
I find this amusing because you're acting like you expect useful discourse to come from posting your blog on Reddit.
In another comment I pointed out that I may be using a different definition for "require" than you are. Let's try to use different words unless we're talking about Composer `require` so the discussion doesn't stay ugly. &gt;&gt; Well putting a dependency in `require` doesn't make it suddenly necessary for the module to function, does it? &gt; &gt; No, but you make it required to install your package which makes little difference. Any given dependency is either necessary or not, and whether or not someone is forced to install it makes no difference to whether or not it's necessary. I might make a Composer project that has Monolog in `require` and then proceed not to use it. That would force you to download and install an unnecessary dependency. It would be unnecessary because if you had some way to prevent installing it, my project would work fine. Therefore, if I did that, then I would be doing something wrong. &gt; Your module could live without it maybe, but by putting it in require it will *always* have it so it's no longer optional. What I'm saying is that if a dependency is not strictly necessary for a given Composer project to function, then it is by definition optional and therefore should go in `suggest`. Just so I'm clear, we *do* agree on that... right? What you're saying is that dependencies in `require` are not optional because you have no choice but to install them; what I'm saying is that those dependencies that are in `require` but are not needed for the Composer project to work, are still optional, but the Composer project author is wrongly forcing people to install those optional dependencies. He or she should instead put these optional components in `suggest` where they belong, being optional. &gt; Yes. But require-dev is different. I agree with you on `require-dev`. But it's not the topic of discussion. We're not talking about `require-dev`. We're talking about `require` and `suggest`.
q.e.d.
&gt; Silex ends as a project in June 2018. Em, what? The official website doesn't mention this at all. Is there more info?
Just seen https://www.reddit.com/r/PHP/comments/7gypvw/silex_eol_in_2018/ and found some Google links. I would suggest updating the official website would be good tho.
again, number 4 says to "make necessary".... If its in require, its required for the module to work. Period. Thats the whole purpose of `require`. 
&gt; again, number 4 says to "make necessary".... That's fair, but you understand what I mean with the Torx screwdriver analogy though right? I agree with you on the purpose of `require`. &gt; If its in `require`, its required for the module to work ...if the developer of the module configured their composer.json correctly, and that's not always the case. I've seen things that are not required for a module to work, put in `require`, such as a Magento 1 Composer module installer. These are literally completely unnecessary for a Magento Composer module to function and yet I've seen them in `require`.
&gt;if the developer of the module configured their composer.json correctly, and that's not always the case. So..... Change the definition of `require` to let this *wrong* use case be valid? I don't think so.
It's not like I have high expectations but who knows, sometimes have good surprises.
The only reason you would ever require an optional dependency is for convenience: to not require the user to install it after if he wants it. But from Composer PoV it doesn't change: it sees it as a required package so include it, it doesn't care if you use it or not. But I would personally advice against: you're more likely to add unnecessary packages which add useless code + potentially create conflicts for not much. So I don't think it's the appropriate place for it, it's more of a hack IMO.
Moved from Material to Monokai Pro aswell to try it out. Pretty happy with it so far. Which flavour are you using?
That's the opposite of what I'm saying. I'm not advocating any change to Composer or composer.json at all. All I'm saying is that sometimes developers, who do things wrongly, put things in `require` that the module doesn't need. So if you say "If its in require, its required for the module to work." then I say: not always, because some people use Composer wrong. That's really all I'm trying to get across.
Filter specrum
I more mean, how does it achieve 0 downtime? 
I think I may not have gotten across correctly what I meant with the Magento plugin story. Let me explain a bit more clearly (the following only applies to Magento 1 BTW - Magento 2 can use Composer just fine). I think we're starting to agree now, which is nice! Let's say I wrote a Magento plugin, doesn't matter what it does, and you have a Magento application, and you want to use my plugin and you run `composer install` and have only my plugin in your composer.json. Then my plugin won't work. See, Magento is not designed to work with Composer. So it won't require the Composer autoloader, so my classes won't be found unless I hack the Magento core. Also I need to add a few XML files in specific places or my Magento module will not load as a Magento module. But I can't do that with Composer, because everything gets chucked into `vendor`. So now I've got a problem. This problem has, of course, been solved. One solution (by far the most popular) is for me to put a `modman` file in my Composer project, and then have the person who uses my module use a Magento installer that supports this file. What this installer does is hook into Composer and look at my `modman` file, it will create and maintain symbolic links from my Magento application to my `vendor` directory, that I define in the `modman` file. That way all the files are where Magento expects them to be and I can use my module with Magento. Also such an installer may add autoloading functionality to Magento. I now have a new problem, which is that Magento does not allow symbolic links for security reasons, but that's a different discussion. Here's the thing. It's tempting for me to `require` my favorite Magento installer, because at first glance that seems like an obvious and sensible thing to do. After all, my module needs to be installed to work. The point I'm trying to make, however, is that I should not. There are three reasons: 1. Once installed, my module doesn't actually need an installer to work, because it never calls the installer's code. 2. If you write a Magento 1 application, I am not responsible for installing my own module: you are, and it should not be for me to decide which installer you use. 3. You might use several Magento modules written in the same way I wrote mine, so sooner or later you're going to run into version conflicts if everyone just `require`s some version of the same installer. This has happened to me a few times now. The way you and I deal with the fact that you need to install my Magento module but I should not `require` it, is for me to `suggest` an installer I recommend instead, and write decent documentation in case you're unfamiliar with all of the above.
Doing it that way allows the selections to been through, in my experience. I ended up doing that, then converting it to a tiff using tiff2pdf, and then back to a pdf.
I’m not 100% sure but I do think that if you do that someone could open the PDF in an editor and edit out the black bars and reveal the hidden text. 
True, it’s for internal use and we just need it to be blacked out when physically printed. I should have specified that
Interesting, thanks!
There are a few very useful vim plugins that make programming in PHP work quite well, you can certainly be productive: * [vdebug](https://github.com/joonty/vdebug) - debugging functionality - a must * [php-language-server](https://github.com/felixfbecker/php-language-server) together with [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim) - this gives you things like completion/go to definition/hover/find references etc. * [php-qa](https://github.com/joonty/vim-phpqa) - shows you phpcs/phpmd/lint/coverage information * [vim-php-refactoring-toolbox](https://github.com/adoy/vim-php-refactoring-toolbox) - helps with refactoring code * [php documentor](https://github.com/tobyS/pdv) - helps create docblocks There are many more standard vim tools that will really help too (like ultisnips, fzf) but it's really up to you to find out what works with your workflow/preferences.
Oh I know Sonata. I didn't like the documentation and I had some trouble with the user stuff and s3 file upload stuff creating dependency conflicts. Ended up in using a fork of one of the deps or else I ran into a bug. Maybe I did something horribly wrong but Sonata is not a good memory.
If there is one thing I've learnt in the years - it is that one day from now, maybe a day, maybe a year, someone will email the PDF to an outside source, thinking they are doing the right thing because it is "redacted".
Yes. After spending several months with Vim when I first came across it, I became more productive on the fly. Getting used to, and actively using Vim terminology really helped me to think in abstract ways when dealing with code in particular.
could someone please explain why my article is downvoted? Just trying to understand what not to post... thanks!
Don’t shoot me but what is Vim exactly?
I didn't down vote you, but I didn't up vote you either. Personally, I stay clear from ORMs, since I know SQL. Also posts from Medium.com have been pretty horrible lately.
Been using terminal vim exclusively for web development for 2 years now with php being my primary language. I feel productive and compared to co workers using atom, vs code, phpstorm over the years am more efficient with jumping around code, some refactoring tasks, jumping to other files, etc. My entire development environment is in a terminal tmux+vim. I use a ton of plugins. But the top plugins that come to mind are YouCompleteMe emmet-vim Ctrl-P vim-gitgutter ack vim-multiple-cursors phpcomplete vim-composer vim-laravel 
It's a command line text editor 
Generally on Linux, though I'd imagine it exists for Mac.
Cool. :)
An awful experience 
I only use it when I need to quickly live-edit a file on a remote server via ssh, or when I need to edit my /etc/hosts file or my ~/.ssh/config file, etc.
I use vim for every language I work in. I find myself more productive in it than any text editor, but it's been a long time with me configuring and setting things up over years. It definitely a time commitment.
I've been developing in vim for most of my career. Once in a while I try a different ide and will be back full time in vim within a few days. Vim is not perfect but once you got the vim text movements down everything else seems inferior in comparison. 
I find this hard to believe though... What do you do when you come across something like $command-&gt;run () and you want to jump to the definition of run? Are your plugins smart enough to know which specific class $command is so it can jump to the exact function definition? Or does it provide a list of all "run" function definitions in your codebase and you have to choose.
Someone get this dev a rainbow for his vim
Comment saved. Thanks for the list a million times 
I just use the vim mode plugin for PHPStorm. There is zero benefit to using pure vim and forgoing all the benefits of a proper PHP IDE. 90% of the editor efficiency gains from vim come from its text manipulation and navigation anyway, which the PHPStorm vim plugin gives you. So it's the best of both worlds IMO.
I like using bin inside phpstorm- get the best of both worlds
I used vim with plugins five years ago when I couldn't (nor my company wanted) afford to purchase some gui. I'm not on IntelliJ, but I develop in many languages that would become difficult to manage in vim. I will continue to use vanilla vim for misc/quick changes pretty often. I would not mind going back to vim in the future.
I dunno. Very interesting read, but I’m left to think that if your using laravel zero to write apps for computers that can’t have PHP7.1 installed, you might be using the wrong tool. I don’t know; I might have been tempted to spend the time rooting through zero in hope of removing the 7.1 dependency. Maybe that just means requiring an early version or symphony? Not knocking your work, obviously since you’re in a Dockerized environment, you had the tools available to get the job done. 
If you're looking for a vim-like experience (including ability to run in a pure text terminal / non-GUI tty) I suggest giving Emacs with evil-mode a try (it makes many things very vim-like). After experimenting and customizing your Emacs settings/packages (an average Emacs power user will likely have 200+ custom packages installed) you'll find it blows your typical IDE (or vim + plugins) out of the water in ease of use, customization, power, and programming output. Luckily, there is a community driven Emacs distro (I don't actively use it as my config is too specialized) called Spacemacs, which has the vim-like stuff installed (as well as the best packages).
Simple Crud example in Laravel 5.5 http://www.laravelinterviewquestions.com/2017/08/crud-in-laravel.html
Vi is new school version of Vim :)
I'll use phpstorm, intellij, or pycharm. You know for the whole integrated part of IDE. Things are indexed, version control diffs,debuging step throughs on and on and on
If you use php-language-server and LanguageClient-neovim (see my other comment for links) then it will index your project in a similar way phpstorm does and yes you can jump to the definition (yes it works out the type via type declarations/docblocks) or "hover" to view the doc, find references etc.
Oh wow. When was that? 
I must check out php-language-server and LanguageClient. I have been using ctags up until now.
&gt; What do you do when ... You do the same thing you do when you come across something like $object-&gt;getFoo() when there is no "getFoo" in the entire codebase, but instead some genius is using magic methods to catch the method call to mimic getter methods. Choose your response: throw up your hands in despair / pull out your hair in rage / die a little inside / become enlightened about the reality of IDE development. 
[I wrote this](https://medium.com/@khamer/writing-php-and-js-with-vim-in-2017-f58e4a5738ae) recently that talks about what I'm using now.
Vim and I am just 5 times more productive. 
Imagine people posting their *gash* ... Own.. content..?
I did the vim tutorial. Found it very good. Opened up vim a week later and couldn't remember how to do anything. Never vimmed again.
Or put a breakpoint on that line. Or even just `var_dump` it.
"New" it's been available since 2014
I like http://flexrecipes.org/ a lot more. 
I’ve been using vim for two weeks now (switching from atom) because of all the praising around me. I steel feels clumsy and far less productive than before. I heard the learning curve is hard so I’m giving it until the end of the year before switching back to Atom (or maybe VSCode) if it doesn’t click for me.
Have been using it for over a year to build anything from simple websites to complete community portals. Custom content types are built in minutes using the Builder plugin. Simply scaffold all lists and forms with the visual builder and then extend the code to your needs. Thanks to the static pages plugin everything is easily editable by the end user. The best part is to have the full laravel feature set at hand all the time. Using the built in Ajax framework you can easily build modern websites without the need for a full blown js framework. And if you want to use one anyway you can simply use October as a headless cms. I haven't been more productive with any other cms in the last few years. 
Why do you put spaces before punctuation marks 50% of the time?
Mac OS ships with Vim.
OP is asking about Vim, and you're taking the opportunity to call them incompetent? I'll bet everybody just loves to chat around the water cooler with you.
Bet ur fun at parties hehe xDDDDDDDDDDD 
Don't feel bad about switching back if you do. There is no shame in giving up because there are amazing editors out there right now: Vim is just one of them, and it's an old one with a learning curve. What matters if you ask me, is learning a good editor or IDE and learning it well, for me that was Sublime Text and now PHPStorm to a lesser extent. It does not need to be Vim. It needs to be something you are productive and comfortable with. That is, unless you need to log into and work on a server over the command line a lot - in that particular case, and probably only in that case, I'd recommend learning Vim instead of, for example, Nano. Learn one little feature at a time as you need it: deleting a line, replacing a word, etc. It's how I learned: like I'd go, "hmmm this feels awkward to do every time, I'll bet there's a shortcut in Vim for this". It took me a *long* time to get a little productive in Vim, and I am not the only one. But now Vim just feels a million times better than Nano.
Using http://vimr.org with add-ons. 
&gt;This is presented like a big change but only the installer changed. From 3.0 to 3.4 (and the last is the same as 4.0 feature-wise), there's been a _lot_ of changes, from autowiring, dynamic env support, readonly environment support, auto-discovery of services, private services by default... So can't really agree here that's Symfony Flex is the only big change :) &gt;The framework looks similar (still the ugly $this-&gt;container-&gt;get('doctrine') inside the default Controller trait) Ugliness is very subjective. This controller trait is simply to use Controllers/Commands as service locators. The stance here is that controllers and commands are just a glue between the delivery mechanism and the rest of your application so having service locators for there was more convenient. Now I do prefer not making them using a service locators and inject their dependencies instead, but you could already do that and autowiring + auto-discovery of services are making it even easier. &gt;Why twig is autowired by default but not the formFactory (even if form.factory is registered by default) ? No idea But if you inject the interface it works Autowiring works by registering a service by its class name. But as it's new, rather than adding aliases for what, hundreds if not thousands of services? Only the interfaces have been added (and that's what you should use anyway). So here injecting `FormFactoryInterface` instead of `FormFactory` is the correct way to go. &gt;Then, why won't symfony doesn't offer an interface for views ? with the method render() ? Isn't there an interface like `Symfony\Bundle\FrameworkBundle\Templating\EngineInterface` or something? Also I think typehinting `Twig_Environment` is wrong, at the very least it should be `Twig\Environment` and IIRC the interface I gave just before works fine for it. &gt;Set this to true, and watch your app explodes (not very explanatory for newcommers) If you start a fresh app with 4.0, this is enabled by default and things works because there is no existing code besides the one installed (which works). If you upgrade, like for every upgrade, stop at the previous latest minor version (here 3.4) and you will have all the deprecations necessary. If you fix them, upgrading to 4.0 won't break everything. If you are willing to ignore all the hardwork which is done to provide LTS, deprecations and upgrade path, then don't be surprised that things break for you. I hardly see what more could be done here to be honest. &gt;Also, controllers have to return an instance of HttpFoundation\Response. Why not use a PSR Response ? Because PSR-7 has been voted with no easy migration path from HttpFoundation willingly alienating a more than sizeable part of the community relying on it (Symfony, Laravel, phpBB, Magento, Drupal, etc.). All of that for what? Something horribly cumbersome to use for which you need not less than 5-6 packages to completely work with and for frankly, something that should be done in the PHP core. But for what's worth, you can typehint against PSR-7 interfaces if you want to you only need to require the HttpFoundation-PSR7 bridge which does work although provide a little performance overhead. But changing the core of the framework for PSR-7 is never going to happen, it's gonna break way too many things. &gt;I was expecting a big change with this new version but I get they need to make the migration easy for people and avoid massive breaking changes (to not break bundle / project). This is the thing I hate and like the most about symfony. I think there was enough changes here :) But maybe you were expecting other features? What are you missing?
That's not actually what I meant. What I meant was, that I think that calling people incompetent because they add a space now and again, smells to me of a certain attitude that can be quite toxic in the workplace. I was thinking: I would hate to have that person as a coworker. In my experience, saying that someone is incompetent or a similar thing is not helpful and only harmful. I would certainly not be happy and eager to listen to someone who called me a shit developer because I added a space before a question mark. Instead, it's better to point out where someone did something wrong, such as not conform to the style guides, explain why it's wrong, and help them improve, such as by pointing out the style guides and integrating a linter, the lack of which was causing the problem.
Thankfully I will never be your coworker.
Amen to that!
Thanks for your answer. I wasn't aware of the interfaces (just discovered php bin/console debug:autowiring...). &gt; I was expecting a big change You are right about changes from 3.0 to 3.4, the framework evolves quite a lot with every version (but I guess they had to call this version a 4.X since they changed the structure and removed the AppBundle). I think I expected a new way of doing things with streamlined middleware (instead of using EventSubscriber). This is a personal taste but I have lots of problem with yaml / annotations to discover features (I have trouble finding available options without relying heavily on the documentation) 
Thanks for the tips. I’ve used vim for years when I need to ssh into a remote server to make small changes. But for local development I was using Atom until recently. At work we have Macs but we run our website in Debian VMs to be as closest as possible to prod environnement. So it’s pretty like working with a remote server. Until two weeks I was using Atom along with sshfs to mount the VM’s remote folder locally. But this was buggy and slow. Being able to ssh into the VM and use Vim is a big plus here. 
Doesn't that mean a developer can easily put in a better / customized content editor? Or is it so bad it would be too costly to modify for a non-developer? I do completely agree that the end user of a CMS is rarely a developer. Even if you make the assumption that "everyone in my startup/ small business is development minded," all it takes is one hire of a not technologically minded content editor to cause issues. I learned that with something as simple as using Ghost with the Markdown editor. Even smart people freeze up when trying to learn a new way of content entry.
I am using php-language-server + LanguageClient plugins in Yii2 project development. The problem is it is really slow in project files indexing...does anyone has the same issue?
I've been struggling to get migrations to work inside of a plugin. We have built a plugin, and it needs a database table to be created. How can we go about that? I tried create:migration and it made some weird yaml files, but I was expecting a laravel migration file. 
There are multiple markdown and wysiwyg editor plugins available. The CMS section in the October backend is meant for the developer and therefore uses a code editor by default. If you install the static pages or blog plugin that are meant to be used by the end user you have a wysiwyg editor by default. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Well i can say yes, since we have huge system on it. Basic website plus whitelabels. Pretty much i choose octobercms because our admin dashboard for mobile system management is on laravel too, so i can use same models.
That wasn't your point. Maybe it is now, but you didn't ask for the benefit 1 or 2 posts earlier.
Use the Builder plugin to create your migrations easily via the backend. If you get the gist you can always go back to manual mode. The migration files are the same as in laravel. In the version.yaml you specify your plugin versions and each version can have any number of migration files. See http://octobercms.com/docs/plugin/updates#migration-seed-files
&gt; PHP7.0 is currently the latest and greatest version of PHP from the PHP project. I'll just leave it here
While `php-qa` looks useful, have you checked out Ale? It's a mutli-language tool for linting, and supports php-cs. The main difference is that Ale uses Vim 8's background process support, so I believe it's meant to be a bit faster on the uptake? I could be wrong about that
Well, it has been plagiarized from the [other article](http://www.bitaccel.com/blog/installing-php7-0-fpm-nginx-web-server/) that has been good for its time. Reported.
Super helpful article. Thanks for writing this up.
We've been using October for the [Godot Engine website](https://godotengine.org/) since early 2016 and it works pretty well for us. It is not as easy to use as WordPress, but definitely feels more flexible.
Vim fits my workflow very well, I handle different file types daily so having IDEs for all the things plus photoshop plus excel is not an option. No need for plugins, I just use omnicompletion and you can call php -l to check for errors.
I'v spend a few days reading the documentation and I'v decided to write a simple twitter stream api interface.You will need 5min to set it up and get the data from twitter
I use the VIM extension with VSCode. Not for any particular reason other than its makes typing/coding (in a text editor) quite fun for me though I don't think I'm using VIM to its full potential. Also, it helps when I ssh into a staging/production server. The learning curve is steep but like any new tools/tech you'll get used to it eventually.
&gt; There is zero benefit to using pure vim and forgoing all the benefits of a proper PHP IDE. Well, that's just objectively incorrect.
Let's be real. IDEs aren't even that smart with any kind of dependability. That's just the nature of a loosely typed language. I still grin and shake my head at how much collective time was spent by other devs on my previous teams stuffing IDE helper comments all over the codebase just so they could reap this "benefit". A real time saver, that.
I used pure vim for years. I like vim. But getting vim to do what PHPStorm can do out of the box is an exercise in madness. There is not a *single thing* from pure vim that I miss that objectively made me more productive as a developer. *Not a single thing*. 
You may be interested in [PDF Redact Tools](https://github.com/firstlookmedia/pdf-redact-tools). It's an open source project that splits a PDF into PNG files. You make the redactions with an image editor and then the tool combines them back into a PDF with all metadata stripped.
Do you also find the vim mode plugin in PHPStorm kinda buggy? Performing actions inside or around enclosures doesn't seem to work as expected
I've used October for a few projects. It's incredibly flexible. I highly recommend it.
&gt; There is zero benefit to using pure vim and forgoing all the benefits of a proper PHP IDE. Perhaps not things that you find worth it, but saying there are zero reasons to choose native vim is rather naive. For instance, a graphical editor can't be put inside tmux, or run on a server.
github
I use almost pure, the only two plugins that I use is ale (syntax validation) and ctrlp to fuzzy search. To me, this is almost perfect for development.
Ctags allow u to jump to specific method definitions
Use it for my personal website and really like it. It doesn't get in my way like WordPress does. 
I prefer my vim without plugins, I use it for PHP, C# gamedev, bash scripts, all sorts of stuff. I tried vim plugin for PhPStorm at a job interview the other day but trying to find the vimrc was a pain so I just carried on using vim with minor rc tweaks in the VM. Even after using it for 10 years my vimrc is pretty svelte. The only real bulk is a BufWrite function that runs php linter/code sniffer on save if file is .php. Something to show me argument order in array functions is the only thing I'd really like.
&gt;but I guess they had to call this version a 4.X since they changed the structure and removed the AppBundle Actually they called it 4.0 because it was planned so (they have a defined schedule release) they just had the opportunity to time it well. An example is the change from bundles everywhere to AppBundle in 2.5 to 2.6 or 2.6 to 2.7 (my memory is fuzzy soz). &gt; I think I expected a new way of doing things with streamlined middleware (instead of using EventSubscriber) Maybe there is more to do here to be honest. I'm just not familiar with that part because I have so few middlewares and always have so little in it I don't care much about it. &gt;This is a personal taste but I have lots of problem with yaml / annotations to discover features Did you try the `debug:config` command? 
Ooh, vim's a bit radical - it's vi all the way for me...
only when I have to
Perhaps lsd
Came in here to say that if you have only one plugin, it should be Ale. Unfortunately some of the common PHP tools it integrates with don’t support processing files over stdin so you lose some of the real-time magic, but I’m experimenting with some ideas using the language server protocol to work around that. 
I am interested in looking at the language server one. Most of the PHP autocomplete plugins I saw worked based on the PHP reflection, which isn't as useful as it could be and fails when php files aren't valid
phpdb and debug web apps running on php internal server
Can you comment on any other October CMS features that are interesting? I know what it is, even have it installed on my workstation, but haven't found time to play with it. I'm pretty familiar with CMS architecture generally - anything else innovative with October?
You mention "without the need for a full blown js framework". What's the October CMS front-end based on, Bootstrap (version?) and JQuery? Is Backbone/Knockout/React common to overlay on it? 
Rainbow?
Vim changed my life. I started using Vim 5 years ago and out of all the things I've learned since then, it is by far the best and the most useful. Although hard to measure, Vim increased my productivity significantly, simply because interacting with the keyboard is much faster. In terms of plugin for PHPStorm, you pretty much have one choice and it's a very good one: IdeaVim. For Sublime Text, there are many plugins available, but in my opinion Vintageous is the best. If you're like me and you really love Vim, you might want to start using in your browser as well. For Chrome, there are two good plugins: Vimium and cVim. I personally prefer the latter. For Firefox, there's Vimperator. That's about it. My recommendation is that everyone should learn Vim, it really is a game changer once you've mastered it. Good luck! 
Set up your VM with vagrant and share your folders... best of both worlds..
Using magic methods has its place (mainly for centralized before/after logic) but if you're using them just for saving a few keystrokes you're doing it wrong. 
I use October with Vue, but any of those you mentioned will work great as well
I think you missed the point of my comment entirely, or meant to reply to someone else.
There are optional "framework extras" that you can include to get [a simple but powerful jQuery based framework](https://octobercms.com/docs/ajax/introduction). Or you can include your own framework as you would with any other laravel (or other web framework). 
The compontents based plugin system makes it stupidly easy to structure your code into small compontents with a controller and a view. Combine them on your pages with other compontents to build your app. It gets some time to fully grasp the concept but once you got it it's a really clean way to structure even more complex apps. Another great feature is the Builder plugin. It allows you to create a proper database schema with list views, forms, localization and permissions for your custom content types in minutes! 
thanks!
I helped get Ale speaking to LSP servers, so can detail this a bit: Out of the box, Ale should detect whether the felixfbecker library (linked elsewhere) is installed and report back anything it reports. That tool, unfortunately, doesn't offer much beyond parse errors as far as diagnostics go; it focuses more on completion (which Ale is [now poking at](https://github.com/w0rp/ale/issues/1162) supporting). Also, last I tried, you can't install it as a project's dev-dependency without setting a `minimum-stability` of `dev`, which at least for me is a non-starter. Contrast to PHPStan, PHPCS, etc where you get much more detail about logical and style errors, but most of them only work on "analyze this file on disk" so out of the box they can't handle your unsaved changes in your editor without some finagling. So far I've put together (most of) a working frontend to an LSP server that I hope to get sitting in front of other code quality tools - even ones that don't support analysis over `stdin` - to allow getting real-time feedback from those tools. No idea if I can make it work for everything (let alone doing so in a performant manner), but if nothing else it's a fun weekend project. None of this inherently solves the "parse error, can't do anything else" problem that some tools are affected by - that has nothing to do with the communication protocol. But there's a tolerant parser that some of those tools use which helps a bit.
How long until you figure out how to exit vim? :D
I used it for a small portfolio website for a client. This was like a year ago. I really like the backend manager for content. I could definitely see it as a replacement for WordPress.
Never used vagrant before. I’ll look it up. Thanks. 
six years
For what it's worth, physical activity can help. I know it saved my sanity. Same position as you. Walking every day. Get some some. Fresh air. Walk away from the desk regularly, lift some weights.
Pretty described the reason I stopped using PHP couple of years ago and moved to Go. At a certain point, you know that you have a page with 3 or 4 components that share no state with each other, but when you try to parallelize their execution, you just can't - or rather, you can but must rely on weird techniques (like using HTTP-in-HTTP calls) or unreliable libraries.
I like October very March, but it May Thursday your April if you don't Sunday every August in June.
This is a fairly typical knee jerk reaction to seeing the developer-first approach. It's a bit like saying an OS without any apps installed is pointless. When in fact that is entirely the point and what makes it so precise. There is a cost to a platform making no assumptions, it means the developer has to build the CMS exactly how they want it. Don't worry it's not hard at all, like building with Lego. A developer who takes the time to understand this knows the platform is "made for people" mostly :-)
Developer-geared CMS vs. User-geared CMS. Many people see only side of the story, mostly the WP and similar end of the spectrum. I have to disagree with them as I'm at the other side. We have our own proprietary CMS, developer-first flavor. I wouldn't trade it for anything else in the world. Super-fast, light, extremely easy to make complex sites including multi-site with shared resources, e-commerce, whatever. You can literally create a functional platform in 48 hours (did this on 2 years ago for a test). Comes with visual database editor + many plugins including user authentication, e-commerce, statistics /analytics tracker, minifier, all sorts of other things. Cannot be hacked in the way existing CMS systems can (uses read-only filesystem, several layers of protection, in-database everything), functional built-in DAL/ORM that makes development blazing fast. Yep - took 10 years to build and refine. My point is - who has never experienced the power of something like this, cannot understand what we're talking about.
well... "new" is relative. It's been around longer at this point than vi had been around when vim was released.
I liked it so much I became a core maintainer for the project! In all seriousness, I don't think calling it a CMS really accurately describes its true potential. The real power of October is in the completely custom applications that you can build very easily and quickly that remain easy for the end user to interact with. October is more of a Content Management Framework; while it's perfectly suited to your typical WordPress-esque needs, it really shines when it comes to the need for custom applications and workflows. I've been using it extensively for both internal and public facing projects at the company that I currently work at (https://www.hillbergandberk.com) and it's been very useful for quickly building projects that meet our own specific needs better than any third party solutions out there without having the high price tag that is normally associated with rolling your own internal applications.
I think you should Google "October CMS vulnerabilities". Then I'd like to know your opinion. 
Sure, but it seems like that would have a very disruptive change. I'd be interested to know how the actual discussion went down.
You nailed it. That's one of the reasons we built October, our experience with CMS' was totally frustrating. It's a bit like dumbing yourself down to fit a system designed for non-technical users -- or worse, making what should be a simple task overly complex. That in itself is OK and those CMS' have their place. However, what we found was clients didn't use this stuff anyway. We think rightfully so, they are paying us to build a website, not teach them how to build one. We found it more effective to use a "need to know" approach: when the client signs in to their admin area, they only see things relevant to them, it's natural and requires no explanation because the developer hand crafted it for them. As opposed to cramming them in to a one size fits all mould. You've also touched on another reason, one very important to us: Business-minded VS Developer-minded principles. This relates to the overhead that comes with maintaining websites, ranging from simple things--like the ability to quickly update some markup quickly via the back-end--to the more challenging aspect of building a platform that doesn't break your website every release, whilst still remaining modern and flexible. This is in October's DNA and why it is unlikely there will ever be October v2.0. Once you have a solid system like this, the focus shifts towards building, building, building and making things reusable. Not reinventing the wheel every time. As I'm sure you know, there is a sweet spot where this approach grants maximum profit for the developer and maximum value delivered to the client. A true win-win.
&gt; instead some genius is using magic methods to catch the method call to mimic getter methods FWIW, you can use @method inside of the owner of the magic methods to hint at what magic methods exist. This can be useful in docblocks anyway.
You realize 99% of these "vulnerabilities" require the attacker to gain administrator access first. Some address permission leaks (all fixed) and some are the researcher not understanding the platform's features.
No, but thanks for the heads up. I gave up CMS after being hacked countless times many years ago using Joomla. I may give October a try, as it seems pretty straightforward. 
Same boat, had to shut down a hosting business because of hacks.
If you don't have a dot, you have to type a URL into your browser, because just a name will make it search. Also, programmers love cleanly separated namespaces.
I don't believe there is anything knee jerk about my conclusion. OP's question was weather it will become widely adopted, which I stand by my opinion of no. I will be the first to admit that it's a much more pleasant experience for a developer than say WordPress, however this is typically only a small consideration, if one at all when a business is selecting a CMS. There is also very little "unique" about this selling point, there are plenty of well built open source PHP CMS's, Bolt immediately comes to mind for the old Symfony Vs Laravel argument. October is a joy to work with and build upon but without any "killer" USP's, its just another nice small open source PHP CMS, of which there are plenty.
Thanks, that does give me reassurance that this may be a good choice. After Joomla I ran mostly static sites with hand coded php to add dynamics and functionality. WP is also a nightmare, a true honeypot. I spent so much time trying to armor Joomla it became ridiculous. 
http://octobercms.com/docs/console/commands#console-up-command
I like that I can hack together stuff quickly. The foundation is great. I install October, create my plugins, and ship my sites off.
We're on the same exact page... Congratulations for taking this step and bringing it to the world. I've already observed, with time, the difficulty is to convey the usefulness of such a CMS to other readers; as there's little to compare to, in this particular niche. Fortunately I don't have to personally "sell" this as our CMS is proprietary and closed source, it's just used for our own projects and clients. However it's such a foundation to built serious business on. Yet I often got negatives for trying to at least explain how powerful such a tool can be for a developer. 10 minutes of simple settings and I can have a new site up - with a lot of whistles and bells. Changes? New features? couple lines of code, 5 mins later - voila, it's up and running. And it doesn't limit you on what you can do - quick - because it's designed to be quickly modified and overhauled. They neg me because they don't know what I'm talking about, and it is such a loss. Our CMS was built as a direct response to my own experiences with the first WP versions many years ago. Yes WP fans can neg me on this, I don't care anumore. I know what I saw back then and still observe. Ridiculous performance of off-the-shelf non-cached installations of CMS like WP(25% of the server CPU on a single simple page load using default theme!), lots of security issues, need daily updates, zero-day hacks, fast forward 10 years and it's absolutely the same. It is the same because the issue is in the original design and can't be fixed without completely breaking compatibility. It will therefore continue to be so. I fully admit the WP usefulness to end users - don't get me wrong, quite good at that - internally it is great work of an entire community, thumbs up to them for that. It is however a tool for the user; and so are most well known CMS'es out ther. But for a developer it's entirely the wrong tool. At least for a developer focused on performance, security and especially speed of development of websites. Or, building platforms, REST interfaces, marketplaces, heavy load applications and such - not mere blogs and shops. Talking about optimizations.... we're now at 1ms execution and 1mb memory after fully overhauling our execution path, with less than 1% cpu load on the slowest VPS out there. Need 10000 concurrent users? Yes, that $10 VPS will do just fine. And it executes the whole stack, not CACHED, but full render! Only database can slow you down - depending on your own queries at hand. Built-in memcached handling... ultra-fast queries and porting advantges of NoSQL over SQL RDBMS. Built-in contact form (just config), built-in shopping cart with connector to backend apps, no more shopify costs, then payment processor integration, automatic translations, built-in bot detection and handling, built-in A/B testing, session-based messaging and caching, url masquerading, source of traffic tracking for conversions, extra string/array/encryption/file/whatever functions. Those you always wanted but aren't there. How can I live without all this today...? No I couldn't. Again I'm not trying to sell anything here - cause I don't have anything to sell. Merely congratulating you for your project. And just letting others know, there's an amazing world where any professional developer would feel like, finally, at home. Whoa, so it CAN be that fast, that simple, and that accurate in result. Only that they don't know because few are entering it.
I don't like it. It's very good at what it does if you understand how to use it, and very easy to extend and add new features. But the whole layout and way it works is far too technical. I use it for a company landing page, and have to do everything because non-technical users can't understand how the different blocks works. I don't have to explain anything with Wordpress - just give it to them, and they work it out. But I have to hand-hold with everything about October. I'll stop using it soon, because my whole reason of using a CMS was to make it easier for non-developers to edit things, and October fails at that by being too complex.
You just need to add a slash at the end. Funny that you would reply 2 months later, just to be wrong...
do you think october cams could be used for something like lead capture? just wonder it would do with hundreds of thousands of records
I program in a lot of different programming languages so I get a lot of mileage out of vim. However I do use PhpStorm for Open-Source projects and it's nice. Interactive debugging is one of the best features of IDEs.
Good tip.
Without posting any code samples at all, it's impossible to say. Sounds like a js error however, perhaps the homepage is loading different JavaScript files and it's causing a conflict. 
Nobody can pull the answer to that out of their ass. You need to post a link to the website or some code, and learn how to debug!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
100% guaranteed.
[removed]
I did. This site came up at the top of the search, so I did a quick comparison against other CMS mentioned in this post. I hope this is relevant. **As of 2017** [OctoberCMS: 9](https://www.cvedetails.com/vendor/15615/Octobercms.html) [Wordpress: 42](https://www.cvedetails.com/product/4096/Wordpress-Wordpress.html) [Drupal: 8](https://www.cvedetails.com/product/2387) 
Before you ditch it, i have seen plugins adding that cms feature back. I was looking into octoberCMS if that plugin was worth it.
Are there ways to hide the some of the dev backend based on the login account type/user? 
Silex is so nice though. Not a fan of the decision or moving to the micro kernel option, but it sounds more like he doesn't want to maintain it anymore and that's fine. Rip Silex, you got me through some projects when I got tired of using full fledged frameworks. You will be missed.
Nice, I guess no more need for `PHP-DI/Silex-Bridge` then? :)
Yes! A user that has access to the backend is called an Admin. You can create different admin roles and give them fine grained permissions to different parts of the backend.
I attended a WordPress dev meetup group and asked them what made wp so popular with its end users. They said it was the familiarity of the system. If October promotes choice instead of familiarity, it might not fair that well. When wp changed some of the editor features some years ago., I remember a client of mine freaking out because something had changed. I had to explain that sometimes things update and include new features or change how things are done for the better. 
I am using it at the moment to build a clients website for be precise reason it doesn’t have loads of shit on it, so I can actually code the site how I want to. Once you get going with there builder plugin you have access to so many completely custom backend forms for the editors to make content with - which is sooo much nicer to use than most Wordpress things like PODS - and the way you can insert ‘components’ for displaying content too using twig is great. Also .. you create the content editor parts using “content” which strips away all tags etc. For the editor. It has been amazing for building a template scratch with. Also a lot of really common plugins (front end users, the builder) are maintained by October which has obvious benefits. I agree that it won’t be mainstream (aren’t 20% of webpages Wordpress?!) but as a dev it is a fucking joy to work with.
Just want to say thank you for making an awesome cms! 
I hope this guy gets punished for the abomination called WordPress. Thanks to him, we'll be seeing its effects even in year 2030.
Thanks, dad. 
For gods sake! Please some skilled PHP developers, MAKE WORDPRESS GREAT AGAIN!
I'm really concerned about whether GraphQL will solve the API architecture problems we experience with the classic REST approach, or end up being a nightmare to maintain for mid-big sized projects. Right now my approach is a more pragmatic rest implementation that behaves a little bit like GraphQL in the sense that the client can have 'some' request possibilities, but instead of giving unlimited configuration power to the client, I only allow a whitelist of query parameters and serialization groups (JMS Serializer). For blockchain, it will keep growing, but that's not really our concern as in the end it's just yet another API for our apps. I've already implemented Paypal and Stripe. Bitcoin and Ethereum will be next. IOT and VR used to be 2017 trends but VR seems to have died down. AI is still going super strong. But it's a completely different field.
People like to hate Wordpress, but this is still the easiest CMS to use, to theme and to adapt imo. I don't think wordpress will go away (even in 2030 ;)). It's not the best code but it works It's like PHP, it's not the best language (it's basically a glorified template engine), but we chose it cause it was easy to learn / use (even if the code is filled with stupid choices like opening &lt;?php, associative arrays, inconsistent fonctions...).
Oh mate; you can argue I worded it really badly and that I'm a terrible writer, but I don't think you can tell me what I intended to convey; that's not how conversations work.
This is not a problem of "skilled" developers. They try to keep the system backward compatible. "Making Wordpress great again" would break a lots of plugin / themes (maybe all of them :D). The same things happens with PHP, we keep having stupid function name and parameter orders for compatibility reason :(
&gt; For blockchain, it will keep growing, but that's not really our concern as in the end it's just yet another API for our apps. I've already implemented Paypal and Stripe. Bitcoin and Ethereum will be next. I guess this is mostly true for the financial world. But there are other domains that aren't as far yet: Smart contracts, insurances, etc. 
Personally I feel that -- unless someone's literally talking about making or accepting payments -- "use Blockchain" is usually buzzword snake-oil designed to woo non-technical gullible investors. 
somebody please teach me AI :(
Codesniffer did a lot to help us. 
 * Enforced test coverage thresholds on new source files * Enforced feature specification writing (`.feature` files for anything new or fixed) * Enforced static analysis via PHPStan on new files * Enforced CS on new files (PHPCS) * CI
If GraphQL wouldn't be backed by Facebook, the tech would already be buried 
Code quality increased when I started reviewing code more diligently and not worrying about offending the person who wrote it. 
&gt; there's a lot of exploration around Blockchains https://www.tbray.org/ongoing/When/201x/2017/05/13/Not-Believing-in-Blockchain tl:dr - There's really very few (if any) technologies that have succeeded after such a high promotion to having stuff working ratio. 
php-cs-fixer fix src --rules=@PSR2,@Symfony phpmd phpdoc
Quick answer: Whatever was trendy in Java world 5 to 10 years ago. /s 
I wouldn't want to work for Automaticc for all the gold in the world.
Just a few random guesses: * After the REST (full) and GraphQL hype, people will understand that the good old SOAP wasn't so bad after all. * We will find that blockchains is not a strength of PHP and are looking for more suitable technologies (for blockchains). PHP is still perfect for web development. * There will be new and specialized PHP libraries for AI. The web is becoming increasingly intelligent. * PHP will be used in more and more enterprise companies. Architecture, DDD and ES/CQRS are therefore becoming increasingly important. There will be new camps: the CRUD (MVC) and the DDD people. * The async hype will also affect the PHP language. Web sockets could play an important role in this. * In 2018, it could turn out whether Vue or React is the winner. I guess many people prefer to stay with jQuery (for stability reasons).
You can do a huge lot of things to achieve that, random stuff: * for team interaction safety: talk a lot, always question your colleagues, always ask for a brainstorming before starting a new non-trivail task * in the same vein: do reviews as much as you can, I know that you don't always have the time, neither your colleagues too, but it worth the shot doing reviews whenever possible * also, try to put in place standards within the teams: common tools, common set of APIs/libraries, common way of architecturing the code * try to have one and only one technical chief on each project, which will decide how this project must be architectured * for code safety, always write type safe code, use PHP type hinting as much as you can * write fucking tests, and review other's tests, unit tests for coverage and tricky low level APIs, functional tests as much as you can * use the same environment as your colleagues (software version, os version, php version, everything's version) - use virtual machines to achieve that * use the same environment as the prod (software version, os version, php version, everything's version) - use virtual machines to achieve that * use the same tooling as your colleagues, and if you do not, comply to standards in regard of the coding style, software design, etc... * always find a compromise where most or all agree on, if not always have a chief to have the final word and decide
- Unit tests - PHPCS - PHPStan
You should checkout GrumPHP! https://github.com/phpro/grumphp
Indeed. But there are also a few very interesting use-cases for blockchains. For instance my company is building a blockchain-based opt-ins management system. It's the first time in a while that we had a technological answer to a purely legal problem : handling customers opt-ins in a fully reliable + accountable + transparent + trustworthy + cheap way. Emphasize on "cheap" (the previous iteration of this project included storing our data in Oracle DBs, which is everything but cheap.)
...Yet. I am under the impression that Blockchains will be helpful for law-related software and legally-constrained business-cases. Adoption in those fields is always slow, since it doesn't exactly help companies create value, quite the opposite in fact...but Blockchain are a nice solution to these problems.
I worked with October CMS and it's a good choice for a developer that is looking for an admin-based Laravel site. It's true that it comes with content editor, but this editor is more a code editor than a WYSIWYG. The application structure is great. The "new" thing about OctoberCMS is the components function: https://octobercms.com/docs/cms/components , this is very useful for large applications. If you've worked with twig/blade templating you will love October CMS. You can create plugins/modules and reuse them. There are ready made templates and plugins, so starting a project in OctoberCMS is a smart choice.
I have a client that mentions blockchain at every meeting. All their requirements can be exceeded with a traditional database and a robust backup plan.
https://www.infoq.com/news/2007/10/php-java-stack ?
I agree with all of the above. The bit I found useful was once decisions have been made on something, write it down in a standards page in the wiki. This means that when someone goes off the reservation in a pull request, you can point at the standards doc and say "no, this is what we agreed on." Also, something I've found useful is naming conventions, for example; "The word Entity is not to be used in a object, unless it a class that is stored in the database and lives in the \Xyz\Entity\ namespace." "Factories must be called the name of the class they create, followed by the word Factory. ie; The factory for PageAccessAuthority must be called PageAccessAuthorityFactory." (I'm a grumpy old man when it comes to naming things though, since I think Manager and Service are dirty class names.)
We had the same issue with database migration in a module that we crated. This is something that needs to be improved.
"But the whole backend administration and way it works is far too technical." - I guess that's the main idea behind October CMS
Each CMS nowadays tries to replicate the Wordpress admin panel. I know that the backend is horrible, but Wordpress frontend is very user friendly and so easy to use. 
&gt; They try to keep the system backward compatible. "Making Wordpress great again" would break a lots of plugin / themes I understand that and in particular ways I support it, but sometimes you just have to say "Ok, stop. We have to draw a line". Otherwise we still have to care for Browser Compatability like &lt;IE7 or &lt;FF36 etc. At some point we really need to be consequent and say "Yea, maybe a big part of the internet don't update their browsers, but we need to change that! We need to _force_ that!" I mean.. don't update your WP from X.xxx.xxx.xx to Y.0.0.0, because it's breaking the rules of downgrading/backwards compatability. It's so simple. Of course this will split some developer ressources that take care of updates and security fixes for version X and the some to the version Y that build a new, better WP. I always asking my self.. do I have to eat the BS, because I it's the only thing on the table or should I go out, take the big effort, the pain, the risk and get a delicious meal? Wordpress exists so long and it's used so often.. but damn,.. I am happy that I don't have to work with it right now and I don't like that state. I believe their is more potencial.
Reading this while sitting on a toilet. *+1*
In my company we use Jira and Bitbucket. For every Jira issue we create a branch. After fixing the problem, make a pull request which then has to get reviewed by another developer before it can be merged. Even the project leader will let his code be reviewed by other colleagues. We are being honest to each other about everything that could be improved. Noone gets offended if somebody thinks his code has room for improvement, and so we learn from each other.
Completely agree with naming things Manager, Object etc. Naming things is hard but it's always worth not getting stuck naming things incorrectly: http://wiki.c2.com/?DontNameClassesObjectManagerHandlerOrData
This tapping thing is kinda out of control :-\
But you have to look at this change from a user point of view. What this rebase will bring to the end user ? - more security, not much, CMS are by nature not secure (since you can add untrusted code on the fly with module / plugins) - more feature, no. You can make Wordpress works with PHP 7.1 already - more performance, no. I'm sure a more object oriented code cost more (more file to include, more things to load) It will only improve the developer experience for sure but this is not the main target of Wordpress. I'm sure Wordpress Core weighted the pro and cons since they have to work with this code base all day long.
Come on, it's just for a dump function ;)
I don't generally take a dump and then do something with it :-P
Stay with jQuery? It is living its last days...
I mean it was skewed before, Silex at the time iirc was at 2.0 and that benchmark is using 1.3?
Quite possible, I find that those benchmarks are incorrect most of the time.
Well personally, I dislike you calling an ORM an "agile toolkit" and "agile data". Agile is an overused word, so please refrain from randomly sticking it to other words. Second, I believe most ORM's in PHP are pretty awful, with the exception of Doctrine, which I can tolerate to some extend. The fact you have to extend a BaseClass ties your code specifically to your ORM: tight coupling is considered bad (even in PHP land!) and therefor I would not want to use your library in any of my projects. Third, I _think_ most people downvoted your specific article, because it reads like a sales pitch of your ORM layer. This isn't bad perse, but most people dislike sales pitches in general, and are quick to judge (downvote). Fourth, most good articles begin with explaining a specific problem (or sets of problems) and then try to find a solution. The even better ones also mention different options, and the trade-offs between those options. Your article is written the other way around: you present a solution, then sort of describe a problem.
Only thing I'd like to add is code reviews. (4 eyes principle). If the quality varies widely inside your team, pair programming might also be a good way to improve.
The first one (Wish List) seems to have an error in it. In particular, it should be `$this-&gt;file['tmp_name']` instead of `$this-&gt;file['tmp']` per http://php.net/manual/en/features.file-upload.post-method.php
Why do you think that?
I don't understand why people compare jQuery to Vue/React. They solve different problems. jQuery is used primarily for *manually* manipulating the DOM. Vue and React *automatically* manipulate the DOM for you when the application state changes. Most apps/widgets can and should be implemented using a Vue/React-like library because it leads to a far more maintainable solution. However, jQuery might still be useful for cases where you need to manually manipulate the DOM. That said, for those rare instances it probably makes more sense to solve it using vanilla JS, rather than including the jQuery library.
Well, you are right, but if the majority of developers isn't happy with the code, less developers will build plugins/addons for them. It's just a theory that we can't proof, but I would bet that way more developers would participate if it has a better code base. I personally stopped very early on and changed to other solutions. For easy install, choose template and work with it to have a Blog: Perfekt. But missusing it like many do and build more features: Dang.. not so nice. Some people would say "It's better this way", maybe they are right.
What about changing that and taking it to throw it at nazis? :P More seriously though: it allows you to do a dump and keep going rather than forcing a die. If you don't do a die, then the tapping helps
My mistake, thank you very much for reporting it :)
Hi, n0xie, thanks for your reply. I agree on the "agile" name, would love to call it something else, but I can't come up with a good name! :) Appreciate all your points! Honest feedback will help me deliver more interesting and enjoyable context. My goal in writing articles is to help others discover new ways to do stuff easier in PHP. Some articles imply basic knowledge of some fundamental principles. Perhaps I could have explained that better in the beginning. You are absolutely correct that I have missed to highlight the problem. As far as the framework code goes, It was actually quite well received: https://www.reddit.com/r/PHP/comments/5ftpxg/thank_you_reddit_you_helped_me_create_something/. It's not a "half-baked" Doctrine clone, not an ORM either, more of a DAL with a different set of concepts. Ideas for changing inter-dependencies have been passed around but it would make overall developer experience worse. Once again thanks for feedback!
This is pretty neat! Thanks for sharing.
&gt; As far as the framework code goes, It was actually quite well received: https://www.reddit.com/r/PHP/comments/5ftpxg/thank_you_reddit_you_helped_me_create_something/. It's not a "half-baked" Doctrine clone, not an ORM either, more of a DAL with a different set of concepts. Ideas for changing inter-dependencies have been passed around but it would make overall developer experience worse. I didn't look at the source code, nor do I have any judgement on your library: to me anything that couples too directly to a 3rd party lib is not something I would use without specific reasons. So don't read my reply as a criticism on your efforts or your library: it's not.
n/p.
Well You will still need to include the DIC of your choice; but Yes you wont need a bridge I suspect.
Where can I read more about feature specification?
This is really cool. For day 4, the following code: (!strpos($user, '&lt;') || !strpos($user, '&gt;')) &amp;&amp; (!strpos($pass, '&lt;') || !strpos($pass, '&gt;')) If `$user = '&lt;foo'; $pass = 'bar&gt;` then the check becomes `(!0 || !false) &amp;&amp; (!false || !3)` -&gt; `(true || true) &amp;&amp; (true || false)` -&gt; `(true) &amp;&amp; (true)`. Is that intentional? If so, I would expect this bug to be mentioned in the explanation. :)
End of 2015, beginning 2016. In May 2017, we changed that and where able to move back from the fork to a proper version.
&gt;* use virtual machines to achieve that Even better: use docker to achieve this 
It's intentionally done this way, otherwise the strpos() trick would not work. If you actually want to exploit it, the strpos() bypass makes more sense, thus we focused on that in the description.
There are some good use cases to use a blockchain but you're not going to ever touch it in the PHP world, in 99.9% of the cases you don't really need it anyway. But it sure is interesting to learn about and play around with. Event Sourcing and CQRS is a very time consuming way to program and thus very expensive. Most projects wont have the budget for it, unless you're working in enterprise. I'm also curious to see what effect the upcoming GDPR has on Event Sourcing and even some blockchain implementations. But it's also very interesting to learn about and has its use cases. I think we'll see a lot more about machine learning in 2018, it's already catching on but I think it will become even more popular. It has so many use cases and I hope I get to play around with it for a live project. I also believe more PHP frameworks will go in the direction if Symfony Flex. 
Will work with Linux, but in all other cases, you still need a VM to get your docker running ! Pun aside, I do agree that docker is nice for this, but if your targetted environment is not docker, you will run locally with a very different environment and might miss a few spots.
From his [PR](https://github.com/symfony/symfony/pull/24280) the main point seems to be the ease of throwing a `dump()` around something during development with minimal effort. Personally I'm not a fan, it's not intuitive behavior. I expect `dump()` to dump something. As far as poop, yea this PR would have been rejected.
Nah man jquery is most definitely not going anywhere.
That's my issue with a lot of terminal based utils(vim and tmux for example.) I would love to use them more effectively, but I would need to print out a few pages of key binds/commands and have them in front of me to do so. 
&gt;Where can I read more about feature specification? I believe those are in Gherkin format. You can use them to test your system with Behat.
Won't happen. Mullenweg is more focused on Gutenberg than, oh, I don't know, anything and everything else that's important. Going so far as to tell people to get lost if the ideas they have proposed aren't in one of his three focus areas. So, no, there is no making WordPress great again. Unless you want a self hosted Squarespace type site. At which point you probably either have a cat blog or are in over your head making technical decisions you shouldn't be and are choosing a platform solely because of word of mouth over a proper capability analysis.
So I decided to give symfony 4 a try after not using the framework bundle ever (although, I've used symfony components standalone for years) and I'm liking it so far. `composer require translation yaml validator monolog doctrineorm twig form` is just nice. Working on porting my invoice stripe payment management site to SF4 from a custom microframework ordeal which uses a lot of symfony components &amp; doctrine. The way the configuration file is setup is pretty cool too, the .env, automatically adds a doctrine block when you install `doctrineorm`. Wish me luck.
&gt; 0 points (33% upvoted) So I'm guessing one upvote and 2 downvotes. I wouldn't take those numbers too seriously. It would only take two people scrolling through the subreddit, seeing a Medium link or the word `Agile`, then downvoting because of that.
I'd like to point out that the overlap issue is one of the issues that I've tried to help a developer fix in my own [graphql implementation](https://github.com/chemisus/graphql). 
Maybe I'm just dumb, but what is this good for? `dump($object)-&gt;method();`
Is there a reason to prefix built-in function calls with a backslash? I've seen it in a few places; \error_log(\print_r($object, TRUE)); Does this prevent clashing with functions defined in the top level namespace?
it is useful if you want to dump something in the middle of a method, the code continues to work without an additional variable.
All of these are great suggestions, but I am seeing everyone skip right over the first two most important steps to improving code quality: 1. Team buy-in 2. Company buy-in If you can't get either of those, then no amount of standards or tools can fix your code quality. Start by having some honest discussions with the powers that be and your team mates before you spend too much time on the actual implementation. And be prepared to have your heart broken. 
 - code reviews - unit tests - Psalm
There are several projects that have millions of records that are managed by October, it works just fine with any size application
It's probably all been said before but here goes: - Agree on a coding standard, PSR is great. - Use version control (GIT) - Get some unit tests going (eg: PHPUnit), start with the initial setup and test as you go. You shouldn't immediately aim for 100% coverage but write some tests for critical parts or parts that are sensitive to changes. - There's a host of static analysis tools, use them. PHPStan is awesome. - If you have access to PHP 7.1 and above, use type hinting! Skip 7.0, nullable types are a must! - Depending on the importance of the project, use merge/pull request - monitor and improve each other! Never merge your own MR/PR's, let someone review and provide feedback first! - Learn together. Go to conferences, have team meetings, communicate, ask questions and involve others - be a team, not a bunch of individuals. Where I work, we have dev meetings every few weeks to talk about new tech, general issues, discussions about problems we encounter(ed), make arrangements (like deciding on coding standards, etc) - Continuous Integration is fantastic, it's a great addition to merge and pull request to automate certain checks (code style, unit tests, static analysis), there's a lot of options available for this - I think Gitlab offers free CI and private repositories. It depends on your current version control setup though. - Get your team a PHPStorm license, or at least try out the trial. Make sure you install this plugin (https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-) It will help A LOT, it's static analysis in your IDE, helps catch a lot of issue while coding and helps you write better code, you learn a lot from the error messages. That's all I can think of right now, but it's enough to get you going!
What's the proper way to prevent the XSS exploit on day 2? Just not using the value provided in the GET parameter directly, but instead using it as a key for an assoc array? Something like: $urlMap = [] //mapping if (!isset($urlMap[$_GET['nextSlide']]) { return DEFAULT_URL; } return $urlMap[$_GET['nextSlide']];
Wow. I lost the challenge on the first day. I didn't know in_array was type unsafe. I have been using that for years... Damn. I have to look at this more seriously
It gives some performance gain, see : https://veewee.github.io/blog/optimizing-php-performance-by-fq-function-calls/
This is so cool. The Twig challenge really opened my eyes. The validation seemed flawless to me, and even a little redundant. The solution made my jaw drop. You can do *that*?
This is so cool. In my experience, there aren't enough resources to learn PHP. Personally, I think you should be learning/teaching any relevant security issues with everything you learn as/for a PHP newbie. 
strpos() as a function would have been more sane if it returned an unambiguous value like -1 instead of false
Do you know what kind of php development one would do? "Code Wrangler" is kind of ambiguous. 
Or, you know, you could use a debugger instead of building on terrible practice. 
It makes bad practice easier.
Yes. In theory composer remove doctrineorm will not only remove the source code from under the vendor directory but also cleanup the various config files. How useful this will be in practice remains to be seen but it probably can't hurt(much).
Every time someone says "blockchain", I link to [*On the dangers of a blockchain monoculture*](https://tonyarcieri.com/on-the-dangers-of-a-blockchain-monoculture) by /u/bascule.
What's funny is that this change breaks Laravel, because it relied on a fact that dump didn't return anything https://github.com/symfony/symfony/issues/25248
PHP is powered by Blockchain. You see, we use the innovative new source-control system “`git`”, which is based on a ~~Merkle tree~~ Blockchain.
This is a complaint about a lot of PHP's built-in functions.
It does seem a little strange to me - it seems like the next slide should be stored in an underlying data store somewhere. When would you ever be displaying a URL that was passed in through a querystring or form?
What bad practice? It's just for debugging purposes when you don't want/need to put a breakpoint...
There's a place for both, peace.
 return in_array(parse_url($nextSlide, PHP_URL_SCHEME), ['http', 'https'], true) ? filter_var($nextSlide, FILTER_VALIDATE_URL) : null;
At the moment I found this article where they implement a c++ worker for the celery v3 protocol. https://github.com/s3rvac/blog/tree/master/en-2017-06-25-consuming-and-publishing-celery-tasks-in-cpp-via-amqp Might try to convert the example to php.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [s3rvac/blog/.../**en-2017-06-25-consuming-and-publishing-celery-tasks-in-cpp-via-amqp** (master → 2d7597c)](https://github.com/s3rvac/blog/tree/2d7597c58a158bac6d96253aad4ac7ff76c9f7bf/en-2017-06-25-consuming-and-publishing-celery-tasks-in-cpp-via-amqp) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqroj9f.)^.
looks interesting - the pattern i described works a bit different but tries to solve the same problem. from my point of view your implementation focus more on resolving all graph edges which must be known before the resolve phase begins - which makes it a good choice for graphql. my implementation allows the resolvers to create requirements from requirements, which is much more dynamic and works good (not just for graphql). Supporting my resolver in your API would be very simple, the QueryBookWirer would return a QueryBookWirer BookRequirement[] 
that's for user defined functions though right?
Just look op anything by @everzet regarding BDD
ok i’ll check it out. i’ve heard about it for a while now. wished it used vue but jquery is fine for now
Yes. Default compares with `==`, but you can set the third param to `true` to get it to do `===` comparisons
Because it's nothing fundamentally new. Before REST/HATEOAS took over, old APIs (everything from corporate bloat SOAP to XML-RPC to hand-crafted artisanal APIs) used to return the results you were after. Then for some reason in about 2008 people started hating on relational data. NoSQL and REST really started to surge in popularity. You now accessed individual records by their identifier and compiled stuff together client-side, or grabbed the entire kitchen-sink in the case of NoSQL. As those matured, people realized they "Hey, wouldn't it be nice to describe what I wanted and let the server package it up instead of doing all that work myself?" -- and MongoDB et al started supporting SQL-esque features (while still adamantly anti-SQL) and people have repeatedly tried to solve the inherent inefficiencies of REST. That's what led to GraphQL. At the end of the day, a declarative query syntax (e.g. SQL or LINQ or GraphQL) has proven to be the most effective way of getting data to a client application. GraphQL is nothing more than more user-friendly way to write almost-SQL designed by people who loathe relational databases so much but recognize the downfalls, so they hide the complexity on the server.
FAAS like AWS Lambda.
This is exactly how we do it Jira Ticket —&gt; create branch, no matter what the change:addition Keep PRe as small as possible and do many over one big one Keep code diffs specific to the Jira ticket, want to quickly change something else? New ticket All PRs require 2 approvals Unit tests is a must have PHP code sniffing will be run and must pass, this includes latest PSR Don’t get offended and if you’re new to the team be ready to comply to the groups standard (if its good...), once everyone gets into the habit of writing things he same way life becomes a breeze
Not PHP specific but I think micro services will become a lot more popular now that RESTful is common. Symfony has already been stripped back and trying to promote less monolithic approaches.
What was the hate on Soap? I feel like I missed an age with that. I went from all internal to fulll REST and skipped Soap. Having used it in a few interview code challenges this year I kind of liked it
From the Snow Flake example: &gt; The lookup for the class name `../../../../etc/passwd` will leak the passwd file. The attack only works until version 5.3 of PHP. Do you know where in the changelog (http://php.net/manual/en/migration53.ini.php) that change is mentioned?
You just need to add more if blocks
Through my experience, non-technical users also don't know how WordPress works either ( thats why they hire us ). Aside from the fact that WordPress isn't suppose to be a CMS, what you're basically giving people is a backend to work with plugins that do 99% of the work for them rather than them going under the hood to make whatever it is that they wanna make. October can accomplish this too, but you have to make the plugin :v. The only thing id say WordPress has over October at first glance is the massive amount of plugins.
&gt; PHP can use multiple cores, while Node is limited to only one is one advantage I can think of. https://nodejs.org/api/cluster.html#cluster_cluster
The hate for SOAP is because it uses XML. I prefer most markups over XML. JSON or protobuf are what I prefer depending on the situation.
- PHP usage will decline further as it is less suitable for the modern landscape of interactive apps and big data processing - We will be seeing more PSR-15 middleware and less layers of abstraction in other parts of our code (data access, templating, sessions etc) 
Not sure it's plugins. Out of the box it's better. Wordpress has the page design stuff, which makes it really easy for a non-techy user to change the title or add a menu. Maybe there's a plugin that does this for October, but as far as I can see from the default install, it's changing the html of a file. And there's no preview so you can see how it looks before you change it. I'm not hating on October just because. I love Lavarel, and any realistic competer to Wordpress is a good thing. But I can (and have) given Wordpress to non-techy users, and they can use it. When I look again it will be filled with broken html and 4 versions of an Instagram plugin, but they can still work it out without input. Give October to a newbie, and they'll break it in seconds typoing '{% partial 'header' %}' on the index page (if they can work out that the index page is under CMS and not Pages) and break the whole site. 
I think there's power in standardization. The beauty of GraphQL to me is that the syntax is well thought out and defined, and there's still enough flexibility to do what you need. We could all make our own relational APIs, but I'd rather have a well thought out standard, personally.
Actually not really where I have seen it the most is on core php functions inside user defined namespaces. The way it works is to signal de compiler not to look for the function inside your namespaces and instead to go directly to the core library. 
October Pond will be taking care of deployments so i think the issue of setting up could be solved with that (Though I don't care for automated deployments), but I can see what you mean about it's easy out of the box. I don't know, i think there's a line somewhere around what non-techy users should know as a basic requirement for building a website with a CMS. WordPress (while it isnt suppose to be a cms) offers a simplistic UI for people to navigate through, while OctoberCMS (Honestly I just like it cause im too lazy to build a backend, and can use plain Laravel) does "almost" the same, but requires a little bit more knowledge like basic html, js, css (sass if you're that kind of person). I "kind" of want that to be a standard in basic knowledge, otherwise you're just undermining what developers go through to develop plugins and maintain them. Think of it as a little push into the developer world. 
Its a text editor that completely sacrifices an intuitive user interface in an attempt to increase productivity. You know how some 'power users' know all the short cuts? Imagine a text editor that is comprised entirely of shortcuts. You literally can't do anything without knowing the short cut. Not even close the damn program. Now imagine it runs entirely in the terminal. That is Vim. 
Exactly
I just published my first PHP book. There is a sample chapter available if you want to peek inside. 
GDPR is relatively simple to manage; recognise that identity is a separate Bounded Context and build that part of your system in a way that supports the regulatory requirements (i.e. don't use ES). Any events in your system that pertain to a user should only refer to them using an ID. 
Could you elaborate a bit more about the "secure" part? I mean what kind of topics the book covers (besides CSRF and SQLi) and does it "prepare the reader" for security issues which can emerge practically anywhere in the code? In general, I mean how security minded the book is?
For XSS, CSRF and SQLi: an insecure implementation is shown and how it can be exploited. After that I show how to make the code secure. There is also information about how set up certain things (error handling etc), password hashing, how to prevent brute force attacks on your login form etc. It's not the main focus, but I still tried to cover all the important bits and pieces.
Thanks for the answer. Maybe adding some mention about XML parsing dangers and maybe browser security headers would be a good addition (if they are not yet there). Of course the list is extremely long, but if possible, it would make a good addition to bring up less common (when compared to XSS etc) problems as well.
Sockets. I'd be more than surprised if we don't see some kind of client-server framework which communicates through websockets instead of http soon. For the php ecosystem I wish we saw more resources focused on daemonized php. If you don't want to use another language on your server, you need those daemons when you start playing with events and queues or to play with long-live network connections.
The hate with SOAP is it was old tech when a generation of new coders got on the market and needed to pad their resume. So they removed all the cruft and got with JSON. And now they rediscover all the shit which got us SOAP, the need for tools. And 10 years from now when the JSON ecosystem will be old and with lot of things to learn before you can use it a new generation of reinvented wheels will appear. That's the cycle of code.
Good work! I'm waiting for a promo code :p
Promo code "launch" is automatically applied until Thursday :)
Thanks. Will consider that. Submitted it to HN, but I highly doubt that a PHP book will get any traction there ^^
Also, you should consider selling through https://leanpub.com/ . Lots of PHP/JS developers on that platform. P.S. - Just upvoted the HN post. Good luck! 
Timoh is right, you can add a "blog" page and post some code examples/page examples from the book. It could help you to obtain a better position in Google/Bing, this is good for SEO. 
This is neat and all, but do people really still write code like this in 2017? Yikes, if so. Most frameworks prevent all of those problems.
This made me feel ill &gt; Matt: It’s a bad reputation. I mean you can totally write bad PHP, and because it’s successful, a lot of people do, but you can write beautiful, elegant PHP as well. And in fact, if you like writing beautiful, elegant PHP, you can work at Automattic.
https://community-auth.com/documentation looks really good.
There is a strong chance your PHP script does not have permission to run the python script. While I can't give you an exact fix here is how I would approach the problem: 1. Ensure your debug settings are correct and your errors and debug messages are being logged in both PHP and Python 2. Monitor the log files while executing your script (eg. using tail -f /var/logfile) 3. Setup xdebug and livetrace the code 4. Use the other parameters of exec to view the result of the command: exec('your exec command', $output, $returnValue); var_dump($output); var_dump($returnValue); If you python script is being served through the webserver, it might be better to use cURL (or a library like guzzle) in PHP to call the python scraper via HTTP rather than using exec()
Would I be able to give it permission if I ran it on my own server? I don’t know much about HTTP calls and I think it would be quicker just to put everything on my private server.
Any day now...
Personally in php world - in 2018 i want to check swoole and create something on it and check how it's performing.
As far as i know many devs in china is using swoole and many websites in php in china are working on swoole.
I’m conflicted. It sounds beautiful but also like hell. 
PHP 5.3 is almost the same as PHP 5.6, there's only a few differences: no splat operator, no expression constants, that's pretty much about it. There's probably a few other features you won't find, but not so many, it's really the same language minus a very few things.
The biggest one for me would be that you'd have to define all your arrays using `array()`, as `[]` only came in 5.4. Eww.
Does your IDE support different language levels? For example, in PhpStorm you can tell it that your project is using PHP 5.3 and it'll use the appropriate inspections etc.
Books dated to release of php 5.3. gl
Factually incorrect. 5.3 wont even run on 5.6 eg 5.3 auto populated global variables with keys corresponding to $_POST keys. You can simulated that in 5.6 with some extra code that is prepended to each executed file, but that's complex topic. Some more PHP4 stuff works on 5.3 but wont on 5.6
Nope, they're right and you're wrong. You see, it turns out that being able to reliably rename a method and have that change reflected across all usages is a pretty useful feature. Vim simply cannot do this.
Yes, forgot that it was 5.4 !
As others alreay mentioned php did not change too much, to get an overview of stuff that has been added i would recommend the official migration information: * http://php.net/migration56 (5.5 -&gt; 5.6) * http://php.net/migration55 (5.4 -&gt; 5.5) * http://php.net/migration54 (5.3 -&gt; 5.4)
I've just finished a short course on writing OOP PHP web apps. I'm looking for the next step in learning PHP. Will this book be right for me? 
From your latest entry: &gt; In line 7 the e-mail address gets sanitized with `escapeshellarg()` Line 7 reads `return escapeshellcmd($email);`. So it's using `escapeshellcmd` - not `escapeshellarg`.
Which course did you finish? I think it might be a good fit. If you know the basics of OOP (how to use classes etc), then you have the right foundation. It starts with clean code theory (which your course probably covered too), but then goes into other topics like architecture and security during the tutorial.
I think I'd take this approach, too. Start from the most recent version you are comfortable with and review change logs back to php53. You're gonna be cutting out quite a lot of convenient features... so good luck with all that... I'd _HIGHLY_ recommend making a cheatsheet on the common things that have changed, such as shorthand array declaration.
To these I'd also add the classic vim plugins: * [ctrlp](https://github.com/ctrlpvim/ctrlp.vim) - Fuzzy file/buffer/mru/tag finder * [NERDtree](https://github.com/scrooloose/nerdtree) - tree explorer
I upvoted it, though the irony of your site not being HTTPS with HSTS and friends sprinkles on top was probably too much for others to do so ;-)
That's a problem with Github pages and custom domains :*( I was looking into fixing it with cloudflare yesterday, but didn't want to mess something up just before the book launch (changes take up to two days to propagate apparently).
Why not just `dump($object-&gt;method);`?
&gt; less developers will build plugins/addons for them. most of the plugins I've seen have been written by amateur developers - I'm sure it has no effect at all on the number of plugins being written as none of them care about quality.
I haven't read this book but I have read the same authors [No-Framework tutorial](https://github.com/PatrickLouys/no-framework-tutorial). Question - How up to date the content in the book is? Does it suggest using PHP 7.1 or 2?
7.2 (but 7.1 should also work) It's much more up to date than my old tutorial, I learned quite a bit since then :)
Great. Already in my shop list.
I like sentinel, the successor project to sentry.
Yeah I learned about classes mainly.. inheritance, encapsulation, magic methods etc.. I'm still a student so I have to vet my purchases extremely carefully, you see haha.
I'm guessing they've update this or else I'm confused.
My approach to GraphQL has been to keep my relational database for all my hidden backend work, but expose the data to the client through another mechanism (in my case, I'm using ElasticSearch.) This makes it pretty easy to allow searching and filtering through the GraphQL API without having to worry about indexes, and keeps the load away from Postgres. It does introduce a fair amount of complexity, and it took me a while to come up with a good strategy for loading relations (since ElasticSearch doesn't support joining) but it is working really well, and it's enabled me to have a full text search API on every string field.
To be frank as a non-c/c++ programmer I must have tried my hands on creating an extension a number of times. I read PHP docs and other tutorials but could not understand how an extension is written for a class. This is a worthy tool to start my long pending personal project. I have just created a project but did not compile and feel **extSkel** script should have more input validation and sanity checks. It throws PHP notices and warning: $ php extSkel --extension=MyTest --dest-dir=/tmp/mytest PHP Notice: Undefined index: proto in /xx/yy/zz/extSkel/src/extSkel.php on line 249 another one: $ php extSkel --proto=/tmp/ext_class.php --extension=MyTest --dest-dir=/tmp/mytest PHP Warning: mkdir(): File exists in /xx/yy/zz/extSkel/src/Analyzer.php on line 81 
I agree, I wish we could easily solve that problem with PHP. I'm stuck using node as a pass through for websockets, and it means a lot of duplication of logic.
I currently actually work on an large legacy application written in PHP5.3, I'm pushing updating all of the code to PHP7 in the next year or so. Some big issues to note, * Register globals exist in 5.3, so that may be something to be aware of while trying to maintain old code. * The syntax can be slightly different in some cases. For example, you can't call a method and it's return index on the same line ($class-&gt;method()[index]). I'm not sure when this was introduced, but I've come across a few cases of code I've written running on PHP5.6, that PHP5.3 won't actually work. * Performance is horrendous. I've read that arrays/string storage can take 18x the actual size to store, which mainly seems to be fixed in 7.0. This seems to be fairly inline with my experiences, because storing large amounts of data in an array to cross reference leads to a large RAM consumption and longer processing time. * MySQL wasn't deprecated (it exists in 5.6 as well). Personally I recommend implementing some mysqli/pdo if it hasn't been done. It will make migration easier in the future. * Array's have to be declare with array(). Using brackets won't work. I can't think of anything else off the top of my head that will have a huge impact. But if you're using Windows/OSx I recommend installing Ampps if you use a normal AMP stack solution(Xamp, Wamp, etc.). I use it primarily because I switch between 5.3/5.6/7.1 fairly regularly, and it fully supports multiple versions (including 5.3). The application I was working on didn't perform well under Docker, so I dropped it for this for the time being.
Yah - it looks like they did.
Coming from a PSR-7 project, how do you handle middleware w/ Symfony 4? For the most part, I have some code ported perfectly. Had to move a few files around such as Entities/Repositories into the flex folder structure and change Session and EntityManager to `SessionInterface` &amp; `EntityManagerInterface` and the constructor autowiring worked perfectly.
It's useful if you ever need to view/edit files on a remote server. It takes some up front investment to tweak your `.vimrc` to your liking(plugins help, I use plugged/vim-plugged to manage them.) I find myself in vim several times throughout the day but do all my heavy lifting in a proper IDE.
Just going through this tutorial now. Impressed how clear and digestible it is.
For OSX, docker and symfony I like to use docker-sync. It uses rsync and unison to sync files instead of using docker native volume. It deliveries almost native performance. 
Gotcha. I really should dive into it sometime. I can definitely see how it could be useful.
In my opinion, and experience, you're going about this the wrong way. You don't create a PHP worker than can handle generic tasks - you build a single worker for each task you want to run. For example, you have an queue that creates thumbnails from a set of images - you should actually write the PHP code to handle creating a thumbnail from GD or imagick or your choice of tool, and then have a worker listener that can kick this worker off. Attempting to read data from a queue and creating dynamic code off of that sounds like a bad idea - unless you're not doing this and I misread your question and I'm an idiot.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Because that dumps the return value of `method` while the original dumps `object`
[Try](https://www.amazon.co.uk/Opihr-Oriental-Spiced-Gin-70/dp/B00N3VMDJY/ref=sr_1_12_a_it?ie=UTF8&amp;qid=1512487164&amp;sr=8-12&amp;keywords=gin) [https://www.amazon.co.uk/gp/slredirect/picassoRedirect.html/ref=pa_sp_btf_aps_sr_pg1_2?ie=UTF8&amp;adId=A0176453IAPCA2TUC3CN&amp;url=https%3A%2F%2Fwww.amazon.co.uk%2FTanqueray-No-Ten-Gin-70%2Fdp%2FB00429MOW2%2Fref%3Dsr_1_19_sspa%3Fie%3DUTF8%26qid%3D1512487164%26sr%3D8-19-spons%26keywords%3Dgin%26psc%3D1&amp;qualifier=1512487163&amp;id=800578585212734&amp;widgetName=sp_btf](some of) [https://www.amazon.co.uk/Plymouth-Original-Strength-Dry-Gin/dp/B0074HZD22/ref=sr_1_29_a_it?ie=UTF8&amp;qid=1512487188&amp;sr=8-29&amp;keywords=gin](these). Hopefully you won't actually need to implement new features in the application, and if you are asked to I would recommend pushing back and suggest instead either migrating the app to php 7, or to make the new features be a separate 'microservice'. The issue isn't that PHP 5.3 is horribly different. The issue is that people haven't written libraries that support PHP 5.3 for ages, which means that every feature has to effectively be written from scratch each time.....rather than usually being able to find a library that does most of what you want. /off-topic. Amazon.com doesn't sell spirits.....whereas Amazon.co.uk does.
I think it is a communication issue on my side due to english not being my native language. I inherited a big pile of php code. Most of the calls into the php code is http or wsdl calls. I already hooked one of the php call to a [rpc queue](https://www.rabbitmq.com/tutorials/tutorial-six-php.html) as a consumer/server and created a [pika python producer/client](https://www.rabbitmq.com/tutorials/tutorial-six-python.html). That loop works and I'm happy with the proof of concept. But now I need to do it for a lot of php calls and using a structure like the [celery protocol](http://docs.celeryproject.org/en/latest/internals/protocol.html) makes sense to me. But I wonder why it have not really been attempted before. I found a c++ example tutorial which I will port to php once I get time or motivation.
Hopefully the fairly boring technologies that make code safer/better such as static analysis tools: - [PhpStan](https://github.com/phpstan/phpstan) - [Phan](https://github.com/phan/phan) - [Scrutinizer-CI](https://scrutinizer-ci.com/) Reply with other static analysis tools you've found to be helpful.
If the dump returns what it's given, the object the same thing, wouldn't `dump($object)-&gt;method() ` return the same thing? 
 $a = dump($object)-&gt;method(); $b = dump($object-&gt;method()); $a === $b // true Line one dumps the value of the object to the screen. Line two dumps the return value of the method call to the screen. $a = $object; $b = $object-&gt;method(); $a === $b // false 
Take a look at Flarum, it's similar to GH Pages, but offers many more benefits. :)
Pretty cool examples so far. How about making it sticky for this month?
Line one is my point exactly. They result in the same thing. 
It's pretty similar to 5.6. I would highly recommend pushing them towards 7.x since the EOL for 5.3 was in 2014. Running 5.3 should be considered a big risk for the organization.
Essential feature for when you have to jump between projects.
Thanks buddy, yes you are right, it's still lake for some validations &amp; sanity checks also it seems that the repo missing the main extensions directory, I will fix it as soon as possible, thank you for your contributions.
Are trying to say that the two calls would be interchangeable?
If we're talking about a *net* benefit then his statement is valid.
I think his point is that the IDE can generally determine what this method is. You don't need to `var_dump` it. Removing unnecessary steps is a valid metric for measuring productivity. Being able to reason about the code without running it should be a requirement.
`dump($object)-&gt;method()` would result in the same thing as `dump($object-&gt;method())`, so yeah they're interchangeable. 
Except the value that is dumped to the screen is not the same thing, only the resulting value. They are entirely not interchangeable in this example. class Thing { fn m() { return 5 } } $a = new Thing(); $v1 = dump($a)-&gt;m(); // prints "object Thing" $v2 = dump($a-&gt;m()); // prints "5" Yes, `$v1 === $v2 === 5`. But we did not print "5" twice. This isn't a difficult concept.
I used the tutorial, but changed stuff to use 5.6 compatible code.
I'll second this recommendation, and follow it up with [kelunik/two-factor](https://github.com/kelunik/two-factor).
Welp, I'm probably late now but, * I have no idea where your Python script is (if you're running everything on Windows, I'm not really sure if the permissions are an issue. But it seems you aren't so this is entirely possible). * Easy way to debug permissions is to follow what he said above for dumping the output of the exec, and having the python script print out a response itself. Should now see any errors/this output. * The exec command may work better with the parameter wrapped in quotes, I doubt it but it's possible (exec("/usr/bin/python /var/www/html/group_a/job_scraper.py '$userID'");) * Set error_reporting(E_ALL) and ini_set('display_errors',1) to ensure errors are appearing. Really, the main flow for debugging this should be, * Make sure the PHP code is can run exec(). * Make sure PHP is running your command. * If not, get the output. If no output, use a command that will always output something. Check permissions if applicable, etc. * Debug the Python script is actually receiving the paramter etc. I find debugging in steps is best because you can isolate where the problem is originating from.
The biggest issues for me, syntax-wise, that I had when on a 5.3 project recently * No short array syntax (already mentioned above) * No ::class syntax * No Traits
Interesting. I actually mainly support 5.3 code currently, so unfortunately I'm not fully aware of all of the different options in newer versions (came from a .NET background). I've never actually heard (or seen in code I review) of the last two.
Public-key cryptography (encryption, signatures) that [don't suck](https://framework.zend.com/security/advisory/ZF2015-10) to use. See https://paragonie.com/blog/2017/06/libsodium-quick-reference-quick-comparison-similar-functions-and-which-one-use for a quick start.
Appreciate the help, I've think I narrowed it down to a permission issue. Because I was able to send a param in and manipulate it, print it to the PHP file. But something about writing CSV files threw it off.
No problem. I barely used Python, so I won't be any help there lol.
Bought it!
https://csv.thephpleague.com/ is usually my go to when doing anything with a CSV's
Looks like forum software? How is that related to GH pages?
Thanks. Let me know what you think when you are done reading. :)
But why? [5.6 is on it's way out](http://php.net/supported-versions.php)
I wouldn't recommend using a package that hasn't been updated in two years with hardly any activity for anything security related. https://github.com/Spomky-Labs/otphp is a MUCH better option.
What specific security deficits do you believe are present in /u/kelunik's library, but not yours?
There's nothing to update for a small and stable package.
Here's how you would do that with Symfony serializer: $exampleCsvContentAsArray = [ ['header1' =&gt; 'lol', 'header2' =&gt; 'bar'], ['header1' =&gt; 'fuck', 'header2' =&gt; 'baz'], ]; $customDenormalizer = new Class() implements DenormalizerInterface { public function denormalize($data, $class, $format = null, array $context = []) { $data[0]['header1'] = 'normalized data'; $serializer = new Serializer([], [new CsvEncoder()]); return $serializer-&gt;serialize($data, 'csv'); } public function supportsDenormalization($data, $type, $format = null) { return true; } }; $serializer = new Serializer([new ArrayDenormalizer(), $customDenormalizer], [new CsvEncoder()]); $exampleCsv = $serializer-&gt;serialize($exampleCsvContentAsArray, 'csv'); var_dump($serializer-&gt;deserialize($exampleCsv, 'meh', 'csv'));
[This page](http://codelegance.com/new-php-syntax-reference/) is pretty good and shows the new features added in 5.4-5.6
Just what I'm stuck with at the moment. 
&gt; I think there's power in standardization. Is this a joke? You do realise that SQL has been standardized since the 70s?
Are you attempting to assert that vim's inability to do project-wide method name refactoring is proof positive that it has zero benefit over the use of an IDE?
There is no standard to expose SQL queries and return data to HTTP clients that I'm aware of. I certainly wouldn't want to offer that as an API anyway.
[removed]
This is the guide that most people recommend for people looking to get started. [PHP: The Right Way ](http://www.phptherightway.com/) Setup your MySQL database, create a user with a password, give the user permissions to do what they need in the database (most likely SELECT, INSERT, UPDATE, DELETE) Create your PHP file to connect to the database. Use PHP-PDO to connect to the database. Write your SQL statements to work with PDO. [This tutorial is pretty good and pretty simple. ](https://phpdelusions.net/pdo) Do whatever else you need to do, hard to say without knowing the project and how much time you want to put into learning PHP. If you know some other languages, you will find PHP very simple. Your professor will most likely want to see you use things like classes, functions, and OO programming, so make sure you use those when possible. Some more on that [here](http://www.phptherightway.com/#programming_paradigms) 
https://www.postgresql.org/docs/9.2/static/sql-copy.html
Thanks for this, I really appreciate it. PHP itself seems fairly straightforward so far, so fingers crossed I can get the rest handled. Again, thank you — you’re a lifesaver. 
Congratulations! Your old github tutorial on building a frameworkless application helped me a lot back then, I will gladly add this one on my wishlist!
Why not just use [docker-compose](https://docs.docker.com/compose/)?
If only enabling xdebug wouldn't hurt performance so badly...
Look where phpuck will be, not where it is - Rasmus Gretzky
Thanks. Glad to hear that my tutorial was helpful :)
huh?
Codeigniter's minimalism made it very easy for me to learn MVC concept but it such a burden to use to build production CRUD app. I remember spending days researching optimal solutions to the authentication problem(which library to use, design pattern, security, validation, etc...). Laravel did all these right out of the box and still maintain its flexibility.
PHP because I prefer my entity to not give a shit.about the view, the businesss logic and trying to be a repository all at once
I think you meant to post this to /r/iamverysmart
Possibly
The article seems to lean a bit toward PHP too
Man.. I had a laugh. This guy was hilarious. He's cynical as F, but he makes a lot of snide hilarious remarks I totally agree with. But somehow.. he actually seems to actually use the language? Anyways.. those who complain the most are often the most experienced users of said complaint-oriented garbage. Old modo goes, you can't complain like I can because i actually F`ing use the damn product.
That's a harsh truth that precisely explains, among other things, why it's negatively received in this sub
Wasted 10 minutes reading this... The author is probably trying to run a rant blog so he can get visitors... But I think this is the result when you pass to an AI 2 topics and a bunch of keywords. 1. Java is the best language out there and/because I (the author) use it 2. Java community/language/frameworks/IDEs is/are smarter than PHP Keywords: semicolon, fucking, elegant, ugly, smart, ball of mud, community...
That guy says ball of mud a lot in his 4 or so articles he's written on his new blog. I really want to say words that begin with laugh, and with laugh, in between out.
Thanks for the links. &gt; if you are asked to I would recommend pushing back and suggest instead either migrating the app to php 7, or to make the new features be a separate 'microservice'. AFAIK they use different technologies and 4 or 5 different languages for different tasks, which is nice. However updating to php7 doesn't seem very realistic for the next few years, it would be good if we update to 5.6 though.
Somebody please put me out of my misery if I ever become this much of an attention-seeking edgelord. Also, for someone who ostensibly cares so much about "improving existing solutions", he sure spends a lot of time on masturbatory insults rather than even pretending to care about starting any sort of actual discussion.
In my team we use a collection of tools at the same time as well as manual pull request analyse to ensure high code quality. tools we use are; [PHPCS](https://github.com/squizlabs/PHP_CodeSniffer), [CircleCI](https://circleci.com/) and [PHPLint](https://github.com/wayneashleyberry/phplint) 
&gt; However updating to php7 doesn't seem very realistic for the next few years Definitely do an analysis of how much work this would be. Chances are it's not very much and it'll save your lots of pain in future. But again, it depends what you're asked to do. I you just running "keep alive" operation on the application or are you maintaining it?
&gt; Syntax, But who the fuck cares? +1 &gt; Using decent frameworks like Symfony doesn’t help them a bit. +1 I've seen Symfony monsters everywhere I've been (Paris, Tokyo, London). &gt; Let’s consider a smart community. Like Scala. Scala ... omg Let me tell you my experience with Scala after 8 years of PHP/JS. I had to maintain an API that was designed half in Java/half in Scala (at a time when both could not be compiled together) with the Play framework 1.2.7. Look online for the best practice, official documentation and third party dependencies to build anything standard in a modern web app. There's nothing. It's crazy. It means everytime you want to build anything in Scala, you have to reinvent the wheel in Scala. Besides it took me 2 month to build a CRUD endpoint with the latest version of Play framework 3.x. Who in his right mind can stay productive with a tool like this. I watched a video once about a developer who gave career advice and he said if you want to be successful at a software developer, always build the most unmaintainable code. This way people will believe you're clever and always call you back for more work. Scala is the best way to achieve this idea. I don't like this approach, I like KISS, I like best practices, I like frameworks, I like reusable code. I know 6 months, 1 year after I drop my baby source code, someone will go and read it and have to update or replace it. Which brings us to... &gt; Reusable Code aka The cycle is endless madness. &gt; The only community worse than the PHP community in this regard I know of is the Node.js community. Actually, most node packages have more advanced options and are better maintained these days than they php equivalent. There is a clear lack of maintenance for core Symfony bundle and php libraries the past 3/4 years. I'm really worried about the situation. &gt; The code that you likely don’t have money nor time to write yourself. The problem is not writing code, it's maintaining it. Every line of code you write will be read at least 10x times. You should write in a way to acknowledge this. Also your code will probably have to be replaced by a better implementation so always let the door open for this. &gt; Let’s see who writes well tested production ready application code faster. I’ll wait you on the finish line. More like, let's see the next developer who takes over your code, how fast he can improve your existing features or build a new one. This metric is more important IMHO.
The line numbers bug out on chrome (at least on a mac), they work in firefox though.
I'm not sure tbh but I know that several devs work on this project and it's actively maintained. During the interview I asked if they plan on migrating to php7 and they also confirmed that it won't be easy task.
I'd like [PhalconPHP](https://phalconphp.com/en/) to trend tbh.
Interesting use case. Thanks for sharing.
Oh man, a very good read ... and at the end I almost fell out of my chair: "Proudly powered by WordPress"
I can see that there are lots of positive mentions regarding your "github tutorial on building a frameworkless application". You should create a new book starting from there. Good luck!
You just focusing on syntax of this language.
That's what this book is all about :)
&gt; But none of the dynamic languages will ever get the level of code completion that’s available for Java. It's only logical. Java is not a weakly typed language. 
Sounds about right. Half of the information is just outdated or flat-out wrong. At best, the author has written some PHP and Java and feels a very strong need to defend his preference (likely due to being insecure about his abilities). PHP has strengths and weaknesses. Java has strengths and weaknesses. Haskell has strengths and weaknesses (but they're all pure). Vim has strengths and weaknesses. IntelliJ has strengths and weaknesses. Noticing a trend? Yes! It's indeed that the author is, in fact, "Highly Opinionated", and his opinions are based on almost nothing of substance.
I wish there was some way we could take away PHP from people who write these /r/iamverysmart posts. XD Most of this isn't a trying to provoke a discussion, it's just shitting on other languages
Sorry, wrong software. I meant Netlify, it's a fantastic static site host. I must have been half asleep when writing that last comment.
I was going to answer that long rant, point by point, then I decided it isn't worth at all, because it doesn't go anywhere. You like Java? go do some Java instead of trying to turn PHP into Java, something it will never be, an obvious fact. You'll be free from working with "morons". People are doing PHP either because that's all they know, that's all they are willing to learn, legacy reasons, because Wordpress or Magento are written in PHP, or because it's cheap to deploy and the opensource ecosystem isn't that bad even for obscure tasks. I might be wrong but I didn't see anybody writing distributed database systems from scratch in PHP, router software, container orchestration, distributed worker queue systems when it comes to server programming, or solve complicated comp-sci problems like machine learning or spam detection or physic simulations as their daily tasks in PHP. The large majority of PHP developers are writing CRUD for 9 to 6, and it's fine. And if some graduate to a job with Java,Go,C++ or .Net, there is absolutely no reason to go back to CRUDing for 9 to 6 ever again. 
Haven't bought it (yet).
When working with code? Hell yes! I do a significant amount of ops/sysadmin work, and use vim daily when SSH'd into various boxes. Editing config files, working with logfiles (etc) are all great use-cases for a text-oriented tool like vim and for these tasks vim is objectively better than any IDE. But when it comes to code, vim is just stupid. IDEs 'understand' code and thus make common refactoring operations *safe* - method renaming is the most trivial example of this but is a useful yardstick when comparing them to vim as vim fails even in this, the most simple of cases.
&gt; PS: He forgot C# his article &gt; There are IDEs for other languages from JetBrains. HTML/CSS, PHP, Ruby, Python, JavaScript, Go, C, Swift, *and some Microsoft languages I don’t give a shit about*. I think this part covers C# ;)
I forgot to respond to this. My point is valid. There is a greater demand for Javascript devs than there has ever been, meaning companies are hiring people with less and less experience. I’ve worked at large companies and small companies, and the lack of knowledge and know-how in the new people is pretty astounding.
[removed]
It's nice that the library has slowEquals, but why does it have classes for algos like sha256 or whirpool? If you want secure passwords without any additional dependencies or coding, use BcryptHasher, just know that strength can be between 4 and 31, higher takes longer (making the password stronger against brute force attacks), so try working with your hardware and set it to 11 or 12 and see how long it takes to log in. Or just create your own Hasher with password_hash, just add algo (from 7.2 use PASSWORD_ARGON2I, before use PASSWORD_BCRYPT). For Bcrypt, set option cost (same as above, default is 10). The primary benefit of the native functions is password_verify, which will take the hash, detects algo and setting from it, applies them to the string, compares them and returns bool value. That means you can have multiple algos in database and not care. You can set up Argon2 after migrating to 7.2, and after each login, after they validate, check db algo, hash the password with new settings and store it. Or only use new settings for new users and users that decide to change their password. Everyone will still be able to log in, you do not have to set up different validators and you are ready for the future.
As far as I know Symfony 4 is not PSR-7 compatible framework because of the Syfony HttFoundation library. Have you tried the [PSR-7 Bridge](https://symfony.com/doc/3.3/components/psr7.html)? For me this sounds like an overkill. That's why I have tried to implement a Middleware stack for Symfony](https://github.com/odan/middleware). It works realy well, but I moved to Slim (a real PSR-7 micro framework) and closed this library.
Reading the article, I would select PHP. Having started my career with PHP, used it for 6 years, and making the switch the ASP over the last two years at work, I can tell you most of the article is also wrong. (Mainly about ASP) Knowing what I know from real experience with both, there are use cases for both, and the project nature &amp; scope would influence my decision, neither is out right "better". That being said I think DotNet Core (Successor to ASP) is by far the nicest to use, and addresses pretty much every issue raised in the article. I don't think there is anything PHP can rightly claim to do (Factually) do better than DotNet Core.
"And unlike you, I pick Java and get a ton of reusable code that I don’t have to write myself and awesome tools that make me very productive writing the application specific code that I do have to write." So whole article with examples who his language of choice allows great productivity in Infrastructure part of code base, and... He use it to prove that he will be productive in Domain part of code base?
**No publication date was provided so this article may be outdate as f***" With that worning in mind, I would also state that it's full of generalizations. So no decision should be made based on this article. (In fact any "should I choose X or Y" is folly. "I need a, b and c, so should I choose X or Y" is always better!)
https://web.archive.org/web/*/http://www.orbitinformatics.com/choosing-platform-for-your-next-project-php-vs-asp-net/ -- Apparently it was first archived in April 2017, for what it's wroth.
Maybe you could give this a shot. [Zephir](https://zephir-lang.com/)
This guy's Twitter is a gold mine for condescending /r/iamverysmart snippets if anyone is interested.
Did someone push that article through google translate? What is Hungarian before??!!
How is that different than years ago when jQuery was getting pushed as the mother of all JS libraries, and was used almost unanimously? 90% of the jQuery code people wrote back then was crappy, untested and non-performant. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; But when it comes to code, vim is just stupid. vim doesn't have to be "smart". The things you do regularly when working with code don't require it to be smart, nor would they benefit in any way from it being smart. &gt; IDEs 'understand' code People talk about this like it's some game-changing thing, but it really isn't. Moving text around, searching it, changing it, adding/removing lines/blocks/characters, comparing things, replacing things, sorting things, aligning things, and all the various other tasks that the overwhelming majority of "coding" comprises are all things that don't benefit from an editor that "understands" code. There are certainly tasks that do benefit from it, like refactoring, but vim has a plethora of plugins for doing these things, and will happily integrate with any external program for things that it doesn't. The fact that no one has created a standalone tool specifically for refactoring method names across a PHP project is not a shortcoming of vim. It's a sign that the demand for such a tool is very low, likely because it's a task that you don't do very often (if ever). But all of this is really tangential to the fact that vim's inability to do this one, very specific, very rare task does not magically erase all of the other benefits it has over use of an IDE for working with code. &gt; and thus make common refactoring operations safe PHP has far too much dynamism for automated refactoring to ever be truly "safe" in a practical sense. But maybe you just mean "safe enough for average use-cases where developers don't try to be too clever" instead, to which I can point out that you can do most of these same tasks with vim (using plugins, of course). And, yes, many of those plugins "understand" your code, to the extent that it's useful for them.
You mean Java won't save the world?
I made something for you! https://puphpet.com I'd suggest you splurge for a VMWare or Parallels license, the performance difference from Virtualbox is drastic enough to make it worthwhile.
[Docker](https://www.docker.com/), along with a few service containers, makes a fast and slick development environment. There are a few examples and tutorials out there for its use. Here's one: https://docs.docker.com/samples/library/php/
Another vote for docker.
Wow, quick work ;-) I'm taking a look, and already a bit overwhelmed with the sheer number of options - can I just shut my eyes &amp; go ahead with the defaults? No wait I have to add a user, right?
Just go through it step by step; the default user is `vagrant` when you use `vagrant ssh`; Change the nginx or apache default vhosts to match what you need and you'll be set to go.
Ok you didn't ask for this so please ignore if you want, but I went through the default settings, downloaded the zip and ran `vagrant up` and got this error: A customization command failed: ["modifyvm", :id, "--name", "machine1.puphpet"] The following error was experienced: #&lt;Vagrant::Errors::VBoxManageError: There was an error while executing `VBoxManage`, a CLI used by Vagrant for controlling VirtualBox. The command and stderr is shown below. Command: ["modifyvm", "b2a17141-9c79-4430-8237-dc5a1191889d", "--name", "machine1.puphpet"] Stderr: VBoxManage.exe: error: Could not rename the directory 'C:\Users\Me\VirtualBox VMs\php-dev_machine1_1512573143280_81910' to 'C:\Users\Me\VirtualBox VMs\machine 1.puphpet' to save the settings file (VERR_ALREADY_EXISTS) VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component SessionMachine, interface IMachine, callee IUnknown VBoxManage.exe: error: Context: "SaveSettings()" at line 3060 of file VBoxManageModifyVM.cpp &gt;
https://bitnami.com/stack/wordpress/installer
I pretty much enjoy [Laragon](https://laragon.org/). While it's name implies that it is Laravel specific, it's actually not and has so far been quite useful.
Great book, I really liked the part one theory! I learned php before I leaned OOP many moons ago and this book would have changed my life back then. I would love to hear more of your thoughts in possibly blog posts or another book if you took the approach that your reader already knows OOP. For the price 4.5 / 5 stars
I've gone through a lot of development environments. The one that makes the most sense and ease of set up is: https://docksal.io/ I've used it on Mac and Windows - and it works beautifully for both. Highly recommend!
I also am in favor of docker, but have to say that it has a steep learning curve. Especially when coming from Vagrant, because it handles everything differently, so I was kinda confused and wanted to go back to Vagrant at first, but now, I'm totally in support of docker! 
This is the best choice, by far.
This sounds like a docker env for Drupal development. Why would a non-drupal developer need `Drush` and `Drupal Console`? Not trying to be offensive, really trying to understand but that project looks like it could also be hosted on Docker hub
Seems like the correct way to do it is by using events w/ before filters, just sucks that you have to do the route checking and all that jazz inside the event itself. Issue w/ this approach is I don't think the `FilterControllerEvent` supports changing of responses (ie.: Redirecting) https://symfony.com/doc/current/event_dispatcher/before_after_filters.html
No offense taken. There are multiple "stacks" to choose from: https://github.com/docksal/docksal * Drupal 8 * Drupal 7 * Wordpress * Magento I've even created my own from their base docker image.
How would you go for a LAMP dev env with Docker, single container or two containers (one for Apache + PHP and one for MySQL) ? 
I run a full Ubuntu VM using VirtualBox. 
Whole thing with docker is compartmentalizing everything. I’d go one for Apache one for FPM and one for MySQL. Though MySQL on docker is really only meant for development. You’d never run that in production 
Split it up, but you can use docker compose to "contain the containers" in a single thing. https://docs.docker.com/compose/
Things like Docker and Vagrant aside, consider trying out the Nginx web server. It has much better performance per-user than Apache. If your dev/production environment is very limited on performance, you can eek out a lot more connections on the same machine.
&gt; vim doesn't have to be "smart". The things you do regularly when working with code don't require it to be smart, nor would they benefit in any way from it being smart. Common tasks like being able to reliably rename a method and all uses across the codebase *requires* a smart tool - one that is aware that code is more than simple text and one that can do tasks beyond simple text manipulation. &gt; vim has a plethora of plugins for doing these things, and will happily integrate with any external program for things that it doesn't. And IDE's do this out of the box with a greater reliability out of the box. I want to be fixing bugs / delivering features, not wanking off over configuring my tools. When I move to a new job / get a new machine I simply download the IDE, open the code and begin working. &gt; PHP has far too much dynamism for automated refactoring to ever be truly "safe" in a practical sense. It depends on the quality of the code you're working on. Legacy systems will be a shitshow, but I haven't encountered an erroneous refactoring with PHPStorm in the 5+ years I've been working with it. Not once. 
Docker Compose is most definitely the way to go.
Been using Lando too, which is somewhat of a wrapper around Docker https://docs.devwithlando.io
register_globals is off by default since php 4.2 and was removed in 5.4 
I read that as satire...
&gt; VERR_ALREADY_EXISTS The machine name you chose is already in use.
I'm still using good ol' vagrant. Simple, doesn't take much effort to setup and you're working directly w/ what ever OS you install from shell. I still haven't got on the docker hype train yet.
I tend to bundle Apache or Nginx in the same container with phpfpm. They can’t work separately (for serving php) and need access to the same source files, so for me it has simplified things to just combine them.
My vote is for Laragon too. It comes with loads of additional tools nicely collected in and integrated. You can also hot-swap PHP, apache, mysql, and nodejs versions. and yes, there is a version with nodejs + npm too, although I don't use Laragon-provided one. 
It doesn't matter for developer machine
I use a few different things, including a Vagrant/VirtualBox setup for a Laravel-based project and a Docker setup for a newer project. At home, I just use [MAMP](https://www.mamp.info/en/) and [VSCode](https://code.visualstudio.com/) with the xdebug addon: [PHP Debug VSCode Extension](https://marketplace.visualstudio.com/items?itemName=felixfbecker.php-debug) It isn't fancy, but it is easy to set up and works perfectly.
If you are upgrading to Windows 10 pro anytime soon, consider Windows subsystem for Linux. You can run Ubuntu and can run almost any tool you'd need in a web server. You can't run kernel-specific apps there (because Windows provides the abstraction layer converting syscall to Windows ones) or GUI apps (although some have successfully installed a working X server there). For development work, it is perfect. 
Yes it does. For a sample, if you have a file upload limit of 50 MB you need to know that on your production server uses Nginx or Apache so you can make additional changes to conf files. Your Docker local/dev/test/internal/etc. environment(s) should be as close to your production environment as possible.
This article has a lot of incorrect information. As someone that grew up on PHP and now works at Microsoft on the .NET ecosystem, here's my take on PHP vs .NET: **PHP** + Fantastic ecosystem. It seems like there's a package for most everything these days + Fantastic development experience - everything just *works* - PHP is losing support from large companies. Facebook, Wikipedia, and Baidu are all using HHVM these days **.NET** + C# is a wonderful language that is like a polished version of PHP + Performance. .NET outperformed PHP on the latest [TechEmpower benchmark](https://www.techempower.com/benchmarks/#section=data-r14&amp;hw=ph&amp;test=plaintext)). I expect the performance gap will widen over time + Microsoft is betting big on .NET as .NET is one of Microsoft's key "products" for Azure. - Development experience. .NET languages are compiled and have rather high start-up times. Whereas in PHP you can save a file and immediately see the changes, in .NET, you usually have to wait multiple seconds. Some incorrect statements from the article: * .NET is pretty much free these days. C# is now completely open source, and developing C# on Microsoft's free VS Code editor is delightful. You don't need to pay for debugging. * .NET is now cross-platform with .NET Core. In addition, .NET can also be used on Android, iOS, and native desktkop apps! Personally, I think that .NET's future is brighter. My recommendations: * If you're a student that is looking to learn either PHP or C#, learn C#. * If you're looking to quickly hack together an app, use PHP. * If you're looking to build a large project, either PHP or C# will do fine. Use whatever you're most comfortable with!
I would go debian without a DM
I used to work on vagrant before, shifted everything to Docker recently. Never looking back.
My personal top three blunders are as follows (not any particular order): 1. Using = when i mean to use == 2. Not returning a value from a function when it's expected 3. Boolean dislexia (which really is language agnostic)
I use Laragon on Windows and docker on OSX. 
This is unwise: http://unserialize.in
Grabbing popcorn
That's what I agree with. But if you use xampp you don't care about mimicking production environment
Did you mean to link to a page with your custom input? 
I have used vagrant and went back to xampp or wamp. I don't mind it. I have dozens of vhosts, a few ssl certs, and can configure Apache to work however I want. I have 3 versions of php and can switch between then as needed. I didn't like the complexity of using vagrant even with tools provided. If I want a new site, create a new vhost and add the URL to my hosts file. If it needs a specific php version, switch to that version and install whatever mods are needed. If vagrant works for you, or docker, use it. I just found the added complexity not worth it. That being said, I am very familiar with Windows and Linux and can quickly troubleshoot and configure my environments and make sure they match up.
Isn’t this like a car manufacturer saying how their cars are better than the steel they are made with? Doesn’t make sense to me.
&gt; Even the most meaningless request will be parsed and turned into the valid and predictable SQL. I'm baffled that the author thinks this is a good thing, especially given how badly that approach has backfired in PHP's own history.
&gt;In Doctrine migrations are made automatically for you, all you need to do is define the model. In Eloquent, you have to make them manually, but don’t need to define fields in the model. Huh? No you don't. This article blows and so does this topic.
You can run Apache or Nginx in a separate container than PHP-FPM as long as you're not using fast_cgi and using the FPM socket. I think usually port 9000.
Vagrant is nice. Docker looks intriguing, but the curve on it seems steeper.
give them a beta api ?
No, I did not. I don't test live systems without a business agreement in play.
If you learn to use Docker, take a look at https://docs.docker.com/compose, it will help you to define an environment per app and easily share your environment.
Oh certainly, but I just don’t see what the benefit is to separate them. If you or anyone else know any benefits to keeping fpm and the web server in separate containers I would love to hear.
Ah. It just seemed strange to link to the same thing that the topic meant to.
Meh. Ubuntu may not have the geek cred Linux has - in general. But's just so easy. It's really a means to an end for me and running a basic LAMP stack on Ubuntu is so effortless. &gt; without a ~~D~~VM Assuming my edit is correct - I am almost there. Still rocking a Mac as my daily dev machine for now. My company allows us to use Linux so the next time I'm up for a hardware refresh it's going to be a serious consideration.
I've tried that, it worked better since the latest windows update (had performance issues when files were in /mnt before that) but sometimes it would prevent me from browsing internet, like there's an issue with DNS or port conflict ? I've tried it on multiple machines and the same issue always came up with apache and mysql. If anyone has any idea about what was happening, I'd happily take some advices 
(Programming language) &gt; Every programming language has some constructs that make it unique and better than the others. Not using those constructs is a big mistake. (Service Container) &gt; Thanks to the ability to access services from the global variable, you can use any service you need in any place you need. With that — point goes to Laravel! So this means we all should use globales http://php.net/manual/de/reserved.variables.globals.php , otherwise we make big mistakes and we unfortunatly cant' use everthing everywhere, right? I don't know if i should crying or laughing
yes but that's not the argument that was made, which was that it has higher performance per user. with 1 user (the dev environment) that is completely irrelevant. the reason to use the same server for dev as for prod is as you've said, but that is tangential to the original point.
I dunno whether you're a fool or a troll, but meh. The outcome is the same.
If by that you mean having different stages (like develop, staging, master), we do have that. But I think that does not change the fact that if we merge PRs without a sufficiently thorough review, potential bugs can make their way to production that the author didn't anticipate.
I meant without a Desktop Manager as in Console only, no GUI. Saves on memory not running a DM. I run XMing on windows and use Putty to forward the Xwindows if I need to run a UI program.
I tried to switch from Vagrant to Docker on Windows, but had fours issues coming up: - Performance issues with shared files using symfony. On Vagrant I can just use NFS through a plugin and performances are much better - It was a pain to use with multiple projects because I always had to close current dev environnement, and then docker-compose up one for the project it want to switch to, etc, and I switch a lot between projects. On Vagrant I just put everything in different folders in /var/www and used only 1 VM and when I switch project, I just switch URL. I don't really need special versions of PHP for each projects where I'm working. - Docker needed hyper-X, but sometimes I do android dev and emulators didn't work on hyper-X so I had to reboot everytime I had to switch to an Android project - Command lines felt weird, like connecting to a container to use the PHP command like from SSH felt like I wasn't doing the good thing ? Did I just do everything wrong? If you have advices about all that, it would be appreciated. Maybe Docker works better for other OS?
Sit in their shoes. What is their problem? Are you the bottleneck? If so what can you do to help? If they are waiting for an api to become available then you could sit with them to agree on the specification then create a dummy api while you actually get the thing working. If the backend team is always lagging behind ask for more development resource. You have said people are grumbling but haven’t really covered why. If things are going well people will not ask you to change your development processes. 
&gt; Laravel, on the other hand, uses traits and magic methods on a regular basis. Thanks to that the code is not only much shorter and without many repetitions, but it’s also easier to understand Lmao
There's also a translatable behaviour for entities: https://github.com/KnpLabs/DoctrineBehaviors#translatable It seems OPs issue with this, service injection, Twig functions etc. is that they don't actually want to stop and think about what they're doing. Global service location, call any function in the view, no need to define fields in models wooooo we're writing code at 100mph!
I was in the same spot, loved vagrant and had used it for years, just started working with some new folks who used docker so I've been figuring it out. Obviously there are lots of technical differences, but the biggest docker pros i've noticed so far are: - You only need 1 VM image on your machine (maybe more depending), and all the docker containers run in there. Vagrant always needs 1 image per project, so if you're working on lots of projects at once, docker can save you a lot of drive space + ram/cpu if you're running them concurrently. - If you're using a vagrant image, it doesn't help you much with deployment. Your vagrant file doesn't really translate into a hosting/cloud environment at all. Your local docker file can pretty easily be tweaked into a deployment ready one you can run in production. One thing that's been a bit of a bummer about docker so far, but I'm getting used to it, is you can't just ssh into a container and goof around. It doesn't work that way, you have to issue commands to it from your host machine.
Personally, from a development point of view, I find Vagrant easier to work with. In a single VM I can have a provisioning script that installs all the required dependencies and all configuration requirements. Having everything in one box makes everything super simple to access and work with. For many projects I use Docker in production, that's where it makes most sense, to compartmentalise a Linux box to better use it's utilisation but still keep all the pieces separate (i.e. rather than e.g. having a web server and database server on a single box). Now, some people are overly concerned (or fixated?) on performance. IF you develop on a Linux machine, i.e. you can run Docker as a development environment on Linux, it will be faster since there is no virtualisation overhead since Docker will run on the host kernel. If you run any other OS as the host, Docker will be visualised (just like Vagrant) and it will just be more "difficult" since you probably end up with more moving parts. Try both. See what you like best. 
Unfortunately not. You can add relationship in one go if you have the id's. But it is food for thought, that might be something to work on.
This is for when you deal with old Java. For PHP you aim for industrial spirit (90%+ alco) filtered* through bread. Nothing else will wash that taste, nor will let you forget about exquisite new stuff in modern php. ;) *filtering is only needed cause industrial alco is tax free so poison is added to "prevent" normal consumption.
Scaling for one, using separate containers makes it easy to scale from one to multiple. Also updates to containers are much easier to pull. Or simply changing php version, update the tag you want and restart. Binding the same host folder to multiple containers is very easy, much easier than keeping your dockerfile up-to-date. 
It's been brought up before, but not pushed for as much. Also I feel like things are going well. It's the frontends and business that are changing their minds. Anyway, I don't want this post to be just about me :P
* Registers globals can be simulated. * Yes. But there may be some good tools that do conversion automatically. Basically extra () will work on 5 &amp; 7 and provide clear disambiguation and preserve meaning * Why, of course empty array already reserve space for 8 elements... (SPL libs are no better. Look for 3rd party data structure libs to alleviate this issue) * Didn't worked much with older MySQLs (thankfully). * You may be able to write some simple AST based tool to autoconvert - dunno if that's worth it at all though
You can start bash with one of those commands, and then you're in and can "goof around" docker exec -i -t CONTAINERID /bin/bash
Thanks a lot for your comment. That point about ssh is a bit of a let down for sure, but the benefits you mentioned are really interesting. We have multiple VMs for sure, i was the one who introduced this type of development to the company where I work and the main reason was to help new people run projects locally that maybe weren't linux users , or just new to it and keep things simple and in sync. I'm probably being a little lazy and need to put some time on it, reproduce a couple projects we have on docker and see whats the outcome. Cheers!
It's just the usual medium "between jobs" announcement. Content doesn't really matter.
is it feasible to set your ci up so a pull request can be used to create an api end point ? i.e. pr-123.this-is-a-bad-idea.api.example.com ?
Thanks for your point of view, as i said before i need to put some time on it, reproduce a couple projects/things we use and compare. But the specifics you mentioned are really interesting. Cheers
Ah, sweet, hadn't seen that before
There were many changes in WSL in Fall creators update or such recent update with support for Fedora and such. I didn't experience any performance issues even on a 5400 rpm HDD. It looks like Windows processes can take over any port in WSL. If you have WSL Apache using port 443, a process started from Windows on same port can take over the same port (at least from my experience). On the other hand, WSL Apache would fail with an error if a Windows process is already listening to 443.
I have honestly never used Laravel beyond a simple "Hello World" I did a while ago and had either not seen or not used this feature. I know symfony can do something similar with the `Controller#get()` method, but isn't using a service locator like this generally discouraged? Wouldn't it be better to use DI instead, especially now that Symfony allows such simple autowiring of services?
This is where I'm at too. Platform-specific edge cases are pretty rare, and if you define all the requirements in composer.json (`ext-curl`, `ext-bz2`, etc), composer should bail out early before you pull your hair out. I sure miss the whole PECL department and easy updates though. 
Something that may be of interest for newcomers (on Windows): There is **Docker for Windows** which uses Hyper-V as the hypervisor. This is the newer, preferred option but it has one big drawback: When Hyper-V is enabled you can no longer use VirtualBox on the same machine. If you need to use Vagrant alongside Docker you need to install **Docker Toolbox for Windows**. Docker Toolbox will set up a boot2docker VM using VirtualBox to run the Docker Daemon on. By default only `C:\Users` is mounted to that VM so easiest is to move your workspace somewhere on that path. Otherwise Docker mount binds won't really work they way you'd hope for.
Docker runs natively on Windows too. The only downside is that you need to activate Hyper-V, and you can't use virtualbox when Hyper-V is active... so if you need virtualbox/Vagrant for some projects and docker for others you'll need to virtualize docker.
Advice from a senior dev who worked with vagrant for years before swapping over to docker this past year: make the change. There are **a lot** of tutorials and sample `Dockerfile` projects that can help you get going. Spend 2-3 nights messing around and reading docs. That's all you'll need to replace your vagrant setup. Learn about making a [`docker-compose.yml` file](https://docs.docker.com/compose/compose-file/). Understand that you can [use environment vars in your compose file](https://docs.docker.com/compose/environment-variables/). If you're on Mac, use Docker Edge (beta) instead of their latest stable version. Make sure you have [the `:cached` flag set on your mounted volumes](https://docs.docker.com/compose/compose-file/#caching-options-for-volume-mounts-docker-for-mac). Mount your database container's storage to your local filesystem so your database isn't wiped whenever you rebuild your containers. Something like this in your `docker-compose.yml` will do. This expects you to have a `docker/storage/` directory in your project. ``` mysql: image: mariadb:latest volumes: - ./docker/storage/mysql:/var/lib/mysql:cached # other options... ``` Once you have your basic setup in place you'll never look back. It's way faster than vagrant to boot up, takes up way less space if you work on multiple projects, and in my experience has been much less prone to errors/problems than vagrant.
Maybe just start creating API earlier? Create time gap (two weeks/sprints or more) between backend and frontend team. That way, when frontend team join project they already have API to work with, so they don't rush backend team.
Ah, yes in that case it’s irrelevant. I was going off the assumption we’re on a Docker build with matching distros, software versions, etc.
Sorry missing your questions. See [php-manual on foreach](http://php.net/manual/en/control-structures.foreach.php). There was a dedicated post explaining the new foreach behavior, but I can't find it anymore.
Almost there, but falling at the last hurdle. Docker is still advantageous on Windows / macOS for a couple of reasons: * While you do still need a VM, you only need one VM. Scale it's resources as you need. * While that VM still needs to be created, it's much more of a one-off than with Vagrant. You use that VM for _all_ of your Docker-related tasks. Switch projects with Vagrant? Better power down that|those VM(s) and start up the other ones - enjoy the wait. Also, that Docker VM is _light_, VERY light. If you use Docker Machine then the whole OS fits in a tiny bit of memory. If you use Docker for Windows / Mac, then it's the same concept, but with tighter integration into the OS (that varies between the two). * Docker has a huge community that's much more active these days than Vagrant's - meaning you can fire up many well-known pieces of software that have official images with very minimal configuration to get going. Would I rather configure a VM, or instead run an already built image where the startup time is either the download time for the image, or practically instant thereafter. * Finally, you can get _closer_ to production-like with Docker if you're using Docker in production. If you're running Docker in production, and a VM locally, there's going to be quite a big difference between the two environments. I've not missed having to use Vagrant **at all**, not a single thing about it. I stopped using it in favour of Docker maybe 2 or 3 years ago now. I still have old Vagrant environments on my GitHub from old projects, and I do no miss downloading OS images, waiting for a VM or 2, or 3 to start; waiting for Ansible to finish provisioning, etc. You skip so much wasted time and effort, and more often than not end up using fewer resources at the end of it in the 1 VM you end up using. Docker Compose is also a dream for local developer environments!
Or a shorter version: $ docker exec -it &lt;CONTAINER_ID&gt; bash Or if the image doesn't have bash (you may find you get a bit of a cryptic error message if it doesn't), a lot of images will have at least `sh`: $ docker exec -it &lt;CONTAINER_ID&gt; sh
Frankly; Vagrant _is_ old news. It's useful if you _need_ a VM (I can understand people still work with legacy applications where using Docker is not realistic, etc.), but otherwise you're just giving yourself disadvantages. Make sure you check the replies to other commentors here, some good points have already been made, including things like how you "SSH" (but don't really _SSH_) into a container.
Someone else mentioned it, but having an environment per-feature branch (if you use them) can be very useful. It's not always trivial to set up of course. Another thing may be to try split things up a little more in your system. It sounds almost like you have a monolith and you're scared about a change in one place breaking another place. This is one area where using multiple smaller (dare I say, micro) services _can_ make sense. You'd be able to ensure boundaries between services, and minimise the impact of bugs. You may also find you can develop more confidently. It does however introduce some more complexity into many areas of your application too.
This used to be a feature and was removed on purpose for good reason.
You stop it.
From RFC: &gt; The requirement that the reference is marked at both the definition- and call-site makes this feature different from the call-site pass-by-reference that was used in PHP 4. 
&gt; Wouldn't it be better to use DI instead, especially now that Symfony allows such simple autowiring of services? Definitely. The only time I get the container and get services from there is when I start writing the service/controller/etc and I'm not sure all the dependencies I'll need. When I'm finished, I'll properly inject them. Not only is it good practice, it makes mocking and testing so much easier.
Dummy API would be my route, once requirements have been agreed you define the API spec and then allow them to work off that. As requirements change, then so does the API spec and hen you can slowly introduce the real endpoints as they're merged. Depending on how they approach things they can either manage their own dummy server via something like https://github.com/typicode/json-server or you could maintain a simple fake service that does not but dump out example data. It's hard to align these things, but I agree with you that the API should be keen more thought but it has to be balanced with business needs. Sometimes you do have to give in and ship what you've got to shut them up, but I always get sign-off on anything I don't feel is ready for production so that it can be raised at the next sprint as being rushed. 
What if the referenced value is a reference to another value? Do you get passed the reference pointer value, or the value the pointer references?
&gt; Global service location, call any function in the view, no need to define fields in models wooooo we're writing code at 100mph! I'm glad you get it too. And this is why I'm not a fan of Laravel. You don't have to do it that way, but it's the recommended way in the documentation. Yes it speeds up development, but it makes debugging much harder and creates tons of technical debt. Maybe I don't bang out sites for clients that I'll never touch or care about again, in which case I might choose Laravel and do some of these bad practices. I have to make scalable and maintainable systems that are constantly updated and often times have to have to have features migrated to microservices.
What's the overall opinion on grouping classes by feature as opposed to by their functionality / type? For example; \MyApp\ShoppingCart\Model (ShoppingCart model) \MyApp\ShoppingCart\ProductModel (relation between a ShoppingCart and a Basket) \MyApp\ShoppingCart\Mapper \MyApp\ShoppingCart\Controller \MyApp\ShoppingCart\Services\... \MyApp\Product\Model (Product model) \MyApp\Product\ImageModel (image on a product model) \MyApp\Product\Mapper \MyApp\Product\Controller \MyApp\Product\Services\... I've currently got something like this; \MyApp\Controllers\ShoppingCart \MyApp\Controllers\Product \MyApp\Models\ShoppingCart \MyApp\Models\ShoppingCartProduct \MyApp\Models\Product \MyApp\Models\ProductImage \MyApp\Mappers\ShoppingCart \MyApp\Mappers\Product \MyApp\Services\... Or is there another better way of laying these out?
You can also specify a "container_name" property in your docker-compose file and do it like: docker exec -i -t myproject-php /bin/bash
And to add to that, a container will always have a name. You can use either the name or ID, both which you can find with `$ docker ps`
Laradock.io even if it seems is only for laravel, any php project should work out of the box. Supports nginx, apache, redis, mysql, postgresql and a lot more.
Nice, well worth the $20.
Also just doesn't seem to know Symfony or Twig that well. Twig [also has verbatim](https://twig.symfony.com/doc/2.x/tags/verbatim.html) tags. Also, you can configure Angular to not use braces. if you're going to compare two things, at least make sure you know enough about both to be able to actually compare them
From what I gathered, the keyword word is “Explicit”. This RFC does not propose to alter the existing pass-by-reference behaviour but rather allow a parameter to be explicitly denoted as being passed by reference at the call-site via the ‘&amp;’ prefix, it seems to be about enhancing code readability and offering more opportunities for static analysis. 
What the hell did I just start to read?
I think most of the posts here are missing something and that is that Vagrant is for provisioning - what it provisions can be docker or a traditional VM - just take a look at their website. So, in theory, you could keep using vagrant but just with a docker backend. That said if you're going to provision a docker environment using vagrant you might as well learn to use dockers provisioning tools, dockerfiles for building images, dockercompose files for a one off collection of services (an image, like a Virtualbox VM but not quite, for your database and an image for your code to run in, all wrapped up and ran at the same time) or go whole hog and create a swarm, a scalable dockercompose file which runs over a single or multiple machines and that's where the real beauty of docker comes in. Your infrastructure, everything you need to run your code, lives in code; spin it up, tear it down, duplicate it, tweak it, track it in source control - and then once you're happy? Push it to a docker swarm supported host and scale it to run on 10's or 100's of servers, whatever your application requires. That means when a new dev joins your team they have the development environment for your code. You add or remove a dependency? Push the changes and have all your fellow developers update, simple, easy. I've found static development environments to be the exact opposite. Invest the time you won't be disappointed.