&gt; what do you mean when you say "external" opinion? Non-member opinion. &gt; In fairness, that sentiment may well apply to every side in a debate. We aren't talking about an arbitrary reddit debate with no repercussions here. These are pretty public and important standards recommendations processes that end up affecting the day-to-day lives of a very large portion of the community. That kind of stubborn, defensive, closed-minded position has no place in those processes IMHO (or any professional setting, really).
Ah, the "it's just a couple of lines of code" argument we all know and love. Well, those could be 5 very important lines of code, so the debate is worth it, in my opinion. Not 6 months, mind you.
Any kind of exception handling would overwrite the body, so while this is technically true it would very likely never be a common problem.
Nothing wrong with that. I read Anthony's concern as being specific to exceptions or other runtime errors. Errors that are non-transient probably aren't a concern. I would defer to u/ircmaxwell for clarification on this point.
Seems like my comments about dependency inversion are the most misunderstood. Probably a case of being so close to the thing that what seems obvious to me will not be obvious to others. Based on your comments and others, I will write a follow up post that specifically addresses the DI problem.
&gt; Your primary point - that this signature avoids coupling to a specific implementation - was already addressed in his article His theories on this point are actually not enforceable, if you choose to think them through. You cannot enforce return types in PHP &lt; 7, and you cannot enforce constructors. Neither of his proposed solutions are actually better than a straight forward type hint. I guess I need to write another blog post to spell this out. &gt; we all think factories are the devil or something? Really? I never said factories are bad, I said something that is generally held to be true amongst advocates of dependency inversion: the best kind of inversion is the kind that requires no extra code.
Not the best choice I've ever made. Should have remembered why I unsubscribed from the group months ago.
It's more about responses being modified before the type of response it actually known. In the straight forward case this is not an issue. A simple change to the interface would make this entire situation impossible. 
Honestly I can't understand how this is not the common opinion ( or maybe it is, but we have a case of loud minority ). There should never be any reason to modify a response, before the call of $next(); For me there are 2 flows a midleware should follow: 1: Normal request? Cool continue the chain, and with the result of the chain ( Response ) do something cool (optional) and return it back. 2: Something wrong / special case of request? Then no need to continue up the chain and return the appropriate response for that special case. IMO a response object should not be even generated at all before the path takes 180 from Request to Response. So either the APP (which is kinda like the most inner middleware ), or the middlware where we decide we shouldn't go any more inside the chain.
Can you be more specific about what the possible problem would be? Body content is the only thing I am aware of that is a real cause for concern, but that is a specific edge case.
Much appreciated! Two more questions. 1) Do you know of any way to semi-securely do it *without* a browser plugin/dedicated app? The website is not meant for technically literate people but still potentially sharing personal information they do not want known. I was aiming for something user friendly but still secure enough that if the database/file system was leaked (but not compromised for a long period of time) the data would still be secure. Requiring a browser plugin (desktops) or custom applications (mobile) is very anti-user. &gt; Public keys need to be pinned and logged in a publicly auditable append-only data structure (example). This is kind of two questions. First, is there any specific example of this? I imagine it is built into the CMS and I could go through that and find out, but if there's a direct example of Keyggdrasil that'd be awesome (such as source code.) The second being, do you know how scalable it is? Essentially how feasible it is to use something like Keyggdrasil with 5m keys.
&gt; 1) Do you know of any way to semi-securely do it without a browser plugin/dedicated app? [Short answer: No](https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/). If you implement this, don't ever call it (even semi-)secure, because you will draw the ire of the security community when they realize you're delivering JavaScript cryptography code to the end user (because how easy it would be to do a targeted attack that steals their key). But feel free to implement it anyway, if it solves your use-case of preventing file/database data from being easily compromised. It's better than storing plaintext. &gt; First, is there any specific example of this? I imagine it is built into the CMS and I could go through that and find out, but if there's a direct example of Keyggdrasil that'd be awesome (such as source code.) It's still being developed as part of the CMS. The blog post explains the theory. If I develop a standalone implementation, it won't be until after we get the CMS launched. &gt; The second being, do you know how scalable it is? Essentially how feasible it is to use something like Keyggdrasil with 5m keys. 5 million key updates in under an hour? Probably would slow everything down until they were all processed. 5 million total? Not a problem.
About a month or 2 ago I've been added to a project that uses CI and that has convinced me to avoid it like the plague whenever I can. Symfony makes so much more sense. Also, it's likely you don't even need all of Symphony. A lot of my projects just use Silex and optionally twig. 
I'm not sure "everyone else is doing it" is evidence that it's the right solution, is it? Part of your argument seems to be that a huge number of other people are doing it your way, but that's not really evidence of correctness -- just evidence of popularity, which is a completely different thing. You know? Again, I don't necessarily have an opinion either way on this, but I haven't found your argument to particularly persuasive. That's just my outside perspective on this. I'm sorry you feel attacked. I don't see it that way, but I understand how it feels. Hope this gets resolved soon and we can focus on bigger, better problems. :)
If you like CI then Laravel is a better and more comparable choice than Symfony but I'd definitely say CI is an outdated and defunct framework that you should look at moving away from.
Ruby is old now, you 95 year old. The cool kids use Elixir-lang or JS. Update yo self. /s
The the return of a function with that code would be NULL because of a "unexpected &lt;" parse error What did I win?
&gt; How long do you reckon we should wait? Until there's a good reason. If a middleware wants to ensure the response doesn't change by the time the code flow returns to him, he can make a clone before handing it off to the next middleware. That's on him, not the other guys. But I reckon 98% of the time we really don't care if the response has been modified, that's the expected flow of events. We've got many 'builders' that already behave this way, like Laravel's query builder, and Carbon dates; you have to clone them if you don't want them to change on you. &gt; Who says you need 2+ fields to start cloning? I don't know what you're trying to say here. Whenever you call one of their `with*` methods it clones the whole thing. There's no way around that given the API. [ImmutableJS](https://facebook.github.io/immutable-js/#batching-mutations) OTOH has a section on "Batching Mutations" which lets you run multiple mutations at once without creating clones in between. &gt; If anything/anyone is able to steer the community in a different or better direction, that's a standard. The community is never ready when the first arrives. The problem is that this was decided by a small handful of people, and now a large amount of people are just going to just blindly accept it because they don't know any better, and after all the "standards" committee decided on it, so it must be good, right? Ergo it's a self-fulfilling prophecy.
This is not true though. If it were a god object, it wouldn't be delegating work to 20 other dependencies, it would be doing all that work itself. A complex application with a complex procedure, that is following the single responsibility principle, can very easily have a need to stitch together that procedure from that many separate dependencies. At that point people will start to advocate for some kind of command bus / domain event architecture whereby your controller only has one or two dependencies (issuing a command), and then several other operations listen for that command event and react accordingly. THAT said, I've found events to be *the absolute fastest way* to lose track of what the hell is going on in your application (even faster than straight-up procedural slop). You have to track down the command to see what event(s) are being fired in that command. Then you have to go into your config to see what listeners are bound to those event(s). If you're REALLY unlucky, you (or someone else) is using nested events, so now you have to go into each event listener to see what handler(s) are being called. You then have to go into each handler to see what other events are being emitted from the results of those handlers, and then rinse and repeat until the whole "procedure" is done. BUT WAIT, THERE'S MORE. Not all listeners will actually respond to all events. Since the event broadcaster includes some data context along with the event, you have to go into each listener/handler to see if it's actually responding to that context or not. So while 20 different listeners may be triggered, only a percentage of them may act on the data context. You couldn't design a more opaque data flow if you tried. Seriously, FUCK THE SHIT out of event-driven architecture. It is so not worth it. I would take a controller that pulls in a list of 30 dependencies, and then executes each step of that procedure in a clear, concise way. Then I can at least *read* what that exact procedure is step by step to know what's going on. It's much more transparent, even if it feels "gross" to have a controller coordinate that many delegates. If you find that the same procedure is needed in multiple places, wrap it up in a class so it can be re-used if needed.
&gt; In short, I think this was a really poorly thought-out response that you probably put together in a defensive state of mind. His rebuttal made me realize even more so how right Mr. Ferrara's assertions were. I would say he failed at all his motivations for writing it and it is best if he just deletes it now and replaces it with a *mea culpa*. In a few years, he will probably regret keeping it as it is now.
How the hell is **Dracony** still active in PHP-FIG after being exposed that his admittance to the Group was contingent on his own manipulation of package stats via botnets??! *THAT* is what I find incredible!
Ha, just a bad joke on my part. The Seahawks were hugely popular during the 2013-2014 season, and successful as well: they won the Super Bowl in 2014. In 2015, they rode on that wave of popularity and made it to the Super Bowl again in January 2015 (a success by any definition, even though they lost the game). But in the 2015-2016 season, they didn't do so well, and they lost both popularity and didn't have anywhere near the winning record they'd had for the previous 2 years, so... not as successful either. Anyway, bad joke on my part. ;) (Disclaimer: I'm a Seahawks fan.)
If your object is taking 20 dependencies and is just passing some to other objects then those other objects should have those dependencies injected instead. If your object is taking 20 dependencies and is actually using all of them it seems incredibly likely that it isnt following the SRP. Refactor into multiple objects and reduce the dependency count. Sure, sometimes an object needs a good number of dependencies to get its job done but that is pretty rare - most objects need only a few and so having a large number should be looked at with suspicion.
&gt; If your object is taking 20 dependencies and is just passing some to other objects then those other objects should have those dependencies injected instead That's not what I'm talking about, nor is it what OP is talking about.
&gt; This is not true though. If it were a god object, it wouldn't be delegating work to 20 other dependencies, it would be doing all that work itself. Actually no, you can call a god object any object that knows to much, not necessarily who does to much. &gt; A complex application with a complex procedure, that is following the single responsibility principle, can very easily have a need to stitch together that procedure from that many separate dependencies. The problem is not strictly about the number of dependencies, but if those dependencies are really indispensable or if they are there because of laziness and/or poor knowledge. &amp;nbsp; ex: In order to send an email, you need a Mailer which needs a source, destination, subject and body. - If you force that Mailer to fetch "destination" on its own, from database, it means that it knows to much (_i.e: it knows about the database_). - If you force your Mailer to check before sending if the "destination" can receive a newsletter, it means that it knows to much (_i.e: what is a "user", what is a "newsletter" and how to work with them_). 
Quoting the introduction paragraph: &gt; Searcher is a library completely decoupled from any framework created in order to simplify construction of complex searching queries basing on passed models (aka criteria), regardless of what do you want to search: rows in MySQL, documents in MongoDB or just files. It’s basic idea is to split each searching filter to separate classes. Supported PHP versions: &gt;=5.4, 7 and HHVM. I find it hard to read and understand. Maybe it would be useful to simplify it? Here is an example from what I've understood: &gt; Searcher is a framework-agnostic search query builder. Search queries are written using Criterias and can be run against MySQL, MongoDB or even files. Then the rest of the home page can get into the details.
Multithreading isn't something PHP was designed for. For WebSockets there exist libraries.
Yes
Productive+smart=good.
&gt; md5($salt . $password); Note that the **order** of concatenation matters! Putting the salt first can make it useless, because the attacker can simply feed the salt-bytes into the hash algorithm, save the *state*, and then use that as their new starting-point. The salt costs them nothing because they only need to handle it once, rather than re-handling it every new password attempt. Obviously that's still not enough to declare everything secure and go home, but it's worth remembering when you're looking for quick-wins in a crusty old codebase.
Is there a realistic threat of timing attacks against PHP scripts? Since the script is running on a remote server the measured time would depend on things like server load, latency etc. so i would think you couldn't spot a difference in string comparison or something like that?
i dont think anyone in 2016 is using md5 to hash passwords 
Do we really need a post about password_hash() every month ? It is as if there is some chainletter going on: if you read a post on password hashing, rewrite it and post it ob your blog.
Laravel is much slower than Symfony http://blog.a-way-out.net/blog/2015/03/27/php-framework-benchmark/
If only that were true. Unfortunately copy-paste blog-spam tutorials are rife, as are copy-paste programmers. Unfortunately, there's no DMCA equivalent for dangerously bad (programming) advice.
This is obviously a bug in [`WhoopsErrorHandler`](https://github.com/zendframework/zend-expressive/blob/29a6578fe3cc7cc0180ce146425955cab529e0b5/src/WhoopsErrorHandler.php#L83-L85) where `rewind()` needs to be called on the stream before writing the exception message. It doesn't mean the proposal is fundamentally broken.
If there's no error, then modifying the response is perfectly okay. For instance, setting the expected content type on the response during content negotiation is perfectly acceptable. Is the order of operations important? Probably. Is it wrong to do it? Not at all.
In part I'd say because CI doesn't use composer to grab it's dependancies and doesn't use a service container. Making a decent sized application I'd want both of these as eventually adding a third party component to CI, especially a large one, you need to add the source to your project directly, you have to manually build large lists of requirements to load them or build your own system in to dynamically load them which is reinventing the wheel completely. If your response is I'm not working with third party libraries or really require a service container because my app is super simple then my answer is, there's a lot of frameworks out there which are a lot more lightweight than CI. Either argument leads to you're using CI because it's the most comfortable for you which isn't wrong as such but you're either limiting your applications performance or you're making more work for yourself. As a guy who's worked with CI in a large scale production app I can easily say the framework has a lot of flaws and doesn't work majorly well.
I just brought it up because it seemed like the only argument op had against constructor injection was the build up of too many arguments. Except in rare cases, that is a sign that refactoring, breaking down, is needed. Events and listeners is a different thing, I won't comment on. 
Source? Pretty sure this would only be true if you md5 the salt and pass separately first and then together.
It actually seems like a good argument for making standard PSR-7 response/stream etc. factory interface.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
In example 1, can't you begin the transaction before adding the user and commit it after adding the product?
The point of a salt isn't to lengthen computation time but to make it resistant to rainbow tables. Typically, if you want to increase computation time, you just increase the number of times you hash it. But I suppose it's a marginal benefit, regardless.
im on my phone so i cant see the code properly but is the key always going to be 0? You can try using foreach too loop through it. Foreg foreach($result as key as $value) { If $key == 0 Echo $value['lat'] You get the idea right? 
Looks right to me, what error are you getting? What are the contents of $lon and $lat? You can use var_dump to see that.
When you get a problem like this, keep var_dumping down one level at a time until you find your problem. Make sure error reporting and warnings are on so you can see when you are trying to access a key on a null object. It looks right to me. Maybe you aren't getting successful JSON back. Again, keep var dumping at different points in the code.
Looks like an object. $results[0]-&gt;lat 
That was my take as well, which [I have just proposed to FIG](https://groups.google.com/forum/#!topic/php-fig/G5pgQfQ9fpA), though once again Rasmus is a step ahead and has already defined [a possible factory interface](https://bitbucket.org/mindplaydk/psr-middleware/src/5688dc2f42d5b9eefcacf2fbc39f140b50a14112/psr-7-factory/FactoryInterface.php).
Thanks for the suggestions... Like you guys said, turns out the code was correct but the url request was wrong... changed $url = "http://nominatim.openstreetmap.org/search?postalcode={$address}&amp;format=json"; to $url = "http://nominatim.openstreetmap.org/search?q={$address}&amp;format=json&amp;limit=1"; and that did the trick! 
Does PHP 7.1 have a timeline? I'm seeing a lot of cool RFC's, but I have no idea how to follow 7.1's development like I was able to with 7.0.
Content type is a property of the request. Middleware shoudl not set content type on the response **unless** it is actively formatting the response, and hence is sure it is that format. Using the response to change logic downstream in the application is weird at best. It is an inversion of logic that is finally backwards 
PHPFox still uses MD5. WordPress uses multi-pass MD5. Piwik uses MD5.
`md5($salt . $password)` is also the ideal setup for a length-extension attack.
It's only an object if you don't pass true as the second parameter to `json_decode`.
Just use [**HackLang**](http://hacklang.org/). It already has [this feature](https://docs.hhvm.com/hack/types/type-system) and MANY more. Collections are **wonderful**!!!
&gt; it makes me feel terrible at security to read such processes. I Understand trade-offs are a part of everything; but it seems like the more robust the security, the less time and $ IT has to spend on everything else like NPD, QA, etc. It's also a question of threat modelling. You, a random person, shouldn't have to worry about the NSA or KGB. A large company like Google or Yahoo should. They should take these drastic measures, you shouldn't have to.
`s/let/var/` It's already reserved \^_\^
Always we ask this question, witch framework is the best? it's not the framework it self, its about your projects needs and about the future plugins and the complexity, and how much you can go deep making development. Good practice is Symfony where U'll have Laravel between you hand.
Most "single call" methods (`$hash=go($data);`) are shortcuts for something like: function go($data){ $h = new Hasher() $chunks = $h-&gt;split($data); foreach($chunks as $chunk){ $h-&gt;setInput($chunk); $h-&gt;doComplicatedDance(); } return $h-&gt;getOutput(); // All other state in $h is discarded } Depending on the size of what you're hashing, certain non-secret-prefixes may be especially bad, since they'd land right on the natural "checkpoint" in the algorithm. Leaving aside the complexity of chunk-boundaries for a moment, consider a hacker's attempt of: function break($prefix_data, $target_hash){ $h = new Hasher() $chunks = $h-&gt;split($prefix_data); foreach($chunks as $chunk){ $h-&gt;setInput($chunk); $h-&gt;doComplicatedDance(); } $checkpoint = $h-&gt;exportAllState(); while($h-&gt;getOutput() != $target_hash){ $h-&gt;importAllState($checkpoint); $chunks = getBruteForceChunks(); foreach($chunks as $chunk){ $h-&gt;setInput($chunk); $h-&gt;doComplicatedDance(); } } return $chunks; // Found password! } Notice that once you have `$checkpoint` you can also farm out the remaining attempts in parallel, since it's just a fixed piece of data describing the starting-state of the hasher.
May be a simple language omission, but seems like common error: MD5, SHA1 and such are not *encryption* algorithms and as such cannot be *decrypted*. They are one-way hashing algorithms that can be *broken* only when someone guesses the input, or finds a flaw in the algorithm, or its implementation, or when attacker has enough computing power to brute-force the input to find a collision.
It's situationally an antipattern. The way it's presented here is alright, since it's serving it's actual purpose - locating services. But when you see this: class Frob { function __construct(Locator $locator) { $this-&gt;foo = $locator-&gt;get('foo'); $this-&gt;baz = $locator-&gt;get('baz'); } } That's when it's an antipattern because it's being used as a poor man's IOC container. It's also causing frob to lie about it's dependencies. Really, the service locator/registry/whatever is one of the better approaches for building an IOC Container. You just have to use it the right way. 
I'm fairly certain Wordpress still uses md5. 
&gt; You have to add an autoloader to your code base. &gt; Also, please you use phpdoc instead of // &gt; Don't use @ &gt; Use namespaces. &gt; I think Error class should be at different folder. I guess you influenced by CodeIgniter. I saw some similarities with CI. But it is not bad if we consider your PHP history. Keep up! :)
Yeah I doubt I will see any performance difference. I will try and move all Classes to Arrays and see if the complexity is reduced enough.
It's one of many CMSes that do, yes. We use a MU plugin that converts everything over to password_hash on all of our client sites, though. 
I already red about using autoloader to locate classes instead the multiple requires and includes. I will try to improve that, but i have to understand that. I am reading the docu at [php.net](http://php.net/manual/en/language.oop5.autoload.php). There are also some libs ready to use for such things. Right? Yeah my commenting and docu style is not the best... Yeah I need to improve some parts of the code, regarding to error handling, but right now this was the fastest solution. I should implement something wich allows errors in dev mode, but not in production. Where do you think the error class should be? Thanks :)
No way, codeIgniter is like 2008-2012, moving forward from there was many other good frameworks.
Recommend anything but code igniter please sir. As much as you used to love it, it forces you into really nasty workflow.
And yet someone shows up regularly doing just that. And yes, md5($salt . $password) is still "just using MD5".
I believe one of the reasons they haven't moved away from md5 is for backwards compatibility. I may be wrong, but I believe Wordpress currently support back to php 5.0, and they plan on maintaining that compatibility for a while. 
PHP is slowly turning into Java, but without the type safety. 
adding new column to users table or extending it/whatever would be enough, or literally anything could be enough, its damn easy to convert while keeping compatibility. keeping md5 hashes just because backward-compatibility sounds like disaster
so what about deprecated mysql. what about escaping sql data instead using prepared statements. /u/dracony is right (btw is this a guy from /r/quityourbullshit who faked downloads and stuff?)
Yes, best to talk about it as it really is -- warts and all. ;-)
Dude, you're not helping yourself. Seriously - just don't reply. I've not commented once on all of this drama - because simply put, it's toxic and it's a waste of energy for everyone concerned. Although I didn't comment, I did read Andrew's article - and I did read your argument on the FIG mailing list. Let's get some perspective: you got caught out doing something stupid, it's not the end of the world - *what's done is done*. **What matters is how you handle that**, and making smart-ass comments probably isn't the best way to help endear you to a community that you actively tried to deceive. You've understandably pissed a few people off. It's now time to acknowledge that, maybe even apologise and then just ignore those comments until they stop: and they will stop. You're really not in a position to be fanning the flames though.
which is cool because the body is the part the user never see or cares about... right?
I really like the look of Hoa, *really* like it. There's a real problem though: documentation. I mean, the Irc module is pretty good in that it has this disclaimer: &gt; Unfortunately, the documentation of this library has not been written yet. Which is *ok*, as the README file is pretty useful with some good examples in it. But then there's the likes of `Notification`, `Memory`, `Xmlrpc`, `Tree`... and many more, and they aren't even clickable URL's on the site. I can't even see the repositories, let alone what they're supposed to do! If there was some basic documentation at the least, I'm sure people would feel more inclined to use those packages and contribute documentation themselves? I know I would. It would be a shame for the project to be let down by the lack of documentation, especially as it looks very very useful.
Nice work! I've given it a quick browse, nothing too thorough - but I genuinely think you've done well considering it was October where you began to look a little closer at frameworks and design patterns. Like /u/adililhan says - there's definitely a CodeIgniter vibe to it, with the layout and how URLs are mapped to controllers. I would say the two things I noticed were: &gt; - Closing `?&gt;` tags &gt; - Lack of Autoloader With this in mind, if I were you I'd: 1. Remove the closing `?&gt;` tags, it's not a huge deal but can be painful if you accidentally add whitespace after them. 2. Grab [composer](https://getcomposer.org/) - this will make your life easier, meaning you can remove `include`/`require` statements, 3. Namespace your classes, with Composer this allows autoloading to work and means you can use other peoples libraries to bolster your framework. If you do these three things then you've got quite a good foundation to build upon. Keep it up though, having a project like this can be an awesome learning experience!
[I refer to this Reddit comment every time I'm writing some PHP password having functions](https://www.reddit.com/r/PHP/comments/3wrlsv/is_password_hash_and_password_verify_all_you_need/cxylz5s).
Sadly yes. That's one of over a dozen reasons why I'm [building my own CMS](https://paragonie.com/project/airship).
Hello and thanks. We are aware of this issue and... we are working on it. Quality and documentation are our top priorities. Thank you for your feedback, it helps :-)!
 $action = function ($rq, $rs, $next = null) { $response-&gt;getBody()-&gt;write('Transaction successfull'); $response = $response-&gt;withHeader('Content-Type', 'application/json'); throw new \Exception('DB Exception'); return $response; } Even if the server receives a status code 500, the end user will believe the transaction was successful.
Actually it shouldn't even be that hard... I don't use or like wordpress but increasing the column length, adding the compat_password library and then changing the login function/method should cover backwards compatability with the exception of extensions who do their own password mangling. Check the PHP version. &gt;5.5? Don't use the compat library, use built in. If its &lt;5.5 and &gt;5.37 then use compat. Less than 5.3.7? Fall back to shitty md5. It should literally only break modules. I imagine (hope) the rest of the core would go through a standardized method for accessing and verifying the password.
Totally read that as "php-ass" at first glance...
It's actually 2^8 passes, not that that makes much of a difference. And they do use modular crypt format for storing password hashes, so switching to a better hashing algorithm won't be breaking backward compatibility. From reading the code it looks like that even just upping the default iteration count to 2^20-30 would be is a single line change. I guess it's just not a priority for them.
phpass adjusts the cost for portable hashes: *1 &lt;&lt; $count_log2* (8192 rounds of MD5). Yet to be seen when they decide to default to bcrypt..
Didn't look much, but i noticed something in Session.php. Some people suggested you not to supress errors a.k.a @, and they are right, listen to them. In you case here : public static function init() { @session_start(); } much better approach is to check is session started, if not, then start it, for example like this: if (session_status() == PHP_SESSION_NONE) { session_start(); } Also following this example your destroy() method should be dependant on session_start()
The inspections help a little. I have one small API that passes 100% inspections, so whenever I move around something and refactor I run inspections afterward to check if I missed anything. PHPStorm fails to change class names in DI configuration, but it sure does warn about invalid ones after the refactoring.
Are these libraries implementing an OAuth 2 server or an OAuth 2 client? It isn't obvious from the READMEs
I just wanted to mention this, here on Reddit when asked why he didn't discuss things directly on the FIG mailing list, /u/ircmaxell said: &gt; On the mailing list, discussion points and arguments tend to get "buried". Simply look at Ross Tuck's points in that thread. They got buried and never addressed again. One of the points he was talking about was when Ross raised this 4 days ago: &gt; Slightly different topic: A good point was raised on Reddit about how (without depending on an implementation) a middleware can't create a new Stream and thus replace the body. /u/shadowhand responded to that point with: &gt; Please, let's not confuse the discussion about a middleware interface further by talking about streams and URIs. Two days later and a couple of blog posts and things are all a lot clearer for everyone.
Perhaps the comment language is irrelevant? And you should take you sjw crap elsewhere. Programming is the field of logic and math. Albiet we require the use of language to some extent, it is not what defines the work.
 public class ParseLatitudeLng { public static JSONObject getLocationInfo(String address) { StringBuilder stringBuilder = new StringBuilder(); try { address = address.replaceAll(" ","%20"); HttpPost httppost = new HttpPost("http://maps.google.com/maps/api/geocode/json?address=" + address + "&amp;sensor=false"); HttpClient client = new DefaultHttpClient(); HttpResponse response; stringBuilder = new StringBuilder(); response = client.execute(httppost); HttpEntity entity = response.getEntity(); InputStream stream = entity.getContent(); int b; while ((b = stream.read()) != -1) { stringBuilder.append((char) b); } } catch (ClientProtocolException e) { } catch (IOException e) { } JSONObject jsonObject = new JSONObject(); try { jsonObject = new JSONObject(stringBuilder.toString()); } catch (JSONException e) { // TODO Auto-generated catch block e.printStackTrace(); } return jsonObject; } } /********Get LAtitude &amp; Longitude From Address*********/ public class GetLatLngAsyncTask extends AsyncTask&lt;ArrayList&lt;String&gt;, Void, String&gt;{ JSONObject jObject; JSONObject places = null; String lat; protected void onPreExecute() { } @Override protected String doInBackground(ArrayList&lt;String&gt;... params) { //ParseLatitudeLng placeJsonParser = new ParseLatitudeLng(); ArrayList&lt;String&gt; inSync=params[0]; double lng1 = 0,lat1 = 0; try{ lng1=lat1=0; places = ParseLatitudeLng.getLocationInfo(YOUR_ADDRESS); lng1 = ((JSONArray)places.get("results")).getJSONObject(0) .getJSONObject("geometry").getJSONObject("location") .getDouble("lng"); lat1 = ((JSONArray)places.get("results")).getJSONObject(0) .getJSONObject("geometry").getJSONObject("location") .getDouble("lat"); }catch(Exception e){ Log.d("Exception",e.toString()); } return lat; } @Override protected void onPostExecute(String result) { // TODO Auto-generated method stub super.onPostExecute(result); } } Call Asynctask for getting latitude &amp; longitude
~~$count_log2 is [8 by default](https://core.trac.wordpress.org/browser/tags/4.5.2/src/wp-includes/pluggable.php#L2011), so `1 &lt;&lt; $count_log2` is 256.~~ EDIT: Actually, you are right, [it's adjusted to 13](https://core.trac.wordpress.org/browser/tags/4.5.2/src/wp-includes/class-phpass.php#L114). EDIT2: The developers sure chose a weird location for the adjustment.
Yeah, people hate when someone kills the laravel hype. Go Phalcon &lt;3, specially the new version. And I can't wait for a more stable version for PHP7.
Definitely server, I'll update the README's as soon as I can. Thanks for the feedback
All of the examples for `league/oauth2-server` are Slim based as well, e.g. password grant https://github.com/thephpleague/oauth2-server/blob/master/examples/public/password.php
&gt; Perhaps the comment language is irrelevant? Perhaps you should finish reading the article? That's exactly where the author ends up. &gt; And you should take you sjw crap elsewhere. Ha! You're hilarious. [Read this](http://paul-m-jones.com/archives/6214) and call me an SJW again -- if you can.
Holy shit. I thought this would be another ugly-ass starter project. But this has 900+ commits, all by the same person. Code looks neat too. Starred already. Good job.
Without using forms to post or links with it as a get variable, I can't think of a way other than sessions 
Hidden form field? Just as insecure as any other option, but with some sort of encryption these options (cookie, post, get) could be "safer", as in decrypting the input and see if it makes sense in some way.
if i used session..i cant send multiple sessions...soo 
Hey! Thanks, About 900+ commits, Now I understand that it's rly hard quest to create dynamic analyzer :)
Just an FYI, I tend to view "Manager" class names as a bit of an antipattern. The term "Manager" is so non-specific it conveys almost no information about what your class actually does, it might as well be called "UserStuffDoer"
I don't understand what you mean by "multiple" sessions? Could you try and explain, maybe give an example of the issue?
Why do you feel you need multiple sessions? What's the particular use case or feature you're trying to implement?
I added a small issue for new analyzer request with a small description about it and ping you, thanks
okay then ..i will write code.. in first page &lt;form method='POST' action='info.php'&gt;&lt;input style='border:none;color:14ae07;' type='submit' value='any' name='in'&gt;&lt;/form&gt; in second page.. $ip=$_POST['in']; echo $ip; when i refresh second page ...index 'in' error will appear...
and can i hold the data in $ip...even i refresh the page...if yes then how can i?? 
I read the article. He concludes no such thing. He is simply veiled in his attempt not to be a prude. And for all his claims of being focused on the task. And that objective problemsolving is the way to go, he then adds "open source is the only path for a professional" Such utter bollocks. There is gold in some areas of open source true. But there is also shit. So much shit. And treating it as gold when it clearly stinks just makes a small problem bigger. Quality code is not inherent to the environment or programmer. Its time, effort and skill. Always, without exception. And that is not his conclusion. Agreed he has some good points in between, but he draws false conclusions. Not a good article, trips over itself. Feels like the point wasn't thought through to the end. 
can i do without using session or cookie??.. 
can i do without using session or cookie??.. 
No.
ive never actually got this excited about an rfc passing
I much prefer laravel. which is built on top of symfony.
I run into the same issue, to be fair. If I'm out of all other options, I tend to go with a name like "UserCrudService", even though it barely feels any better than "UserManager".
&gt; But whatever, some of us can separate "technical" talk from "political" talk. I wish we all could. 
Great catch on the slim helper methods. I'll make that change ASAP. Thanks for the great feedback.
This problem has always bothered me. It seems like using methods that aren't on a typehinted interface should be prevented at the language level. As in, the API of the incoming variable should be restricted to that of the type that was hinted, and you should get errors like "such and such method does not exist on FooInterface" even if the methods exist on the implementing class.
I've only had a chance to skim this, but it looks like it fills the biggest gap we currently have with the `callable` type hint. For those who like to heavily use type information, exposing potential errors even earlier in the program is always a huge benefit, and this paves the way for a static analysis tool to handle nearly all possible type information before runtime. 
No PHP7 experience?
thank you ..syswizard...i got what i expected
Yeah, there's absolutely nothing on the main PHP site sadly.
Isn't an IDE already analyzing my code and helps me to make it as efficient as possible at many points? (thinking about e.g. PHPStorm)
Type declarations in PHP are non-nullable by default.
I have to make an e-commerce website in PHP that is super big : multilingual, different prices and stock depending on the country, etc. It's a very long project. What tools would you use to improve your productivity ? CMSes like prestashop are a pain to use because there are many customized things that prestashop won't do out of the box and it's a pain to extend so I probably ruled that out. We used it for some small sites and it's already a pain, so for a big project I think it's going to be worse than hell :) Usually for big projects like that I would just pick Symfony, but I am open to any suggestions. It seems that there are some [Sylius](http://sylius.org/) components that are nice for e-commerce, but the big red banner "Sylius is still in development" is pushing me off. Does anyone have any experience with that ? Are there any cool libraries / components I can use ? I know it seems like a question that is often asked, but I didn't find that much recent opinions about this, so I would love to hear suggestions
Must have when working with return types.
A good IDE would have caught it. That's what I get for using vim w/o proper plugins.
Hello, I use the PHP Annotations Plugin and Symfony Plugin together right now. It doesn't feel like a workaround at all. Actually you get autocomplete while type Annotations. Accepting the hints also ADDS the needed USE statements. 
So this adds some complexity to the function/method signature. In my opinion it would be much better to use interfaces instead, but provide easier way of using closures as interface implementations: [Functional interfaces](https://wiki.php.net/rfc/functional-interfaces) would be a much better solution of this kind of problems for me.
Thank you! Yeah I took a look at many frameworks before, it is definite inspired by some big players of PHP frameworks. I can remove every closing tags, I think this is not much work. I will to that as soon as possible. About the autoloader. I need to test out some different approaches, but I will try to implement this also because it is necessary. Thanks for the tip with composer. I will take a closer look on namespacing my classes.
Honestly I don't understand the question mark. We could just as easily have gone with union types instead, which would be more specific: `public function getItem(int $id): Item|null {}` We already have nullable types in param declaration: `public function setTime(int $time = null): TimeObject {}` Question mark just feels strange to me. `|` is already used in doc-comments, so it would make sense in code as well. **Edit** This is not a complaint, its just what I personally feel about it.
Ah true, stupid question =)
Hey, thanks for your feedback. I really appreciate it. I will try to create a config file. About the closing tags: I now use PHPStorm, which always tell me that the ?&gt; is redundant. But I will take care of it as soon as possible. I started studying php autoloader topics on stackoverflow, and on google results :) Why is it a no no to name a class like the php file? I did not really thought or worked lot with unit tests unitl now. So I have to study this in advance. Yeah I thought about a routing system and I will definitely create something for it.
Oh ;) right after I finish the PHP framework, okay?
because you would never call the PHP file: Something_Name it is always SomethingName. For example if you have a user controller in the controllers file: UserController is the standard name
Have you ever worked with a language where classes are called by a path rather than just a name? E. g. Java, where you have a full-fleged package path? It is a really nice starting point for your folder structures - think of packages, not folders. Things that logically belong together should go into the same folder/package. Packages that logically belong together should go into the same folder/package. Taking a look at existing frameworks (doesn't quite matter which language, as long as it has this) is a good step towards getting a feel for which type of division makes sense.
I'm not intimately involved, but I have been watching. ZF3 is real. In some ways, it's a big departure from ZF2, in other ways, it's very similar. The biggest change is that ZF is transitioning from a big monolith to a component framework. The various components have been moved to their own repositories, and are now versioned separately. A lot of work has gone into the core MVC stuff, reducing the number of dependencies for zend-mvc. zend-eventmanager got a big rewrite that is supposed to be much more performant. There have been a series of blog posts about the status of the ZF3 project, the most recent of which can be found here: http://framework.zend.com/blog/2016-04-21-zf3-update.html 
The question mark is also used in the swift language for optionals. So it might be influenced by that. The swift implementation is even better, but this is a nice step forward. 
Its just not a valid comparison. They are very different tools, for different audiences and different needs. That said for the people disparaging Codeigniter - it is one of the fastest and best performing php frameworks in production in 2016. Codeigniter 3 supports and runs on PHP 7. You can use namespaces, package managers, etc in your code. It is an active project and development is active on the next version Codeigniter 4. It is not backed by a person or company; it has a school BCIT behind it. Codeigniter is in use worldwide and has consistently been in the top 10 monthly trending PHP of github for years. And yes, its tough if the code in a project or at your work is weak or hard to develop with. But that is not codeigniter's fault. You can write very clean code with it. If you need different features then spare everyone the bile and pick up a different tool. But there are always tradeoffs involved. 
For me personally problems that these two solutions solve are completely orthogonal (Functional interfaces is for easy implementing single-method interfaces basically, while function prototypes are a necessary part of type safe function composition). With that in mind I really wish Functional interfaces could still pass voting...
https://core.trac.wordpress.org/ticket/21022 I made the same mistake, assuming it was standard phpass. Unfortunately, it's not. Here's what happens: If `$this-&gt;portable_hashes` is true, it goes to `$this-&gt;crypt_private()` which uses multi-pass MD5. [Evidence](https://github.com/WordPress/WordPress/blob/4.5-branch/wp-includes/class-phpass.php#L233-L254) and [more evidence](https://github.com/WordPress/WordPress/blob/4.5-branch/wp-includes/class-phpass.php#L121-L164). Everywhere `new PasswordHash` is invoked, this flag is explicitly set to `true`. [Proof](https://github.com/WordPress/WordPress/search?utf8=%E2%9C%93&amp;q=new+PasswordHash). Consequently, WordPress still uses MD5 even on PHP 7.
Check out [Expresive](http://zend-expressive.readthedocs.io/en/stable) which is sort of the preview of ZF3. I liked what they were going for with ZF2's event system, but it was too heavy-handed. Expressive is simply a queue of middleware components that act on the request/response and either continue or error out. IMO it's what ZF2 events should have been, all the power and flexibility without mind-melting complexity.
Still maintained? Barely hanging on by a thread, I'm afraid. Loved it back in the day, not sure why you'd use it now. 
yay!
That it is. I think EAP is rolling too. I just remember when I tried to use EAP as free at the time I had it for a couple of months before it stopped working, and the next EAP was two or three months later. But yes, EAP is free, my bad
&gt; it looks like it fills the biggest gap we currently have with the callable type hint. It doesn't fill it.....it papers over it, as noted in the RFC: &gt; To add to that, nested callables can get pretty unreadable quickly, both of these problems would be best solved by a typedef feature of some kind, added to PHP later. I would vote for a typedef feature, I couldn't possibly vote for: function reduce( int $a, int $b, callable( callable( callable( callable(int, int):int $zebranky, int):int $pik, int):int $fot, int):int $zot): int { return $zot($a, $b); } to be valid code. 
While that can be frustrating, I wouldn't worry too much about it. Resources are limited, after all. More peripheral components will get some love eventually. In the meantime, your best bet is to pull from your own fork until your PRs get handled. For instance, I've had a simple PR open against zend-expressive/twigrenderer for a couple of months now. I won't worry about it not getting merged until it's not included in the next release.
It's maintained by BCIT and a surprisingly thriving community of dedicated people. I'm a symfony man myself, but still if I had a site I needed to quickly throw together targeted at shared hosting, CI is top of my list. 
https://github.com/blackfireio 
I was looking for a project to do something somewhat like this earlier in the week. Do you have plans (or implementation) to statically ensure that method signatures do not violate PHP s rules for extending and implementing?
I used to use net beans but not for ages. Use sublime text now but it's not an ide, runs super fast though. Atom is similar. I always hear good things about phpstorm but it's never really grabbed me whilst evaluating it. Also I'm not a fan of their recent change to pricing monthly / yearly. 
I mean if you really want to write some bad code you could store it in a file or database as well...
Is there currently any mechanism to suppress messages that I am not interested in?
&gt; We could just as easily have gone with union types instead &gt; We could *just* &gt; We could **just** &gt; We could ***just*** "Just" is a word that programmers should avoid using at almost any cost. It covers up huge assumptions about what difficulties would be involved with implementing a feature, and almost invariably means that the person saying "just" is making a bad assumption about how difficult something would be, at least in part because they're not going to be the one doing the work. Instead of saying "We could just as easily have gone with", instead ask "I don't see what the difficulties would have been with". That promotes a conversation about what the difficulties would be, instead of hand-waving away a whole set of problems. &gt; Question mark feels strange to me. A question mark before a word - for the record, I will be pronouncing it '[Que?](https://www.youtube.com/watch?v=e7mpClSPyhk)'. 
&gt; It's more like DIC used as a service locator. A container is a thing. Dependency injection and service locator are patterns. So it's always a DIC that gets used as a service locator, it doesn't change the fact that it's the service locator pattern. Now I'm not saying it's always bad to use that pattern, in some contexts it makes sense.
I'm with /u/Danack: Symfony's DIC is complex. I'm not saying it's a bad container, it makes sense in the context of Symfony, but it would be better to compare Pimple or another simple container to the homemade DIC. In that case the difference would be pretty much null.
I recently found out that as a student I qualify for a free license for the whole jetbrains suite, so phpstorm included. They do other deals/offers too, so check their website. People seem to agree that phpstorm is the superior ide
PHP ain't going away anytime soon.
&gt; Do you see PHP as something that might disappear in the near future? yes it'll disappear like the dinosaurs AFTER MILLIONS OF YEARS - hell theres still cobol systems out there ... So no it won't disappear. This is a shitty shitty youtube video. Do not watch this. This is the opinion of one "developer." &gt;It seems like a relevant language still, considering it's used in WordPress themes. Wordpress is something of a joke. PHP is used largely, next to java, in huge enterprise web applications and Hell it powers facebook. Something that powers a site your mom uses to upload naked baby pictures of you is not going to go away especially when 1.x billion people use it LOL. &gt; But aside from that, would it be prudent to place priority on another language (eg. Javascript, Python, Ruby, etc.).? 2 commentssharesavehidegive goldreport - Javascript is a front end language (tons of frameworks - React for example (Yay more facebook jazz)) - Python has some relevancy here but not a lot - Rails (Ruby) is another large well know web framework. 
Wow, I didnt known about it, thanks!
Hey! I've created a task with ping to you
About site, I will rewrite it ASAP Yeap I will do compare with all analyzers in few months, after first alpha release :)
Yeap I will do compare with all analyzers in few months, after first alpha release :) Anyway comparison will help me on the way, what I need to implement and etc. ) Thanks for notice
I used Netbeans for about two years before I purchased PhpStorm. Netbeans is great, but if your project is huge you may run into issues. It still does some things better than PhpStorm though. PhpStorm is worth the license cost if you have a steady job or if your employer will pay the license. If you're unsure, ask. My employers offer to buy it but I prefer owning the license.
For a novice, PHP is perfectly fine for web apps. When you start needing very performant web services/APIs then looking into other languages (such as Go) would be advised. Don't try to make PHP fit everything, use what works well. Edit: bring on the down votes without posting why you disagree (╯°□°）╯︵ ┻━┻
This guy's arguments are inane. He concludes that since the function names are bad then the actual PHP function is bad. 
NetBeans rocks. Using it for my PHP development since 2007. Pair with xdebug and you can include breakpoints and step though your code. Works great with versioning software. Has unit testing. Best of all, it's *free and open source software*. Hoping that they start supporting PHP 7 soon.
php is great to learn. its powerful and here to stay. try looking up jobs to get an idea of its popularity. once you understand it and feel confident in it try picking up another language. i know a few and it only helps. this video is stupid.
This. True 
Yeah I switched to net beans from eclipse and really loved it for a few years. Glad to hear it's still going strong. 
Also a lot of CBS sites (see GiantBomb.com and such) are built using Symfony as far as I know. I mean, if you look for jobs in CBS Interactive you will see most search for PHP with Symfony experience.
I will take a look at it. If you have ideas open them as issues and maybe me and others will take a look and submit a PR or at least discuss them. Either way, keep it up, looks very interesting.
The Moodle LMS used in universities and big corporations (Sony for example) is written in PHP. The top three CMS are php (Drupal, Wordpress and Joomla) ...
Node.js makes Javascript backend too...
Oddly enough this is the exact situation that just came up on the zend-expressive issue tracker https://github.com/zendframework/zend-expressive/issues/347. The error handling should probably create a new response, so no, if things are implemented correctly, the end user will not believe the transaction was successful.
AFAIK, no support for php7 on Netbeans yet :(
Can you describe what you mean by "more modular" so we can make improvements where needed?
You could consider contributing to existing projects until inspiration strikes. That way you get to sharpen your skills, get a taste for working with others in open source, and even get a slight fix of what you're looking for.
yes, but in todays development you mostly hear of it being front end.
I only see clients there.
It is getting better with the new language features but a programming language (especially your first) can have a profound influence on how you think about programming. Not sure what Dijkstra would think as the best "first language" of the current slate of language options for modern web development but since his preference seemed to be haskell my guess would be none... Still the man had a point when he said we are all shaped by the tools we train ourselves to use. [To the members of the Budget Council](http://www.cs.utexas.edu/users/EWD/transcriptions/OtherDocs/Haskell.html) [On the cruelty of really teaching computing science](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html) The consensus in the past was pretty much unanimous in that PHP is not a good first language to learn the concepts of computer programming. With some of the new language features it may be a bit better but lets face it if you load up PHP 7 and start hacking away there isn't a guarantee that the code you write will be of the more modern variety. One example is that prior to PHP 7, PHP uses hash tables to the point where it doesn't even acknowledge other data structures, this is like bringing out a sledgehammer every time you see a nail you want to tap on. You run the risk of having an entire programming career without understanding that there are other data structures that have specific use cases. I strongly believe PHP is a good tool to build web solutions with but that doesn't mean it is a good tool for the creation of new programmers. 
Don't let that cloud your judgement. Type aliases should be their own feature. Also, I do not envy those who have nested callback signatures in *any* language. Let's not pretend this would be a unique-to-PHP pain.
The only pain I feel as a result of that code today, is just a side effect of my having read it; It will go away quickly. The pain I would feel if we made that shameful code valid in PHP would be much more severe, and would last *forever*. &gt; Type aliases should be their own feature. If they are actually aliases, then yes, that feature can stand on it's own. Although, I can't think of a good reason it *needs* to be a separate feature. However, we can avoid messy code like that by having formal callable types as forward declarations, only. callable Type = function(int $int, string $string, ...); function foo(Type $t) { $t(...); } Possibly: callable Type as AliasedType; This seems much preferable ...
&gt; if things are implemented correctly Things are implemented perfectly fine according to the PSR7 specification and THAT is the issue. And your solution is yet another issue. For example I am on an api server and I sent a request which my action determined to respond with json. When the exception is thrown it will show an html layout instead of a json.
PHPstorm EAP https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program
IMO one of PHPs weakest sides is how tedious it is to work with large numbers. BC math syntax and the way these functions have to be chained is a major PAIN. So if you want to do something math related, I would suggest looking into perhaps finding an easier way for PHP devs to work with large numbers! http://php.net/manual/en/book.bc.php
Php can't disappear in fact it seems growing with each passing day.
If you made a library to calculate Chi2 I'd be so happy. Tried to write something a while ago in the context of split testing but it's been many a year since my last stats lecture and I'm rusty beyond words.
Or a library that makes "proper math" less of a headache?
Any sort of data analysis tool would benefit PHP - Especially since there is basically none of these tools available. Something like pandas (for python) would be a step in the right direction.
Yep, I got an OSS licence, for example!
Upvoted for adorable table flip
That's not really true, ZF2 is component based. But the good news is that there's plenty of other reasons to hate on ZF2... like the massive overuse of design patterns, being a massively over engineered, how difficult it is to learn compared to Symphony, the lack of people using it... It bothers me that the main powerhouse behind PHP would make such un-PHP like frameworks.
You could create a simple to use library to calculate root finding and stuff like this. I'd use that over my own implementation, specially since there are many corner cases that needs to be covered.
I find you actually don't need half the stuff in Laravel (as an example). You only tend to find you use different elements because it is there, not because it provides any particular value to your project. Using micro-frameworks was the best thing I have done. You don't miss something if you don't have it out the box, and if you really do need it, you can easily use it via the micro framework container. I have used micro frameworks for 5 projects and never ended up with all the stuff a full stack framework has in it.
Yes. The ecosystem is bigger than just bare PHP. Yes, the language itself is evolving and forking. That's all great topics however a bit irrelevant to the question.
It was a *rhetorical* question ;)
PHP is in no way going anywhere. Take a look at these stats from W3Techs: https://w3techs.com/technologies/overview/programming_language/all There's a huge community behind PHP and there's plenty of help to get (both good and bad, as there is in any kind of programming). PHP has come from a less developed past to being a more consistent and powerful scripting language for web developing, but the bad reputation is clearly hard to get rid of. Just see the video author, Chris Hawkes - he's referring to an article [posted almost four years ago](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) - he kind of skips the parts where the author updates the article whenever some PHP version has fixed some of his annoyances. He stopped updating the article after PHP 5.6 came out, apparently. But this article isn't that relevant anymore (get over it, haters!). Additionally, he refers to Rasmus Lerdorf, being quoted for not planning PHP as being a problem solving language, as if the fact that Rasmus hates programming makes PHP bad (straw man argument). Seriously, how do you come to that conclusion? "Python is better than PHP! Why? Because I said so - I'm a credible source without bias". Nice going, Chris Hawkes. He also concludes, as a finishing statement, that "people are fleeing from PHP", but I don't buy that as an argument for anything. So he found some big names that moved on from PHP, so what? He thinks this only happens for PHP? How about the experienced developers currently ranting about Ruby? Don't pay attention to this guy. Sure, PHP has some issues - just like every other language has. I use PHP along with Python, to compliment each other. I also write Java for Android Apps - and I f*cking hate Java. Just learn some languages - if PHP is one them, good for you. Choosing Ruby, Python or something else? Good for you. Just get crackin' and code something.
I once created a library for arbitrary number base conversion: https://github.com/thunderer/Numbase . I'd be very happy if you could think of any improvements, maybe even create a Pull Request? :)
Everyone shitting on PHP while I'm just sitting here picking up the work and making bank. PHP is here to stay, and from how PHP7 has matured the language, it may grow.
Hey, really good job, seems nice. I tried it on my project, but I've many issues with undefined methods in my controllers which exist in a dependency loaded in vendor (an abstract controller). Is there a way to load the vendor folder without analyzing it ? Because the vendor contains 2200+ files :(
Somehow, I get the feeling you got a bit butthurt from my personal opinion? Obviously there might be another set of difficulties, but I don't see how changing the already existing syntax from `int $var = null` to `?$var` is beneficial at all, other than it tries to imitate other languages.
I have an impression that it’s creating an unnecessary distinction between closures/callables and classes, just like with the `array|Traversable` chaos. Instead of sticking with one way of doing things (always expect Traversable or always expect an interface) we create two separate ways: * Oh, I’m just accepting arrays, so you can’t pass your generator here, use `iterator_to_array` and loose any benefit that generator might give you * Nope, you need to provide `Traversable`, your array literal isn’t good enough, wrap it in `ArrayIterator` at least * Hello, pass me a function, I don’t know how to call a method on an object, even if it has only one… * Gimme an object implementing this interface with this one method… Just the method as a callable? Nope, can’t handle it. The array vs Traversable juggling is tiresome. I’m afraid this kind of changes lead to similar experience with callables / functional interfaces.
And Kotlin iirc.
xdebug_disable will disable only error/exception callback handler as I review, not all
They think PHP is the dinosaur -- old and outdated. It's actually the cockroach. It survives no matter what.
Im not sure joomla is anywhere near top3 cms :) 
Got an error from the phar : https://paste.ee/p/KRCEz
Can't do much about it: most of the CR team (including me) is busy with contract work at the moment.
Port pandas' Dataframe structure.
Same here, after reading an agile development book too, I feel like it's helped me grow a lot and really really think hard about how I write my code. 
 &gt; It bothers me that the main powerhouse behind PHP would make such un-PHP like frameworks. Zend has very little to do with ZendFramework, and the team at the core of ZendFramework has little to do with PHP itself.
My Symfony application (an e-commerce shop) running on PHP7 has an average execution time of 17ms, for some pages it reaches 5ms. Symfony is actually really performance tuned and also enables a developer to tune its own application, for example with the kernel.terminate event, which makes it easy to send the request back to the client and then still do some leftover processing. So the whole discussion about "Symfony being slow/bloated" seems ridiculous to me. By the way, I did not optimize Symfony - if run in production mode it optimizes itself.
node is a wonderful back end as well. Arguably much stronger than php at this point doing asycn stuff. Learning ratchet/reactphp right now but it seems a bit behind node. I think it will largley swing back to php with the obvious push in php7 though.
it's still awesome. (edit: btw. it's my subjective opinion, but you can further downvote me which just shows your maturity.)
Mantis. Stop laughing!
Seconded. 
Urgh, please use a proper benchmarking tool, like https://github.com/phpbench/phpbench. Without considering stuff like standard deviation and overhead, you are likely measuring wrong bits anyway. The reflection API didn't change anyway, and not even internally that much, so you are probably just getting results about the actual method call overhead, and not its internals.
That's a good idea actually. Thank you.
code intel was exactly the plugin I was looking for, for my sublimeText installation. Thanks. 
Or, something that is powerful enough, and way less complex: http://diakonos.pist0s.ca/
Hate topics with "you need" instead of "you should".
Thanks for feedback! We have docs for using Eloquent: https://github.com/illuminate/database Using container is a matter of requiring `illuminate/container` and just doing `new Illuminate\Container\Container`. There is no special wiring needed. 
Thanks for pointing this out. I've made it to have a real world example of general performance of reflections (with all the overhead) because i don't found anything useful for my case. And than i just published if anyone else need something like that. I don't really care about bit exact or microseconds granularity. Anyway, thanks for commenting this.
I always figured the main bulk of development on ZF was funded by Zend, is that not the case?
Wordpress is PHP. Wordpress isn't going anywhere soon.
Yes, I'm using PhpStorm as well. I didn't say you need to use Emacs to be productive. I just think that *learning* Emacs allows you to be more productive with IDE like PhpStorm.
So...does it use Namespaces yet?
Yes. A novice should avoid Php. But not because of concerns regarding Php disappearing. But because Php is a inferior language and the majority of stuff you learn in Php has very little use outside it's context. Another reason is that Php teaches a lot of concepts in a wrong or awkward manner. For example, even the newly added type hints. The community refers them as Strict/Static typing. The associated rules are also weird. In short, Php is a mess. People are able to build stuff with it. But that does not mean it is not a mess. It is not getting really cleaned up, but more mess is being added as of now in the name of adding "modern features". That is only scratching the surface. So yes. If you are new to programming, stay far away from Php. Python is a much better choice IMHO.
Well, for myself I could say that I am using vim extensively (to edit files in console) and I wish I had more experience with it. 
&gt;Sure, PHP has some issues - just like every other language has. Please stop touting this. Php's issues are no where similar to that of "other languages" . Your credibility goes out of the window as soon as you say something this...
Yes you can. Just use X forwarding. But if you edit your source directly on your server, you are doomed anyways
Tell me how I'm wrong?
&gt; Using micro-frameworks was the best thing I have done Symfony is a micro-framework and doesn't have any opinionated architecture. It's just that the standard edition is full-bloated and MVC oriented out of the box for ease of use, but if you're looking for more customization and know what you're doing, you should use the empty edition isntead. 
https://signalvnoise.com/posts/439-four-letter-words Often, words like this are demands masquerading as requests and they can undermine trust and working relationships.
SFTP is SSH. The benefit is I'm not limited to a command line editor, I can use any GUI editor which means syntax highlighting and other tools. My point is people think you need to only learn vi or emacs for remote file editing but it's simply not true.
What about the gmp extension? It's gotten even easier to use as of PHP 5.6 with https://wiki.php.net/rfc/operator_overloading_gmp
I would not make every callable prototype in a type alias if that feature was available. Probably only nested ones, which are rare, and probably even more rare that I'd want to type them.
Damn right. Dogs &gt; Cats.
No descent module system? A std lib that is a mess? Extremely weird and obscure type coercion rules that even bites devs with decades of experience. A godawful amalgamation of a data structure that is supposed to be used for everything (The php Array)? An order of magnitude more edge cases and gotchas than similar languages... Those are the commonly accepted things even here in /r/php. I can add a lot more, but it might disturb some people here. So not going further. 
[@MarcJSchmidt](https://twitter.com/MarcJSchmidt) [@niluspc](https://twitter.com/niluspc) [@Ocramius](https://twitter.com/Ocramius) [@reinink](https://twitter.com/reinink) [@settermjd](https://twitter.com/settermjd) [@bitfalls](https://twitter.com/bitfalls) [@lisachenko](https://twitter.com/lisachenko) [@evertp](https://twitter.com/evertp) [@CiPHPerCoder](https://twitter.com/CiPHPerCoder) [@colinodell](https://twitter.com/colinodell) [@WyriHaximus](https://twitter.com/WyriHaximus) These most match your criteria from my follow list ([@AndrewCarterUK](https://twitter.com/AndrewCarterUK) if you are interested).
Both of you get a downvote! Cats &gt; Dogs!
Demonstrably false: var_dump('Cats' &gt; 'Dogs'); // bool(false) var_dump('Dogs' &gt; 'Cats'); // bool(true) 
Should I tweet about my cats now?
&gt; when attacker has enough computing power to brute-force the input to find a collision ... which is often the case for md5 and sha1 algorithms, because it's possible to create GPU implementations and have billions of attempts per second with a low investment farm. Not arguing with you, just complementing what you said :)
Next time I need someone to transcribe a posted video I'll be sure to mention you. PHP is trying to make up for years of inconsistency with a lot of things, and apparently, people like you care very little for the hard work put into improving this. That's fine - go masturbate over some gems or something. If all you can do is rant the same way as every other hater does, your input has no value.
You shouldn't be editing config files directly on the server, you should be managing them with some sort of configuration management.
Go on. What particular management it should be? What config files it should manage?
That's why I don't really use Twitter or Facebook to find content at all; reddit's concept of separating by topic instead of poster is much better suited for the task.
Yes. We love cats. 
Fixed: https://twitter.com/Ocramius/status/735143020996222976
&gt; I didn't even watch the video. I figured as much, but I forgot to add irony punctuation. &gt; Well, the question was if php issues are comparable with other languages. No it wasn't. There were two completely different questions; one being whether or not PHP is going away any time soon and the other being if OP should focus on other languages. But enough about semantics... &gt; [...] Which is what you declared. No i didn't. I said that PHP has issues, just like every other language has. Apparently, that rocked your boat. &gt; I thought you didn't know what "every other hater thinks". because you asked. I asked you to prove to me that other languages doesn't have issues. You apparently suffered from a brainfart and started ranting about PHP instead. 
&gt;I am trying to find useful information on Twitter There's your problem.
&gt; No it wasn't. There were two completely different questions; You seem to have a hard time following the current context of the conversation... &gt;I said that PHP has issues, just like every other language has. Apparently, that rocked your boat. Lol. Clam down. If you can't take conflicting arguments, may be you should not be posting in online forums... &gt;I asked you to prove to me that other languages doesn't have issues.... Oh. You didn't. You asked how you are wrong, *when* I said, "Php's issues are no where comparable to issues in other languages". So it naturally follows that you are asking me to show how Php's issues are much worser than the issues in other languages. Which is what I did, and you got all pissed off...Lol. 
&gt; You seem to have a hard time following the current context of the conversation... Not really, but I have a hard time following you. Not the same, but again - semantics. &gt; Lol. Clam down. If you can't take conflicting arguments, may be you should not be posting in online forums... I am calm, I just concluded that my statement rocked your boat. How is that agitated? &gt; You asked how you are wrong, when I said, "Php's issues are no where comparable to issues in other languages". Apparently, I'm not the only one having a hard time following the context. I asked you to prove my statement wrong, you read that as me asking you to do something completely different. &gt; Which is what I did, and you got all pissed off...Lol. It's funny how written words are interpreted differently. Like "Lol" reeks of insecurity, but I'm pretty sure you're about to tell me I'm wrong about that too. 
Hey and I think that you should use twitter the way you want to. No judgement. But at the same time I understand the OP's sentiment and tend to unfollow the people with a too low signal to noise ratio.
Here's a list of people I'd recommend: https://github.com/gnugat/knowledge/blob/master/read-it-later.md#twitter
I'm actually kind of shocked by the level of downvoting here. I dont remember Codeigniter being this hotly detested. Thing is, OP doesnt necessarily need to be completely alienated by all the insane advancements we've taken as a community to drive and direct ourselves better. We all started somewhere. Sure maybe Laravel would be the most logical jump into modern php development, hell im still going to advocate towards Symfony myself. But as a person who's been forced into maintaining some wandering ZF1 applications for the past couple years, and talking to those applications original developers, the response is usually the same: they're intimidated by all the new stuff and usually jsut want to get a job or idea done with no hassle. As much as it pains me to hear. So that said, CodeIgniter. It's still an active project whether you like it or not, as opposed to ZF1 (unless ive missed something about some updates recently, everyones kind of moved on since), and yet follows much of the same design patterns so it's easy to transition into, and then hopefully use that as a tiny step into modern framework usage. 
I see what you mean. You think that a system always works as intended and all you need is to deploy it. Good for you.
An unexpectedly familiar name. 
What? No, but if something's wrong I'm not modifying the config file on the server, I'm pushing out a change with Puppet, and I'm usually testing those changes on a staging instance first so, frankly, things rarely go wrong in production that I can control.
And people say FIG is not open to hearing from outsiders.
That's a great quote. I agree with you, as long as you are aware of your mistakes and can learn from them. There are those who learn just enough to be dangerous and then learn nothing else, and it's script kiddies like that who are a problem. On the other hand, PHP has democratized coding in some ways, making it available to almost anyone. And criticisms of it remind me of Plato's argument against literacy, that it would mean the death of poetry. 
I think most (if not all of them) do (as long as you're hydrating the results to entity objects - doctrine has issues casting types for array-hydrated results).
Nice, do you also happen to know if it handles NULL foreign keys?
Sorry, and what does "hydrating the results to entity objects" actually mean? Could you ELI5?
So I said. You live in the perfect world where things work as expected, and all you need is to change a configuration option or two, which is good for you.
Yes. Doctrine does handle NULL FKs.
Uhhh... please don't use Doctrine 1.2, it is ancient and un-maintained tech... Doctrine 2 has that, btw.
Yep COBOL is still being used by lots of institutions for transactions and internal systems. 
Do I have to manually define a Person class before hand for this to work? Maybe an ORM isn't what I'm looking for, I think I'm more looking for a dynamic query builder that can analyze schema and auto-cast the results to the appropriate data type.
Awesome, thanks for the tip! Yeah I think this is what I'm looking for, I might skip the ORM part altogether.
hahaha, I just pasted the first google result. I'll edit the original post.
like what? if i want to modify the crontabs i can just do "EDITOR=nano crontab -e"
There could be no nano installed. 
What kind of problems do you have where manually editing files on a server works but managing the file with config management doesn't?
Editing a config management system configuration file.
Some of the PHP devs I follow, in no particular order: - https://twitter.com/auroraeosrose - https://twitter.com/SaraMG - https://twitter.com/e3BethT - https://twitter.com/notajf - https://twitter.com/lornajane - https://twitter.com/michellesanver - https://twitter.com/dead_lugosi - https://twitter.com/ieatkillerbees - https://twitter.com/eryno - https://twitter.com/SamanthaGeitz - https://twitter.com/AmbassadorAwsum - https://twitter.com/jesslynnrose - https://twitter.com/elstamey - https://twitter.com/kayladnls [e] I somehow forgot Kayla Daniels and I repent in dust and ashes.
&gt; CiPHPerCoder time to follow CiPHPerCoder. :D
Food and shelter are overrated.
Cats are essential to any programmer.
Hahaha this. Twitter is like a loud coffee house with people "hanging out" by shouting at each other over the din. It's not really the best place for news or learning.
&gt; Are there some real good php guys out there worth following Yes, lots. It helps you get to know the community and fellow developers a little bit, and sometimes people tweet small things they're working on that are interesting. I keep a list of awesome people here: https://twitter.com/coderstephen/lists/awesome-developers. Cal Evans has a good list going as well: https://twitter.com/CalEvans/lists/phpeople
Atom is free. Good. I will use Atom. 
Indeed! Downgrading to eating dirt and grass soon :-)
I would say that it forced me understand more about WHY structured languages and frameworks do things the way they do, and how I could apply those concepts across the board. It helps me understand when using frameworks what their limitations might be - e.g. if data layer using a factory, I'm limited on data source choices. It's easier to understand when documentation is wrong and how to adapt. It also lets me make the decision of how much engineering I actually want to apply. If I have a client that wants a 40 hour build, and is only paying for a 40 hour build, then I'm not going to build for flexibility - I'm going to slap the thing together "well enough". If I'm looking at 2500+ hours, I know that I need to get it correct up front. That's MY choice with PHP. 
In other news, people hate it when you disconfirm their priors.
Cool
It's 8192 rounds, but that's still terrible. * 86,000 rounds of PBKDF2-SHA256 is the minimum. * This isn't even 10,000 rounds, and isn't PBKDF2. * MD5 is shitty, but that's not a security concern.
Better idea: Switch to [a more secure CMS](https://paragonie.com/blog/2016/05/keyggdrasil-continuum-cryptography-powering-cms-airship) (WIP, but being actively developed).
&gt;But if you edit your source directly on your server, you are doomed anyways Been editing the source directly on the server for more than 10 years now and I'm still not doomed, what am I doing wrong?
&gt; However, loading the classes into memory is the biggest bottleneck I'm not quite sure what it means for a class to be loaded into memory. Doesn't this happen anyway as soon as you autoload a class? So in real world usage any class you're using (with or without reflection) would be in memory anyway, right? 
Totally! I've been using the new types a lot but the current implementation is too restrictive for empty content. It's not fixing the NullObject pattern but at least it fixes the `''` vs `null` issue.
I need to create an app that can detect the height of people in photos. The photos are very specific and can have guide objects in it. They are also on have a white backdrop. I would also like to cut out the backdrop and guide objects to produce a transparent PNG. Do you have any tips on how to do this/what software I could integrate with to achieve this?
Mobile keyboard blankets*
Who would write code like this in the first place? Wow.
The repositories node in the composer.json file is root only.
There was only 1 Nay from Bishop, so we know who the culprit was.
Yes, that's what it means. I will update the description for a better understanding.
True not, PHP related but pretty interesting nerveless. There is more algorithms at http://www.cs.usfca.edu/~galles/visualization/Algorithms.html 
Yes, the [Cake ORM](http://github.com/cakephp/orm) does tat automatically for you, also for a lot other column types. One cool feature it has is that it knows the common return type of SQL functions. So if you use them in your select, the right type will be returned in PHP
If you don't like cats, maybe the internet isn't the place for you :) https://pbs.twimg.com/media/CdP9QFwUMAAOeQw.jpg:large The non tech tweets from my tech friends are some of the most interesting tweets ... interesting [local] news items, local wildlife, pictures they've taken on their travels ... I love all that ... Nobody spends their lives thinking about this stuff, and it's nice to see what other things they think about. It's a happy coincidence that a lot of the time, what they find interesting enough to tweet about, you find interesting enough to read about.
&gt; The expansion of Information Technology (IT) sector across the world lmao
I think there's a misunderstanding: that sentence was an answer to the previous comment which said it was impossible to tweet every hour about PHP. I'm not saying everyone should do that. I'm saying it's possible to tweet only about PHP, it just doesn't require to tweet every hour. Also it's not about not being social and not have other interests (I personally certainly do have some), it's about some kind of "editorial policy". It's perfectly fine not to follow one, just like it's perfectly fine to want to tweet about our cats or whatever.
event linux terminal has cat cat /var/log/apache2/error.log
Oh I love cats! 
What are the download stats like? Not sure I want to use a project if it's not popular...
I literally JUST finished the docs, it's a new component. 
My mistake, you're right: 8192 (thanks http://3v4l.org). Therefore the official documentation is wrong ? &gt; (...) the default implementation uses PasswordHash, which adds salt to the password and hashes it with 8 passes of MD5 According to the [code](https://github.com/WordPress/WordPress/blob/4.5-branch/wp-includes/class-phpass.php#L121-L164), it should be: &gt; (...) the default implementation uses PasswordHash, which adds salt to the password and hashes it with 2^(5+8) rounds of MD5 if the PHP version is superior or equal to 5 and 2^(3+8) otherwise. Which is EVEN WORSE ! Thoughts on the other points ? :) As usual, thanks for enlightening us Scott !
inb4 php drama, flamewar, phpfig explosing
Except you can. If you have some kind of configuration management there is no need to modify the configuration files right there on the machine that uses them. I put all of my configuration files in git anyway, so I can edit them with My Favourite Editor (tm) on my mac and then just pull the finished version on target server. I’m not arguing that learning more powerful cli editor won’t boost your productivity. I’m just saying it’s not the only way, and as others have said: [that’s just, like… your opinion, man](http://www.reactiongifs.com/wp-content/uploads/2013/06/opinionated.gif).
[This update broke my workflow!](https://xkcd.com/1172/)
I learned most of what I know today (about programming) because of twitter. I know yours is sarcasm, but I genuinely believe (due to personal experience) that following a healthy list of technical-oriented accounts is worth more than going to every programming conference there is out there. 
Wow, all this constructive feedback in this thread is amazing. Thank you so much /r/php
Pointless cat award incoming. 
Tough questions. In short, PHP is a nice language to start but not to invest on for too long. It is a good starting point because its approach to typing makes very easy to be productive and get that good feeling you're making progress fast. However it is also lacking in many areas regarding tooling and ecosystem toxicity. Eventually you'll figure out if you're more of a type-centric developer or not. If you become one of such people, you will tend to move to languages like Go, Rust, C# etc... OTHO, if you find yourself preferring still dynamic languages, you might find yourself supplementing your PHP skills with other languages such Javascript, Python or Ruby. PHP is a fine language, will not be gone any time soon. However you will find that in practice PHP salaries are shrinking and the quality of job openings are getting worse too (less capitalized companies offering worse work contracts). 
I don't talk about cats!
[Properly advertised](https://twitter.com/TobozoTagada/status/735438489194483713) (robots welcome)
^ And him. Sorry, I did a skim.
Do you think any of this might have been your fault?
&gt; it's in active development It might be in active development, but that doesn't make the developers any better at their jobs. I'm pretty sure it's fairly well known that the core dev team of Wordpress are extremely out of touch with modern day security and coding principles.
A few quick observations: * You're missing a license. * You've got some mixed indentation in the README's code examples. * Good to see good test coverage. * Bad to see lack of docblocks. * You're not following PSR-2 completely here, if that is a concern is up to you I guess! * Interesting choice to use the magic methods, isn't there an impact on performance with that? * Also an interesting choice to use static methods. Surely this will only promote service location, i.e. the anti-pattern? * The callback thing seems a little confusing, could you add some examples of how to use it, and why it's useful?
The amount of sock puppets in this thread is mind-boggling.
Personally, I'd consider the usage of static methods and magic methods an anti-pattern. Aside from that, I think the `build()` would be better off named `shared()` or something that more explicitly indicates that it's a single instance instead of creating a new instance every time.
Tonight I will write a series of scripts that will post several hundred constructive comments at 2AM. ;)
Naw man, it's somebody ELSE who made /u/dracony look bad. See, his boss wouldn't let him use PHPixie because it wasn't popular enough. So instead of just saying, "Ok, whatever, there are a million better alternatives out there", he decided to write a script that would artificially inflate the download count to help make a better case for PHPixie. "Look boss, the download count is rising by several thousand at exactly 1AM! Isn't that awesome? We should really consider using this tool that's been steeped in mediocrity." "Oh, well that changes everything! Go forth, my underling, and use this now-popular tool!" But once this mysterious employee - who also happens to browse Reddit and the PHP FIG mailing list - heard about the drama he inadvertently caused for his beloved /u/dracony, he decided to man up and come forward about everything. What a guy, amirite?
They start with 3.0 to keep with the framework. so 3 is just a number. The number 3.1 and 3.2 incrememnts when a breaking change is introduced (which happened twice).
Redis is a better choice for shared session management I think.
You should really follow SemVer. If you'd started your numbering from 0.x then you'd be allowed breaking changes between 0.1 and 0.2 (etc), as these changes are common early in the life of a project. Once you hit version 1.0, minor version changes must be backwards compatible. The breaking changes between 3.1 and 3.2 would break any code that depended on your project that ran a 'composer update'. If you'd been tagging 0.1 and 0.2, this wouldn't happen.
yes, you have to enable persistent storage in Redis' configuration file though. If you don't store the sessions as persistent then you might lose your sessions.
This isn't a very hard problem to account for. Just figure out the average memory usage of each request and divide the amount of ram in your server by that. That number, multiplied by the amount of servers, is how many requests you can handle at once (yes I realize I am hugely simplifying this). If the average session size multiplied by maximum number of requests is less than the amount of memory allocated to your k/v store, then you have a potential problem that you need to handle. Either add more ram or add a persistent storage layer of some sort. Also-- use Redis not Memcached. It does everything Memcached can do and a LOT more. 
Let's say; you have 1024 request/sec. There is 20KB data each request. So, you need 20MB memory sum of requests. Memcached has 64MB memory (for example). As per the disaster scenario, your article shared through Twitter by a famous person (Katy Perry?). When your 3300th user log in to your system then you will lose your first user's session.
So, they might write comment to the article. I wrote this article influenced by real problems. A lot of people had faced with this problem. 
Is there anything Redis isn't a better choice than memache(d) for?
Yes, there is no any problem in Memcached. The problem is usage of Memcached.
Basically just systems that don't support it (Wordpress didn't used to though that may have changed)
Any recommendations? I was thinking about trying to build one myself. 
Been using Netbeans on Linux and I'm not sure what everyone is talking about it being slow? It is fast, offers all the features I see my colleagues using on Sublime, and goes beyond that with all the IDE tools. Even something simple like being able to supply the intellisense-style hinting on classes that are not even yet loaded into the solution through watching the auto-include paths is incredibly useful, and something I just don't see on a text editor like Sublime. Sublime is great, but at the end of the day it's only a text editor, and can't compare to a full IDE in terms of the capabilities; that's just a fact. That said, I wouldn't force my way of working or my tool choices on anyone. Whatever works best for them is fine as long as it works.
&gt; I'm saying it's possible to tweet only about PHP, it just doesn't require to tweet every hour. Which is saying literally - you should either have to juggle two different social media entities (at that point, just write a blog) OR never ever discuss anything else that a user would, as a normal human being, use those social media platforms for because you, as a consumer, don't want to read anything but their PHP thoughts.
The mostly search framework does not mean it is the mostly used...
Maybe you just want [Doctrine DBAL](http://doctrine-orm.readthedocs.io/projects/doctrine-dbal/en/latest/). ORM stands for Object Relational Mapper. By definition, they take database data and put it in the correct object. The DBAL has a query builder and returns the data as an array. I *believe* it will cast numeric column types to the appropriate PHP type, but I'm not positive.
That's a pretty cool concept! Do you have any other examples?
I always encourage upgrading to the latest stable version, upgrade and run tests and you are done. Not having package private classes in php makes every class you have part of your public api. I have no idea how would you add a meaningfull feature without modifying some of te existing classes. I saw projects deliberately saying that some classes are considred public api, and some considred plumbing, and modifying these plumbing classes then doesnt constitute bc breakage. I dont like that approach either tbh. At any rate i can always intoduce semver keeping the 3. prefix, so its 3.1.1.1 For example if you consider whats documented to public api, then i apperently have never broken it ever since the first release, since I have been always adding new stuff
I'm not a fan of "language wars on the internet" for the reasons you're discovering here: if you call into question someone's credibility, you are unlikely to be heard, and you'll get an earful instead. In fact if you _start_ hostile then you might even deserve what you get! From time to time this sub gets people who've "seen the light" and evangelise against PHP. I suspect that even if they're right - and I won't comment on that here - I doubt they'll have any impact. Maybe everyone should just put that sort of effort into building cool products - whatever their favourite language is? 
How about not storing sessions at all? ;-)
A moderately competent person will almost always write queries that don't involve temporary tables. A RDBMS specifically does this as a last resort.
&gt; I always encourage upgrading to the latest stable version, upgrade and run tests and you are done. So, you actively discourage people from using your framework for business applications? Businesses refrain from refactoring all the time like this for no reason. And they need to keep getting support for their libraries (they need to keep them up-to-date for security reasons). &gt; I have no idea how would you add a meaningfull feature without modifying some of te existing classes. By having separation of concerns. &gt; I saw projects deliberately saying that some classes are considred public api, and some considred plumbing, and modifying these plumbing classes then doesnt constitute bc breakage. I know of no project that uses such thing. All frameworks I know (besides Yii) adheres to SemVer. Symfony doesn't break anything from any class when upgrading between minor versions. &gt; At any rate i can always intoduce semver keeping the 3. prefix, so its 3.1.1.1 The last `.1` is a revision number, for internal purposes only. I don't know why you're so fond of the `3` prefix. &gt; For example if you consider whats documented to public api, then i apperently have never broken it ever since the first release, since I have been always adding new stuff Everything is a public API. Even `final` methods. You can **add** new methods, but you cannot modify signatures or remove methods between minor versions.
Hmm, in 2016 I'm looking for something a little more powerful. Do you happen to know of any query builders with a graphical interface that can be used to generate SQL? Using the query builder syntax seems just as tedious as just writing out the SQL.
That's even less performant and more error prone.
Actually, it's about ethics in PHP dev lists.
&gt; I already said that the actual api that business would use is rarely broken. I don't even know how to reply to this. So, people can't extend the framework? It's not OCP compliant? Also, there's no such thing as plumbing classes. Classes are classes, their responsabilities should be well defined and they should not depend on each other to work. Any framework strictly following SOLID practices won't have any issues with adding new features.
I actually tried the very same thing a while back, I can't remember where exactly I diverted to another solution, but it had to do with the way everything is compiled and cached, I needed dynamic routes at some point also, and all the signs were just "please stop doing what you're doing". Every step I made forward I was sent 1 backwards, very frustrating. I don't know your motive but I would go for one install per tentant tbh. It should be doable for almost any situation with the right deployment strategy. You should handle anything tenant specific through parameters(so you can make it part of deploying)
3rd party services can and will fail. They can go down, just like anyone else. If they're jerks, they can also break their service contracts. Test that your software handles these failures gracefully. Otherwise, you're building super brittle "my system depends on another system to ensure my system works" tests. Your test suite should not fail because a 3rd party is having a service outage. Does their outage have ANYTHING to do with you and your code? You're coupling your system, and even worse, your test suite to another system. 
That's exactly what I'm afraid of what will happen and the "please stop with what you're doing" is all too familiar. Eventually something will go wrong and having this setup will probably also make debugging exponentially more difficult.
I dont think its worth the pain. I started with emacs in my school, i'm really happy about that, i learned shortcuts that can be used everywhere (except windows bullshit) Like Ctrl+A to go to the beginning of the line, CTRL+K to cut the right side of your cursor, CTRL+Y to paste, and, well, that's all but i use them everyday. You are right for the config files, but you dont have to code with Vi/Emacs to modify your php.ini, just have to learn the bases IMO. By the way you can open files in PHPStorm with their name (being autocompleted, CMD + MAJ + O on mac)
People want different things, is this a problem? I don't see how it affects anyone. I just follow people that tweet X, some others follow people that tweet Y.
When you install wordpress, you should know that you do not get security with it.
I'm not arguing the point, but I was just looking to know an answer to my question, lol. I know the scenario presented is lackluster/horrible and reeks of horribleness (I've raised up some of the same points). However, we own the company now that sparked this inquiry, so if they do go down then there's bigger issues than just my tests not working.
At least it will get noticed and fixed in a timely matter. You can't depend on that with less popular or in house CMS.
I would recommend you favor multiple installs instead. And a separate git repository for the configuration files, which is pulled in during build and packaged together with the code. This way a deployment wouldn't affect all users, you're not altering the default way the framework runs/initializes, you have the flexibility of deploying different versions for each tenant (in the rare occasion you would need that). I worked on an SaaS application in the past and we went with a similar approach and caused more headaches moving forward, then the straightforward alternative of multiple installs.
You *could* use an obfuscator like Zend Guard (and there are many on the market), although it's not 100% reliable. The blunt answer is: do not use PHP if you want to give people the application without giving them the code.
I wouldn't trust working with software of which source code I didn't have access to.
No. Sell it as a service, or open source it and sell support. No runnable obfuscated PHP can't be unobfuscated. Furthermore, on a matter of principal, source code isn't worth anything. Speaking from experience, I've had my hands on a few Fortune 50 codebases, and in addition to usually being awful, it's not what makes the business tick. I can't tell you how many unfounded "BUT THEY'LL STEAL OUR SOURCE CODE" meetings I've been in, as if that's the only thing stopping someone from being Target. If only we had Target's sweet sweet source code, we could run them right out of town. Not true. Netflix open sources plenty of projects, feel free to try and compete with them. Wordpress being open source isn't slowing down Automattic. Point is, don't worry about someone stealing your source, no one cares. If you make a great service, sell that, if you make great source, sell support.
Sorta off topic.. Nothing directly against blade, but I typically use Twig (I'm using it in multiple projects that aren't necessarily written within Laravel so it's easier to transition). I also found that the way Twig handles adding on functionality to be much more intuitive and flexible than blade. I had a hell of time trying figure how to send a variable created during a `foreach` in a view to a custom function in blade - not sure if I ever did figure it out - but Twig worked as expected. As far as Eloquent goes, I like it because it's pretty damn simple to use, but I find that my projects lean on that functionality. Not sure if that's bad or not - I guess I'll find out. Sorry, maybe, futureself. My work projects I (over)use repositories because they are long term so there's some shielding there.
lucky enough to have one shipped my way. Its a great shirt. 
"topics" are a new feature but i think they present some slightly [different results](https://www.google.com/trends/explore#q=%2Fm%2F0jwy148%2C%20%2Fm%2F02qgdkj%2C%20%2Fm%2F09cjcl%2C%20%2Fm%2F0cdvjh&amp;cmpt=q&amp;tz=Etc%2FGMT%2B4) (also added laravel because duh). 
It's a pretty good indicator. 
They fixed the md5($password) approach almost 10 years ago. Although it is still 8192 rounds of MD5 (the same it was back then ~10 years ago, I believe).
&gt; I think I need a micro framework... do you? raw PHP has everything you need: * separation of concerns is easy when accepting POST to a single URL * CLI in PHP is kinda like writing your typical shell script * speed (it's the fastest) 
I took an endpoint of a larger app that was bottlenecking[1], rewrote in plain PHP with no frameworks (I'm literally talking read url, get data via direct driver, serve response) and went from 120 req/s to 8K. We served the same amount of traffic using an order of magnitude fewer servers which equals thousands saved every day. Take a look because you might be able to just use raw php for the critical bit and then do all the rest in a regular framework. As long as your data stays consistent (and that's the biggest challenge), you're golden. [1] http://hybridlogic.co.uk/2016/02/the-hot-path/
As others have stated, making real cURL requests is more appropriately done in integration tests, not unit tests. You would not be able to get decent code coverage in your unit tests unless your third-party service is failing all the time (you do handle errors, right?). I recently had to write code to interact with the MailChimp API via cURL. Details of how I handled it are below -- perhaps it will give you some ideas. I first created an interface contract that listed all the cURL features I needed. interface CurlSession { public function close(); public function execute(); public function getInfo($opt = null); public function init($url = null); public function setOption($option, $value); public function setOptionArray($options); } I then created an implementation that wrapped PHP's cURL functions ([adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern)). class BasicCurlSession implements CurlSession { public function execute() { return curl_exec($this-&gt;curlHandle); } ... } I then created another class that implemented CurlSession solely to be used for unit testing. The class does not really use cURL -- it allows me to simulate whatever success and failure conditions I can think up. class MailChimpTestCurlSession implements CurlSession { public function execute() { return 'Whatever I need it to return.'; } ... } Anywhere cURL is needed, a CurlSession is required (["program to interfaces, not implementations"](http://stackoverflow.com/questions/2697783/what-does-program-to-interfaces-not-implementations-mean), [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection)). I can pass anything that implements that interface and it will be accepted. $curlSession = new MailChimpTestCurlSession(); $mailChimp = new MailChimp($curlSession, $options); $updatedListMember = $mailChimp-&gt;insertMember($listMember);
I've been impressed by some of the Java decompilers. If people _really_ want the source code they're probably going to get it.
Technically you're right. People (your average joe mainly) tend to install plugins without considering if its a secure one. So since the team behind wordpress lack the time to review plugins before uploaded. Chances are people will use whatever is available. 
Never thought I'd see one of my blog posts up on here. Happy to answer any questions people have. 
Like /u/teuna said, you don't even need a framework for this. Raw PHP will be the fastest solution for you. Otherwise, you can just pull the components you need: * [League's Container](http://container.thephpleague.com/) for your application's DI * [League's Route](http://route.thephpleague.com/) or [FastRoute](https://github.com/nikic/FastRoute) for your router * [Symfony's Console](http://symfony.com/doc/current/components/console/introduction.html) for building CLI commands Just glue everything together and you should be good to go. If you need to tack on any new functionality, you can easily add new components and flesh out your application even more.
Its the same with .NET. The red-gate reflector not only decompiles any .NET EXE/DLL you throw at it, but also does it in the language of your choice!
Shits cray. All your source code are belong to us
I really like blade for some reason. maybe I'm just used to it, and I like the fact that it's still php so you can use Php functions and your helpers if needed (I'm aware also a drawback because nothing prevents you from putting logic into your views)... But when I'm not using Laravel I use Twig, because as far as I know you can't just composer require blade and start using it like you would with Twig.
I only saw it because of your comment elsewhere; I think it's a great example of picking tradeoffs. Nicely done.
Phpunit is acceptable haha :P
Quite frequently. ;-) &lt;http://auraphp.com/about&gt; (Hm, I need to add some 3.x notes there.)
awesome!
1. Yeah, that totally can happen. Just like someone can download wordpress, and boot it up themselves. Sure it can happen, but think about what you're gaining, Adoption. Let's say it happens millions of times, let's say your software gets "stolen" and installed all over the world. What you now have is a vibrant community of developers that rely on you, and this is a very lucrative thing. Sell support? Sell Training? Sell Custom Consultancy? People do that kind of stuff all the time. Additionally, you can sell your software as a service, and never give the source away at all. 2. Open sourcing your code protects you from this. You let the whole world see who wrote it and when. If you have an active github, showing you built this over a period of time, pretty hard to argue it wasn't your work. At the end of the day, source code is the HOW, not the WHAT. You mention you have great ideas, and I'm inclined to believe you, but it doesn't really matter how those great ideas are implemented in a repository. The only thing that matters is if you solve someone's problem. If your CRM meets some kind of market need, and businesses all of the world say, "WOW, this guy got it right! We're so happy!", I assure you, monetizing the thing will be the least of your problems. If you need MORE examples, look at the classic big software suites that are moving to service based. MS Office? Available as a Service. Adobe Creative Suite? Available as a Service. When you're shipping software today, It's either behind a paywall (service), or it's open for everyone (open source).
I found Flight a pleasure to work with. http://flightphp.com/ 
Zend is bringing results for Zend Studio, Zend the company and Zend Engine
&gt; Phpunit is ~~acceptable~~ mandatory There, I fixed for you. :) 
Ah so it's not semver, great.
Tech people on Twitter depress me, it's all wonderful jobs I can't get, awesome meetups I can't attend and traveling I can't afford to do. 
&gt;I hope we don't count PHPUNIT as a dependency! If it's a dev dependency it doesn't count.
Silex is pretty fast, Symfony based and version 2.0 came out a week-ish ago. Granted, raw PHP will always be faster (unless you use a ton of libraries in which case I don't see a reason to skip a framework that can make your life just a tad easier).
https://www.google.com/trends/explore#q=php%2C%20Nodejs%2C%20%2Fm%2F0bbxf89&amp;cmpt=q&amp;tz=Etc%2FGMT%2B5
Why not use SugarCRM?
I've been working on [JSON Guard](https://github.com/thephpleague/json-guard), a validator for JSON schema. I originally depended on guzzle for resolving remote references but I removed it in favor of a simple curl implementation. I will make a separate package for the guzzle loader if I end up needing it. I would have used a separate package for the JSON pointer implementation but I couldn't find one that supports php 5.5 and can traverse objects. I wrote a [cli tool] (https://github.com/yuloh/json-guard-cli) which depends on silly and symfony console, so that's a separate package. Of course I have a few dev dependencies :)
Since you don't need routing, I would skip the framework. I'm not sure how you would use the router internally like you mentioned, but you can probably accomplish that with something simpler and faster. It's nice to have an HTTP abstraction for testing and ease of use, so I would pick HTTP foundation or psr-7. If you go with psr-7 I wrote a tool called [crux](https://github.com/yuloh/crux/blob/master/README.md) which lets you write a single handler for your app. It's just the HTTP and middleware part of a micro framework. If you go with HTTP foundation check out stack php. Both solutions let you use middleware which helps keep your code organized. Any HTTP abstraction is going to be slower than raw php. Just depends on how much you value raw speed vs sanity :D For cli tools silly is awesome. It's way less painful than using symfony console alone. 
A lot of reasons, unfortunately. * The WordPress core development team largely doesn't care about security (Dion Hulse being the big exception to that general rule) * A culture that encourages stagnation (PHP 5.2.4, etc.) * A culture that encourages the use of loaded terms like [responsible disclosure](https://adamcaudill.com/2015/11/19/responsible-disclosure-is-wrong) which is every bit as arrogant as it is anti-security-researcher * A culture that values adoption rates (quantity) over excellence * Low barrier-to-entry combined with poor quality controls (unless you count popularity, which assumes Sybil attacks aren't a thing) Any of these things in isolation can be bad for security. All of them together is a recipe for repeated disaster.
Or a severe case of NIH syndrome.
Probably the day before I found composer. I really have no desire to re-create the wheel.
https://github.com/paragonie/constant_time_encoding/blob/master/composer.json Only requires PHP 7 (plus phpunit for testing) I found Sc00bz's work and decided to modernize it and release it under the same license (MIT). Then I refined it a bit, removed a couple more sources of possible side-channels, and now it's stable. What is it? It's an alternative to `bin2hex()`, `base64_encode()`, etc. that transforms data in constant time. This makes it more suitable for encoding/decoding cryptographic secrets than what PHP offers natively.
I can't remember the last time I ever thought of provisioning a memory cache in megabytes. If you're worried about the 65th megabyte, memcached isn't going to work for you, and storing sessions in a database is fine. However, for non-trivial workloads, storing your sessions in a database table is a big anti pattern and is to be avoided. 
https://github.com/sgolemon/table-flip I'm adding this as a dependency to *everything* now.
&gt;However you will find that in practice PHP salaries are shrinking and the quality of job openings are getting worse too (less capitalized companies offering worse work contracts)... This.
Wow. Thank you. 
[removed]
Idk if you checked the docs since it all kind of vecomes obvious: Preamble: PHPixie uses factory classes ecerywhere, the container is an optional component, that exists to give you options. If you want to use it like a regular container you can, want to use it as a static locator, you can, etc. The static call support causes your points 1 and 2. Why do I support static calls? It seemed like a nice feature that someone may find useful if they use the container as a service locator. 3) allowing method calls via container makes accessing dependencies easier. Instead of registering every other component in the container I can now just register the components factory and access all components via get(components.orm). It saves typing time. If a dev decides to abuse it, its their choice. 4) I cant implement interop::get() for example because it is implemented via __call. If i change it into a regular method it will stop working statically(i wont be able to use __callStatic and will not be ablw to retrive proper lsb class name) 5) 5.4, but Ill make it support 5.3 too today. Why? Because its not like it requires any effort. Using array() is a personal preference. 6) the abstractness is needed so I can keep value(), callback() methods protected and thus only accesable from the inside of the class. The container cannot be changed feom the outside. 7) You cant use it without extending it. It can only be changed from the inside with protected methods. Ofc you can read config files if you like, but from within the class. 8) service providers imho break the nice structure of the container. Instead just register another container or a factory class as a service and use it via dot access. Since dot access to methods are supported technically any class vecomes a service provider, which allows me to do the above get(components.orm) 9. Ill add docblocks todY, but all the documentation you need is in the Readme file. You only need whats there
Yes, because it is an example value. What are you going to do when you need to restart your Memcached server?
The LRU is one of the problems. The memory is so cheap at the present time. What are you going to do when you need to restart your Memcached server?
I was thinking a lot about library design in the past month or so and i came to a conclusion that it's always preferable (more work though) to release a package with the library's domain logic that has minimum or none dependencies and then another package (the main one) that will depend on the domain and will contain the adapters and infrastructure. The main package will obviously have dependencies, but the plus side here is that the underlying package can be used even if the main package causes version conflicts or anything for someone - he will have to provide his own implementation of the infrastructure, but that's better than nothing, right? See my brain dump [here](https://medium.com/@DusanKasan/library-design-and-version-conflicts-367a1dcb9f3e#.32e1ywqfv). Thoughts? Also, to answer the question: - https://github.com/DusanKasan/Knapsack - https://github.com/DusanKasan/Chan (work in progress)
300ms for autoloading? That sounds like too much... Are you using Composer for autoloading? If not you might consider switching to it as it can bring the following performance improvements: * by default composer will try to locate the file of each class, since it's filesystem intensive it takes quite a lot of time (which might be the cause of your current issue) * `composer dump -o` will generate a "class map": an array associating all the Fully Qualified Class Names found with the path to their files (if you try to autoload a class that's not in the class map, composer will fallback to the filesystem lookup mentioned above) * `composer dump -a` will remove the fallback mentioned above. Since Composer 1.1, there's an optimization that makes this option very interesting: it makes the class map OPcache friendly, so if OPcache is enabled (`opcache.enable` should be set to `1` in your `php.ini`) you'll get even more speed I've had to work with a legacy project that runs on Symfony 2.0 which didn't use composer and had its dependencies commited in the git repo. Autoloading turned out to take ~200ms (similar to your issue). To improve it, I've installed Composer for autoloading purpose only by setting the `require` parameter in `composer.json` to match all the available namespaces (including the vendor ones). It solved this specific bottleneck (the next one was sessions).
Then increment the major version number? That's what it's for! Version numbers are not marketing tools, they're valuable indicators of compatibility ([composer docs have a good section on it](https://getcomposer.org/doc/articles/versions.md)).
This is still a discussion? I'm tired of it.
&gt; I would love to stop doing this. I really makes one sick to engage in this sort of argument I think that's what I find odd - of course you can stop. You seem to carry the zeal of a person who "knows" it is terrible, and you're willing to be unpleasant to a whole bunch of people in service to that idea, knowing that you may not have any success in that mission anyway. By all means, lurk in PHP threads and say what you like. But if you can make an effort to start off amenable, you may even find people willing to listen to some of your criticisms, even if they disagree with your broad message. 
I don't like what happened either but the guy obviously has nothing to do besides PHP, the things he did were a bit sad, but looking at some of the other voters I don't mind him having a vote. I mean, contao, drupal, eZ, HORDE(for gods sake), PEAR.. They all have a vote. Take a good look at the codebase, it doesn't look THAT bad. I woulnd't use it, simply because I need a very solid ecosystem, but for anything less serious it's not a bad framework. If you can't take it serious with ixie in it, you can't take it serious anymore without him also. So the question is, does it really bother us that he (probably, allegedly, whatever, lets assume he did it) messed with his stars/downloads. I honestly don't care that much. But yes, it becomes a problem if more people start doing it.. :\
Anything I use to test or prototype something. Most of the time its algorithms or a php function where I don't know what happens in specific cases. Sometimes it's a benchmark, it really depends. Anything that doesn't require maintenence or my co-workers don't need to see. **Tl;dr**: Prototypes and toolbox
That shirt is great
*Allegedly* messed. Just saying...
I don't think there's any chance of you actually taking any of the advice you've received in this thread on board (despite your earlier protest about the criticism not being constructive). But if you do choose to listen, I strongly recommend reading this document back to front: http://symfony.com/doc/current/contributing/code/bc.html You should warn your users (the real ones) to **never** use a "\^3.1" or "~3.1" version constraint in their composer files. They should **always** use "3.1.*" or whatever.
Try yii2. It has modules and extensions support out of the box. 
Good news, it seems that /u/dracony has finally learned his lesson! Now that he's not writing any more spam bots, he's been able to dedicate more time to quality code! And by the looks of things, it's working well - the [GitHub stars are rolling in](http://web.archive.org/web/20160526084637/https://github.com/PHPixie/Project/stargazers). Now, people might question some of those accounts, as they were all registered a week ago - but if you look closely, you can see that most of them fork the tensor flow repository. And why would a fake account bother forking a repository? Don't listen to the haters dracony, good work!
&gt; The ~ operator is best explained by example: ~1.2 is equivalent to &gt;=1.2 &lt;2.0.0, while ~1.2.3 is equivalent to &gt;=1.2.3 &lt;1.3.0 I really see no problem with it. With * you can still get a buggy version installed. E.g. if 1.2.3 had a bug that was fixed in 1.2.4, constraining ~1.2.4 makes sure the buggy version won't get installed. The * can still install the old buggy version. So I really have no idea why are you saying this.
Nope. I had much more interesting things to do rather than re-inventing stuff.
Oh come on. Even you can't believe that now, can you. Why would I even do this on the next day of the FIG vote? This is somebody just doing the lulz. Anyway, it seems they are rolling back now, so github is banning them
Like I said. It doesn't have to be a full blown app. Example, not a php related piece of code, but I made up a checkers game for shits and giggles. It could be anything. Hell, even a little curl script for some small piece of info.
I don't break the actual public API. Also whoever runs update and doesn't run tests afterwards is asking for it anyway. If you check the ORM, none of the parts meant for users have changed since like half a year If I do it the semver way and also apply the idea that everything is part of the public API, every little change I make that has 99.99% of not even being noted by the user will require them to manually update the composer.json file and stay with outdated code. 
It's a great article and one that shows you've got some experience behind you, demonstrated in a measured approach to change management in the software life-cycle. I wonder if you have experimented in switching runtimes? I spent the entirety of yesterday switching various projects to HHVM in isolated environments using docker and vagrant. It seems to gain us between 10-60% so far. Now for about a few weeks of testing, then a month or so of testing... As long as you have strong operations team, it's a way of gaining speed without changing any code. It does sound to me like something prior to your systems architecture re-shuffle, but nonetheless, it's a way to maybe squeeze out a few more r/s, maybe with this you can hit 9k or 10k
You can test it easily on your own system. Clone it and run it. 300ms, it means 300ms for loading the classes, unless if it is autoloading or manually include. If you take a quick look in the test.php you will see that the autoload not need to do a lookup, it is always a fixed path to load from. So composer doesn't help here. I've done the test not on a high performance server. 300ms for 1000 files to include/parse sounds reasonable on mid-range systems.
Would "everything mentioned in the docs" count? 
Not even kidding, experimented with it a lot ( https://github.com/Ocramius/PSR7Session )
I think sometimes people are too quick to jump to pull in massive chunks of external code. It depends what you're building and where in the stack it sits, but if I had a penny for every time someone includes the entirety of Guzzle to make what can be done in a 10-line curl request, I'd have a measurable number of pennies and no idea what to do with them. Every library has a greater surface area exposed to feature creep than any composite application ever will. So the chances that any dependancy is over-engineered and more complex than you need for a given task is inversly proportional to the complexity of your task.
To be fair, they could just be bots. It makes sense that "popular" projects get fake stars since people are trying to make the bought stars look real by forking and starring projects that get a lot.
See for yourself. Get a monthly plan and cancel before the first payment if you don't want to watch it further. The videos are fantastic by the way, I recommend Laracasts.
Yes I watched them and found them very interesting. Don't know of any free or cheaper alternatives of laracast that have the same quality in laravel content. If you pick up 2 or 3 tricks or patterns that solve some problems in your future projects you already earned back your 9 dollar in my opinion. What are you trying to learn exactly? I can tell you if the videos contain the information you are looking for.
I am trying to improve my quality of code and explore new ideas about codding (programming). I am self-taught programmer, so I am missing a large portion of what programming is, and in the last couple of months I am learning about theory and practices (at least I try, job can eat a lot of time :/ ). 
It seems interesting. How about security? Is it secure? I can't make a remark much. Because I haven't tried it yet
If you can sell PHP code, you can sell a software-as-a-service. [Spend $99 on Spark](https://spark.laravel.com/) to get you a bootstrap SAAS app that will save you likely over 500 hours of development time doing it on your own. Btw, the irony here is that this is downloadable, unobfuscated code that you're being charged for.
_demonstrably_ messed. Just sayin. 
Thanks. I found [this](http://creolab.hr/2013/05/modules-in-laravel-4/) laravel HMVC tutorial that sounds good. Do you recommend that I start with laravel 4 or 5? **edit** On second thoughts, the [laravel way](https://github.com/creolab/laravel-modules) isn't full proof. If you had to run `composer dump-autoload` every time you add a module to your app, then what's the point? You can't just package and send your modules to your users like Drupal modules or Wordpress plugins since the dump-autoload can't happen automatically.
I've documented all the limitations and pitfalls of this approach, and it was audited recently too.
I'm self taught too and I learned a lot from it. Mainly the solid principles which I had caught glimpses of but never understood. 
The biggest shame here is putting all those who supported dracony and dracony himself with the likes Jordi (author of packagist, composer..) in the same group. 
The routing / app detection portion of Laravel Valet can't use any dependencies because it runs before your own application's Composer include and we can't have them conflict.
What a joke. Instead of being a symbol of progress in the PHP community, FIG is little more than by-law bickering and architecture astronauting at this point.
&gt; Does not sugar coat and are to the point "Jesus saves, mudderfucker!" `:-)` 
Dude you just made my day. I LOL'd so hard at my desk "architecture astronauting" is now my new favourite term, thank you :)
Agreed, there wasn't even the obligatory /s afterwards.
&gt; They fixed the md5($password) approach almost 10 years ago Actually they bodged it and essentially said "screw it, that'll do". Wordpress password handling is a joke.
&gt; We also didn't have the resources to educate them or have me manage their server. This could and should have been written into the contract with them. "At $XX an hour, I will maintain and patch your servers, handle deployment of code, and make sure its a smooth process". In all honestly with all the tools out there, it should have been a no brainer just to use something like Capistrano, Git, Frabic or FTP even on a digital ocean vps.
Yeah. They had a two-week voting period. And that started just two weeks ago. So the results are only just in.
No, I get that. It's just that typically a "useless use of cat" is when people pipe cat into something rather than using input/output redirection. So I thought perhaps there was some unknown (to me) cat alternative that could have been used here.
&gt; someone includes the entirety of Guzzle to make what can be done in a 10-line curl request Preach the Word my brother.
https://github.com/jsnfwlr/CastleKeep This morning...
Thank you! Looks like quite a big list. Will try to pick some.
And, stirring the pot again, even though already settled, solves exactly what? It's the only purpose of this thread.
LGTM
One I hate is array_multisort(), it's very useful but I never succeed in making it work in less than 10 minutes (it's damn too twisted to be easy).
Thanks :)
Don't judge me, but I had missed some functions/functionality that could have made live easier. - strtr instead of multiple str_replace, or one str_replace with arrays. - PDO can return an object of any given class (not just stdClass). It's not robust as a full ORM, but it's something. - (not related to PHP). use HMAC with a secret key instead hashing a concat containing a secret. 
[array_walk](https://secure.php.net/manual/en/function.array-walk.php) is a personal favorite because it tends to solve all the problems of the other various array functions and does so quite efficiently.
array_multisort does too many things and that's why the manual page is so huge. It's from a time before anonymous functions, i bet you can easily do what you want with usort or uasort.
Yeah querying config is fine in register, because config is bound in a kernel bootstrapper by reading a PHP file, way before even the first service provider is registered. It can do this because the application can import from PHP files without any other service providers being registered already. However, I'm not talking about querying config. I'm talking about querying the database in a service provider, and using the query results to register a binding. The conflict is that I have to do the database query in `boot()` (because querying the database relies on other service providers having been registered), but I need to register my binding that use the database query results in `register()`- but of course `register()` is always called before `boot()`, making this impossible.
BDFL of Kohana here... Lots of people still use Kohana in existing apps. There is still some development [happening on Github](https://github.com/kohana) but activity has slowed significantly. I absolutely would **not** recommend starting a project on Kohana at this point. There are plenty of better choices for frameworks now: Slim, Silex, ZF3, etc. Even Laravel is a better choice than Kohana at this point, though I have my own reservations about Laravel. Edit: If your project is "complicated" you might want to seriously consider learning Symfony. The learning curve is somewhat steep but ultimately gives a much better platform for good architecture. Symfony is the basis for other frameworks and will not fade away in the near future.
&gt; For all the negative points you made there are also positives you left out, complaining without proof or a solution is just whining for no reason. Without proof or a solution? I *tried* to make WordPress secure. The most I managed to do is get them to use a CSPRNG (which is a huge win, but only a small fraction of the issue). I don't complain about things without some skin in the game. What's the positive of their poor password hashing strategy? Compatibility with *insecure* systems? That's not a positive, that's a liability.
*even* Laravel? I still don't see why this sub has so much dislike for Laravel lately.
Just like plugging in a USB connector - Upright: doesn't fit - Upside down: doesn't fit - Upright again: AAAH now it fits
&gt; drupal, PEAR yeah, those small time projects have no place there!
Yeah. The FoxyCart shirts had been unicorns pooping lucky charms, however with the new branding switch to Foxy.io we needed to class it up a bit
/u/codenamegary has best description to Laravel ever: [https://www.reddit.com/r/PHP/comments/2sk19r/pick_one_or_more_frameworks_and_describe_them_in/cnq7u5k](https://www.reddit.com/r/PHP/comments/2sk19r/pick_one_or_more_frameworks_and_describe_them_in/cnq7u5k)
I've been playing around for a while, and I came up with a solution that does work, but isn't ideal. This utilises the `ServiceProvider::when()` method: class SettingsServiceProvider extends ServiceProvider { public function boot() { $this-&gt;app-&gt;singleton('settings', function() { return new Repository(Setting::lists('value', 'key')-&gt;all()); }); $this-&gt;app-&gt;['events']-&gt;fire('settings.bound'); } } class MailGunServiceProvider extends ServiceProvider { protected $defer = true; public function register() { // Note that because of the when() method below, we can be // certain that 'settings' has been bound already. $this-&gt;app-&gt;singleton('mailgun', function($app) { return new MailGun($app['settings']['mailgun_api_key']); }); } public function when() { return ['settings.bound']; } public function provides() { return ['mailgun']; } } class AppServiceProvider extends ServiceProvider { protected $defer = true; public function register() { // Note that because of the when() method below, we can be // certain that 'settings' has been bound already. if ($this-&gt;app['settings']['blog_enabled']) $this-&gt;app-&gt;register(BlogServiceProvider::class); } } public function when() { return ['settings.bound']; } } Although not ideal, this seemed to work. But then I realised not only do you have to defer and add the `when()` to all providers that directly rely on settings being available, you also have to defer providers that indirectly rely on settings being available. For example, a MailGun plugin that wants to register some behaviour with the `MailGun` class: // This will throw an error because when boot is called here, mailgun hasn't // yet been bound because it is deferred, and only bound when // SettingsServiceProvider has booted and fired the 'settings.bound' // event. As this provider isn't deferred, it is booted before // mailgun is bound into the container. class MailGunPluginServiceProvider extends ServiceProvider { public function boot() { $this-&gt;app['mailgun']-&gt;registerPlugIn(); } } // Deferring the provider until settings have registered will work, class MailGunPluginServiceProvider extends ServiceProvider { protected $defer = true; public function boot() { $this-&gt;app['mailgun']-&gt;registerPlugIn(); } public function when() { return ['settings.bound']; } } The downside to this is that if I have a few different providers all registering things with each other in their `boot()` methods, I'm probably going to have to remember to defer every service provider and add the `when()` method, or create an abstract service provider that does it for me that I need to remember to extend. And honestly, I'd really rather not have to do that. On top of that, it's not obvious at all why my `MailGunPluginServiceProvider` can only be registered when the `settings.bound` event is fired, because it doesn't directly need any settings. Every web app in the world has settings, why is this so difficult? Is every just not getting using these settings in the service providers and instead querying the database for setting values in controllers and service classes? Because that just seems wrong to me, in the same way why it's wrong for one of your classes to depend on and query the config repository; Instead you should be extracting out the bits of the config you need for the class in the service provider and pass them in via the constructor. I just want to do the same with my user configured app settings!
Can someone tldr this? 
[removed]
Glad to hear it Shadowhand, you've done some fascinating work! I really liked the minimalism and simplicity of Kohana framework that is rarely seen in php frameworks nowadays. It kept the spirit of CodeIgniter alive and still managed to add the newer PHP goodies like namespaces, PSR-0, etc. and even HMVC. I wonder why its activity has slowed down even though its so good.
Go with 5. No point in using a version that is 3 years old. Also there are a few packages out there that should do modular structure for you. On mobile right now so i can't find the links but there are a few different approaches. 
Same. And am well prepared to demonstrate _with actual code_ that it's **very easy** to write clean, testable, well-architected code on Laravel.
Laravel doesn't support it because my view is that if you feel you need "HMVC" then your controller's are doing too much and you should be using injected services in both controllers to coordinate that shared behavior. In other words I see HMVC as a code smell / anti-pattern.
Agree. Not only do I have a lower opinion of FIG, but of all the projects who were opposed. - Stash - Aura/Solar - PPI - Stormpath - eZ 
For almost every function I have to look up the order of arguments and the spelling: CamelCase, under_score or abbreviations? Does it return the array or change it? The list goes on...
I still lightly maintain a large size Kohana application. Would not recommend it for new projects, though. 
People are allowed to have unarticulated reservations, Taylor, and they don't demand demonstrations in response. With 10M+ downloads, and goodness knows how much revenue from Laravel-branded offerings (how many $M/year from Laravel Forge alone?) you have nothing to prove to anyone.
Well, a lot of people prefer more full featured frameworks as I would classify Laravel and Symfony. Personally, I like to use micro-frameworks like Slim and Silex because I don't really need all those bells and whistles. I prefer Silex to Slim but Slim is still a great option in my opinion.
My opposition, FWIW, was on the wording of the vote. The Group has no power to "nullify" a membership, and my concern was not with the faked downloads, but with sock-puppeting inside the group.
Whew, so glad to hear someone else say this. I thought I was the only one bothered by this.
&gt; beyond a certain size the cost of all the magic ... eclipses the savings Still interested to hear your critical opinion on [Atlas](https://github.com/atlasphp/Atlas.Orm), with all that spare time you have. ;-)
I've also just realised something else about my second example in the OP (conditionally registering a service provider that provides services and routes depending on the value of a setting from the database) - I use route caching in production, and if I did conditionally load a service provider based on a setting, it would mean that the routes that are cached will be dependent on whether the blog module was enabled or disabled at the time of running `route:cache`, which obviously will break things when enabling the module as the routes won't be available in the app until the next deploy. Looks like my original approach to this isn't an option then, and instead I'll always have to register the `BlogRouteServiceProvider`, defer the `BlogServiceProvider`, and add a middleware to all blog routes where I check the value of the setting to see if it is enabled or not. Unless anyone can think of a better way? This is a shame actually, because these modules (of which I'm using blog as an example) are usually configured once when the client starts using it and won't be changed again... this will many all possible routes for all modules being loaded on every request, even if they aren't using any of them.
Found my own answer, but here's a description if anyone else is interested. It's a ternary shortcut: http://sampsonblog.com/58/a-shorter-ternary-operator-in-php-5-3 
for me: http://php.net/manual/en/language.oop5.references.php
Even as a junior dev, if you've never run into the floor() function, you likely had a poor treatment of mathematics in college, and have not done significant programming on any of your own projects. I'd be skeptical of your capabilities.
A couple of weeks ago I wrote a directory viewer for our internal use. This was on PHP 5.2 so package options were limited or nil to begin with. I broke a couple of "rules" building it to make it easy (aka hid complexity) to use because I'm not always the one implementing it. 2 lines to get it going and tons of configuration options. Thinking about it now makes me want to rewrite it for modern PHP.
There's rote information, and then there's floor(). A function you'll come across in every programming language's math library, in mathematics, and in science.
Saw this recently in a code review and thought it was a mistake. I'm right there with ya...
It's better to compare Slim to other micro-service frameworks, { Sliex, Lumen ... etc }. Having said that, I am totally biased as I contribute to Slim on a regular basis. :)
Heard of these new things called IDE?
No offense but if it takes you half an hour to figure out `explode()`, I sure hope you're not trying to make a living of PHP development.
*facepalming hard right now* Thanks. Learned something today.
I'd argue you should explicitly return true to make it easier to read for other developers.
replied to the wrong thing boy that was weird.
Ok guys. Be ready to discover something 95% of reddit/php doesn't know. Php internals will hate me for exposing this secret. One month ago I was coding, chilling on some string output messages in a co-worker code, which always use " insteaf of ', " are really ugly IMO but whatever. I wanted to change his string, ok lets do this.. i wanted to put a '%', I left-miss-clicked an my finger pushed the '$' key. And here it is, one big strange moment. PHPStorm propose me some variable name list for autocompletion, i cryd, saying to my mac, "its a string, mac", but he didn't care, i could pick a variable, test, and... IT WORKED. Now, a month later, i was promoted to expert at string-variable concatenation, and I will reveal you for free my secrets. $one = 1; $array = [2, 'three']; echo "I can count, watch me. $one $array[0] $array[1], this one in letters, cause i roll over you" . PHP_EOL You can't use objects or arrays with string keys, remember, keep the secret guys!!
&gt; If you had to run composer dump-autoload every time you add a module to your app, then what's the point? You don't have to do it (be it Laravel, Symfony or any PHP framework). It is just required for production (and recommended with the `--optimize` option). 
Symfony is a micro-framework as well, you can just go with the empty edition instead of the standard edition instead (which is a full-stack one) ;)
You can. Wrap them in brackets: echo "This works with objects too, like {$object-&gt;test}" afaik However, this is slower than single quotes. Single quotes + concatenating the strings &amp; vars, as double quotes have to be parsed, and single quotes don't.
Can't wait till PHP 7 works properly and easily as an Apache2 mod: $var = $_GET['var'] ?? 'default'; I love that
Honestly I've never once used this, as the only times I've needed it is for arrays, and that will give a notice when the array key doesn't exist. Can't wait for PHP7 to be more popular so I can use `??` (null coalesce operator).
The speed difference between different methods of string concatenation are completely negligible in basically all modern contexts. Readability is far more important. 
Careful with that. The `?:` operator **does not check for `null`**. Instead, it checks if the left-side expression is "falsy". So these are equivalent: // Short ternary $result = $foo ?: $bar; // Ternary (expansion of the short version) $result = $foo ? $foo : $bar; // Equivalent expression if ($foo) { $result = $foo; } else { $result = $bar; } Luckily, a `null` value is equivalent to `false` in PHP's loose/dynamic comparisons. [However, there are pitfalls to comparing loosely like this.](http://php.net/manual/en/types.comparisons.php) It's definitely a useful tool, but you just have to remember to be careful with it and really understand what you're doing when you use it. However, [PHP 7 actually has a **proper** "null coalesce" operator](https://wiki.php.net/rfc/isset_ternary), that not only checks for `null` values, but actually does the equivalent of an `isset()`, so the left-hand expression could technically even be "undefined". Just figured I'd pop in and save you some potential headaches with this info. :)
I think (hope?) it can still be saved. There's still a lot of potential for good, but things can't go on like this. Looking forward to V3.
&gt; To me "Hydrating" is not appropriate word for filling model with http request data. Hydration is the process of populating an object from a set of data. [Quite a few popular frameworks/libs/langs use this term.](http://stackoverflow.com/questions/6991135/what-does-it-mean-to-hydrate-an-object) **Incoming** simply uses hydrators for a particular purpose, but it's not an invalid or inappropriate use of the term. :) &gt; Look at symfony/serializer and it's normalizers. It does almost the same thing. There are many names for serialization, deserialization, marshalling, unmarshalling, encoding, decoding, normalizing, denormalizing, etc. Some of them have very small semantic differences, absolutely. It's all up to the purpose/domain. Even still, it's largely a matter of choice.
Slim is a micro-framework, whilst Lavarel and Symfony are more fuller frameworks. You'd compare Slim or Silex or Lumen. That's a subjective one. I used Slim instead of Silex for something by accident, and well, the application survived well. 
How about for variable names? PSR-1 seems to be agnostic on that. 
Well that's good to know, but I think I'll be passing on it for now :/ I don't normally have a problem with traffic, but I might have 15GB of data that needs to be imported and normalized in different ways and reports on that data need to run in a reasonable timeframe, and all I have is one generic Apache server that may or may not be on shared hosting. It's all on me to get the best performance out of the code, and that means I take any optimization I can get. Mostly it means writing giant SQL queries. So I'm sort of stuck. The microframeworks are too micro, because I still have to make a website, but whatever I use has to be pretty quick so the bigger frameworks aren't suitable. I need something in-between, and it seems such a framework doesn't exist. [added by edit] seriously? downvotes because I don't want to use one framework? This sub, seriously...
I didn't know about the ... argument syntax. Woahdude!
I would think one has to take the usage into consideration in terms of evaluating the level of security, as you know public use will go down and expenses go up the more levels of security you add to any system. Thus it should not be used for anything critically important, the reality is it's a lot cheaper to recover a backup then lock down and manage security at a high level. I don't expect my house to be as secure as a bank and I don't expect WordPress to be secure enough to host a banking website for the same reason.
In your defense array_column started like in php 5.5 or so.
 find | grep "name"
&gt; I would think one has to take the usage into consideration in terms of evaluating the level of security, as you know public use will go down and expenses go up the more levels of security you add to any system. This is actually wrong, for reasons that are totally counterintuitive. [Many security trade-offs are illusions](https://paragonie.com/blog/2015/12/let-s-re-think-security-trade-offs): * We need to sacrifice security because cost. * We need to sacrifice security because performance. * We need to sacrifice security because usability. Competent engineering can make security cheap, fast, and easy-to-use. You don't need a $100,000 box to stop hackers, just educate your developers. &gt; Thus it should not be used for anything critically important, the reality is it's a lot cheaper to recover a backup then lock down and manage security at a high level. I haven't had a code injection vulnerability surface in *any* of my projects in over a decade (and people do try to hack them), because I taught myself how to write secure code. It actually isn't that hard. [My company's blog covers a lot of this topic](https://paragonie.com/blog/category/security-engineering). &gt; I don't expect my house to be as secure as a bank and I don't expect WordPress to be secure enough to host a banking website for the same reason. I don't expect WordPress to host *anything of value* or reside on a sufficiently beefy server. 
Understood, thanks!
Eh, uhm… quite efficiently is well (function calls are expensive!)… why don't you just use foreach? The useful one here is really array_walk_recursive(), as it avoids you to manually write a recursive function.
You're entitled to defend Laravel until you're blue in the face. I was asked for my opinion and gave it. I will say that my experience with performance is [not unique](http://hybridlogic.co.uk/2016/02/the-hot-path/). And it really doesn't matter which ORM is faster, since in high performance applications you almost certainly should not be using an ORM all. 
Nice find but wow is it ugly. I'll stick to the standard search. 
No Silex is another framework built on top of Symfony Components, it doesn't share the same philosophy. You have an empty version here: https://github.com/gnugat/symfony-empty-edition and a REST API version https://github.com/api-platform/api-platform. Symfony, at its core, is just a glue between components, if you want a micro-framework, you can just not use any bundle. The standard edition is made to fit 80% of the use cases out of the box which obviously makes it much bigger than what you might need.
&gt; it's a lot cheaper to recover a backup then lock down and manage security at a high level. Yes, and I'm sure your users will agree when your site gets owned, the database dumped, and their passwords cracked. And, considering the number of people who reuse passwords... That's not how this works. You secure your shit, not because you care but because you have to out of an obligation to your users.
Yep, you gave an opinion that was misleading as if building your entire application around facades is your only option when using Laravel. So I corrected it. I made no mention of ORM performance so no idea what you're talking about there.
BUT, there's a [composer package for it](https://packagist.org/packages/rhumsaa/array_column) if you're still on 5.4.
Nice one! Very accurate.
Prove your words with some benchmarks first. hint: concatenation is slower
Right click on the search box, click "add keyword for this search", type "p" as the keyword, save. Now you can type "p strpos" in your URL bar, to look up if it's $needle, $haystack, or $haystack, $needle.
Thanks for the response! Yes I meant `-&gt;singleton()` not `register()`, thanks. That's what I get for typing ask the examples directly into Reddit rather than phpstorm first and then copying and pasting! Yes actually I think you are right. The reason I thought I couldn't use Eloquent in a binding factory is that I looked through every single one of Laravel's service providers, and the only external services that their binding factory functions referenced were `config` and `events`, and other services registered within the same service provider, but even then they are always registered in the correct order. Eg `service1` is registered, then `service2` that depends on `service1` is registered immediately after. Both `events` and `config` and bound way before all service providers are registered, so you can be sure that they exist. This made me think that the only services you can reference in your binding factories are `config`, `events`, and any services you've registered previously in that service provider. Now I think about it, of course you can reference any service at all, because nothing has yet been resolved out of the container at that point! This doesn't solve the issue of conditionally registering service providers based on database queries though, but as I alluded to in a different comment this thread, I've realised that that's not actually a great way to go about it, and instead I should defer the BlogServiceProvider, always register the blog routes, and then wrap the blog routes in a middleware that checks the `blog_enabled` setting, returning a redirect of it isn't enabled. Would you agree that's the best way?
People dislike symfony in equal measure ("too enterprise"), and Aura, for reasons of "Paul" as best I can tell. People are insanely tribal about their choices and like to find any reason they can to attack whatever they don't use in an attempt to prop up their own choices. It _honestly doesn't matter_ ... pick whatever works best for you.
I think that's why it's a secret search function, probably still in development.
&gt; Regulations don't prevent a criminal from opening your window Sure they damn well do. What do you think governs how secure things are? Regulations. All your crypto, has specifications (regulations). All your decent password hashing methods, all your best practices, these are the regulations that security is built upon. Trust me, if a window says that the lock is unpickable from the outside, that's enforced with regulations. If it isn't, then it's just snake oil.
F3 fans !!! :D
My biggest beef with camel casing is trying to decide how to handle acryonyms and ids. For example, if I wanted to get all ACL data for a given username, should the function name be getACLDataByUserID,or getAclDataByUserId? That being said, I typically camel case public attributes and methods, and use underscores (often with an underscore prefix) for protected/private ones.
The `ltrim`, `rtrim` and `trim` family to remove given characters from the start or end of a string. If I wanted to remove a trailing comma, for example, I'd previously always used `substr` in combination with `strlen`. After spending time looking up what order `substr` takes its parameters in, of course... it was all a bit of a hassle. Also, frameworks. I've only tried out Laravel so far, but after just a few weeks of learning I was able to recreate a site in less than two weeks that had previously taken about two months to code from scratch.
It's fast enough. If Lumen is your bottleneck I envy your traffic.
Or you know, just press ctrl+space in your IDE... Wait a minute, it does that automatically as soon as i type `strp` Technology nowadays ***mind blown***
Im surprised [`sprintf`](http://php.net/manual/en/function.sprintf.php) (and his twin `vsprintf`) isn't here. Damn I love that thing. No more long ugly concatenation.
For each and array walk have been proven to run at about the same speed. In the worst examples its slower by a factor of 4 so from a compsci standpoint that's fine. On top of that I've never seen the slow function call issue in PHP actually affect a real world problem because most people don't use PHP for its computing performance. The organizational benefits of having a function reference are also much more valuable to me. 
http://giphy.com/gifs/yes-rick-and-morty-jerry-smith-3oEduKfOrlQkQdebks
Best micro-framework. Zend Expressive comes in second for me. I'd choose either. It's aimed to experienced users or tiny apps. Silex didn't age well... and Lumen is just Laravel, with a different router and trimmed. People lying in the middle, I'd go for Symfony or Symfony a la micro-framework making use of that trait it's got to do this..
If it's an array function it's needle/haystack, if it's a string function it's haystack/needle, never look it up again.
Thanks for the tip, I'll check them out.
This sounds like a good way to solve that issue. It also means your routes will work well with the route caching.
It probably doesn't shut down everything cleanly, but someone should make a PR to at least do a `xdebug_disable()` if possible. I wonder if it would improve performance much. Speaking of composer performance, I'm going to plug [prestissimo](https://github.com/hirak/prestissimo), as it solves some weird proxy problems I have and also speeds up `composer {install,update}` by a HUGE factor due to parallelizing the prefetching.
no doubt, console goes nuts in debug mode.
the one where i am too lazy to even do that, and just search google. usually the first result.
&gt; People are insanely tribal about their choices... I guess it is human nature, but I'm not sure why that is the case in programming. I'm an old programmer, so maybe I don't understand the motivation.
The use keyword for passing extra variables to your anonymous functions. So you can write something like: $myConst = 10; $myArr = [1, 2]; array_map(function($val) use ($myConst) { return $val + $myConst; }, $myArr);
But what if it's `array_walk` or `array_map`?
Depends. Typically I would go for ACL and ID until you are dealing with Laravel (Eloquent) models which converts things like ACL into a table name of a_c_l. I fought it for a bit then just caved and went with something like Acl.
It's relatively new, not even a year old, and I'm just now getting it to "stable." Better website coming soon, I hope. :-)
Disappointing to see how many comments expressing cautious or potentially neutral opinions on the issue in question have been down-voted and effectively removed the this discussion.
to me, the most convenient method to look up a PHP function is just typing in the browser's address bar php.net/function_name
ACL = Acl. Otherwise it's unclear when you have more than one, see parseDBMXML for example.
Just use `sprintf`, goddammit.
[removed]
Does anyone know of any open source software built using Silex? Would love to see some examples. I only really know of [bolt](https://github.com/bolt/bolt).
Interestingly(?) the first two such decoders I find on google both fail with a "hello world" file I just sent to them. 
nice concept, but shows that developers should never try designing stuff :P
You could type `?` to see the entire help which also lists the available shortcuts. In addition to those listed, you can also use: - `up up down down left right left right b a enter` (_hint: watch the logo_) - `b o r k` - `r o t a t e [enter]` - `m i r r o r [enter]` - `I [space] h a t e [space] P H P [enter]` - `I [space] l o v e [space] P H P [enter]` - `l o g o [enter]` - `u n r e a d a b l e [enter]` - `r e a d a b l e [enter]` 
Why not inject it in the closure with 'use'? $router-&gt;map('GET', '/shops/[i:id]', function($id) use($serviceContainer) { $_GET['shop_id'] = $id; require 'go_to_shop.php'; });
I tried that, after initialising it manually, but I think that the problem is the way the rest of the code tries to access it (with the global keyword).
&gt; Can't you pass the container to the anonymous function using a use( $serviceContainer ) statement? That'd be a far cleaner solution then having to rely on globals. I actually did that, by manually initialising the $serviceContainer manually, but I think there might be some relation to how the included code tries to access that particular global variable.
&gt; Does routing have a security purpose(obfuscating/sanitizing request destinations?), or is it just for pretty URL's? Routing has many purposes. "Obfuscating request destinations" probably isn't one of them. If you're relying on that for anything, you're 100% screwed. Always assume that attackers can enumerate and even read your PHP source files. Among other things: * it saves effort in parsing input found in URLs * it provides a centralized location to enforce the format of that input * it makes it easy to substitute handlers for various URLs without having to rename a bunch of files (which would create a mess in your version control system) * it lets you see at a glance which URL patterns are valid in your application, which is useful in countless ways, including security audits
I'd like to do a follow up article on string manipulation. That's where I'd see `strtr` fit a bit more. But yeah, that's a good one that I don't even use that much :D
To make this a little easier, and to separate it from the web server, you can create a php-cli.ini file right along side your normal php.ini so that only command-line scripts are affected. But /u/fivetide's advice about using the -d flag is much more granular, and you could create a wrapper shell script (or an alias in your shell, i.e., .bashrc for bash) so that you don't have to supply the flag(s) manually every time.
I've read that, at least in 2.3, there was a hard-coded `ini_set` that sets the memory limit to 256mb. If that is still true, then I don't know if that can be ignored in the command line--in comparison to using an `.htaccess` to set the `memory_limit` using `php_admin_value`, which would ignore any calls to `ini_set` for the option in question. That being said, you could report it to the project as an issue and see what the developers suggest, and/or you could see if a different version of Symfony fixes the problem. A less-than-desirable work-around would be to write your own cache-clearing script that simply deletes the files from the caches, but then that would be extra code you'd have to maintain. Please let us know if you ever find the solution to the problem, and good luck!
Now that's a lovely function I did not know about!
All the time, I try to write atomically and a lot of composer packages tend to bring in everything and the kitchen sink. 
Cmd+T, php array_map, return
You mean downcasting [1]? [1] https://en.wikipedia.org/wiki/Downcasting#Example
**[Downcasting](https://en.wikipedia.org/wiki/Downcasting)** --- &gt;In class-based programming, downcasting or type refinement is the act of casting a reference of a base class to one of its derived classes. &gt;In many programming languages, it is possible to check through type introspection to determine whether the type of the referenced object is indeed the one being cast to or a derived type of it, and thus issue an error if it is not the case. --- ^I ^am ^a ^bot. ^Please ^contact ^[/u/GregMartinez](https://www.reddit.com/user/GregMartinez) ^with ^any ^questions ^or ^feedback.
TIL. I've always wrapped the variable in braces. echo "Hello there, {$foo['bar']}!"; 
I'm talking about the footprint.
Do you have any good Git must-reads? I'm concerned that I might be about to create an issue for myself. I have a large feature branch that isn't complete, and then a smaller request just came for a feature I can add in a couple of hours. My concern is that if I complete this small request and merge it back to master that I will hit conflicts when I complete that larger feature branch and try to merge.. or is that what rebase is for... I need to do some googling.. ~~edit: no, rebase is not for that..~~ 
so true, makes it more readable too =)
Subclasses can have more properties than the superclass – how can the engine automatically know what to put as values for those properties? This is a flawed design – there is not really a work around. You have to fix the design issue.
Which is something you don't need to do in PHP, because PHP's type declarations don't erase type information.
You should only need to change that value (using -d on the cli as others suggested) if PHP is running out of memory during the operation. Increasing memory_limit will not reduce memory usage, it just allows PHP to use more memory.
Microframeworks are micro because they only provide the HTTP bits. You can choose any other components you need to build the app you need. I'm a big fan of this.
I actually find it way harder to read
`final` `private function __construct()`
I love slim, but wish I could use it for more. The biggest issue I have is I'd like automated controller injection. In the skeletons I have to write each controller into the container with their dependencies. I would rather the router inject my container into my controllers and use it that way. Which is why most of my projects now use Laravel (RIP Lumen for apps). I'm looking into prototyping with Silex but I remember not being very fond of Symfony's syntax. The power of Slim was that it felt like I was in control, and the framework stayed out of my way. **Edit:** I worked on a [Silex Application Skeleton](https://github.com/bearlikelion/silex-skeleton) today and plan on using it for future projects. It seems to be exactly what I was looking for (after some work).
I dare you to tell that to Toby's face.
This is the approach I've taken for the couple of projects keeping 5.x BC. Due to where the new version was created, it may work out that e.g. 3.1.8 and 2.7.8 have feature parity where 3.y.z is a &gt;=7.0 line and &lt;=2.y.z is for &lt;7.0. The Readme then says which major versions have what requirements. This is fairly similar to how PHP itself does stuff, at least regarding bug fix releases 
Indeed. This is actually an awful idea for mobile sites due to limited client processing power. There's a reason that fully dynamic web apps (eg React) are encouraged to pre-render at least the first page. It may or may not get you more req/sec, but it won't necessarily feel faster to end users. 
i use string templates all the time when I can, its so clean and easy to read
Oh wow! Thank you so much for pointing that out! I didn't see that written anywhere before lol. I edited that section to mention it. 
After reading about Radar from pmjones below, I think I may just be another convert to this paradigm. :P
Top tips: - The fastest routers are server configuration files - You can probably serve a lot more content than you think as static files - Clients can do processing too - If you have to bootstrap your PHP application for each request you are wasting time ([see these slides](http://andrewcarteruk.github.io/slides/breaking-boundaries-with-fastcgi/))
What do you mean by "site could be automatically built and updated with something like Memio"?
Why not use a proper search server such as solr?
Well I guess I could do that, but then I wouldn't have a fun project to work on. 
 $string = sprintf("Hi %s, you are %d years old today", $user-&gt;getUsername(), $user-&gt;getAge()); $string = "Hi {$user-&gt;getUsername()}, you are {$user-&gt;getAge()} years old today"; Dunno, to me the string template is easier to read, especially once sprintf's start getting long in the tooth, or lots of processing is done in a single expression, a thing string templates forbid you from doing
Basically the digital equivalent of an intern. You give them a handful of design documents and they output working code.
&gt;The fastest routers are server configuration files. Would tossing everything into the htaccess file work?
It used to work! I'm not recommending it as something to do (depends on circumstances), but most apps that use PHP routers could sacrifice maintainability and portability for performance using server configuration files more heavily.
Tab, space, enter. All keyboard buddy. 
Oh I'm so glad to hear it. Let me know if you need anything else!
It's the other way around, and you wouldn't necessarily need to write any PHP. It's already being used by some frameworks to generate Tables and Models.
You're welcome! Always happy to spread my random trivia :)
The fastest site would be one that was made from static files. Generally this is not possible when there is any kind of querying or server side processing. So let's assume that you **do** have to do server side processing. Balancing maintenance with speed is the difficult part. To this end, I would: - still use composer to manage my dependencies, but use no autoloader of my own - use server side routing with static files for each endpoint - use PDO or a very lightweight PDO wrapper like Aura.SQL for queries - have immutable value objects for entities/models (because objects provide better long term consistency, and immutable because its safer) - use functional style code everywhere else
Just started playing Laravel for the first time, and `artisan tinker` launches a REPL like this. I never knew what I missing. So much awesome.
Today. I had to make a basic website with 3 or 4 pages. The contact form used curl to create contact details. I was tempted to try a JS framework but it's a Bank Holiday weekend in the UK. 
My $0,02. Been a happy php developer since 2002, but if performance is the utmost number 1 priority over everything else don't use php. Golang + ember/angular will get you the most bang for the buck. But it all depends on the user case. Imho a a javascript frontend and a pure php backend to talk to will give you the most flexibility for an optimised experience. Then you get the best of both worlds. Especially if you use a queue with some clever design your app will feel ridiculously fast for the user. 
Server side processing can be done in static files. Maintenance shouldn't be a problem with static files being generated and updated automatically. The real hurdle would be building the system that generates those static files.
Let me just chime in here, it's rare I get to thank people for their work. Kohana saved my butt on more than a few projects back in the day. It was my first framework. Thank you 
Ah, but it's not a sensiolabs products
For the record. I most definitely am a hater of Wordpress. Long Live BoltCM
&gt; but there isn't a one-size-fits-all answer to explain what that particularly developer did in that particular file ^ that is called bad practices.
By "static files" I mean HTML. 
Cheers, mate!
I'm not sure if you are a volunteer or paid but either way you're talking about something a developer will be able to do in less than an hour and will cost your company less than $100 assuming you get the right developer. The only way I would suggest you try this on your own is if this is actually coming from a widget that you can modify from the wp-admin area. If you modify the theme directly and this is not a child theme then any updates you apply to the theme down the road would cause this to be erased. This is me assuming you keep your themes updated. Lots of people don't though. Other than that we pretty much need access to your themes code to be able to tell you the right way to do it and at that point https://www.reddit.com/r/PHPhelp/ would be a better spot for this.
This is the correct solution 
I've recently started using duckduckgo, and they have some awesome search functions. You can search for php functions like this: !php function_name
&gt;but if performance is the utmost number 1 priority over everything else don't use php. Golang + ember/angular will get you the most bang for the buck. They really aren't, though. The fastest code is no code of course, but if you really need some request-time computing the fastest language is still open to some debate depending on exact definitions like startup time cost vs fixed cost of specific things vs something else but it'll almost certainly be C or Java. And the fastest JS is no JS, but if you really need some the fastest JS will be very carefully made JS that takes into account the relative costs of various means of manipulating the DOM or whatever.
&gt; Sorry for the harsh tone, it's nothing personal How can your comment not be understood personal? Try to rephrase it as a grown up, so that OP can have a constructive feedback.
I'm not a fan of micro frameworks for exact opposite reason. The point of using a web tier framework is to 1) remove boilerplate 2) create a common consensus on "how it works" between team members. My experience with micro frameworks is that everything is going to be reinvented using off the shelf components for e.g. for configuration, DI, directory structures, etc. You basically end up with a bit of an ad-hoc mess because you didn't had a clear picture when you started and you were eager to get something up and running. A "full stack" framework already does this for you. If I use Symfony and I hire someone who has Symfony experience then we have a common ground and understanding of the boilerplate, we can now focus on the specifics of the application. To me, developers who "love" micro frameworks often come across as guys who just like to "tinker" with stuff rather than building solutions to real world problems. Not trying to be judgemental though. :) 
I think this is a false dichotomy. A site built with a framework can be built for maximum performance and scale indefinitely using these kind of strategies: * Use PHP7 - it is much much faster than previous version * Cache data, pre-compiled views, sessions etc using Redis and MemCached (Memcached can serve cached content directly, so no need to even invoke PHP engine for cached content) * Cloud scaling - it is now simple for anyone to using auto-scaling to dynamically increase capacity on demand * Progressive loading - only load a minimal amount in the initial load and conditionally pull extra content in via client side as necessary * Micro-services to split your application into separate containers of functionality which can be load balanced/scaled/optimized separately. If you decide to implement your own application without a framework, you are going to end up spending a large chunk of your time re-inventing the wheel instead of actually working on the code that makes your application unique. Over time this means a larger code-base to maintain and more work to achieve the same outcomes. However, to answer your hypothetical - if you absolutely wanted to go down this path, you would be best to write the main chunks of functionality as compiled PHP modules (using something like Zephir). You could then write your actual PHP application as small, procedural only PHP files (with no classes and minimal functions), whose job it is to act as controllers which invoke the functions in the modules and templates to output the result. Optionally, you could use a framework like Phalcon, which is already compiled as C module: https://phalconphp.com/en/ - this would give you the best of both worlds. 
On Soviet Reddit, downvotes are upvotes!
To be honest - I have no dog in this fight. In other words I don't give a shit about it unless it changes throughout the code that I have to actually deal with.
How much do you make?
What about DJango vs Node? 
The people I work with are biased toward node, but that has more to do with their backgrounds. The python guys I know prefer DJango. Django is probably a little easier but you can do more with node 
Settings -&gt; reading -&gt; discourage search engines from indexing. Uncheck that
One that I discovered way too late was that var_dump() accepts multiple parameters. // Before enlightenment var_dump($foo); var_dump($bar); // Nowadays var_dump($foo, $bar);
That's a very neat macro! You should try submitting it into Laravel!
:D no problem
`logo` is used for what /u/Dgc2002 [said](https://www.reddit.com/r/PHP/comments/4l78sh/secret_instant_search_on_phpnet/d3lquft). Regarding the `unreadable`, you need to use `readable` first; `unreadable` will just reverse the process (_i.e: get back to initial state_).
I had to condense things a bit to get a readable title, and I think muffled a key point of the hypothetical. Assume you have a digital intern to do all the coding. You hand them Design files that work similarly to Migration files, and they do the rest. In this situation: Would the only priorities be security and performance? What would this site look like and how would it differ from a typical framework-based site?
I'm not sure what you mean with "maximum performance". Do you mean page load time? Do you mean least CPU cycles? Do you mean time spend in PHP? More importantly, what would be the goal? There are _plenty_ of scalable sites on the internet that use frameworks. Symfony2 is usually (unfairly) described as a slow framework, but it power some of the largest sites on the internet. The problem, I think, you're trying to solve is not one that depends on your framework choice, or benefits from any of your other optimisation steps. Frankly you could probably just have a Wordpress site, with Varnish in front of it, and it will most likely outperform any custom solution you try to think up.
&gt; Looks really nice, but please take that scrolljacking out back and shoot it. A firing squad has been commissioned and will deal with the scrolljacking shortly.
Buy a subscription to Laracasts. Also consider starting with laravel 5, unless you are forced to 4.2...
Okay... I genuinely laughed at this one.
I recommend you instead of hoping it all be forgotten, try to at least make amends.
Awesome, yeah definitely. What are a few providers you use?
No thanks
There are still plenty of realistic options that still outdo Go or massive JS frameworks, though. C might not be the best idea, but a lot of web projects with high performance demands are Java and coming in to the future Rust may take some of that market. 
I think it would be the best to meet while the lunch. I hope there will be a buffet or something similar? Edit: you can't miss me, I'll wear a white "InvoicePlane" tshirt
there will be food. a lot of it. just laying around, waiting to be eaten.
i recommend the [docs](https://laravel.com/docs/4.2) and [laracasts](https://laracasts.com/skills/laravel) (it's for laravel 5, but still worth it!)
im in there but not seeing a dev channel...
Yes, I'm an active developer there.
http://www.reactiongifs.com/r/lvar.gif 
Unfortunately it is useless if it is takes 30 minutes. :-(
Looks good, but the previous font was easier to read for long texts.
Here you go, this is for Laravel 4.x but I suggest you start with Laravel 5.1 LTS or 5.2+ https://laracasts.com/series/laravel-from-scratch 
Is there a low-carb version?
I avoid double quoted strings completely if not absolutely necessary or when avoiding them is too much work. echo 'Keep variables '.$off.' your strings!'; echo sprintf('Or at least be %s with it', $smart); Much cleaner code.
&gt; I just don't put variables in strings. No-one should.
you can leave "site:" out in google chrome
Currently at the [PHP 2016 Conference in Belgrade](http://conf2016.phpsrbija.rs/). Just met Phil Sturgeon... asked him to come back to /r/php and Reddit overall, but he was a bit upset at the whole CoC thing and decided to take it easy for a while. Very cool and fun dude, delivered a really great talk today :)
I don't have any scrolljacking here?
&gt; and Laravel is based on Symphony No. Laravel uses a few core Sym***f***ony components like many other apps and frameworks, and even then, it re-wraps or extends a lot of them to provide a much cleaner and more terse API. It is not "based" on Symfony.
You might have more luck in /r/phphelp which is meant for these types of posts.
Congrats! CakePHP is one of the early frameworks in PHP land. I learned MVC thru it and loved the scaffolding.
Yii has a pretty good tutorial that covers everything you mentioned except REST. 
Look into laravel tutorials. Even if you don't use the framework there are a plethora of best practices to be learned.
&gt; I've seen people use Slim library, however that style of programming confuses me (it's like Java, php and HTML merged into one). That style of programming is.... well....... "modern". If you're looking for "modern" tutorials but don't want to write "modern" code then I'm not sure how anyone can help you.
Yes kinda. Have a look at http://php-tk.sourceforge.net/
Yes you can, but why should you? It's not really a good choice. Check out Electron instead: http://electron.atom.io/ 
I think he wants to avoid frameworks. And write code from scratch. 
Even if there is one (phpGtk), you shouldn't use that. That is not for production. And maybe waste of time. If you want to build desktop app, learn programming language for desktop (.Net or whatever) or check out pyQt/pyGTK (like /u/argues_too_much said)
It's possible to do (you can check https://github.com/garak/electron-symfony), but like others suggested better use a different language for that.
I did just then. I generated the page. Works like a charm. I accidentally broke it by trying to change the login and name to use a username. Looks like I'll be looking into learning in-depth this programming language. 
Sorry, I didn't realise that this is how server side code is managed. I'll look into learning this language. :) Thanks for the insight.
I think the main thing about modern PHP development is that we no longer build everything from scratch without any library to help us. Instead most of us would build upon the work of others using what libraries are available using composer and packagist. If you don't want to get invested in a framework such as Symfony or Laravel, you could also go for a more direct approach with a micro-framework like Silex. This may suit you more: you pick the libraries you actually need. So you get basic request handling with Silex, you add Twig if you want templates, add Doctrine if you want something more than PDO, add Guzzle if you want to do HTTP requests etc. 
REST is also covered in the latest versions
https://github.com/gabrielrcouto/php-gui is an option.
Sorry I am busy.
I'd suggest Laravel, and even a subscription to Laracasts.com. It's more than worth it, and gives you a much better guide through things you could hope for! 
I keep that echo thing in mind, thanks. But I’m still not convinced to use `"` instead of `'` when having simple strings.
Symfony is also a microframework, and it doesn't need the so called MicroKernelTrait (which only enables you to configure services and routes in the AppKernel class instead of configuration files). See: https://gnugat.github.io/2015/12/23/symfony-micro-framework.html
Instead of eval, do echo.
This. "Choose the right tool for the job" is overrated, nobody tried all the tools to be in an objective position to know which one is best at what. And even if they do test all the tools, their views is always going to be biased by their own preference. It all comes down to you, or your team.
I just ran it through a debugger - if you request the script with certain cookie and POST values, it will eval the code given in those values (line 76.) Line 72 just seems to echo the PHP version and the version of the script itself. Nothing much to see. It executes remote code.
Probably something to the effect of "it's a web scripting language, which was originally designed to respond to an HTTP request not sit in memory for hours being interacted with by a user". Which is true. Whether it can still work well despite not being in scope of PHP's original design is a different matter, of course.
This is just one file out of several. They're all kind of obfuscated similarly so I suspect you'd discover more functionality if you analyzed them all. What debugger did you use?
Firstly, agreed. Good advice. Scripts like this spotted a lot since cookie-bomb php script era, it needs data to be posted to it to see how malicious scheme behind it works. There is an automation tool to inject and setting up obfuscation for the injection code, doubtfully the attack was logged well since mostly are exploited and designed not to log afterpwn, but please seek for unusual access during the similar file-time-stamp.
&gt; I am really quite surprised nobody has linked to PHP: The Right Way yet! because PTRW is more of a guideline, not a guide. PTRW tells you what you should be doing, not how you should be doing it. It can help increase your searches for specific things, but in all honesty there aren't that many good tutorials on how to write modern PHP the way people from /r/php expects people to know how to do. There's more articles on why doing X is bad (eg.: service locators) rather than having more articles on you should be doing Y instead of X because of this and this is how this looks in the real world. There's not a whole lot of that.
I played around with [WXPHP](http://wxphp.org/) earlier this year, and it is a pretty cool effort to port WX Widgets to PHP. However the extension needs to be compiled since it isn't (widely) available in Linux repos. Also the core dev has done some great work, but development has slowed these days, and there are still some stability issues to iron out. I'd love to see PHP be used more for this, but I think presently Python has much better support. 
This looks great `:-)`. 
&gt;lelelel wordpress is so bad its used everywhere llelelel. That's kinda retarded argument. It's popular not because it's good or secure, but because it has low learning curve. Also, most non-programmers doesn't want secure applications, they want something that works, out of the box and is highly configurable (by plugins). By the way indian programmers love Wordpress. And we all know how bad they are. Wordpress is like a deathclaw tongue - It's long, messy, and you don't want to get too personal with it, unless you absolutely have to. 
Out of curiosity, how'd you manage that?
One minor gripe I had was that I can't seem to set a custom paginator for Eloquent models. I think its because the Pagination classes don't have a service provider and Eloquent instantiates it directly (going from memory so may be wrong).
eh, if you are on ubuntu 16.04, it comes as default php installation and can be installed as easy as sudo apt-get install apache2 php7.0 and it works properly as apache mod
I know there's an app for android, that basically gives you a web-browser with a fixed page to load. If something like that exists for windows phone, you can definitely also use that app in win10. 
That is a interesting question. If a "green" travis/... build implies that is a information that could be appended.
What about doing it on something like https://3v4l.org/
I think the most popular projects already know about their runtime compatability. Anyhow a listing including "popularity" from stats offered by packagist is a cool idea.
How come unit tests can test this form from not being compromised?
I've once been told to use NodeJs instead of PHP, to create a long running process web application, because "PHP wasn't built for it". Oh the irony. Javascript's original scope wasn't to be run on the application side. This kind of thinking is highly limiting: PHP itself has been built using a programming language whose original scope wasn't to create other programming languages. Programming languages aren't tools shaped to do one job, they are Lego bricks that allow you to innovate and build whatever you want.
I want to add your [secure sessions](https://paragonie.com/blog/2015/04/fast-track-safe-and-secure-php-sessions) post to your list as it's something I've been trying to refresh my best practices for of late.
Oh, nice, when coming up with ways you might be achieving that, I hadn't thought of you doing it in a `__toString()`. Interesting
Sourceforge is a spam site now
As others have said yes it is possible, but no it's no a good idea. If you are interested in making desktop apps, have a look at C++ with Qt (especially nice for cross-platform apps), Python, or C# if you're focussing exclusively on Windows.
Use framework and have it all done for you.
There are programming languages created specifically to create programming languages (YACC for example https://en.m.wikipedia.org/wiki/Yacc). The C programming language was created as an abstraction of assembly.
Someone else already mentioned this, but you might want to check out github electron. You can take the JavaScript that you're already using on the frontend, and package it as a desktop app, which can "talk" to your PHP backend. But yes, you can build a desktop app with PHP &amp; GTK. However, using Github Electron would probably be easier and more practical.
Even in the web context, the JavaScript interpreter was designed to run efficiently over a long period of time. The design decisions for the php interpreter often make it better for the way it's most commonly used, exiting as quickly as possible. When you're making any piece of software, sure, you can use most any language or tool for it.. but it is foolish to use the wrong tool for what you're attempting to do. Languages are often designed to fill a specific niche, and if you don't correctly work with that, you're often wasting your time - which can be better spent making cool stuff working with the right tooling. For instance, you bring up the language chosen to create the Zend php interpreter. I'm assuming you're referring to the large C codebase it contains (C being a very general purpose language) - but the actual language parsing parts of PHP are written in YACC.. because they chose the right tool for the job.
PHP uses YACC for the parser.
An article which clarifies this position: https://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die
Cross-posted [here](https://www.reddit.com/r/webdev/comments/4ljjth/tell_me_the_best_language_for_desktop_apps_as_i/). 
I came here pretty much just to talk about the Laravel training videos, they have so much awesome shit from code to IDE use. Totally great for a first timer. 
I'd say a good quality would be knowing when to look for help when you don't know something.
As part of our hiring process we also send out tests and use them to determine a candidates skill level. My best advice would be for you to be realistic and honest. Employers know that you can use Google/stack overflow at work and we expect you to use it when testing your abilities. A junior level php dev wouldn't be expected to know all the built in functions inside out so do your research and find the answers. Any source code you submit that is not your own (i.e. you grab a snippet from SO) you should absolutely note that you did not author it and site where you pulled it from. It will show your honesty and integrity in your craft but will also show your potential employer that you're resourceful. At the end of the day what an employer is looking for is that you are capable of solving the problems they've put before you in a logical manner and that you communicate how you've done that.
I did interviews for PHP candidates at my previous job. You should not be expected to memorize the PHP docs and keep them in your head. It is 100% expected that all developers of any skill will simply look up the things they don't know. That said, if you just copy and paste the descriptions of each, that doesn't show the employer anything. To PROVE that you understand the differences, give your own examples of different input/output between the two functions, and explain why one might be more advantageous than the other in different situations (or that there might not be any meaningful difference between them at all). This demonstrates that you can not only do the research, but you know how to apply and understand the things you read. At the end of the day, they just want to make sure you're not a copy/paste jockey.
Didn't know that, my bad. My point was: all programming languages are general purpose. 
I don't want to risk it falling in the hands of script kiddies. (A skilled enough hacker to implement this won't be assisted by my describing it, however.) Basically: It had a known 160 character header, with multiple evals hidden in various locations. Part of the startup process would checksum this header compare it with a stored hash. If it didn't match, it assumed someone was trying to reverse engineer it, so it would trigger the "pwn the blue team" subroutine. Otherwise, it would proceed as normal. It probably goes without saying: with an IT person's `id_rsa`/`id_ecdsa` and `known_hosts` in hand, you can cause a lot of damage to everything they have access to. Especially if they have `sudo` access (or, in my experience, they just log in as root).
I'm sorry to be contrarian, but they aren't. Domain specific languages like YACC are programming languages but are definitely not general purpose. And just because you can use a tool to do near anything doesn't mean it's productive.
I was able to SQLi your form using 1' and benchmark(1, sleep(20)) and 0 = ' Use prepared statements! 
For my experience as a junior PHP dev, it doesn't matter that you look it up. I got the job with barely knowing how to code PHP. However I know **How to code** (and research relevant information). What matters is how you think, not how much you know by heart ;)
Thanks for all the responses, I would reply to everyone but it's kinda redundant.
You /can/ with WxPHP, but last time I tried there were some big threading issues. Probably resolved now, but I don't imagine the performance would be great.
Kinda dislike it: 1. Do we really need more array stuff? 2. Iterators are a must nowadays :-\
You need form sanitation badly. You app is wide open to sql injections. I don't know if this is the best article out there but it's a start. https://www.sitepoint.com/8-practices-to-secure-your-web-app/
How does this work?
Have you considered what happens when a large number of users share a single public IP address? 
I've used nw.js.. it's more about writing javascript applications.. but you can execute php cli. I've used this combination to do some limited php desktop apps.
&gt; Never memorize something that you can look up "[I do not] carry such information in my mind since it is readily available in books. ...The value of a college education is not the learning of many facts but the training of the mind to think." - Albert Einstein In response to not knowing the speed of sound as included in the Edison Test: New York Times (18 May 1921) Basically, the same message.
Didn't core decide years ago that they won't put into PHP anything that can be easily implemented in userspace, as shown in the RFC?
Laracasts.com is a good resource !
Interesting read, thanks. I wonder if the garbage collection issues were addressed at all in PHP 7?
Yep, it evals remote code. http://pastebin.com/JAeCJUgA The 'extra functionality' it has is a custom password hasher (instead of using md5 or something.)
Check out Patrick Louys' [no-framework tutorial on GitHub.](https://github.com/PatrickLouys/no-framework-tutorial/). It teaches you how, as /u/toolskyn said, to not reinvent the wheel and writing modern PHP code.
They aren't necessarily bad, people here call them an anti pattern because the common way people use them is to pass the service locator as a dependency which couples your classes to rely on this service locator object rather than using the service locator to make passing dependencies to other classes easier. Which lets you make your objects testable and easily reusable outside of this framework. Something along those lines eg.: Bad: class UsesPdo { private $pdo; public function __construct(Container $locator) { $this-&gt;pdo = $locator['PDO']; } } Good: class UsesPdo { private $pdo; public function __construct(PDO $pdo) { $this-&gt;pdo = $pdo; } } $container['PDO'] = function() { return new PDO(...); }; $container['UsesPdo'] = function() uses($container) { return new UsesPDO($container['PDO']); }; Feel free to correct me if I'm wrong though. &amp;nbsp; _(wrote this in a way of not knowing if the reader knows about this stuff or not)_
I see. Thanks
It is usable, but don't do this for sensitive data. To make it look nicer you can use mod_rewrite directives to translate e.g. example.com/index.html?page=5 to something like example.com/page/5/ (looks nicer to the user) If you want to transfer stuff like username/password, the best way would be to POST the data in the request body. Single page applications (SPA's) are all the rage now, but they're written in JavaScript because the browser doesn't understand anything else. Done right, they can make for a better experience - look into it.
I feel there's still no clean way to turn an array into a "dictionary" in PHP. I always find I have the need to take a zero indexed set of objects, and then re-key by the ID of those entities. That way I can do something like $section = $sections[$sectionID]; Looking up an element by a known/available key is cleaner and faster than looping or array searching to find it.
You mean something like this? $b = array_combine(array_map(function ($r) { return $r['id']; }, $a), array_values($a)); 
But thinking is themental manipulation of some chunks in your head. Without those chunks you don't have the means to think. 
Not really. Standard practice now would be to.use some sort of routing typically as part of a framework (see laravel / symfony etc) so instead of www.website.com?page=home you would simply have www.website.com/home klein is a nice lightweight router you can pull in with composer if it's just routing you are after. https://github.com/klein/klein.php
Have you considered using a modern PHP framework? You won't have to worry about things like this and it could save you a ton of time if you're still spending time building routing components
What does that do exactly?
wrong kinda page, buddy. the page you are referring to would be a parameter of an existing query. ie `/users?page=2` OP is asking about a much more basic thing that would be along the lines of `index.php?page=users` to stick with the `users` page analogy. This was popular before mod_rewrite and clean urls.
It is not usable and it is not a best practice. Take a look at modern the frameworks' routers.
Yes, Ive used laravel for my latest projects. But I went back to my old source code in my quest in making a simple PHP application and wondered if this way of routing is still used :)
Thanks, will look into this
While I won't be using drupal any time soon javascript isn't without its shortcomings either. The problem is only using php. The "if all you have is a hammer all problems look like nails" analogy applies here. Just use the best tool for the job. It does get tedious how the cool kids constantly poo poo php while not acknowledging the shortcomings of their language of choice. There was a time when php was awful compared to other languages, but we've come a long way since. 
&gt; Modern PHP with namespaces and all is now considered as horribly verbose and overly complicated by the forerunning developers who have in large numbers left PHP for the JavaScript realm. What? Namespaces and all the features that **real world** languages have had for years is verbose and overly complicated? Maybe you should switch to javascript...
A project is not cool because of the technology, but the problem it solves. PHP is another tool we have to solve problems. A crm is not the coolest problem to solve, so changing technology may make them feel good about programming, in the end it's still a crm.
There's a bunch of practical tutorials in the sidebar at /r/PHPhelp/. I like the blog one at the end, but I would say that - it's mine. Not a video though - they aren't so great if the author intends to maintain their tutorial over the long term. 
When dealing with very large arrays, for me a foreach block can be faster than function with a map/filter+callback. YMMV
here: [php][1], [mysql][2] [1]: https://www.python.org/ [2]: https://www.postgresql.org/
TIL that developers no longer use query strings to paginate their results.
Yes, but something more readable and more efficient than three array transformations.
I can't wait to build my next ReactJS app with no modules. Gonna save so many keystrokes!
It would be more efficient (and shorter) to use array_column (since PHP 5.5). $b = array_combine(array_column($a, 'id'), array_values($a));
&gt; I'm just supposed to attach a **word document** with my answers. lol run away ;-D &gt; just research and answer as if I knew the answer Probably over half of being a coder is being able to find out answers to things. We never really know everything leading into any one project, it takes R&amp;D to get right... If we think we have all the answers, we are wrong and mess up the project. Personally I google for needle and haystack of PHP functions every bloody time.
Nice! Didn't realize they had snuck that in.
http://labs.octivi.com/handling-1-billion-requests-a-week-with-symfony2/ the framework isn't the slow bit
I read articles like this, and all it makes me think is that we live in a world where TDD stands for "trend-driven development". PHP has a damaged reputation from the PHP4 to early PHP5 days, especially with the large number of people writing bad code that eventually became the top results for google searches, and we may never be able to shake that bad reputation, no matter how much improvement happens in the PHP space. But to be honest, I'd rather work in the stable, tried-and-tested PHP way, than spend my days jumping from sparkly-but-untested technology to untested technology just because it's whats new and what people are talking about on Twitter.
&gt; Not to mention everyone uses iterators nowadays. I'm assuming you mean a class implementing the array-like interfaces. If so, this is totally wrong. They're not even semantically equivalent to arrays, let alone interchangeable. A good old-fashioned array is very frequently the best tool for the job. 
"Namespaces, I'm out!" - Said no one ever. This article sucks.
True, i spoke too quickly on this one. Sorry. Sometimes (Most of the time?) we need arrays and the quick operations on small data sets they provide. Maybe with the addition of few functions, the pipe operator and short closures, sequential array operation will be more readable. Then we can more or less use the built in functions as a collection pipeline. That being said, at least to me, making the array an object (extending Traversable maybe?) with a new consistent interface of array functions is probably the best (although probably harder to push and implement) solution. Wouldn't break anything and we can be all sexy like Java's (or number of other languages's) collections. This would of course introduce a disparity between the array functions and the new array methods, but maybe it could pave the way for a BC in the future (argument order and inconsistent function names come to mind), while still providing the methods for the array object. I mean, i get why we ended up where we are now, with the quick and organic growth and all that, but maybe now that PHP is all grown up it's even time for a BC and a cleanup of stdlib? At least a partial one? Pretty please? Now i read the post and realize i got carried away. Oh well, will write a tl;dr 'cause nobody will read this anyway. TL;DR: Yup, we still need arrays. Maybe a bigger change to stdlib is in order.
I wasn't saying that it was. I'm just curious what a non-framework could look like.
I get the author's point. But why so passive-aggressive? Yup, it feels that we see the hype bandwagons every few months now. What the author fails to realize is, that the hype we see is just the vocal minority of trend hoppers excited about their new find. He should probably learn to take these hype trains less seriously as they are like 90% people excited about new technology and 10% technology bringing something new to the table. Not to mention some of the claims are entirely wrong. Like, wth? I think everyone using PHP as their go to web language thinks it's in the best place in years.
yeah lol I wonder if they tested it on mobile, it's just not usable
Laracasts or teamtreehouse
TBH I don't know how is the PHP Learning Scenario today. But I can guarantee that you can jump in directly into PHP if you know a bit about how websites work (browser &gt; http server &gt; php). Fear not my friend!
I would recommend learning how to use the command line. It's used a lot for modern php. Not being fluent with the command line made learning php a lot more difficult for me initially. There is a free course called learn the cli the hard way. You can also do a free code academy course. Edit: links http://cli.learncodethehardway.org/book/ https://www.codecademy.com/learn/learn-the-command-line
Linux server commands and basic HTML would be good. 
Conventions are debated. The real best practice is consistency. If you use a framework, follow their lead.
&gt; This approach requires no less than 4 lines of code. And no more than 4 lines of code.
I actually use array_change_key_case.
hello, world
I like this... this new feature might be something I'd actually use
What defines "easily"? The password _ hash stuff could be done in userspace. So could random bytes.
How databases and SQL work, and how SQL injection works (please, for your users' sake, don't build anything internet-facing until you learn about SQL injection). Also, how to structure a database in terms of tables and columns; research normalization and normal forms to learn about this. In my experience, this is an important part of building PHP applications where I've found most inexperienced PHP developers to be sorely lacking.
Also note this type of coding is looked for by bots that then set that page to external txt file to include and then execute php. For basic stuff you can use that as a variable into a case statement instead of having it open ended. But long story short this is also common coding methods from over at least 12 years or more. A framework or cms is far preferred.
Find a small open-source tool and try to figure out how it works. Maybe change something you don't like or just try fixing a bug that's on the bug tracker. If you don't get totally lost trying to follow the flow control of unfamiliar code and constantly looking up documentation for unfamiliar functions, you're in good shape to start. Those are critical skills for learning and working on any codebase, really. Also, http://www.phptherightway.com/
nope, jump right in. In all seriousness though, seriously, just jump right in. PHP is one of the easiest web languages to jump into. on windows? grab a copy of XAMPP and get to it. Grab some cheap shared hosting to host your shiny php scripts and your laughing. on *nix? install php natively, cd to your script/site/app, type `$ php -S ` and boom! your up and running without a server :) 
I do know entry level HTML... unless we're thinking of something different. :) 
I benchmarked this while writing the RFC and found that `array_change_keys` was significantly faster than `foreach`, although it's entirely possible that my benchmark doesn't represent all possible cases.
You need the command line for what exactly when coding PHP?
Ahhh. Ok. I'll look into it. :)
Nope, just wasn't sure since you only mentioned CSS. You're good to go then, go forth and write code. I have always found it way easier to learn something when it is required for a specific goal rather than just googling and trying to learn anything you might need to know at some point. It's like tools, buy them as you need them for repairs. 
Well, if you have a decent idea of how OOP works already, then just starting to hack away on something is a decent start - you'll pick up the stdlib quick enough. I suggested going at an existing project as a way to see OOP in practice. To this date, I still haven't found a good beginner's tutorial that I'd recommend (they usually mis-judge past knowledge, or add in all sorts of unnecessary or inaccurate info while leaving out really useful stuff)
I don't agree that knowing the command line/terminal is required to get started with PHP. Most of our junior developers at work can't use it. Anyway, in "modern" PHP, tools like Composer, [Artisan](https://laravel.com/docs/4.2/artisan) and [Symfony Console](http://symfony.com/doc/current/components/console/introduction.html) is run in the terminal.
Like encryption, everyone can make a CMS that they themselves cannot break. Make sure you're facilitating that knowledge with real-world applicability, such as using a more advanced system like Drupal. If you're not using a CMS, dunno why you're on wordpress.
&gt; I'd much rather see some basic datatypes like fixed array being optimised I agree, there are other more-important improvements that can be made to PHP. I unfortunately don't have the expertise to implement those, otherwise I would try to put my efforts there. Just trying to improve the things that I can :) &gt; If PHP array performance is a must for your application then maybe PHP isn't the right solution for your use-case. Performance is a nice benefit of this RFC but its not the primary one.
I find myself needing something like this every week or two.
To add to what /u/spin81 mentioned, there is still a ton of old code out there using the mysql extensions. Don't just blindly copy and paste. Update it to use mysqli or pdo.
I guess git and composer. 
Installing PHP with apt/yum/brew, editing php.ini, disabling/enabling xdebug, running scripts in psysh, using composer, updating nginx or apache configs, serving files with php -S, checking error logs, using httpie or curl, fixing permissions, editing /etc/hosts. I use it all the time. Of course it isn't strictly required. You can use XAMPP/MAMP or something but I think spending a week learning the basics of the CLI will make you a lot more productive.
Well I'm not going to say anything about the javascript bit, but PHP's namespacing does leave something to be desired given it didn't go with the much easier to deal with situation of importing *is* namespacing which is the way most relatively new (Let's say past 20 years) languages have done it. As it is PHP has the `include` and `require` functions to try and do importing - and then autoloading solutions as an alternative - and then name spacing as well. Implementing only `include` and `require` made sense in PHP's early days of being a templating language, but it's a meh solution for a general-purpose language. Since the concept of 'modules' doesn't really exist you can't make the namespace code exists in implicit, and therefore you have to set the namespace explicitly when you want to put things in it, and you may have to both load and muck about with namespaces separately. It is a bit of a hassle, and it's one of those things that now, for backwards compatibility reasons, is unlikely to ever really get made a bit nicer. import foo; import bar from thing; $x = new foo-&gt;SomeClass(); $y = bar(); You can't tell me that wouldn't be nicer with a defined module system that meant it wasn't ambiguous how PHP should look for `foo` and `thing`.
If I was going to do this for a serious project, I would write a javascript front end and pack it up with electron, then write the backend in PHP and host it on my own server. That's how the slack desktop app works. If I was doing it for fun and couldn't use a remote server I would still use electron. You can bundle the PHP app and have electron start it, but the user will need to have PHP already installed on their machine.
I was looking all over for this, thank you! I guess I forgot to star it. Probably the only GUI library that is just a composer require.
mod_rewrite... look it up!
the practice of using ?page=about and such seems to have died down a bit, people mostly use some sort of routing library or framework that allows you to create urls that are like this /page/about or just /about. this stems from the shift in web dev from the "page controller" pattern to the "front controller" pattern, everything is MVC-y now, very rarely do you see anyone advocating for single php files scattered all over to create your website.
I can totally imagine a bunch of Php programmers, who doesn't buy into Composer hype, git hype, SOLID hype, Laravel and symphony and 'Php the right way' hype...They are happy with their version of Codeignitor, i'nclude_once's and date stamped version control files.... Within themselves, they probably says something like this to each other, while gushing over the new Codeignitor library/update... &gt;it feels that we see the hype bandwagons every few months now. What the author fails to realize is, that the hype we see is just the vocal minority of trend hoppers excited about their new find (SOLID, Laravel, Composer, Git etc). He should probably learn to take these hype trains less seriously as they are like 90% people excited about new technology and 10% technology bringing something new to the table....
Divorce.
&gt;PHP is another tool we have to solve problems.... A vastly inferior tool...
Or better: $b = array_column($a, null, function ($key, $item) { return "newkey-{$item['id']}"; }); In case a new key would need to be computed from old key.
&gt;PHP is one of the easiest web languages to jump into. Python is not much different. import SimpleHTTPServer import SocketServer PORT = 8000 Handler = SimpleHTTPServer.SimpleHTTPRequestHandler httpd = SocketServer.TCPServer(("", PORT), Handler) print "serving at port", PORT httpd.serve_forever() Everything required to start a web application is built in (I believe it had it even before Php had a built in web server) 
Is thing open source?
I don't know how it works in OS X, but in most recent Linux distros it will just ask if you want to escalate privileges when trying to open a file you don't have permissions to. There's no trouble in learning it — it's like doing all other file operations. Besides, none of that is actual programming — that's more in the sysops department. As I said, knowing CLI will help you tooling-wise, but if you can't program, there's nothing to do in CLI anyway.
Usually `&lt;?php`
Yeah, it's just like material things; "Ohh myy gawd, that celebrity is using an iPhone so I must have it too". The problem isn't the phone, it's the purpose.
We don't need it in the core. You always can implement such functions in userland and distribute as composer package.
You may learn HTML and CSS first, to present the result of your PHP code. Then you look for some simple PHP tutorial such as login system. After that you try more complex system. Finally you may learn some framework to help you finish your projects easier.
I think for me it was miles easier to understand programming because I have a fundamental understanding of the theory behind programming. Sure back this up by learning a language but I'd recommend not just copying out pages of code from a tutorial website, but go learn what the theory is behind arrays, variables, functions etc.. Then you can apply that knowledge to PHP. It will allow you to think through a problem logically, which is just basically what programming is (problem solving). But it will also allow you to apply that knowledge to any programming language in the future.
A lot of people run them in phpstorm, or maybe someone set up a ci server for them
My DO droplet is still on 15.04, actually upgrading as we speak. Had PHP7 compiled myself -- it would run command line (php -v gives 7.1-something), but not as an Apache mod yet. 
SQL is worth a much closer attention. In a way, PHP is just a proxy between a browser and a database. Most of the logic is performed in the SQL. And SQL is not only a language but also a database design. While SQL injection is a simple thing that in fact is just a by-product of improperly formatted SQL. You can forget about it by means of following a very simple rule: every bit of SQL statement have to be hardcoded in your PHP script. That's all. If you need to add a variable to your SQL, and it cannot be chosen from the hardcoded values, simply represent it with a placeholder. For the learning purpose, [PDO](https://phpdelusions.net/pdo) is the best choice for the database interaction. 
Very good. Especially the start, regarding best/fastest and reading/writing, can be applied to any language. 
Thanks for your in-depth answer! Cleared things up :)
I used to teach programming and noticed that students that paid more attention to the fundamental concepts did WAY WAY better than those who just cared about the code itself. The best advice I can give you is: learn everything you can about the **request/response life-cycle**. The web is simply just that. A machine requesting information from another machine and having that information delivered via a response. Once you understand the request/response cycle, you should go on to learn about what **web-servers** (the software) actually are. Is a web-server any different than an FTP server? What is a server? what is FTP and HTTP? Basically, understanding how information flows between machines and how applications deal with the information itself will make your programming 10x better and you will be able to understand more complex concepts with ease. Once you understand these fundamental ideas, which IMO **shouldn't take you more than a day or two** to get into, you can go on to programming itself. **Once apache (the web-server) hands PHP a request, what happens**? well, that's what web-applications are. Start with that and you keep on improving by researching more and more complex concepts. 
&gt; Installing PHP with apt/yum/brew, editing php.ini, disabling/enabling xdebug, running scripts in psysh, using composer, updating nginx or apache configs, serving files with php -S, checking error logs, using httpie or curl, fixing permissions, editing /etc/hosts. I use it all the time. We're talking about entry-level PHP for beginners. So basically it's *code, Alt-Tab, F5, Alt-Tab, code, ...*
You should know HTML and CSS, obviously, at least if you want to create websites (what I assume you do). After that, dig right in.
I don't agree on that part, fast isn't always intelligent. look at the examples in the blogpost
Honestly, WordPress isn't successful, because _the codebase works okay_, it's successful, because most people don't realize (read: _aren't competent enough to see_) what kind of monster it is. Just look at the constantly hacked wordpress sites as soon as you install one single plugin. You may say it's the plugin developers fault. But tell me, why doesn't WordPress have a secure plugin system then? Other CMS are able to secure their plugins mostly correctly (Let's not talk about bulletin board software here) since they provide easy abstractions for the common stuff. WordPress is a bunch of userland-functions and PHP4-classes that are put in a completely unlogical folder-/file structure and it's a wonder why its still working up to this day without exploding constantly. Only when every single WordPress site has finally been hacked down, only when millions and millions of developers actually looked at it and told you: _this is a shitty codebase_, only when millions and millions of dollars have been spend on overly-complex templating mechanisms and coders that "unhack" your WordPress site (Dude, I make good money with this, not even kidding), only then will people finally realize: **WordPress is a piece of garbage and shouldn't exist in a modern world**.
I suppose that was a bit of irony. A pro always tends to write a shorter code, but where is the limit? Recently I wrote something that I called "A Singing Elvis": $data = $data ?:[]; and still in doubts whether I should use all these shorthands or not. 
I'd recommend relational databases over NoSQL for beginners every time. The structurelessness of documents (say in Mongo) is a great way to shoot oneself in the foot, and joins seem to require lengthy for-each constructs in JavaScript iterators.
Just saw this. I'm around today too. Happy to grab lunch together. :) 
Looks like shellcode, will check on this in my free time. ------------------------------------------------------------------------- 0x00000000 5070 7ba4 53e5 f4a3 3712 f7d6 3566 87c6 Pp{.S...7...5f.. 0x00000010 f6d5 95b3 5783 2583 a526 e654 d34d 2d74 ....W.%..&amp;.T.M-t 0x00000020 5349 2c2e 9515 e556 93d3 77a4 6543 b7e3 SI,....V..w.eC.. 0x00000030 c446 7603 85c2 1246 24b4 c437 7664 f2b4 .Fv....F$..7vd.. 0x00000040 e416 a572 8422 6252 7406 c733 0222 05d3 ...r."bRt..3.".. 0x00000050 13f7 6793 95a2 a616 b647 2472 9364 8752 ..g......G$r.d.R ------------------------------------------------------------------------- 0x00000000 50 push eax ,===&lt; 0x00000001 707b jo 0x7e ;; // unk | 0x00000003 a4 movsb byte es:[edi], byte ptr [esi] | 0x00000004 53 push ebx | 0x00000005 e5f4 in eax, 0xf4 ;; // get_thread_area | 0x00000007 a33712f7d6 mov dword [0xd6f71237], eax ; [0xd6f71237:4]=-1 | 0x0000000c 356687c6f6 xor eax, 0xf6c68766 | 0x00000011 d595 aad 0x95 ;; // _sysctl | 0x00000013 b357 mov bl, 0x57 ; 'W' ; 87 // swapon | 0x00000015 832583a526e6. and dword [0xe626a583], 0x54 ;; // oldlstat::const char *filename // target:0xe626a583 ;; ## TODO: must tr anslate | 0x0000001c d34d2d ror dword [ebp + 0x2d], cl ;; // brk() ,====&lt; 0x0000001f 7453 je 0x74 :: // unk || 0x00000021 49 dec ecx || 0x00000022 2c2e sub al, 0x2e ;; // setgid() ??? wtf.. || 0x00000024 95 xchg eax, ebp || 0x00000025 15e55693d3 adc eax, 0xd39356e5 ;; ## TODO: must translate ||,==&lt; 0x0000002a 77a4 ja 0xffffffd0 ||| 0x0000002c 6543 inc ebx ||| 0x0000002e b7e3 mov bh, 0xe3 ; 227 // lsetxattrib::const char *pathname ||| 0x00000030 c44676 les eax, [esi + 0x76] ||| 0x00000033 0385c2124624 add eax, dword [ebp + 0x244612c2] ||| 0x00000039 b4c4 mov ah, 0xc4 ; 196 ||| 0x0000003b 37 aaa ||,==&lt; 0x0000003c 7664 jbe 0xa2 |||| 0x0000003e f2b4e4 mov ah, 0xe4 ; 228 |||| 0x00000041 16 push ss |||| 0x00000042 a5 movsd dword es:[edi], dword ptr [esi] ||||,=&lt; 0x00000043 7284 jb 0xffffffc9 ||||| 0x00000045 226252 and ah, byte [edx + 0x52] ||||,=&lt; 0x00000048 7406 je 0x50 |||||| 0x0000004a c7 UNK |||||| 0x0000004b 3302 xor eax, dword [edx] |||||| 0x0000004d 2205d313f767 and al, byte [0x67f713d3] ||||| 0x00000053 93 xchg eax, ebx ||||| 0x00000054 95 xchg eax, ebp ||||| 0x00000055 a2a616b647 mov byte [0x47b616a6], al ; [0x47b616a6:1]=255 ||||| 0x0000005a 2472 and al, 0x72 ||||| 0x0000005c 93 xchg eax, ebx ||||| 0x0000005d 648752ff xchg dword fs:[edx - 1], edx ------------------------------------------------------------------------- 
How do we know its really his website? You can go to jail for trying this out (sql injections, etc)... or not? Am I too extreme here? thanks =)
Eg: corporate networks, academic networks, households sharing a connection, or most people on 3G/4G.
I started my adventure with programming from c++ so not much advice here, but I can tell you that one of the best learning experiences was when a client requested no known framework, so I wrote one (very basic but still). So maybe you could try to write your own, simple blogging system?
I think it depends on what you are trying to do. You can do a lot of Api work with php alone. If you want to go full scale web-development though, html, css should be understood first. Then php and javascript/AJAX/jquery for interactivity. But in the end, it all depends on what you are trying to achieve. If you want to do server-side scripts, you'll probably have to look into linux and batch files more than css and html. If you want to make well designed pages, html and css are definitely necessary. 
https://twitter.com/kajonacms 26 followers ? Wow. Any users ?
Here's a list of things you should know - not necessarily before PHP, just in general. This is like a list of knowledge goals you should aim for. It's not complete, but it's enough to get you started. #Basics * syntax (variables, arrays, if/else, loops, objects, interfaces, namespaces etc). * debugging and tracing through code (also environment config for maximum error reporting, and logging) * using $_GET and $_POST to work with user input (also, the post-get-response pattern) * using sessions and cookies * using composer and autoloading * understanding the stateless request/response nature of PHP #Version Control * Need to learn git. * You should learn git. * There's this thing called git. Learn it. * Have you heard of git? It's something you have to learn. * How to keep app configuration / sensitive credentials out of version control so that each environment can have their own config settings. #Databases (SQL-flavored) * using PDO safely to query a database * understanding how indexes work and using them to optimize performance * how to normalize a database to avoid repeating data * the differences between different types of joins (hint, Venn diagrams are useful for visualizing this) * Set up something like phpmyadmin (or better yet, learn the command line) and just practice creating tables and querying data in different ways. You end up writing SQL statements in your PHP anyway, so this is a quick/easy way to practice seeing what tables look like with different queries. * What N+1 queries are and how to structure your code/queries to avoid them #Security * the notion of "filter input, escape output" * cross site request forgery attacks and protection (e.g. be able to do them, and protect against them) * cross site scripting attacks and protection * SQL injection attacks and protection * how to securely hash a password in PHP * safely allowing image/file upload * the difference between loose comparison (`==`) and strict comparison (`===`) in the context of security * using timing-safe string comparison functions * the role that HTTPS plays in security * the role that proper server configuration plays in security (e.g. there's no such thing as secure file uploads in PHP alone - you MUST have the right server configuration for this to be possible) * the difference between cryptographically secure random numbers, and pseudo random numbers. E.g. (`mt_rand()` or `rand()` are not suitable for security purposes) #Object Oriented Design / Software Design in general Note that just because you know OO *syntax*, doesn't mean you've learned OO design. OO design takes years and years and years to get good at. It takes trial and error. * understand the SOLID and GRASP principles * concepts like encapsulation and polymorphism * separation of concerns * declarative vs imperative code * designing for maximum readability, understandability, and maintainability (hint, sometimes overuse or incorrect application of SOLID and GRASP hurts these goals more than it helps!) * composition vs inheritance - when to use which * dependency injection and inversion of control * what the law of demeter means * what singletons are * various design patterns and terms (factories, abstract factories, repositories, DBAL, collections etc - many, many, many patterns and terms. This will feel massively overwhelming as you dive in to software design.) * how to comment your code *effectively* #Unit Testing / TDD * Writing unit tests to automate the testing of your code * How to refactor your code, using unit tests / TDD as proof that your refactorings didn't break functionality. # Elements of Application Structure &amp; Design * what Model View Controller is * what the front controller pattern &amp; routing is * what IoC containers are and what problem they help you solve * differences between dependency injection and service location (e.g. do dependency injection, not service location!)
I don't know..Just felt like saying it. You got a problem with that?
 $data = $data ?: []; whitespace helps a lot
i agree with everything you said. but "Most of the logic is performed in the SQL". maybe in terms of volume, but not in importance
not sure if you got anything else than that script running on that server, if yes. i'd advice you strongly to take it off *now*. The following lines leave you wide open for SQL-Injections: https://github.com/crispytx/asktoby.php/blob/master/searchresults.php#L36-L59 Using that lines i could Read and Drop any table you got access to using the mysql user that you configured.
This. The whole world will say you are stupid for using Php, when "much better alternatives" are available. If you give any sort of ear to these, you will end up being miserable. You will have to pretty much limit yourself to circles dedicated to Php to escape from these haters and whiners. You will also hear people saying that Php jobs are disappearing fast, being eaten up by Javascript. But everyone knows that javascript is just a passing fad and is for hipsters. So don't worry about it. We will keep making cool shit™ in Php even if no one will pay for it. I mean, people are working hard to improve Php. We should not let them down... Also, did you buy Phpstorm. Because it is this awesome IDE, that every Professional Php developer uses. It has got code completion and some other shit that you must use. It is so cool that you can even go to bathroom *without leaving the IDE*....
I wonder, any existing frameworks that can already run on PeachPie ?
Working on kind of a big one ;) 
Maybe python is the vegan of code. "Hi, nice to meet you. By the way, I code in python"
I don't have anything .NET related on my PC atm, but if you have the environment, can you try if PHPixie works? If not, PM me with what needs changing to make it compatible =)
Peachpie will definitely not be able to run PHPixie right now. It needs to be customized specifically for that purpose, so quite a lot of things would need to be added. It is an open-source project though, so anyone can fork it and make it work, Peachpie definitely WILL be able to run PHPixie if customized for it. 
I still don't get why you think that starting a minimal web app in Python is harder than it is in Php... The only think I can think of is how Php maps urls to files and just execute them to produce the output. Is this what you think that makes Php specifically easier....
Is the client going to pay you for the time you took to re-write code to make some hypothetical future devs life easier? If yes then fine otherwise you're going to have to convince me. 
I agree clean code is good, but let me be the Devil's advocate for a moment: sometimes you just need to get a chunk of code down and move on to something else fast. Clean code does not always equal business value, no matter what you perceive it to do in the future. 
So would this proposed function
Because the steps required for the average server is create an index.php file in the document root and typing &lt;?= "hello world "
This is exactly the way I did it when I got involved in a project that used plain saltless md5 passwords (also in CI btw). 
Would be more in favor of removing array_change_key_case instead of adding more array_change_key_* functions
I like this approach
The majority of website hacks happen by automated systems that use known exploits. If it were true that wordpress is just so bad there's exploits everywhere, it would take less than a day to bring a great deal of them to their knees. 
1. As per SRP, I think a service provider should provide only one service. This gets rid of the need to return callable factories and you get to keep class-based definitions. 2. Having service providers "decorate" the output of another service provider seems over the top. It's not the same real-world usage as HTTP middleware. 
Yep, but no extra boilerplate required :-)
Sorta like leftpad? :-P Seriously though, I might do this regardless of the RFC's outcome (especially if it passes to provide BC).
Yeah I'd love to see what results others get! I'll try a few additional variations tonight too in case my original tests were a fluke.
It's such a weirdly specific function. I'm honestly surprised this exists but a more-general version (like the proposed function) doesn't.
I'm proposing this general-purpose function for that exact reason - we don't need a dozen variations of this. Removing the array_change_key_case would be nice in an ideal world, but that would break BC and should therefore be avoided.
Interesting. I must admit we did not consider the "one class service per service provider" option. It is true it would solve a number of problems, but most of our "services" are not actually services but rather container entries that can range from anything from a configuration option to an alias... Forcing one service per class would also create a huge number of classes and make the whole thing less performant (as it would require autoloading all those classes). For instance, this Stash service provider I wrote would generate dozens of classes: https://github.com/thecodingmachine/stash-universal-module/blob/1.0/src/StashServiceProvider.php. I prefer to have many services in one single place. Makes it less confusing and more readable in my opinion. I would however be interested in hearing what the others have to say about this idea! 
A lot of the problem with SO is that the questions posted are of the lowest quality. There's so much more knowledge required than just PHP in order to develop in it.
&gt;I have a hard time finding many cheap shared hosting packages.. I am not sure what you mean by cheap. One can get a digital ocean droplet for as little as $5 per month. You get an ssh login and once you login, it is as easy as creating a .py file and running it from cli. And you are online. If you use a framework like Flask, you don't even have to restart the server manually, after a file change (if you develop in debug mode) The point is, there is no need operate your own vps. I wish more people know about these options every time they choose php for reasons involving hosting provider.. A better reason might be "I have a hard time finding many cheap developers for working in my Python application"...
A development team that is not comprised of college kids working on the core in their spare time....
My husband is a software developer. I just don't like asking him to help me with stuff because he's impatient (with everyone... not just me). I'm going to show him this but I"m pretty sure he can help me with all of this... if he'll be patient. He was patient last night hahaha. Maybe he thinks it's hot his wife is trying to learn PHP. I appreciate the very detailed reply btw! This has been the most supportive subreddit I've ever seen... half the time I have to beg people to respond to me in other subs. :)
Object Oriented Programming. Design patterns. Database normalising. Security (sql injection, cross site scripting, session high jacking / fixation) plenty more here, but that should get you started. Pdo, prepared statements. Once, and only once you have learnt the above, pick up a framework like Laravel. Frameworks are great tools to learn, but they hide a shit ton of stuff that you really need to know in order to build secure, stable, performant software. I'd also look into server setup and maintenance, Linux (debian) based are easiest to pick up. Let me know if you need any help and I'll happily answer any questions or point you in the right direction. 
Asking what libraries to use is against the site's policy, I thought.
The map can be faster or the same if you use an actual named function over an anonymous. Apparently the anonymous function is redefined on every iteration.
What? Since when does StackOverflow require reputation to *answer* on the main site (not meta)?
&gt; a service provider should provide only one service. That would make it a factory. A service provider provides the factories, that's its responsibility. &gt; Having service providers "decorate" the output of another service provider seems over the top. It's actually a must have, it becomes obvious if you consider the current ecosystem of service providers (Silex/Pimple, etc.). Modules need to be able to extend container entries, for example to register event subscribers (to the event dispatcher), controllers, CLI commands, log handlers, cache backends, etc.
Having a dupe hammer, I can get a bit of satisfaction by closing this kind in one click. But... my effort is just a drop in the ocean!
I just require the autoload.php of those packages in my bootstrap script in addition to my local autoload. 
And remain a noob forever? No thanks...I would rather be an unknown contributor to Linux, then be a 'Php god' in its circles.... Every php core developer I have ever came across had some kind of flawed logic built into them. I am not naming names, but I am not exaggerating when I say *every, single one of them*. Not really surprising, considering that it was Php they ultimately choose to work in.....A codebase that was hacked together with little thought or foresight....
[citation needed]
This is not a translator. The PHP is not translated to C#, it is compiled to MSIL and can then be decompiled to C#. Therefore, in fact, some of the "shortcomings" of PHP code are corrected in this process. What cannot be argued is the difficulty of covering ALL cases, but you can take a look at Phalanger and see that it does work quite well. Covering some specific usecases will then be up to whoever needs to use Peachpie for that purpose. So what is the purpose of this project? Many websites have parts in PHP that are far too extensive to be rewritten to .NET for example. Other websites are written in PHP and are often pushed to the limit due to high traffic, which .NET handles way better. And don't forget that the interoperability works both ways, so you will be able to write plugins for WordPress in C# thanks to Peachpie - for example. 
Yah. I know. That's part of the reason I want to learn PHP. Wordpress is pissing me off. :D
Despite what this looks like, I sensed more of a rant about Drupal. I'm working with Drupal almost every project, and compared to other projects with Laravel, Symfony, etc, the Drupal code is way behind today's best practices. D8 fixes most of them, but it took us 4 good years, and other frameworks have gone far now. 
... digitalocean is a vps. And in production you'll still need nginx (or equivalent) for a reverse proxy to redirect traffic from your domain name to the proper port your app runs on. Which means having to learn how to manage a proper server, and keeping up with the latest security threats and patches. Worthwhile to use technologies like Python and such granted, but again, a barrier for entry that affects everyone who isn't prepared to undertake the hat of a sysop while maintaining their app. 
We can't have all the same girlfriend. Python is an option. Use it successfully and enjoy. PHP has its place. So does Python. Having options is good. We should focus on the qualities of a language instead of talking down one or another.
And whenever developers start thinking that they just need to get that chunk code down &amp; move on to something else fast, shit hits the fan &amp; 5 months later you, the hypothetical future developer are explaining your management why your sprint velocity is down the drain &amp; the project isn't moving anywhere. :)
Haha, It's painful to read this but on the other hand it makes me smile to see other people have been there. Hence the reason why I wrote this blogpost. The create some extra awareness on why we should write clean code. 
I hear you. Here's a Python script I wrote using the StackOverflow API that you can run from the command line to help cut through the noise a bit: https://gist.github.com/klenwell/16dd32f4438c53042b6e It's pretty rough but you can tweak the filtering formula and I found that it did help surface more interesting unanswered questions by more serious users. Maybe someone can port it to PHP. :)
Yeah that was pretty annoying and it took an age to get out of it.. upvoting other peoples comments or some such jazz. I persevered so I could help others with my research into the G+ api.. which is sadly abandoned and broken in many places. SO doesn't really tell you want you must do to escape noob quarantine either. It's ripe for being overtaken by someone else. Anyone remember slashdot? I tried googling top social media sites because I forgot.. and it isn't even listed anywhere. I finally remembered just now.
continuous integration - scripted testing and pushing if the tests are good - it all happens automatically
I saw this a bit too late today. So we could just meet on Tuesday with the InvoicePlane guy? At least if we both find him ;-)
&gt; Have you worked on a long term project? :) 5th year of a commercial project originally written by someone else in php3 &gt; As for your question about is the client going to pay for this? Of course he is, and he'll be grateful that you billed him the refactoring Again, I disagree. I've never met a client willing to pay for something he can't see. 
Well, there are plenty of wordpresses getting hacked daily
Must be nice to live on a planet where the devs always get to choose the right hosting solution for a project. Here on Earth, I don't have control over the hosting. My boss does, or the client does. I've made the case for moving to Amazon or DO in the past, but if they're not on board, then I have to roll with it. Maybe they have a budget for dev time but not for server admin, I don't know. It's not like I can refuse to work on something if it's on shared hosting. That said, I have a project on a reasonably good Amazon VPS that still had issues. I had to spend three days rewriting a report generator so that we could get the processing time on about 100k records down from over an hour to a few minutes. Throwing a more powerful VPS at a problem isn't a solution if it's not what the client wants. So them's the breaks, I guess. Another example of real world programming not anywhere near as ideal as we'd like it to be.
Many languages have different runtimes. Ruby has JRuby, IronRuby, etc. Python has a few different ones. Benefits of using .NET in some cases aside, this is a good thing. It helps define and test the PHP specification and might generate some competition. I don't think we would have had a fast PHP 7 if it weren't for HHVM and Zend suddenly waking up and realize that there's suddenly viable competition. One thing this at the very least could enable in the future, is PHP directly integrating with non-PHP code running on the CLR. This might not be possible yet, but I imagine that it might in the future. I believe when you say that you're not trying to be snarky, so don't see this as a comment directly targeted towards you... but it irks me quite a bit to see so many projects initially being met with people looking at flaws, as opposed to applauding doing something interesting. Even if OP just did it as a research project it's pretty fucking impressive and it doesn't hurt to point that out as well. Being biased against .NET is fine, but letting that influence your opinion in this context is pretty short sighted, because a large part of the industry is not biased against .NET. That fact alone should tell you that there could be a market, even if you personally don't like the Microsoft ecosystem. 
I was a very early and very enthusiastic adopter of Stack Overflow when it launched. Unfortunately, from my point of view, almost from the moment the doors opened it started heading in the wrong direction. I eventually abandoned it, and for the last few years my only interaction with it has been occasionally running across interesting and thought provoking questions on SO which had been closed and locked as inappropriate. ...of course, while I say "wrong", but SO is democratic. The fact that they've spent the last 7 year systematically locking questions I find important and rewarding questions and answers I find worthless isn't the result of some cunning conspiracy; it's just a reflection of the fact that this is what the userbase wants (and is why I'm no longer part of the userbase). I do think that there have been elements of a tragedy of the commons, and I would highlight the way that SO relies overwhelming on democractic processes, whereas Reddit (by comparison) relies much more heavily on unelected volunteers. The PHP tag on SO has nobody who can outline (much less enforce) a vision or standards; the will of the crowd is supreme. The PHP subreddit on Reddit has a moderator team who can and do enforce certain norms. The fact I'm on Reddit and not SO posting this comment shows which system *I* think works better. In short, I don't think this is at all unique to the PHP tag, and I've seen this play out on *every* tag I follow. Shortly after the site launched, while looking for some quick rep I answered an idiotic question relating to a language I don't even know which literally wondered what the modulus operator was in Java; it's far and away the most upvoted answer I ever posted. Meanwhile, every serious question (or answer) I posted languished in obscurity, and (as mentioned above) every meaningful question I find worth answering has already been locked as irrelevant.
1. git clone project_library_is_used_in 2. composer update 3. cd vendor 4. cd vendor_name 5. rm -rf library_name 6. git clone library_source 7. cd library_source 8. composer update After doing that, I can make all the modifications I want in the project the library is used in, and in the library itself, and run the unit tests for both. Composer _mostly_ understands that the modified vendor dir contains a git repository and so doesn't clean it - however it is possible to get composer to delete some of your work if you delete the installed.json in vendor/composer; I recommend committing and pushing in the library before doing updates in the actual project. btw I actually use sourcetree most of the time, and name the libraries working in a project as 'library-working-in-project' - which makes finding all the instances where the library is being working on, easy to find, and easy to understand where they're being touched. 
The link provides useful info - relative paths to your own local packages is a good way to do it. The recommendation to work in the vendor directory isn't great when it comes time to deploy, because it's recommended that you put vendor in your .gitignore and not push it up to a git server or when deploying.
You know what I was thinking? I have attempted to up-vote submitted answers and been met with some required criteria for reputation. My jogged memory just so coincided with the linked post being meta. I do know the whole reputation thing has gotten in the way enough that I just treat the site as read-only. I just do my day job and when SO happens to come up in search results... well, OP is right... it's usually archaic info.
You can require your packages with the --prefer-source option which will make a git clone of you vendor package instead of downloading a dist and installing that. This way you can easily work in your vendor directory and make changes there. The only drawback here is that editing your vendor library won't update your composer.lock which might make deploying harder. But there probably are ways around this if you put some effort in it :) $ composer update vendor/library --prefer-source 
Fat chance, since stack sold to some investors so they wont do anything to make the site less popular.
Welcome to the life of a Magento developer, where there is no choice but to do that :(
Almost every answer so far is unique. This is very interesting. Looks like this is definitely something we need to work on and find a best practice for - no approach given seems ideal. I personally go with OP's approach, but it could definitely be easier. Looking forward to seeing what others have come up with!
Man I'm in the same boat. I'm willing to answer a question or two in my lunch break, but not if I have to jump through hoops first. 
Most low quality questions on SO start with a lower case character, you should fix this ;)
As long as you recognise that you're taking on technical debt, and go into the decision with eyes open its usually ok. Like financial debt, technical debt is useful but only if you (like financial debt) understand what your capacity to repay is and you can afford to be burdened by the interest going forward. The problem is many developers don't understand what they are getting themselves in for. They go "fast" to deliver value and end up with a system where the debt is total and technically bankrupt. Signs include an inability to modify the code in the future or ever increasing time to deliver new functionality.
This would probably be better suited for /r/forhire Also, you will need to include a lot more information than what you've listed if you're; A) Serious about something, and, B) Want to attract serious freelance developers.
What he means is just make your changes in the vendor dir of the main project and commit right there. Then push your changes up. Then you can run `composer update` in the main project and commit and push.
really nice article .... I'm a junior and I try my best to create a clean code but what to do when your boss want it now and never accept the time you ask for? 
It seems like many of the questions there (at least the ones I run across) only require a couple of lines of code to answer, often using only the built-in functions. To use your own example question, the answer is [one LOC using `header()`](http://stackoverflow.com/questions/1628260/downloading-a-file-with-a-different-name-to-the-stored-name) (as I expect you already know). Why would I *bother* using a library to do only that? Most questions, and this isn't specific to SO (or this sub), are devoid of enough context to say when a library is a better solution than a hodgepodge of one-liners. For example, I never *start* by recommending SwiftMailer since a properly configured call to `mail()` is good enough for 90% of people. It's figuring out when you're in that 10% that's the real trick.
You should know HTML before PHP. CSS and JavaScript are also helpful for web pages for the front end side of things. On the backend you'll want to know something like SQL. With that said, you can fake SQL with the help of ORMs........…BUT this can lead to poor database design decisions since the person doesn't understand what is being done under the hood for you. 
&gt;And in production you'll still need nginx (or equivalent) for a reverse proxy to redirect traffic from your domain name to the proper port your app runs on.... This is so trivial, almost as simple as locating and editing your php.ini file if you are on a shared hosting. &gt;Which means having to learn how to manage a proper server, and keeping up with the latest security threats and patches. Again, trivial stuff. My experience with cheap shared hosting was extremely frustrating and inferior when compared to my exprience with digital ocean. Installing nginx and configuring it is a much easier task than having to deal with your own version of Php.ini and apache's .htaccess, if you are on a shared hosting. Using google and digital ocean guides for doing common stuff, are a more pleasant experience than dealing with the customer support of a cheap hosting provider. More people need to realize this. 
I suppose the only novel thing I do with composer is ask the autoloader to autoload a config file. In this way I can create my own environment key:value pairs easily changed in a larger master config file-- like database connection information, my Google analytics key, twitter account details, facebook social media stuff, and of course and most importantly the static information needed to integrate with MySpace-- all the cool kids are doing it. The end result is the convenience of automatically having $_MYCONFIGS['gAnalytics'] just always available similarly to how you might access $_POST['something']. ``` "autoload": { "files": [ "path/yourConfigFile.php", "path/path/yourOtherConfigFile.php" ] } ``` Beware-- you are force loading these files. If you don't need them, they are still loaded. However, my pages that don't need them are small and the extra overhead is negligible compared to the unbelievable convenience on complicated pages that are now portable so long as I keep using similar logic and architecture.
Is it not possible to develop under ./app/code/Namespace/ for local dev? I'm pretty sure we aren't that limiting. If we are, well, that should change. 
&gt; "what's the best library for doing X?" I understand their format doesn't cater well for this kind of question, but these questions are often the most interesting and it's frustrating to see them shut down. Those questions flood reddit, particularly /r/webdev and particularly "what framework should I use". They are nearly always pointless, with six different people responding with their preferred framework, regardless of whether they are in any way suited to the question. None of it ever ends up ever being informed or objective, and it always degrades to a pissing contest of fanboys arguing over each other. Edit: Why not ask yourself if any of the time and effort put into responding to these over just the last two days, answers anything better than "pick the one you prefer" ? - https://www.reddit.com/r/webdev/comments/4llrlc/choosing_a_framework/ - https://www.reddit.com/r/webdev/comments/4llb1w/is_using_wordpress_okay_for_a_freelance/ - https://www.reddit.com/r/webdev/comments/4ljjth/tell_me_the_best_language_for_desktop_apps_as_i/ - https://www.reddit.com/r/webdev/comments/4liawm/best_options_to_build_webpages_today/ 
&gt; Codeignitor At least write the name correctly.
That's a good explanation, thank you. So PeachPie is not a translator or some "transpiler", it's a PHP.NET runtime to replace /usr/bin/php through reimplementation of PHP's core? That makes much more sense to me. Also, I'm now interested in the project. I guess in my rush looking at the site and screaming "I don't get why you would do this" with my perceived opinions, I admittedly tunnel visioned and missed the actual purpose. Thank you for helping me understand. 
I'm not sure why disclosure5 is being downvoted. They're right. A lot of /r/webdev is noise, and most of these questions are a waste of time.
Writing clean code doesn't necessarily always have to take a lot of time. It's usually something that grows with you as a developer. Don't be afraid to make mistakes when you start out. The biggest misconception (mostly by juniors) is that you can write the best code possible as i've written in my blog post. So for now try to be sane when you write something, gain experience. Asking for time correlates to asking your boss for more money when you're a starting developer they already invest a lot in you so try to gain their trust by proving you can work with the time you receive. Once they see you "maturing" and you gain their trust by providing sensible solutions you'll have an easier time asking for more time. Hope this is a good answer for your question.
This seems like the best, least hacky way.
Isn't this the same as *composer install &lt;vendor/library&gt; --prefer-source* ?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; The recommendation to work in the vendor directory isn't great Composer will clone your dependency's git repository in vendor, you can from there commit into your library's repository. Vendor is not part of your application's repository. That's btw. the same approach [Jordi is using](https://github.com/composer/composer/issues/601#issuecomment-5229134).
That's really cool, never thought about using it that way!
thanks you so much will do that 
PHP != Laravel.
Really nice guide! Thanks :)
Loved your technique. I'll most likely rely on it. `defer` keyword in Go seems like a good language mechanic. Is there any similar RFC in PHP?
To me it seems that ```defer``` does not help with readability, you can just throw it in anywhere and it executes at the end of a method call? ```finally``` makes it much clearer when things are executed imo.
I used this approach: 1. Maintain copy of composer.json under the name composer-dev.json with modified repositories section using "path with symlink" repositories. 2. Set environment variable COMPOSER=composer-dev.json. Composer commands will then use this file instead of default composer.json. 3. Make sure to keep dependencies in both files synchronized and do *composer update* with original file before commiting composer.json and composer.lock. Lately I'm experimenting with [slightly modified composer-merge-plugin](https://github.com/Furgas/composer-merge-plugin/tree/add-or-prepend-repo). Works good so far: &amp;nbsp;1. Add to original *composer.json*: "repositories": [ { "type": "git", "url": "https://github.com/Furgas/composer-merge-plugin" } ] "require-dev": { "wikimedia/composer-merge-plugin": "dev-add-or-prepend-repo" }, "extra": { "merge-plugin": { "include": [ "composer.override.json" ], "prepend-repositories": true } &amp;nbsp;2. In development mode, create *composer.override.json* with: { "repositories": [ { "type": "path", "url": "/path/to/your/local/git/source", "options": { "symlink": true } } ] } &amp;nbsp;3. Now *composer update* should use path repository with symlink (first call may download the package from original location - just run it again). &amp;nbsp;4. Delete/move aside *composer.override.json* and call *composer update* before commiting *composer.json* and *composer.lock*. Alternatively, you can delete your symlinks and use *composer update --no-dev* so merge plugin won't be used. 
Depends on the reason why your boss doesn't accept your estimates and how often that happens. If it is a regular occurrence and it's mostly done to get the job done as fast as possible or without providing a really good reason, I'd seriously consider switching jobs. You should always strive to reduce the technical debt instead of increasing it. Ignoring that just causes more long term problems and stress. There's also a possibility that your boss simply doesn't trust your decisions which is a really unhealthy environment to work in. If it happens only sometimes or in extreme circumstances, it's pretty normal (still not particularly good though). Learn from it if possible and try avoid it in the future. However, if your estimates are just off due to a lack of experience, you should consult with more senior devs before giving a concrete number to your boss or PM.
Uhm what 
I stand corrected.
This is a good question , what is laptop battery timing of Dell Inspiron 3542 Core i3 4th Gen Laptop? 
Which example didn't work? There's seems to be an issue somewhere which caused me to have to correct missing )'s 3 times already.
I disagree, defer is perfectly fine and readable.
I spend more time going to the php docs than what I spend reading docs about libraries, and the reasons are: 1. Internal function code is not available 2. These functions are a mess of quirks. This one just adds up to the pile. 
I never said "easier." I said lower barrier of entry, that is, it is easier for beginners with no experience to jump in to. There are more resources and tools available for web development with PHP, since you know, that's it's thing. If you google "Python web development" you find a page from Python's docs about setting up CGI, mod_python, etc. When searching for documentation for getting HTTP Request data, the document directs me out to a third party library. While PHP might not be pretty, PHP is written 100% with the web in mind. 
I expect you to be able to come up with answers and solutions using all available tools (aka the internet as a whole, PHP docs, etc). You don't even need to make note of the fact that you had to research to determine the answer, unless they specifically ask you.
If I'm reading your code correctly, you're echoing a nonexistent variable called $written and you're passing strings instead of resources to fclose.
Ah, gotcha. Fixed, thanks!
Yes, callbacks from within internal functions to internal functions are typically very fast (at least compared to userland manually invoking it on every iteration), but not to userland functions.
this is pretty cool. i often have use cases that require constants to be duplicated in javascript like static id references or redirect urls. 
Definitely not.
&gt; These are popular packages that millions of other packages depend on. Sure. Millions. 
In ADR, domain is analogous to model in MVC (not to the controller). I have my doubts about your generalization of domain to one interface. Time will tell. Good luck with your project :)
Quite possibly. There is no 1:1 match... model _might_ be closer, but domain doesn't only represent data but also operation. Perhaps it also depends on whether you believe in "fat model" or "skinny model" MVC. ;)
http://stackoverflow.com/questions/tagged/php Just look at the questions above and anyone will know why you wouldn't want to touch that shit. 
One solution for rapid development (but maybe not the best way): I assume you're using vcs-repositories in composer for your packages. * Use two composer files. composer.dev.json and composer.json. composer.dev.json uses "dev-master" for all packages, where composer.json uses versions. * When developing do "COMPOSER=composer.dev.json composer update --prefer-source" prefer-source will clone your repository in vendor. When you change something in vendor/$repository and test it locally, you could commit and push from there
That's horrible. Best of luck with the recovery.
Yup, sometimes I'm willing to go out of my way in order to contribute something to the discussion/conversation. But then I'm met with "You must have 50 reputation to comment." Well shit then I won't comment and expand on an answer or address a question left in comment form. I suppose they need to create incentive for [things like this](http://i.imgur.com/LHb11jw.png)
Yes, most ADR implementations I've seen have the same types of interfaces. It's generally people who think they are being elite and object-oriented whilst still writing ugly procedural code. 
I think that Paul believes in the "fat model" approach.
Nice to see this. :-)
Thanks man! This couldn't have come onto my feed at a better time. Last week I was having some issues with the "official" SDK and I happened to see your post over the weekend. Came in this morning and I am up and running in less than 15 minutes with this! You took a lot of the awkwardness out of the official syntax.
Given the `finally` construct exists for this exact reason a lot of people would call adding a `defer` construct just adding things for the sake of adding them rather than for actual gain.
In some languages, like Python, you'd use a context manager that I think does the same thing but in a more clear way. with open('foo', 'rw') as foo, open('bar', 'rw') as bar: print('blerb', file=foo) print('blarb', file=bar) And when the `with` block ends the defined means of leaving context of foo and bar (Which with the file object `open` returns is simply to close the files) is called.
&gt; I fucked up accidentally while the guy in question did it intentionally... Ha ha..that does not make any difference. What is wrong with these php "developers" and their weird logic...
why are you here?
If you do not want critique then take it down.
Don't you?
You didn't provide anything constructive. Critique is not just saying "you're trying to be elite and it's dumb". That's trolling, not critique.
Your mom called, said to tell you to stay off the internet.
This pearl of wisdom brought to you by [@officialjaden](https://twitter.com/officialjaden)
How careful do you need to be to make sure you don't cut yourself on all those edges?
Of course you're correct, but being technically right about something doesn't matter a lot of the time. I can be technically right, and even bring it up repeatedly if we run into more issues, and I'm pretty sure that's starting to annoy my boss. But if they're still not on board for whatever reason, then there isn't much else I can do. My job is to get it done to the highest quality possible within the budget with the tools I'm given, and I accept that I don't always have the leeway to dictate what those tools are. My company isn't being paid for me to be a purist about where a site has to be deployed, and digging in my heels about it would be a good way to get fired.
Toran proxy does the job in these situations :D
That's a good point. *sort_pos* or *sort_num* would make more sense.
&gt; There are also approaches to copy Cucumber (like Behat), but I think it is barely usable in PHP. Interesting that he came to that conclusion. I wonder what prompted "barely usable". I love Behat.
Silver lining: he probably won't do that mistake again, and maybe even think of a service packagist/composer/whatever could offer to give some room for errors :) Reminds me when I was a intern and `rm -rf *` a sensible directory on a production server :D Kudos for the recovery. 
Novice question: Why is this if statement being used this way? if (false === fwrite($handle, $uppedFirstLine)) { fclose($firstLine); return false; } 
I like that idea! Altho I feel the need to point out that just because it's your way doesn't make it "the best way". Everything usually boils down to a trade off. In particular, destructors are called during garbage collection (when no more references are made to the object), which could cause issues if execution order matters in the "deferred" code.
Curious that he complains about RoR but states Laravel as a good example, Laravel is practically the RoR of PHP.
You only need `finally` if you're dealing with non-OOP code, such as your file system example. Although I'd be far more tempted to wrap the file system API in a proper OOP structure than litter my code with `finally` blocks.
I have very opinionated vision on automated testing. And consider Gherkin approach not simplest way to go (disregard Ruby or PHP implementation). Testing is very sensitive things and I prefer to keep is as close to native code as possible, i.e. use PHPUnit+Codeception in PHP or Minitest+Capybara in Ruby.
There's more than one way to complete any given talk, I just thought I'd share this way.
Really enjoyed it. Very concise and easy to follow. Please do more like dependency injection. I still don't really understand it 100%
From the RoR website: "Ruby on Rails makes it much easier and more fun. It includes everything you need to build fantastic applications, and you can learn it with the support of our large, friendly community" An opinionated ActiveRecord based framework that focuses on developer happiness and shipping with everything you need to build apps, that sure sounds like Laravel! Adding to that that it's maintained mainly by a single author that stirs the direction wherever he wants and discards everything that does not fit his preferred use case of the framework and that marketing is a very big piece of both frameworks and it's managed brilliantly. I can continue but I think those are enough. I was not talking about the technical points, and I didn't mean that as a bad thing either, Just that Laravel and RoR have many things in common.
Well the context manager is a bit more a protocol than a magic method call you might say, but yes it involves a certain amount of indirection that you'd need to read docs to understand. I suppose the thing I should have communicated is that I think context management provides a better alternative to `defer(thing)` because it's a more general solution to any need for pre and/or post operations somewhere. Since resource setup/cleanup is just a special case of general pre/post operations it just does that as well. with open('foo', 'rw') as fp: fp.write("blerb") raise RuntimeError is nice because it will open and close the file correctly, even given the exception there, but there are context managers that do other useful things since the manager protocol is pretty open-ended. A simple example with a simple custom context manager: @contextlib.contextmanager def tag(tag_name): print("&lt;{}&gt;".format(tag_name)) yield print("&lt;/{}&gt;".format(tag_name)) with tag("h1"): print("some header") which will output &lt;h1&gt; some header &lt;/h1&gt; 
nice job - i like the way you've put this together starting with the bootstrap ( DI -&gt; middleware -&gt; routing ). Auryn looks pretty cool for container config as well. 
Well to be honest, I never did actually use it. I'd just close or finish things like the blog post showed in the other examples!
It's ok Jordi! We all fuck up badly from time to time. On the other hand, awesome work bringing everything back in place. 
Oh no! Someone likes a different style than you! Don't get me wrong, if I am choosing the styling for a project the opening bracket will always be on the same line but as long as it is consistent throughout the project it doesn't matter at all.
Possibly close - doesn't that check out a detached head version, though? I still prefer the explicitness of doing the manual clone - reasonably often I actually be working from a forked repo, where I can commit and squash those commits without anyone else seeing my fuckups......before committing to the real repo.
I almost deleted all of our product rows in production today...Luckally I got the gut wrenching feeling as soon as I hit the execute button and was able to stop execution before anything bad happened...
All of the other `array_` functions which take a callback are fairly consistent. I think `array_map` is a special case because you can pass in any number of arrays, so that variadic parameters ends up being the second one.
We've all accidentally formatted the wrong hard drive at least once in our lives... Teaches you to re-read and re-re-read the names of things before pressing that big, red button!
Will you publish the results?
Open a terminal in the project root directory and "require autoload.php" to pull in your composer libraries, and you've got a pretty good way to mess around with simple expressions and manual debugging. For me, this is a lifesaver whenever I have to mess around with dates and the Carbon library. 
If you happen to be on the laravel stack, "php artisan tinker" will pull in all composer libraries and your config/app.php file and start up the REPL. Most frameworks support some sort of REPL now days (or probably should).
I can publish the result here if people want it
I really appreciate this write up for several reasons. 1. It doesn't just say "write clean code, duh?". It actually goes into real life examples. 1. It doesn't drip of pretentiousness that other articles on clean coding I've read have had - "Writing bad code is bad, duh!?" 1. It shows that using a namepace of Domain is perfectly acceptable if a better name doesn't hit you. I used this in a smaller app with a definable domain, but the domain didn't define itself until I was closer to completion. (Personal to me - I know). Actually, now that I think about it, I'm still using the Domain namespace in a "monolithic" app I'm in the middle of. (Probably getting broken up in to other-than-micro services.) EDIT: I've mentioned this before but I typically only work on long-term solutions (internal applications) so learning how to code cleaner really hits home with me, because I'm the psychopath and I know where I live.
Take a look at http://psysh.org/ for something more powerful. I use it all the time.
From the docs: Note: Autoloading is not available if using PHP in CLI interactive mode.
Interesting. What version is that happening under?