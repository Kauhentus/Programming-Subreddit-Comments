I've been working with Chef a lot lately (all Mac based). Haven't tried Ansible so I can't say how it compares.. But I just launched a pretty large application running on Symfony2 with Chef. I have a full development environment with all storts of features like automatic vendor management and automatic cloning of our production database. Our web server is also provisioned by Chef and features completely automated zero-downtime revision based deployment from git. Full chef runs in dev/prod take about 20 seconds after the initial provisioning when there is nothing to update so it's pretty darn fast even with large projects converging lots of resources (we have close to 300) It's a bit difficult to get started and it takes a lot of work, but you can do virtually anything with Chef.
No, you can choose PHP, HHVM or nothing. Also Ruby, Python.
This is interesting. May I know the general overview on how you used all of it? I'm working for the same thing, except mine is a little bit simple and small scale. So far I got Chef (solo though) for dev machine and some production provisioning, Jenkins for automatic testing and deployer, Gitlab for code hosting and issues, and DigitalOcean for vm's. It works for us, quite a small infrastructure but I do think there's more to add. Interested to know more about your setup. Thanks!
That's a really broad question. You might have to be a bit more specific. Structure-wise I do all my cookbook development using berks, test-kitchen, chef-solo, and vagrant. I then upload those cookbooks to a hosted chef-server. The dev environment runs on vagrant provisioned by chef-client. Our prod server is hosted at Rackspace and also provisioned by chef-client. There's a knife plugin that makes bootstrapping rackspace servers a breeze. I'm happy to answer any more specific questions :)
Vagrant in combination with Symfony2 is just way too slow on my macbook air, it takes five to ten seconds to generate a page. Otherwise I'd definitely use Vagrant.
so?
... PHP 101?
I said the same thing myself. Whoever came up with the idea must have some issues
I can understand why the first "open letter" was published on the blog rather than the mailing list, it was of a generic content. But this one addresses technical details in a specific PSR, so why not simply participate in the ML just like everybody else? It just doesn't feel right. Now I'm not good enough to get into the details, but there is one thing that strikes me about what you suggest for **Tagging**: &gt; And if you wanted to get more fancy, you could create a new interface for cache items which are tagged: &gt; interface TaggedItem { &gt; public function getTags(); &gt; } &gt; Then, your set() method becomes: &gt; public function set($key, $value) { &gt; $this-&gt;cache-&gt;set($key, $value); if ($value instanceof TaggedItem) { $this-&gt;setTagsForKey($key, $value-&gt;getTags()); } } Then users of your caching library will start using those `TaggedItem`, and what happens when they switch to another library? Boom, doesn't work anymore. They would be coupling themselves to the library that implements these features, and thus completely defeating the purpose of the interface. 
How is that constructive?
&gt; I can understand why the first "open letter" was published on the blog rather than the mailing list, it was of a generic content. I guess an assumption is made you read the first. But a follow up to an open letter is still open, right ? Still speaking to all of us, I think :)
try https://apigility.org , it should get you up in minutes. then you can build on top of it pretty much whatever you want, if you grasp Zend Framework 2 architecture.
You can try [Silex](http://silex.sensiolabs.org/), this is a micro framework based on [Symfony](http://symfony.com/) components, made by [Sensio labs](http://sensiolabs.com/), the creators of symfony
The first thing that comes to mind is if you need to install additional packages/software for your server (like e.g. php-mcrypt). And while this works quite well if you only code in PHP and happen to not use any functionality outside the PHP version MAMP installs, it can be a huge plus point if you can install newer PHP versions (or HHVM), a different DBMS or other webservers besides Apache. I try to match my production environments as closely as possible on my VM. Furthermore I think it is an advantage to be able to quickly boot or shut down my VM. I don't want e.g. a MySQL server to hog up system resources while I'm not actively using it in between development sessions.
My thought too. Open letters are generally political and deal with attitudes, processes, people. This is technical and is very much outside any open letter drama. 
Well, ok, so I think you have a few misapprehensions in mind, which I'll correct, before going on to what you actually need. &gt; I only need the model layer of any framework, because all the controllers and views will be done by angularjs. No they won't. This is a misapprehension on your part. You still need all the layers in MVC, but in your case, the V and C will probably be quite minimal. People seem to think that if you're not generating HTML you have no view layer. This is not so. Anything exposed or returned is the view. The controller, additionally, is what gets the data from the model, and returns it. Without all three of these layers you have no meaningful application. Using an AngularJS setup doesn't mean you have the M in PHP and the VC in Angular. It means you have **two separate MVC applications**. &gt; I have considered CakePHP 3 and Symfony 2, because I like the model layers of both frameworks. But I'm not sure if either of them is fit for the job, because they're both quite big and maybe make me do work work instead of less work. You need to be careful with things like "big". What you may be referring to is "leaky abstraction", having to learn how to operate the framework, rather than actually implementing stuff. This is a valid concern. But if what you're talking about is that the framework has a large download or filesize... that shouldn't be considered as a big factor. Personally, I wouldn't look at CakePHP 3 myself. It's still a beta, and a lot of Cake's support has gone... elsewhere. Moving on.... I can't help thinking that this sounds exactly like a perfect job for Laravel. Laravel excels at generating APIs, because it supports resources natively, and simply returning its model object will create the required json. &gt; I prefer convention over configuration sound like Laravel &gt; app will use nested resource routing supported in Laravel &gt; I only need to do data validation hard to tell what this means specifically, but it shouldn't be an issue &gt; and user authentication / authorization built into Laravel Using something like Jeffrey Way's Laravel 4 Generators would trivialise this too, and with no interface you pretty much would be done with a single artisan command per entity and then some cleanup and validation and stuff. 
Another example I just thought of: I previously had MAMP as well, then switched to the builtin Apache2 in OS X and then I had a project where I needed memcache. It was really complicated to get a running memcache server and recompile PHP with the memcached extension. Then when the next OS X version came along I had to do it all over again because the native PHP version was overwritten. Additionally with a VM you can have it running on multiple machines. I am using my MacBook Pro as my main dev machine but sometimes I like to switch to my home Mac Mini. Having to do all those steps on two machines is far to much work. Now I just copy over the Vagrantfile, type "vagrant up" and have the exact same dev environment with DB server etc. included on both machines in a heartbeat. The next part of my series will also talk about how I keep my code synced across machines so it doesn't really matter anymore which computer I am at, I can just continue to work. 
Uh, a lot of old and even dangerous practices, factoids. Example: 6 (Security is not the issue here), 7 (`var` is a syntax error), most of the MySQL part is deprecated.
&gt; No they won't. This is a misapprehension on your part. You still need all the layers in MVC, but in your case, the V and C will probably be quite minimal. People seem to think that if you're not generating HTML you have no view layer. This is not so. Anything exposed or returned is the view. The controller, additionally, is what gets the data from the model, and returns it. Without all three of these layers you have no meaningful application. Yes you are right. However, I didn't mean that there would be no controller whatsoever or that I wouldn't return anything. I'm aware that I will need at least a front-controller. And I'm aware that anything returned to the front-end is technically called the view. What I meant by it is that the controller-layer and view-layer of the back-end won't grow as the application grows. Or at least that's my intention. So once I've set up a fully functional front controller + router and once I've determined how db-results will be formatted as a json to present to the front-end, then that part of the app should be completely finished and I should be able to forget about them. &gt; You need to be careful with things like "big". What you may be referring to is "leaky abstraction", having to learn how to operate the framework, rather than actually implementing stuff. That's one part, but mostly I meant that "big" frameworks are so packed with features, that are also made so generic (so they work for as many use cases as possible), that I would need to do a ton of configuration to make it do what I want it to do. Thanks for suggesting Laravel. I've read in the highest-rated post in this subreddit that you guys appear to love Laravel, so I'll take a look to see why.
&gt;Then users of your caching library will start using those TaggedItem, and what happens when they switch to another library? Boom, doesn't work anymore. After reading both blog posts, I think you should approach the problem with a different mentality: Rather than looking at different implementations of `TaggedItem`, think about an interface for it. The fun thing is that you are specialising more and more with new interfaces, and can get exactly what you want and no more. So all together you start off with a generic cache interface for 50% of the developers. Maybe only another 50% of those then actually need `TaggedItem`s, so you build a new PSR interface for TaggedItems. And so on, all the libraries stay compatible. If everybody agrees on the same (minimalistic) interfaces/protocols for single tasks, rather than on huge ones, everything should stay compatible. It's a bit like the web works: everybody agreed on a specification for TCP at some point for data transmission, and then everybody agreed on the HTTP specification to transfer hypertext. It's so much better than building a single huge protocol from top to bottom for everything.
I know it's expensive, my company is sending me so I am very happy :) Hire that freelancer. Better option
Have been there before ? 
are you using NFS? Haven't had any problems on my mac at all. It's definitely slow on windows though
&gt; But this one addresses technical details in a specific PSR, so why not simply participate in the ML just like everybody else? It just doesn't feel right. Because the technical details I preset are more about OO design in general than they are about caching. I was trying to show that **in general** composition of simple interfaces can do the same things that complex interfaces can, but they have the added benefit of that they are easy to implement and can be composed as necessary. Yes, I talk quite a bit about caching. But you can apply the same compositonal techniques I talk about to any proposal or interface. &gt; Then users of your caching library will start using those TaggedItem, and what happens when they switch to another library? Boom, doesn't work anymore. No. Then you write an adapter. And yay, everything still works. And if enough people find the specific interface for `TaggedItem` useful, then it can become its own standard. Heck, there's nothing that says that the library that provides the cache backend needs to be the same one that provides the tagged item functionality. How cool would that be, if you could compose things at the package level instead of just at the interface level. Heck, isn't that the point of interfaces in the first place? &gt; &gt; and thus completely defeating the purpose of the interface. The purpose of the interface is to solve problems. There are two possible approaches to that. 1. Solve all possible problems with one interface And wind up solving none of them well... 2. Solve a simple case And compose simple solutions together to get complex functionality. 
&gt; But this one addresses technical details in a specific PSR, so why not simply participate in the ML just like everybody else? Two reasons: 1) Just like the PHP internals mailing list, the PHP-FIG mailing list is toxic. Even when it's operating at it's best, the discussions on there are meandering, easily led off on tangents and above all not leading to a good result. But when it's operating poorly, it is entirely venomous and not something sane people would want to be part of. It doesn't help that the Google interface for reading the mailing list is shite. 2) People outside of PHP-FIG don't read the mailing list. Although PHP-FIG claims to be acting on behalf of all PHP users, it composed of a self-selecting group of people who have the time and energy to wade through the huge amount of process discussion on the list. It is far easier for ircmaxell to get people who don't regularly read the FIG list involved in a conversation by posting it somewhere else than the list. Inviting people to go back and read something on the list, when most people have already decided that interacting with the FIG is not a good use of their time, does not seem a great idea. 
&gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC
If the software you're running is simple enough to run using a local webserver then you aren't really going to benefit much from using a VM. If you're using a specific version of anything or any of composer/npm/bower/grunt/etc... then that gets to be kind of a nightmare to manage manually in a local webserver.
I use the TDD approach to get SOLID. It's not easy man. For a complete PHP application, I suggest you read about: &amp;nbsp; 1) OOP http://stackoverflow.com/questions/1530868/simple-explanation-php-oop-vs-procedural [StackSearch](http://www.howtoscripting.com/stacksearch/?s=OOP%20PHP) &amp;nbsp; 2) OOP Principles (Inheritance, Abstraction, and Polymorphism) http://stackoverflow.com/questions/367276/what-is-the-difference-between-abstraction-and-polymorphism [StackSearch](http://www.howtoscripting.com/stacksearch/?s=Inheritance%2C%20Abstraction%2C%20and%20Polymorphism) &amp;nbsp; 3) Unit Testing and Mocking http://stackoverflow.com/questions/8313283/phpunit-best-practices-to-organize-tests https://github.com/beberlei/bankaccount [StackSearch](http://www.howtoscripting.com/stacksearch/?s=phpunit%20examples) http://stackoverflow.com/questions/16841706/php-unit-testing-and-mocking-with-mockery [StackSearch](http://www.howtoscripting.com/stacksearch/?s=unit%20testing%20and%20mocking%20php) &amp;nbsp; 4) Dependency Injection http://stackoverflow.com/questions/130794/what-is-dependency-injection [StackSearch](http://www.howtoscripting.com/stacksearch/?s=dependency%20injection) &amp;nbsp; 5) Object Relational Mapping (ORM) http://stackoverflow.com/questions/1152299/what-is-an-object-relational-mapping-framework [StackSearch](http://www.howtoscripting.com/stacksearch/?s=object%20relational%20mapping) &amp;nbsp; 6) OOP Interfaces http://stackoverflow.com/questions/2866987/what-is-the-definition-of-interface-in-object-oriented-programming [StackSearch](http://www.howtoscripting.com/stacksearch/?s=OOP%20Interfaces) &amp;nbsp; 7) The Repository Pattern http://stackoverflow.com/questions/16176990/proper-repository-pattern-design-in-php [StackSearch](http://www.howtoscripting.com/stacksearch/?s=Repository%20Pattern%20PHP) &amp;nbsp; 8) SOLID http://programmers.stackexchange.com/questions/202571/solid-principles-and-code-structure [StackSearch](http://www.howtoscripting.com/stacksearch/?s=solid%20principles) &amp;nbsp; The StackOverflow/StackSearch Links I provided are just for quick reads. You can generally search Google for articles, videos, and books on the subject matter. &amp;nbsp; My Personal Projects: [Chikka API PHP Wrapper (Library)](https://github.com/champoyradoo/chikka) [Reader](https://github.com/champoyradoo/Reader) - Laravel, Abandoned :) 
Agree 100%. &gt; What if we did something easier. What if we provided a new, simple interface [...] You call a get method, and pass it in a way to re-generate the cache item. I proposed [exactly this](https://groups.google.com/d/msg/php-fig/UkSWS48eEgo/guux1B4L4ksJ) early last year.
You want to use Symfony
Guzzle comes with a [set of utilities](http://guzzle.readthedocs.org/en/latest/testing.html) for testing. They provide the ability to intercept requests and return preprogrammed responses, using the Guzzle client as a [stub](http://en.wikipedia.org/wiki/Test_stub) essentially. I would favor using those utilities over mocking third party code.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Test stub**](https://en.wikipedia.org/wiki/Test%20stub): [](#sfw) --- &gt; &gt;In computer science, __test stubs__ are programs that simulate the behaviors of software components (or modules) that a module undergoing tests depends on. &gt;Test stubs are mainly used in incremental testing's top-down approach. Stubs are computer programs that act as temporary replacement for a called module and give the same output as the actual product or software. &gt; --- ^Interesting: [^Software ^testing](https://en.wikipedia.org/wiki/Software_testing) ^| [^Method ^stub](https://en.wikipedia.org/wiki/Method_stub) ^| [^Test ^harness](https://en.wikipedia.org/wiki/Test_harness) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cldvfaj) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cldvfaj)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
This guy created a php lib that helps interface with it and also has binaries available via composer. https://github.com/mikehaertl/phpwkhtmltopdf
Yeah, that's the lib I'm working with. The [package you're referring to](https://github.com/h4cc/wkhtmltopdf-i386) only has the Debian binaries, which is why I put this together. I'll probably do a PR soon to get mine to replace the current one. EDIT: Just submitted a [PR](https://github.com/mikehaertl/phpwkhtmltopdf/pull/73/files)
It's a bit weird that conversation didn't really go anywhere after 5 pages. Anthony luckily this time provided much more complete examples, which is why I hope this gets a little more attention from the group. The only two arguments are "But what if a thing returns false!" which can be solved with docblocks, and "Allow them to extend the CacheItem class to add tags and stuff". It seems to me that using composition approach you can achieve all of this, and create MUCH more flexible components. Maybe now that we have a better workflow and deprecation, people will be less scared to split PSRs down, and make more, smaller ones.
That's a good answer to my question, it makes sense! Thanks.
I'm glad I asked, your answer makes sense! Thank you.
I say this as a big fan of a couple of your jQuery libraries, Mika. Stay the fuck off /r/PHP this place is a cesspool.
What platform are you running this on? The default value for that ini setting is -1 on Arch Linux.
Yerp, have seen this with a Symphony app (externally developed) which I'm moving into production recently. It doesn't always throw the message - but agreed, I couldn't determine exactly what was causing this to be logged - from memory I did a quick grep of this applications code base and couldn't find any clues (or use of `$HTTP_RAW_POST_DATA` - but I didn't search hard). [php.ini-production](https://github.com/php/php-src/blob/PHP-5.6.2/php.ini-production#L705) packaged with the PHP 5.6.x source comes with this setting at default. I just flipped it to -1 to squelch these messages too. Noted that in the current HEAD of php.ini-production (moving towards PHP7) this INI setting has already been removed.
The [manual](http://php.net/manual/en/ini.core.php) may come in handy to understand the default configuration upstream and what is going on. &gt; If set to TRUE, PHP will always populate the $HTTP_RAW_POST_DATA containing the raw POST data. Otherwise, the variable is populated only when the MIME type of the data is unrecognised. So it could be that certain requests trigger the deprecation warning simply because of how some requests are coming in. However, on the note of the default configuration not making any sense, here it is: If it shipped as -1 by default, that would break BC currently since some poorly written/age-old apps could still be using it. Best annoy them during the upgrade so they know to update their code then cover it up with -1 as default to just opt them into the new behavior without any notice. Package maintainers may set the value to -1 by default since they are doing what they think is best for developers. Upstream is doing what their guidelines say, which is don't break BC as much as possible. 
&gt; So it could be that certain requests trigger the deprecation warning simply because of how some requests are coming in. That seems the most likely situation. Good call.
That is definitely PHP.
Of particular merit in there, IMO, is "pragmatic". All decisions should be legitimately pragmatic, rationally determining the best method for the desired outcome for the business. But all too often the so-called "pragmatic" view is a club used by the short-sighted to bully developers out of considering things like maintainability and long-term stability. We should be very wary when we hear or use that term. 
You don't need to know C to write plugins for Vim either. ;)
You know, the last thing I built in Silex was very similar to OP's requirements. It mostly a simple JS app with an API. Because it was so simple I decided to skip a full framework and just use Silex, setting up my routes, etc. Then I decided to use an ORM and installed Eloquent. (In or out of Laravel it's a solid ORM.) Got my data access working. Then I installed Twig to manage my simple views. Had those working nicely. Then I thought about how I would deploy it, and started installing Phinx for migrations... then stopped, installed Laravel in a clean environment and never looked back. Micro-frameworks are great, but sometimes we throw the baby out with the bathwater, I think. By paring down to minimalism we just end up with big functionality holes we have to repair in other ways, and everything we gained may still end up lost. 
Cool
Propably array\_filter being meant to be in line with most other array\_* functions, while array\_map could not follow that rule(-of-thumb), because it can take multiple arguments. I'm not saying it was a good idea...
Why don't you just use JSON? It's more compact and easier to read.
You might also want to read [Why are PHP function signatures so inconsistent?](http://programmers.stackexchange.com/questions/32541/why-are-php-function-signatures-so-inconsistent).
Looks good!!..Thanks a lot
You don't need to wait until monday to see what the morons have to say - they're here all week.
Can I get some recommendations for a reference book for php? I don't need a book that teaches how to program just a good "desk reference" book.
Amazing reference. http://www.phptherightway.com
Thanks! :)
In the meanwhile: https://gist.github.com/anonymous/23597cffedb13e407391
There's not a better source online. Jeffrey does the best screencasts I've ever seen. Period.
are there any command line (full-stack?) frameworks for php? I wrote this facade for some symfony components, but I'm not sure it has any use. https://github.com/florinutz/nimic
have the same idea after going through few ones. Some tutorials make it so tough we might even think to drop the idea to learn. But yes as you told Jeffrey is the guy for laravel.
Not so much of a question, but I feel kind of stupid about it. I only really just figured out what MIN and MAX are, and the things I can use them for. :D
This is intentional. See the thread ["always_populate_raw_post_data E_DEPRECATED thrown by default" on the php-internals list](http://news.gmane.org/find-root.php?message_id=CD0C00D7%2d8690%2d472C%2dB2E8%2dE41E92160412%40gmail.com)
I'm in the same boat as you are in. I've been doing PHP for 15+ years, but don't feel that my skill has really improved much during that time. I'm the only developer in my company, so I've managed to be successful, but sadly there hasn't been anyone to bounce ideas off of or learn from. I know OO is possible in PHP, and I've seen it done a few times, but that is about the entirety of my exposure to it. I even went back to school a few years ago for a "programming" degree; the course on PHP never touched OO, and really the only class I had that did was Java which was done and forgotten long before I had the chance to really practice it. I know codecademy.com has a PHP course which spends some time on OO. I've not done it so I cannot comment on how useful the class is, however it is a free resource. A quick search also returned a site killerphp.com that has some video tutorials, but again I don't know how useful they might be. With any luck someone with far more experience in OOPHP will see this and provide better resources.
There are a few issues I can think of right now with using a framework. 1. If development is every stopped on a framework for any reason, you're now stuck with a giant code base that you will have to maintain yourself, or rebuild your entire project with another framework. May not be an issue for many years, but what about 10 years, or 20 years down the road? 2. If I work with a framework, it's going to encourage me to just use it's functions as is. Why bother understanding it, when it does it all for me. If I develop my own, I'm forced to learn these things. Not to mention the code of a framework is going to be very advanced and difficult to learn / understand the code that makes it work. I've looked at code of frameworks in the past, and I'm simply overwhelmed because much of the code just doesn't make sense without seeing the big picture, which isn't easy at all. I've never been able to learn by looking at the code of anything beyond very basic frameworks. 
Answer 1: I don't understand why you are concerned about 10 years down the road. I understand long term thinking is important, but you want to learn OOP now. Very rarely do applications last for 10 years, and at some point you would need to rewrite, or refactor anyway. I would also point out, if you do learn OOP the proper way, you learn to loosely couple your business logic from the framework. I have an application I have just finished. I basically use laravel as a routing engine and eloquent. All my business logic use their own classes, in a different namespace to Laravel. If I wanted to put my code into another framework, it would not take a lot of refactoring. Answer 2. If using a great framework, doesn't inspire you to understand how it works, what is? If you develop your own, you are forced to learn things, but not necessarily learn them well. There is a big difference. Now don't get me wrong, I am not an advocate of learning frameworks and that is that. I am an advocate of using a framework and getting to understand how it works. Really, install x-debug, spin up a Laravel installation, and step through the code as many times as you need to, until you understand how it all comes together. It won't all come to you overnight, but this anti-framework mentality, you need to get over it. 
I was in the same boat a few months ago and I solved most of it by "trying" to understand Laravel and modern php concepts. I think you are best served by picking a framework then trying to understand how it works, creating "large" applications with it and generally trying to understand modern php. Use google to your advantage for it has helped me alot. Understand design patterns, SOLID principle, read php documentation(I know it sounds silly but just do it) etc. Its not goint to happen over night but trust me in a few months you will be greatly improved. ps If you want to learn how to create your own framework checkout https://github.com/fabpot/Create-Your-Framework
I don't get it, can you tell us what they are? 
Couple of questions: 1) The "$" which signals a new level, does it appear on as the last character of the line (showing that the next line is a new level) or the first? 2) How do you know when to go up a level? In your example it seems pretty arbitrary. ~~3) Is this just for output or do you need to parse this another way?~~ **Scrap q3, it doesn't matter. I thinking about it I wouldn't deal with usage with the iterator**
Case in point!
MIN is the minimum number between two numbers, and MAX is the maximum number between two numbers. Example; `echo max(-1,0);` will echo `0`, because that's the maximum number between the two. And `echo min(10,13);` will echo `10`, as that's the minimum. Super simple after having it explained, which is why I felt so stupid. Say you want to list `$x` numbers below or above `$y`. So if `$x = 2;`, and `$y = 7;`, you want `5 6 7 8 9`. But if `$y = 1`, you would normally run into `-1 0 1 2 3`. So you'd use `max(1,$y - $x);` to prevent it from going under 1. If none of that made sense, I'll try to explain better in a reply. :D
I second that. Laravel is a great framework to use and starting with version 5 (still in development) it ditches the old MVC pattern in favour to more modern concepts. While I was learning PHP I also created my own framework and used it for several years on a few projects. It was great and I learned a lot but I learned much more after I started using well-established frameworks. As an exercise I wanted to update my framework with already-made components (such as Symphony's) but each time I realised what a waste of time that would be. Also, please keep in mind that while you are learning and using a framework you can make improvements and contribute your code to the framework. Your ideas will get reviewed by others and the knowledge gain on your part will be a lot more than from any other sources.
I know the feeling all too well. I made the OOP jump a couple of years ago. Prior to that I had written a CMS that was entirely procedural code. It was working pretty well, but it gradually became a nightmare to maintain. Spaghetti, meatballs, all of that! My first try was to rewrite the CMS in OOP, and it ended up being a mess, mainly because I was using classes like places to hold functions. I did learn a bit about encapsulation and inheritance, but the overall architecture was that of a hay bale. My second try was another rewrite of the CMS. At this point I had no notion of the use of frameworks, and since I had started to dream bigger, the resulting monster was a CMS/Framework hybrid, which ended up in the bin as well. Still I did learn a bit about SOLID principles in the mean time, and managed to create some sort of autoloader that lended a bit of structure to the whole thing. During the whole time I had pretty much the same misgivings about using frameworks that I did not write, but I also was coming to the slow realization that, in order to do all I wanted to do, I'd need a couple more lifetimes that I was normally allotted. So I looked into Symfony 2. I started building a web app with it, encountering resistance all along the way. At first I thought it was the framework that resisted me, but along the way, a lot of Symphony's design decisions started to make sense. It was still very alien to me, and coming from a mostly procedural experience, things like Dependency Injection made no sense whatsoever. I did love the separation of concerns however, especially the Twig templating bit, as well as the separation of parts of the application into bundles, got the hang of routing, what a Controller should and shouldn't do. Still, with my stubborn self as guide, I ended up writing yet another Framework (the CMS would be built on top of it eventually). This time it was leaps and bounds better. No Dependency Injection yet, and a myriad of Static Classes for the core of the framework, but a much better architecture overall. I still use it for smallish projects, but from this usage I started to understand why I really need Testing, Dependency Injection, as well as making the thing Composer-friendly. So I looked into Laravel ([Laracasts](http://www.laracasts.com) is awesome by the way) and, for the first time, I started to really understand a framework. What was done the same way as in my own framework made me smile, but most importantly, what was done differently was no longer incomprehensible. I am now on my first Laravel project, and although I still have those moments of strife, it is now a lot easier to work around roadblocks (perceived or real). I still have a long way to go. Still, it gets easier. And looking back (and scoffing) at my old code tells me I have made some measurable progress in the meanwhile. In retrospect, my best advice would be to grab Symfony or Laravel, and start building with either of them. It's going to be counter-intuitive at first, but the AHA! moments will come. And they will be Glorious!!!
I appreciate the comment. You had a bit of a better explanation as to why not develop my own framework other than, don't do it. Haha. I'll look into Laravel. See about figuring out how it works, I just hope it makes some sense to me, or else I'm not going to get very far heh. Not sure what to develop with it either. All of my experience has been developing Text Based Browser Games that rely heavily on asynchronous connections, which might be a bit slower with a framework. Either way, thank you very much for the input! My current project is almost entirely procedural, and way outdated haha.
This book helped me a LOT. [PHP Objects, Patterns, and Practice](http://www.amazon.com/Objects-Patterns-Practice-Matt-Zandstra/dp/1430260319) I've known the basics of OOP for a long time, just always had trouble wrapping my head around things for real working items. (that and OOP in PHP years ago was way different than now). This book was great. If you get it, make sure you get the latest edition. I see in getting you the link, there is newer version than what I read (of course, I read it online via books24x7.com)
you've had this troll account for over a year and you still only have -15 karma? What a failure you are.
Easiest way? Learn Objective-C or Java. These languages force you to deal with objects. Then figure out how to transfer your knowledge to PHP, which is not hard to do.
I'm the author by the way, so if you need to know anything more about the book ...
As a Brit, who does know how to queue, and a PHP developer who does use RabbitMQ and PHP together (a lot), this looks interesting. When are you going to open it up for purchasing?
This is a great answer. I don't get the downvotes.. Learning OOP with PHP is just awkward and the language's idiosyncrasies get in the way.
Thanks so much! This book is available through my university's online resources. If you are associated with a University you should all check your's out.
Do you feel like you completely understand what classes and objects actually are? That's critical to understanding OOP if you're coming from nuts-and-bolts imperative programming, where you just have statements. I've found that explanations of OOP are often unnecessarily complicated. Just in case this might be an issue for you, let me break it down: Classes and objects can look complex, but they're really very simple. Imperative programming: Create a data structure, pass that to subroutines to perform work on the data and do various functions. OOP: Associate subroutines with a data structure. When you create the data structure, in essence it has a "menu" of subroutines that can be called on it. The associations are the "class". The data structure is the "object". That's it. That's really all there is to it. There are some more wrinkles about being able to define one class in terms of another class (inheritance), but it's critical to understand that an *object is a data structure with the subroutines that can operate on it associated with it*. So practically speaking, this is the difference between the two methods: Imperative: $data = array(); $data['a'] = 10; $data['b'] = 20; doWork($data); function doWork($data) { ... } OOP: class myData { public $a; public $b; function doWork() { ... } } $data = new myData; $data-&gt;a = 10; $data-&gt;b = 20; $data-&gt;doWork(); I hope this helps out somewhat! 
Sorry to say, I actually found that one of the most confusing introductions to OOP. 
Hmm. I've found pretty good success in the past with explaining it this way; I'm curious where you found it confusing?
Recently I've been investigating PHP performance vs other solutions and looked up [articles like this.](http://blog.famzah.net/2010/07/01/cpp-vs-python-vs-perl-vs-php-performance-benchmark/) I know near nothing about compiled languages but was a little suprised to see PHP is over 5000% slower (in this case) than C++. I understand compiling gives slow development with good performance but didn't expect such a magnitude of performance difference, I started looking into some sort of middle ground and came across HHVM. Should I be using it? It seems like a worthwhile upgrade for any project if the code migrates without problem. Are the performance increases too good to be true? Are there certain types of tasks it's not so good at? I'm not going to switch to it right now (I use incompatible php extensions), but might try using it for future projects. On the same topic, is it worth learning C++ and building my own extensions for specific tasks? Has anyone gone this route?
Am I the crazy uncle nobody wants over for Thanksgiving when I use eclipse for php development in a project?
You cannot set protected properties in this way
Cache invalidation. Say you have a blogging system. For every new blog post you cache the whole page, that includes: comments, authors, etc. Now you as the post author, changed your display name. Instead of clearing ALL the cache, it would be handy if you could just clear the cache for the posts you wrote, right? That's when tags are useful. You can tag the blog post with `author-123`. And when `author-123` changes its display name you can just clear the cache of everything that have the tag `author-123`.
When I'm looking through popular PHP forums I see a lot of unanswered questions as well as a lot of frustration from both posters and potential responders. Although the r/phphelp community seems pretty tolerant of us beginners not posting our questions as specifically as we could, other forums aren't. So I thought a simple checklist might be of help to those that, like me, have experienced the frustration of not getting questions answered.
Static functions are not a good thing IMO. Static functions are useful when you want to access a particular method within a large class, which means you can avoid instantiating the whole object. Namespaces help separate a collection of classes. So if you are using composer for example, to pull in different packages you want to use, as they all use namespaces, both packages could use a class called '*User*', without namespaces it would throw an error. You would call these classes using the namespace: $packageA = new packageA\User(); $packageB = new packageB\User();
No, but you would get invited to Christmas if you used PhpStorm.
&gt; Usually when I see OOP concepts you relate them to real objects. In my opinion, that's exactly why many people have so much trouble with classes and objects. Trying to put it in abstract terms is giving examples of *why* you might use classes, but it doesn't tell you what they actually *are*. My explanation throws away all the abstract confusion, and tells you what they actually are. I think once you understand what is actually going on under the hood, abstractions can be grafted on after that, and it's a lot easier to understand.
Fair enough. We will agree to disagree. But otherwise yes, I thought your example was good, and I can relate to it! 
Namespaces: In essence, it's just an extra part of a name. Think about file directories. You can have the same named file in two directories, but they're different. But you can operate in a single directory and not worry about other directories. Static function: It's just a function that's defined as part of a class, but does not have a data structure object associated with it. But the class itself can have "static variables" which are part a single data structure associated with the *class*, but not any particular object instance. In essence, all the object instances have access to the static variables. But the static functions don't operate on any particular object instance. Usually you would use a static function as a utility function for doing some sort of operation that isn't object-specific. When you see complex class hierarchies, one way to look at is in terms of "sharing". These two classes share the same sub-class, why? Normally, it's because they have something in common. Let's say I have two table access objects, User and Client. They both have a subclass of "Table". The Table class has common code for accessing tables. The sub-class User and Client have specific code for "users" and "clients". Higher level classes generally have less specific code, like the reason you would write a subroutine. People sometimes get crazy with the abstractions, but the idea is to have logical places to put things. It's logical to put a general table access subroutine in a "table" class that doesn't specifically worry about what table. It's logical to put client-specific routines in a "client" class. And you can be assured that if you have a "user" object, you're not going to be able to call "searchClient" on it. It's all about organizing things so that things are in logical places.
Of course, in my opinion, I think everyone should start with assembly language before they even think about the abstractions of high-level languages, but reasonable people can disagree about that. :) We would have a lot less terrible code in my world, though...
Haha. I think higher abstracted languages are good in the fact that you can't bugger up the lower levels as they share a common platform. I would say there would be an loads of AWFUL code if everyone learned assembly! I agree having an understanding of how compilers work and assembly works is useful. Not important though unless you need to start messing around with drivers and such. 
Have a look at this: http://stackoverflow.com/questions/19437544/phpmailer-from-is-showing-as-root-user
What I meant was, we don't want to inject the container inside our classes (like you pointed out) but injecting DI\InvokerInterface will still inject the container, so we would use the DIC as a service locator, no? And the service locator is an anti-pattern, right? 
Probably. The IDE debate usually comes down to heavy- vs light-weight, with PHPStorm being the best heavy-weight and Sublime being the best light-weight. That being said, it's more important that your IDE accelerate you. If you know eclipse well, and it's various quirks aren't slowing you down, there's not a good reason to switch.
After deciding to get on the GoDaddy webpage chat support, I directed the agent to this question and they were able to tell me exactly what I had wrong and what I needed to enter. So this issue has been successfully resolved and maybe someone else will find this page useful. Props to the GoDaddy support agent who was able and willing to help out, and didn't just toss out some line about "custom scripts" Here is what was used to make PHP mail work with GoDaddy require("phpmailer/class.phpmailer.php"); require("phpmailer/class.smtp.php"); $mail = new PHPMailer(); $mail-&gt;IsSMTP(); $mail-&gt;SMTP_AUTH = false; $mail-&gt;Port = 25; $mail-&gt;Host = "relay-hosting.secureserver.net"; $mail-&gt;FromName = "mywebsiteemail@company.com"; What I had to comment out //$mail-&gt;Username = "mywebsiteemail@company.com"; //$mail-&gt;Password = "myemailpassword"; //$mail-&gt;SMTPSecure = 'ssl'; 
Thanks for taking a look and offering a suggestion, luckily GoDaddy support was able to figure it out for me.
Good question. It's obviously something we've been thinking about. The CMS is pretty solid itself, but since the extensions are PHP, and there's no way of sandboxing them properly, there's always a chance somebody messes up majorly. There are a few things we're contemplating: - We encourage extensions to have public repositories on Github (or other VCS communities supported by Composer) - We're running some tests on extensions automatically to prevent them from crashing when people install them. We also realise that this is _not_ a way to prevent someone from sneaking in back doors (knowingly or not) - We're considering adding a killswitch for extensions. This way every site would show a big red banner telling people to upgrade or delete an extension. We could even consider making the killswitch automatic, so that whenever a Bolt install checks the updates, and one is "killswitched", it will be removed automatically. However we're not sure this is desirable. - Another idea we've been thinking about is a way to add "officially reviewed" badges or something like that. But, if that's feasible or not depends on the amount of extensions there are. At the same time, we should be careful to avoid "favoritism" in extensions, because people might feel we put them at a disadvantage if we don't get around to reviewing their extensions quickly enough. Other than that, we'll write more guidelines and best practices, including security. Regardless, this is a complicated manner. If you have good ideas about how to go about this, we're all ears. 
phpliveregex.com is pretty cool, they have some easy to understand tips. \d+ in your case of WordWord999 would match 999 \d is any digit. The + means one or more. \D would match any non digit. So \D+ would match WordWord
To prevent some confusion, you can then get the number from `$results` array (if you need it separately): if (preg_match('/([a-z]+)([1-9]\d\d)/i', $test, $results)) { $number = $results[2]; // do stuff to $number } 
Well, the first thing you have to ask yourself is this: Do you really have performance problems, did you test it by yourself or are you just embarrassed or jealous when others show you a benchmark where language X peforms better than the one you are using? Most if not all benchmarks I saw so far were biased in one way or another, just used default options when there are clearly a lot of things you can tweak or were just using some general usage patterns you will usually don't see in your web application. Like the one you linked: just lots of loops with basic math calls and a pretty large memory footprint - nothing your average web app is normally doing. I didn't use HHVM so far, but if you start a project from scratch, it sure doesn't hurt to use it if you want - it seems stable enough for production use. But in my experience, PHP wasn't usually a bottleneck and there are things you can tweak (like using an opcode cache) in stock php as well. Especially when your only experience is within the PHP realm, switching to C++ for some specific performance gain is just asking for trouble IMHO. There are other parameters you have to consider, like experience, time to market etc.
PHP and C++ target vastly different use cases. Even if we ignore that, compiled is almost always faster than interpreted and strongly typed is almost always faster-to-execute than weakly typed. As for writing C/C++ extensions, **don't**. If you are asking yourself *"do I need to write an extension for this?"* the answer is **no**. If you ever end up *needing it* (most people never do) you'll *know* you need to write it :)
really cool! I started with 1.4 and have it up on 2 small projects. Will be going to test this as I have time and hopfully to migrate on of my static sites over to bolt.
Give your &lt;select&gt; element a name attribute. &lt;select id="flavor" name="flavor"&gt;
Hi, Nicoon. Sure! Up until two years ago we used a few different CMS'es at our company. Drupal for larger websites, custom made stuff on Kohana for non-standard webapps, and a home-brew CMS for smaller sites. I think it's a benefit to be able to be proficient in different tools, to provide for your clients. Our home-brew CMS really started to show its age: No composer, no namespacing, not autoloading, smarty, `serialized()` config, etc. So, it became time to retire it, and choose something else to take it's place in the choices we offer our clients. We've evaluated a ton of systems, but all of them made some people cry: - Wordpress: clients like it, backenders have to cry. - Concrete5: Frontend devs liked it, backenders could get used to it, clients were confused. - Joomla: everybody cries So, we decided to do it differently, and we tried to make sure we cater to all the three different kinds of people who have to work with it: Back-end devs, Front-end devs and content editors alike. See [this chart](http://twokings.nl/preso/sug/#/5) for clarification on that. I then started to build the system the way I knew how. Once the first version was sort-of workable, I started posting it on forums and stuff. Some people didn't get it at all, some people saw what we were trying to achieve, and some people ~~flamed me~~ gave constructive feedback. Some of it was just harsh, some of it was justified, some of it was both. I used this to make the code better, but more importantly: Quite a few people started helping out. Around january of this year, we _really_ started working on version 2, and a lot of people who are better programmers than me really made sure we are building a rock solid system. This is were we are currently: finalising version 2.0, which I think marks the coming-of-age of the system. I'm really content with the current state of the code: It's solid, quick and understandable. And, it's not saying anything definitive, but I am personally quite happy with the fact that the number of stars, contibutors and forks [on our github repo](https://github.com/bolt/bolt) keeps growing, month over month. Slowly but steadily. Right after 2.0 is released, we're going to market it more efficiently. We've noticed that most people who hear of it, do so by word of mouth, or via reddit. People often tell me "I'm happy i bumped into it accidentally, because i had never heard of it before". When 2.0 is out, we're going to promote the system, and encourage people to release extensions and themes to build a larger ecosystem. There will be a well-designed site, that appeals to the different target audiences, and different types of documentation (like a [cheat sheet](http://cheatsheet.bolt.cm), a quickstart "Bolt in 60 minutes" guide, and other reference materials, to complement the extensive documentation for frontend- and backend-developers). By doing this, we're going to position ourselves as a viable alternative for developers to use in situations where they currently tend to use wordpress-as-a-cms or where drupal is overkill. Also, the system is obviously open source, and it will absolutely stay that way. completely. We will never cripple the system intentionally in order to sell extensions that ought to be part of the core. 
Am I the only one thinking this question is asking for too many attributes to actually solve the task?
Cool! If you bump into any issues, don't hesitate to get in touch. 
Ah, so the unexpected case. So if it's expected, I should be doing something else and not throwing exceptions, right? By your logic, this is incorrect usage of exceptions: class User { public function __construct($email) { if (!is_valid_email($email)) { throw Exception("Email is invalid!"); } $this-&gt;email = $email; } } That's incorrect usage of exceptions, yes? Instead, I should maybe use an array or some other mechanism for letting the caller know something went wrong in an *expected* fashion, maybe like this: public function __construct($email) { if (!is_valid_email($email)) { return ['success' =&gt; false, 'message' =&gt; 'Email is invalid']; } $this-&gt;email = $email; } Do I understand you correctly, or am I missing something? I guess I don't understand why I would intentionally throw an exception... If I know the list of conditions I expect to accept, then I also know the conditions that I *don't* accept. Do you throw an exception if someone passes in one of those other conditions? Why not just return false (or something a little more descriptive)? Example: function user_age($age) { if (is_string($age)) { $age = get_number_from_string($age); // 'five' -&gt; 5 } if (!is_integer($age)) return "That's not a number!"; return $age; } In this case, I know I expect an age to be a number. I suppose a user could put something in besides a number, like the string "five". If they put in "five", then maybe I try to change it to 5 and keep going. I *know* I expect a number, so if they put in something that's not a number, then I *know* they put in something wrong, so I can return a helpful message. To put this all a bit more succinctly: if I know what I *want* to happen, then I also know what I *don't* want to happen, which means I should be able to handle that. Where do the exceptions come in? My caller should be able to handle "false" or "['success' =&gt; false, 'message' =&gt; 'File does not exist.']" just as well as an exception... Sorry if I'm making this more complicated than it needs to be, I'm just not really sure why we need exceptions for things we can predict...
I like the idea of a user opt-in for the killswitch. Something easy accessible from the settings, but also set upon installation.
Sorry. Maybe I'm being dense. Why do I need an exception for things I can predict? Let's go with your file example. You can predict that files might not exist, so you can check for them first. function get_profile_photo($user) { $photo_path = $user-&gt;get_profile_photo_path(); if (!file_exists($photo_path)) { return ['success' =&gt; false, 'message' =&gt; 'File does not exist.']; } return fopen($photo_path); } I can check if the file exists before I return it, so there's no need for a try/catch block to catch an exception, right? My caller can just do: $photo_file = get_profile_photo($user); if (!$photo_file || !$photo_file['success']) { die("Whoops, that file doesn't exist! Upload a new one."); } show_photo($photo_file); I don't see how that's any different/worse than: try { $photo_file = get_profile_photo($user); } catch (Exception $e) { die("Oops! Something went wrong! ".$e-&gt;getMessage()); } show_photo($photo_file); What's the difference? There's no catastrophic failure here. I don't need a stack trace to tell me that a file doesn't exist. What am I missing?
/r/phphelp, also if you could format it using using four spaces for code format.
Any estimated price point set yet?
First things first, format your code properly: Four or more leading spaces will display as code This will help us help you, as we will be able to see the line number causing the problem.
We're still looking into a proper way of doing this. Starting with this release we'll be keeping a proper, running changelog. Also, we're moving to gitflow to make sure the 'master' will remain in a stable, deployable state. &gt; Only unit tests and a commit log aren't very telling of a projects health Agreed. To me it's much more important that we keep increasing the number of contributors, and people active in the community. Also, the actual activity on github is a factor too: https://github.com/bolt/bolt/graphs/contributors
&gt; I'm also very against using frameworks I didn't develop myself, I'm not sure why exactly Because you don't know how they work under the hood, which your first approach (building your own) will solve. I was exactly the same way, then I built my own IoC container, mini-ORM, router/dispatcher, and front-controller, and then was like "K, I get it now" and just started using Laravel. This is normal. So yes, definitely learn by building your own, then realize that other frameworks like Laravel and Symfony are just more stable and robust implementations (with way more helper features) than the thing you're building on your own.
If your functions are simple and use only native functions, then exceptions might not be necessary. You'll need stack traces when operations get more complex and abstracted and object-oriented. Also, if you use an MVC framework, many of those classes already use exceptions to handle error conditions, so adding exceptions of your own blends nicely with that whole structure. The MVC framework typically will also come with an exception controller, so that if one of the many objects you use throws an exception that you're not catching, it will be caught at a much broader level and handled by a standard error page. In my example, I'm actually doing a number of steps. First I'm taking the file ID from the querystring and finding the corresponding row in the table. (If the file ID is missing, I use zero as a default, so I don't need to make that a separate exception.) If it's not in the table, I throw an exception. This uses a database table object which in turn creates a database query object; both of those may throw exceptions of their own. The query returns a database row object, which uses magic methods to access the columns. If I try to access a column that's not in the row, the row object's magic getter function will throw an exception of its own. Then I have a helper function to generate the file path, as I store the original filename of the uploaded file in the database but store it in the filesystem having renamed it to the row ID and the original extension. That accesses a registry object and a config object, which may throw exceptions. I will throw an exception if the file isn't in the filesystem. Then I check to see whether the row has been marked as deleted, and if it is, whether the user has admin privileges. (We use soft deletes because a user can delete a file attachment, but an admin can reverse the delete.) If not, then I throw an exception. Then I note the download request to the application log, which uses a log object. If for some reason the log isn't writable, that will throw an exception. If there is an exception, I won't use die(). Instead, I will log the exception, generate a flash message that varies depending on the type and code of the exception, and also depending on the type and code, I may or may not trigger an exception report email. I may also then redirect the user to a different page.
Ha ha, +1 for the title! The introductory chapter probably needs to apologise a few times, for no reason at all. 
So glad this thread exists today! I'm not even remotely qualified to say I code anything, but I'm having to hack a quick php script together. In essence, I'm trying to send an email to a set person(s) and the contents of that email will be the very web page I'm on, with a small addition to the URL. IE- If my form is on https://www.dokuwiki.org/config:sepchar then when I select my mail recipients, it will get the body of the email from https://www.dokuwiki.org/config:sepchar&amp;do=export_html. Basically just taking the current page and tacking on &amp;do=export_html to the end of it. How can I concatenate that and pass it to the emailpage.php script?
Nope. I feel the same way.
Pretty much a large refactor. Brought in some of the external blocks into the core, and renamed some of the terms (call to task, and task to job) to make a little bit more sense. Output is a little bit more friendly too. 
Why wouldn't you just use a VCS? &gt; git status
Congrats on the release! 
This. POST and GET do not look at the id attribute. That's mainly for Javascript. GET and POST looks at the name attribute.
I've got a site that has pseudo-MVC set up... but I've got all these functions that print things (or return formatted strings)... many of them accept an id for something, go get the info from the database, then print out results in a certain format (that gets used all over the place). So I might have a template file that says: &lt;h1&gt;&lt;?= $article['title'] ?&gt;&lt;/h1&gt; &lt;div class="byline"&gt;by &lt;?= get_article_author_name($article['author_user_id']) ?&gt;&lt;/div&gt; then those functions usually pull in the `global` database connection to do a query and return/print the results. It's useful to have these "formatting" functions so that we can print things out the same way across many templates, but it still doesn't seem right. Where should those formatting/template functions go, and should they even be doing database queries at all. What if they need a template engine (currently moving toward plates)... what would be the preferred way to inject/pass the template engine to these printing/formatting routines? Should they all go into a class (or some classes?) and pass those into the template?
I'm confused, where is emailpage.php? Somewhere on docuwiki.org? If you're looking for what URL your script is running for, you can use `$_SERVER['SERVER_NAME']` AND `$_SERVER['REQUEST_URI']`... You could then just append the "do=" part, or use `parse_str()` and `http_build_str()` to do it more intelligently. Then to pull the contents of that URL into your script, `file_get_contents($final_url)` might work, depending on the set up of your server. There are some nice HTTP packages for fetching remote content as well.
No I would not look at it that way. When you code against interfaces, you are not coupling yourself to the implementation, because you don't know which implementation will be injected. At worse, you are coupling yourself to the interface (which is the best you can do). In your case, you wouldn't know (in theory) that the container will be injected here. You can replace the container by any other implementation of the interface. - Are you coupling yourself to the container? No - Is that the service locator pattern? No, because you are not "locating" (or retrieving) a service with a service locator. `InvokerInterface` is not something that retrieves services. - Are you coupling yourself to DI\InvokerInterface? Yes, that's the small downside (that doesn't mean you can't ever replace PHP-DI by something else, that means you'll just have to provide another implementation of the Invoker that's all)
&gt; but in the end they were updated to have -1 as the default value. That's weird, I'm seeing the opposite when installing 5.6, that's why I opened this thread. To be more explicit: by default, the default value is "0" in all cases I've seen. Are you saying it should be -1?
Yes. Try NetBeans if you don't want to buy phpstorm
:)
Thank you so much for writing about this situation. I was literally composing my message that is just about the same as yours in my head for /r/PHP then I saw your post. Thank you to everyone who has contributed -- I feel more assured in my progress and I have some great ideas as to where to go from procedural coding!
These two books were the best programming books I have ever read: * [Code Complete (2nd Edition)](http://www.amazon.ca/Code-Complete-Edition-Steve-McConnell/dp/0735619670) * [The Pragmatic Programmer](http://www.amazon.ca/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X) Code Complete is focused more around OOP, however both of these books will teach you how to become a better programmer. I recommend these timeless books for all programmers of *any* experience level. 
.
That's a legit point. I definitely hadn't thought about it that way before.
Beanstalkd doesn't do much but it is _simple_. RabbitMQ does a whole lot and can be quite confusing, but it is _powerful_. 
My question is, why do you prefer an if statement over a try/catch? Because there's less lines? Say someone, maybe another developer, uses the get_profile_photo function. They don't wrap an if statement around it, and so they've just got: $photo_file = get_profile_photo($user); They try it, the code runs fine! No errors. All is well. But they have no idea that the function actually didn't work and $photo_file is now an array. Off they go to the show_photo function: show_photo($photo_file); show_photo just got sent an array. So what's that developer seeing now? They'll be seeing an error from inside the *show_photo* function. But actually, the issue was back there in the get_profile_photo function. With an exception, they'd have seen right away that there's an issue they're expected to deal with, the error will come from the right function and it will have a message that makes it clear exactly what just went wrong.
I've been looking into using Bolt to replace WordPress where I'm currently working, but there's a few things I need that I can't figure out are possible or not. Can I add custom fields to specific posts? Say I have a gallery page, but only want the gallery upload available on that specific page rather than every page? It'd also be nice to have another section in the admin to have custom settings that I can then grab in the template, but I'm not sure if that's possible either.
Here's [my checklist for Stack Overflow](http://blog.jondh.me.uk/2012/09/how-to-use-stack-overflow/). Not all Stackers would agree with it - but I think it's a good start. 
Thanks Phil. In the context of queues and workers, what can it offer more, though? It seems like RabbitMQ is overkill if you don't need the whole messaging thing. 
Hi, &gt; Can I add custom fields to specific posts? No, you can define the fields per contenttype only. In this case I would probably make a separate contenttype for "galleries", and add it in there. &gt; section in the admin to have custom settings You can add these in the theme-specific `config.yml`. They will then be available as `{{ theme.foo }}` variables in your templates. 
I'm not entirely sure I prefer if statements over try/catch... As my original question suggests, I'm not 100% clear on when to use exceptions or why, which is why I'm asking... But the semantics of an if statement suggest that I know what's going to happen: *if this happens, do this, otherwise do that.* The semantics of a try/catch statement are: *I have no idea what's gonna happen, but let's try it and see what happens, and if something goes wrong, we'll figure it out later.* In my mind, try/catch is an admission of "Something could go wrong, but I don't know what it could be", which I don't think makes sense when I can clearly predict what could go wrong and handle it accordingly...
I've been thinking about this for the last half hour on how best to answer you. First, the concepts that you need to understand to solve this problem are [linked lists](http://en.wikipedia.org/wiki/Linked_list) and [recursion](http://en.wikipedia.org/wiki/Recursion_%28computer_science%29). You would create an object for each line and the object would have a field which points to it's parent, with NULL for the top level. You would also be better off creating a pseudo top-level container for your overall container. That way you can iterate through the top level and then recursively get and iterate through children. The issue I am having is in your definition of the problem, if you are in charge of the original format of the string (which you suddenly defining EOL as the end of the encapsulation suggests) then why not use a more defined existing structure such as JSON or XML? If you are not in charge of the string format then you need to tell whoever is that having a "$" and EOL signs are a very bad way of defining the data. It sounds like you are trying to build something similar to how the first part of a compiler works, but I think your definition is bad. 
You can use custom exceptions for specific things going wrong. You throw a PhotoNotFound exception, and check for it. Then it's pretty clear exactly what you expect to go wrong and you can write code that clearly deals with a specific issue. The main issue with your example is returning an array in place of an exception. It's weird for a function for getting a photo to return a photo sometimes, an array at other times. A function should only return valid data or it should error. You're returning an array, but it's technically not a valid response. But "null" would make more sense, as long as you consider null to be a valid response. So show_photo would happily accept null, and handle it gracefully (maybe by showing a default image instead). So then $photo_file = get_profile_photo($user); show_photo($photo_file); *Always* works. I know you probably just made your example... as an example. But it's either something that should throw an exception, or it's something that shouldn't error at all.
I found a video series a while back that was very helpful in showing me not only the syntax of OO PHP but why and how to use the properties of the objects you create as objects. Its called PHP - Beyond the Basics by Kevin Skoglund. You can find it for sure on Lynda.com. Maybe there's a free or cheap version somewhere?
I've registered on the website :) good initiative!
Thanks, fixed.
That totally makes more sense. Thanks for your input. :)
&gt;I'm also very against using frameworks I didn't develop myself Well then, you're going to have a hard time trying to figure out how OOP works and/or how to even begin making a framework. I mean, how in the hell do you expect to understand how to design and build a more modern php framework when you've NEVER even used one.
&gt; figuring out how it works You don't really need to do this. You don't need to know how every piece of a framework works. You only need to know the signatures of the interfaces or abstract classes that you're using of that framework. You're getting overwhelmed with the complexity of these frameworks because you're trying to dig too deep into how they work. Most developers don't know how every piece of a framework works in-depth, but they usually know how to implement most of the framework.
Is it worth it to create a MySQL server instead of using SQL Server 2008 to use for a database for php? I've already run into some fun converting scripts from mysql to sql including an infuriating 2 hour bash my head against the keyboard where the problem ended up being me typing sqlsvr instead of sqlsrv. Ahh, the joys of learning a new language.
While not the best choice, you could go the Apple approach and be strict. However this may not be as feasible, especially at the beginning so you could implement something where any plug in can extension can be added to the library, but ones that are not approved would require the user to switch a flag in the admin panel agreeing to take their chance by viewing ALL extensions. 
Interestingly enough, a couple of years back I was in the phase of my own framework is the best and other hold me down similar to OP. So I thought that one of my most popular answers on StackOverflow would be helpful in understanding that mindset: http://stackoverflow.com/questions/5925356/reasons-to-not-use-a-php-framework
If you add your interest via the link you can specify the maximum price you'd pay, and I'll set the minimum price to something around the average that everyone suggests. At the moment that's likely to be around $19 but of course I'll do a special offer to kick things off.
I feel like I'm densely missing the inside joke here due to a mismatched nationality - what's the deal with brits and queues that makes this funny?
&gt; I hate that this RFC bolts on more Frankenstein-like functionality instead of simply fixing the conversion rules used by the filter extension. Actually, if you look at [Theodore's PolyCast](https://github.com/theodorejb/PolyCast), a polyfill for these functions, you'll see that to_int is implemented in part by using filter_var. What filter_var does now is not that different, for `to_int` at least. However, filter_var isn't terribly convenient. Faced between `(int)$foo` (dangerous, but works) and `filter_var($foo, FILTER_VALIDATE_INT);` (much safer, but a lot of typing), the lazy programmer will choose the former. The idea is to make doing the right thing as convenient as doing the wrong thing. These functions also handle non-string data. &gt; (I can see the intval() vs. to_int() Stack Overflow posts now) People will read documentation, surely. It wouldn't be difficult to clarify that one never fails and the other sometimes does.
What's the performance, how fast can it pull an index/entry page, how often it hits the db? Assuming lamp defaults no caching at all, etc.
Note that the `filter_var` dependency was temporary and has been removed as of v0.4.0 (performance win + compatibility with PHP binaries compiled without the filter extension).
I would posit that "read the docs to find out which function works" is at odds with "make doing the right thing as easy as doing the wrong thing". We'll never, ever stop hearing about $needle, $haystack :: $haystack, $needle until we create a (breaking) release that chooses one, and then wait 10 years for the shared hosts to upgrade. Yes, there's a way to tell, somewhat systematically, which it will be, but it still is a problem that you as a programmer have to learn a complex rule and not a simple one. Type conversion is no different: yes, the language always behaves consistently given specific inputs, but that's different than having consistency of the API. I don't vehemently care all that much, and maybe we need to add new API before we can kill old API. This *is* part of what documentation is for. But it would be nice to introduce fewer of these inconsistencies and start tying up some of the left over ones.
sorry for the confusion, let explain a bit more. the default value is 0, as you can see here: http://lxr.php.net/xref/PHP_5_6/main/main.c#641 what I was referring to by -1 was the suggested default php.ini files(http://lxr.php.net/xref/PHP_5_6/php.ini-development http://lxr.php.net/xref/PHP_5_6/php.ini-production). but those lines are commented out, so even distros which use those files as-is for the default php.ini will have always_populate_raw_post_data=0 and the E_DEPRECATED message is triggered when we actually populate the $HTTP_RAW_POST_DATA: http://lxr.php.net/xref/PHP_5_6/main/php_content_types.c#59 (either because always_populate_raw_post_data was set to 1, or 0 and we had post data with recognizable mime type: http://lxr.php.net/xref/PHP_5_6/main/SAPI.c#220).
&gt; performance win Are you sure it's faster?
&gt; What filter_var does now is not that different, for to_int at least. That's precisely my point. We already have a good foundation in this extension, and I would much rather see us refine it than add *yet another* way to filter input. &gt; However, filter_var isn't terribly convenient. I understand, and I would be totally on board with `to_int($foo)` simply being an alias for `filter_var($foo, FILTER_VALIDATE_INT)` and the like. The problem comes when we have both, but they operate differently from each other (which they will, based on this RFC). Then they'll both operate differently than `intval()`, and so we end up with *three* different ways to turn arbitrary data of some sort into integers. &gt; People will read documentation, surely. It wouldn't be difficult to clarify that one never fails and the other sometimes does. We have no shortage of examples in PHP where things were well clarified and documented, but still lead to rampant confusion and misuse within the community. It's no coincidence that most of them revolve around type casting and implicit conversions.
You know, to_int() doing the same thing as filter_var() here might be worth considering. Hmm... EDIT: Though `FILTER_VALIDATE_INT` has a lot of options. I'd rather we just support the common case (decimal). EDIT: Oh god, why doesn't it accept `"0123"`...
As a developer that is working on a queue based system in PHP against my will, I must ask you why PHP? There are all sorts of issues with it at scale, especially if you need to do some queued action inside another, it just sits there and blocks (and wastes like 10mb of memory in our case). I would actually love to speak with you about some pitfalls and ways around them since the powers that be are happy with our unscalabe architecture, and at the very least will never leave PHP, and we are in production with it.
I wouldn't pass this RFC. These functions are trivial to write without building them into the language. Also, why is there no `to_bool`? And how would you implement that with the proposed returning false on failure? Edit: [linked below](http://www.reddit.com/r/PHP/comments/2ju3ym/rfc_safe_casting_functions/clf49df) we can see these functions can be implemented in [81 lines](https://github.com/theodorejb/PolyCast/blob/master/lib/PolyCast.php). And given how controversial they are (returning false), there's really no sense making these a standard.
By the way, I finally added those string overflow tests. And I added ones for octal and hex.
Thanks! I'll make sure my implementation matches.
There is a **`** in **Line 5** after the closing **;**.
"An Englishman, even if he is alone, forms an orderly queue of one." We just like queueing. It's about the only time strangers will talk to one another.
Figuring out how it works is how I learn to program. If I just use it, and don't try to understand it, I'm just going to end up learning nothing but how to use the Laravel framework. if someone asked me to develop a class using the newest methods I won't know how, because I just used Laravel had no reason to really figure out how to do the same things.
My case for exceptions instead of error values: http://markmail.org/message/uzxu46sammhzqsq4
Thanks for taking the time to write that, just curious: what was wrong with drupal 8?
I created the polyfill as a way to prototype different behaviors and start using the functions now in PHP 5.x. However, if we are ever to get scalar type annotations in the future I believe it's important that simple, consistent, and safe casting functions be built into the language.
There are really two different issues with parsing strings into other types and this RFC only addresses one of them. This RFC always assumes that you want to explicitly handle failed parsing. For another example, look at C#: It has two sets of methods for these activities, the `Parse` and `TryParse` class methods. These allow the programmer to signal intent as well as ensure correct behavior. The `Parse` method raises an exception if the conversion fails were as `TryParse` returns true/false on error. These PHP functions are "ok" but the naming convention implies the `Parse` behavior while actually behaving like `TryParse`. I personally think if they're going to use functions for this, it would be best to copy the C# naming and provide both sets of functions: try_parse_int($value); // return value or false parse_int($value); // raises error if $value can't be parsed as int try_parse_float($value); parse_float($value); ...etc... 
OK thanks for the precisions. &gt; the E_DEPRECATED message is triggered when we actually populate the $HTTP_RAW_POST_DATA So that means that POST requests will trigger that notice I guess? (i.e. it depends on the incoming request, not the PHP code?)
Or, install Vagrant. :)
1. Travel back in time to 2002. 2. make videos with yourself in them for no particular reason I can't be bothered keeping this up.
The act of forming an orderly line of where the person at the front is the one getting served next. Think bank lineups, or waiting to renew your car insurance or something similar to that. It relates to RabbitMQ because that's pretty much what it's for - creating an ordered list of jobs where the background workers will usually (rules can be made for priority and worker selection beyond this) prioritize the jobs the come in first as the ones that get done first while the others wait for a free worker. This is useful in PHP because you don't necessarily want to leave the webserver (and the user) hanging while a time consuming job occurs. The job gets pushed in to the queue, and it gets completed whenever a worker has time to do it. Meanwhile the web request doesn't bother to wait.
This was a really interesting show, but it was a little too much fluff. These guys are all really smart and I would have loved for there to be a ten minute jargon filled debate or lecture. Anything I didn't understand I could google using the VOD later. Just seemed like such a waste to have these really smart internals people and ask them about high level stuff.
Honestly, the biggest problem that I'm running into is that it feels like every search that I do to look something up, I have to fight through every example using mysql. I was working through a guide on creating logins and login security and I ended up spending about 2 hours converting it over to SQL from mySQL commands. (It definitely helped me learn things quickly though.) 
As the old adage goes: "A man who likes sausage shouldn't ask how it's made"
Because http://mysite.com/about points to the about page but so does 55.24.226.85/about and you don't want that shit indexed by google. Why would you use C++ to build a website? Are you a masochist? 
Except when on a train platform, then for some reason you'd think the world was ending and it was the last transport to safetye
It was 3:00am when we started and 4:30am when I bailed, I was really really tired ... I failed a bit there ... sorry about that ...
I think anyone who does `to_int((int)...)` probably needs another cup of coffee. ;-)
&gt; However, if we are ever to get scalar type annotations in the future I believe it's important that simple, consistent, and safe casting functions be built into the language. I think having functions built into the language plays second fiddle to coming to a consensus on how the actual conversion rules should work. For example, I would consider it a massive failure if this RFC passes as proposed, and we end up with `to_int('10.0') === false` but `to_int(10.0) !== false`. But obviously some pretty smart people disagree with me on this, as it's been explicitly decided to work this way.
Seems like a Mocha (et al?) clone in php. Useful if you prefer BDD testing.
Given that the OOP concepts and underlying syntax are virtually identical between PHP and Java, what do you think makes learning it with PHP awkward where learning it with Java is not? (Bearing in mind that OP has been programming in PHP for a decade.)
It might help to think of interfaces in terms of cables. Remember when every cell phone had its own proprietary charger, with a plug that only worked for that one particular cell phone or brand? Pain in the ass, wasn't it? Then some wizard came along and said "hey guys, let's come up with one kind of plug and all use that one plug and then we can all share chargers!" Thus USB chargers came into being. USB is an interface. Cell phones are classes. The charger is a class. The USB cable allows all cell phones that are designed to work with USB to use the same charger, just as all classes that implement a particular interface can be used by any other class that accepts an instance of that interface.
You can do something along the lines of define("WP_HOME", $SERVER["HTTP_HOST"]); To set the site home dynamically. Of course, this means it will be set to whatever HTTP clients send, if your webserver still serves it. This could be an IP address, wildcard sub domains or even "@#£%&amp;-+*?!;€™®©" depending on your webserver setup.
We actually use Drupal a lot. And i'm sure we will use Drupal 8 as well, as soon as it's stable. However, this was not a reason for us _not_ to create Bolt. Drupal is a huge, complex system, that is best suited to make big, complex websites. It also takes some time to configure it properly, so it will keep the editors happy. Also, theming it can be a time-consuming job, if you need to do it properly. Bolt on the other hand is much quicker to set up, and theming is straightforward, and editors usually get it immediately. However, Bolt is less suited for multi-sites or websites with complex role-structures or editorial workflows. So, for us they co-exist happily. We choose one of them (or something else entirely), depending on the wishes and needs of the client. **tl;dr** Choose the right tool for the right job.
Actually, right before I started on Bolt, Drupal announced they would use Symfony's kernel in the next major version. Drupal 7-something was the current version back then. 
I can't find anything about translation in the documentation. Can you translate the admin panel to a non-english language? Is it possible to create a multilingual site?
Non-scientific. Methodology was to spin up an an out of the box install on a standard Ubuntu 14:10 / PHP 5.6 environment. Prefill the database with dummy content. Here's what I get in the Backend: **Dashboard Page:** Total Time: 177ms Memory: 8MB DB Query Time: 10ms **Backend Content Listing** Total Time: 263ms Memory: 10.8MB DB Query Time: 18ms **Frontend Home Page** Total Time: 214ms Memory: 8.8MB DB Query Time: 12ms **Frontend Single Page** Total Time: 160ms Memory: 6.2MB DB Query Time: 10ms 
Well said!
You could (or should) still use a VCS to keep track of the changes, and then use whatever technology (FTP, torrent, ...) to upload revisions to production ; by replacing all the files at each deployment, you would make sure that what is in production matches a revision on your VCS.
I would argue sticking to popular solutions can save your lot of time. EG Php, mysql. But maybe you really love SqlServer (I thought it was fine back in my .Net days). But when you want to get a bit serious about stuff, it can be a lot easier to walk down the well troden path. 
It's well written, the various architecture examples speak volumes about the issue. Kudos
Hi! I'm very interested to become more familiar with php. So far I actually did the codeacademy php-course (I see that's week 1). I'm familiar with Linux for several years and have experience in skripting, programming and databases. Can you elaborate a bit more how you plan to get this thing rolling? I'm asking because if I register, I would participate from overseas (Germany) and if you plan meetings and tutorials via IRC or another form of chat-protocol I think I will not wake up for that meeting in the middle of the european night ;-)
nvm it works now
yes.
If you use a well written query builder library or ORM, you should be able to easily switch between the two. If you have access to something that's not MySQL and are experienced using it, there's no reason to switch *to* MySQL.
You should be able to just do $article-&gt;author-&gt;name or something similar, the author data should be loaded before the $article variable is passed into the view/template.
He was using mysqli_query() and also had post data straight into the mysqli_query without any sanitization.
As I stated in the first paragraph of my post, Vagrant is definitely worthwhile considering for projects that are more than few pages in size. But the built in web server is handy to have if you need to test static pages, or simple PHP applications. 
The main advantage of using exceptions for a lot of things is that they bubble up, and can be try/catched anywhere you want. The "exceptions should only be used for exceptional cases" is nonsense, what you should strive for is DRY and maintainable code, not some randomly invented principle. For example, say you have a ThingController that calls a ThingManager that calls a ThingRepository and invokes a ThingValidator. If a validation error occurs somewhere deep inside this hierarchy, rather than calling a method like hasErrors() or returning false and calling getErrors(), you simply throw a ValidationException. This exception can then be catched anywhere you like - at the controller level, or at an application-wide level (for all controllers), for example if you're writing a JSON API and want to have a standardized response layout for validation errors. This sort of thing is almost impossible to achieve without exceptions. That being said, you should code to avoid exceptions where appropriate. For example, assuming that a "not found" error *doesn't* need to bubble up, we can replace the following code: try { $thing = $service-&gt;getSomething($name); } catch (SomethingNotFoundException $e) { // do something else } With this: if ($service-&gt;hasSomething($name)) { $thing = $service-&gt;getSomething($name); } else { // do something else }
I think it depends on the situation. If ALL subclasses of the ShipAbstract class need that interface, than we should force it in the ShipAbstract class. So ALL subclasses must have it, either inherited from the ShipAbstract class or overriden in the subclass (like chalne pointed out). If, in the contrary, only some of the subclasses of the abstract class will need the interface, you CAN NOT force it in the abstract class. Furthermore, if the interface will not be used by other classes outside the ShipAbstract class tree AND will be needed by ALL subclasses of the ShipAbstract class, then we might as well just forget about the interface and force the contract in the abstract class itself. Do I make sense? :)
I don't agree with the statement that the abstract class is a contract by itself, it's a optional helper class in my opinion. Centralizing the implementation of the interface in the abstract reduces code but defeats the purpose of an interface. The `EngiShip` class is leading and should therefor implement the contract (interface). Setting a new/different interface on `EngiShip` that extends the `ShipAbstract` which also implements `ShipInterface` feels to me that something was not setup right from the beginning.
If you have wildly differing public surfaces on your classes, maybe a single abstract class is not the right choice?
If the concept `Ship` needs differing public surfaces, a common abstract class might not be the right choice to begin with. Interfaces are bare bones public surfaces and no matter the implementation details, they will give you what the contract states. Implementing the interface on the abstract class saves code copy/paste. The details of the implementation are just that, details. Your `EngiShip` might implement its refuel method differently, and thus need to override the abstract class' implementation, but it still does what it says on the tin.
All `Ship`s should implement the `ShipInterface`. That is why you have a `ShipInterface`. `ShipAbstract` is merely there as an optional class to reduce the code that might be used for all `Ship`s. So in my humble opinion there is no 'situation' here. Using an `ShipAbstract` as a contract feels wrong, it does not enforce the implementation of methods and circumvents the reason we have interfaces to begin with. When you use IoC you always use inject the interface and not the abstract class, otherwise you will force other classes to extend the abstract class AND overwrite the methods if needed.
It really depends on what your interface is for and what you're trying to accomplish with it. I've used both approaches extensively, and you can't choose one carte blanche over the other. I'll try to provide some sort of examples to explain what I mean. My interpretation of what you're trying to accomplish with the ship interface and ship abstract is akin to a foundation. If every ship must implement your ship interface to effectively be a ship (ie contract via interfaces), then anything naturally extending your ship abstract should include it too otherwise it wouldn't be a valid ship. In such case, I'd recommend implementing the interface with the abstract otherwise extending the ship abstract would give a false sense of validity since I'd assume such an abstract would implement the interface. If the ship interface isn't a global generic, but instead a specialty like docking to a specific type of station, then implement interfaces as needed with children and not generally through the abstract. If what I've provided sounds a bit like a cop-out to you, then you'd be spot on. The importance of your decision is dependent entirely on what you're trying to achieve with it. Generalities should be addressed as far up the chain as possible whereas specialties should be addressed further down. If you were to extend the ship abstract with a child class, would you assume it to always implement the ship interface? If yes, then implement it in the abstract, otherwise go with the child. I'd also like to note that your abstract isn't "contractless" by avoiding implementing an interface because it still has its own public API. That API is a contract of its own. All an interface provides is an API definition without implementation whereas an abstract is an API definition with an implementation whether partial or complete.
The interface is a type and you would use it to explicitly type parameters of methods so you can force a contract without having/needing a concrete implementation. The abstract base class is purely a helper class in which you can define functionality that might be shared by multiple classes but you want to communicate that this class should not be instantiated by itself. Therefore: class EngiShip extends ShipAbstract implements ShipInterface { } Is correct. 
The same here. Really interested though.
Why using this instead of PHing?
On the other hand, wouldn't the less familiar PHP developer benefit more from this approach?
This is the book i started studyin php with i had no experince with php before so i guess this is what you are lookign for, you cna propbly find some free online pdf somewhere if money is an issue. http://www.amazon.co.uk/architects-Zend-Certification-Study-Guide/dp/0973862149/ref=sr_1_2?ie=UTF8&amp;qid=1413888893&amp;sr=8-2&amp;keywords=zend+php
phptherightway goes straight from "installing php" via "coding style" to "dependency injection". I'd suggest reading it AFTER learning the basics of PHP web development.
How about http://www.codecademy.com/learn, it teaches the very basics.
I vote for the first one. No seriously. Result will vary depending on your PDF. Try this: [class.pdf2text.php](http://pastebin.com/dvwySU1a)
At this point programs that do string manipulation and don't treat all strings as Unicode are broken, plain and simple. 
- For every programmer [Code Complete](http://www.cc2e.com/Default.aspx) is a must. Don't let it discourage you that the book is older. It talks about stuff that's eternal like naming, formatting, commenting, structuring your code etc. and it teaches you how to think about things that are not mentioned in the book. - For PHP programmers [PHP Objects, Patterns, and Practice](http://www.apress.com/9781430260318) is a good book. It's not meant for total beginners in that it doesn't teach you syntax, but it starts with basic types, anonymous functions, OOP principles and goes from there, to design patterns, enterprise patterns, best practices, versioning, testing etc.
Sorry, I'll add that.
I'm interested, but I may not be a good candidate. I've been working with php for years now, but I was self taught. I may have some 'bad' tendencies. I have experience tooling around with wordpress, and building out large sites using CI. Heck I just released this site: http://such.ly which uses a ton of php and javascript/ajax to access php scripts. Do you think I know too much to do this?
If you need to do a queued action inside another, could you not just put the new thing on the queue again (or another queue)? All languages are fundamentally scalable - it's architecture that gets in the way. 
You are starting wrong. You are trying to use inheritance for classes that represent physical objects - which is a fundamentally bad idea. Inheritance is OK for things that exist only in a computer, but for real objects you should only use composition. And the interfaces should be defined on the class where they interface is implemented, shitty example ahoy: abstract class FileFilter implements Processable { function process() { //Does some processing //possibly calling an abstract internal method } } class GzipFileFilter extends FileFilter implements Cacheable { function getCacheKey() { //returns the cache key this should be stored under } } So long as you use the interface name where you are trying to imply that the interface is required, rather than substituting the abstract class name as a pseudo-interface, then it shouldn't be a problem.
Even if you're using Laravel it doesn't do EVERYTHING for you. You still need your own objects to actually do anything, so you will be writing classes. Nobody is ever going to ask you to do what components of Laravel already do. If someone ever does ask you to do it, awesome, you know how to use the Laravel components and can STILL DO THE ACTUAL TASK. I think you may need to scrap the current way you learn to program because it most definitely isn't working out for you.
Apologising for not Apologising, definitely British! :-P
The problem with that is what happens if you care about that result for your current action, such as getting a list of who you are following in order to build a feed.
Righto. Well, if it's a blocking operation it's a blocking operation - wouldn't that be a problem in any language? (I may be missing something, and I obviously don't know your use case). 
He was wearing a bowler hat when he said it too. /me pops off to buy a new briefcase. 
In languages with light threads (go, java, etc.) the thread waiting doesn't really matter, but with PHP it is a full operating system thread, with a full allocation of resources (pid, fd, ram, etc.) It also would not matter in an evented language (node, dart:io, etc.) because you just have a little callback ready for whenever the reply happens.
dont do it in php ... use some command line tool that can extract the text (like xpdf etc) and just catch the output within php and store it somewhere there might be newer/better tools than xpdf, thats just what we happen to be using 
mPdf worked well for my needs. Used it mainly for converting html to printable pdfs.
Yep. A bit more complexity is just what I would have liked. It would have come at the expense of junior developer familiarity, which is a balance that it's up to the host to strike.
Can you use pthreads for that? I had a play with it recently, it's very cool (does require a recompile of the PHP binary on Linux though). Of course, some architecture issues are as political as they are technical. Your PTB sound like they're happy with PHP overall, but you might be able to lobby for some Node/Java to process part of the queue. You can reassure them that heterogenous environments are very common with non-trivial applications (and the only downside can be managing complexity and hiring, but they are not insurmountable difficulties). 
Have you ever considered the Symfony CMF (http://cmf.symfony.com/) as a building block for Bolt?
We have considered it _very_ briefly, and very quickly came to the conclusion that we would absolutely not use it.
&gt; any suggestions of where I can go and look? Yep, use Reddit search and go through the [hundreds of other threads](https://www.reddit.com/r/PHP/search?q=tutorials&amp;restrict_sr=on&amp;sort=relevance&amp;t=all) that get posted here every day, including the [one from an hour before yours](https://www.reddit.com/r/PHP/comments/2jvkuq/any_modern_introductory_booksguides_to_php/).
I agree that we have one more case of duplication. Here's an idea: - Add to_bool too, make this the definitive way to cast stuff - Place a notice or something (PHP 7) on all the others functions (filters that do the 'same' thing, intval, (int), etc) that it will be deprecated *on the future*. Then 20 years (lol) from now you remove them from core. Why? Because them we can slowly move to a single implementation. And people who like using the best available options will know that THIS is what you want to use. I think this could be done to a lot of things because: - It doesn't break anything - It doesn't force people to touch their codebase if they don't want to (is 20 years enough time??) - It provides a way of saying "one day this will be the only way to do it, so if you have the option please use it"
Can you please share some more details on why you avoided the CMF? I'm new to the PHP/Symfony world and the whole CMF-thing seemed like a good idea. As I am in the process of moving away from a custom-made Python/Django CMS (no time to mantain it) I am looking for something a little bit "future-proof", built on top of real software design principles (so that one popular PHP CMS is totally off the table :p).
I don't mean to start any shit as much as to point out what seems like inconsistencies in this subreddit but wasn't there some bullshit with ircmaxell being banned or something for posting links to his own site? I am not against posting links to your own site, just looking for some consistency in how the rules are handled.
&gt; Why would you use C++ to build a website? Are you a masochist? Why not? Besides a masochist would build his/her web site with Bash, which is possible.
There was a discussion about this a while ago: http://www.reddit.com/r/PHP/comments/2bb79c/pagekit_a_new_modern_cms_built_with_symfony/cj3p00n Also, there are _no_ CMS'es that I know of, that actually use CMF. None. 
It really doesn't. Programs that deal with strings, and don't use a Unicode encoding, are broken, plain and simple. To maintain any other position is to ignore the international nature of the modern world. Even if you don't support multiple languages, right-to-left text, et cetera, you're still liable to deal with characters that come from outside some arbitrary non-Unicode character set. The exception, of course, is if you're not doing "*string manipulation*", which is why my comment made that qualification. If you're not actually manipulating the strings in question, it doesn't matter whether you treat strings as Unicode or not. As long as you pass them through in an 8-bit clean manner, Unicode strings will be "*handled*" just fine.
I think it is OK to post links to your own site, as long as the quality of the link is decent, which I think this is.
I think that if you already know CakePHP and the Crud plugin, you have a really good chance of success by using Cake 3. Those two combined are a very powerful and flexible tool for building rest API's the proper way. Is there anything I can do to help you in that regard?
Both are true. If the ups/downs are mostly downs and the author continually posts, they'll more than likely be banned.
I would also vote for exceptions instead of error values, because: * FALSE *is* a valid value in my opinion; especially * if `to_bool()` were ever to be introduced, it would either be inconsistent with the proposed functions, or impossible to tell whether it had errored Also, the example given: &gt; `if ($value === FALSE) { … } else { … }` vs `try { … } catch (Exception $e) { $errored = true; … } if (!$errored) { … }` seems like a red herring: why not do move whatever was going in the `if (!$errored)` block to the `catch` block?
Just wanted to add that CakePHP is very well supported, specially the version 3, which will have a release candidate before the end of this month. If there is a moment to start looking at what this new version has to offer, it is now :)
It's worked for me plenty in the past, I've updated all of my other languages up to standards, now I'm bringing PHP up to standards. I learn by creating a framework because I learn how to BUILD MY OWN OBJECTS the right way. Which seems to go over your head.
Agreed. So let the up and down vote's do it's job. If people want him to stop posting they will down vote it to oblivion. I can see why you asked the question though ;)
The global Reddit guideline is 1 in 10. As in, out of every ten links you post, only one should be to your own site. Obviously mods of specific subreddits can apply their own rules, but it'd be hard to defend a zero tolerance policy when the admins are cool with it.
Well, a perfect example was raised on this subreddit today. Go find me a decent PDF library. A few of them didn't even have descriptions until I sent them pull requests. The whole first page looked like crap, or framework specific, or framework specific crap. :-/
I think `mb_ucfirst()` is the only thing that's missing in terms of PHP and Unicode.
When a sub gets big enough, the voting system starts to break down a bit though, and moderation becomes more important. I don't know if this sub is there yet (I'm usually happy with the content that shows on my front page, but I don't visit the sub directly), but at some point voting won't be enough.
If you don't need to be strict on validation, you can simplify this by just stripping all non-numeric characters. preg_replace('/[^\d]/', '', 'WordWord999'); // 999 This replaces all non-digit characters with nothing, leaving only the numbers.
Wich PDF library do you recommend? Im using mpdf
I've not been posting at all over the last few months. I took a little break from Reddit. I'll keep a balance in mind as I post more, but this specific post was in response to a similar blog post, which was posted by their author. Had to self post to match that self-post. :D
I don't have a problem with you posting your own links. Just that some others are not necessarily allowed.
Chech out what RSS is, and your question will answer itself
He was just using this as an example. Almost every explanation of the Factory Pattern that I've read has used a Car object as an example.
Used tcpdf extensively and I'm very satisfied with the results.
It's easier to get the results you want with php without sticking to oop.
/u/ircmaxell was *not* banned by the moderators of /r/PHP. He was caught by the antispam filter that reddit.com uses. We petitioned to have him unbanned. We encourage content creators to create and post their stuff here (as long as it's quality)!
Hello! Thanks for your interest! Hopefully we'll keep the bulk of interaction on the forum at [grokphp.buscommando.com](http://grokphp.buscommando.com). Since since we've got folks from India, Europe, and the Americas all participating I believe an asynchronous discussion forum format would be best. I don't have any plans that involve everyone being in front of their computers at the same time. The goal is to have the majority of folks doing the same exercises and reading the same material during the same week, so we can all help each other learn and provide support and encouragement. If you've already done the codeacademy, there's no reason you cannot work ahead - if anything, being ahead of the course would put you into a good position to assist the folks who are struggling with material that you are already familiar with. Let me know what you think
Hey, I'm copying my response to renser as a reply to your comment so you get your oranged... Hopefully we'll keep the bulk of interaction on the forum at [grokphp.buscommando.com](http://grokphp.buscommando.com). Since since we've got folks from India, Europe, and the Americas all participating I believe an asynchronous discussion forum format would be best. I don't have any plans that involve everyone being in front of their computers at the same time. The goal is to have the majority of folks doing the same exercises and reading the same material during the same week, so we can all help each other learn and provide support and encouragement. If you've already done the codeacademy, there's no reason you cannot work ahead - if anything, being ahead of the course would put you into a good position to assist the folks who are struggling with material that you are already familiar with. Let me know what you think
That makes sense. Good explanation. In our codebase, we have a class that is basically like this: class Response { public function __construct(bool $passed, $data = []) { $this-&gt;passed = $passed; $this-&gt;data = $data; } public function passed() { return $this-&gt;passed === true; } public function failed() { return $this-&gt;passed !== true; } public function $data() { return $this-&gt;data; } } Most methods return a Response object, so for something like this, I might write: public function getSomething($name) { if (!array_key_exists($name, $this-&gt;things)) { return new Response(false, "This thing does not exist"); } return new Response(true, $this-&gt;things[$name]); } $response = $service-&gt;getSomething("foo"); if ($response-&gt;passed()) { $thing = $response-&gt;data(); } else { // do something else } It doesn't bubble up, but I also don't have to catch anything. I can pass back a single message, or I can bundle them up and pass back as many messages as I want in a single response. With exceptions, in my experience, they tend to be one-shot things. If the Thing doesn't exist, it throws an exception, so I don't get to the next item in the validation list, which may or may not exist, and if it doesn't, then that throws an exception too. For instance, if I'm validating that the user's email address and password meet acceptable criteria, in a standard exception scenario, I'd throw an exception on the invalid email, but maybe they also put in a password that's 1 character long... the exception was already thrown for the bad email, so they don't get the error message about the password until the second time they do it. I suppose you could have a bunch of if statements to detect all the different errors and then throw a single exception containing all the error messages, but I don't see how that's any different than just making all the if statements and returning an array of messages to begin with. I also don't fully grasp the bubbling up process. I haven't been able to pinpoint exactly what the problem is, but sometimes I'll throw an exception somewhere and try and catch it somewhere else, but it never gets caught, even though it's clearly getting thrown. I don't think the guy who built this system fully understands either, because we get email messages when exceptions are thrown, and sometimes the stacktrace is the error handler itself and not the actual thing that went wrong. Very frustrating. Anyway, just rambling a bit here. Thanks for your explanation, it was very helpful. 
Eh. okay. I respectfully step down from the soapbox and thank you for clearing it up.
No, I don't think you know too much to do this. Your existing experience could be very valuable to folks that might be stuck on concepts you are well familiar with. As far as having 'bad' tendencies: the book we plan to use for the bulk of the study was published in 2014, and has a focus on current best practices. Perhaps the material will help you shed bad habits and condition yourself to new, good habits? You might be bored the first two weeks (especially since you've built complete apps with PHP already) but I do believe your experience could benefit the group and the group can offer some benefit to you!
When using command line based tools inside of PHP, what is the best way to handle it? In one of the scripts I made a while back I had to use a command line tool and capture the output. The command line tool I used had an option to print to a file so I just had it print to the file, and then I opened the file in PHP and then afterwards deleted the file. I tried to google for the best way to deal with this type of situation because I just feel like the way I am doing it is some what hackish and I felt like I was severely missing some type of error that could of happened.
But not for the described use case.
I wasted an entire day trying out FPDF, TCPDF, DomPDF trying to generate 100 page documents. Problem was it would take 7-10 minutes to render the PDF. Downloaded wkhtmltopdf and set up a script to save the HTML and call wkhtmltopdf and it rendered the same document in about 5 seconds. I imagine looping through 1000's of PDFs and searching for text is going to be very similar, so I 100% agree that PHP is not meant for encoding/decoding PDF's unless they are very small (a simple invoice or couple page documents)
for creating simple pdfs dompdf is very good, for big documents i would use a html2pdf tool too
My vote's for [dompdf](https://github.com/dompdf/dompdf). Pass html in, outputs PDF file. It can't get any easier than this.
I think this is an excellent resource for intermediates (for which +1) but for beginners it's a lot to take in, and rather fragmented. 
Video got moved: https://www.youtube.com/watch?v=t9bkrixyQjQ
You should always favor (note: *favor*, not *use*) composition over inheritance, and the decision to use one or the other has nothing to do with physicality.
Oh cool. I've used mocha before, but currently use Jasmine for my js BDD testing. Thanks for the context though, I did see some syntactical similarities to Jasmine when I was first looking through it.
Absolutely. One of the best things about the Ruby community is that they don't do this shit at all. People are busy building a startup, a cool service or an amazing package because they're not trying to build the 6,000th router. They just use Sinatra or Rails and get the fuck on with their day. I don't know why the PHP community is different. It seems intent on wasting its time on stuff thats already been done to death.
Aw, but that lacks the aftershow :(
We could always do another. Maybe one where I haven't been up for 24 hours, having just gotten off a 10.5 hour flight... 
Started using hack some time ago. Stopped using it, and now using it again. Only pitfall I have vs PHP is IDE support. OSx support missing is not that bad, just use a virtual box to run it in. So please phpstorm add hack support, which should have to be full blown but just a tip would already be helpfull; - &lt;?hh - : int (return type hinting) - scalar type hints - public function __construct(private Map $params, private int $length) support And most of the red lines would be gone for now :P but hell a boy can dream
On Ubuntu 14.04, it's in the repository ( apt-get install php-apigen ). Easy to use, and if you are on Ubuntu 14.04 it works out of the box. With my code, phpDocumentor takes 2-3 hours to generate doc. ApiGen takes about 2-3 minutes.
Sorry, but Canadians are the best apologizers.
Bit of a dig to get there, but there are tests with the extension ... https://github.com/krakjoe/ustring/tree/master/tests
Thanks phil, I can always count on you to write an article where the topic doesn't matter at all. Your next one should be on the best editor, and following that you can do a dissertation on tabs vs spaces.
Using mpdf too, but the styling options could work better.
the best way imo (at least thats how i deal with it) is to use a job server like gearman and remove the whole procedure from the front- to the backend. the flow will be like this: php script &gt; calls gearman worker &gt; gearman calls a function (which indeed can be coded in php, using something like the symfony process component) &gt; output gets stored in a json file or database &gt; frontend grabs the data from database. if someone has a better solution, i'd be glad to get my hands on it.
I can usually count on 99% positive feedback, then one or two people to just be snarky little douchebags. Thats how putting articles out in public seems to work. I wouldn't expect everyone to be interested in every article I write. That would be weird.
I sometimes (eg. in laravel) see traits used to share base functionality. When would you use an abtract base class and when would you use traits?
I personally like tcpdf.
i like apigen for its flexible layout. With only minor work I could integrate it with wordpress: http://phpixie.com/api/
One obscure use for max() is determining whether all elements of an array are null: var_dump( max(array( 3, 4, null, null ) ) ); # 4 var_dump( max(array( null, null, null, null) ) ); # null 
The Symfony2 documentation is pretty great. They have full documentation of all the various things you can do in the framework. Plus documentation of each individual component (the framework is built up of many components, so these docs cover all the edge cases and other small things you can do). Plus a full API doc (a website version of the exact documentation on exactly what each function in the framework accepts, does, and returns) Plus a cookbook which shows examples for commonly done things that pull multiple features together.
https://github.com/KnpLabs/snappy
I suggest using Apache tika to extract the text from the PDFs then pass them to a lucene based search engine like Apache Solr or Elasticsearch, Don't let the jargon lure you, both are relatively easy to setup and start with. The PHP side will only query the engine and return results.
This did NOT work well for me for creating books. Also the code was extremely messy and difficult to tweak. DO NOT RECOMMEND unless you never need to modify and only export 1-2 page files at a time!
Hey all, I'm one of the authors of Peridot. A huge incentive for us to write Peridot was to enjoy testing the way we do in a lot of our other favorite testing tools: (Jasmine:JS, Mocha:JS, Ginkgo:Go, RSpec:Ruby, etc). We really wanted to make something extensible, and we think our first stab at that was a good one. Check out the [yo plugin](https://github.com/peridot-php/peridot-yo-plugin) or an [example](https://github.com/peridot-php/peridot-scope-example) using scopes to add webdriver methods to your tests. I know you can't always write something that fits everyone, but we are hoping Peridot is another useful tool in the PHP developer's toolbelt.
It looks like a lot of work went into it. I'll be sure to give it a whirl if I ever get back into PHP dev.
This is an awesome lib for interacting with wkhtmltopdf. https://github.com/mikehaertl/phpwkhtmltopdf
Use a VM!
Why? Because this new developer's way is *obviously* better and will be blazing fast, awesome, and kick everything else's ass. At least, that's how those guys who keep reinventing their frameworks try to tell me. 
One thing you might be missing is that PHP has recently had a framework renaissance. We used to have the likes of CakePHP, WordPress (as a framework), etc. Suddenly the rug was swept out from under the established frameworks with a bunch of new players with new ideas. They're on top now. It must be tempting after a revolution to try and push the ending just a little bit further so that you'll be remembered in the history books as the revolutionary that changed everything. At least that's how I rationalise all the rebuilding of things.
Traits can't have properties, so if there's an expectation that the abstract class has a set of class properties that will be set in the constructor of the child and used by other methods in the abstract. That would be an example where traits wouldn't cut it. I don't like the idea of forcing a child constructor to do a specific thing, but I have seen it done.
I saw that, and was ready to use it, but then just did my own thing that seems to get the job done just fine: public function render($report){ $this-&gt;fileName=md5(rand().microtime(true)); file_put_contents($this-&gt;fileName.".html",$report); $execPath='/usr/local/bin/wkhtmltopdf'; exec($execPath.' '. $this-&gt;fileName.'.html '. $this-&gt;fileName.'.pdf', $output); return; } public function serve(){ $pdf = file_get_contents($this-&gt;fileName.'.pdf'); header('Content-Type: application/pdf'); header('Content-Length: '.strlen( $pdf )); header('Content-disposition: attachment; filename="' . $this-&gt;report . '.pdf"'); header('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT'); echo $pdf; unlink($this-&gt;fileName.'.pdf'); unlink($this-&gt;fileName.'.html'); } Basically saves the HTML document I generated to a file, calls wkhtmltopdf to convert it, and then serves the attachment, and finally deletes both the HTML and PDF files.
Wow - if you get any form of Windows support I would be surprised - is that seriously coming?? Don't know why they would waste the development effort personally... And as below/above said - use a VM or Docker for a HHVM instance.
I've seen people code up in normal HTML and CSS and then run PhantomJS page grabbing tool and using that grab to output to PDF . I don't know the limitations but it seems really smart and clean to keep your presentation layer consistent throughout your app. EDIT: Just realised Op wanted a tool to read PDFs. My bad.
It doesn't matter between those. They all will install pecl extensions without a problem. I use Chef at my company, so we just put: php_pear "mongo" do action :install end in a recipe and call it a day. However, the chose between Puppet/Chef/etc. is more than just "which will do the job" since they all will do it, just with different syntax.
I am recalling Akihito Koriyama, who once mentioned on twitter than the [Di](https://github.com/auraphp/Aura.Di) docs of aura is one of the best one. I do believe reading through each version is nice to have. http://auraphp.com/packages/Aura.Di/ . In the sake of making a unified way to docs, I have started a small project which can render docs from the github markdown. Eg can be seen at http://ghdocs.herokuapp.com/harikt/aurav2book/master/manuscript/introduction.md . It is very flexible to be hosted removing the {username/org} or the repo name itself.
Thats... what I suggested?
I don't get it. That's exactly what the article suggests.
Well, it'd be quite easy for IDEs and static analysers to detect this. :)
https://github.com/laracasts/larabook this was build in this series: https://laracasts.com/series/build-a-laravel-app-from-scratch
I'll use butterflies to build my website. 
http://labs.ft.com/2014/08/not-everything-is-awesome/
The change to the constructor signature itself is completely valid, you can also do: public function __construct($param1) { } That is, just drop the second param. The IDE doesn't connect the dots (just see's a changed signature), a static analyzer might however. I did throw this in phpStorm 8, and it understood that the argument unpacking would (potentially) meet the requirements of the parent constructor however.
Great! I loved Yii 1. This is definitely interesting to see!
Wow never thought of this use case, that's indeed pretty awesome. I hope PhpStorm's autocomplete will not go berserk because of this too.
I'm not saying I'm anti-drug or anything here... but if I were trying to attract a developer to do work for me, I would not post it from an account where many of the other posts are in /r/trees and /r/drugs. Better to keep your personal goofy stuff separate from the biz. We all have it, but it's going to turn-off some potential candidates.
Related to this: http://www.reddit.com/r/PHP/comments/2jvvol/rfc_ustring/
Yes it'll have the same syntax, but without scalar types it's just a half-solution. It's really a shame that every discussion on *optional* scalar types devolves into a flame war...
&gt; Those are just pulled directly from the annotations in the source code and assume that you already have some familiarity with how things work. This is not how to document an API. ZF1 and 2 are also guilty of this.
As for those "Different Unicode character sets can still be used to defeat this method." regarding mysql_real_escape_string() - Anthony Ferrara answers it best. http://stackoverflow.com/a/12118602 Basically it's a character encoding exploit, and you have to be using one of a few specific encodings - so conditions have to be just right.
Thank you guys for replies. What i was thinking that,if i can store whole pdf text into DB when I upload a new one, then find a string from DB . Do you think that's gonna work??
If I were to implement scalar type annotation I would only allow that *exact* type. It's up to you to cast the value to the proper type beforehand if it's not already the correct type. This completely bypasses the issue and lets you handle the conversions the way you think makes most sense.
&gt; I tend to think of Behat and PHPUnit as being complimentary, rather than alternatives to one another. Unit vs. BDD style testing. I agree, yes, but together they cover the space of what Peridot seems to want to do. I don't think it's bad having them separated. &gt; I actually like the idea of event driven plugins, I'm sure there's more than a few use cases. Probably. I *do* like having event hooks, but I'm just not sure if they're needed in a testing framework. Would like to hear some examples of where they'd be used. &gt; I'm not sure the origins of the describe/it syntax I don't know where it started either, but it seems to be quite popular [in JS](http://mochajs.org/#synchronous-code). &gt; not sure what other syntax would make more sense for this style of testing. PhpUnit's syntax is fine. It doesn't need to read like English. Non-programmers aren't going to be able to write the tests anyway. It just seems way too cutesy with no real gain. I don't necessarily think Peridot is bad, but I really like having a definitive testing framework. When I jump from project to project or want to help out with some open source project I can know how to run and create the tests without having to learn an entirely new testing framework just because someone thought they were clever. Therefore Peridot has to offer something new and worthwhile otherwise we're better off if it didn't exist.
I think you're probably right. I got excited about Laravel when I was watching their screencasts about Laravel 5. But the annotated routes threw me off a lot, I really don't like them. I will still continue trying it out, but yeah, for my next project I'll probably go with CakePHP 3 + CRUD. I'm guessing I would have to alter the CRUD plugin a little bit. I have an idea to create some extra conventions that would make expanding the app even easier. I want to share my idea with you, because very often I think I've thought of something awesome and then a more experienced programmer tells me why it's actually a shitty idea, and I learn from that. Basically I want to have / make these conventions: - Connect any route in the form of /controller/action/arg1/etc to the appropriate controller and action. (Those default routes have been deleted in CakePHP 3.0, but it's easy to get them back) - If the action or controller doesn't exist, then let the CRUD plugin take over. (I know the CRUD plugin already takes over when the action doesn't exist, but I'm not too sure about if the controller doesn't exist) - If the model doesn't even exist then check if there's a view template which is in a folder that's similar to the URL. If that view exists then just return that view. I think if I use those conventions then I can avoid having to write a lot of predictable code. What do you think?
I can't recall the last time I needed to refer to API documentation like this. Why not just click around the code, or read the intellisense?
Well I hope some day there will come scalar type hinting (although type hinting will be renamed as far as I remember an RFC for it) But then if I say int it must be an int and not an int likt. Because well then you become more compatible with hack, so going to hack or back isn't a problem. Would be nice, then you really just use an other engine (HHVM). Next for MongoDB it matters if it is a int or an int like (dunno about other databases). 
Make an PHP file solely for the purpose of logging that data, then when the page you redirect to is loaded, load the logging PHP file through Ajax.
A trait is not the same as an interface. The purpose of an interface is to force a "contract". E.g: public __constructor( \Acme\DatabaseInterface ) You can pass any instance into the above constructor as long as it implements the \Acme\DatabaseInterface. This could be a concrete implementation or a mock object while testing. A trait allows you to "augment" your classes with functionality of another class. E.g. I use setters for dependency injection so to be able to inject something into something else I create a trait: trait UserManagerInjectionTrait { public function setUserManager( UserManager $userManager ) { $this-&gt;userManager = $userManager; } } So I can now easy "augment" any class to have a UserManager injected: class SomeManager { use UserManagerInjectionTrait; } Traits are kind of an elegant way to do multiple inheritance, something that C++ allows but many other OO languages do not. 
Writing a few pieces of meta data to a database shouldn't cause a noticeable delay to the user's experience. Milliseconds. How long does your redirect take now?
You're right. I'm thinking that a fast redirect is mission critical but the logging isn't so if the database was slowed by an errant load for some reason, maybe the user could get redirected but the logging could wait 30 sec or so. 
Maybe you should benchmark the times first, before assuming a database write slows down users significantly. What i would expect is similar to the following. time for inserting a record (ip, UA, referrer etc) into the database: 2ms. roundtrip time for your redirect (network only, not counting rendering): &gt; 20 ms. Insert time is propably the least you have to worry about. 
If you're really concerned, you could use an AJAX request and redirect as soon as the request has been sent. I.e. don't wait for a response. Alternatively, you could queue the database writing operations.
Best practice: use syslog (http://lu1.php.net/syslog) for logging. It takes nearly zero time to write your log message, because it provides you a local socket. After you have given the message to it, you can configure it to parse it and store into database or transfer to a remote server or give it to a script etc. I would recommend using syslog-ng (http://www.balabit.com/network-security/syslog-ng) for the server.
I use RHEL/CentOS servers so I package up my pecl extensions as rpms and add them to my yum repo. I then install it with puppet as a package { 'php-pecl-memcached': ensure =&gt; installed }
I see one comment is pretty close, but you need to close the session as well. This is the code I am running in production to do all my work after delivering the page and closing the connection. ignore_user_abort(true); ob_start(); // This is the HTML of the page. Echoed into the output buffer. $smarty-&gt;assign("question", $question); echo $smarty-&gt;fetch("thanks_comment_saved.html"); // get the size of the output $size = ob_get_length(); // send headers to tell the browser to close the connection header("Content-Length: $size"); header('Connection: close'); header("Content-Encoding: none");//send header to avoid the browser side to take content as gzip format // flush all output ob_end_flush(); ob_flush(); flush(); // if you're using sessions, this prevents subsequent requests // from hanging while the background process executes if (session_id()) session_write_close(); // DO Your DB work here. Browser has closed connection. Are process is still alive. 
&gt; But then if I say int it must be an int and not an int like. I completely agree, and this does seem to be the most popular opinion *by far*, but there is an extreme resistance to this within internals, so I don't think it'll ever happen.
Thanks, I didnt know about the properties :)
Thanks for your answer, but I didnt ask traits vs interfaces, as I am well aware of the use of interfaces as contracts. The question was about abstract base classes vs traits to share implementations. In the UserManagerInjectionTrait, thats something that could theoretically also be achived through inheritance.
guess it was someone saying the end-all be-all solution of prepared statements? because i was going to say the same too - until finishing the article, that's exactly the point.
I can't help that most of what you write is utterly worthless, or that the majority of your readership has about as must desire to push technical boundaries as an Amish farmer. I don't despise it because it's false or misleading, it usually isn't - I despise it because it's a waste of time to talk about the same shit day in and day out. You sit around complaining that the ruby community "doesn't do this shit at all", that they're off doing interesting things - but the irony is that *you're doing exactly the same thing*. The only difference is that instead of designing yet another framework, you sit around and write about how awful it all is. This to me is just as bad as writing the 5000th router, or the 90000th framework. I'd literally die of surprise if you did something interesting that inspired others to do the same. So do the world a favor phil, take your own advice and stop writing about the shit we already know and get the fuck on with your day.
Well first and foremost it results in a consumption issue, memory usage is increased 3 fold at least for all strings. There's not actually any getting around that. Then there is the problem that, everything is more complicated for unicode strings, the entire std ext and every other ext must be rewritten to use whatever unicode api we decide to use, so do streams, so does SAPI. This amounts to an insurmountable impact on performance and consumption from every angle. NG changes gave PHP a boost in speed by introducing simplicity, we will ruin that if we try to introduce unicode strings everywhere ... in my opinion ... it is opinion, if someone comes up with a magical way of absorbing that impact, then I'm totally up for doing that, but I don't see it happening.
Indeed. If you do a header redirect you can continue to run code after the user has already left the page.
If this is truly a problem, e.g. you got hundreds or thousands of requests every second, the easiest and most scalable way is probably just to push the data to a non-blocking stack or queue, like one of the many MQ services or something like Gearman. But since I believe that's overkill, using syslog like tommeyikya recommends is probably simpler.
This is indeed the best options if you're sure the redirect will occur and the user can't get some error.
Well, I'm not getting away from specifying dependencies - the concrete class will still expect them - but the exception will be thrown on line #14 rather than the construction definition. This was more about using __construct() as a hook in "Concrete", which is what the __constructor() is for - but handling the fact that if the signature of Base changes I don't need to modify dependent classes. Still - respect your input - cheers :) 
Yup, I've done this stuff with http://pdf2xml.sourceforge.net/ a couple of years ago. Just extract the text paragraphs from the PDF, parse it with SimpleXML, import into DB.
You could use a queue like [Beanstalkd](http://kr.github.io/beanstalkd/)? Take a look at [Beanstalkd](http://kr.github.io/beanstalkd/) and [Pheanstalk](https://github.com/pda/pheanstalk) You could then use Pheanstalk to queue logging and inserting: &lt;?php // Hopefully you're using Composer autoloading. use Pheanstalk\Pheanstalk; $pheanstalk = new Pheanstalk('127.0.0.1'); // Send your data to Beanstalkd $pheanstalk-&gt;useTube('default')-&gt;put(array('with' =&gt; 'the data')); Have a script running either by cronjob or with [Supervisor](http://supervisord.org/) that takes care of the queued data: &lt;?php // Hopefully you're using Composer autoloading. use Pheanstalk\Pheanstalk; $pheanstalk = new Pheanstalk('127.0.0.1'); // Get the next job from the queue $job = $pheanstalk-&gt;watch('default')-&gt;reserve(); // The data from the array can be fetched with the follwoing method $job-&gt;getData(); // When you've inserted the data, you can safely delete the job from Beanstalkd $pheanstalk-&gt;delete($job); It's a crude example, but it illustrates how you can queue stuff for a later time.
Amiss ORM - http://k3jw.com/code/amiss/doc/ Relatively unknown library, but really comprehensive and easy to read documentation.
To be fair, this is the exact reason why service locators are considered to be anti-patterns: It hides dependencies, it only displays errors at runtime, it makes the classes more difficult to maintain and develop against. I have strong reservations against using variadics in this particular way. 
I'm certainly not at all confused about this concept. I''ve been talking about this for over two years now. https://philsturgeon.uk/blog/2012/03/packages-the-way-forward-for-php
Ha. Right? :)
Thank you for your feedback. If you look at the upvotes on this article, the comments on the article page itself, or most of the comments on this comment thread on reddit, you'll find yourself in an angry minority. I absolutely appreciate constructive feedback, positive or otherwise, but right now you just seem to want to complain about stuff so I guess I'll just let you crack on. Let me know what interests you the most in regards to pushing the PHP community onwards and upwards, and I'll consider talking about that next.
This is perfect, thank you for this 
To be fai by the same logic one could look at the github stars of the 5000th router, find a community of people using it and thus justify it's existance =)
The HTML/CSS support is not great. I use it frequently in existing projects and it will cause problems. Read the top comments, and try some command line utilities. I am now using wkhtmltopdf and https://github.com/KnpLabs/snappy as a wrapper. Just try and compare a simple render of google.com and you will see why not to use DomPDF.
Try https://github.com/KnpLabs/snappy as a wkhtmltopdf wrapper. This library seems to fit all my needs. (Used to have DomPDF as a default which caused me a lot of troubles with HTML/CSS support, issues with nested tables, memory problems, ...) (There also is a Symfony bundle https://github.com/KnpLabs/KnpSnappyBundle)
What encoding were you using that increases memory usage 3 fold!? Ideally, if strings were stored as utf-8, memory consumption should hardly increase since in practice most string bytes are ascii anyway. I understand that a lot of complexity would fall on php extensions; but that is kind of the point. That complexity currently falls on end users of the language. Most ignore it, some solve it badly, very few solve it properly.
I met Igor at PHPNW14. Delightfully crazy. (In a similar way to myself, actually... I ended up hacking on YOLO with him)
"In the UserManagerInjectionTrait, thats something that could theoretically also be achived through inheritance." Not if the classes using the trait are in completely different inheritance trees ;)
utf16 was being used, I believe ... it doesn't much matter anyway. As a simple example, look at the consumption of wchar: http://ideone.com/P2s6XO It doesn't matter what characters are used, it doesn't matter if none are used, as you can see. I don't think the choices are support unicode everywhere, or not at all; I think a good starting place is having a tidy API. Then fix the things holding this api, and incidentally other ideas back, introduce hashKey magic so that these objects (and any other objects) can be used as array keys, maybe introduce support at the compiler with something like the U prefix we see elsewhere, maybe the ability to cast scalar to complex types so that you could $line = (UString) fgets($handle) as shorthand, again that would solve other problems. There is more than one way to skin a cat, and we did already try going at it with a big knife and peeling the thing. It did not work. We should try another way ...
Ofcourse it matters which encoding you use! UTF-16 stores unicode code points in 16bits, or for very high codepoints surrogate pairs (2x 16 bits). That not every character requires 5-6 bytes is the entire point of encoding the string! In the case of UTF-16 surrogate pairs are extremely rare, so in most cases that only doubles memory consumption. This happens to be the encoding most javascript engines use and they prove that attaining good performance using this encoding is possible. wchar is implementation defined and does not even necessarily store all of unicode. The ISO/IEC 10646:2003 Unicode standard 4.0 says that: "The width of wchar_t is compiler-specific and can be as small as 8 bits. Consequently, programs that need to be portable across any C or C++ compiler **should not use wchar_t for storing Unicode text.** The wchar_t type is intended for storing compiler-defined wide characters, which may be Unicode characters in some compilers." You should actually be measuring char16_t: http://ideone.com/HujZPY Ofcourse there are multiple approaches to the unicode problem. However, before considering performance, complete native unicode support should be preferable for a high level language that deals with text as often as PHP. Your reasoning is imho not sufficient for abandoning the attempt.
I'm not saying what the reasons are for the abandonment, I'm saying what my reasons are for not thinking it's worth trying again, yet. The fact is whatever we do we increase consumption, nothing has changed so drastically that we can afford to absorb that impact. A modern JS engine does have something that allows them to absorb that impact, a JIT capable runtime.
[Brainfuck](http://en.wikipedia.org/wiki/Brainfuck)
Yes, that language is called "brainfuck".
I'll hold off on writing my own extensions for now, I want to eventually expand my experience to a compiled language, thought a C++ extension would be a good entry point. I'm looking through the extension list at [pecl.php.net](http://pecl.php.net/packages.php), is it sound advice to use these over php packages where they solve my problem?
I've found that generally doc like this is used by less experienced programmers or when working with parts of the software I haven't used in a long time.
http://www.lynda.com/ is great for pretty much anything and everything. I highly recommend.
I asked you what blocked adoption of unicode strings, and you said "first and foremost [...] consumption". The reasons for abandoning the attempt at support are probably the same for not trying again, since unicode hasn't radically changed recently. If memory consumption is not the reason, then I ask again: why won't php7 be natively unicode? Also, if you wanted a neglible increase in memory consumption, utf-8 should have been considered. (Was it?) Any ascii string is also a valid utf-8 string. There would still be a performance hit for certain string operations, but not enough to reject the idea outright. As things are now, it *looks* like unicode has been scrapped without much consideration. I fear the proposed UString 'solution' will not be adopted by everyone (how is it better than mb_*?), and only add to the confusion surrounding string encoding.
...and here I was thinking, "This is why you should have just gotten a CS degree. You really should understand what's going on here." 
You'd have to look at the implementation to get the details of how it worked, I never worked on it. So the only person I have heard say that it might be worth perusing native support, that's dmitry at zend, said that we probably could have a go at it if we went about it differently, the last implementation did bloat everything, did cause consumption issues, did have a performance impact. Now, I've assumed, possibly wrongly, that this is just the nature of storing everything as unicode. He seems to think that there is some way around it, but he's also said he doesn't have the time or will power to work on it, and hasn't given me enough details to conduct any research. He said something in passing about doing something with the zend_string structure. I asserted, possibly wrongly, that I didn't see a way around consumption. I don't want him to work on it, not right now, I think right now it's worth pursuing other solutions. I can easily be wrong, if someone comes up with a patch, I'd love that ... but not at the cost of the performance gained as a result of more than a years work by Zend and others. It benchmarks faster than mb equivalents and has a nicer API, I should think that is obvious, or maybe it's just my perception that says it's nicer.
I met him at Laracon 14. Same thought.
&gt; it doesn't make a big difference at this point in time Except that downloading a single .tar.gz or .zip, despite being large in size, is still more efficient than doing a git clone, especially if the repository has a lot of commits. I mean, there's no resaon not to do what you've outlined - except maybe someone wants to run the tests from a .tar.gz, I don't know - but the impact is nowhere near significant unless you're on some retarded hosting setup where you pay per megabyte used or something.
It doesn't make a big difference in the context that I was referring to. &gt; except maybe someone wants to run the tests from a .tar.gz If you want to run the tests, you most likely clone the package and test it as is. When you install a package, in 99% of the cases you will be just a user of that package, so the development stuff related to that package is not needed. And because those files are not needed for the user of that package, you as a package maintainer should not force your users to install those files anyway.
Wish more people would put this much time into their docs. 
PHP is dynamically typed so unless you are absolutely certain that you need to strictly evaluate your conditions than == and != will be sufficient for most cases. In general, much of your input and output will be strings that may contain numerical data and so strictly checking against integers and floats will fail even if the string contains data that would fit either of these types. However, this dynamic nature also presents a significant number of "gotchas" particularly when it comes to casting between different types upon evaluation. For example, `array() == true` will evaluate to false while `array("") == true` will evaluate to true. If you wish to retain strict evaluation you can utilize casting to convert your input variables to the proper type before evaluation: intval("0") === 0 or (int)"0" === 0 However, keep in mind that these casts are not lossless and will convert types that are clearly not of the proper type to their requested types which can ultimately defeat the purpose of strict evaluation (which is to ensure type safety!) Read this section thoroughly: http://php.net/manual/en/language.types.type-juggling.php
*Most likely* you will clone the package, yes, but I bet there are some weirdos out there that can't or won't use git - just like there are weirdos worried about how much disk space composer packages take or how "clean" your vendor directory is. Question is, which weirdo do you appeal to?
To simplify this answer: "===" means equal value AND equal type and "==" ignores type. So you COULD use `$flag === "0"` in your code and it should return as expected. 
Really if it's that important to you, you should probably be running your own build/deploy and not rely on composer. This isn't to say that you couldn't use composer to bring in your dependencies, but if you were to run them through gradle/ant/maven/make/whatever to strip out the stuff you don't want and customize anything else you need done it would be considered a good production best practice.
There are many cases where you still want to use === and !==. For example: 1. Telling the difference between false and null. 2. Comparing object instances When comparing objects, === is known as the identity operator and is more performant than loose equality (==) which compares properties and values. The identity operator checks if they are actually the same instance of an object, just like in Javascript. That being said, the loose equality is often a quicker, easier way for reliable comparison of numeric values that may be string types. My personal opinion on best practices there, is you still want to be explicit about what types are in use, so you should always know that it's safe to use ===, and know what type to compare it to. Hopefully this helps.
=== is more performant and also communicates intent to the developer. In general, if you know your input is going to be a specific type (or require it to be) then prefer ===. Otherwise you have to decide which is more important. == communicates certain things quickly and succinctly, but of course the automatic conversions can sometimes be problematic. You can also cast to the proper type yourself and then use ===, this also communicates intent to whomever comes after you.
...
https://getcomposer.org/doc/04-schema.md#archive There you can configure your paths that should be ignored by packagist/satis for creating your distribution archive. Just use "archive": { "exclude": [] } in your composer.json (as a package maintainer, obv.)
From what I know that setting is used just for `composer archive`
You are definitely not wrong for wanting to use `===`. If variable types are ambiguous in your program, that is probably indicative of an underlying problem with code quality. Refuse temptation to guess. (Also, `gripejones` gives a good answer to how to solve this: `$flag === '0'`).
&gt; For example: 1. Telling the difference between false and null Not just NULL, but any falsey value that isnt (bool) FALSE For example, strpos returns FALSE when substring isnt found, but potentially returns 0 when it is. So the only way to tell is to use !== FALSE
Few months back, I had compiled a list of good codebases to learn from. Check em' out: https://github.com/chiraggude/awesome-laravel#codebases-for-reference
One thing though: putting a constructor in interfaces is a bad call, kinda defies the flexibility of an interface. I think that's what you meant in your interface example above: public function setUserManager( UserManager $userManager )
Interesting - I didn't think you could do that. I suppose they still can't have a constructor, but that's such a technical implementation detail. Then I have the same question that I answered - why would you choose an abstract class over a trait?
Will that work with any PECL extension?
&gt; why would you choose an abstract class over a trait? I think that's apples and oranges. A trait is not a replacement for an abstract class. You can only abstract so much but you can combine many traits inside one class. You use abstract classes to build common/shared class functionality and you use traits to build classes (abstract or not). Trait is nothing more but a remedy to copy/paste and duplicated code problems and should be treated like that. 
If you say so, sport.
Haha, okay. I'm not the one struggling here with basic concepts. I'm currently a professional java Dev moving towards a devops role in a rapidly growing company managing over 300tb of customer data. Also self taught, also went through the struggles of going from procedural code to oop. I don't know what I'm talking about at all though.
The SQL Server connection will likely be your biggest hurdle - hopefully you already know how to deal with Bootstrap. The docs are pretty good - so I can't see there being too much of a problem there. Hint 1: Use Windows for your web-server environment. I have gotten SQL Server (MSSQL) extensions to work in Linux - but it's just so much easier in Windows. Hint 2: [http://www.microsoft.com/en-us/download/details.aspx?id=20098](http://www.microsoft.com/en-us/download/details.aspx?id=20098) Hint 3: Whichever DBAL you choose for this you'll likely be the only contributor to the MSSQL driver as this isn't a popular mix. Hint 4: If you are using Bootstrap for the charts/graphs - I would reconsider and look at using a library that does this specifically like [HighCharts](http://www.highcharts.com/) (my personal favorite). Edit: Typos - and more hints.
Yup! You can also discover custom channels and install packages through that. See: https://github.com/opscode-cookbooks/php php_pear_channel "pear.horde.org" do action :discover end But you can also do the same thing in Puppet (example42/php): php::pear::module { 'PHPUnit': repository =&gt; 'pear.phpunit.de', use_package =&gt; 'no', } It really just depends what you're looking for. Puppet, Chef, Ansible, etc. are all close enough that choosing between them really depends on the specifics of your project and stack (for example, if you use Ruby you might use Chef, Python use Ansible, etc.) although there are other ideological reasons why you might choose between them. There's countless blog posts comparing all of them with their strengths and weaknesses. Check out https://puphpet.com/ for a pre-built Vagrant box for PHP using Puppet. You can then modify it from there.
Everyone else covered most of the reasons between using them, but another is that a lot of functions will return false or 0 which mean completely different things. First example that comes to mind is `strpos` which returns false if the needle isn't in the haystack, or 0 if it's in the first position. Using a strict check ensures you don't confuse the types since `==` will return true even if a match isn't found.
This right here, I prefer to cast and be strict than to be loose.
How far have you got and what issues are you running into? Have you got the data from the database? Is the data in row arrays or objects? Do you already have a chart bootstrap extension or is that the level where you need help (bootstrap doesn't have a native graph/chart library)? http://www.chartjs.org/ https://developers.google.com/chart/
&gt; is it sound advice to use these over php packages where they solve my problem? Depends. For most things, you should use userland packages ([Packagist](https://packagist.org/) being the primary source). However, there are few cases where an extension really makes sense. Mostly things that are not possible/feasible in userland ([Gearman](http://pecl.php.net/package/gearman) and [Protocol Buffers](http://pecl.php.net/package/protocolbuffers) are great examples).
Well I get your point and I agree there are cases when it would be useful. But I don't think manual configuration file is the solution. People are lazy and forget things. You would end up pull requesting this config to any non "mainstream" packages. Besides when it would be done, there is this thought that may occur to you: "Hey I don't need this part of package and it adds additional 10MB of unused source code! When there is 10 packages like this it is 100MB! How do I get rid of this." Instead of "ignore" I would rather see a way to tag things like: "docs", "tests", "functionality a", "functionality b". And you could choose which parts of package you want. But it would be hard to handle which "functionality" depends on which. And probably if you would need to do something like this, the package is doing more than it should. And it would be better to make more packages of it. Well, after this post at least you will not be the weirdo here.
"==" equal to "===" exactly equal to equal-ish is a strange word :D
For example: 3. Comparing strings that may be numeric. When you have strings that may happen to be purely numeric (user input, hashes/checksums, etc.), `==` tries really hard to compare them as numbers. See http://3v4l.org/ulqj3 for a few examples, I'm very amused by the last one.
&gt; I guess the guidelines from JSLint made me think that I should do similar thing on PHP. You actually probably should. And for the same reasons. Because == and != can lead to unexpected behavior. And PHP is even worse than JavaScript in this regard. For example: "foo" == 0; // true in PHP
I can see your point, but ( *at least in theory* ) each vendor's packages will follow a standard layout, which means that you could write the .gitattributes file once and then copy it when you create a new package. If you look around on packagist, even packages from different vendors have similar layouts: lib/ or src/, composer.(json|lock), docs/, etc, which could make things simple even for the lazy ones.
That's sexist! ( a very inside joke )
[Sweet Jesus](https://github.com/igorw/yolo/blob/master/examples/hello.php). 
I've recently seen this snippet: var_dump(md5('aabg7XSs') == md5('aabC9RqS')); // TRUE var_dump(md5('aabg7XSs') === md5('aabC9RqS')); // FALSE var_dump(sha1('aaO8zKZF') == sha1('aa3OFF9m')); // TRUE var_dump(sha1('aaO8zKZF') === sha1('aa3OFF9m')); // FALSE (source: https://twitter.com/spazef0rze/status/522882677452832768)
&gt; Later edit: It looks like when someone tries to push a good practice its a weirdo and (s)he gets advised to build is/her own build system. If the same post was made by @philsturgeon, @ircmaxell or any other known community member, this would get a total different feedback. That's probably true. Generally speaking, ideas from prominent and well respected contributors to a community are more well received than others. &gt; I don't know what is more weirdo: When a John Doe tries to come with a solution to a problem and he gets bashed, or when the community has ears only for the known community members. The problem you're facing is that most people (myself included) don't give a hoot how clean the vendor directory is. This is like obsessing over the contents of your system32 directory in Windows. All that being said, assuming your solution works, it seems like a good one. You should open an issue on composer on github.
&gt; The problem you're facing is that most people (myself included) don't give a hoot how clean the vendor directory is. And that is the proper and mature way to say that. Not saying that I'm a weirdo or that I should make my own build system. &gt; All that being said, assuming your solution works, it seems like a good one. You should open an issue on composer on github. I don't need to. The solution presented by me works *right out of the box* with Github and Bitbucket ( *composer is missing support for this just for gitlab at the moment* ). Just drop a ".gitattributes" file in your git root, like the one from my example, commit it and you are ready to go. To test, just run "composer (install|update) --prefer-dist" 
Being strict isn't a bad thing.
Nice, good work!
I agree! Unfortunately, a solution would either involve a core change to the way git works (introducing some sort of clone command that also takes into consideration `.gitattributes`), or a lot of extra logic performed by Composer, which would defeat the purpose of this optimization in the first place. If someone comes up with it, though, I'm all over it.
Absolutely prefer `===` over `==` until PHP has safe/sane implicit type conversion rules (if it doesn't happen in PHP 7, you can probably forget it for the forseeable future).
Thanks for the feedback. I've written my fair share of PHPUnit and Behat tests :) These are great tools with a focus on improving code quality, and they have definitely saved our bacon time and time again. We personally find the "describe-it" syntax more enjoyable to write, and we think a reporter that spits something like [this](https://www.dropbox.com/s/ywgz6pzhv3gfh70/Screenshot%202014-10-22%2010.49.13.png?dl=0) out to be more readable for both programmers and stake holders alike. The whole purpose of the [event](https://github.com/peridot-php/peridot-yo-plugin) and [scope](https://github.com/peridot-php/peridot-scope-example) system is to make it easy for developers to extend what grammar they use and what functionality is available to their tests without creating huge hierarchies via extension. Event's even make it possible to [report things the way you want](https://github.com/peridot-php/peridot-code-coverage-reporters/tree/develop). As stated above, this tool is aimed at bringing a style of testing to PHP that is present in other languages we use (Jasmine:JS, Mocha:JS, Ginkgo:Go, RSpec:Ruby, etc). The end goal for any of these tools is better code and better design, definitely not to create division :) 
This solution works right now. Just commit a ".gitattributes" file in your git root directory and you are ready to go. Test it with "composer install --prefer-dist" or "composer update --prefer-dist". 
YES
I hope this will not be interpreted as a plug ( *L.E: it was* ), but you can test it with one of my packages: " *composer install gentle/bitbucket-api dev-develop --prefer-dist* ". You can view the .gitattributes file [here](https://github.com/gentlero/bitbucket-api/blob/develop/.gitattributes)
You're going to have trouble coming up with a random library/package to write. Its just like trying to come up with the next big product that'll get you rich on TV. Think of your daily work life/development life, think about any problems you've encountered... a feature you wish something had... a library you wish existed to help you solve *that* problem you had last week, etc. You'll have a better chance of coming up with something to write. Once you get that idea, start a GitHub repo, get the word out, you'll get people like yourself willing to contribute to the code. If you're looking to *help* code thats already out there, then do something similar: find a package you frequently use, clone it, fix issues or add features. Good luck!
One approach might be to look through PEAR and see if anything there looks both interesting and worth updating. http://pear.php.net http://pear2.php.net
How is this an issue? How are those extra files in anyway causing you a problem?
And its strangeness conveys that you may get unexpected results when writing sloppy tests. For example: if ($thing) { echo "hi"; } will not say hi if $thing has not yet been defined, or is NULL. If your test is for whether or not $thing has a value, then this will also fail if $thing === 0, or $thing === "". It makes me glad that this C behaviour (and it was lifted directly from C) was not included in Java. If I need to test for null, I have to specifically test for null. Likewise with zero.
Thanks. I'm getting a Vagrant box going from puphpet. I'm trying to read the Puppet .pp files and I just hate it. I'm not sure that it would be better on any other system.
&gt; It looks like when someone tries to push a good practice its a weirdo and (s)he gets advised to build is/her own build system. I like this practice. It's definitely worth doing. It's such a small addition with the potential for a huge impact.
The likelihood of finding somebody who cannot use Git but wants to run unit-tests on a ZIP file is incredibly slim, and certainly not a demographic that needs to be catered to. 
"Coercably equal"
Well said. If this was some big complicated procedure I'd say (as many others have done here): "meh, who cares, I got space." But its not. It's trivial to implement and it saves everyone time and effort. It's reducing the download times for composer packages, which we certainly need. I see no reason not to do this, and I'lll make sure The League recommends it for its projects. :)
So then you have 1000 developers stripping different things during the build process, creating issues because things don't work, having the package maintainer look into those...etc. -or- The package maintainer could provide a .gitattributes &amp; those same 1000 developers get a known-working, clean distribution.
Should you forget them? Absolutely not. You should learn where they are appropriate. A really comment mistake I see a lot in code is checking for part of a string in a variable: if (strpos("foo", $bar) != false) ... The problem with this code is that it will run the condition for "afoo", "ofoofoo" but it won't for "foo". The reason being is that if the position of the string is the start then the function will return 0 which when evaluated by != returns false. So in this instance you have to use !== false. My advice would be whenever possible in code used by other people add a docblock to explain what inputs you expect and what outputs you'll be returning, that way a brief glance will inform people what they should be sending to your function. I had a great experience of this today where someone had added a line of code if ($foo == "string") where $foo by default is a boolean of true, so their one specific thing ran for everything!
Well, that's terrifying. 
/u/nikic already did this during the RFC process: https://gist.github.com/nikic/6390366
Yes, but he did it in serious way. I did it in a less serious way =)
I'd love to see a curated version of packagist
True, there is some standard layout and in most cases this `template` .gitattributes would suffice. But if you really need to shrink the size to absolute minimum you would also need to update source code (delete comments and unnecessary white space, shorter names, etc.) That is work for another tool. And for text files, code files especially compression works wonders. edit: I mean for fast deployment (e.g. over FTP) not for downloading source to code with.
That's a very good point. I usually use `==`, but then again, I know what variables I'm dealing with. If you don't know, then something's seriously wrong with the program in the first place.
Yeah, I'd like to be able to overwrite whether or not certain directories are ignored or not.
Totally agree, [been doing that myself](https://github.com/mnapoli/PHP-DI/blob/master/.gitattributes) for a long time!
Thank you for taking my feedback positively. I'm a bitter person and it takes me awhile to accept new things. That reporter is definitely pretty.
To be fair, you should never do either of those things for most(1) hash comparisons: you need to use a timing-safe hash comparison function. In PHP5.5+ just use http://php.net/manual/en/book.password.php or http://php.net/manual/en/function.hash-equals.php (5.6+, more general-purpose) (1) If you're just checking uploaded file hashes or something similar, `===` is probably fine.
PHP is loosely typed. Checking for type is always a good thing.
So its ok the port stuff from other languages if you belong to a group of people who are loud in the community, but not if you are a nobody. Seriously, people, release as much as you like, rewrite stuff, reinvent! We are not on the pinnacle of software. You can always make things better. The PHP community feels very politic these days, and it needs to stop. If theres 30 routers so what? Heck, PHP is a language implemented in C, and its not the only one, so couldnt you call that reinventing the wheel? [banksy] If you repeat a lie often enough, it becomes the truth. [/banksy]
The would add a huge layer of complexity to the system. Right now, the Git repo is generating the archives and hosting them on GitHub or whatever. Composer is downloading those builds and extracting them when it installs the dependency. Your feature would force Composer to download the original archive, process the contents (ignoring the exclude directories) then make a new archive, then have THAT one be downloaded. Or, if you had it remove the excluded directories after downloading the package, then we are still downloading larger ZIPs than we need to. No need for Composer to do this. Git does it perfectly already. :)
&gt; So its ok the port stuff from other languages if you belong to a group of people who are loud in the community, but not if you are a nobody. Where did that come from? 
I have a very simple rule for this. I use `===` when I can, and `==` when I explicitly want to opt-in to the loose behavior.
Not running out of inodes in a vagrant box could be prolonged by this. 
Agreed - but probably worth expanding on that in your article.
When using satis with the package file mirroring, I believe it listens to an exclude-dirs in your composer.json.
== means "equivalent to" === means "identical to" or "the same as" It probably isn't a good idea to always use one or the other. You should use which one makes the most sense. In most cases, === will make the most sense, but not always. For instance, sometimes you will want 0 and false to be treated the same, like when with the results of a web api. When your variables are coming from HTTP io, you'll probably need equivalency. Consider index.php?article=7&amp;fullpage=0. Is article an integer or a string? Is fullpage a boolean or an int? If you're checking for 7 you'd want == 7. The fact that PHP was built to be used for web sites (http) -- I assume -- is the reason why PHP is loosely typed. 
&gt; .gitattributes file This is an unworkable solution because **not everyone uses git to publish their composer packages**. The git-centric (github-centric?) worldview is perilous because you're in danger of completely excluding everyone else. e: Apparently everyone here is perfectly fine telling people that don't use git to go get fucked. That's fine. We'll create our own dependency manager, with blackjack, and hookers...
[Wordpress](http://developer.wordpress.com/docs/api/) just rolled out a REST API in v4. It's pretty darn slick.
Vagrant isn't production though.
I took that entirely from the example42 README. Unfortunately I know Chef more than Puppet so I wouldn't be able to help out.
giggity
Handy. :)
Your blog still isn't accepting comments, so although I'd prefer to communicate directly, I'll post this here: &gt; This is like claiming PSR-0 and PSR-4 were for composer, that PSR-3 simply standardized monolog, PSR-3 was absolutely about standardizing Monolog. That's fine though as it's just couple of simple interfaces that could be used in any library or application, that could allow anyone to make their own custom logging library be used by other applications/libraries. PSR-0 was absolutely about standardizing the already existing standard autoloader from Horde/Pear (Edit - sorry not Composer, as I previously stated, but it was to standardise an existing practice). PSR-4 was completely pointless - the only thing it allows is to have a few less directories, which has been made redundant by Github Those two autoloaders are both missed opportunities - they dictated the implementation not the interface. I would love to be able to define an autoloader in a library that generates code on the fly and have that library installable by other people through Composer. But no, because the implementation is hard-coded to "your classes must already exist at this location" that's not possible. I also like [this critique](https://r.je/php-psr-0-pretty-shortsighted-really.html) of the PSR-0/PSR-4 autoloaders. PSR-6 currently defines a huge implementation rather than simple interfaces; this is not good. Of course, it just so happens that you happen to be person pushing the PSR-6 proposal most strongly; and you're _also_ the author of [the library](https://github.com/tedious/Stash) that is likely to become the standard implemenation if PSR-6 is adopted. You just don't seem to understand the difference between defining an interface and an implementation or why common interfaces are good, forced common implementations are bad. You've also been casting aspersions about other people's motivations whilst not behaving that pleasantly yourself. [Tedivm wrote elsewhere](https://groups.google.com/forum/#!msg/php-fig/fUwLr4TVNok/mjUnQac0Es4J): &gt;Keep in mind that I would support moving it to review as soon as tomorrow, and having it get voted on immediately after. Trying to ram a massive implementation through in a quick vote may succeed - but it will pretty much be the end of PHP-FIG as an organisation that has any relevance, rather than being a great step forward for inter-compatibility between PHP projects. I strongly urge you to step back and try to understand other people who are saying that the proposed PSR-6 is just too damn big, and that PHP-FIG should be defining simple interfaces. This isn't a criticism of the actual implementation of PSR-6 or Stash, it's just that it's not an appropriate level to be standardised. 
I would say the opposite. PHP is loosely typed. Use that to your advantage. Check for type when it matters.
Okay - the Composer autoloader followed the Horde/PEAR convention, and the PSR was about standardising that standard. It was good because it was following a good practice - but it's still a missed opportunity to support anything other than a "class is a file in this location" standard.
Genius.
Store it somewhere that gives you persistence, like a database then cache it somewhere with a long TTL where you get performance (redis, memcached etc). The logic would then roughly be to read the value out of cache if it is there, if not read it out of the db and cache it. Loads of libraries out there that handle this sort of thing.
Right, but wouldn't this just be for wordpress.com, and not for self installed versions of WordPress?
Git is used by composer, this is about composer. What's the issue? 
Composer can also use mercurial and svn. It is not exclusive to git. Not all of us use git. Not all of us publish packages using git, on github.
Fair point, but 90% is on git 
Sorry if I'm missing something, but are there plans to add this cache functionality to the core of PHP? 
Was not aware of this, it's a valuable suggestion. Thanks!
This. Exactly. I don't mind people using `===` in a better-safe-than-sorry fashion. That's actually advisable for coders less versed with the intricacies of PHPs type juggling. On the other hand, context-specific alternation between the two comparator types leaves a somewhat more ambitious impression. Btw: For the strpos check, I meanwhile settled on a slightly more pythonic `is_int(strpos(...))` test. (Which does not check for the position negation, but actual integer-presence. Teensy bit more readable IMO.)
Just because a majority of published packages *currently* use git, that does not make it a good idea to bake features and functionality into composer that are *only* possible if you use git to host the package.
&gt; but it's still a missed opportunity to support anything other than a "class is a file in this location" standard. Why do you want to define it, when it can be registered to autoloader. So people can make use of their own naming conventions. Probably I don't understand you.
The main argument for me is that I don't want to have some library's tests in my auto-completion.
Why are we debating this, it was a suggestion for limiting files in dist packages, if you don't use git ohh well you have extra files in your production package, 90%or more packages won't, the idea is still good regardless if it is specifically for git or not 
No. The PHP-FIG is a group of PHP frameworks and libraries trying to work together to create standards. They want to work together better. This is not going into PHP core.
var_dump( !$news == $goodNews ); /* true */ var_dump( !$news === $goodNews ); /* false */
Where are you having a problem?
Really great !
I have a repo thats still in work but contains some actual code instead of demo stuff. https://github.com/GH-analytics/server. Even features how to make an artisan command use resources and a little orm optimization.
Just in case other people didn't read this far, I'd like to pull out one part: &gt;Fear, Uncertainty and Doubt &gt; &gt; Myth: The standard doesn’t follow OOP guidelines or take advantage of composite classes. &gt; &gt; ... &gt; &gt;The driver model, while great as a direct interface to a caching backend, fails at some of the basic principles of object orientated design. The driver is responsible for all things- connecting with the service, setting and retrieving individuals, item invalidation, clearing or flushing the caching pool. The driver is responsible for the caching system, the items returned from it, and every idea that the caching library developers have to improve performance. By taking advantage of the Single Responsibility Principle and creating a class for the caching system as a whole and another for the individual entries in it we take advantage of some real solid API design. &gt; &gt; Could this be split up more? Probably, but when asked the group decided that their minimum standards should all be included in the standard. The reason for this is pretty simple- if they’re minimal standards that have to be supported then adding interface checks to make sure those specific features are present (even though they’re already required so we know they are) would be unnecessary boilerplate. That being said any pull requests to improve that would be looked at seriously. I've read this six times - I have no idea what this is meant to mean, except that i) the author doesn't accept the criticism that the proposal is too massive; because of reasons. ii) The author is implying that any people who don't like the caching proposal are spreading FUD rather than having legitimate suggestions about how to share caching classes between projects better.
Love it, will update my packages to support this accordingly. Do you happen to know if this will only affected tagged releases, or will it be done per-commit?
This is a valid point and I don't know why you got so many down votes, but anyway. I'm not familiar with other VCS ( *I briefly used SVN* ), but if you find a corespondent with .gitattributes in your preferred VCS, please share and I will update the post with that information.
No but this is also useful for the developers that run into that issue. 
This will work with any archive you download for your package ( *branch, tag and commit* ) as long as the .gitattributes file is present in that tree. Of course that this will not affect your past tags and commits. The idea is simple: when you download an archive of a package which has a .gitattributes file, you get the stripped version of that package ; if you need all the ( *development* ) stuff from that package, you need to clone it.
Just an FYI, I showed this to Matthias Noback, the author of A Year With Symfony and more recently "Principles of PHP Package Design": https://twitter.com/matthiasnoback/status/525180336989548544 I hope you don't mind. 
Sorry, my bad, poor explanation. My goal is to interface statistics engine already in place with our site and our backend. We have a musical related site, and we send to external applications like GA or other analytics software meta informations on the visits user make on our site. We have already in place pre made analytics such as "Most read artists", "Most read articles" etc. So the data is collected and we can fetch it through the 3rd party apps. What we need is to interface, fetch, store and manipulate those data directly through our app so that we can use it to populate some widgets (like most weekly read articles) and to give the editors a quick glance on what's trending on the site. So my question was to seek advice on how to design those classes. I wanted to design so that the system that interface with all those potential 3rd party app could be as much as agnostic as possible and flexible at the same time. Don't know if it's clearer now.
Amen. This is the most sane approach based on my experience . One should certainly understand the difference between ==/===, but going down the route of ONLY using === feels incorrect to me. It goes against the nature of PHP being a weakly typed language. That by its own definition introduces some vagueness through automatic type conversion, which if you write reasonably sane code is perfectly fine. However, some developers love extra precision and control (especially when coming from a strongly typed language such as Java). In attempts to re-establish control they go for ===, which in my opinion ends up hurting things in the long run. You're going against the languages's foundation. Using === isn't going to turn a weakly typed language into a strong one. Suddenly you need to start casting everything constantly (adds code clutter) and to enforce a particular type in a language that's predicated on hiding that. In some instances the code could become more brittle. Some developer is going to forget a cast, another developer may accidentally pass a '0' instead 0 and now some early error catching if block with === will get by passed. Garbage data might make it into your database. For stuff like $flag == 0 vs $flag === 0, I use empty( $flag ) which feels clearer (odd bonus which I find strangely satisfying: empty is a language construct and gets highlighted by most IDEs).
Why would it be a bad idea to let the getter decide what to do if you pass a single key or an array? After all, a single key is like passing an array of one.
A plugin by the creators of WordPress, so not a third-party plugin. Thought that was worth mentioning :) also, the plugin is the basis for the core feature, so you can use the plugin now and keep using the API when 4.1 hits. [Official website](http://wp-api.org/)
Thanks for that - however they don't mention the crucial thing, which is custom content types. I'll certainly investigate more, though.
Why should I mind ? I feel *warm and fuzzy* when I see that we can act as a real community, where ( *real* ) feedback ( *good or bad* ) is offered and people are open minded to ideas which can be debated in a mature way. Leaving that aside, thanks for spreading the word !
[/u/philsturgeon](https://www.reddit.com/user/philsturgeon) could offer more information regarding this, but from what I know, PHP League does not force package mainteners to do something in a unified way. They put more accent over quality.
&gt; PSR-3 was absolutely about standardizing Monolog. Yup, that standard took about two weeks to make and its the sole reason I decided to work on the workflow bylaw, to make sure that sort of thing never got rushed through again. &gt; PSR-0 was absolutely about standardizing the Compose autoloader. Um, PSR-0 was alive for a year before Composer was even a twinkle in Jordi and Nils' eye. Get your history straight. &gt; PSR-4 was completely pointless - the only thing it allows is to have a few less directories, which has been made redundant by Github Because the only time people ever navigate folder structures is on Github. &gt; I would love to be able to define an autoloader in a library that generates code on the fly Why the actual fuck would you do that. &gt; But no, because the implementation is hard-coded to "your classes must already exist at this location" that's not possible. An autoloader that focuses on autoloading classes funnily enough expects that you have classes to autoload. &gt; PSR-6 currently defines a huge implementation rather than simple interfaces; this is not good. It is currently two interfaces that have about 6 methods each. Wut? &gt; Trying to ram a massive implementation through in a quick vote may succeed - but it will pretty much be the end of PHP-FIG as an organisation that has any relevance, Ramming a PSR through that has so far taken over 3 years. Right. 3 years is a rush. Ok. I dont know what your problem is but you're basically a mile off with everything you just said. Happy to talk about it, but lets focus on facts instead of fiction.
Devs don't redirect because they just handled a SQL insert, they redirect because they handled a POST request. This SO thread has some info about why you should do this. https://stackoverflow.com/questions/1083357/do-you-always-redirect-after-post-if-yes-how-do-you-manage-it If you want to make sure certain things are handled after certain requests you might want to make them asynchronous. That way the important stuff even happens when a request gets killed halfway through.
While an excellent tool, this is not at all what I am looking for. It isn't a CMS and doesn't have a REST api built in to it.
lies, damned lies, and benchmarks?
Good point!
WordPress does have [custom content types](http://codex.wordpress.org/Post_Types#Custom_Post_Types).
Dude, this is bad and you should feel bad for releasing it. Please make a proper description of the project. What is haks? What is hurr? No way to configure environment? No way to configure error reporting? Current state of the 'project' is just a weird (edit: changed from bad) implementation of Laravel components with no proper goal. What problem are you solving?
&gt; You would end up pull requesting this config to any non "mainstream" packages. I don't understand, why is this a bad thing?
Doesn't Drupal 8 have REST capabilities? Edit: https://www.drupal.org/documentation/modules/rest Also, extending the Laravel point mentioned by zanthraxnl, what about this [October](https://octobercms.com/), but with [this](https://octobercms.com/forum/post/implementing-rest-resource-controller)?
Any information on what this is or how it was calculated? I Googled "technical debt" and read the Wikipedia entry, but that doesn't seem to apply to whatever this graph is representing. 
&gt; Why the actual fuck would you do that. As already said: "It would be awesome if a library could register a class loader that allowed for generating classes dynamically e.g. through Ocramius's Proxy manager where the class implemenation is generated dynamically based on either application config and/or the class name containing information how the class should be generated. e.g. Trying to load an instance of Foo\Cache\Timer\Bar dynamically creates an instance of Foo\Bar that is decorated with both a cache and a timer. Yes, I could register a custom class autoloader to do that for my own application....but there is no standard way for other people to register that autoloader. And in particular there's no way for people to use a library that either needs or provides dynamic class generation."
For some example details, here's [Silex](https://insight.sensiolabs.com/projects/0324fdf2-995c-4365-8e89-96c36910e229/analyses/82). The site seems to be under heavy load at the moment, so here's a [screenshot](http://i.imgur.com/SXBwmvP.png) Edit: here's [WordPress](https://insight.sensiolabs.com/projects/483d638d-cd53-4407-b0be-bb35bb6fadd8/analyses/16)
The metrics that feed into this can be found @ https://insight.sensiolabs.com/what-we-analyse Obviously the time to fix is going to be pretty damn fuzzy - but the fuzziness should at least be consistent between projects. It's mostly useful for relative comparison.
Somewhat of a lesser known CMS but [SilverStripe](http://www.silverstripe.org/) has a built in API that is extremely flexible with custom content (DataObject) types. However I do warn you, I currently work with SilverStripe and have for the past 1.5 years and I always run into problems and I find the documentation to be a little....lacking....at times. Apart from that though it's a fantastic, full featured product.
ELI5 Technical Dept?
Is it possible to use wildcards? Like: */Tests export-ignore Can't find it in the docs.
wtf is this..
You take short cuts to speed up development, saying we'll come back and refactor that when we have time. The amount of time to refactor the code would be considered technical debt, which is being put off until a later date. Left unchecked the amount of technical debt will continue to add up to the point where it can actually collapse in on itself creating a black-hole that will suck the life out of you and destroy your soul. Moral of the story: just do it right the first time
It is not bad bad think per say, collaboration is important. I just tried to point out that to most people even few hundred MB of tests is not important and probably he will have to do it one way or another himself.
Hmm dat Wordpress....
What I'm more concerned with is what is considered relevant. If they can't get the relevancy right, why would the technical debt even be close?
I can't comment on your project, but I like your github avatar
Question about server settings - if you have /var/www directory owned by www-data.www-data, do you deploy app as root user and make chown? I don't want to use root user for deploying. How do you solve that? Is there a possibility to use sudo? 
Most of the changes in the example you gave are you changing stuff from snake case to camel case. I'm all for using the PSR but I wouldn't assume I can go through somebody else's project and change it to that without first checking it was OK with the author. It's you that wasted your time, not him.
If your intention is to exclude multiple directories with the same name, but at different levels ( *ex: ./Tests ; ./app/Tests ; ./api/Tests* ), then you could use: **/Tests export-ignore Not tested, but it should work.
Ok I will rephrase, most people I know. Actually I support this. I only wanted to point out it seems quite prone to fail and isn't completely universal, what if I want tests but not docs? (I already have a package in mind where I will pull request this, I wan this to success) English isn't my mother tongue, I probably wrote my initial post more negative than I intended to.
Not really. Sometimes you need to release anything that resembles release when you look from distance and if you try to do stuff right, somebody can get most of your potential customers with half-assed startup while having huge technical debt.
Why does everything always have to solve a problem? I take this as an attempt and rolling a custom application layer using off the shelf components. I haven't looked into the code super closely buy I believe the spirit of what's being explored here is valid. You don't always have to accept the default application template as the gold standard. It's a very worthwhile exercise, for self learning and in some cases for real production scenarios to take familiar utilities (e.g. - Laravel components) and assemble them in some other fashion. Personally, I have my own tweaked forks of laravel/laravel that I start from with every Laravel project.
I'm generally not fussed about these kinds of things, but I'll give an upvote to the first person with some crazy carbon footprint saving estimations for a package that has done this. For example, I think mockery would save around 50kb doing this, and it gets installed around 3000 times a day according to packagist. 
There is nothing wrong with building your own stuff, but when you release it to the public it should have a clear goal. Programming is about solving problems, so the goal should be to solve a problem or provide an alternative implementation of a solution. The least OP can do is let the community know what the intentions are with this project, only then can we provide constructive critisism.
I agree with you. Honestly I have no problems embracing the proposed solution when authoring packages. It just makes sense. In practice though, aside from the potential for optimizing speed / download size of packages (which is great), I really still don't give a crap what my vendor directory looks like. Having any number of tests and whatnot in vendor has yet to cause an issue for me.
I like poking fun at wordpress as much as everybody else, but I fear this isn't completely unbiased. A project that's not running on Symfony, and not using Symfony code standards is _obviously_ going to have more perceived issues than a project that _does_ run on symfony. Of course, there _are_ major issues with WP, but this chart should be taken with a grain of salt. 
Yes really. That's the EIL5 version. The EIL15 version would be, that of course there are exceptions to this. Times where the technical debt is acceptable to take on in order to get something done. But even in those cases, you can still do things in a way to try and minimize the amount of technical debt you're incurring. 
Only if your developers are inexperienced. Professionally written code on a fresh project can be done quickly without taking shortcuts. Then once your MVP is out in the market, without the tech debt slowing down the project you can iterate much faster. Meanwhile unchecked tech debt will continue to pile up, slow down development and prevent the rapid iteration necessary to foster innovation. Fast forward a few more years and the tech debt is so bad that the project is at a complete standstill. In my experience, I have most often seen this happen when inexperienced developers start a project and don't realize the need for project structure, separation of concerns, etc or feel that "It's faster" to roll their own framework and continually waste time reinventing the wheel.
Built in, brother. I've already done it myself. You could use WP for the backend and slap a fancy JS front-end and have yourself a pretty slick whatever you're making.
I dont really care if there are extra files in there, but the cost of continually transferring bytes does mean something to me
think i solved it. Was in js file. 
s/dept/debt It's a really complex subject - this article is pretty good but impossible to summarise neatly: http://www.infoq.com/articles/managing-technical-debt The short version is when code sucks, that can either be a good or a bad thing. And when code is written very well, that can either be a good or a bad thing. ¯\\_(ツ)_/¯
**TL/DR:** This post hand-waves around the criticisms, invents problems that don't exist with the criticisms, and then uses them to dismiss the criticisms and show why the current proposal is fine. Alright, let's go through this: &gt; This is a burden on several major groups- * *Frameworks have to build adaptors for just about every library that uses a cache.* Which is why FIG should make a standard. Good. * *Library/Component developers are stuck reinventing the wheel in order to give their library caching capabilities.* This is the first point over again, since frameworks are just collections of libraries or components. But OK. * *App developers (the consumers of Frameworks and Libraries) need to configure and manage multiple systems or just forgo caching in some components altogether.* To be fair, that's never been the concern of FIG. As they stated *many* times, standards that they produce target framework authors *only*. And everyone else is "optional", but not a target So unless there's a shift in the FIG's mission, that's not really a fair one. Although I do agree that it's important to do, as stated by FIG it's outside of scope. * Operations engineers have very little insight or ability to configure and tune the resulting conglomeration of caching systems. Again, way outside the scope. But not just of FIG, outside the scope of *any* standard. The job of a standard is to define the API, the interaction. Not the implementation. It's up to the implementation to provide those features to the ops engineers, not a standard API. &gt; The simplest method of caching is what we’ve been referring to as the Driver Model. So you try to argue against the points I raised in my blog posts ([#1](http://blog.ircmaxell.com/2014/10/an-open-letter-to-php-fig.html) and [#2](http://blog.ircmaxell.com/2014/10/a-followup-to-open-letter-to-php-fig.html)) by completely ignoring them, and adding 3 new methods to the interface (and completely changing the semantics of it). So the rest of the post I'm assuming builds on a misdirection from the start. Great. &gt; Sometimes developers want to store negative values such as false, null or 0. Ok, let's look at this in detail. The API I proposed in my blog posts has `0` and `false` and `[]` defined to be perfectly acceptable values. `null` is the only one that's not. So you're already showing that you don't understand what I said. Or you do, but are purposely ignoring it. &gt; This is perfectly acceptable behavior and a lot more common than people think. For `false` and `0`, completely fair. But `null`... Why would you want to cache null? Sure, there are some edge cases where someone *may* want to, but is it that big of a deal to say "null is off limits"? So far, I've seen you (and others) say "null is important", but I've yet to see a single example where it is. Can you provide one? &gt; However, it does make for sloppy API design as developers will be expecting different return values in different places to represent the same thing. What? What is that supposed to mean? What different return values represent the same thing? The interface I proposed defines `null` to mean a miss. End of story. If *your* use case means `false` is the same as a miss, then that's up to the implementation of the use-case. The driver can go on treating misses as `null` and be done. &gt; A solution to the “null” problem is to stop relying on the return value itself for whether there was a hit or miss on the cache request. I took the liberty of adding it into this example already as the “exists” function. Again, this `null` problem doesn't exist. So there's no reason for the `exists` method to exist. Everything that builds on that is building on a disputed assumption. And to say there's a race condition again hinges on the assumption that `null` must be a valid cache value, which was one of the contentions that I raised in my posts, which has gone completely unanswered except for saying *"This is perfectly acceptable behavior and a lot more common than people think."* **about a more general problem (including `0` and `false`)** &gt; The Driver Model supports it straight out of the box by taking in an array of items to be set as a parameter. Again, this is not the API that I designed. And I think that's a **bad** way to design an API. The API that I proposed only takes string keys. Why? Because fetching items in a batch is a **different problem**. And a different problem **requires a different solution**. Trying to shoe-horn them into the same interface (or set of interfaces) is the problem. So the entire next few sections are based on a fundamental misunderstanding of an API... &gt; The above issues have a number of solutions but we’ve ultimately looked to solve it in ways that are provable, simple, and flexible enough to fit the needs of future systems. Yes, the solutions that you described before hand have issues. But those aren't the solutions that others (like myself) have proposed. They are ones that you've proposed. And crafted (you admit to it in your post, by adding `exists` methods) to have those issues. So that's a bit disingenuous to say. &gt; Any value of any type can be stored and retrieved, there will be no ambiguous code Again, there's no ambiguous code in my interfaces either. Excluding null from the valid types that can be stored doesn't introduce ambiguity. It simply simplifies the interaction significantly. But we'll get back to that. &gt; To do this we toss our saveItems function out the window and replace it with saveItemDeferred. So rather than building a new interface which can batch up set calls, you simply make the pool stateful... So who knows what you're committing... Great... &gt; This takes more work away from the calling libraries and gives the frameworks and higher level applications more control over how caching should function. Actually, no, it doesn't. It takes control away from the higher level applications. Because each low level library (calling library as you put it) has the ability to multi-set and commit, the high level can't decide how to batch things appropriately. Instead, if you really wanted to support batch, you could create an interface for that: interface Batch { public function set($item, $value); public function commit(); } Now, higher level APIs can inject localized batch instances which ignore commit calls, to then batch at a higher level. But because you conflated the two APIs together, that becomes *far* more difficult... &gt; The driver model approaches each action as a stand alone action- in fact, if it wasn’t for configuration needs you could make the driver model a set of static functions or even just procedural code without noticing any real difference. Not procedural, functional. And that is correct. Cache is a service, not domain logic. And [Services Should Be Stateless](http://en.wikipedia.org/wiki/Service_statelessness_principle). So you just gave another argument against your own proposal. &gt; Added item state has powerful implications. * *It makes solving the null/exists problem ridiculously simple, as has already been shown.* So it solves a non-problem. Great. * *With the ability to store item state, caching libraries can also attack other problems that are invisible to the outside developer.* And make it impossible (or incredibly hard) for the outside developer to get visibility to them if they want to. Great. &gt; With the Pool/Item model the developer can put something to clear the lock right in the Item’s destructor so it gets cleared right when the item is out of scope. But where was the lock checked out? Is it a magic lock? &gt; To solve the locking issue the driver would have to maintain a record of all of it’s locks and clear them on destructions, or on a scheduled basis for long running processes, or else it’s no better than relying on the TTL and you get the performance hit. So you invent a new responsibility, and blast a simple interface for not implementing it. Interesting... It's really funny, because later on you talk about the Single Responsibility Principle. Good interfaces implement one responsibility, as you even say. But you're tacking on responsibility after responsibility onto your interface(s) and then saying how that's a good thing... Huh? &gt; To boil this one down, there are people out there who feel that splitting the caching library from one class to two we are increasing the complexity of the standard to a level that is unacceptable. And that's the fundamental problem with your argument. Nobody is talking about **classes**. We are talking about *interfaces*. One interface doesn't mean your implementation needs one class. Your implementation can have a hundred classes. It just means that you present *one* interface to do *one* thing to the end user. &gt; The driver is responsible for all things- connecting with the service, setting and retrieving individuals, item invalidation, clearing or flushing the caching pool. Again, the *interface* is responsible for *one* thing, persisting items. Get/set/delete. That's it. Nothing else. No *connecting with the service* (I didn't see a `connect()` method). No *item invalidation*. No *flushing the cache pool*. Those things are up to an implementation to implement. And that can (and should) be done with multiple classes. So while the implementation may be more complicated with other responsibilities, the overall interface that it presents to *consuming* code is simple. Which is the point. &gt; Probably, but when asked the group decided that their minimum standards should all be included in the standard. Which precisely was the point my blog posts were making, that's a bad idea. But so far, that hasn't been argued, so...? 
&gt; You can not spend any time at all building caching libraries or services without running into this, especially if you’ve ever worked on enterprise level software. Nobody has said others haven't done this. What we've said is that it's un-necessary complication. You cite several Java examples. Great, let me cite an example of Java over-complication and why that's not a good idea: [java.io](http://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html). 12 interfaces. Some with 1-2 methods, but some with 20+. But then look at Go. Their [I/O package](http://golang.org/pkg/io/) is multiple simple interfaces (most only have a single method). You can implement them all on one class, but you almost never do that. Instead, you typically use one of the *small* interfaces. Heck, compare the Java write interfaces: public interface DataOutput { void write(int b) throws IOException; void write(byte b[]) throws IOException; void write(byte b[], int off, int len) throws IOException; void writeBoolean(boolean v) throws IOException; void writeByte(int v) throws IOException; void writeShort(int v) throws IOException; void writeChar(int v) throws IOException; void writeInt(int v) throws IOException; void writeLong(long v) throws IOException; void writeFloat(float v) throws IOException; void writeDouble(double v) throws IOException; void writeBytes(String s) throws IOException; void writeChars(String s) throws IOException; void writeUTF(String s) throws IOException; } To the Go one: type Writer interface { Write(p []byte) (n int, err error) } You can justify a lot of complication by the fact that "java" does it. But that doesn't mean it's a good thing. Go favors Composition to solve problems. Java favors inheritance. Java favors building bigger individual systems that don't need to be composed to solve problems. And a lot of people grow up thinking that's the only way to build robust systems. And it's not. Building smaller and more composable interfaces makes everyone's life easier. Easier on the library author. Easier on the maintainer. Easier on the consuming component author. Easier on the end user. It provides more flexibility without requiring complexity. Which should be a goal of good design. But that's I/O, what about caching? Take a look at [the Revel framework's cache abstraction](http://godoc.org/github.com/revel/revel/cache): The have a single getter interface: type Getter interface { Get(key string, ptrValue interface{}) error } interesting. No item class needed, just an abstract pointer (a reference in PHP). They return an `ErrCacheMiss` error if there was a miss. So you can cache `null`, but without needing an item class... But the entire cache system is slightly more complicated: type Cache interface extends Getter { Set(key string, value interface{}, expires time.Duration) error GetMulti(keys ...string) (Getter, error) Delete(key string) error Add(key string, value interface{}, expires time.Duration) error Replace(key string, value interface{}, expires time.Duration) error Increment(key string, n uint64) (newValue uint64, err error) Decrement(key string, n uint64) (newValue uint64, err error) Flush() error } Which is still simpler than the current PSR proposal. Heck, if you remove `Add`, `Replace`, `Increment` and `Decrement` operations (which neither of our proposals do), then you get: type Cache interface { Get(key string, ptrValue interface{}) error Set(key string, value interface{}, expires time.Duration) error GetMulti(keys ...string) (Getter, error) Delete(key string) error Flush() error } Which simply adds 2 methods to my simple interface (one for multiple gets, and one to clear all cache entries). And this is a driver approach, not even the abstraction that I was presenting. But it does show that others do implement simple APIs...
Learning PHP Design Patterns from o'reilly is a good place to start.
This sounds like it would be difficult to debug with just the information you have currently. You need to get more info, I'd recommend using either: [Wireshark](https://www.wireshark.org/) - Be able to see what the network is actually doing. There is a very small chance that how PHP is getting the information is causing something borky to happen with your network. Wireshark will allow you to see the actual requests being made, and whether it's the problem is happening on the network. [strace](http://linux.die.net/man/1/strace) - Be able to see all the system calls that are being made by PHP, and how long each of them take. Pretty obviously there will be some that will stand out as being absolutely massive. Once you've found what the system call is that's taking the time, you should understand what's happening. 
During the process of learning you don't have to solve any problems other than your own. He released it looking for feedback, telling him he should feel bad and that because his projects outlines don't meet your own personal standards and due to that he doesn't deserve any constructive criticism is a very poor excuse to insult somebody on the internet. I find the OP's readme efficient enough to get a general idea on what the project is and what his intentions were. Plenty of room to provide insightful feedback.
Huh. I guess I thought that was the point of this thread. If the solution exists already, why don't more people do it? Seems like a no-brainer. But all OP got was flack for mentioning it, so I figured it wasn't possible yet.
It's called a [heredoc](http://php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc). I don't think it's specifically bad practice, but I can't remember the last time I used one. Maybe present your use case and see if there is a better alternative?
All of those tools do roughly the same thing. It just depends on what best matches your development style. At my office, we tried Puppet first, and are now using Ansible, which we prefer much more.
While interesting, it's calculated by sensio, author of sf, silex, twig and involved in composer, so of course these projects do better according to their own criteria. Who wouldn't? But for Wordress, phpBB, Prestashop and the like, I bet nobody needed a graph to know they have a lot of technical debt.
By the way, why the quotes? The syntax is: $message = &lt;&lt;&lt;EOF Huge long text here EOF; No quotes around it. What you posted just gets you a string containing the literal characters "&lt;&lt;&lt; EOF ... EOF;". You can also just use a multi-line string: $message = " Huge long text here "; If you need a heredoc, there's also nowdocs which are single-quoted and don't interpolate, like single-quoted strings: $message = &lt;&lt;&lt;'EOF' Huge long text here EOF;
but what they measure has nothing to do with technical debt. It's design tradeoffs, which is not the same thing... Eih...
+1 Also the projects have different scopes. Symfony beeing a framework, it needs to be very well written by definition. Wordpress just need to have a good theme/plugins ecosystem and to be able to create cool and easy-to-use websites, which is the case despite the code. The technical debt in the end don't have the same impact on long term development of both projects. Just my 2 cents ^^ 
What does Symphony have to do with any of that?
Personally I think they look ugly as sin. Just using a standard string is much easier and clearer.
Ohhh the choices, much choice. I thought it needed quotes. Thank you :)
Someone in that thread mentioned that "Technical debt is the sum of all cost", and so they basically added up the cost to fix each of these errors that came up in the analysis. I don't think I agree, but that's what they have used.
The scores are calculated by Sensiolabs' Insight suite. Which is developed by the same company that's behind the development of Symfony. 
Sublime 3 seems to syntax highlight SQL in any string, for me
So it does! Just tried it. I'll be sure to make use of that in future.
Well I guess that's that. 
I think that's an apples to donkeys comparison. Using variadics like this doesn't hide dependencies like a service locator does. It's *much* easier to look at a parent class's constructor to see an explicit list of dependencies than it is to browse all the child class code to find services being located/used.
I doubt it is a bad practice. I can see at-least [Nikic's FastRoute ](https://github.com/nikic/FastRoute/blob/master/src/RouteParser/Std.php#L13-L20) using it. And trust me, if it was anything bad, you would not see it there. It is just probably one of those things that has it's best use cases and not. But that does not mean, its bad. 
We have a difference of opinion then. 
Respect for using Allman style! :D
Ahhhh, I wondered how this was done. I noticed a few packages that don't download the tests but if you download another way there they are. Good to know!!
yeah, I just noticed :) If you are feeling bored, you should buy it (or *find it*). It is very entertaining. 
I've used them for queries when you dont' have a query building abstraction. Also used them to display information for CLI's.
This is a pretty philosophical debate. PHP's anonymous functions are closures in that they allow you to close over parts of the parent scope - you just have to explicitly specify which parts you want and the binding mode you want to use (by-val/by-ref). Additionally `$this` and the class scope are automatically bound, with the ability to opt-out (`static`). PHP chose not to make a distinction (in implementation or documentation) between an anonymous function which closes over variables and one which doesn't. Think of the latter as a closure over an empty symbol table, if you like. Also, I think in your last example you wanted to declare `function add(x)` and the closure in it with `function(y)`, otherwise it doesn't make a lot of sense to me.
Yeah Anthony has some great points. I don't think PSR-6 is huge, but I do think its complex. Great talk between those two kicking off in this comments page. :)
If these generated classes are being put into memory then you don't need to autoload them, and if they're being dumped into files then plain-old PSR-4 will work just fine. I don't get it. :)
I kinda like putting those in separate files and using file_get_contents() to pull them in. But I bet some people will have a problem with that too :)
My favorite bit was `$_obfuscate_DQMRGx0nCUAFODY7BRsPNCYBBx0kATIÿ`.
I like this from the vantage point that some systems (heroku) generate slug maps for projects. The more files, the more space it takes up, and eventually it gets exhausted. So while I might not have immediate need for it, it's an optimization worth having as an option. 'cause you're only gonna need it once before you'll wish the community had thought of it before you! ;)
yeah, if you have a lot of files or trafic, your creating a bunch of unnecessary disk activity
What's truly impressive is that hotscripts.com actually still exists. I'm surprised it hasn't died yet.
Not just highlighting. PhpStorm 8 has a feature where you can right-click it and open the block in a new editor tab. That tab is totally self-contained, has its own language setting and so on. And as soon as you're done editing, the IDE merges your changes back into your PHP file.
Switch to PDO and use prepared statements. Then you don't (generally) have to worry about these sorts of things. 
Well it is "where web development starts".
900+ of WordPress' 1000 violations are "Global variable or function should never be used". In other words, non-object oriented designs are going to have a bad time in this tool. I don't think anyone should start a non-OO PHP project in 2014, but turning WordPress into one at this point would go way beyond paying off technical debt. It's a redesign, or maybe a replacement.
Yup, go for pdo
I'm not sure that I agree with you, the way I think of it is that technical debt is a subset of the design trade-off category where the result of the trade-off is code that is more difficult to understand, debug and/or modify. Having had a quick look through the criteria they are using I'm inclined to agree that many, if not most of them, are serious issues that if observed should be raised during a manual code-review.
&gt; But for example Laravel does this naming without people complaining. People complain about this *all the time* (things like Blade::sharpen from L3 or even the L4 namespace Illuminate).
They could do that in strings, too (Sublime Text does this for SQL). There is no real functional difference between heredoc and a string, except one has an ugly syntax.
Not quite. A heredoc allows you to convey the type with your delimeter.
$time = strtotime('last monday'); This will give you an integer timestamp, but you can convert that to YYYY-mm-dd with the date() function, e.g. $date = date('Y-m-d', $time); If you don't care about times, just use the date format.
This is a great idea for you. It must be explored. No. 
&gt; The popularity is much easier to determine Not really. There are many different metrics to being popular or relevant including downloads, installs, number of plugins/extensions, user ratings, etc. The ones they list there *are* popular so don't see why it matters that some other popular apps are missing.
The classes wouldn't be generated ahead of time - the custom autoloader sees that someone is trying to generate a class that doesn't currently exist, generates it on the fly; with the details of what exactly is built set by the config of the application, and then caches it in a sensible place, where the standard composer autoloader could load it. There are other cool things you could do if you were able to have custom autoloaders: * Module versioning - currently it's not possible to use two versions of the same library in a project. It wouldn't be that hard to write an autoloader where you can set which version of a library is used on a per request basis. * Make a tool to analyze what classes are used by various end points in an application by sampling what classes are loaded for each request. * Security checks - you could make an autoloader that prevents certain classes being loaded if the request hasn't come from 127.0.0.1 or other checks. * Another idea similar to the dynamic proxy creation (, that also might be slightly crazy) - you could integrate a DIC into an autoloader to allow dependency injection to work in a library that wasn't written with dependency injection in mind e.g. Currently this: $foo = new \Foo(); is hard-coded/strongly coupled to always return an instance of \Foo. With a DIC autoloader you could dynamically decide to return a child class of Foo. No dynamic code generation need to take place. That would allow you to take a library that is not easily testable due to the hard-coding of classes, and be able to slip in mock/stub versions of those classes and be able to test it, without having to re-write massive parts of it. Yeah, yeah - I can write these and use them for my own projects, but if anyone wants to use them, the have to do some funky setting up of spl_autoload_register, rather than it's being a something that can be just imported through Composer or package manager. As I said, the PSR-0 was standardising the existing standard which is good.....but by defining the actual implementation rather than an interface it makes it hard for anyone to be able to share their own implementation, which is bad. 
I soft-recommend using heredocs when there is embedded structured text, such as a database query: $query = &lt;&lt;&lt;SQL SELECT id, username, fullname FROM users WHERE id = ?; SQL; If your IDE or editor has goodies, then good. If it doesn't, I still prefer it to the string variant: $query = " SELECT id, username, fullname FROM users WHERE id = ?; "; It's somewhat of a personal taste. Note that it does get clunky when the code around it is indented: class UserMySqlGateway { function getUserNames($id) { $query = &lt;&lt;&lt;SQL SELECT id, username, fullname FROM users WHERE id = ?; SQL; } }
If you know the types of the variables in question you should be using === anyway since it's more likely to create a problem if someone changes the types later on (and your loose equality checking may be fine or may cause submarines errors.)
They are pretty ugly and they break easily whenever someone uses and editor with auto-indenting.
You might want to look into the [PHPBridge](http://phpbridge.org) curriculum for a starting point. It's missing a lot of teaching materials (the VM, the setup for it, etc) but the project itself should be good :)
&gt; Only if your developers are inexperienced. Professionally written code on a fresh project can be done quickly without taking shortcuts. That's the problem, _on a fresh project_. If you're on a project that's been around for years and need to release a feature, but don't have a week to refactor the code then you're shit out of luck.
Well I wouldn't take it to ridiculous levels of renaming actual methods or classes other than the entry point one. )) Thanks for the insight. I honestly thought people liked laravel naming. But my point is that Blade is seen as a srparate templating engine and has been often compared to Twig. While Yii had also a nice engine, but as of yet Ive never seen anyone try using it outside yii
Thank you I'll look into it.
I probably _should_ be using strict comparisons more often. So far, it's been mostly a matter of habit. Best to make small improvements to style and patterns continuously, so I'll probably start doing this before too long. Still, I do find things more legible to do things like this: `if ($foo) {` than do more explicit checks, unless there's the possibility of a legitimate value being false-y.
I like that style as well when I don't care if $foo is null, 0, false, empty etc. I'm more referring to situations like $foo = intval($input); if ($foo == 0) { 
Look at his comment history, he's just an angry troll. Amazing you took the time to write as much as you did in reply.
Thanks for explaining, but I think I am still missing the problem. PSR-0 just says that a class called "Foo\Bar\Baz" must be in the Foo/Bar/Baz.php directory. Thats pretty much the extent of it. I'm not sure how anything that you want to do is limited by that. You are discussing implementation details, which are completely unhindered by PSR-0. Composer happens to build a cache on install, then shove those locations into an array. The Composer autoloader then looks in that array which is "Class Name" =&gt; "File Location" and tries to include that file. It's simple and quick. You could very easily replace Composer autoloading logic with any other autoloader and still be PSR-0 compliant. I think your issue is that the Composer autoloader is being treated as a standard and the Composer autoloader works in one specific way, and you are mistakenly blaming things on PSR-0 and PSR-4. If I am correct, and your issue is with Composer, then you can get around that by bundling your own autoloader, having composer require that file for you and all your code will work as expected. This is not uncommon, and its totally invisible to the user. Or am I still way off?
DBAL is a pretty solid database abstraction layer, nothing fancy with it's name.
Beautiful. This will be handy.
for fucks sake.
 $foobar = &lt;&lt;&lt;SQL ... SQL;
I was hammered and I couldn't sleep. 
Also, technically, PHP's "closures" aren't closures at all as they can only copy the values, not keep the parent scope alive.
How do you have it if you didn't buy it?
I think you pay additional tax.You also don't get holiday pay or a Christmas bonus. Just guessing.
Use PDO, or something that wraps around PDO, or something similar to PDO. Then use prepared statements. Then never worry about having to deal with things like this. If that's not an option, then even MySQLi has prepared statements - if this is a legacy codebase for instance. Ideally, the best option would be to introduce more modern components if possible.
Oh, I guess you mean conveying the type to the IDE? Because PHP doesn't do anything special with different delimiters. I suppose that is potentially useful, but IMO doesn't outweigh the drawback of ugly, non-indented syntax.
Yes, someone outlined here earlier that symfony has reverted such a change in the past.
Wordpress is a huge, in a sense of codebase and community contributed themes and plugins. Such products in general have important issues to address, in terms of bugs, speed and security, and need to maintain backward compatibility to some degree. They cannot address and implement every new cool (often experimental) feature, or pattern. They have their internal structure, and if they'd be listening to every "code ninja" who comes with a brilliant idea how to rewrite the system each year, because, you know, it's trendy, they'd sink long time ago. Wordpress is quite old project, so it was evolving more natural, and some tings are done in a way, it was common back then. This graph is essentially useless - it's basically doing search in source, for i.e.: "global" keyword and then decide, for whatever reason, that for each global it would take 1 day to be fixed. Ok, whatever. Do some more search for "die" and "exit" and again decide a random number. Do search for "TODO" in comments, and again decide. This is just one big nothing. It's unscientific and completely useless. Now, I'm not a fan of Wordpress, I don't think is a brilliant example of well written code, but shaming it because it don't comply with your standards and ideas, above all for reason of self promotion, that's just low and not productive at all. 
The technical debt by definition cannot exceed the time required for a complete rewrite. Hence the amounts calculated by this system are ridiculous and serve only marketing purposes. Also what are these times anyway ? Man-years ? If its just years and doesnt take into account team sizes its even more stupid
Hi! :) What license is Eaglehorn released under? I found the github repo but still don't see a license.txt. (A link to the github repo on the site would be a good idea) Without a license, it is difficult for many people to commit to using it. Cheers! =C=
There isn't a catch. Contract work in the UK both has higher rates and less tax. 
Oh, c'mon...
No. Because if you're going to confuse people with shit like that, then you might as well put the effort into something cool like a Star Wars framework: Force::push(); Force::flow(); Force::crush(); Force::lightning(); Yoda::initializeYouMust(); Yoda::doOrDoNotThereIsNoTry(); Yoda::foreverSleep(); Yoda::die(); Luke::kissSister(); Luke::loseHand(); Luke::getAbusedByDad(); Luke::getKidnappedByYeti(); Luke::seeDeadPeople(); // Luke is a regular bad luck brian... Han::shootFirst(); Han::getWookie(); Han::smuggle(); Han::solo(); // Singleton pattern or something I mean, who the fuck knows what any of that does, but that's the not the point right?
Looks like it's MIT: https://github.com/ajaxtown/eaglehorn/blob/master/index.php
And another...
True. But note that all I eanted was to change the name of the package, not implementation. Consider Plates template engine, or Twig. Would really suck if they were all named Template. Dont you think ?
Thanks Calevans. I will add it soon.
Which is caused by technical debt which is exactly the point he's trying to make.
The answer is no. No lingo. Read this: https://medium.com/@frankdejonge/a-case-against-coding-lingo-8ffae1a4fa4e
I'll see your wordpress and raise you OpenX at 198.6 years: https://insight.sensiolabs.com/projects/2944c093-d750-4a9a-8fdd-e3a22170e10c/analyses/1 
5 hours to fix those, eh? Clearly I should ask for more pay...
Just gave it a span and it works really nice. This is going to help me tremendously making sure everything works correctly on a all supported versions without having to rely on travis for me :D! Some minor points though, but I'll open issues for those.
Oh good, fresh meat! - No sign of namespacing - No sign of dependency management (composer) - Singletons everywhere, no sign of DI - Confuses "model" with "data storage layer" - Needlessly implements another SQL builder - And then includes RedBean right in the repo? WTF? - Data storage layer includes HTML error messages - "Logger" emits HTML, does not actually log anything - Needlessly implements another template system - Almost everything in functions.php is wrong, broken or bad design - `eh_log`: No, logging should be provided by a thing you get from your DI container - `getController`, `getMethod`, `getParameters` contain global state accessed by statics. - `eh`... eh? - HTML helpers belong in your template library, not in a core function library - `encodeString` and `decodeString` are for what, exactly? - `display`: No. Go install xdebug if you want pretty `var_dump`. - `getFilesFromFolder`, `getSubDirectories` aren't actually bad, but you should look up the various recursive directory iterators as alternatives. - `getBrowser`, `arrayToObject`: *Whyyyyy?* - `validate_email` **NO! WRONG! BAD!** If you want simple, use `ext/filter`'s thing for email addresses. If you want *correct*, use [`is_email`](https://github.com/dominicsayers/isemail) - For example, this function will reject email addresses at any of the new *dozens* of gTLDs that are longer than six characters, as well as throw up all over IDN TLDs. - `flipArrayKeys` does what that `array_values` doesn't? - `getRandomString` could be greatly simplified to use `str_split` and `shuffle` - `ifPostExist` should probably look at the request method instead - `get_client_ip` should **never** trust anything other than `REMOTE_ADDR`, especially the forwarded-for stuff, unless expressly configured with a whitelist of known `REMOTE_ADDR`s that are allowed to send forwarded-for headers. Huge-ass security hole there. At least you're using PDO, an existing ORM (kinda), and an existing email lib. Overall grade: **D-** ... not a complete disaster, but pretty bad. Doesn't bring anything new to the table and doesn't provide any obvious benefit over existing systems.
On the one hand, they give higher pay and flexibility with less tax to pay. You get to work on a wide range of projects but are expected to be able to become familiar with them quickly. On the other, you have to be responsible for your own tax assessments, contracts are shorter and you have no guarantee of work, and you are usually expected to be productive much quicker. You'll also typically travel more as well. This adds up to higher expenses.
They know Drupal 8 is only just in beta right? It's not released and likely won't be for another year at least. 
I didn't mean lingo. I meant just giving packages separate names, like for example Symfony2 template engine is Twig
Agreed. The fact the product quality is so poor is entirely coincidental. 
&gt; Moral of the story: just do it right the first time But WordPress' Technical debt is paid off more than hourly through the amount of time it's sheer existence frees up for devs. If we'd been waiting 20 years for WP4.1 no one would give a shit about it, and someone would have built something with 100 years of technical debt. Moral of the story: Do it at whatever speed is appropriate for the product.
Guessed wrong I'm afraid. Not only do you get paid more, typically speaking, you also keep more of what you earn. On average 75-85% because of the way dividends are taxed once you pass the higher taxation rate threshold. Please don't everyone think it's all roses and tulips, though. If it was easy we'd all be doing it. Being a good developer isn't enough. You're expected to be highly professional and very self-managing and proactive. You're also running a business. I mention this because I've know developers far better than me who could never do contract work, so question whether it's for you and don't be tempted solely by the money. This is your living, and it's a healthier way to live if you enjoy what you do. Lastly, don't forget that contracts are typically 3-6 months and expect a month or so in between, so you've got to balance the books well, and you will still have business-related outgoings whilst you're not earning. All the tax and vat are your problem, too. So sure, you might earn twice as much, but if you're working only half the time, with all the extra effort, is it really what you want? It's a great life if you enjoy it, but don't get blinded by the big bucks and make the choice that's right for you. 
seriously? Is this your first day on the internet :)
It does. Also for regular expressions that are top/tailed with "/". 
Oh, fantastic. I guess they only keep the 5 latest. Just look at https://insight.sensiolabs.com/projects/e5468286-d0c9-4b4e-b1f9-f1feb9344d4c/analyses/7 and https://insight.sensiolabs.com/projects/e5468286-d0c9-4b4e-b1f9-f1feb9344d4c/analyses/8 For analysis #8 it's telling me 3 hours to change an interface by adding Interface to the end? I'm not sure how reliable any of the reports are going to be.
Unfortunately, 'last monday' is not a reliable frame of reference. http://gamereplays.org/reference/strtotime.php 'last monday' will give you a different date depending on what day it is when you call it. There are only three strings you can use with `strtotime()` to get a consistent frame of reference no matter what day of the week it is when you call it. strtotime("next monday"); strtotime("this sunday"); strtotime("last sunday"); It's really stupid, but from testing, those were the only ones that reliably returned the same date. Note that it was tested in 5.3, and may have been fixed. Haven't had a chance to repeat the testing with newer versions.
Laravel for one. Even if I don't like it, it's still the most popular php framework last I checked.
IMO the framework **itself** should get a creative/non-sexist name and theme/imagery.
Are you saying shitty hotscripts packages are available on file sharing sites?
Thank you.
$this
I did not mean to insult anyone. My bad if I did. Saying you should feel bad was not excactly constructive critisism. I still stand by my other points.
I'm changing the images. But how us the name PHPixie sexist ???
Thank you for your comment. Sorry to bug you with more questions, but I've never heard anyone's opinion on this subject, and I am really interested in learning more. &gt;Being a good developer isn't enough. You're expected to be highly professional and very self-managing and proactive. What do you mean by being expected to be highly professional and self-managing and all? When I read job descriptions of contract work, they don't seem to be more strict than permanent job descriptions. &gt;question whether it's for you and don't be tempted solely by the money That's the thing: it's not just the money; it's the shortness of the projects. Also, this could allow for me to travel while I wait for more work, during which I could develop my own projects. Very win. &gt;you will still have business-related outgoings whilst you're not earning. I will still have business-related outgoings while I'm not working? This is related to the sole business I would need to open to even be able to do contract work, right? I heard that the UK is actually great for this sort of thing as it has rates quite advantageous for businesses? Also, we're still talking about 3-4x the salary rates of permanent jobs. (Okay, 2-3x if we include tax). I'm sure some minor additional costs can be more than covered by the excess money I get compared to a permanent job equivalent. 
Wow seriously? How hard can it be to make a reference for a two-week timeframe?
Out of all of those projects, which has the most market share? Which makes the most money? Hint: It's WordPress (Automattic), by a factor of 10 or more.
You should start a service where people can send you code and for 2 cents per line of code you will criticize it, rate it, and tell people how to improve. Code review for money. You can call it: McGlockenshire's 2 cents. I am not even joking, I would pay you lots of money. 
I think it's a light hearted way of doing things that's might give a laugh. However I also wouldn't want to use a framework that did that. If I use a framework, I want it to adhere to high cohesive names as much as possible. Sure, this one example isn't too bad (if you ignore that a sprite and image are different things) but if there's a clearer name for something, use that. Ultimately you should think of how your component would seem stand alone. If I'm not part of your frameworks community, and I see a component called sprite, I'm going to assume it deals specifically with sprites, not images as a whole.
How exactly does the word unicorn describe what that package or set of packages do?
Unicorn was just a random name (read the P.S. line). By the same logic you could argue that the word Twig doesn't describe a templating engine, or Doctrine doesn't describe an ORM. you have to have names to distinguish stuff
Looks pretty great, but could you include php5.2? It's still eerliy popular, unfortunately! I have to maintain a VPS with an old version of Ubuntu, currently!
`date('N', $date)` will give you an integer representing the day of the week. Some simple logic and arithmetic will get you the Monday through Friday of that week 
Because they're not sub-packages belonging to something else, but rather products in their own right. Sorry to be rude but do yourself a favour and take a moment to think things through prior to acting on things. It appears that whatever happens to be on the top of your head comes out unfiltered on the internet and I doubt that's particularly pleasant for anyone. 
Interesting. Yeah the first bit and COW makes sense. Was surprised about the reference assignment triggered a COW. That would then imply that object2 got its own new zval and object1 and object3 share the same zval
My apologies. To clarify, I was referring to the imagery/theming specifically. I think you have a reasonably solid set of components - but that you are wasting its potential and the chance for greater adoption, and even to be taken seriously by the corporate world *unless* you were to change the name from PHPixie and adjust your tone/language surrounding the package (all the way down to personal blog posts, docs etc). It's hard to put your framework in front of serious (100 million in revenue+ a year) corporations and to be taken seriously, even for their smaller non-mission critical projects. I would urge you to reconsider the approach you are taking.
But those are stand alone projects where the name of the total package matches the vendor name. It's twig/twig, not sensio/twig. Conversely, the vendors that release multiple packages seem to use descriptive name: zendframework/zend-view, symfony/yaml, phpunit/php-code-coverage Unless your planning to spin each component out with its own brand, marketing, and vendor, I think you're better off with descriptive names after your vendor. P.S. the league folks seem 50/50 on silly name and descriptive names. I definitively wouldn't follow that example.
Laravel is on the graphic. I think. On mobile - looks like Laravel 4?
FYI in phpng the last assignment will no longer trigger a copy.
This is *exactly* what happens. You should be able to use `debug_zval_dump()` to see this. Some slides on this here: https://speakerdeck.com/dshafik/phpnw14-php-under-the-hood?slide=50 Covers copy-on-write, and references. PHP tries to use the minimum number of zvals to represent the data, in this case on the first assignment, it can use a simple ref-counted single zval. Once you do the reference, it needs two zvals, one with `is_ref=0` and `refcount=1` and one with `is_ref=1` and `refcount=2` to cover both the non-referenced value and the referenced one.
Has anyone used this service? Did you find it useful?
I see. Would you say that laravel does it better? Their namespace looks like: Illuminate\Database but then some classes are namespaced under Illuminate\Database\Eloquent which is basically putting the name even deeper in the tree? I'm just looking for a nice example to follow
Stop trying to emulate Laravel. It won't make your framework more attractive to developers. 
&gt; I get that Wordpress is shit and choosing it will cost you more time in the long run, but 20 years for Wordpress vs 4.75 hours for Silex??? For what kind of project? Building Healthcare.gov???? I think you misunderstood the graph. It's a visual representation of the technical debt of the projects *themselves*, not your own websites/applications created with these projects (which would be completely separate/different and vary wildly). Also, it's measured in man-hours, not absolute time (e.g. it's estimating that Wordpress would take a team of 20 developers 1 year to resolve all the violations, not that it would take until the year 2034).
I'm not trying to emulate. I'm trying to find an established convention to use.
Honestly, i'd remove the ability to use eval at all
Sorry but composer &amp; phpunit both require &gt;= PHP 5.3
dun'it
DUnit (Dee-unit) =)
The current site has that listed in disable_functions, but I've secured the new site beyond just PHP itself, so I think leaving eval() in is safe for the time being. Prove me wrong, though!
And passthru, etc. Having shell access to a linux server without being sandboxed to a directory makes hacking it pretty easy. I'm no netsec expert, but I'm pretty sure being able to list every file on the box is a huge security hole.
I released [my own tutorial](http://ilovephp.jondh.me.uk/) a couple of weeks ago, intended for beginners. I use graphical diffs to illustrate changes - I'll be interested to hear if anyone feels they help visualise the development process. The changes presented mirror the way in which applications are really created, rather than the artificial way in which they are illustrated for teaching purposes. The material covers all you'd expect: HTML, CSS, forms, redirection, SQL, databases/tables, SQL injection, sessions, authentication, password hashing. I've deliberately avoided a framework, and use only one library out of necessity, as I think exposure to the core language is a good thing. I believe I have interested one learning group in taking on this material, so please do let me know if you do also. Feedback "from the field" is of great interest. 
[Best version.](http://i.imgur.com/BtjZedW.jpg)
It's a trade-off between having a script full of junk hindering readability and disk activity.
I guess they take into account people not using an IDE like PHPStorm that would have to manually search and replace the occurrences of that class.
Each 'render' runs inside an otherwise-empty docker container with nothing of interest inside it. PHP is also run as an unprivileged user inside that container, and the container itself is discarded after each run. There are also strict memory and run time limits enforced to make sure you can't use too much time. If anyone can get around everything, I'd be very happy for them to so I can lock it down further, however, the goal for the rewrite was to allow as much code as possible to run and the more restrictions I add, the less useful the tool gets, in my opinion.
&gt; pagekit/razr dev-master &gt; katzgrau/klogger 1.0.* &gt; rupaheizu/ribe dev-master I had the hardest time pronouncing those in my head
I assume the reason it exceeds complete rewrite time is because so many web applications are dependent on them. At very least, even if it was a completely rewritten, there generally maintains some level of backwards compatibility and unfortunately with any large project, you are constantly battling rampant growth by trying to maintain some level of consensus. There's a reason most of the most widely used platforms also tend to have the highest technical debt. I get what you are saying, but it's also not as easy as starting from scratch when you're talking about widely adopted platforms.
Please check out the beta link at the bottom of my post - it sounds like you're still using the old site! I see that my original post was a bit confusing, so I've cleared it up and made this more obvious
Oh! Haha, I am bad at reading.
As an aside to this does anyone know how to check if your code itself is compliant with each version? I'm trying to upgrade from 5.3 to 5.5. I was using [this](http://stackoverflow.com/questions/15781364/how-to-use-php-codesniffer-for-upgrading-and-compatibility-check-php-5-2-agains) and it worked a few months ago. However when I try running it now it just runs forever. Last time I let it run for over a day and nothing ever happened other than my fan spinning. Usually it would take about 5 minutes to go through my codebase and tell me what was and wasn't right.
I'm impressed they know what `mysql_real_escape_string()` is for! Oh, hang on, what's this I see? md5( $_SESSION['password'] ) Oh dear. 
Also, of note, I actually dropped the themes feature on the new site, but I've just added [an issue](https://github.com/tehplayground/support/issues/2) to bring that back in and also theme the render. Probably just be a day/night switch which affects both the editor and output panes. Thanks!
Just use DUnit :). Follow the configuration section. Just change your .dunit.config to this to run 5.5 only and only syntax checking. DUNIT_PHPVERSION="5.5" DUNIT_PHPSYNTAX=true DUNIT_PHPSYNTAXCOMMAND="find /opt/source -type f -name \"*.php\" ! -path \"*/vendor/*\" -print0 | xargs -0 -n 1 -P 8 php -l | grep -v 'No syntax errors'" DUNIT_PHPUNIT=false DUNIT_PHPUNITCOMMAND="/opt/source/vendor/bin/phpunit"
Very cool.
Please don't... :(
I like the concept (very much), but the use of `readonly` as the modifier keyword name - not so sure - seems open to confusion as to what it actually does/modifies. 
A good question is how many of these "standards and ideas" even existed at the original time of writing of WordPress over time, vs came to fruition afterwards.
How does this lib compare and contrast with phpenv?
What's the output of `$ cat /etc/resolv.conf`?
Also maybe that "missing information" you don't get with /usr/bin/host has been rate limited by Google's DNS servers? And have you tried an alternative set of DNS servers? Maybe OpenDNS? Or the nameservers at your ISP/VPS/Dedicated server host?
I dislike it. This would be covered by the [property get/set feature that was rejected few years back](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2). It would make much more sense to try and revive this, especially since a majority voted in favor of it. Let alone the fact that there's a new reserved keyword, this is totally confusing: it's readonly, but actually it's not really readonly, it's only readonly when accessed outside of the object's scope. It really feels like it's addressing only a part of the problem of property get/set, so we'll still need getters/setters in some cases. So in the end, either we mix public properties with getters/setters, or we only use getters/setters.
technical debt is crap code that you'd fix if weren't so busy dealing with the crap code.. [from wikipedia](http://en.wikipedia.org/wiki/Technical_debt): &gt; debt can be thought of as work that needs to be done before a particular job can be considered complete or proper. If the debt is not repaid, then it will keep on accumulating interest, making it hard to implement changes later on. Unaddressed technical debt increases software entropy. So yes, violations in and of themselves are debt
Awesome, thanks Davey!
You're only just now realising Insight is shit?
You bolded out of context.. The beginning of that sentence sets the context &gt; **If the debt is not repaid**, then it will keep on accumulating interest, making it hard to implement changes later on It's already debt. That debt is why it's hard to implement changes later on... because you're swimming in debt. Your debt has caught up with you. **That zero-interest rate was an introductory rate.** This is **not** the quote &gt; Your bad code isn't debt until it you need to make changes 
... Exactly such behaviour of php is the reason why im asking ._. Thanks you very much!
Correct me if I'm wrong, but wouldn't Travis CI or another CI service handle this? The only benefit I see would be to test a version immediately, which could be useful. I'll give it a try sometime.
Aymen brother. That's why it's key to select a talented team or join something early enough before the whole thing goes to hell. I've wasted wayyy too much of my life cleaning up other people's shit so the project can move forward faster. This is why design patterns and object oriented programming matters 
You actually put phpenv on your box. I personally don't believe in installing dependencies like phpenv on my box. It is great being able to just tell anyone at the company just to append the composer require-dev to their project and they're able to have PHPunit and PHP syntax ran against their project for all the PHP versions we'd like to support.
The reason why I released the code to the public is to let other users how it was built. Simply, I look to another person's code. I wouldn't give a damn what the project is about when there's room for change in his codebase. The point of this project is play with architectures with what @codenamegary had said
&gt; The only benefit I see would be to test a version immediately, which could be useful. Along with the fact not having to push to Travis CI just to check if you broke compatibility with say PHP 5.3. You can see us doing this [here](https://github.com/Vectorface/whip/commits/master). You're also right about the factor of testing a version immediately. At Vectorface we love the fact that we can check syntax and run the test suite that covers 100% of [this](https://github.com/Vectorface/SnappyRouter) across all supported PHP versions in ~8 seconds vs Travis taking longer than 8 seconds to start up a container. I also don't want to fork out $130/month for Travis's private repos just to make sure my code runs smoothly on these PHP versions.
Why is it have to be 'solving problems'? If the problem were *ah, the whole framework can be bloated at times so i should use its components individually when needed with a custom architecture*. Can it be considered then? To answer your questions in general You don't have to know what the project is all about, you just need to read the code and provide criticisms about it. To answer your specific questions &gt; What is haks? It's a [project](http://i.imgur.com/28TowVs.jpg) I started two years ago. &gt; What is hurr? Your typical init.php &gt; No way to configure environment? What is to configure when you only have one environment to work on at the moment? You should look closely on the filesystem before asking this one. &gt; No way to configure error reporting? No need at the current pace, I can just tail the error log for the app. edit : fixes.
Uncle Bob disagrees https://twitter.com/unclebobmartin/status/17906056084 Technical debt is not messy or "improper code" in and of itself. Technical debt is taking a shortcut that you know is not optimal in the long-run. *Using* Wordpress to quickly build and launch a blog site that will need further, and more complex business rules that Wordpress will fight the implementation of, is technical debt, because you sacrificed long-term development for short-term gains. Conversely, if all you need is a simple blog, *using* Wordpress is not technical debt because you picked a tool designed for the job at hand. But Wordpress itself is not technical debt just because it has messy or improper architecture. Maybe there is technical debt in Wordpress because of some architecture decisions made by the team to quickly do something knowing full well it was not a good way to do it in the long run, but that is not the same thing as messy code.
Haha that's excellent! &gt; This man has GOT to be crazy to do this Better to live crazy than to die sane, I always say :-)
Here is the result if you edit the value: https://beta.tehplayground.com/MuUPP8FHlyDRwWIO
Not to mention that it's also trivially easy to implement in userland already using private properties and `__get()`, if you absolutely must have public, read-only properties (but, IMHO, you should always prefer accessors anyway).
Great catch, I didn't even notice that. Thanks!
How did your testing go? :)
&gt; But Wordpress itself is not technical debt just because... We are in agreement. At least from the "end-users" perspective / Joe Blow wordpress user. However, from a Wordpress contributor's / wordpress team perspective, there's debt
Yes. If you have mastered the art of *finding free anything* then, that's whaat you'll find
Technical debt isn't like carbon credits. You don't get to nix it because the thing you shittily built helps other people save time. Your project still has issues that need to be addressed.
So? It doesn't make it well engineered and when discussing technical debt you aren't discussing market share, you're discussing engineering.
&gt; It would make much more sense to try and revive this, especially since a majority voted in favor of it. I'm not sure it does make sense to revive it, it didn't get the required majority. I would still vote no on anything as complicated.
One man's complication is another man's simplicity. I'd love to replace the horrible getFoo/setFoo functions polluting my class with simple, clear, unambiguous bits inline with the property declaration.
Has anyone used XHP for a live site? What are your impressions of it? After years of pure-PHP templates, I recently tried out Twig and rather enjoyed it. I've been thinking about exploring other template options, but haven't had the courage to try out XHP yet.
I'm not a fan of this. I've already voiced my concerns to /u/Hatte_keine_Ahnung on Twitter regarding it being an ambiguous term for such functionality: https://twitter.com/trevorsuarez/status/524946003863302144 (read the whole conversation)
&gt; One man's complication is another man's simplicity. The patch is as a matter of fact complicated, I'm talking about that. I'm not talking about the idea of mutators/accessors ... I like the idea, but don't like it being hugely complicated, which that patch definitely is.
I usually teach people how to make a forum of sorts. I find it pretty much covers all the real basics you need to make your own project after it. You will learn login-techniques, database-calls, security, permissions, posting/editing/deleting, moderating etc etc etc. It ofcourse depends on the level of the people you teach, but this is a nice start that I use.
Debt, whether technical or not, can exceed the cost to start from scratch. Debt can a decision (though sometime we may not have much of a choice) for a short term gain that you know will cost more in the long term. Money example: I have a mortgage, which is costing me way more than if I lived on the streets for 20 years and paid it off in full. This debt is beneficial to me. Code example: there are a few million users of your code. You choose to implement a new feature by introducing more global state. This means you don't break backwards compatibility for all these users but it's harder to test, refactor and add features in the future. In the case of WordPress, the 20 year estimate is equivalent to 80 developers for 3 months. In that time you could easily build an awesome WP competitor from scratch. But it wouldn't be backwards compatible with the millions of users. In summary: for WP, the cost of the technical debt is less than the cost of breaking backwards compatibility.
It *is* the one true style. :&gt;
Of course Magento is excluded because otherwise we'd be unable to read the rest of the graph.
Here's a 1 liner to run your tests in PHP 5.6 (replace the 5.6 with other versions as required). docker run -it --rm -v "$(pwd)":/home/test -w /home/test php:5.6-cli php ./vendor/bin/phpunit The first time you run it, it will get PHP 5 6 images from the Docker hub registry (about 200MB IIRC). The PHP is pretty bare bones and doesn't contain all the extensions you may need. I've had a play with some HHVM containers but haven't got it down to a 1 liner yet. Ideas welcome. Yes, Docker is awesome.
Didn't have the time yet to give it a go. I will give some feedback after I will test it.
Hm sad that this needs Docker ;( any alternatives?
If you're not rewriting code because of BC breaks, it's your design choice. There is no code that would require 20 years of refactoring. This number is just made up.
It sure did. Thank you very much!
Writing getters instead of declaring a property public will assure you that you won't break the public API when you will realize that you need to manipulate the value before you return it.
Havn't tried XHP yet, but it does seem pretty useful for composing elements. My only complait would be namespacing and composer integration (edit: nevermind for compose i'm wrong!) which seem pretty off by todays' standards. I might be wrong though (?). Was looking for a templating system with the features of something like Twig, without the need for learning a syntax and came accross League\Plates which does exactly that. XHP, Twig, Plates: Smarty days are long gone and PHP now offer really interesting templating solutions \o/
I'm 100% behind this.
What the hell is this? https://github.com/ajaxtown/eaglehorn/blob/master/core/worker/ajax.php
excuse me ?
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8) # DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN nameserver 8.8.8.8 nameserver 8.8.4.4 
What are your goals? Are you trying to implement localised interfaces based on different cultures, or are you simply trying to translate text? [If the latter, then none of the options you've presented (just translate the text itself, don't duplicate the views).](http://php.net/manual/en/book.intl.php) &gt;if a sentence is longer in a certain language, i can adjust it if necessary (i don't want to fall in tests like if($lang == "en") { $width = "150px"; } ... Or you could not hardcode widths on elements which are dynamic. 
&gt; https://github.com/ajaxtown/eaglehorn/blob/master/core/worker/ajax.php It is a test worker. Its not documented in the documentation. The framework is in beta state. I am expecting suggestions to improve. Thanks.
Have they made the consideration that they're risking the reputation of the product by letting customers run it on versions of PHP that are no longer supported and not getting critical security updates?
Do you have that material online? Would be interested to see it. 
Functional programming shouldn't be using global variables either. In fact, global variables are considered bad practice in pretty much every legitimate programming paradigm that I know of.
just trying to translate text as for the dynamic widths, it was an examlpe. i'm also concerned about the construction of the sentence. (that's all i can think of now) &gt; some [dynamic] text &gt; some text [dynamic] i was looking at MessageFormatter (in your link). i don't really understand the msgfmt_create / formatMessage. you have to create each sentence in order to use them just after ? &lt;?php echo MessageFormatter::formatMessage("en_US", "{0,number,integer} monkeys on {1,number,integer} trees make {2,number} monkeys per tree\n", array(4560, 123, 4560/123)); echo MessageFormatter::formatMessage("de", "{0,number,integer} Affen auf {1,number,integer} Bäumen sind {2,number} Affen pro Baum\n", array(4560, 123, 4560/123)); ?&gt; you have to write the sentence in every language you're going to use ? with few sentences to translate, in only 2 languages, i can understand this solution, but with 3 or plus and many texts to translate, i have some trouble using this solution
It's a lot better than the current one. Maybe not in terms of style but it feels a lot less "sexy just for being sexy". Not a huge fan of the face though.
Their material is mostly excellent, but has some omissions. I raised a few GH tickets recently to see if it can be improved, so we'll see. They already know about some XSS sec issues (ticket pending since April) but I wonder if they don't presently have the time to fix them. 
I appreciate the time you spent in reviewing. I understand your points and will be working to cover up most of it. Its still a Beta version. It would be of great help if you can fork the repo. Just a request !
Thanks! I'll probably get some more concepts done before the final result =)
So what? Code is code, regardless of where in the release cycle the product is.
Feeling proud is great. Keep it up. Never stop learning
I'm not a fan of this. Number 1 the reserved work is misleading. The member variable is only read only outside of the class. Number 2. A simple getter achieves the same functionality and ensures that any future updates to the language don't break BC for 'readonly' member variables. Of course if this RFC is approved there's nothing to stop anyone choosing getters over readonly. 
I don't care about your branding strategies. This is not PHP and it doesn't really belong here. If you want input on the direction of your framework for matters like these, turn to your own community (if you have one). Also, you post way too much. Since yesterday you've made 5 submissions to reddit pertaining to PHPixie. Tone it down. 
every time i do this: class [SomeEntity]Collection extends \ArrayObject {} I am proud of myself for not being an lazy ass using plain untyped arrays.
Yikes. If you have to be crazy to run the paid version, how do you classify someone who would trust the version found the "borrowed" route?
&gt; PHP is such a hacky language Agree with most of your post, but not this - bad work should not be blamed on tools. Blame bad work on the users of the tools. This is probably one of the problems of contracting - no long term care for the product (either by management or by poor-to-adequate contractors) can leave it in a sorry state.
smart :)
Just wondering whether you've had a chance yet?
lol funny as hell
It is a bar chart, with lines in between. 
Yes, but in this case it's more like &gt; One man's simplicity is 10 man's complication
I love tremendously useful classes that need maybe 150 lines of code, such as my `TaskDependencyResolver` I once wrote.
A quick glance at [your submitted page](http://www.reddit.com/user/dracony/submitted/) proves you're easily breaking the [9:1 reddiquette rule of thumb](http://www.reddit.com/wiki/reddiquette) and a look at the votes on those items shows you consistently post content that people are not interested in
It isn't like running your own business, it's still like working 9 to 5 as you are working for a company, without actually being an employee of that company.
When I was contracting, the only downside was holidays. If you get contracted to a company for an amount of time, they expect you to be there for that amount of time. So you have to weigh up the pro's of a long contract giving you more security, with the cons of not being able to take a break for a year. The other bonus though, is if you work for a year at £400 - £500 a day, you can afford to take a couple of months off after it, if you were sensible with your money. Also, I found the interviews for contract jobs were much more intense. Expect several interviews with a lot of technical questions and tests. If they are paying £500 a day they want you to be good.
I don't see why this is necessary. To me, adding this additional layer over bootstrap would only keep away web designers who don't know what XHP is. I also don't see how it's helpful to have the following: &lt;bootstrap:button use="default"&gt;Default&lt;/bootstrap:button&gt; Over this: &lt;button type="button" class="btn btn-default"&gt;Default&lt;/button&gt; What solution does the first one solve exactly? Why would I want to move away from HTML, a language familiar to a lot more people, and move toward the XHP approach?
If it's obfuscated, then it ain't open source. That's one of the understandings of open source.
**Helpful Answer** Check out [this](http://stackoverflow.com/questions/19249159/best-practice-multi-language-website/19430987#19430987) **Less helpful and somewhat unrelated** Check out this [MVC For Noobs](https://gist.github.com/Hamz-a/0b7d2e552812640dd8ef). The term MVC gets thrown around a lot and maybe it's me but I'd be a lot more comfortable if people said "MVC Inspired" rather than "MVC" unless it really *is* MVC.
£400 - £500 for PHP is a bit optimistic unless you are a top blagger or genuinely talented and have a great rep. I know contractors who have taken holidays but that was usally for long term contracts and not web php which always seems to be deadline driven. They talk about contractor burn out a lot. You say "when I was contracting" what are you doing now?
I'd say these rates are about right in London at the moment... Trend is going up according to IT job watch too.. http://www.itjobswatch.co.uk/contracts/uk/php%20developer.do
Bingo. The GPL on this subject: &gt; The “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work. Obfuscation is not allowed.
I'm dying to use XHP, but last time I tried it, it broke basic PHP functionality (something about auto-loading classes or the like) which coupled with the lack of PhpStorm support made me turn away in sorrow. Right now I'm using [HTMLObject](https://github.com/Anahkiasen/html-object) as a poor man's XHP, which allows me to do things like: /** * @return Elem */ public function printHeader() { $header = Elem::create('div') -&gt;addClass('theme-base-header'); $header-&gt;appendChild($this-&gt;printNewLogo()); // $header-&gt;appendChild($this-&gt;printLogo()); $header-&gt;appendChild($this-&gt;printNav()); return $header; } /** * @return Elem */ public function printNewLogo() { $container = Elem::create('div') -&gt;addClass('theme-special-logo') -&gt;appendChild( $link = Elem::create('a') -&gt;setAttribute('href', "{base_url}") -&gt;setAttribute('title', $this-&gt;getSiteName()) ); if ($this-&gt;hasLogo()) { $link-&gt;appendChild( Elem::create('img') -&gt;setAttribute('src', $this-&gt;getLogoUrl()}) -&gt;setAttribute('alt', $this-&gt;getSiteName()) ); } return $container; } ...rather than using templates, which aren't very flexible when you want to change things. Edit: could code blocks be toggable, and hidden by default?
There's two problems with this, in fact. Passwords don't need to be stored in the session, and yes, on shared hosting without user isolation (suExec), passwords can be grabbed. The solution here is not to use shared hosting and/or not to store the password in the session (I don't know why they do that). The thing I was mainly drawing attention to was the use of MD5 - it is now so computationally cheap to reverse this hashing operation, it is next to useless and you might as well store passwords in plain text. Here there is no salting either, so you can just use a rainbow table site from the internet. 
Why not using Gettext? http://php.net/manual/en/book.gettext.php
For poin t#3, you shouldn't just cringe at passwords being plain-text in an email, you should be horrifically worried that they send you your password. This means that the password is *not stored as a hash in their database*. That alone should make you run for the hills.
I guess also an md5 rainbow table covering all passwords up to a certain length would also make the salt useless if the total length of the password (including the salt) was covered by the table. Unless the rainbow tables only cover common words and not the more random passwords? Edit: just tried looking up the md5 of "password" and of an IP address-salted version "password123.123.123.123". The first one was found quickly, but the second one was not. I suspect it may just be the length that made it less easily crackable, rather than the fact that it was salted. Event "password-myname" was not found on a ~~1.5~~ 15 billion entry lookup. It also couldn't crack "gdhyenta" so it looks like even ~~1.5~~ 15 billion entries doesn't cover all 8-letter lower-case passwords. I was using this to try it: https://crackstation.net/ * 5f4dcc3b5aa765d61d8327deb882cf99 password * 1544124b6b0fbf99a1e373fc1b85bb55 password123.123.123.123 * e798969e2f6d940edad647179dd0f5e9 password-myname * 52490eb52fded6d97beba5fbfa52270c gdhyenta Not saying that md5 is good to use though.
&gt; i like the idea of having different .phtml : if a sentence is longer in a certain language, i can adjust it if necessary (i don't want to fall in tests like if($lang == "en") { $width = "150px"; } I do a lot of multilingual stuff. Maybe 1% of the time do I have to put in a language-specific exception for view stuff - even in bidi situations. I think you are probably throwing out a VAST amount of code reuse in exchange for avoiding something that barely ever happens.
i don't know, i'm not fan of big arrays like your example. protected static $messages = [ 'pt' =&gt; [ 'Hello world' =&gt; 'Olá mundo', ], 'nl' =&gt; [ 'Hello world' =&gt; 'Hello wereld', ], ]; you'll finish with a thousand-row-array and a risk of doubloons or maybe use this solution, but splitted by [controller-name]
I agree, that's why I said that I am an 'ancient' developer who worked at Prestashop
Re your edit, I'm surprised at that short one. Shop around and try a few sites. Or, if you don't mind leaving your computer on overnight, try brute-forcing it yourself? I'm sure programs are readily available for this. 
OK fair enough. Maybe this is popular enough to be pirated. I've searched for this kind of stuff before and never found it. Plus as halfercode says it's often modified, and not in a good way.
The reputation of the product is based on how easy it is to use it, not on the performances nor anything technical. It is really a shame, Prestashop could be much more if it used at least some symfony components
Yeah, it isn't real salt if it's the same for everyone. I guess the thing about salt that people sprinkle on a meal, is that it is done to personal taste; everyone has their own way of sprinkling and amount they put on, and what they put it on. So a password salt is the same - the added salt is some additional unique or near-unique detail about that user. From my experiment, if you are not sure about how a site is storing your passwords, then make it a long password with no real words in. That makes passwords a bugger to remember though, so maybe just long, real words for memory, and some additional characters thrown in that are not just "." or "123" on the end.
&gt; Even as an experienced developer, I couldn’t tell you off the top of my head what the “DB” facade’s actual class is. Whenever I need to know this, I need to &gt; Open up the app configuration &gt; Look for the DB alias and the actual class &gt; Get the service identifier (db) from the facade class definition &gt; Use grep or ack to search through my source code to find how the service was bound and/or extended &gt; Jump to that class definition Or... you can just go to the facade and look what it references to ? https://github.com/illuminate/support/blob/master/Facades/Event.php#L4
Nice summary of the problem. TLDR: &gt; In the end, Laravel’s meta-programming creates a weird, two plateau learning curve. Of all the modern PHP programming frameworks it’s the easiest to get started with. However, that ease comes at the cost of a very steep learning curve when you’re ready to start digging into how the framework does its job. Laravel "encourages" a very specific (and, depending on who you ask, *wrong*) way of doing things and if you wish to deviate from it just a little bit, the framework will fight you for it. The upcoming version 5 should at least help with the coupling issues.
yeah, maybe you're right. I think i'll go for solution **3**. then how do you do it ? one big array with all the texts ?
The standard for managing translations is GNU gettext. PHP is supported. I'd recommend using it.
It's really nothing like that. 1. Find your customers - You don't need to if you sign up to agencies that specialise in contractors. Also, they aren't taking the money off you, they take it from the company paying you. 2. Produce invoices - It takes two minutes, just use a template and fill in your time/amount. It's not like freelancing where you have to keep a log of your hours for each different job, you have a day rate. 3. Chase payments - Again, it's not freelancing, you are paid a wage. X amount per day for Y days, paid into your account every week/month. I never had to chase anyone. 4. Tax returns - Recorded my expenditure and put all my receipts in a box, at the end of the year I gave my accountant my expenses and he did everything. £150 once a year. One year he even managed to get me a rebate! 5. Putting aside money - When you're on £400 a day is not a hard thing to do, unless you're really bad with money. 6. Work on your personal brand - I did absolutely zero work on my personal brand. I don't even have one. 
&gt; Chase payments That's the biggest pain, if you work direct with the client they will try to delay paying as long as they can for cash flow
Unless I'm reading it wrong the average is £350 
&gt; i'm not fan of big arrays like your example. That is just an example. You could get using a simple key -&gt; value storage like Redis, or storing the information on the database, or using [Gettext](http://php.net/gettext) ... doesn't really matter where the messages are coming from.
I think I found an error: Warning: file_get_contents(/etc/shadow): failed to open stream: Permission denied in - on line 4
You're right about it not being 100% accurate, however the examples you posted come under the violation "Database queries should use parameter binding". These examples use *escaping* instead of parameter binding, so the violation is valid. [PHP the right way](http://www.phptherightway.com/#databases) has a short intro to parameter binding.
Exactly. My point is that the fact that WordPress was created a long time ago does not mean that it cannot follow current best practices. If code is written well then it is easy to change and (if it is still being developed) can follow current best practices.
Hey mate I learnt the basics on codecademy then moved onto buckysroom.org. I'm no professional but from knowing nothing it's taught me ALOT LPT: listening to background music while watching buckysroom tutorials to avoid falling asleep
'exposed', as something sitting between 'public' and 'protected', would describe it better I think.
I have met other contractors who follow that path too, and it's an entirely acceptable way to find work, but in my experience this path is taken by the minority rather than the majority. I do worry about the IR35 implications of this approach, and morally I personally don't like the "pay an accountant to save me money approach" without understanding what it is the accountant is doing. But I don't/won't judge anyone else who does so. I also ( and more importantly ) worry about the sustainability of this approach, if you're in contracting for the long game, then you I feel you really do need to work on all of the above.
&gt; The upcoming version 5 should at least help with the coupling issues. How?
I don't think it's that simple - for example, Wordpress is well known for being the a prime target for website hacking *as well* as being quite slow once you go past the basic "site with pages and articles" point, and that effects its reputation.
I'm not defending sending passwords in emails, but they could be generating a new password, sending you that, and still be storing them hashed.
That really depends. It is downright impossible for code written during PHP 5.0 or 5.1 to follow best practices, far less PHP 4 - and reading Wordpress's source code you definitely get the PHP 4 feel. Sure, it *can* be updated, but if you have a huge codebase written before modern features and best practices kicked in, that's "hidden" technical debt that have built up for months or years. (Hidden because the better decisions you should've made were not currently possible in the langauge the code was written in) Even code written post-5.3 can be really poor, considering that a lot of the best practices took a long time to really settle in with PHP programmers.
When the hell dir /r/php become a place to share shitty nulled scripts?!
Yes I have, no dice unfortunately. Upon further investigation it is possible its a DNS iptables rule on a perimeter firewall, I will try and get this checked. Its odd as dig works perfectly fine. 
If you're having Laravel problems I feel bad for you son I got 99 problems but Symfony ain't one.
btw you left an IP address un-anonymised...probably won't matter, just fyi. 
Kids, this is like God calling out Jesus for turning water into wine. Alan Storm keeping it real for 40 fucking years. RESPECT. 
There is now a `Contracts` package where all the dependencies live: https://github.com/illuminate/contracts
As you guessed below, the DNS responses are getting back to your machine. From your strace, re-ordering to make it easier to read: 1) you're connecting to 3 DNS servers, 2 from Google and one possibly from an ISP. connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("8.8.8.8")}, 16) = 0 connect(4, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("8.8.4.4")}, 16) = 0 connect(5, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("x.x.x.x")}, 16) = 0 2) The request for the dns lookup is being sent: sendto(3, "V\353\1\0\0\1\0\0\0\0\0\0\3www\7example\3com\0\0\377\0"..., 33, MSG_NOSIGNAL, NULL, 0) = 33 sendto(4, "V\353\1\0\0\1\0\0\0\0\0\0\3www\7example\3com\0\0\377\0"..., 33, MSG_NOSIGNAL, NULL, 0) = 33 sendto(5, "V\353\1\0\0\1\0\0\0\0\0\0\3www\7example\3com\0\0\377\0"..., 33, MSG_NOSIGNAL, NULL, 0) = 33 3) And then all the connections are timing out: poll([{fd=3, events=POLLIN}], 1, 5000) = 0 (Timeout) poll([{fd=4, events=POLLIN}], 1, 3000) = 0 (Timeout) poll([{fd=5, events=POLLIN}], 1, 6000) = 0 (Timeout) fd = file-descriptor, aka the way of following which connection is which. btw you can add -T to time the system calls....but it's pretty clearly a problem with the results of the DNS lookup getting back to you. 
phpBB's normal queries use parameter binding in DBALs that support it. The queries highlighted that use sql_escape are doing queries that can't be bound by parameter binding either due to database support or due to issues with binding the query type. Remember that phpBB supports PostgreSQL, Firebird, MSSQL, MySQL, SQLite and Oracle. There's points in the application where it needs to obtain status information (such as the size of the database) which can't be done via binding. The examples I posted are not valid for this reason.
This is because I'm an idiot and didn't have notifications on for that repo. I'll see if I can get these fixed ASAP!
&gt; when you will realize that you need to manipulate the value before you return it. Instead you get abused by your colleagues when they realise that the getter you wrote isn't actually a getter. 
I actually like this one a fair bit. The reason why is that she seems less like a woman made to be cute/sexy and more... of a person. The sexual aspects are toned down to gone, and she looks a lot less like a stereotype and a lot more like an adventurer. She looks like she's setting out on a journey, and looks like she could be holding a bow and arrow and it would just fit in. In short, she looks like an actual personality, not just a sexualised symbol. Well done, this is much better
&gt; but they could be generating a new password Sure, that's a slightly less scary idea. However, I noted: &gt; you should be horrifically worried that they send you your password The phrasing implies that it was the OPs *actual original* password *in plain text*, not a new random one. Neither of the emails in the screenshots of the articles indicate that the password in the email is a new random one; they both imply that it's the current password *the user set*. 
Surprised me too. 
The [SplFileInfo](http://php.net/splfileinfo) class is really handy for manipulating files. I find myself using it a lot, and occasionally extending it with a class to suit custom business needs and enforce validation.
What does this have to do with the PHP community, or code though? Its a branding/logo concept. /u/dracony: it's great you're building a framework/programming, and sharing it with the world but it seems like you're using reddit to push your project, and a little too much (polls, etc). Posts like this are more suited to keeping it on a blog and sending out a link to your mailing list subscribers (if you have that setup), or even make a /r/phpixie sub? Just a suggestion.
This feature could be implemented as a compiler optimization without any need for new keywords or syntax. That makes implementing it just seem like a terrible idea. 
Simply adding interfaces to everything doesn't magically uncouple your code. I don't see how they're going to help practically when a lot of the them are really poorly written. What is [this method](https://github.com/illuminate/contracts/blob/master/Auth/PasswordBroker.php#L60-L66) supposed to do? Will it break if I replace the default validator? What arguments are passed into the closure?
Well, it's not technical debt if the code isn't released yet is it? It's just 'work that still needs to be done'. You don't start a project and go, 'our technical debt is 6 months!'
Well, it's not like I'm doing this every day or anything. Yesterday I was thinking about new design which resulted on the first topic. The second one was the result of my thoughts and was talking about general naming not just PHP. And today the new logo arrived so I wanted peoples opinion. It's kind of too much, but it's not like I just try to market
The question is not whether you *can* or not, it's the question is whether having to look it up to know what class is getting returned is a smell.
It sounds like you're on the right track, but if you still can't figure out the cause, and if Dig is working then doing a comparison between dig and PHP through either strace or wireshark, would provide another clue in the bug hunt.
Wouldn't that be with any software you use? Learning what it does and how to utilize it.
The definition of insanity is doing the same thing over and over and expecting different results. How does this help? How does any add-on templating system simplify anything? This statement is in earnest; I just don't see the point. The 'designer' vs 'developer' argument is invalid. If you're not interpolating logic in your templates, which you shouldn't be, its a moot point. How is &lt;?=$foo?&gt; any more complicated to understand or implement than {$foo} ? Or {foreach from=$haystack item=$needle}...{/foreach} than &lt;? foreach($haystack as $needle){ ... }?&gt; 
I just put my classes and tests in the same namespace. So per example Rocketeer\SomeClass and Rocketeer\SomeClassTest, and then this is all merged via psr4: &gt; "Rocketeer\": ["src", "tests"]
i thought about that too. But it feels wrong exposing tests to the actual code.Especially in the light of recent reddit post about "not needing tests in production"
&gt; This feature could be implemented as a compiler optimization without any need for new keywords or syntax. No it couldn't. There's currently no direct equivalent.
Oh right, didn't realise it was your material. Good work, anyway - I especially like the presentation, very clear and readable. 
The `DateTime` classes give a much nicer OOP interface to working with dates and times, and especially handling timezones. More people should use it instead of `date` and `strtotime`. &lt;?php $monday = new DateTime('monday this week'); // format for MYSQL echo $monday-&gt;format('Y-m-d 00:00:00');
[Mandatory linky](http://hyperboleandahalf.blogspot.co.uk/2010/04/alot-is-better-than-you-at-everything.html) to talk to the alot monster!
I guess it's whether you want to be found by people who want the code written or whether you're happy going through an agency who will do that leg work for you. A lot of contractors I've worked with (especially recently) have got their current contract through word of mouth / reputation, all of which I classify under personal branding. Some of my best clients have come directly to me from my personal website too :)
&gt; the framework will fight you for it No framework code uses the facades. You can simply never use them and you will not need to use them. There's no fighting there...
Same namespace. Why would you worry about your tests going serverside? It's not like the tests are actually loading or executing.. there's no performance cost. Is it the disk space that you're worried about? FTP upload times? I put *everything* serverside. All development assets -- source code, photoshop files, everything. That way, a future developer has access to it if they need it.
Or if its heavily used, your Os should cache it for you. I find HERE/NOWDOC useful for short multi-line strings, say up to ten lines. Anything bigger, and yeah, usualy your better off putting that into another file.
So: nothing we can't already do in phpstorm/intellij, but missing the power of a real IDE?
Thanks! :)
Your Root-Namespace should be \Vendor\Product (like composer packages are named vendor/product). I would save the Tests under \Vendor\Product\PHPUnit(\ORM) or \Vendor\Product\Test(\ORM) like you already suggested (did you really invented an own ORM? ;-). After that, you register this namespace in the bootstrap of your phpunit with $autoloader = require 'vendor/autoload.php'; $autoloader-&gt;addPsr4('PHPixie\Test\', 'tests/src/'); This way, you have your test classes available in your tests under the same namespace as your code, but can't use your testclasses in your "production" source code. Also they are physically seperated. Bonus: If you use --optimize-autoloader when calling composer install (which generates a huge classmap for performance reasons), your tests don't pollute your classmap. P.S.: That means you can potentially conflict the namespace with your source code (if you really have \PHPixie\Tests\ in your "production source code"). If you worry: use \PHPixieTest oder \PHPixie\PHPUnit
Think about it semantically. It's still code that belongs to PHPixie, so changing the vendor doesn't make sense. It's still code that is part of the ORM component, so changing that doesn't make sense. These are tests for the ORM component. They live inside the ORM component. So, semantically, the only logical place to put this code is: \PHPixie\ORM\Tests You can do this easily enough with Composer and PSR-4: https://github.com/thephpleague/skeleton/blob/master/composer.json#L29
This same logic be applied to the Symfony ServiceProvider. Take this code sample from The Symfony Book: if ($form-&gt;isValid()) { // do some sort of processing $this-&gt;get('session')-&gt;getFlashBag()-&gt;add( 'notice', 'Your changes were saved!' ); return $this-&gt;redirect($this-&gt;generateUrl(...)); } I have to go and check the request object to see what get('session') returns. It's name implies something to do with sessions. But I don't know and if I want to know what it is, I have to look at the code. The second time you use it you'll be like oh that's the Session object. Anytime you're working with something new to you, you'll have to look up the object to see what's returned. 
Or better yet, look at the documentation that lists all of the Facades: http://laravel.com/docs/4.2/facades#facade-class-reference
I do this as well, but I don't put the autoloading for tests in `composer.json`. So my composer.json looks like this: { "autoload": { "psr-4": {"Chrisguitarguy\\Whatever\\": "src/"} } } Then, in my test bootstrap: $loader = require __DIR__.'/../vendor/autoload.php'; $loader-&gt;addPsr4('Chrisguitarguy\\Whatever\\', __DIR__.'/unit'); $loader-&gt;addPsr4('Chrisguitarguy\\Whatever\\', __DIR__.'/integration');
Thanks. I'll go with this approach. there is just one small issue I have with it: I have a \PHPixie\ORM top-level class and I really like my test folder structure to resemble the source code folder structure. If so than the test for \PHPixie\ORM class would go to \PHPixie\ORM\Tests\ORMTest and the test for \PHPixie\ORM\Query would go to \PHPixie\ORM\Tests\ORM\QueryTest. Doesn't that seem a bit redundant? Or should I not have a PHPixie\ORM class in the first place? 
&gt; Well given you are referencing a contract, that is totally up to you. That makes zero sense. Clearly PasswordBroker has a role. Clearly that method has a purpose within the larger role or it shouldn't be in the interface. There's some concept of what a "password validator" or it wouldn't be in the doc block. Based on your description it seems like the method in question is an implementation detail that leaked into the interface.
The entire v4 routes file and documentation encourage the use of "facades", which are a wrong way of doing things. I assume most people on /r/php know that you can inject dependencies from having read previous Facade rants but new programmers will not. They may not pick up the inner workings of "facades" and assume that static methods are easy to test and considered "good" code.
Ah I get what you mean now. In that respect, I did kind of have a personal brand then, but it grew organically, rather than me putting time into it. I did get some work by word of mouth, especially if I did some work for a company that was part of a group. I also got a lot of enquiries via LinkedIn and other similar sites (in fact I still do even though I don't contract any more). I would never make my own website as I'm a terrible designer, and not that up to date with client side stuff either, so it would probably scare people away rather than attract them, so I just link to GitHub on my profiles.
Absolutely, but at the same time, there are arguably better ways to go about it. For example, if one used Dependency Injection instead of the Facade, you wouldn't have to look up what class is behind the facade, it would be explicitly specified in the constructor.
I had no idea composer returned an object from the autoload file. Thanks for the insight, I love this idea for adding an autoloader in the test bootstrap.
I think I should add, this isn't my code - I was just looking for a way around it to do fun things.
Yeah, this is one place where I would say the security can take a hit for usability. I have more than one email address. Make it easy for me to figure out which one I used for your system. There are also times I think I signed up for a service, but haven't yet. And, like you said, the system will already alert a user/attacker, if they try to sign up with an email address already in use. This would be just as easy to script and exploit, so you're really only making it harder on the user trying to log in. If you're concerned about brute force attacks based on a learned email address, the better solution is a (temporary) lock out after X number of failed attempts, depending on the system you're securing.
without breaking who knows how many installs and still retaining "precious" backwards compat?
Would you consider: * Using meaningful titles, so we know whether to click on your item * Posting in /r/PHPhelp for script assistance, that's probably more appropriate than /r/PHP * Pasting your code here using Markdown, rather than using external pasteboards. Thanks. 
Namespacing is definitely an issue; what trouble are you seeing with composer? http://bootstrap.hhvm.com/ uses Composer for the autoload map (including the XHP classes), and for the dependency on the base XHP PHP-lib.
i disagree with this on every fundamental level. this is hands down one fo the worst php projects ever made.
I would be more interested in seeing how XHP can integrate with React components, especially since it's another Facebook project, and one for developing even higher levels of UI abstraction. The dropdown example seems like something that could be more succinctly abstracted into a React component.
finally ended up getting the active class to work. with strpos() thank you again for all of your help
Out of the box its not easy to specify Eloquent reads against the write database. It's difficult to extend the request object. I've run across others that I've had to hack my way around, but I can't remember specifically right now.
&gt; Are you suggesting that it's okay to leak information in one place because it already happens elsewhere? Yes, if the alternative is making the UX worse for precisely zero security gain.
The Instagram example offers precisely no UX improvements over not revealing the email address in that context. Your inability to keep track of your email addresses *as a user* is outside the scope of just about any service. To say otherwise is just a variant of the argument for plain-text passwords being "more user-friendly" than hashed passwords.
The usual way we do this is that the XHP component just renders a &lt;div /&gt; with a unique ID, and then makes sure that a react component is rendered into the div. The naive way to do this would be for the XHP component to also render a &lt;script /&gt;, though most frameworks provide a nicer way to do this.
What was your autoloader? Composer's fixed several XHP-related issues in the last few months, and http://bootstrap.hhvm.com/ is using it.
Use agile methodology/ scrum. Articulate users need in a story and break down the story in a product backlog. Product backlogs become tasks. Review tasks after completion and change priorities as needed. 
No maintenance. We won't deal with such a kind of disgusting folk for longer than necessary if we are able to avoid that. Smart project coordinators are great, because they will just pass the ball back so you don't have to deal with it. Problem solved :)
My bad, i was looking at the wrong repo! (xhp insteadof xhp-bootstrap). Edited my comment above to avoid confusions.
Next time tell your colleagues that a getter/accessor it's still a getter/accessor even if you manipulate the value, as long as you don't change the internal state of the object. The internal state of the object **should** always be changed from a mutator/setter.
Minor, but when PHP version is in 5.6.2, it's calling out a syntax error for variadics, even though it still works: http://i.imgur.com/mgr2TfZ.png Awesome work!
Must be for Gov jobs, our money to burn :(
This only works when your client is capable of and interested in spending potentially infinite money and time. Agile just isn't the real world of client work.
&gt; *How do you approach this? How do you lock down slippery requirements and protect yourself from flaky / incompetent clients? How do you nail the functional specification and make sure your statement of work isn't open to interpretation by these kinds of clients?* Well, I've been bitten in the ass by a few clients in the ways you're worried about. I've completely changed my business model. Clients used to pay me to *make a website*. They used to pay for *results.* Unfortunately for me, the 'results' that clients are looking for often turns out to be a moving target, and one that your client will often make impossible to hit. Always a bad situation. Clients no longer pay me for results, *they pay for my time, and that's it.* I no longer make any guarantees about the final product or end results. At all. I make estimates, which are nothing more than just that -- estimates. They purchase an amount of my time, upfront, and I spend that time working on their project. If the project isn't completed in that time, they buy more of my time. If they are unwilling to pay upfront, or if they are unsatisfied with the results of my work, they can go elsewhere. I don't need a "functional specification" to promise my clients I'll follow through or even do good work. That's what my reputation is for. I find it's impossible and silly to try to outline every specific detail of a project before you've hardly even started fleshing it out. It's the nature of this stuff to change radically, and frequently -- you cannot just set a specification in stone and expect it to all play out as planned. You need to expect the unexpected. Always be prepared for anything. For me, this means when a client radically changes their project's scope, I just don't have to care at all anymore. They buy hours, I spend 'em workin'. That's all that matters, now.
What's wrong with the use of facades? Personally, I prefer DI, but facades are very pragmatic in some instances, particularly in situations like the routes file where the framework API is taking center stage. 
This works quite well in phpstorm and I use it frequently: $sql = &lt;&lt;&lt;SQL SELECT * FROM table SQL; You will get sql syntax highlighting with the above. I also use it for dql and rest assured phpstorm will someday implement syntax highlighting for dql as well: $dql = &lt;&lt;&lt;DQL SELECT Entity e DLQ; If you're writing sql more than one line in fact I will insist on the above in my codebase.
Yeah PHPixie\ORM should not be a class. It should be PHPixie\ORM\Something.
The comment I was replying to implied that technical debt is something to be avoided at all costs, and that it will destroy your project. What I was trying to imply is quite the contrary - it's often much more profitable to build something useful, quickly, in a sloppy way than to build something slowly and perfectly. It's like any other type of debt, it allows you to leverage resources more quickly that you would not generally have access to which is often crucial for obtaining users and market share in the fast - moving Web world. I'm not saying you should build crap, but I am saying that you should build the best thing that you can as quickly as possible, without spending too much time worrying about the technical debt you may be accruing. The only time technical debt matters is if you are in a position of needing to scale, which comes way down the line when distributing Web software/services. And if Facebook and WordPress have taught us anything, you can pile crap on crap and still stay ahead of problems of scale :)
I'm going to take those two paragraphs in reverse order. - Developers shouldn't be having this interaction with clients. If you're a freelancer and you ARE the one to interact with clients, you've got to be able to switch hats. I agree completely that Project Manager is a critical role. - If you get into this situation with a client, *shame on you*. They've never built software before, and they came to you because you're supposed to be an expert, and if you've failed to provide sufficient guidance through the process, then that's your problem, not theirs. You're free to choose not to maintain and support your clients if you want, but putting the failure on them ensures that you don't address the process/system problems *in your own house*, making it very likely the next client will be another one of those disgusting folk. And the next one and the next one, until you bag it all and go into the shrimp business.
While I totally agree this is the ideal way to do it, often clients don't have the budget for this entire process. They may have a $30K budget and they need a $30K website, so spending $4K on documentation means that they're losing functionality they need to get documentation that they honestly don't. Also, you very often need to go through some form of this process to give an estimate, and companies are reluctant to pay for this type of analysis before they've decided to go with your company which they can't decide without an estimate. In those cases with smaller projects, I'll often use an abridged version of this process which is basically just the Functional Spec. The Use Cases are captured by the functionality and the technical is left to the developers to determine. It's not ideal, but you have to adjust to the client.
One phrase that is included in every contract: "Anything not explicitly specified in this document is not included in this estimate." 
How about the way I suggested in this post: http://phpixie.com/blog/naming-libraries-properly/ People actually argued that additional namespace wouldn't be good =(
You really kill code portability as soon as you start using Facades. My general rule is it's "okay" to use facades in areas where you're tightly bound to the Framework. I think of this as routing, controllers, and cli commands. But you're better to be consistent and never use them.
Well, that's where "qualify the client" comes in. You've got to understand their appetite to spend before you can make any sort of sensible plan for servicing the account. Sometimes you've got to do "enough" analysis, or roll the analysis into a number for the whole project. In our business, $30k would be quite a small project indeed. So it's certainly the case that the higher the risk of the project (both financially, but also in terms of the risk to the client--or to the client sponsor personally--if it fails), the more formality is required in the analysis. But I can hear a thousand $30k projects getting permission to code first and think later, as I say that...
&gt; They purchase an amount of my time, upfront, and I spend that time working on their project. If the project isn't completed in that time, they buy more of my time. That's really great, and works well in the freelance world (in fact, it's basically what I did back when I was freelancing). It's very unlikely to be a workable approach in the agency world. As you climb up the food chain of corporate clients, unpredictability in budget and timeframe increasingly becomes a problem for them. Lots of companies won't sign on for work without a fixed bid proposal for the whole project.
What is "pragmatic" depends on what you want to practice.
Nothing about agile says potentially infinite money and time. I've been part of it used succesfuly on multiple projects. Having sprints with deliverables and review at each one is a much better way of having an *ongoing* conversation about features vs delivery schedule vs time/money/hours. You want X? OK, that will push back Y or we need to cut Z until phase 2 (which has a new budget). Waterfall just sets you up to fail, you waste a bunch of time creating a spec and then having an adversarial conversation weeks later when circumstances change.
It's not that you are using Wordpress or Drupal that is incurring cost overruns. If you've picked one or the other AND your incurring technical debt, you (or more likely sales) picked the wrong tool for the job. Yes, both come with their own opinions and assumption about how to do certain things. This will give you a lot for free but you will end up fighting against them to do things *exactly* how some crazy client request wants it. With them (or any solution really), you're going to have better outcomes if you line up client expectations to work WITH the CMS or Framework instead of against it. This mean not letting the client specify the implementation exactly, they should be specifying the business outcomes and end results. If its a very complicate/ambitious project, then you should look at a framework, either full featured or a micro-framework, that gives you room to do everything exactly how you want but may mean building a lot more yourself.
True of course, but doing that makes it tricky to take advantage of `autoload-dev` in Composer, meaning you're polluting your production autoloader with tests, stubs, etc.
Correct, which is why Symfony HEAVILY suggests not using the container as much as possible, and instead, using dependency injection.
Composer allows you to autoload based on the dev environment too, for things like tests. CHeck out how i did it in [bldr](https://github.com/bldr-io/bldr/blob/master/composer.json#L50)
I would tend to disagree. When you have a budget of 30k and you do not spend the time and money on getting exactly what you want and expect from the process hammered out, you will easily spend more than 4k worth of time in doing revisions and changes. Many projects I have been on have spent as much time on specifications, UX and design as they do on development. 
I consider those folks to be Site builders, not Developers.
There is at least one reasonable solution I have come across. And that is as follows: When a user attempts to sign up, you can validate all of the information that they supply in order to create an account. All except for the existence of the provided email. Assuming no errors are found in the application, then account creation can occur, at which point the email is validated. Here 1 of 2 things can happen: * 1: The email is in use; send the registered user an email informing them that someone attempted to sign up with their email address, including a link to reset the password in the event they are trying to sign up after forgetting they have previously registered. Inform the user on the app/site that an email has been sent and to check their inbox. * 2: The email address is not in use; create the account and send the normal activation email. Inform the user on the app/site that an email has been sent and to check their inbox. End result is the same. User receives an email regarding the registration. Genuine sign-ups get an account, non-genuine ones have no idea that the email address is in use.
&gt;Clients no longer pay me for results, they pay for my time, and that's it. The problem with this attitude is that how they perceive you will generate a reputation - and if they feel your work isn't in line with what they want that reputation could come back to bite you in the ass when looking for other work. You need to be able to say "with approximately this amount of time, and this amount of money, I can produce this result". This is how real contract jobs where the goal is to produce a product work in the real world. This is why I agree with [ratbastid's method](http://www.reddit.com/r/PHP/comments/2k7iim/agency_devs_freelancers_what_is_your_discovery/clio7hc) **strongly** - because that process is more likely to produce a result that is more in line with the client's expectations. His method is what real professionals do. Never do shit by the seat of your pants, always have a real plan that the client is fully aware of.
Why do you have to say things like that? And who the hell is upvoting this?
I break down projects into 4 task areas because that correlates with the teams that we have to do the work. * Project Acquisition/Management (Sales cycle, documentation, meetings, customer review, etc) * Design/UX (graphic design, layouts) * Implementation (Converting Designs to HTML/CSS, front-end work) * Development (Architecture/Database/Coding) So.. when I throw out that $4k number, I'm talking about just the first item on that list. Phone Calls, meetings, document writing, reviews, training.. all of that customer interaction stuff that certainly has a value, but does not actually contribute directly to the project being built. If you group Design/UX with that, I would totally agree with you. I consider that to be part of the actual creation of the site rather than the documentation.
I rarely ever think of individual classes as more than components in a system anymore, but there is one I've written in php that stands out for usefulness over the years. This was in 2007 when I rewrote an entire travel system with two others. We did a lot of research trying to figure out the best way to do stuff, and frameworks weren't prevalent back then. Neither Zend nor Symfony were mature enough for example and there wasn't jQuery to leverage. We did everything wrong, really wrong, but it somehow worked in the end. After the initial development, I was tasked with integrating Bill Me Later payment support. This was before BML implemented any sort of API and before they were bought by PayPal so I had to write my own processing system that uploaded files for batch processing to a bank under their account. This also meant that I had to fully implement their entire validation logic on our end and the validation document was 50+ pages of rules and exceptions. The only sensible way of doing so was via regular expressions, and since I was the only one who properly knew how to use them, I worried about doing a huge cryptic regex mess that nobody else could understand. I tried to break out every single component and explain everything going on because it was far from trivial. I eventually decided to build each rule in pieces and later combine them to form the proper regex. For instance, invalid phone number prefixes would be in an array that I imploded with a pipe: // Invalid phone prefixes: ###-xxx-xxxx $invalidPrefixes = array( '555', '800', '88[0-9]', // 880-889 ); $invalidPrefixPattern = "(?:" . implode("|", $invalidPrefixes) . ")"; I was on the phone going back and forth with BML and their bank for months trying to get everything properly integrated, but I eventually left the company before my payment processing system went live. The person who inherited the project was a designer, not a programmer so when I heard about it weeks later I immediately felt horrible and reached out to him offering help. His reply is the reason this sticks with me today, "Thanks, but I didn't need any help getting it approved since you did everything in a way that even I could understand it. It really was easy using what you wrote." I'd be lying if I said that didn't make me feel a little proud. Because we wrote everything the wrong way, nearly everything was eventually rewritten over the years. Last I heard, my validation stuff was still in use mostly unmodified because it didn't need redoing. If anything needed to be changed, they'd make the few minor changes in the file and were done. The best part though happened years later when I'm having drinks with one of the guys I wrote the whole system with that was still there. Out of the blue, "You know that validation thing you wrote and left unfinished? It was more useful than you probably know. We have roughly 40 or so programmers now and we get a lot of cowboys and egos coming in trying to overrule everybody thinking they're senior-level when they're juniors. Sometimes, they actually do know what they're talking about, but most of the time they don't know what they don't know. I've taken a few of them and sat them down, pulled up that file you wrote and asked if they could write something like that. They would just sit there dumbfounded. I'd tell them that until they could write something like that, they need to shut up because the author was one of the guys who wrote the initial system we're working on today." We laughed so hard at that because we both knew we didn't know what we were doing back then which is why we did everything wrong. That one validation class has instilled an understanding more useful in me than any book could, and that's actual experience in seeing how something you see as trivial can have a huge impact. I thought I was turning over that system to a programmer that didn't understand regular expressions so I wanted it as clear as possible. I wouldn't have fathomed it would be turned over to a designer. You never know who will take over your project or work in the future. It could be someone qualified, or it could be someone who completely doesn't understand; it could also be your future self cursing you. Just make sure that whatever you do, it's clean, legible, and can be understood. Don't get overly clever with your work.
Work is underway to support 5.2. It won't be enabled by default but should be pretty easy to work with. [github](https://github.com/Vectorface/dunit/commit/33f740d8a2587edcd363e5f3a0d782ea06a90646)
I'd still be worried even if it was a generated password, especially if they don't provide any kind of expiration information with it. I would hope they wouldn't leave it open indefinitely...imagine if an attacker knew that the generated passwords only used A-Za-z0-9. That significantly reduces the bar for them to try to guess the password correctly and if it never expires, all the time in the world once they hit that password reset form themselves. protip: don't forget to make generated passwords strong too.
There's one tip that he left off of his list imho - make the most secure way the easiest way. This is where the balance gets the most tricky. When developers implement security measures, it's easy to think that the simplest way should be the one with the least amount of security. It's simpler for the users if they don't have to jump through a lot of hoops, right? Unfortunately, security shouldn't be degraded just to be nice to users. UX isn't about "being nice" after all. It's about providing a good experience, including making the security part of the normal workflow of the user, not a bolted on, separate piece.
people who prefer symfony over laravel, I'd guess.
Yeah, I'm not sure how they get those "hours to fix" metrics from...they're always way to high. It'll show a few hours for something even as simple as a syntax change or removing commented code. I'm more of a fan of how other services ([Scrutinizer](https://scrutinizer-ci.com), [Codacy](https://www.codacy.com) and [CodeClimate](http://codeclimate.com) give you a "grade" on how good the code is and mark the problems with levels under that. I could see providing some of the time-based metrics based on the commit history vs time the issue was resolved, but even that is pretty subjective...
Well, I prefer symfony over laravel but this is bringing absolutely nothing to the discussion yet is the most upvoted comment. Sometimes its just depressing.
&gt; By the way, this WHOLE analysis phase is billable. And the deliverables they get out of have a TON of value This is likely our problem. Our analysis is not a separate billable phase / deliverable. We have a separate, totally inadequate analysis phase that simply exists to give the client a quote, without really getting a chance to fully vet the requirements (so naturally budgets are often, but not always, too small to begin with). So then our proper technical discovery phase is now competing with the time/budget to actually build the thing... robbing Peter to pay Paul. I am not part of the sales team, I'm just a lowly developer that takes what management gives me, but my concern is sales might have a hard time finding clients willing to pay for a thorough technical discovery before we even give them a quote to build the project :/
Id be very surprised to hear of a website use case that you couldn't use Drupal for. In those cases it's really not a shortcut, you are simply not using it correctly. Drupal is far more of a framework than a cms. That's not to say it's not a complete bastard, but managing your clients appears to be your problem, not the complexity of their requirements.
Don't get depressed over a comment on the internet/reddit.
I used Composer. I'll try again in a few days to see if things are working now!
Framework master race. I use yii personally. Make it rain down votes! 
No, that's to be expected. The code is rendered as an unprivileged user, so it shouldn't be able to read /etc/shadow
Ahh! So this is because the linting is actually done in JS by the AceJS editor, which I guess doesn't yet support the newer PHP features. I might have to disable that for now. Thanks!
Ok I'm going to sound like a total noob, but why do you need to add the tests location to composer or to add them at runtime via the addPsr4 function? I never did this and never had the need to. My phpunit.xml file autoloads vendor/autoload.php from composer when I run the phpunit command, and that is all that seems to be needed for it to work. I have never had a problem.
It really depends. Sometimes you have clients who physically have to navigate a website in order to determine that it's what they want. Thankfully these days it's really easy to generate an html prototype, and it's starting become common for designers to make an html prototype (using tools, not actually coding) that the client can navigate and play with. 
PHPUnit will locate files that end with `Test.php` by default and includes them. You'd only need autoloading if you have base classes or other utilities as part of your test package.
Don't tell that to the facade haters. Laravel is purely a facade. Nothing more nothing less. Facades of facades of proxies of facades of service locators of facades of surrogates. 
That's what we were using at Piwik until yesterday: you can replace that with: { "autoload": { "psr-4": {"Chrisguitarguy\\Whatever\\": "src/"} }, "autoload-dev": { "psr-4": {"Chrisguitarguy\\Whatever\\Tests\\": "tests/"} } } Much simpler.
Ya know, most people talk about this issue with facades as being tightly bound to the framework, etc.. But like, am I the only one who plans their development around what is needed, and not spend extra time extracting and making all these repositories to separate my app from caring where the data is from, separating my controllers and all this extra fluff complication shit, and chooses a framework, a database, database structure, and all that before development, so 3 months into the development I'm not like "Ya know what? Laravel was a bad choice. I should have used Symfony." and have to move stuff? Sure in theory the idea of extracting things out so you're not dependent of the framework is great, but in seriousness, it's an extra layer of complexity that isn't needed if you just plan your project accordingly.
Don't listen to people. PSR-0/4 recommends using "Vendor\Package\" as namespace root. Every other framework does that.
its not this subreddit. Reddit in general is comprised of comments that bring nothing to the conversation, and get upvoted to hell. Nothing to get depressed over.
Before you do discovery do a statement of work. This is incredibly important. In the discovery SOW you need to describe what you're going to be doing and why. The reason this is important is that your client can use the fact he/she paid for discovery as an insurance policy against you later on. I've had this happen a few months ago where the client didn't hit a ridiculous KPI they set internally and said the discovery phase should have ensured they met their target. Sometimes clients don't pay for discovery but instead the agency picks up the tab as failure would be costly for us for other business reasons. I harp on to clients about the importance of failing quickly. If we can remove the unknowns and larger risks from the project at the very beginning, the project will be much cheaper if it fails and a better quality if it doesn't. Sometimes our discovery process is our UX team and account managers meeting client stakeholders to discuss the challenges of the project. Other times it's the development team putting together a prototype to show that the technology is or isn't viable. It depends on the type of project, the risks identified by the agency and the concerns of the client. Discovery is a really important process. You mitigate risk and get a better focus on what the final deliverable should be. Good luck convincing your coworkers. 
You need to remove the text from the presentation layer. An abstraction most are not used to. You don't mix your text in with the HTML, that way you only have 1 html file. You can use variables, tags, or some other method to place the text in the html. Using gettext is probably the most standard way of doing it.
We keep tests in the same namespace as the code they test (but in "tests" instead of "src"). When you start doing this, you can remove loads of "use" statements all through your tests. It also means that any remaining use statements are for classes in a different namespace, clearly showing dependencies that may not be expected (and may hint to something needing a refactor).
I do something like this, but I keep it simpler. * phase one: define what the product needs to do (time and materials) * phase two: develop the product (a fixed bid is provided at the end of phase one for this phase) * phase three: ongoing support / and upgrades (time and materials) Most of the time, stuff gets nasty in phase two because we skimped during phase one. 
Can you quote a specific passage that recommends that? I looked through both and it doesn't seem so. In fact they have Zend\Acl class in the examples section
Erm this is the first line in PSR-0: http://www.php-fig.org/psr/psr-0/
Well, and you're fighting a culture of jumping at every opportunity that seems to come up. Turning away some work this year was sort of an epiphany for my company.
Not sure why you need Supervisor here - since HHVM is the only process running inside the container?
Where do I learn to get these 6 figure projects? I must be doing something wrong...
Your sales team brings them in for you. I doubt you'll find many (any?) solo developers who land big projects like that on their own (and can also deliver them to success while managing the client).
I agree so much. Bombs away where Facades are concerned into your controllers, just try not to let them creep into your domain. If they do, punish yourself and mark that use statement with a "TO-DO: Stop being lazy".
I don't have a preference, but I enjoyed the wise crack so I upvoted. I do not understand how this comment caused a fuss. Similar wise cracks happen IRL every day with colleagues when discussing the merits of various things.
Very important to stress this. Otherwise project will have endless scope creep. There will be many things naive clients will realize they cannot do without, but not until the projects starts to shape up, way after the estimate. This is when you say - this feature was not in requirements and will cost this much and take this long in addition to the estimate.
&gt; How do you lock down slippery requirements and protect yourself from flaky / incompetent clients? This is really hard when you're dealing with "whole projects" as one single unit. I started out being employed in a web agency, and we had this problem all the time. Every project had a massive spec, with some distant launch date that was pretty much just a guess. Every project ran late, the specs always changed, and people often worked weekends trying to get shit done on time. I'm now a freelancer who works directly for my clients (not through an agency), so I manage and perform the whole spec/quote/build process. Life is much better. Here's how I manage this without having to simply charge per hour... Any website over $5000 is broken up into "components". I specifically quote for each component along the way. The quote is just an email with any details I can put into writing. Fucking around with Word documents is a waste of time. I also include in the component quote what it **doesn't include**, just to make things clear... for example a recent project I did had single purchases using PayPal. I specified in the component spec email that there was no "cart" functionality to buy multiple items at once, because they didn't need it. If they change their mind, great, I'll quote another component for the cart. Each Component is numbered and has a name. On a large project, generally the first components would simply be: **Component #1: General website layout (header and footer), homepage + contact page** **Component #2: Users can create accounts, login and reset passwords** Breaking up jobs like this is good for both of us, I get paid along the way, rather than at the end of a large project. The client gets to see clear see progress and test it. And there's no huge evolving monolithic spec or launch date to worry about. Also, because the client is signing components off along the way, it's more obvious to them that changing things is halting any progress on other future components. So they're keen to sign off and let you continue to the next part. So if there is an estimated final launch date, is at least both of our responsibility, not just mine. I don't start working on the next component before the client has signed off the last. Generally I'll quote for up to about five components at once. If the client wants something changed in a component that will affect others, I can re-quote the current or future components. I also put a small contract in place at the start which covers general terms, including the whole "component" process. There's no pricing in the contract, it's mostly to make the point that once we agree to a component spec and they've told me to begin, that the client has to pay me for it, unless we agree to change the spec/quote for the component.
I totally see where you're coming from. And I've often wondered if I'm wasting my time with building out these abstraction layers. This is especially true with database abstractions, I'm not changing my database from mysql to postgres, I don't need the abstraction. But with the repository there are some definite benefits. **Code simplification through a unified access point** In the following example, I'm creating an blog author's profile page which will show a paginated list of their latest public published posts. function profile(User $author) { $posts = Post::where('author_id', $author-&gt;id)-&gt;where('is_public', '=', 1)-&gt;orderBy('date_published', 'desc')-&gt;paginate(); return View::make('user.profile', compact('posts', 'author')); } The look up conditions here are some what complex and it is not immediately obvious which posts were looking up. If we want to add this same list of posts in the sidebar of every post written by this author, we'd most likely copy and paste this code into the revelant controller. With a repository you would place all this code in a function, maybe called `findAuthorsPublishedPosts($authorId)`. This will immediately make it obvious what posts are being returned. It will remove the copy paste code. And we've hidden the complexity of our ORM. **Read Through Repositories** You can easily create a read through cache layer when all your code has 1 single access point. If you want to add a caching layer to your look in your controller, you can easily do something like this: function profile(User $author) { $posts = Cache::get("posts.author.{$author-&gt;id}.published"); if (!$posts) { $posts = Post::where('author_id', $author-&gt;id)-&gt;where('is_public', '=', 1)-&gt;orderBy('date_published', 'desc')-&gt;paginate(); Cache::set("posts.author.{$author-&gt;id}.published", $posts); } return View::make('user.profile', compact('posts', 'author')); } We've added more complexity to our controller. The amount of code that we're copying and pasting between different usages of this segment has grown in size. With a repository, we can create another repository, a cache repository that would handle only the cache reads and writes, but would use the ORM repository to manage the reads to the persistent store. class PostCacheRepository implements PostRepositoryInterface { public function __construct(PostEloquentRepository $eloquent, Cache $cache); // assume these are assigned public function findAuthorsPublishedPosts($authorId) { $posts = Cache::get("posts.author.{$author-&gt;id}.published"); if ($posts) return $posts; $posts = $this-&gt;eloquent-&gt;findAuthorsPublishedPosts($authorId); Cache::set("posts.author.{$author-&gt;id}.published", $posts); return $posts } } We've added no extra complexity to our controllers nor to our ORM repository. We won't have to update both the profile page and the blog post page to use the cache mechanism, since all reads go through the same function. This is helpful when a new programmer is assigned the feature to add the caching. This developer may not realize all the places that we had used the spaghetti code. In Laravel, you'd probably have a service provider that looked something like this: App::bind(PostRepositoryInterface::class, function() { return new PostEloquentRepository(new Post); }); We'd need to update the PostRepositoryInterface to be bound to the new Cacheing repository. App::bind(PostRepositoryInterface::class, function() { return new PostCacheRepository(new PostEloquentRepository(new Post), Cache::getInstance()); }); Now we can easily turn off and on the cache layer, this might be helpful in some instances. **Easier to Test** For awhile, everybody has said don't test controllers or you can't unit test controllers. Look again our two possible controllers, one of them seems fairly easy to unit test: function profile(User $author) { $posts = Post::where('author_id', $author-&gt;id)-&gt;where('is_public', '=', 1)-&gt;orderBy('date_published', 'desc')-&gt;paginate(); return View::make('user.profile', compact('posts', 'author')); } function profile(User $author) { $posts = $this-&gt;userRepository-&gt;findAuthorsPublishedPosts($author-&gt;getId()); return $this-&gt;view-&gt;make('user.profile', compact('posts', 'author')); } The second example appears to me to be extremely easy to test, two mock objects. By using repository, with no intention of swapping out our persistent store, we've improved code maintainablilty, improved code readability, greatest increased the ease of testing our application. 
One more thing to tag on, there are business needs that can not be for seen even with careful planning. I was part of a ground up rewrite of a site, we had used one email provider to send out all transactional emails from the site. Our investors backed another email provider. We were told to switch email providers, if we had built out better abstraction this change would have been easy. It took me ages to switch out the providers. The point of the story is even with careful planning, you can't predict how your business will need to adapt.
laravel.io - https://github.com/LaravelIO/laravel.io
Aura already have a spl_autoload by default on every package. So in the bootstrap it just requires it, and the rest are taken care by composer itself. See https://github.com/auraphp/Aura.Web_Kernel/blob/develop-2/autoload.php https://github.com/auraphp/Aura.Web_Kernel/blob/develop-2/tests/kernel/bootstrap.php and is using the same namespace across tests.
https://github.com/tastejs/todomvc/tree/master/examples/angularjs **EDIT** why the fuck was this down voted?! lol. This was exactly what OP asked for, it's an example angular application.
&gt; Drupal is far more of a framework But in what way is it a better, easier framework to work with than Laravel or Symfony (or even Yii or Cake)? The route/action/domain/response structure of Laravel and Symfony makes it absurdly easy to build *exactly* what you want with *exactly* as much or as little abstraction as the scope of the project requires/allows. I feel like that's always going to be faster than fighting a jungle of abstraction, assumptions, and ancient architecture patterns.
Yes, this is correct. I meant to imply that Wordpress/Drupal is not the right fit for the majority of the work we do. There's a misconception that custom code is expensive and that the kind of basic user authentication &amp; CMS capability you find in Wordpress is difficult or time consuming to do in a modern framework. At the end of the day, it really isn't that difficult, especially if you use create and re-use your own packages/bundles to get you started on each new project. Then you gain 100% freedom to implement the other, more complex business rules the client needs.
&gt; You should also be learning that tool inside and out to be able to take full advantage of it. I've found that learning the tool inside out is moving goal post. "Oh, you need read-only syncing from your horribly structured Salesforce 'database', read/write syncing of only certain data from Netsuite, multi-store inventory management syncing between your Amazon and Ebay store fronts, and Hubspot syncing for marketing?" I don't give a shit how well you know Drupal, you don't know it well enough that you won't waste a hundred hours just looking for and testing various plugins/extensions that claim to be able to do complex stuff like that, only to find out they don't quite work or that the client forgot one wee little detail that sends that house of cards falling down around you. It's easier, faster, and less fragile to work directly with the APIs of those services and work directly with your own database. Each client has a unique combination of complex shit they want you to do, which means you can't just know Drupal/Wordpress, you have to know its extension/plugin landscape too. And if you're not leveraging extensions/plugins, what are you even using Drupal/Wordpress for in the first place? It's a noisy rat race that I think is far more trouble than it's worth.
Seriously chief? The facades are just proxies. Any method you call via the facade you can also call via an instance of the represented object - the facade just does static forwarding. It's literally no different than the way the official PHP documentation uses static accessors to keep the API terse: * http://php.net/manual/en/book.pdo.php * http://php.net/manual/en/book.datetime.php * http://php.net/manual/en/book.reflection.php And yes, the facade mappings are documented, so that's not an excuse: http://laravel.com/docs/4.2/facades#facade-class-reference
(&lt;Namespace&gt;\)* is 0 or more not 1 or more
His argument about the DB alias stands though - it is a bit of a barrier to entry. But any laravel package that includes Facades and doesn't put a @see tag in their doc block should take a step back and think about developers 
Hmm OK. So a standard utf8 encoded string should do the job? I'm having trouble with the web service accepting my encoded post field. 
You should really learn about character sets and UTF-8. It's one of the things absolutely every programmer should know. * http://en.wikipedia.org/wiki/Unicode * http://en.wikipedia.org/wiki/UTF-8 * http://www.phptherightway.com/#php_and_utf8
I put tests in the same namespace as (but different directory to) the class being tested, suffixed with "Test". That way PHPUnit can automatically determine which classes your tests cover, obviating the need for `@covers` annotations at the class level. You just need enable the `mapTestClassNameToCoveredClassName` in your PHPUnit configuration file. Here's [an example](https://github.com/IcecaveStudios/archer/blob/develop/res/phpunit/phpunit.coverage.xml#L6).
Now I get it. You should learn to use [pack](http://php.net/pack) and [unpack](http://php.net/unpack). For example, to get a byte array from a utf-8 encoded string: $byteArray = unpack('C*', 'Fußball'); var_dump($byteArray);
I think there are some over here https://github.com/chiraggude/awesome-laravel
I don't think you get his point. The Laravel documentation shows all examples using the facades and not the classes they map to. Of course you can look at which facade maps to which class and then "translate" the docs, so that Input::get() becomes ... Path.to.input.class-&gt;get() but this is extra work and does kind of make the docs pointless because you can just look at the API. 
People complained here that in that case tests show up in IDE completion =\
You can using references. 
That doesn't keep the parent scope alive. It's similar, but it's not the same thing.
I didn't say it was better or easier than those, it clearly depends on your requirements. These are all tools. Drupal is a very powerful one if you leverage it right. It's a steep learning curve, so I can understand your last sentence, but Drupal 7 made huge leaps from Drupal 6, and Drupal 8 looks to be even more impressive (and includes Symfony). So I wouldn't just dismiss it out of hand quite so quickly. Again, your issue is managing your clients, not the tools at your disposal.
Well PHP's closures don't close over a scope. They close over explicitly defined variables. It's by design like that. But yeah, I guess my response was poorly worded. 
They don't close over the variables, though, they copy their values. :/
I'm sure this will get down voted here but, actual experienced developers would choose options other than PHP frameworks, especially for backend applications.
Every time i start a new Laravel project something in the back of my head is screaming "You should be using Spring!". 
Experienced devs will know other languages, but we keep choosing PHP because there is a large pool of developers. This means there are usually several devs available for contract hire if you fall behind on a project or need to have someone else take over a rewrite. Even as an experienced dev I still choose Laravel for most projects. Many of the common problems have already been solved, so there is an expansive array of libraries and articles to help do common tasks in an efficient manner (time efficient). As for why you see older devs using Symphony is that they are most likely building their own framework of packages using composer. Their end result is usually something similar to Laravel with only the parts they need.
Spring is nice. So, is Play framework. I really want to check out using Clojure.
When presenting clients with technical documents to sign off on they usually shrug their shoulders and say I have no idea what a database spec means. So I find that largely problematic and keep the technical specs to myself.
I use Silex for most large professional projects. I use Laravel a lot for personal stuff because it lets you build so damn fast. I don't know that it's a matter of experienced vs. beginner, other than the fact that Symfony has a much higher learning curve. It's more about choosing the tool that lets you get your work done.
"Actual experienced developers" know that choice of language or framework is one of the most trivially irrelevant choices you'll ever make.
Frameworks I can agree with but hell no for languages. Some languages are better suited for certain tasks than others.
I worked at a company that had to support something like seven different languages. Use option 3. In your template, use a tag like {{GLOBAL_WELCOME_TEXT}}. In the controller, load whatever relevant language file, which should have a big array of replacement values, one of which is ['GLOBAL_WELCOME_MESSAGE' =&gt; 'Hello world'] (for english obviously).
No, there is no best language for a certain task. "Actual experienced developers" know that there are many variables to consider when choosing tools other than just the task at hand. Team size, skill-level, familiarity, time constraints, hardware constraints, software constraints, and a million other things can make one language the best tool for the job under one certain combination of factors, while one of the worst tools for the same job under an entirely different combination of factors.
&gt; No, there is no best language for a certain task. Lets see you write software for an embedded system using php. Could you make a 3d first person shooter using Haskell? Hint: Carmack is having a hard time doing that. How about making a web framework in ASM? Build a binary reverse engineering malware analysis tool using prolog.
Suggest you re-read the post, as you've obviously missed the point.
Because experienced developers have been around longer, like Symfony. Laravel is very new to the scene and the growing developers aren't always wedded to a framework yet. They have more freedom to try out other options in detail.
You contradicted yourself. &gt; No, there is no best language for a certain task. # &gt; and a million other things can make one language the best tool for the job under one certain combination of factors What is a task other than a combination of factors which decides which programming language is the best to use?
I'm one of the rare developers that uses ZF, both 1 and 2. I love symfony as a library, not a framework. I honestly don't like a lot of the mvc frameworks these days. They're so damn worried about being uncoupled that they've lost sight of what makes a framework actually useful, which is very quick development with reusable tools. With ZF1, I can literally add a public method to a controller, add a view file, and I'm done. No routing, not worried of layout definitions, the action is completely unaware of the view (it's just part of the framework to load the view with the same naming scheme as the action), I have an easy way to plug in "plugins" that allow me to do stuff before and after a request and it it's not fumbling around with a shitload of config files and other bullshit, I add a method to the bootstrap. Don't approach frameworks as what is the coolest, hippest, newest framework or what's the most popular. It's like a musical instrument. You gotta go to the damn store and strum it before you whip out the wallet. You can have different opinions like I do, but still be a very effective developer. /e $.02
&gt; You contradicted yourself. No, you just misunderstood the semantics of my post. &gt; What is a task other than a combination of factors which decides which programming language is the best to use? "We have a team of 10 developers" is not part of the task "build a basic blog application for the company." It is *related*, in that the process of doing that task is going to require us to make some decisions based on our team size and other factors, but it's not part of the task itself. This is easily demonstrated by simply changing the team size and noting that the task - "build a basic blog application for the company" - does not change.
Thanks for the feedback, it's appreciated. What's different with Laravel is the multiple levels of indirection involved. With Symfony you have a service identifier linked to an implementation class. One level of indirection, pretty easy to keep in your head. With Laravel you have a class alias hooked up to a an actual class (the facade). The alias defines a service identifier. The service identifier is then linked to an implementation class. That's two levels of indirection, and one more thing to keep track of in your head. 