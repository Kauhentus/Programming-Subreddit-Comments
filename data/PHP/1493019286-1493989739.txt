Would be better suited for [PHPhelp](https://www.reddit.com/r/PHPhelp/) as it's clearly a beginner tutorial. Also, why do you need a MySQL Database for that tutorial? Well, maybe he copy&amp;pasted his introduction. As for beginners I guess it's okay? The author should have added some indention and comments, but then you wouldn't watch his video...
That'd work out pretty well IMO. I'd imagine Jeffrey would open up Laravel to more of a committee / group of main contributors. Imagine if you had the likes of Spatie on board as well, there's some extremely talented Laravel contributors out there that would step up. 
An iPhone app making a post call to an API endpoint isn't that different from the chrome browser submitting a HTML form. We use Symfony forms for all our JSON API's. If you use FOSRest the JSON data you submit to your API is automatically translated so you can just do the same old $form-&gt;handleRequest($request); It wouldn't even be that hard to read a file and use the Form component to validate and process data from a file. It's not the perfect solution but you don't seem to have enough understanding of the form component to have a meaningful opinion.
Are you a bus driver by any chance?
I have a breathable (almost uncleanable) fabric on my chair. I also have a memory foam cushion covered in the same breathable mesh. Downside, I don't eat in my desk chair... or take part in any other potentially messy activities. The leather sounds like a bad idea. I'm conjuring images of sweaty, smelly swamp a**. Thanks a lot you jerk. Disgusting.
Firstly, Thanks! I'm thinking about phpmd.xml, but I'm not sure about magic strings, because it would really pollute code analysis output. On the other hand as you suggested to search just from provided list maybe is not bad idea :)
See [benevolent dictators](https://en.wikipedia.org/wiki/Benevolent_dictator_for_life). Won't happen anyway.
Spam Reddit.
It would improve.
My be not for you. Buy it is easy way or do you have any other idea share with us
[This Stack Overflow](http://stackoverflow.com/questions/21445245/simple-php-calculator/30866609#30866609) answer is good as it separates concerns.
Minor point, I wouldn't call Drupal composer friendly yet. It's improving, oh God it is, but many Drupal PaaS , and contrib modules have their issues. 
Not getting leather/non-fabric chair again. Not someone who sweats a lot, but even after about 20 minutes of sitting if feels nasty when your whole back is wet.
This makes me so happy. Thank you!
&gt; Chronos, for DateTime stuff. Personally I prefer the carbon library for DateTime stuff
As I am using the Phalcon formbuilder in my current project I am highly interested in your answer. Would you mind sharing your classes for reguarly stuff? I'd really like to see in which direction you use them. One more question regarding validation, how do you handle input arrays? 
Great idea, although I do not have acess to the original repo, but I will still create the organization.
I have no idea of the use case for this, seems a strange thing to want to do (are you sure you don't just want bitmasks?), but anyway you probably want: * Tests * Put it in a namespace * Use "its" instead of "it's" in quite a few places
There has been some discussion around this. Frank de Jonge, the creator / maintainer of Flysystem was ok with creating a new adapter outside of the league organisation. See: https://github.com/thephpleague/flysystem/pull/777#issuecomment-295259423 
People seem to really love this guy 
I've attempted to install, setup and use xdebug several times in the past 5 years and I've never been able to do it properly. Kint just works. 
I have leather dxracer chair and its super comfy, doesnt get wet or sweaty and cleaning it is super easy. I sit in it in office as well as when i come home and it's perfect for my back, i'Ve had a lot of back problems previously, on peasant chairs. Link: https://www.dx-racer.cz/dxracer/serie-d/3858-zidle-dxracer-oh-df73-nc.htm
Sure, but you can ask the owners to transfer it to the org, unless it is not possible for you to contact them (or if they refuse). 
I think this comment might be more because Taylor is 7-foot-12. As a bus, I'd feel existential dread if faced with the prospect of driving into the man...
This will not be possible, because we follow different paths
Anyone can contribute to the framework already.
My preferred stack can basically be seen in my [mvc-example](https://github.com/shadowhand/mvc-example). This doesn't use middleware. If I did use middleware it would be with [equip/dispatch](https://packagist.org/equip/dispatch) and middleware from the [middlewares project](https://packagist.org/packages/middlewares). Other things: - Preferred query builder is [latitude](https://packagist.org/packages/latitude/latitude). - For validation I think [assert](https://packagist.org/packages/beberlei/assert) is a fantastic option. - Anything related to dates is done with [chronos](https://packagist.org/packages/cakephp/chronos). - For command handling and queuing [tactician](https://packagist.org/packages/league/tactician) is fabulous.
Ah okay - that makes a lot of sense :) Thanks for the contribution to OSS.
Learn programming. 
You should name that committee the "Illuminate-y". Right? RIGHT? Showing myself out.
Jokes apart. After reading your reflection about your MicroConf experience made me wonder... As much as it could be impractical, how wonderful it would be that some _no name_ devs or small time entrepreneurs using Laravel to have a place in that secret channel? And as much as sometimes I feel like I'm not with you on some things you say or do (I mean not as hardcore as most people on reddit seems to be about you!) I would totally apply for that kind opening to that channel.
I invite people who regularly contribute.
It depends on too many variables really. I think PHP is awesome, as do millions of other software engineers. But not everyone likes it, and that's OK as well. Are you wanting to increase your chances of employment? If so, what languages are popular in your locality? Where I am in the UK, any of PHP/JS/Java/.net are good, but Ruby/Perl/Go less so. I have nothing against those "less popular" languages, but I would not be well advised to learn them if increased employability was my goal. If you are asking if PHP is worth learning in 2017 in general, then yes. The ecosystem is very healthy but it is not in flux like JS (no, not looking for a flame war folks - just an opinion!). The future looks bright for the core language. 
I don't think framework bashing leads us anywhere.
How is that any different than http://symfony.com/doc/current/components/var_dumper.html?
I'm certainly not hoping Taylor gets hit by a bus...... I very much appreciate the work he does, I just think Laravel could really excel with a better public face fronting the project. I say this because most of the negativity I see around Larval is (rightly or wrongly) aimed at the way the project is ran and the way its put across rather than the framework it's self. Either way it will always be my go to framework when ever I have to drop back to PHP.
Just a general tip for this type of furniture: Check your area for something like a 'business resources' store. One near me has a 'Discount Warehouse' which is just all the used furniture from offices that replaced it with new stuff. I picked up a SteelCase Leap with a small fabric tear, $200. Also got a 6ft. x 3ft metal SteelCase desk for $100. I need to go back and raid their multi-monitor mount stockpile come to think of it.
There's nothing wrong with learning PHP in 2017. PHP isn't going anywhere and it's a good language to have in your toolbox in my opinion. Why not learn something like Go as well? That would get you familiar with programming in a strongly-typed language, in addition to providing access to a language that can be used in conjunction with what you've already learned. Go, for example, a language with built in concurrency could be used to provide data and micro services for your JS and/or PHP applications.
The second hand ones seem to fall into my budget Â£400 (GBP), no chance of a new one at that price yet.... thanks for the advice 
Then follow your heart.
I jump between PHP and Python. I took a Python contract for a year and enjoyed it, and now I'm back on a PHP project. My advice for people just starting their career : * do a project in raw PHP, and try to follow the MVC pattern . By the end of the project, you should start seeing some patterns. * work on a little WordPress, then jump to MVC frameworks and try to avoid WordPress projects because you will get pigeon-holed into being a WordPress developer * learn a serious MVC framework, and also learn about payment gateways . If you're not moving money around, then it's probably not "business critical", and your income won't be as good as projects which are
Didn't know that I assumed it was meant in a more evil way.. 
I am thinking to start with Laravel, Any other framework you suggest ? 
Never said it mattered or otherwise. I'm just stating that, to my experience, such a group *could* benefit from"unusual" members with new point of views. Reverse is also true. Such a group could also be beneficial to a starting entrepreneur (to reuse my own exemple from earlier).
I mean to say I want a job for that PHP seems to be the most visible one in my region 
I will surely get into it as well once i master with one core language. 
Laravel is a good place to start . You may need to learn Symfony in order to get more serious gigs
You are so true with your words and experience. I had worked with wordpress before but I feel so many loop holes there. MVC framework seems a better option to work with. I really feel Learning programming is easy, But learning standards and the right way of programming is the difficult part. Because there are so many bad coding examples out there. 
That's awesome!
Some facts: * Funds collected will be escrowed with Jim Denaro, who previously collected funds for #isTouchIDHackedYet. * Funds will most likely be used to hire [Kudelski Security](https://research.kudelskisecurity.com/2017/01/16/when-constant-time-source-may-not-save-you/) (link goes to a blog post worth reading to get an idea of the talent they have access to) * Neither me nor my employer will ever see a dime of this money, it's all going to better the community Some speculation: * If sodium_compat passes the audit: * We can push to get WordPress to adopt Ed25519 signatures for their automatic update feature (currently: no code signing, so if you pop their update server, you get RCE on 27% of all websites for free) * Drupal is immediately interested in automatic updates (Ed25519 for auto-deploy, and X25519xsalsa20poly1305 for uploading SFTP credentials so Drupal's security team can deploy critical patches for some customers / use cases). * Joomla will likely ship with JCryptCipherSodium in 4.0 (and possibly 3.8?) * Magento can move off their [broken legacy crypto](http://www.openwall.com/lists/oss-security/2016/07/19/3) * ...and all of these projects will be able to interoperate, since they're using the same crypto * If sodium_compat fails the audit in a recoverable way, then the bugs will be fixed. (This is somewhat normal for audits.) * If sodium_compat fails the audit in an unrecoverable way, then we have solid proof that it's impossible to write secure cryptography code in PHP. (/r/netsec trolls and their FUD do not constitute solid proof) * This is the worst case scenario of an audit, but we still learn a lot about the long-term security implications of PHP's enormous market share and can have positive discussions about improving the state of affairs. No matter the outcome, as long as the audit is funded, OSS written in PHP will be more secure in the long-term. What's uncertain is if they will be secure in the short-term. The absolute worst outcome here is that nobody contributes (especially the large companies that make their money off PHP). So don't let that happen.
A lot of the negativity is just dickheads been dickheads, they find the tiniest 'flaw' (where flaw === 'doesn't do it the way I think it should be done') and then harp on about it. That's not to say there are not legitimate issues but not all of them are. 
Yeah this is wrong. We'd probably not hire you at our company if you strictly knew one language and only wanted to learn one. We've had multiple people come in that were just PHP devs for many years and we didn't hire them. Unless you just want to be at an agency your entire career, learn other languages and work in developing different types of systems. While it's true we wouldn't start a project in a specific language unless we had a "master" at it (Elixir would have been a great choice for our new websocket system, but we didn't have anyone that knew it well), most places you have to be quick on your feet and switch languages. Most people that work here (and this is the case in a lot of other places) didn't come in knowing PHP, Node, Python, Go, but now they are working with all these systems and are better developers for knowing all these languages.
All of the PSRs are about standardizing common tasks that frameworks might do so that we can make frameworks (and libraries for frameworks) work together nicely. PSR7 Specifically is about how to represent HTTP Requests, Responses, URIs, streams, etc.
No matter how long I speak English I will always mix up it's and its when I'm not deeply thinking what I type. Namespaces I'm meh about for functions like this, but it's probably a good idea. Tests I need to do. It's use case was basically a bitmask translation where you might be unable to do the bitmask logic (such as a framework rendering out a multi-select that needs to autoselect the masks in use).
ð
It depends on the project you plan to do / the companies you want to work for. JS server-side is pretty new, and fits well for real-time bi-directional stuff. PHP fits well for more classical server-to-client ones (even if RachetPHP and such allows bidirectional &amp; real time in PHP, but that totally not what the stack looks to be meant for). So I would say PHP is a must to know, but you don't have to master it (in other words: you must be able to read it and tweak it, but maybe not lead a full project from scratch/mastering all its frameworks) .
This is a terrible article in my opinion. It covers, in my opinion, less than the bare minimum. Developers working with MySQL need to know much more than this. I would expect to see at least multi-column indexes covered, if not covering indexes. I would also expect some discussion of the performance effects of (too many) indexes. I also have no idea why "for the ORM developer" is part of the title. I would expect anyone developing an ORM to have a much more thorough knowledge of indexes than this. For people interested in MySQL / SQL performance, see also: * https://use-the-index-luke.com/ * http://www.highperfmysql.com/
Just as recently as a month ago, acquia and pantheon don't support composer, you must create artifacts to deploy. Chosen library comes to mind as broken with composer as well. I'm not saying you can't but there are documented issues all around contrib a PaaS providers who have still not caught up. Like even just 2 months ago I believe composer.json was not required in contrib. The d.o packagist shim had too do it for the maintainers. It's a long shot from flawless imo.
PSR-7 is a set of Object Interfaces that make any "Page request" interoperable between frameworks. It defines a base set of objects/terms. Request Response UploadedFile Body Uri ..etc It allows you to write framework decoupled HTTP Actions/Controllers.
To put it into perspective, if you want a job its a good idea to be "an expert" for a language and show some experience with. Surely you should be open minded for other / new languages, but its probably way better to know one language in depth and a few others just on the surface, then a lot of languages only on the surface or a bit deeper. Having one language you are an expert in often means aswell, that you are easier able to understand basic principles e.g. OOP or a bit "deeper" MVC.
That might be the big difference between us :) We don't use any PaaS for our projects, we host projects ourselves on plain and simple VPS'es. 
I was a PHP dev for about 15 yrs. Built some awesome stuff with it, including a pretty large and profitable bespoke e-commerce platform. It worked great. For the last year, I've been building all of my backend stuff with Node, and I love it. Specifically, I use Koa for the HTTP middleware framework, Sequelize for ORM, Lodash for JS utility functions, and Postgres for DB (along with Redis and Elasticsearch). Using React/Redux on the frontend. I personally prefer staying in ES6 all day on both sides. I wouldn't derogate PHP after it was so good to me for so many years, but I definitely prefer full stack JS at this point. I think I'd miss too many ES6 goodies if I were to switch back. I just can't fathom having a valid reason to pick PHP on the backend for any new project at this point. :-/ Maybe I'm just too dumb to make the contextual switch all day long back and forth between languages / libraries. These days, you can really build anything you want in PHP, JS, Ruby, Python ... just pick whatever works best for your brain. The marginal differences between the options narrows every day that goes by.
It would probably starve from lack of new buzz words and marketing hype.
Because it's high quality content and worth the money, in my opinion. I will never stop recommending resources I find useful. If you don't want to use those resources for any reason - that's your choice. You can get something close to the same level of knowledge by reading through a variety of other sources, but the High Performance MySQL book, while it is starting to age a bit and is missing information on some of the features / changes in the latest releases, is an excellent read for anyone interested in the subject. I haven't found any other single source (other than perhaps reading the MySQL manual "cover to cover") that provides the same amount and depth of information. Unfortunately in the current world, (most) people cannot work for free. Some people choose to provide things for free - and that is their choice. Others need the money to pay for food, clothing, housing, etc. I provide and use open source software and documentation, but I also find enough value in many software packages and documentation resources that I will pay for them. This rewards the authors and enables / encourages them to provide updates or similar / related resources. If you are unable to pay for such things, there are often free alternatives - in the case of books, libraries are an excellent source. You may also find that your company will provide books (eg. as part of a training budget) (Personally I think every company that employs developers should have a "company library" of useful books their developers can read)
Thank you and I appreciate the honesty. In my second post I start going into indexes further and discuss ordering of indexes etc. At the bottom of this post i mention going on to covering types of indexes. I'm aware its a simple start, but from my experiences with other developers in my area they do not have the necessary SQL experience in general which prompted the post to start with. Only a few knew how or why they should even be adding indexes, and a very small subsection of them knew anything further. ( Explaining / profiling queries and what table scans / filesorts indicate for performance.) Now, this is just my experience. I might not be associating with the right groups of devellopers in my area? Im also aware norfolk isnt known for its intelligence nor being a bustling tech city which could also contribute to this.
It would certainly improve 
It's a standard for Requests/Responses. So if I write my controller in Zend 2 as follows public function get(ServerRequestInterface $request) { $resource = $request-&gt;getAttribute('resource'); $searchTerm = $request-&gt;getQueryParameters()['search_tearm']; $response = (new Response())-&gt;withStatus(200); $response-&gt;getBody()-&gt;write(json_encode(['matches' =&gt; []]); return $response; } This should work with Slim/Silex/Laravel/Symfony without any changes. Of course, ZF2 doesn't like PSR7 so much, so you need to make your own wrapper for it, but it's not hard. ZF3 and the other frameworks should play nicely though
Why not stay in Javascript, there is node and reactJS? I have been doing PHP for years, but find myself doing more Javascript all the time, it is the back-end of Mongo etc. Php is so much easier than Javascript you should find it easy enough. Companies are moving from Laravel to Node, etc. You can make some cool Javascript projects using reactJs to show your talents. Try to do dynamic single page applications rather than boring PHP MVC applications, anyone can do that. If you are going to get into Php Laravel/Lumen is a good choice.
This has been asked several times before. /u/utotwel isn't some lone wolf working mysteriously in a secluded basement by himself, Laravel has a lot of maintainers so it'll continue moving forward without him.
Pretty happy with Ansible. Easy to get into, flexible and powerful without getting in the way too much. I find the way of defining playbooks fitting nicely with the mental model of 'I want to automate this and that'. Based on your description you might be able to do without Ansible tower. You could have a playbook for provisioning (run as user that can sudo). For deployment another playbook. Run manually and log deploys in a DB where you pull dashboard data from. 
those dinosaur enterprises won't use new releases either so they have 0 impact on this. if they use php5.3 they are surely still using ZF1.
Ok I'm intrigued and you have never given the link. What's the library?
&gt; I tried to find out but Redhat put the info behind a subscription: https://access.redhat.com/solutions/409673 At the time of this writing, we have following default versions of php packages available for RHEL5, RHEL6 and RHEL7 RHEL5 :- php-5.1 (latest RHEL provides php-5.3 in php53 package) RHEL6 :- php-5.3 RHEL7 :- php-5.4 The major version for php will remain as above for its whole life cycle. Please check below paragraph on how are RHEL packages managed. Red Hat Software Collections provides support for php-5.4, php-5.5, php-5.6, and php-7.0 for RHEL6 as well RHEL7 (as Software Collections follows a different naming convention, these packages are named as php54, php55, rh-php56, rh-php70 respectively). Please visit How to use Red Hat Software Collections for more information.
Ansible or saltstack would work great for this situation. Both are easy to setup and can scaffold easy as your environment grows
Meh. My PR failures == "not worshipping Reddit neckbeards" ... guilty as charged.
People are free to sponsor if they want. I'm not going to turn down their money. Two companies wanted to sponsor at a high level so I put the Patreon around it.
&gt; I tried to suggest once again to switch to json_encode() and json_decode() functions and never use unserialize() with user supplied input, but my advice was rejected because JSON functions might have some negative effects on performance. Amazing. It's especially amazing as the JSON decoder has about the same performance.
Anytime you feed user input to a function that doesn't clearly differentiate code from data (`deserialize`, `eval`, ...) you're tempting fate. Do it enough times, and there will be an article like this with your product's name in it. 
We use Python Fabric. It's great!
I'm not surprised at all. I had to deal with pro/ent/ult sugar for 1.5-2 years and I'll never touch that again. If you've ever seen the rats nest of code they have beyond just what's in the blog post here, it would't shock you either. When I left that job, almost every bit of configuation sugar stores, it stores within a file. A file that is read every time you refresh the page. If I recall sugar had a high number of files that would cause high drive read times. One thing that stood out to me was using xdebug to solve an import issues, because support was being a pita. It was only importing something like 1500 contacts or accounts and for whatever reason this one function had been called 1.2 million times. It's been so long I don't remember which function but I do recall replacing it myself and everything running much faster. In the end the company gave up having our own sugar instance hosted on their servers and paid for 3 DigitalOcean VPS's to separately host sql/apache/elasticsearch and it was so much faster. While typing this up and having read the blog post, I just realized a module I had written because of how slow sugar support team was, I may've been exploiting a bug. See quite often in order to develop a module for someone using their data, you need their database and configuration. Well sugar support was taking 3-5 days to give us a backup file. So I wrote a custom module that didn't flag their module loader (they looked for things like file_get_contents and blocked installs). It would use techniques to read every file off the server, base64_encode the data and send it back to my server where I would decode and save them. It also had the ability to dump the database via the same means. It worked fast and quite well until I left. Seeing as we were working with other clients also hosted on their cloud system, I did test 1 or 2 times as to whether or not I could connect to other sql instances, and if I recall it was possible.
Please define what kind of `interesting` and `cool` do you seek. I'm kinda interested in php as a web server, so for me this are interesting: * [Aerys](https://github.com/amphp/aerys) * [AppServer](http://appserver.io/) * [PHP-PM](https://github.com/php-pm/php-pm)
For the record I bought the book and Loved it
Learn something NEW. For me, 2017 is the year of GoLang so far. It's great learning new things.
01. [Golang](https://golang.org/) : [ð Go Bootcamp](http://www.golangbootcamp.com/book) , [ð Microservices](https://www.safaribooksonline.com/library/view/the-principles-of/9781491935811/) 02. [Swift](https://swift.org/) 03. [Rust](http://rust-lang.org/) : [ð¤ why?](https://stackoverflow.com/insights/survey/2017#technology-most-loved-dreaded-and-wanted-loved) , [why not?](https://twitter.com/ozkriff/status/821999302931259392) , [web](http://www.arewewebyet.org/)
Yeah, there's certainly a mountain of work /u/adamwathan has done in the community (PHP and Laravel) to offset this book's success. What I learned, here, is not to waste one of the moments of triumph by failing to learn how other successfully launch things.
I'd actually say he was overly polite towards them.
Nope, I'd never own one of those piles of crap again. A chair is THE most important thing in your office - dont cheap out on a &lt;$200 one. Go for something like the Herman Miller Mirra, or the Aeron if you can afford it. Seriously this isnt something you think 'oh screw it that one will do' unless you plan on spending half your life in agony.
I don't think people are wondering about "who can send in a PR"; it's more a matter of "who decides what PRs are accepted, and what direction the framework is moving in?" I don't actually know what is true or not, but I think the perception is Taylor chats with a couple of friends &amp; then decides himself. Perhaps that perception needs to be dispelled with a little more info? I don't think it's intended to be any kind of secret.
We run multiple clusters happily managed by ansible. It's very easy to learn and has a very simple syntax. Major selling point is that your infrastructure is now under version control, so you can (in theory anyway) move DC's in a matter of (some arbitrary amount of time). Also by moving the responsibility to automated scripts, no more mucking about on live/production servers (why should anyone ever need to login to a production server anyway?)
&gt; that's not the case How do you know? Not saying it is or isn't, but what's your logic to draw that conclusion? There's actually a long-running joke - "Submitted my first PR to Laravel. Waiting for the rejection notice." 
I'd definitely go with Bolt if you have some Symfony/Silex experience. I was facing a similar dilemma recently when picking a CMS that would be pleasant to work with for the client as well as the developer, that included WYSIWYG editor (good luck explaining Markdown syntax to clients), multilingual sites and backend translations. I did a project using Bolt recently and it was a breeze compared to the alternatives that were mentioned in some of the comments (Grav, PageKit). I've tried WordPress before with Timber / Roots / Sage and such, but it felt very hacky to do something other that a blog with it. Don't get me wrong, I know people can create awesome sites with WordPress - but it's just my experience. 
Fabric is ideal for SSH-based workflows like this - you can specify individual tasks (git pull this directory, composer update here), and then which servers those tasks need to be run on, and in which order. You can make some of the tasks run in parallel, and have others block waiting for input. Puppet would be less useful here - it cares a lot about maintaining state, likes to run on a regular schedule rather than on-demand, and requires an agent on each box. Still an excellent tool, but harder to use for code deployments.
As someone who stuck with PHP since the very beginning of my freelance mission (don't like the word career &amp; it's going over 8 years) and only recently started feeling like I'm writing consistent code from project to project in a modern SOLID way. I say get experience from many languages, then stick to the one you really like. One that you feel like you are most comfortable with. Don't chase the hype, not everyone needs to be writing nodejs or rust, but knowing how they work and their problems will help you overcome issues in other languages. I've worked with C++/C#/Nim/Go/Kotlin/Crystal/PHP and a few others that I can't think of off the top and they all taught me things I wouldn't have learned by just sticking to one language. They all made me approach a similar problem differently even when the project was the same (trick for learning a language is writing a similar program in all languages and see where you hit a wall, helps accelerate the learning process). Most important is get good at one language, knowing other languages will be beneficial to you in the long run. You don't need to be proficient in all languages, just good enough where you aren't writing bad code and you can get around to do the job you're trying to accomplish.
Big fan of adam's podcast, book, and video courses
well, https://github.com/laravel/framework have 1338 contributors so i guess there will be plenty people to retake the project
I'm loving Golang. I thought it was going to be a pain to get into but it's actually quite refreshing not to worry about OOP/hierarchy/classes/objects/exceptions...
Hacking around frameworks can often lead to a mess, but in my experience it's almost always necessary. I was once against writing PHP code without using a "strict" framework that mandated that things be written in a specific way. However, after not using a framework for several years I find it can be easier to read and debug code that is organized in a somewhat logical fashion.
That's about it. I tend to use `array_key_exists` when checking for existence. But yeah, it's a linear operation to flip the array in the first place.
Agreed. I know many people that build reliable and well built sites using wordpress. Just dont do Drupal. Not even once. 
Flipping arrays only works if your values are unique and can be valid indexes. If not unique, it'll only use the last occurrence. If not a valid index, it'll throw an error. So now you have to balance saving performance on the search with impacting performance on exception handling.
&gt; It's use case 
(These are the reasons I didn't care when I got started. I definitely care today.) * No one told me it was important. * No one cares enough about hacking my stupid little site, right? * The client didn't ask me to make the site secure, they wanted it to be cool. * Corollary to the above: Security isn't in the budget. * It's hard.
I don't think any good dev would not care about security. They may be ignorant about a particular practice being insecure. There's also some circumstances where their method is generally secure but not the "most secure" by community standards. I doubt any good dev is like "eh, I'm not going to sanitize this variable because nobody is going to know or test it" while they may accidentally have an insecure sanitization method without realizing but still care about security very much. Your question is phrased as if there are a large group of people that are just fine with knowing their code is insecure. I think if that's the case, they just don't know, which is possible because the barrier of entry for php is so low.
"How dare you say I don't care -- my site is secured against every threat I know about."
The article is talking about what happens when you scatter business logic ad-hoc throughout the components the framework provides, without thinking about your overall application architecture, and separating UI from domain. And you're talking about absolute beginners using a framework as training wheels for security by relying on the framework "defaults" to take care of it (which is probably the most common way security vulnerabilities are introduced, BTW: trusting your framework fixes it "by default" somehow). There's zero overlap between the two. No framework is truly so encapsulated and narrowly constrained that writing in it automatically results in good apps. No framework. You still pretty much have to know WTF you're doing, or you end up with a mess.
From Scott's standpoint stuff like Wordpress and Drupal are insecure, and there are a metric ton of installations of them.
I am a random guy from Bangalore. I've learned few tricks from a PHP tutorial written in the last century. Security? What are you talking about?
I do care about security, very deeply, and that's what we have law, lawyers and cyber insurance for. This means that we can run a lean business without having to think about cyber security at all because if it ever happens (LOL... who would ever want to target us?) then we can just issue a cease-and-desist or make a claim on the insurance and everything is fixed without ever having to change anything on the servers or hire expensive IT administrators or pay more for our outsourced programmers. I'm happy with it so far, and the cyber insurance is a very reasonable flat rate tied to gross revenue. The only problem is the yearly security testing they make us do, but that's pretty easy to get an A-OK if you choose the right service (look for the ones with the badges for your website, it's cheap and afterwards you're proven secure)
"How many threats can there be, really? Like, ten or fifteen? And half of them don't even apply to my situation."
It less not caring and more ignorance in some instances for me. I'll try to make an application as secure as I possibly can, but there will be countless things I'm unaware of. Hunting them down can be increasingly time consuming especially since it's only one of countless things that you try to keep on top of in this industry. Stuff slips through through the cracks.
Probably 30-35 hours every week is spent building new features and solving bugs that have no immediate security consequences. I still design these features to be secure when I write them, of course, but that's usually not the "focus".
I guess I'm kind of the exception here, then? :P
I dont code php anymore but heres what i can gather. You need to send a HTTP POST request to https://safebrowsing.googleapis.com/v4/threatMatches:find?key=API_KEY with a HTTP header of Content-Type: application/json. And it will return json. https://developers.google.com/safe-browsing/v4/lookup-api The body of the request is in JSON { "client": { object(ClientInfo) }, "threatInfo": { object(ThreatInfo) }, } with threatinfo object being the urls. https://developers.google.com/safe-browsing/v4/reference/rest/v4/threatMatches/find heres some info on php http request sending https://stackoverflow.com/questions/5647461/how-do-i-send-a-post-request-with-php 
&gt; even if insurance covers your losses, one thing insurance can't cover is your reputation. Yup, they include a full PR package and reputation damage mitigation, they've very very good at it. &gt; Once your reputation has been ruined it is very difficult to recover. You can't just go to your users and say "but I have insurance to cover that!" What complete and utter bollocks. We had a minor 'breach' two years ago where about ten thousand of our customers got a bit arsey about their passwords turning up on the internet, it's not my fault they don't know how to change their passwords and they just wanted to point the finger at us. Anyway, did it ruin our reputation? No. Did we get lots of publicity? Yes. Did we lose any customers? No. Did our stock price drop? Yes, our stock was undervalued for a few months then the market adjusted and we're now hitting new highs. Do our customers think we're more secure now? Yes, that's what the PR is for. Did we even have to change anything? No... but we do have a kid watching the log files or something now and it all gets reported straight to the lawyers. ... Let me tell you one thing, good lawyers are like having a direct phone line to God himself, and with a good PR team I could personally take a dump on each and every one of the subscribers and they'd come crawling back for more. It seems like you haven't got a clue what you're talking about, son.
And I think that probably answers why: it takes a long time to learn (even with your very helpful guides). The sheer volume of stuff to learn is immense; it is also very technical and complicated. Most people have enough trouble just getting something working in front of their eyes, let alone handling the negative situations that they can't easily see / reproduce / understand. Not everyone has the brain power to understand all of this extra stuff. This said, some people are just lazy. I'm referring above to those who know they should concentrate on security, but don't. Although your question is aimed at those who don't care about security, I don't think there will be many people in this sub-reddit who do not care; but there will probably be plenty who are unable to care...
I'm also on board with the switch to Go, I've not written any PHP in my own time now for well over a year, and only write it at work. The rest of the time has been between Scala and Go, and I'm finally settling much more into Go as a very pragmatic, productive choice. I've learnt a ton more along the way, there are plenty of things you never have to deal with with PHP (that also hold it back) like the lack of concurrency, and handling long-running processes that you're writing yourself. It's very fun, and great for system tools and web services (and more).
&gt; I don't think there will be many people in this sub-reddit who do not care; but there will probably be plenty who are unable to care... https://www.reddit.com/r/PHP/comments/67h2u8/ask_rphp_if_you_dont_care_about_security_why/dgqdcm9/
I would love to get /u/sarciszewski opinion on this write-up and the SugarCRM product from PHP security standpoint.
Sure. Give me a bit.
THIS is the real reason security is hard. Any dope can paramaterize their queries and encrypt their passwords.
It's not just PHP developers that do print debugging; it seems to be the most common technique for many C, C++ and Java programmers I've encountered as well.
&gt; Any dope can paramaterize their queries and encrypt their passwords. You'd think so, wouldn't you. &gt;:(
You might be right. But I don't want to believe it. And I won't like you.
I am right, you don't get to the top by being nice.
God damn I'm not sure if you're serious or not, but that is scarily accurate. 
Many cliets cant afford anything but the bare minimum but want the kitchen sink, so they get an overloaded CMS with no understanding of its life cycle and that is just how it is. Often its something with very poor ROI because its a vain afterthought not a core part of their business. I worked in a small shop that churned out Drupal 6 site 4 years ago or so and most of them are still out there on php 6.29. None of those sites are going to be properly rebuilt and tested.
...and it is appreciated. I read just about everything you publish. --Including the post about not using JWTs, just about broke my heart Scott. I do think of security as a spectrum. I'd like to be as far on one end as I know about-- and I try to keep learning.
To expand on this; you'll likely want to dump the json to an associative array since you have URL's as keys. [Check out this example](https://repl.it/H0Fr/0). 
&gt; var_dump($json["example.COM"]['target']); &gt; string(11) "example.com" NULL
&gt; var_dump($json["example.COM"]['target']); Does the little process key at the top of the JSON have any significance?
You're trying to extract JSONP. You need to remove the function `process(` and `)` to get just the JSON.
Can you share the source?
I have a Herman Miller Embody.. Best money I have spent! 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
It is the effort and technology invested..and of course if you consider someone who read a few tutorial on the net a hacker than yes it is impossible but if you consider people who do it for living..than that is a different thing, you can see just how many sites were hacked..or just see the results of hackaton..if you have the money you can pay the people.and they can invest effort..this way paypal was hacked, youporn, facebook, yahoo and many more
&gt; I guess I'm kind of the exception here, then? In what aspect are you an exception? 
I find it very cheap to find vulnerabilities in frameworks/libraries that people assume are secure.
Yes, a lot of sites have been hacked. Some were companies that had a lot of money. That doesn't prove, "for the right money, every site can be hacked". No matter how much money you throw at a problem, if the code is secure, you aren't getting in through a code vulnerability. More than likely, if an adversary has enough money to burn, they'll just send a burglar to infiltrate the data center and steal the data they need.
&gt; Nope..if you read regularly the posts describing hacking attempts and how they succeeded, you will see that there is always a backdoor. That's not what that word means. A backdoor is an intentional vulnerability; usually NOBUS. &gt; for instance if you are using php 5.5 and serialise user input which most of the frameworks/coders did at the time, you can get root access to the linux servers I'm not stupid enough to do either of those things. * https://paragonie.com/blog/2016/04/go-php-7-our-commitment-maintaining-our-open-source-projects * https://paragonie.com/blog/2016/04/securely-implementing-de-serialization-in-php &gt; I am senior PHP dev and spent a lot of time with security and still, last week an ethical hacker showed me a way to hack a PHP application I didn't know even existed :) I used to regularly report 0days to large open source PHP projects. Lately, I haven't been motivated enough to look for vulnerabilities. (It's a thankless process, and there's no financial incentive.) I've written libraries that are used by hundreds of thousands of sites. One has an install base of over 25 million (not counting all of WordPress 4.4+, which probably puts it at over 100 million). I published what I believe is the only comprehensive guide to [writing cryptographically secure PHP code](https://paragonie.com/blog/2017/02/cryptographically-secure-php-development) on the Internet, to date. If you're telling me that there's a vulnerability in my code just because other people made mistakes, I disagree. If, conversely, you're saying that it's likely that, if a hypothetical vulnerability existed, then I'd likely be blind to my own mistakes, then I'd agree with you. But do not conflate the two.
How about a [free taste](https://www.youtube.com/watch?v=65NrzJ_5j58) or [two](https://www.youtube.com/watch?v=jJ5PCbjZIsY)? Why not [all the free tastes](https://www.youtube.com/results?search_query=paul+m+jones+modernizing+legacy&amp;page=&amp;utm_source=opensearch)?! :P PS: That "A Stitch in Time Saves Nine" talk is great, too. Honestly, Paul's full of good knowledge, and if I was modernizing something legacy without a rewrite I'd buy that book in a heartbeat after seeing his talks. PPS: Refactoring by Martin Fowler will also be a great resource!
This book was my bible at an old agency I worked for. The book outlines an easy to follow plan of refactoring. Know that it's a slow process and takes time. Once you've completed the first cycle you rinse and repeat for different parts of the application. When I give talks about Legacy applications I reference this book and suggest attendees purchase it.
That link is back to this thread you posted, is it not? Unless that is a mistake, I have re-read all the posts and I take it that most people do care, but are unable to do much about it for various reasons. Anyway, not wanting to get into an argument about this, as I really respect and appreciate all the work you do, and we'll have to agree to disagree about the perception of the replies here. 
&gt; thats why we pay so much for security audits at the end.. The state of affairs in PHP would be so much better if more companies actually did that.
Honestly, I think Martin Fowler/Kent Beck's "Refactoring: Improving the Design of Existing Code" is much better. 
Money can be a motivator to get [very talented people at work](https://www.evonide.com/how-we-broke-php-hacked-pornhub-and-earned-20000-dollar/).
That's why I think it's a better choice. *Refactoring* applies to any project while still showing the reader how they could go about improving their weaker software. He said he's an intermediate-to-novice PHP developer (or at least out of practice/touch). I don't think that MLAPHP is a bad book, but I think he should read the other first. It's more important to learn the fundamental skill than how to apply fragments to narrow cases. Hell, I think he should read Clean Code before he reads any of these.
Easily with the money. 
Most frameworks are easy and not simple. https://www.infoq.com/presentations/Simple-Made-Easy
You should post this in [/r/phphelp](http://www.reddit.com/r/phphelp), as per the sidebar rules.
&gt; Scan through arrays for elements (O(n)) instead of flipping those arrays when possible for O(1) access. And flipping is for free?
The interesting thing is no one ever wanted to mix two or more giant frameworks in one app. So the problem didn't exist, but boy, do we have a bunch of solutions for it. :P
I was in the same boat as you. Bought this book a few months ago, and now I write awesome code (as far as I know) that runs on PHP 5.6+ and has unit testing and everything. Admittedly, I haven't touched the book since I read it the first time. It just helped me go in the right direction for writing new code. I'll probably have to bring it back out when I have to start refactoring old code.
I see the point you are making. I feel like we would need to know what his knowledge level actually is. One thing is for sure: MLAPHP is **immediately** applicable to his project. There are many common pitfalls in legacy PHP apps and I think it would be more straightforward **in this case**. I guess my point is that MLAPHP can be used without really needing to understand what's going on, whereas Refactoring and Clean Code take (rather constant) thought.
try using your browser's network inspector to check the actual network traffic/request
to quote him in that other thread &gt; Laravel = Taylor, which is somewhat true in that I call all the shots in terms of what gets merged, etc. I'm willing to lose out any companies that don't like that, because I'm not willing to sacrifice the quality of the product to a design by committee approach or something.
&gt; 7-foot-12 8ft? 
In regards to the first one, most hacks are done by bots, programmed to put for example, spam on as many sites as possible. Bots don't get lazy and think, well I won't bother with this one, it barely gets any traffic, it will blanket hack everyone it finds with that weakness.
Do you think the internet in Bangalore is stuck in some kind of time warp? :D
You may wish to pose this question to /r/PHPhelp...
Thank you for the guidance. I am really looking forward to improving my validation techniques. Can you suggest me any tutorial or something from where I can learn that? 
Since I'm working in IT-related field I'd recommend you to master Java ( for back-end ) and also php / html ( front end )... Learn MySQL / MsSQL as well ( database )... It'll be handy... 
[removed]
So, what O would you rate it, then?
It is not about coupling. I personally don't care if framework is monolithic or composed of individual packages (which is nice of course, but not my primary concern). What I as a developer care is ease of use, speed of development, ease of teaching and explaining. Take route definitions in ZF2/3 as an example. It is deeply nested php array that is unwieldy and hard to grasp at a glance. Compare it to say symfony way it looks overly complicated. Now don't get me wrong ZF is quality framework and has solid engineering behind it, but it is not a "sexy" framework to use. 
The bus would do no damage because Taylor is nothing but a facade.
That's where we disagree on priorities: framework decoupling *is* the primary concern. It has nothing to do with splitting packages or using micro- vs monolithic-architecture: it's about having a 10 years old application to maintain, and being able to migrate it to `&lt;insert new version of whatever you want&gt;` without dragging along the framework. Maintenance work is where we spend most of our dev life, so code should be written for segregation of code domain (reads: "what makes money") and supporting domains (stuff that will likely change, depending on library or software development practices changes). It's basics of hexagonal design, and while ZF3 doesn't achieve that yet (still a lot of coupling in the form component, for example), it is trying hard to get there. About the sexiness, check Expressive (said it above): an Expressive app can be reduced to a few lines of code in an `index.php`, including service container setup, yet achieving the above. Also: sexiness was never the point: * code rot * reduced coupling with components that change a lot * ability to easily replace code * run-time and startup-time segregation * upgrade complexity * security These are *IMPORTANT* focus areas. If I wanted sexiness, I'd choose another job anyway. Code is not sexy, it's mostly garbage :-P
Most projects probably don't need special-tailored collection classes, and as such shouldn't be writing them. Using the "full power" of anything in programming is not something you should strive towards. You're going to end up overcomplicating your code for no good reason other than to show off how "smart" you are. There's a good reason Java and its AbstractBeanFactory-type classes gets made fun of.
&gt; A lot of PHP programmers didn't use full power of OOP. A lot don't know about it. Of those that do know about it, some choose not to use it. If you utilise every feature OOP has to offer in PHP your code will look like enterprise Java. I can't count the number of times I've seen two hundred lines of AbstractFactory, FooFactory, FooCollection, Foo classes where a simple static method and an array would have sufficed. Simplicity is key to good programming and the full power of OOP doesn't make thing simple. &gt; I saw a lot of code where array represent the data type but object can do it better. I agree, a lot of the time arrays are used where objects should be in PHP. CakePHP 2's ORM does this all the time and it drives me nuts! &gt; I almost haven't seen the collection classes in PHP project(1 out of 100 use it). I've never been in a situation where a collection class actually helps me. An array and a better written object has always been the answer for me.
Great stuff Adam, pleased it's working out so well for you ðð»
You aren't bad ;) sometimes it's usefull
thanks ;)
Does this solve the (speed)problem of making several API calls synchronously (auth, feedA, feedB...)? Some of the sites I maintain require several API calls per request, caching helps a LOT but, asynchronous composition would be ideal.
If you're working with a lot of data, in PHP 7 using objects instead of arrays can be faster and use less memory: https://www.exakat.io/moving-from-array-to-class/
As someone who started learning PHP 2 years ago being 18, didn't had the money to purchase sufficient resources/books/subscriptions. USD converted to regional currencies are a huge amount. Free resources don't even teach you why and how to refactor the code by using the OO approach. Infact most even don't teach youâ OOP with PHP. It took me 2 damn years to be good at this and I was only working PHP for straight 2 years, nothing else. (Not even JS)
coolsunshades is correct, everything comes back as arrays. cakephp 3 introduces the concept of entities (which are objects representing a row in a table) but cakephp 2 simply uses multidimensional arrays for everything
Your conclusion would be mine also. It's a form of lazy evaluation, allowing you to only evaluate the expression at the point you actually need it. In this case it's in a dependency injection container, so this has three particular advantages: * Dependencies aren't created until they are needed. This avoids unnecessary resource use (execution time, disk I/O, potentially network connections to things like databases). * Dependencies with their own dependencies won't be created until their dependencies are (though the particular ordering here depends on the DI system). * Dependencies can be created asynchronously, so you don't need to worry about the order you define them in. Think of it like autoloading for dependencies.
&gt; PHP objects are slower than arrays Nikita Popov (aka /u/nikic) [disagrees](https://gist.github.com/nikic/5015323) with you. Also, see [this comment](https://www.reddit.com/r/PHP/comments/67nb99/oop_in_php/dgrueb9/) &gt; there is very little benefits with POJO in PHP, compared to stricter OO languages. What? I'm going to give you the benefit of the doubt that you mean POPO, but even that is just incorrect. Even with "plain ol' PHP objects" you still get the power of OO design if you write your objects in that way (one of the more common cases being inheritance/polymorphism).
As a PHP dev, when I started to learn some Java frameworks and when I've read more about S.O.L.I.D. principles, I found that I'm not aware of OOP advantages in terms of code maintainability and scalability, i.e. quality. PHP is not so strict in some cases so I was ending up with a poor-quality code just to finish it asap. It's not good idea and boilerplate code is not as bad as I thought. Just my thoughts... ;)
The difference is what you get when you use $x after the definition in the first case *$x* is a instance of *stdClass* the second case is much more interesting, *$x* is a closure the returns a new *stdClass* object, so every time you execute the closure by writing *$x()* it will evaluate to a new and different instance of *stdClass* for example: $closure = function() { return new stdClass(); }; $one = $closure(); $two = $closure(); // this prints false, because they are different instances of stdClass var_dump($one === $two); Usually, a closure that returns a ready for use instance of a given class is called a *factory* in this case you do nothing special, but the object returned from the factory might need some boilerplate to be ready for use, like setting some parameters, executing some of its methods, or anything you need (in your question on stackoverflow your example uses a variable named *$container*, I'm assuming you saw this on a documentation for a dependency injection container, *pimple* maybe?) This approach is commonly used by DI containers (like [pimple](http://pimple.sensiolabs.org/), [PHP-DI](http://php-di.org/) [laravel service container](https://laravel.com/docs/5.4/container) and others ) to define what they call *services* you can define as many services as you want and the will not be instantiated (therefore using more resources) until you use them, this is called *lazy loading* edit: typos and formatting 
If someone ends up with a class with a lot of static methods, he aint designing it properly. Static properties/methods are code smells, they signify that the methods do not really belong in that class and SRP is being violated. A perfect example is UserModel::find($id) static method, which should be refactored into $userRepository-&gt;find($id) instead. In my project I dont use static methods at all, except for Scalar Object classes(aka Nikita Popov's amazing C extension), which requires methods to be static.
I got myself [this nice chair](https://www.amazon.co.uk/gp/product/B00KY055GU/ref=oh_aui_search_detailpage?ie=UTF8&amp;psc=1), and I'm a bit of a fan. I can usually sit in it for about 10-12 hours without getting uncomfortable, and it's fairly sturdy and feels strong
[Entities are NOT objects representing a row...](https://martinfowler.com/bliki/EvansClassification.html) They represent a domain object with an identity (in contrast to value objects which don't have an identity).
What is important to note here. That static methods are also really hard to test. You can mock Objects easily making tests easier thanks to Dependency Injection. There are a few hackt libs that can overwrite static method calls but it's kinda scary and dirty. 
Static methods are awesome for named constructors on value objects. But I haven't found another good usecase for them.
I've never used them so I couldn't comment on how helpful it is. If it's in Laravel it must have a purpose thought. Â¯\_(ã)_/Â¯
It separates out the value object or model from the class that is doing the finding. This is pretty core to the single responsibility principle and makes it easier to test your changes and if necessary provide a new repository implementation without mucking with your base entities. Classes should either be data, or work with that data. Not both 
Yeah, I hear ya. I said "idiocy" because said colleagues would make everyone else's work painful in the name of "performance", but would be utterly clueless about the topic on which they had such strong opinions. It's OK to simply not know something. There's more to learn than any of us ever have time for. It's _not_ OK to not know something, have no interest in studying up on it, and still push on the rest of the team about it.
When you're doing more than just assigning a value.
Your mom is syntactic sugar (Couldn't resist)
I thought the same way once. Always bought some cheap knockoff pseudo leather thing to sit in. "it's a chair, so what, just let me pay as little as possible". But as a programmer you sit eight, ten, maybe fourteen hours in that chair. Every working day. So why not treat yourself to something really comfy? I mean I wouldn't buy the cheapest mattress that I could find and I spend more time in my computer chair than in my bed. 
Yeah, probably. But when your job is programming, and your hobbies are mostly video games, tv and anime...
It depends on whether you want an object logic where objects have their own behavior, or a simple HTML/whatever templating. I also saw projects where "OOP rules the world", which turns out to be a pretty poor habit (they turn SQL's tables into PHP object and back into HTML tables, doing a lot of useless but bugprone things). I actually use OOP for meta-project (how to serve the website content) and simple procedure/template style for the real project (what is actually served). Logic is often delegated to (My)SQL because it's 99% a plain simple data logic (where atomizing stuff into classes would bring nothing but no-more-global-sight)
"Programming habits that make your code smell 1. Saying, âIâll fix it laterâ... ... 11. Refusing to write bad code There comes a time in every developer's life when deadlines will force you to write terrible code, and thatâs okay. Youâve tried warning your client or manager about the consequences, but they insist on sticking to the deadline, so now itâs time to code. Or perhaps thereâs an urgent bug that canât wait for you to come up with a clean solution. Thatâs why itâs important to be versatile as a programmer and to be able to write poor code very quickly as well as good code. Hopefully, you can revisit the code and pay back the technical debt." It seems the writer is a bit conflicted! 
There is a difference between being lazy and being rushed. If something horrible is broken in production and a quick nasty fix will take care of it until the underlying problem is addressed then do it but don't leave it that way. If you have two weeks to fix some bug don't write a nasty solution when you have the time to fix it properly.
I agree that you should know when to write ugly code if it can fix a critical bug or make a deadline you just can't afford to miss... But I don't see how writing bad code can make your code smell less.
&gt; Static properties/methods are code smells This is not part of OO paradigm. This is basicly global variables and procedures. And there is nothing wrong for example with pure static methods since they didn't have side effects. The problem is only with global state. &gt; which should be refactored into $userRepository-&gt;find($id) instead. It shouldn't. `find` method here acts just like factory method. It isn't pure and it works with global state (database in our case) but we could replace this static method with just function `findUser` for example. And after that there won't be SRP violations. Yes, we could use separate class `UserFinder` instead (not repository since it responsible only for finding records and create instances of them) which will be factory for our `$users`. But what we will get? Benefits from testing? maybe, but this approaches usually used in context of very data-centric applications with small amount of logic. Unit tests won't help us here. And `UserFinder` will be covered by integration tests. The problem is not `::find` methods, the problem is that developers don't really want to think which approach fits better to their needs. &gt; In my project I dont use static methods at all named constructors/static factories? they are testable (since they are pure). Why not to use them? Also, do you have getters/setters? &gt; except for Scalar Object classes Here again. in scalar_objects extension static methods are just functions which is defined in specific context. This is just a way to add custom functions to scalar objects. This just convention. All this could be covered just by pipe operator and simple functions and doesn't really have anything related to OO. OO = actor model, message passing and late binding. The only popular language that I know which really OO is Erlang. 
In my opinion a lot of these habits are a result of the same mentality issues. The article would be more clear if it addressed one or two of these mentality issues, instead of being click bate with a high number list as title.
In languages like Kotlin classes just don't have static methods. You could just define function in context of package.
&gt; That static methods are also really hard to test. public function testStaticMethod() { $this-&gt;expectException(InvalidAmountValueException::class); $result = Amount::positive(-12); } So don't have any problem if static methods are pure. &gt; There are a few hackt libs that can overwrite static method calls but it's kinda scary and dirty. If static methods are pure, you don't want to mock them.
when a function has more than one return value - for example https://secure.php.net/manual/en/function.exec.php 
I use OOP extensively, but there are situations where **pure data** is best left as arrays. There's a way to overdo this, wrapping every single data item in objects, I've seen things like: $user = new User( new UserName("Foo Bar"), new UserId(new Uuuid()), new UserEmail(new Email("foo@bar.baz")) ); Where the balance sits for everyone depends on their specific practices. But I've had great success modeling data "more coarsely", say using "entity sets" as the object, not single entities: // Returns an instance of "class UserSet". There is NO "class User". $userSet = $repository-&gt;getUsers($criteria); echo $userSet-&gt;count(); // 3 $userSet-&gt;getName(0); // George $userSet-&gt;getName(1); // Louis $userSet-&gt;getName(2); // Scarlett ... and this yields surprising advantages to building APIs that allow efficient batching, avoids high serialization/deserialization costs etc. I've also had great success using objects for the "entity service" only and leaving actual entities as untyped array data. Works fine in many cases, just make sure data is validated on input in the service. There's **no one right way** to doing all this.
I have created workaround with http://docker-sync.io/ for my symfony project. This work in both directions(also back-sync) using unison https://github.com/Arkowsky/docker_symfony - maybe this help you.
&gt; you just have to create a bunch of temp vars if you don't want to inline the array_* calls. You don't need temp vars: function foo($array) { $array = array_unique($array); $array = array_reverse($array); $array = array_map(..., $array); $array = array_filter($array, ...); return $array; } **Zero additional variables.** You can argue some functions are missing, and some are inconsistent in argument order etc., but you don't need to constantly wrap/unwrap arrays in Collection objects to get that, you can use simple, fast static method helpers: use Foo\Bar\ArrayUtils as a; function foo($array) { $array = a::unique($array); $array = a::reverse($array); $array = a::map($array, ...); $array = a::filter($array, ...); return $array; }
Hey, awesome, glad you agree!
Ok I worded that incorrectly. Code that uses a lot of Static Methods will be hard to test. If you want to test this: public function getAmount($userId) { $data = Users::getById($usersId) return $data['amount']; } You will have to find a hacky way to mock Users::getById
&gt; If you mean "create your own" then that's an entirely different argument. Every company/project has one of those. And one for strings. It's so easy and quick to write, I suppose it's easier to spend an hour and write it, instead of arguing what to use. &gt; The thing is, with these collections, there's not often a need to unwrap unless you're working with stuff that can only accept arrays (which, in most cases, is when doing a transformation, which is possible to do to a collection). Laravel makes a specific effort to accept and return Collection instances, and you probably use Laravel, this is why you don't see "stuff that only accepts arrays" a lot. But outside Laravel, that's basically 100% of APIs, because Collections is not a PHP class, it's a Laravel class. I think taking and returning an entire new type in your APIs, only for the helper methods is a giant mistake. Collections is not a new data type. It has no different semantics than an array. It's just a boxed array with helpers. I'd accept Collections as a good thing, if it maybe supported lazy iteration of any kind of iterators, but last time I checked the implementation it has to materialize the array during construction. So it's as good as "array with helpers". This stands in stark contrast with other libraries like Java 8 streams, where arbitrary dynamic iterators are supported, it's a brand new type of data structure. And BTW, whether you realize it or not, you *don't need to wrap an array in an object in order to use an OOP interface for processing it*. Let me demonstrate using a transform library I use in my apps: function foo(array $array): array { return t::pipe() -&gt;unique(...) -&gt;reverse() -&gt;map(...) -&gt;filter(...) -&gt;apply($array); } Watch very carefully what differs between Collections and my pipeline object. The array **is not a part of the object**. Instead I build a reusable pipeline I can then apply to many arrays. And the moment I feed an array, the result is immediately another array. use Foo\Bar\Transforms as t; $pipe = t::pipe() -&gt;unique(...) -&gt;reverse() -&gt;map(...) -&gt;filter(...); $array1 = $pipe-&gt;apply($array1); $array2 = $pipe-&gt;apply($array2); $array3 = $pipe-&gt;apply($array3); Not only this eliminates the need to wrap/unwrap, but also it makes the pipeline reusable. I process three independent arrays using the same transforms. Do you still like Collections? Do you still feel putting one array in an object box is the best approach?
Number 2, yeah I agree with this. Sometimes you just gotta let go of that regex and write a damn loop.
This may help you out. https://www.owasp.org/ Here you can search for specific topics.
"Premature optimization is the root of all evil" wow that's really insightful.
- https://3v4l.org/gU0X9 - The closure is lazy. It will only create the object when you ask for it. This helps a lot in a big app where you might only need something in some requests. - https://3v4l.org/Ue2mF - The closure returns a new instance each time. If you don't want to return a new instance each time, you can [wrap the closure in another closure](https://github.com/yuloh/container/blob/master/src/Container.php#L39) to make it return the same thing each time (singleton) if you want to. - https://3v4l.org/aCWNa - Since the object is only built when you ask for it, you don't have to build objects in a specific order. This one is a little harder to follow. You pretty much only have to ask for the outermost object, and the closure can fetch it's dependencies, which can fetch it's dependencies, etc... until they are all resolved. Without the closures you would have to start by building the inner most object and work your way out. With containers, it _can_ be useful to set an instance like your first example. Some containers will have a method to do it, but others will just make you use a closure since a closure can be used for instances or anything else (https://3v4l.org/MLuGd). I wrote [an article about building a simple closure based DI container](http://mattallan.org/2016/dependency-injection-containers/) last year that might be helpful.
Yeah I hate that. Premature micro-optimization? Sure. No point in unrolling a loop to shave off 0.000000000001 of a second. However if a piece of code is taking 10x longer to execute than it reasonably should be, look into it and optimize it, because something might be fundamentally wrong with the approach and may need to start over from scratch. You don't want to build your whole platform on the wrong algorithm.
Even if UserModel::find() does delegation only, the class design is still flawed. In the code above your UserModel class is tightly coupled to the concrete implementation of TableGateway, and even worse it is a hidden dependency that other programmers wont know by reading your API. They can only see this by delving into your source code, and to mock this method they have to mock TableGateway as well. It may not violate SRP, but you end up with tightly coupled code with low cohesion anyway. In your example, its much better to write $tableGateway-&gt;find("User", $id) than what you come out with. Its not much more effort than using static methods, and its a much better/cleaner class design. Its also worth noting that Service Locator is an Anti-pattern, and an aspiring programmer shouldnt use TableGateway for this purpose. 
&gt; &gt; Every company/project has one of those &gt; I don't think you realize how spoiled you are. [...] I have to fight to put utility classes into the project because people argue the necessity of it. Yup, you have to fight. For your right. To paaaaaaarty! &gt; So your pipeline approach is pretty neat. I'm not sure how there's much difference if you were to to create a collection inside foo and return a plain array. - The pipeline is reusable with different data, Collections is not. - It stops encouraging people to use "Collections" typehints, thus infecting more and more components with dependency on Collection. The latter is important because there will always be more APIs that take arrays than Collection instances, so you have to convert back and forth. With pipeline you explicitly end up with an array, so you stay consistent: `array` types everywhere. This is especially useful for flexibly changing your implementation. You can have a function `foo(array $a): array` not using pipelines, then you can use pipelines, and then you can remove them. The function interface doesn't change. But if you write the function as `foo(Collection $a): Collection` now you are committing to using Collection, and your callers have to commit to it as well. And this is subjective, but if you pass Collection around, it will be computed on demand. Which sounds like a great thing if you somehow throw it away before you compute it. But actually: - Chances you'll build and pass a Collection and it won't be computed are from slim to none. - The "housekeeping" of maintaining the lazy computation state is an extra performance hit on the overall operation of Collection. - If your Collection has attached closures to it that might throw an Exception, if computed lazily, they might throw that Exception in a completely different place in your code, where that code doesn't expect exceptions. It makes code harder to debug. So I don't think "lazy by default" is a benefit here. If you want lazy you can always wrap the logic in a function/closure/object that is called on demand. But that would be rare. &gt; How do you handle passing multiple arrays to map? Or do you just not want to support that feature like stock PHP does? Can you show an example, as I can't understand from the question alone? If you mean this: $result = array_map($callback, $a, $b, $c, $d); Then this is equivalent to this (flatten with me is 1 level deep by default): t::pipe() -&gt;flatten() -&gt;map($callback) -&gt;apply([$a, $b, $c, $d]); Of course you might just merge them in advance as well.
&gt; One problem that Iâve seen in every team that Iâve worked on so far were monster entities. Even though the applications were in different domains, they all had a select few entities that just kept growing larger. &gt; &gt; When I learned about the importance of having bounded contexts, the problem revealed itself. We were trying too hard to focus on DRY (donât repeat yourself) by only having one entity. Preach it. &gt; I think the problem was a result of just blindly relying on an ORM without thinking about the bigger picture. /me nods I have begun thinking of the ORM as a *data source* for DDD elements, but not as a *builder* for those elements. (Cf. [Atlas.Orm](https://github.com/atlasphp/Atlas.Orm) and especially the [domain model](https://github.com/atlasphp/Atlas.Orm/blob/1.x/docs/domain.md) doc therein.)
https://github.com/christianblos/codedocs
&gt; the class design is still flawed. But OOP is not about classes, right? &gt; In the code above your UserModel class is tightly coupled to the concrete implementation of TableGateway abstract class TableGateway { private static $implementation; public static function find(string $dataModel, string $id) { return self::$instance-&gt;find($dataModel, $id); } public static function setImplementation(TableGatewayInterface $implementation) { $this-&gt;implementation = $implementation; } } And you could put any implementation. Even in memory gateway if you want. But yes, I doubt that I will ever use something like this. But this could be very useful in case if you are refactoring legacy application for example. &gt; but you end up with tightly coupled code with low cohesion anyway. Even with this approach I could have loosely coupled and high cohesive code. The huge downside for this is only amount of boilerplate required to test this correctly. &gt; and its a much better/cleaner class design I want to design my objects, not classes. Classes are not important. &gt; Service Locator is an Anti-pattern This isn't true actually. Anti-pattern is when you use dependency container as service locator. In that case you loose control over your dependencies. But in Laravel for example there nothing wrong with service locator implementation since at least it uses segregated interfaces (many small locators instead of huge one). It still preferable to use good old dependency injection, but... in some cases (especially in legacy applications) this could be much better approach at least to begin refactoring.
&gt; It stops encouraging people to use "Collections" typehints, thus infecting more and more components with dependency on Collection. What I meant was something like function foo($array) { return collect($array)-&gt;map()-&gt;filter-&gt;toArray(); } Something like that. Then you only work with arrays, but you get the benefit of a library that's already build and rather featured. This is the exact wrap/unwrap thing you mentioned though, but I'm not sure how it's much different than having to `apply($array)`. I am going to defer from touching the other points based off the premise of passing around Collections since there was a misunderstanding in my last response. I feel like you wouldn't have brought this up since I did mean to convert to collection inside foo. Also, I do understand that this (un)wrap works great if you do everything inside a method such as `foo`, but let's be honest, a lot of devs won't. &gt; The latter is important because there will always be more APIs that take arrays than Collection instances Totally. Can't argue that. &gt; Can you show an example Are you sure your example is equivalent? So, the way `$result = array_map($callback, $a, $b, $c, $d);` works is the callback would receive 4 params for each iteration of the map, whereas a flatten or merge would just make one giant array. Basically, you can create `zip` or `transpose` by using `array_map` in a fun way: function transpose($array) { return array_map(function (...$items) { return $items; }, ...$array); } $arr = [['a', 'b', 'c'], [1, 2, 3]]; return transpose($arr); // [['a', 1], ['b', 2]] It appears to me that flatten or merge would do this instead `['a', 'b', 'c', 1, 2, 3]` You could also concat them, multiply, etc. I feel like with flatten/merge it's just not the same as you won't get each "column".
&gt; Are you sure your example is equivalent? So, the way $result = array_map($callback, $a, $b, $c, $d); works is the callback would receive 4 params for each iteration of the map, whereas a flatten or merge would just make one giant array. Hmm, interesting. I never used array_map() this way to be honest. It's... a curious feature. That said I have a transpose() method in my "table" transforms, I can just transpose the array and *then* pass it to map() and you'll be getting one item in the callback that is [$a[0], $b[0], $c[0], $d[0]] etc.
Shitpost 
I *choose* not to use it. Objects don't play nice with existing libraries and methods. You can't half-ass it. If you buy into objects, then all of your methods should accept `ICollection` or what have you, and then you're juggling these stupid interfaces. To give you an example, lets say you want to write a method that checks if an element is in your fancy collection. Then you have to write some crap like this function in_collection(ICollection $iter, $value) { if($iter instanceof ISet) { return $iter-&gt;contains($value); } foreach($iter as $v) { if($v == $value) { return true; } } return false; } Taking special care to check if the collection is actually a set, because sets are optimized for contains lookups, and we don't want to miss out on that! Otherwise we have to iterate the entire collection searching for it. Or you can just say fuck all that noise and just use [in_array](http://php.net/manual/en/function.in-array.php) and be done with it. Now you might argue that your fancy pants collection library already has methods for all that junk. Great, but does your *framework* of choice play nicely with it? If you're using Laravel, then most of its junk will accept Illuminate collections, but if you wanted to use FancyPantsCollectionLibrary you wouldn't be able to. You'd be converting back and forth between lumens and fancy pants. It's all crap. Unless your language comes with a *standard* set of interfaces, it's just not worth it IMO. C#/.net has IEnumerable and what not, and pretty much every method already accepts those, so those are fine to work with, but when there's no standard across the entire PHP ecosystem, you're boned.
if you know it's taking 10x longer than it should, I wouldn't consider that premature
Did you know how can I get the memory usage with xdebug? This is my xdebug config $ cat /etc/php/conf.d/xdebug.ini zend_extension=xdebug.so xdebug.remote_enable=on xdebug.remote_host=127.0.0.1 xdebug.remote_port=9000 xdebug.remote_handler=dbgp xdebug.profiler_enable=1 xdebug.profiler_output_dir=/home/mercado/profiler xdebug.trace_format=1 xdebug.show_mem_delta=1 xdebug.trace_output_dir=/home/mercado/profiler I get the cachegrind file but that only includes the time. In this link they are getting the memory usage by function :D very cool https://derickrethans.nl/xdebug-and-tracing-memory-usage.html edit: works adding xdebug.auto_trace=1
First of all, congrats on writing the book! I took a look at the free sample and your writing style is clear and concise. However, I noticed a few problems with word usage and some grammar mishaps suggesting that it might need a proper proof-reading. Cheers!
My initial thought would be to investigate the request failures. A 26% failure rate is more likely to be a problem with your usage or setup considering how popular it is and the fact that you aren't hearing about high failure rates more generally.
&gt; Even with "plain ol' PHP objects" you still get the power of OO design if you write your objects in that way &gt; I didn't say anything about property bags, If you're starting with arrays and you transfer to POPO, that's what you get. It's almost like you don't pay attention to the posts but just feel the need to kneejerk about your personal beliefs.
Even 1% of failure doesn't make sense. This is either the server killing the request due to timeout, a dependency failing (say SQL connection limits exceeded or timeouts) or an error in the script/config. Lumen can't do much to cause a failure itself. It does affect performance though, of course. Investigate the source of failure.
&gt; We were trying too hard to focus on DRY (donât repeat yourself) by only having one entity. I've learned that building a large system is about writing many components in isolation and then writing tons and tons of adapters and mappers to convert data and API calls between them. Adapters/mappers are part of the game. If someone is trying to avoid them by having "one universal X" for some functionality, chances are it'll turn into a nightmare. &gt; I have begun thinking of the ORM as a data source for DDD elements, but not as a builder for those elements. (Cf. Atlas.Orm and especially the domain model doc therein.) Does your ORM create objects or arrays by default? If objects: why. Arrays may be a good intermediary format if you'll have separate DDD objects anyway. My own mapper *can* produce objects, but I keep things arrays until it reaches a more interesting part of the domain.
It is literally only a hello world output to test the lowest base functionality, this was for leaving out SQL and more. As some of the heavy boys like ZF3 and symfony does not do this and still have higher r/s there is surely something wrong 
Sometimes if you hit a server with enough requests, it just being slow might cause a high failure rate. Dunno.
I do agree with that, which is why I have run the test of each system 10x with 5 min interval to remove any problems.
Define "production grade" please.
So did a test on a production ready server, not a big one but it has all the facilities ready: Label # Samples Average Min Max Std. Dev. Error % Throughput Received KB/sec Sent KB/sec Avg. Bytes HTTP ZF3 500000 16 1 368 16.39 0.000% 2782.49256 667.28 592.37 245.6 HTTP Lumen 500000 23 0 313 24.21 26.082% 1874.00678 1343.74 327.37 734.2 HTTP Laravel 101138 110 3 6612 510.94 0.049% 440.5464 437.17 0 1016.2 TOTAL 1101138 28 0 6612 158.33 11.848% 1628.67349 856.08 286.63 538.2 
*The grade of a Production.* /s
I must have missed where they talked about casting an array to an object. This all started because I mentioned OO design, which is certainly more than just a class with properties.
Ah, and what do these "production grade" sites run?
Have you run 'php artisan optimize' ?
Sounds misconfigured to me. Have you both 'config:cache' and 'route:cache' first? You'll need to provide an exact cloud provider config setup that other people can replicate to test your setup. I've run high load Laravel and Lumen sites without any issues that you describe. 
What does "error" mean? I mean, what kind of failures are we talking here? You're throwing around a very vague but dangerous term - please give us reproducible steps and/or full responses of those errors (error code, server message, log entries, anything). Let's collectively get to the bottom of this and reach some proven and peer reviewed conclusions.
You forgot to leave a link with a spammy anchor text, I'll help you [worst php web application development services company in india](https://your-business-fuck-you.com)
Unless you "design for performance"
Laravel, Symfony, and ZF consistently perform poorly compared to other frameworks in "raw throughput" in benchmarks. Laravel and Symfony seem to be mostly interchangeable in performance. 
I have edited the main do you need more? 
The correct choice is not use a website at all. Or we just accept that there is no perfection and do a final decision in which solution we trust. If you like Laravel/Lumen more than ZF or Symfony.. well, do it! If you and your team can work better with that way, then there shouldn't be a force telling you to use something else. There is no sense in forcing someone using CakePHP if you are a master grade certified Zend Framework Guru. You just wasting a lot of potency to something meaningless. Frameworks are just weapons. Tools to make your way. These wars which one is better is like which god is better. It doesn't matter at all! If your life works better when you trust in Odin, well then Valhalla may be your destination. All this senseless wars for nothing.. "uhh my imaginary frameworks are way better than yours" Btw. I am not pointing at anyone,.. just wanted to post this down somewhere~ 
does not seem to exist the optimize command - please tell me I'm wrong, but don't tell me to start installing modules , I want to know if the base is stable and scale-able, not if i can install modules to handle stuff.
It seems lumen clears the headers, and content not responding back. Apache log has no errors, same with PHP. JMeter states Non HTTP response message: Cannot assign requested address (Address not available)
Your readme and website (link in repo description) have discrepancies: * Readme says PHP 7.x is required, website says that PHP 5.3 is required * Readme assumes composer autoload + namespaces, website suggests explicit `require` + no namespaces &lt;Insert here mandatory comment about lack of tests&gt;. Overall looks interesting, chaining calls is a good idea. A comparison with other libraries (like [Imagine](https://imagine.readthedocs.io/en/latest/)) would be nice (eg. why should I choose your library for my next project instead of Imagine/etc)
Can you try benchmarking with something like [Siege](https://www.joedog.org/siege-home/) and see if there's a difference in stats?
This is terrible, Why are providing a code generator when you don't even know basic php or SQL
Frowned upon by who? What projects/standards frown upon using camel case in PHP?
[removed]
Just to clarify - are you using the Expressive version of ZF3 or the MVC version? Or just a single routing package? What exactly does your use of ZF3 entail?
I really hate information disseminated by video because you have to digest the information at the pace dictated by the speaker. In this case, the pace of someone with absolutely no idea what a code review is.
There are some issues with your setup, you should not be getting back any errors. For a more thorough benchmark you can check out https://www.techempower.com/benchmarks/ The important thing to notice is that once you start talking to the database in each request the difference is not that big.
wtf, psr-1/2 states 'Method names MUST be declared in camelCase' what are you a wordpress developer or something?
"Hardcoding values instead of making them configurable" - on the other side using obfuscated xml as another language instead of writing readable code in what you already know
Sure, AB does not create any errors either, but it also does not count fully disabled/empty responses as a problem. My point is it's okay you are suggesting a benchmark site but I'm using the same test system as my company uses for their other sites. Basically the same as Amazon if you don't know Rakuten. And since it does not create the same error on other frameworks that is even faster or an empty html site, something tells me it's not the setup.
The standard skeleton application actually tho with empty layout and only outputting the variables in the layout and template. Laravel and lumen outputs only echo and breaks more or less, not even using the template system as this gave the fastest results. Both are using their routers. On another note, even my system with complex regex routes and database access in zf3 is able to fire pages of in single threaded mode at 0.006s. (still testing more, and testing Lumen more, though my lumen results continue to be bad) Yes it's the expressive version I'm testing but I'm not really using it though it is activated.
When it comes to OOP, SPL is doing the same too: see http://php.net/manual/en/class.arrayaccess.php
Yep, make sense to use set because it's an assignment (figure type)
If we are talking about http://php.net/manual/en/class.thread.php. It has one big problem. It uses php serialization to pass data between threads and makes it less interesting. You cannot pass a database connection or any other resource, serialization takes a lot of resources. It may not work out of the box for objects and you end up dealing with custom serialization rules here and there. Practical example. You start a Symfony app in main thread and then you'd like to pass the container to child threads to do stuff. You won't able to do that. I'd suggest to use message queue like RabbitMQ. Set a pool of consumers, split the work in chucks and tell them to process them. The context is isolated, easy to scale Here's just an example. The fos:elastica:populate command may take a huge amount of time on big data sets. That's because it process stuff one by one. You could immensely improve performance just by doing it in parallel like here: https://github.com/php-enqueue/enqueue-elastica-bundle
This. Every time I read anything that is more than about 4 or 5 rules, I think it would be better to call it "here's everything you need to know to completely know this thing"
Is the question how to do multiple requests to the API in parallel or how to parse the resulting data as fast as possible? What of that takes 4-5 hours?
Not a technical response, but you are awfully aggressive in your post. This is what people mean when they talk about all the poison and bad attitude in the php community. What do you have to "vent" about? Did someone stab you in the balls and steal your girlfriend? You ran some tests that came out unexpectedly bad &amp; counter to what most people say. Maybe a better approach would be to say "I did my own tests on a production machine and results were nowhere near what I expected. Can anyone explain this, or have similar results to share?" Is it even remotely possible you've made a mistake somewhere, or are you dead certain people need to "stop fucking hyping this crap"? As a programmer &amp; engineer, when I see something I can't explain, it piques my interest to find out why, not makes me think "well, this is a bunch of shit". Just something to think about. 
I'm sorry, it was not meant to be aggressive, just direct. Tho this is after a week of testing many possibilities. Thinking back I should have said that. Basically I wish somebody stabbed me in the balls lol. Also I'm a little tired of many programmers/engineers as I'm meeting more and more who calls them self engineers and programmers. In my world a engineer know good architecture and good code structure, but most is coding the same was I was when I was 12 yr and then start hyping their skills. Basically use bad architecture and create bad code is fine by me, but but when calling themself good... Please no.. So when a "big" framework comes along like Lumen and pronounces itself fast then I am feeling a like someone stabbed my balls lol. Basically don't proclaim something you are not.
You miss the point. Make damn sure you aren't making any mistakes, *confirm your results against those of others to see if you are an outlier*, and then accuse it of not being what it says it is. You got things in the wrong order.
I've tried to use pthreads to build a batch processing system. The documentation is terrible, the docs on php.net are all for pthreads v2 which is now deprecated by v3. v3 is almost a rewrite with no backwards compatibility. Even the examples in the v3 source are still v2. I persisted and spent ages reading almost every github issue and even debugging the extension itself while attempting to design my solution using pthreads. Ultimately I gave up and threw away 2 weeks worth of time in favour of spawning child worker processes that listen to a queue (disque). If you go down the pthreads route expect memory leaks from various extensions, segfaults (don't pass handles between threads), and frustration over lack of docs or help from the maintainer. 
You might wanna brush up, camel case is the preferred method and has been for a few years. 
I'm a PHP noob. I just want to ask what kind of stuff I can do with it. I'm currently developing a website and for a big part of the project I want to allow a user to create an image to share an action they took on my site. The action is basically placing a bet and I want the user to be able to share the dynamically created image on social media. Can your library help me somehow with this? Think of the old forum signature images that gamers would have, they displayed info about their score in a game etc. 
It's a PSR and is pretty much the defacto style in pretty much any modern PHP application
I don't think it's aggresive. It's kinda funny! Well, I'm in a good mood today.
Would queues with a variable number of consumers be a solution?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Any webhost that works with PHP and looks good. Or as I prefer a vps with nginx or apache2. Digitaloceon and vultr is pretty good.
Yes! with VPS or any managed hosting I can do that. what about the caching and performance majors?
So why did you decide to put time into developing your own library instead of just implementing Intervention Image or some other library? You had to have some justification for choosing to do so, unless it was just for fun. If you're going to promote it, even if it is only a pet project, you should be prepared to answer the "But why" question that is inevitably asked. It seems like you're saying it is a smaller library that is more readable (maybe a simpler API?). So when someone asks why they should try your library, that's what you tell them.
I've had him ~~tagged like this~~ tagged as a not very constructive person for a few months now, he just keeps reaffirming my decision.
Will you go for managed? Then you need to find someone who manages your needed services, if you go for a VPS, you can do it all on your own. Basically: http://symfony.com/doc/current/reference/requirements.html Caching and Performance: Symfony is fast enough in Production Mode in my opinion. Its not like a static html page of course but still pretty fast. If its not enough, you can go for: Memcache / Varnish / Redis / ... What ever the problem is you have to solve. But caching/performance is something you do not want to challenge before the bottleneck is clear.
In that case it's probably not your code that will smell less, but your participation. Too much obsessing over code perfection can leave you unwilling to commit any code, and ultimately we're here to solve problems, not create art. And even artists have to ship. Technical debt is inevitable. And as a developer, you see one part of a problem really well, but ultimately what you're doing fits into solving a larger problem that other people are paying to solve. You absolutely have the professional responsibility to warn them of the tradeoffs in shipping fast versus good, but ultimately whoever is paying gets to make the decision. Now, if you find yourself having that conversation over and over and never get a chance to pay down the technical debt, that's a job smell, and it's time to update your resume and start looking.
&gt; If the library doesn't fill you expectations I don't know if the library fills my exceptions that's why I'm asking what the advantages are there over an established project like Intervention Image. You must of had reason to create this library because Intervention Image and others didn't reach your expectations. What features or problems has your library solved where the others fall short? Like is the watermarking API better? Is the image resize more performant? Doe's it offer access to more image libraries that the others don't?
Laravel Forge (https://forge.laravel.com) might fit your needs. Links with your DigitalOcean, Linode, or AWS account and gets you the latest PHP, Nginx, etc. all installed, push to deploy, etc. We have a preset for Symfony apps when you install a site so that Nginx is properly configured for Symfony.
That typically makes sense to me. what about the permission setup because in development I need to reset permissions for **/var** folder.
Aren't they big companies which use Laravel in production? I mean, literally, what else could "production grade" mean?
forge is looking interesting to me. I opted for Cloudways managed hosting or sensio cloud but surely I will check forge too. what are Nginx configuration you setup for Symfony?
Yeah DigitalOcean looks good to me 
&gt; I created this library to deal with common image tasks What common issues did you have that Intervention *did not* solve?
[removed]
&gt; What common issues did you have that Intervention did not solve? Sure it can sove many issues. But Need "full-features" image API library for crop and save one image?
&gt; I've just been using Doctrine DBAL in the repository implementations. Simple, flexible and does the job well. Sure; [Aura.Sql](https://github.com/auraphp/Aura.Sql) and [SqlQuery](https://github.com/auraphp/Aura.SqlQuery) also do the job well, until the job becomes tedious ... &gt; Where do you see the benefits of adding an ORM there? ... as when you have several relationships to manage. Copying from &lt;http://paul-m-jones.com/archives/6568&gt;: &gt; I figured that it would be enough to use a Table Data Gateway on top of Aura.Sql and Aura.SqlQuery to retrieve rows, then map the rows over to domain objects. This was fine, for as far as it went, but the problem was ârelationships.â Oh dear Codd, the relationships. &gt; &gt; Selecting one or many objects from a single table was no big deal, but doing multiple selections from multiple tables and building up the selection statements for those relationships was a tedious, tiresome, and time-consuming burden. (Wiring them up in memory once theyâd been selected was not too bad, given Aura.Marshal, but it was still more effort than Iâdâve rather been expending.) &gt; &gt; So it all âworked,â but it was just not satisfying at all. So, I've done this work both with and without an ORM, and I have to say it was a lot easier to iterate toward building a domain model with it, than without it. At least, it has worked that way for me; YMMV of course.
[removed]
linode. We get to configure everything, which allows us great freedom, since we're a small shop.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Sure that everyone has "right to affirm" what seems best...
&gt; it looks like pmjones was suggesting using an ORM and then still doing the mapping to the actual business objects manually Yes, that's an accurate assessment. I say that mostly because it is tough, at the beginning of a project that *seems* simple, to know in advance where the complexities will arise. Starting with a dumb persistence object for basic CRUD lets you do simple stuff quickly, and then as complexity appears you can iterate toward using the dumb persistence objects to populate the DDD entities &amp; aggregates. EDIT: I presume you can, at some point, completely drop the ORM in favor of custom queries directly to PDO, but I myself have never gotten that far. ;-)
The docs on php.net *were* outdated - I have mostly updated them to target v3, though still a little more work is needed. I've also written an [upgrading article](https://www.sitepoint.com/upgrading-pthreads-v2-v3-look/) to help those who are looking to migrate from v2 to v3, as well as an [introductory article](https://www.sitepoint.com/parallel-programming-pthreads-php-fundamentals/) for those unfamiliar to pthreads (v3). So there are resources out there now on this. And, of course, StackOverflow should be used for any further questions you have, rather than asking them on the pthreads repo...
&gt; I did tried to simplify (in this API) Okay then why not just say that instead of having a passive aggressive tone for no reason to a genuine question? If that's the goal then this library (for me) fails in its objectives. A common task on my website is to open an image from disk, resize the image to have a max width of 300px and then save the image back to disk as a new file. Your API &gt; $avatar-&gt;load('image.jpg')-&gt;resizeToWidth(300)-&gt;save('new_image.jpg) Intervention Image &gt; Image::make('image.jpg')-&gt;resize(300, null)-&gt;save('new_image.jpg); Feedback: For me the library offers no simplification yet sacrifices features. You are also locked in to the GD Library with no option to change it
https://www.tomasvotruba.cz/blog/2017/04/14/3-symfony-and-laravel-patterns-that-make-code-easy-to-extends-without-modification/#don-t-forget-to-have-final-word Classes can't extend interfaces, might want to update that example.
To create the object I just use the constructor. To read out, either getters or (on the current project), I store an `EventStream` in the entity which contains all state changes and then gets used to save the events in the repository and update the db tables.
I'm not sure I understand. I am curious what features you've implemented into your library that was not possible in Intervention. If you did no research and never used Intervention then fair enough... (not a great sign), however if you cay say "I made this library with X/Y/Z which Intervention does not have", then it's a bigger selling point. Because right now, it doesn't sell itself.
&gt; In both examples, I don't see sustancial difference in the way of it can write the code So my feedback: &gt; For me the library offers no simplification Which is the main selling point of your library. So as above... It's not for me
 $message .= 'Attachment: '. $this-&gt;improveCode(); /** * Improve our code example */ private function improveCode() { // TODO: improve the JobOpportunity package } git commit -m "Refactored method to correct spelling"
Threads are a pain, both to develop correctly AND to debug when things go wrong. I just converted an old threaded java app we use for processing some data into a queue with a pool of php consumers. I used gearman + supervisor to keep my php consumers working in the background. Depending on the size of the instance I can vary the # of consumers supervisor runs I originally wrote the scripts to work with AWS Lambda, but too late in the process I saw Lambda only works with RDS inside a VPC (and we havent migrated yet). Once we do move to VPC I'll be switching it over to Lambda so we don't have to keep a "job server" running all the time and I'll only have to deal with Lambda throttles/dead letter queue to retry parts. Still its probably worth the lesson learned, b/c locally I can have gearman handle my dev for more rapid dev/feedback while flipping a config switch I can have it shipped off to AWS Lambda
Rule 36. Memorise the last 35 rules.
Like others have said, it's probably better (and easier) to switch to a worker/queue method. I worked on a project that processed between 200 - 500gb of raw data a day and it was not a problem at all in php7.
Might be wrong, but digging in our department that was working with Laravel, and now is working on using lumen, actually said they had to do a lot of hacky stuff to get the speed. So I'm wondering if the ones you mention had to do the same?
And then I tell you that there is problems when you hit it harder, searching the internet shows the same. It's fine you are a fortune 500 company, an you have an in-house sales type app, but how much is it used?
Keep it civil.
It's be super neat to setup some kind of private repo that applicants could clone, add their details, commit and push in order to submit a resume or whatever. Obviously it's have to keep other applicants info safe and all that. I guess you could setup an API with some write only methods so the user would have to check out the code, have the know how to setup/build/compile and run it to submit a resume into an endpoint that saves it for you without having any get functionality. That'd weed out a lot of people. Maybe that's good, maybe bad. If they weren't familiar with your particular tools it'd scare people off even if they proficient in other tools. I dunno just typing out loud. Proficiency with basic version control has become one of my mandatory entry barriers.
Both of your proposals do seem better. And I'll be honest. I don't like fluent interfaces with immutable objects. I don't even like `$figure-&gt;withRandomAttribute('blah')` because one interpretation of that $figure is a collection and that `withRandomAttribute` is supposed to filter all figures with randomAttribute set to blah. I post more about that at https://www.reddit.com/r/PHP/comments/5pb7cv/3_benefits_of_using_immutable_objects/dcq92n1/ Just because something is all hip and trendy, now, doesn't mean it'll endure, long term. I guess we'll see what we see!
Others have said it, I'll also say it. Using a producer/consumer or worker/queue pattern is the way to go if you can do these calls in parallel. We use a producer machine to throw hundreds of thousands of messages on a queue, then we use auto scaling to handle the workload. We also use pcntl_fork to handle multiple messages on the same machine instead of using threads.
I did put ?! After sham, but hey XD. Personally as I see it, and as I have learned/discussed with a consultant that works for Novo Nordisk and MÃ¦rsk Laravel does not have the architecture or the speed to be a proper Enterprise framework, and it seems lumen doesnt either. On the other hand it probably good enough for a few simple things that will never go legacy, and does not have big teams working on it. From my research into frameworks, Laravel has a very bad OOP structure, with lots of hidden magic etc. That makes advanced stuff hard to debug. Thereis a reason (I know it is and mainly frontend) that software like CKEditor is going away from so-called black magic.
It really depends what the bottleneck is. Have you done any profiling on that? It could be the HTTP requests, it could be disk IO, it could be CPU, or several of them combined. Have a look at xdebug profiling with a small sample set, find the bottleneck and try to fix the specific issue at hand. 
You should set it up on a private gitlab repo so that applicants can fork it and push to their own private repository. You'd be able to view their code and track their progress a bit better. The example should have more context though. There are a lot of things that should be changed that the applicant may ignore since they are only given a small piece of the hypothetical puzzle. For example: this class screams abuse of inheritance when it should be using an interface. Can I change that or should I expect that there are some pretend methods that rely on the parent class that have been omitted? Why isn't apply static? What would you expect the user to change?
I use objects where needed, if I have any work to do with it's properties, and arrays for straight up data. I like php because it sits in this weird limbo of languages sometimes. But I agree, OOP is just a tool on your tool box and one should know when to use it. 
As long as we're talking in the abstract nothing matters. What did they hack? We need specifics to have a real conversation. 
I will ask, tho I'm not sure I'm even allowed to talk about it. But ask I will.
I also want to point out I find it pretty fishy you're allowed to mention you use Laravel, but not mention the specific things you supposedly "hacked" in the core to make it faster for your company, even though it would not reveal anything about the company at all. I find this whole post suspicious to be honest, right down to the title.
This isn't really an open ended kind of question. Don't be lazy. Google it.
&gt; I have designed a couple of full stack frameworks myself and sold them off so I know the workload. So you must be a big name in the industry if you're selling full stack frameworks and selling them.
_My_ framework is Production grade, _your_ framework is the other grade.
[removed]
[Here you go](http://lmgtfy.com/?q=what+is+php+hhvm+%3F)
At 75,000 req/sec, why in _the fuck_ would you be considering any PHP framework in the first place? Make your life easier and just choose Golang at that kindof throughput requirement.
After making this post, this was exactly the idea I had. As you said doing so would demonstrate that they at least had some working knowledge of using version control, which is a must have honestly. 
I just switched companies recently and I came across a couple places that did something like this, or provided some kind of "test". I don't have the time to play little games like this, especially when I'm applying to 10+ places. I would pass on applying when I came across one of these. Granted, I had the luxury of already having a job so I could be more picky than others. Overall it seems like a waste of time for both parties involved, even worse for yourself as you(or someone) will have to review code from X number of candidates.
I will double check on that part and keep you updated. This was basically a rough draft that I am working on and some items were copied from an older job posting. 
You can try something I wrote and use in production.. have been using this for years. It uses forking.. I have been considering to convert it to using pthreads but havent had the time. https://github.com/jayesbe/php-process-executive
I think you could be more open ended while being more flexible. Something like giving the applicant ~50 lines of procedural code that prints something to a terminal with different formats depending on a given condition. Have them refactor. This way they're given all of the inputs, and outputs, but have unlimited structural freedom.
Because there's no middle ground? /s If you don't want to deal with XML, just create a file full of `define()`s and be done with it.
Sounds like a task for messaging queues. I've used RabbitMQ in the past and set it up with some python scripts to pull data from twitter pass to the queue for processing and then on to sub queues. Depending what your'e trying to do this portion of your project can be written in a variety of languages and frameworks as long as you have a way of passing the data to it and then receiving it back into your php environment.
If you would go that way, i would also look into https://github.com/chrisboulton/php-resque
This is a good read on the subject http://www.newyorker.com/tech/elements/why-brainteasers-dont-belong-in-job-interviews they use word problems/brain teasers but it's along the same lines as this.
Looks interesting. Why would I use this over image.intervention.io as an example?
I would also suggest you use some kind of message queue like RabbitMQ or ZeroMQ. There's also Gearman, which I would also consider if you're not planning writing workers in other programming languages.
Correct, but have many times tried to start a discussion on good architecture, and code structure. Unfortunately they just stop. I don't know if it's because 99% is coders and not programmers (according to an old teacher, coders just code where programmers know about fall points, good architecture etc.). So I'm wondering if it's just a lack of knowledge. Getting stung unfortunately often ends up giving more than the other as it's completely dead.
While I don't mind doing a small coding exam, this kind of ad feels like a company trying too hard to be clever. By all means, have a coding exam with clearly defined criteria - hopefully including unit tests - but this kind of shenanigans where I have to parse some code just to work out what you're looking for instead is vaguely infuriating. If I were in the market, and this is the ad, I wouldn't bother.
I implemented that in a Silex project a few months ago. Worked pretty well, although I definitely prefer the Laravel queue system in the end.
I find the timing of this post very suspicious as I am currently watching [his talk on Event Sourcing](http://verraes.net/2014/03/practical-event-sourcing/). Another interesting topic that I can see easily abused, but infinitely interesting. 
&gt; All of those transformations become very slow, verbose, and cumbersome when you can't just foreach() an array of data Just implement `IteratorAggregate` in your value object and for bonus points also implement `ArrayAccess`.
This doesn't really address what I'm talking about. If you have two even slightly different value formats in two slightly different entities, in two collections for this type of entity, you have to recreate one to the other from scratch, or awkwardly share code through inheritance and traits, not to mention write all these additional classes that do very little. With arrays I can quickly map one to the other using the shortest possible path: function mapVer1to2($users) { foreach ($users as &amp; $user) { $user['displayName'] = $user['firstName']; $user['fullName'] = $user['firstName'] . ' ' . $user['lastName']; unset($user['firstName']); unset($user['lastName']); } return $users; } $usersV2 = mapVer1to2($usersV1); I didn't have to implement IteratorAggregate and ArrayAccess on two classes `UserCollection1` and `UserCollection2`. I didn't have to write classes `User1` and `User2`, and I didn't have to write classes `FirstName`, `LastName`, `DisplayName`, `FullName` and painstakingly unwrap from one, wrap in the other and construct another new entity, and add it to an entire new collection. Objects are awesome. About 95% of my code is in object instances and about 5% is static methods. Everything I do is object oriented, and I love the encapsulaton, polymorphism, programming to interfaces, GRASP, SOLID, yada, yada. But when it comes to **pure data** in PHP, the value of value objects is sparse... I use ValueObjects rarely. To date the only time I felt the need to wrap values in ValueObjects is for: - Authorization tokens (I have a complex format for those) - Date and time - Money amounts (with arbitrary precision math and multi-currency support etc.)
I, too, have had some absolutely wonderful experiences with Gearman. Beanstalkd always looked interesting as well.
Makes sense. I use a similar approach.
- What is the use of rand ()? - What are the differences between mysql_fetch_array(), mysql_fetch_object(), mysql_fetch_row()? 2006 called, they want their interview questions back. Seriously though, if someone asked me this, I'd just walk out. http://i.imgur.com/UF1vQAB.gif
A better link to be sharing instead of some random medium post: https://github.com/laravel/framework/releases
Is not a random medium post, Mohamed Said is a Laravel employee.
If you need help with &gt; What is PHP? &gt; What is the use of âechoâ in PHP? &gt; What types of loops exist in PHP? &gt; What is the use of isset() ? &gt; How to find current date and time? And many many more of those questions, you shouldn't be applying for PHP jobs.
If you would like to learn Docker you could do it independently and see how you get on. When it comes to things like Docker/Vagrant I usually like to think of things as "who else will be working on this project", for example at my work we have 7 developers, if we all had our own way it would be very slow to get setup on projects and such, so we have vagrant files for each project (in the git) and this creates an environment and they never have to think about it again. For projects that just you alone will work on, then if you have a working setup then there is no real reason to change that, focus on the app :)
Absolutely! Dockerizing my local dev (not only for PHP) was the best thing I ever did. Just install docker-compose. Have a docker-compose.yml file that you can tweak for each project and fire 'em up as you need them.
Yes...using docker for local development for the past 2 years and it's great. I also use it on the staging/testing server hosted on AWS. It's fast and usually it's all contained in a docker-compose file.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help
[thats another good talk on the topic](https://www.youtube.com/watch?v=JHGkaShoyNs) But event sourcing should only be used for certain applications/contexts, while value objects should be used in any object oriented code-base in my opinion.
It's mainly caused by Composer calling the directory `vendor/bin`, could name it "executable".
I use docker. I found it super easy to learn and it solves a lot of my problems. Now my frontend-developers doesn't even need to know what is PHP, composer, mySQL, MongoDB etc. They just write docker-compose up and they are ready for local development with fully working local server. For me, as for backend developer it adds scalability and freedom of choosing technologies I use in the project. Before I switched to docker and microservice architecture I was developing monoliths and SOA apps. Now I even share some of the services across customers.
&gt; Improve your example code.. Just saying Isn't the point of the class for the applicant to improve it?
Depends on your location really
Next Retail big enough and none tech enough for you? 
&gt; I am using async request as well Are you really? A lot of people are just using CURL-multi to do 'async requests' - however that doesn't actually do async requests, it just allows you to process multiple in parallel. [Artax](https://github.com/amphp/artax/) is library that allows you to make and process requests in parallel, which is very useful when the work you're doing needs to make subsequent requests, based off the results of the previous requests. 
I have a library for collecting services, in a similar way you describe it in the 3rd point: [nassau/registry-compiler](https://github.com/mlebkowski/registry-compiler). Would you find a minute to leave me some feedback on it?
What does being in-house or outsourced have to do with anything?
For those like me who asked themselves if it was a advertisement it's not. Not at all. Quite the opposite. Let's just say it could be titled "Scott Helme reviews nomx, and it's terrible"
&gt; there's no point &gt; competently bypassing the main advantage I disagree. You're describing a best practise. To have a dockerized/vagrant local environment has other major benefits, like the fact that you can completely destroy and re-create a broken environment and you get a fresh empty server every time, with empty databases and so forth.
&gt; ok, imagine you have to add developers to your team, what will you do? With docker you just need to run docker- I use to have the same perspective. Then we started needing to grow the dev team. But even if it that wasn't the case, now that I have started using it there is no way I would go back. No matter where I'm at or what machine I am on, I can type "docker-compose up -d" and have an exact copy of the dev environment running locally. I would say at least go through the process of learning to setup your dev environment to see the benefits first hand. I dismissed it for a long time, but it really is a powerful software set.
Yeah title might not be clear I just copy and pasted from the blog post.
I wouldn't worry about it, the article looks like flamebait to me. Inheritance isn't and never was a pillar of OOP in my opinion and Encapsulation tends to work just fine. The history of what OOP is and should be is wild and hard to decipher, but I like to think everyone should just agree on what Alan Kay said: &gt; OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme LateBinding of all things.
It's easy with any paradigm to come up with problems and bad examples. I also feel that sometimes a problem is creating a giant hierarchy of objects - not everyone can visualise these sorts of structures and so again tend to not use them properly. Like anything in the real world or the virtual one, find the strengths and weaknesses of the solutions to any problem and come up with the best one at the point of making a decision - as pointed out though - next year you will probably have changed your mind and will be cast out as a heathen!
Yes...using docker for local development for the past 2 years and it's great. I also use it on the staging/testing server hosted on AWS. It's fast and usually it's all contained in a docker-compose file.
This does look like flamebait to me. Its funny that the FP fanboys are advocating as if OOP is evil and their FP is the way to solve every software engineering problem, but reality is that OOP and OO languages still dominate the IT industry. I prefer OOP myself, and I've so far failed to see any reasons why FP is objectively better than OOP. Most of the arguments/examples against OOP are characterized by the presence of bad programmers, not that OOP is bad itself. FP is useful in certain situations and some of its concepts are neat, but I wont use a pure functional language over an OO language with some FP support(ie. closures, immutables). Nowadays there are programming languages labeled object-functional such as Scala, which combine the strength of OOP and FP. I believe they are way better and more practical than pure functional languages. 
&gt; I implore you to stop projecting your own expectations on other people It's not my expectations its the exact problem Docker is trying to solve, like it or not, it's the main point right there on their own website
It's much better than spaguetti code.
I've always viewed FP and OO as complementary. They help tame complexity in different ways and in different places.
why you don't split the work and spawn new process?
Using bit operators will be quite a bit faster: function binary_explode($number) { $number = intval($number, 10); $power = 1; $parts = []; while ($number &gt; 0) { if ($number &amp; 1 == 1) $parts[] = $power; $power = $power &lt;&lt; 1; $number = $number &gt;&gt; 1; } return $parts; }
Sure, maybe, don't really know to be honest. I basically just do what I'm asked to. Maybe it's because I have 8 (9) companies that have asked me to work for them instead And that the highest suggested salary is 17000$ a month (which is a lot for me). Yes I'm a workaholic, I work from. 6:30am to 3am every day except for weekends for the last 5 years.
titles like these are dumb. you can have two protocol that are equally secure, RSA + AES
I completely agree with this. I don't get the point of using Docker if you're not also using it on a live server (and tbh I don't really get the point of using it on a live server either as it is by definition slower, even if negligibly). If you need to test on specific PHP versions then use Vagrant and replicate your server setup. It's a bit slower to start up but works perfectly well for me.
Let's take these attacks on "pillars" one by one. You can't reuse code because you need to bring in the complete hierarchy and supporting classes. That's why we have packaged libraries and defined ways to access them. Of course libraries are going to have their dependencies. That's why we have tools like Composer for PHP to help manage this. He tried to do this via copy/paste and found that didn't work so well. Wow... just wow. Inheritance is bad because someone didn't realize that tweaking on a parent class would impact the children. First off, the premise is ridiculous. Of course working at the top of the hierarchy is going to have a major impact down the road. You can't just unit test your way out of that one. Falling back to the core question of "is-a or has-a" to determine what to inherit and what to bring in via composition is your guide. At the core of OOP development that question is the clue to determine which approach makes sense, and which is just going to muddy the waters. For example, if he were to ask... is a company a document? Obviously not. Can you say a document has a company? No. You can say that a company has a document. Here is a case where you don't want to inherit, you do want to include by composition, and it's clear which object should contain what. The diamond problem illustrated could be addressed in the same way with the same set of questions. In that case the problem would be more readily solved using interfaces to promise the functionality, then letting the copier and printer implement what they need to. Encapsulation is NOT the problem he's getting at. He wants immutability of values within an object so they can't be altered once set. You can do that very thing, by using encapsulation. If you have to know that a value should never change once set, encapsulating that value behind a method can do that. It won't do it by itself, which is more along the lines of what he's asking for. His argument about polymorphism is just silly. He likes it, but because of his other points it sucks. Huh?
&gt; But does that really mean that it's impossible for it to serve other purposes equally well? No, of course you *can* use it in such a manner but it seems completely pointless (in my opinion) to add the extra overhead and complexity for no other reason than to have a LAMP stack running locally. If you're running local environments which exactly match the live server your code will be running on (which is what docker is intended for) then the value is un-measurable and yes, definitely use docker. You also get the added benefit that your server config is under source control as well so any changes made will be made every where, all devs and live servers get the same changes this is a game changer for any kind of development. &gt; my work laptop is running Windows 7 I really feel for you here, I had to use Windows on a government contract job, I lost so much productivity having to fight Windows to get it even doing the basic stuff it made me really realise how good Linux is as a development platform.
I find in some cases that FP makes it harder to understand exactly whats going on. Both have their benefits and their downfalls.
Correct, not since the government killed my mom, my uncle tried to steal all my dad's money, grandparents brainwashing my brother, my other uncle hiding that he took everything when my other grandparents died. And I got shot 5 times.
Although there are other reasons to learn Docker and if changing your local env is an excuse to give Docker a spin then by all means you should go for it 
This article needs reading. The title doesn't do it justice. I felt like I was watching wacky races while eating my cereal this morning. " oh, no way!" three times. 
It's almost like it's *difficult* to understand *complex* domains.
Flamebaity bullshit articles aside... it's good to question our assumptions about programming. I'm still mostly Team OOP but this video made me think a lot. https://www.youtube.com/watch?v=QM1iUe6IofM
80% of these arguments come from a lack of understanding of one of the most important principles of OOP: _Classes should be open for extension and closed for modification_. This DOES NOT EXPLICITLY MEAN INHERITANCE. Any argument against OOP that has to do with, "I overrode method A and now everything is f*ed!" is not a valid argument because overriding methods is modifying an implementation which should be avoided. The other arguments are just side effects of OOP and stem from the fact that nothing is perfect. I'm sure anyone else could write just as long of a useless article about why FP is bad. But that doesn't mean FP is bad. 10 min of my life I'll never get back.
I like your idea; there's a good hint about what should be worked on - it's not too broad. By looking at OP's example, my first thought was "Oh, crap, where do I start?", and a few seconds later later - "OK, but where would be an end, too?". You can go as far as wrapping an entire little framework around it, and still not be quite sure if it's enough :-E
inheritance isn't a problem if you accept interfaces and not concrete types in your methods. That's all there is to it. YAGNI. Don't decompose just for the sake of Composition. TDD is here to make sure you don't put the cart before horses. The problem, yet again, is that PHP doesn't have private classes. If PHP had private classes this question would be irrelevant.
lasania code much worse than spaghetti :(
How the fuck do they achieve DRY with one class? the consequence of DRY is the exact opposite : code modularity and separation of concern. I don't believe that blog post a single second.
It's interesting that their planned bug bounty says "vulnerabilities which are **exclusive** to nomx". With that weasel-wording they could try to deny like 99% of bugs, either arguing that at least one other product has the same problem, or that the bug has to be in their glue-code and not in an outdated or misconfigured third-party component.
I use Fedora for development with PHP setup on localhost and vagrant + puppet for devops work. I use a server setup with Homebrew when working on my laptop for improved battery life. I can't wait to be using Dockerfiles instead of monkeying around with puppet but I'm reliant on someone else to make it production ready. I'll definitely use docker a lot more for development once I'm pushing docker images to deploy instead of building RPMs. I don't need my local dev environment to match production since I've got Jenkins setup for auto deployment on a test and staging server. 
I've been using docker for all my projects for the past 2 years. It think it's the best thing ever when it comes to backing services. You can spin up the whole ecosystem in a single command and know that it will run just the same in production. There are a couple of limitations tho. 1- Command line tools are hard to run from docker environment. Say you want to run composer, then you have to have a container with composer. This is most likely not your main php container because you don't wan't it installed on your prod machine. So you might be tempted to use a specific docker image of composer. Once you tie everything together, you'll end up with a working solution that is hard to use/reuse across projects project, and that is slower than running it natively on your own box. 2- Combining projects / packages. Say you have a chain of dependencies. You'll often want to work on your package in isolation. If you don't have a local install of php, that means each of the package requires it's own docker environment to get tests running. While this is not a problem in itself, it's often more complicated to do this than to use a local php installation on simple packages, and keep the docker setup for fully featured apps. 3- Debugging is now harder. If your IDE has to connect to the interpreter, then you need a way to tell it to use the interpreter within the container to execute the code. Up to recently, phpstorm was not able to do this. I know it's on their roadmap tho. I am not aware of editors which support this. With that being said, I ended up having a fully functionnal docker environment for all of my repos. It has the advantage of being easy to install for anyone that joins the project. It's also amazing when it comes to CI. But I don't use all of the features myself, I still use my local php interpreter that provides me a bunch of shortcuts and features that makes my own workflow smoother.
Using Docker was one of the most beneficial and productive things I did in the past couple years. I work a lot with different projects and I often try new tools within these new jobs. Docker helps me a lot with environment setups also environment sharing among team members and machines especially because my OS is Windows, so...
### Previously: [What would you pay to make 27% of the web more secure?](https://www.sitepoint.com/what-would-you-pay-to-make-27-of-the-web-more-secure/) (Sitepoint) Some facts: * Funds collected will be escrowed with [Jim Denaro](https://twitter.com/CipherLaw), who previously collected funds for #isTouchIDHackedYet. * Funds will most likely be used to hire [Kudelski Security](https://research.kudelskisecurity.com/2017/01/16/when-constant-time-source-may-not-save-you/) (link goes to a blog post worth reading to get an idea of the talent they have access to) * Neither me nor my employer will ever see a dime of this money, it's all going to better the community Some speculation: * If sodium_compat passes the audit: * We can push to get WordPress to adopt Ed25519 signatures for their automatic update feature (currently: no code signing, so if you pop their update server, you get RCE on 27% of all websites for free) * Drupal is immediately interested in automatic updates (Ed25519 for auto-deploy, and X25519xsalsa20poly1305 for uploading SFTP credentials so Drupal's security team can deploy critical patches for some customers / use cases). * Joomla will likely ship with JCryptCipherSodium in 4.0 (and possibly 3.8?) * Magento can move off their [broken legacy crypto](http://www.openwall.com/lists/oss-security/2016/07/19/3) * ...and all of these projects will be able to interoperate, since they're using the same crypto * If sodium_compat fails the audit in a recoverable way, then the bugs will be fixed. (This is somewhat normal for audits.) * If sodium_compat fails the audit in an unrecoverable way, then we have solid proof that it's impossible to write secure cryptography code in PHP. (/r/netsec trolls and their FUD do not constitute solid proof) * This is the worst case scenario of an audit, but we still learn a lot about the long-term security implications of PHP's enormous market share and can have positive discussions about improving the state of affairs. No matter the outcome, as long as the audit is funded, OSS written in PHP will be more secure in the long-term. What's uncertain is if they will be secure in the short-term. The absolute worst outcome here is that nobody contributes (especially the large companies that make their money off PHP). So don't let that happen.
Good catch, thanks! Fixed: https://github.com/TomasVotruba/tomasvotruba.cz/commit/0999e055a51eeb2fd34309dd30a7ca20a1132b77
That's great you came with the same idea. I'd be happy to check it. I wrote to the issues. How do you use it now?
Is Vagrant what's keeping you from using native Docker support on windows 10? I was bummed when I realized that VirtualBox is incompatible with Hyper-V, meaning no Docker and VB at the same time. But Docker has won for me so far.
And v5.4.21 already released because the v5.4.20 broke some stuff...very well tested I would say.
I use docker for mac. I only need one machine, and docker's docs recommend using docker for mac instead of docker-machine in that case. I am aware of [issues like this one](https://github.com/docker/for-mac/issues/689) with docker for mac, but haven't had the time to sort out some stuff with docker-machine to get things up and running *(ie. configuring port forwarding through virtualbox, the NFS thing you mention, etc...)*. Maybe it's time well spent to avoid the performance issues docker for mac has?
With the advent of module systems being implemented, and higher order programming facilities added, OOP is provably useless. The only feature I like about OOP is the convenient method call syntax. I would invest time in Haskell. JavaScript is quickling evolving into FP practices, and less and less of the OO features
Debugging is literally the same as any other php app and there's nothing special PHPStorm or xdebug needs to support to debug a container. I do it every day. 
I have never used docker for mac so not sure how slow it is, but at least on my mac, docker-machine is really slow without nfs. If you use virtualbox, docker-machine + docker-compose, there is nothing you need to configure. Pretty much install all of these and start using. 
I use vagrant and have a shared folder to my local dev directory. Works great.
&gt; C++ gets this right in most of the standard library by using small objects with few methods Methods are there because C++ lacks a proper module system, only reason "methods" exist here. UCFS will be coming to C++ one day.
You should try http://docker-sync.io/, it give a significant boost to performances
Agreed, I like AR and Laravel, but have read doctrines documentation and it looks like the ORM is stable and works (and clearly, it does). Even with Laravel, what new ORM features have been released in the last two years (aside from syntactical sugar)? An ORM doesn't need to evolve at some rapid rate because a database is a database and not much ever changes. What more do you need than a pragmatic approach to accessing and manipulating your application's data? 
&gt; could name it "executable". This is standard [unix convention](http://www.linfo.org/bin.html) for executable files. So you could for example do export PATH=./bin:./vendor/bin:$PATH and just use `phpunit` for example without any thoughts of where it is located.
This doesn't seem like a good fit for PHP.
Just to clarify - in 5.4.20 a new feature was added (Queue Prefixes). It turns out they had some unexpected side effects (there were some tests, but obviously not enough). This *only* affected people who tried to use the new feature in 5.4.20. No existing functionality was broken if you did a composer update and did not try to use the new feature.
I think the idea is you can then "subscribe" to the medium article to know of updates. All Laravel related releases across all repos will be posted to the one medium account, giving you just one place to know of updates. So rather than have to watch 4-5 different `CHANGELOG.md` in different repos - you just watch the one feed.
Hahaha..wow. I'm impressed with how far he took that. I thought it looked like a cheap piece of crap as soon as he took it out of the box, but he went all the way! Even tried contacting them knowing full-well they would skirt the issue and/or have no idea what he was talking about.
Well, dying doesn't mean dead. It's about degressive development in last 2-3 years. Look at Symfony, Laravel, Eloquent. Look at issues, PRs, blog as well. Or put in another way: what recent features do you like?
Instead of writing a new reply I'll ask that you read my comment again as I've addressed everything you just said. Your only metric for labeling something as 'dying' seems to be a lack of recent features, which makes zero sense. 
Then let me raise the question: How does phpstorm knows which container to use and which interpreter within that container to use?
Your only metric seems Java and status quo. I've just better experience with software that evolves periodically. Both implementation and maintenance. I live in evolving world of software, where more adaptable always wins. Doctrine is dying for over 3 years, just now I've come to point to share with others, before people start vendor locking project to bad software just because it's the only one here.
well in your example I think you should just rename the class to not include the interface name for the example's sake. Since you still want to explain why you don't want to extend in this situation.
Hi, I never mentioned Java and you're on an alternate account. Honestly, you've done nothing but avoid any of my points and refuse to answer any questions. I really don't see the point in continuing this.
Dictionary attack. If the password is that stupid, it doesn't really matter how good the salt is.
Totally. I've always used that sentence since the day someone asked for a formal license, one day I found about the [WTFPL](http://www.wtfpl.net/) but I felt it was too much :) 
&gt; and changing it is allowed as long as the name is changed Yea major flaw there. 0/10
Lmao.. what the fuck are you doing that makes you re-build your app constantly? You should have to set up your dockerfile (or docker-compose file) ONCE and then be done with it. Why are you re-creating them all the time? Even if you switch databases you shouldn't have to re-build.. all you have to do is change the env variable from mysql to postgres (or whatever you are switching to) Docker caches your build steps for you.. so you should literally start and stop in seconds.. Please don't tell me that you are re-building your entire image whenever you make changes to your source files..
How code signing is going to help if a bad actor takes over WordPress.org? Honest question. 
&gt; How code signing is going to help if a bad actor takes over WordPress.org? The key used to sign updates should be kept offline with trusted developers. If an attacker takes over Wordpress.org they could push a malicious update but all Wordpress instances running that check the code signature would not install the update. Taking over Wordpress.org would still be. very big deal but at least they don't instantly compromise all existing installation that have auto-update running.
Your joke is cool ! The downvote less :(
&gt; evolves periodically Please read #6211 tiket in repository. This is what "evolution" is. And yes, evolution can be slow.
We've tried craftcms recently as a wp alternative and it has some very nice features. Sadly the MVC system isn't all that and a lot of logic still ends up in the templates. Also their version of ACF is not ACF, which sucks. Also wanted to take a look at decoy, which is basically a plugin for laravel to add a cms, but haven't had the time yet. 
[removed]
You both are actually missing a very important point: boolean, integers, floats, strings, â¦ **are** value objects. It is true that we cannot use them like real PHP objects (e.g. `$string-&gt;length()`), but they offer all the same properties as value objects do in PHP 7: 1. We can type hint them. 2. They protect their own invariants (to some extend, beware the coercion). 3. They are identified by value and not identity. 4. They are immutable. In other words, if you need a signed 64-bit integer and you can be certain that your PHP executable is 64-bit, `int` is the way to go. Similarly, if you need bytes without any character set attached to it, `string` is the way to go. The problem with the suggested _custom validators_ is that they usually lead to code that is actually performing slower. Simply because you need to revalidate everywhere if the chosen type does not ensure validity. `string` is most probably the best example. People are always treating it as if it is UTF-8, however, there is absolutely no guarantee that this is actually the case. This does not matter much if you use it in a pattern matching context (e.g. retrieving a service from the container), but it matters a lot if you are dealing with a user supplied string that will be inserted into the database. It also matters a lot if we want to perform certain actions on that string. Using the various `mb_*` functions everywhere where appropriate might be faster from an execution point of view compared to wrapping those calls in a dedicated object. The cost to change such calls for whatever reason is extremely high. This gets even worse if you are working in really big code bases with many developers, as we at trivago have it. Particular people have a better understanding of certain domains, for instance about UTF-8 and string handling, while others do not understand all the details about that. Having those people implement it once with an easy to use and a comprehensible API will solves the problem for everybody. Requiring everybody to re-implement that logic, or calling the validators at the right point on the other hand will have a single result: bugs Performance has many faces and DDD aims at solving problems of big domains with high complexity and many involved persons. It is not meant for high throughput number crunching jobs. However, OOP is not a good fit for such use-cases nor are high-level languages like PHP. **TL;DR** The overhead of simply wrapping data in objects is huge. The reduction of complexity, bugs, and performance by performing a validation once is huge too, and easily compensates the other. Definitely not in tight-foreach-benchmarks, but in huge complex systems with many involved parties that is meant to last for many years to come.
Such mapping tasks always happen in architectural boundaries (user facing or storage facing), and one is dealing with scalar or compound values there anyways. However, this would be the point where you actually want to transform those values to value objects to ensure that your actual domain does not need to care about such trivialities. Of course, if you have a very simple domain where you just read data from the database and directly display it, who cares, YOLO. However, if your data is going through a complex system where various components are going to interact, things change.
5.6 has security support until December 2018. There is no inherent security issue with 5.6 just because a new version is out. In fact, it could be argued that a security patch only version has security advantages since new functionality and changes are where most issues are introduced.
Legacy Responsibilities Effort Thats why shared hosts stay behind. Even as a day to day PHP developer who builds systems on frameworks like Wordpress, Drupal and Laravel. We stick to 5.6 for now, we'll be moving to possibly 7.1 in less than 12 months.
So what are you asking then? They need to support Legacy systems, imagine in-place updating all PHP4 servers with PHP4 code to 7.1. Do you expect it to work? If a shared host does that then think about how liable they are to losses to customers? I understand what you are trying to get at but thats a perfect world situation you are thinking of. Not a realistic one. Believe me, I was young once! And I wish it was that easy but if the client does not care even after you tell them they should consider updating. Then you can only say, I told you so.
The salt is md5 hashed so has a possible 32 to the power of 16 combinations. This might sound a lot but it isn't by today's standard. Also SHA1 has proven collisions. There's simply no reason to be using such hashing methods when there is built in options for bcrypt and people shouldn't be using any other method and certainly shouldn't be making their own salts. I have a full write up here in more depth if anyone is interested http://mstd.eu/index.php/2016/07/01/how-to-correctly-has-passwords-in-php/ 
Please god no.
Sorry I don't have any experience (in the last 6/8 years) with Windows or Mac and what they use. If you're interested knowing how its achieved then take a look here: https://linuxcontainers.org/ mainly at LXD as it seems to be replacing LXC. I believe docker has a LXD/LXC driver as well so if you don't want to directly develop docker for cgroups (LXC is much easier to work with) then you can use a the LXD driver.
Yes at some point you are absolutely right but it's only a year left what they will do after 2018? still residing on PHP 5.6?
I am just working on a react project where the team working on the underlying framework is all into FP. The code is really hard to read, it is overcomplicated, it is slower than with standard approaches, FP libraries are used all over the place even for simple constructs..they will not do an "if else" but import an FP library and use an "if else" replacement just for the sake of making everything FP..so my point is that yes it is super cool to do everything in FP but the cool factor will not finish your app, make it performant or keep it maintainable. FP was here before OOP and it proved to be a very bad choice..today we have very performant hardware and multiple cores/threads and there are FP languages which can leverage from FP's immutability approach and use the hardware at its best..but still for any common purpose FP is just slow and messy
I don't know what your beef is with Vagrant. I use Homestead to develop using Laravel. You can totally develop WP or any PHP based CMS using only Homestead.
I have no beef with Vagrant, I'm one of its most [staunch advocates](http://www.sitepoint.com/re-introducing-vagrant-right-way-start-php/). I have a beef with the way Symfony works on it, but luckily [that looks to be changing soon](https://twitter.com/weaverryan/status/858297901101010944). In fact the only reason why I made [Homestead Improved](http://www.sitepoint.com/quick-tip-get-homestead-vagrant-vm-running/) was to make it even simpler to use, so that people don't have to have *any* runtimes installed on their host OS. It's the Vagrant VM I use for 99% of my projects. Why do you think I have a beef with Vagrant?
Vagrant doesn't work well with every hardware/software combination.
I just started with statamic. If you like Laravel, you will like this. https://statamic.com/
There are the things I need for a CMS: 1. Multilingual support (WPML is a POS to work with) 2. ACF with repeater 3. Form builder (nice to have but not a deal breaker) Grav looks interesting. I have never used a flat file CMS before. I know you can't have contact form in Ghost but Grav looks to not have that limitation. 
How about Bolt? https://github.com/bolt/bolt
[Concrete5](http://concrete5.org). Besides a clear mvc architecture the CMS core contains version control on pages and files, advanced permissions model, user&amp;group management, workflow, multilingual, conversations model.
What happened is that the author opened an issue, did not get immediate satisfaction and thus posted a tantrum article. Really kind of sad.
I have this alias set in `.gitconfig`: fixlock = ! git checkout --theirs composer.lock &amp;&amp; composer update --no-scripts &amp;&amp; git add composer.lock
Interested in this thread, just asked a slightly similar question in the symfony sub. https://www.reddit.com/r/symfony/comments/687r5l/cms_recommendations_for_getting_started_in_the/ I wasn't aware of vagrant issues, I don't really understand the problem from the link you shared? I use [drupalvm](http://drupalvm.com/) every day with drupal 8 and have never had a problem? Also, I can understand your issues with Drupal, but 8 really is a massive step forward imo.
I've been using Concrete5 daily since 2012. I couldn't imagine using anything else. It just seems to be the best multi purpose cms. 
I might have confused Vagrant with Wordpress in your post. In which case, I've got nothing to say :).
Huh. This is a recommendation I don't see often. Is it not full of tech debt baggage due to age? How's its release cycle? How up to date it it with modern practices? (tests, separation of concerns, NIH..)
Nothing wrong with Symfony, but the Sulu team has learned from Drupal's (and other CMSes) mistakes and have started from scratch with best practices in mind, so if I went with anything Symfony based, I'd go with that instead of Drupal or eZ Publish.
I'll have to check DrupalVM out, thanks - anything by Geerlingguy carries a lot of weight in my book, that guy's an Ansible master. Perhaps it'll contain something I can scavenge and plug into [Homestead Improved](http://www.sitepoint.com/quick-tip-get-homestead-vagrant-vm-running/) for better Symfony support out of the box.
Are they mistakes, or are they design decisions? You're working with CMS's, which have to combine pure data with multiple languages to render out a webpage. Every method of doing that, so far, has different suitable use cases. There is no such thing as a CMS that will do everything you want. Just being able to have a good editor experience by itself is extremely diffficult. Being able to have dynamic data views and creates data entries and pages based upon other data is also, difficult, but Drupal 8 pulls it off nicely. I think you need to not look at this from just a perspective of what frameworks are used, but what the CMS is actually capable of doing for your needs.
Such programs' output is the most boring display in the world. Given all these stupid script kiddies bombarding your site with exploits from lists made in the last century like looking for vti_bin or Wordpress admin, this program will give you tons of useless garbage. If you want a security test, there are dedicated testers. But looking at such a program's output is just a waste of time.
Same. It would be overkill to use it for anything more, I think. At least at this stage.
What makes you like D8 over Concrete5/October/Bolt?
If it is a RHEL based server it could be that they have PHP 5.3 LTS which they expect to support till 2020. I believe CentOS 6 does this for that exact reason. 
Depending on your business it can lower costs of servers needed to perform the same tasks. Does to cost investment to get there however fit? That depends strongly on the company and useage of PHP. 
Few years ago they did a major overhaul adding symfony, namespacing, etc. It was a painful upgrade, but very well worth since it's currently not full of tech debt. Up to date with modern practices; yep; dive into it i'd say. I remain impressed how Concrete5 keeps innovating through delivering stable/professional core elements, and simply lets the community take it into all kinda directions for the wider audience. Check out the Express feature for example.
Yes there was an entire program about it on TV today. Available here for UK IPs: http://www.bbc.co.uk/iplayer/episode/b08p1nts/click-29042017
&gt; Inheritance isn't and never was a pillar of OOP in my opinion While I agree with you that the article does look like flamebait, I do disagree with you on this statement, Inheritance is a massive part of OOP, enough to be called a "pillar" (whatever that actually means). Composition over inheritance is obviously still the better way to go but that doesn't remove how powerful the concept of inheritance is and how central to the idea of OOP Also notice the that guy who wrote the article never mentions mixin/traits.
I've been marginally exposed to it through our tutorials, but I'm more interested in *why* you would recommend it over all the other solutions
I left Cascade Server with the same feelings as you have about WP. In response, I've spent the last five years building (and running) an enterprise CMS to address these issues. Our site has about 10k pages, some fairly complex integrations, a broadly distributed contributor base, and traffic typical of a big company that isn't web-based or web-driven; a few million visitors a month. The system we built is proprietary and internal politics have now killed the project, so unfortunately, I can't share it. I can say that Drupal and Concrete5 were the best-seeming replacements despite concerns. I have assessed Adobe Experience Manager and SiteCore extensively. Once you get past a simple demo site, and for all of its quirks, awkwardness, and necessary customization, Drupal is still less buggy, more extensible, and has a less-frustrating user experience. I can also say that the Vagrant/Symfony issue does not match my experience. Our custom CMS was written in a different framework, but we still used Symfony (for Codeception) on Vagrant VMs without issue.
I've been using CraftCMS in an agency setting and it is definitely a contender to replace WordPress if they keep updating it. I don't like that there are no default or starter templates, you have to totally build them yourself. The custom fields system is great, and gets better with plugins, but still lacks some features of ACF. I like the simplicity though. Next version of Craft will allow you to define custom fields in code so you can separate them out from the database. Plugin updates have to be uploaded manually, that's supposed to be fixed soon. No multi-site, but that's coming in next version. The MVC comes into play if you build a custom plugin. It has good roles and permissions support. Good internationalization. Great asset management. Live preview is a great feature. The admin interface is super nice and very fast. Far less clutter and less confusing than Wordpress. I wouldn't use it if the website was meant primarily as a blog or news site, as WordPress and it's plugins are more targeted towards that. But if it's any other type of typical website, I would want to use Craft.
Useful feedback, thank you!
&gt; Sulu, like anything based on Symfony, is unusable on Vagrant To be fair, anything using Composer could be "unusable" on Vagrant. God help you if you let Composer clone your packages instead of download them too.
&gt; There is no such thing as a CMS that will do everything you want You lie! I have been told that Drupal is only 1 module away from doing everything you want. 
&gt; failures == "not worshipping Reddit neckbeards" I don't ask for worship, but if you have any food offerings......
My main client is government and we are using the Drupal WXT distribution put together by Statistics Canada developers. On one hand it's great because it pushes for maximum accessibility, on the other hand it's Drupal 7. Despite the love hate relationship I have with Drupal I would still recommend it over Wordpress for anything beyond a blog.
&gt; You're right but hosting companies don't give a damn about your app's performance. They should. If my app runs faster on PHP7 and they don't offer that, guess what I'm gonna do? Find a host who does.
Yeah, [I know](https://www.sitepoint.com/symfony-on-vagrant-performance-hacks-sulucms-case-study/), but I'm not just talking speed here. There are [other problems](https://twitter.com/bitfalls/status/858107303240896512) that keep cropping up.
Most of real-world API data is trivial. It's not like most of us are modeling complicated DNA sequencing and quantum physics simulations through our PHP web APIs. So this is why most of the time value objects aren't necessary, and validation at the boundary is enough.
&gt; The problem with the suggested custom validators is that they usually lead to code that is actually performing slower. Simply because you need to revalidate everywhere if the chosen type does not ensure validity. I work both with VO and with array/scalar data and I understand your fear you'll have to "constantly revalidate", but it's really just not true. A ValueObject would be validating its data on every single construction and change (or change to a clone, for immutable VO using the -&gt;withFoo() convention). This includes internal creation, internal trivial transformations, even hydration of a VO from your database, which makes no sense as if you stored invalid values in your domain, you lost the game long time ago. In contrast, keep data as data means you validate it just once - when it enters the domain, and it's untrusted external/user data until this point. Nothing else is truly needed. Having VOs validate your values at every step in any other context plays the role of a debug assertion: it helps you catch bugs in your code. But debug assertions are designed to be turned off in production and you can't just "turn off" the overhead of VOs. Ironically it's much easier to run a validator as a debug assertion during internal data passing, if someone fears bugs. And once code is stable, I can disable assertions. So this means I get both performance and no bugs. Go figure. That said the fear of bugs within the domain is overblown. Properly architected domain modules are small, focused, encapsulated, which makes those bugs which are exceedingly rare in my practice, because if you model your values to be simple and comprehensible, you don't need the redundant abstractions to protect yourself from yourself. &gt; It also matters a lot if we want to perform certain actions on that string. Using the various mb_* functions everywhere where appropriate might be faster from an execution point of view compared to wrapping those calls in a dedicated object. The cost to change such calls for whatever reason is extremely high. False dichotomy, you don't have to "use mb_* functions everywhere". You can abstract tricky string operation calls in a class with static methods like `$string = StringUtils::doSomething($string)`. This is what millions of projects across dozens of languages do and it works fine. You don't need to wrap/unwrap/wrap/unwrap/wrap/unwrap your strings in a dedicated object, only to get the syntax sugar of doing an object call. &gt; &gt; TL;DR The overhead of simply wrapping data in objects is huge. The reduction of complexity, bugs, and performance by performing a validation once is huge too, and easily compensates the other. Definitely not in tight-foreach-benchmarks, but in huge complex systems with many involved parties that is meant to last for many years to come. There are many ways to reduce complexity and bugs. One may be that you already have a "huge complex system" and the only way to get back control is to defensively pack every nugget of data in its own object and thus implicitly and constantly run validation assertions everywhere. But another is splitting a domain into simple modules/service, each of which is simple enough so you can fit the entirety of it in your head and edit code with ease, which results in less bugs because it's quick to get familiar with what the code does and why. That's the model I choose. So while all those modules may sum up to a "huge complex system" no developer has to actually think about any "huge complex system" but about their module, and so the situation you're talking about doesn't apply. There are situations where VO are appropriate, but for most trivial data, including what you at Trivago do, it's really not the case IMHO. But look. I actually don't mind you solve this problem **in your team** this way. It can work, sure. Sure it's also slower, sure it also results in a ton of extra classes and code, but it works. I'm merely trying to give some food for thought to those with an open mind to consider an alternative to their ways. Which most developers aren't, unfortunately. 
Please use /r/phphelp for support questions. This is not a support subreddit. You might have even more luck posting this in a framework specific community.
&gt; October it seems comes closest, but it could be easier to install
It's a one line install with Composer `composer create-project october/october .`
I'm interested. Hard to see from the landing page what value it woud provide though. After some recent... situations with client sites, I could probably scare up a little budget, too. Literally.
Yeah, coming from a Rails / Laravel background, the amount of template logic that goes on in a typical Craft build was a little jarring to me. I've been trying to get into a system where if I'm doing way too much in the templates, pull it all out and push it into a plugin, which isn't too hard to do.
I like [Contao](https://contao.org/) a lot, which has been on the market for 10y now. It's very flexible, feature-rich and customizable out of the box, so you don't need a plethora of plugins to get off the ground. For example, apart from highly modularized pages/articles, it comes with a form builder, a blog, an FAQ, newsletters and an event list (calender thing). There's also highly granular rights management, literally down to each and every setting in all dialogs. It puts a lot of power in the user's hands through the way it handles templates and styling (it has a graphical CSS editor, for example). At the same time, it's not a ball of wool like Drupal is, for example. But because of all that, the plugin landscape is not quite as varied, I have to say. That, and the fact that it's not as widely known. But it has a somewhat well thought out system that's pretty straight-forward to extend. Since v4 you can keep the core files out of the docroot, and only really expose files that need to be there (mostly static stuff). For enterprise it's nice that it has LTS versions.
I always find it highly irritating how many CMS don't see I18n, and especially L10n, as a core concern, but something that should be bolted on through a plugin. The ones I've seen all suffer from it.
100 % agree, yes. If that is your use case, do not even try to make use of DDD. It will not only be bad for performance, but it is also bad for agility and wastes your time.
After that, you need to edit some PHP files, manually configure crontab, and jump through hoops to get a secure directory structure (`index.php` not in root of the project, but in `public`). The database credentials entry could have been part of a composer script, too, along with the above.
Is there any reason you are preferring Vagrant instead of Docker? You really should consider switching to Docker instead of full-blown virtualization. It's orders of magnitudes faster and needs less resources.
And what's different about a secure directory structure with WP again? I love Wordpress and love the easy installation. But nothing about the default installation, assuming it's Joe Schmo installing it on a shared host, I would consider more secure when compared to a default OctoberCMS installation. But yes, the DB credentials could be part of the Composer install. You're right. But the point, at least in this case, is that you don't even need a database in the first place to have a fully working install stood up and serving traffic.
Don't forget http://phpfastcgi.github.io/
I think you misunderstood - I'm not claiming WP is more secure, just that I don't like this default which October has chosen to use, and must change it, which is another (non trivial) manual step. Also note that you need to change `'disableCoreUpdates'` to `true,` in `config/cms.php` if using the Composer installation method, and nowhere is it explained in the docs why we're doing this. All I'm saying it could use a bit of DX polish, being so close to awesome.
In a nutshell: - I publish hundreds of tutorials per year, all of which need to work the exact same way on every machine of every host OS for all readers. A Docker learning barrier is not a welcome addition in those cases, especially with its problems in cross-OS environments (needs plugins for speed on OS X, needs fixes and weird approaches on Windows, etc). - I don't want to deploy my app in Docker. And if I'm developing in Docker, I have to deploy it as such, too, otherwise I have no dev/prod parity. - If I really want Docker, I can spin it up inside a Vagrant VM just as easily.
&gt;I'm preparing a more detailed post about those three btw, tested on a real use case. I'm looking forward to reading this, as well as any follow up from this post if you do try out a couple of the suggestions here. &gt;I have a hard time honestly recommending anything else for a reason other than code quality I'm in the same boat. I need to get my shop off of WordPress but I need to be able to justify it, and I haven't found the right successor CMS yet.
&gt; I'm looking forward to reading this Cool, keep an eye out [here](https://www.sitepoint.com/php/), or add to your RSS reader, should be coming out in May. Really trying to do a comprehensive job, currently sitting at 4k words and I'm not even 30% through :/ We'll see how it plays out, maybe in several parts. Likewise, if anyone else reads this and wants to write a comparison post for any of the other suggestions here and get paid, [get in touch](https://www.sitepoint.com/write-for-us/).
Are we just arbitrarily listing languages faster than PHP now? JavaScript rest applications aren't too relevant in this sub.
Not totally surprised - what web server were you using?
I second Drupal 8. I was getting tired of Drupal before it came out. I love that I can hook into Symfony. It's fast to setup simple sites but robust enough to handle more complicated projects. I still use Symfony for some projects. 
I like the idea, but there's some math gone wrong because it shows A LOT more commits. According to git-score.php, the branch I've just evaulated has 171016 commits. However, *git shortlog -s -n --no-merges* says that there are 44896 commits. Maybe I'll dig into this if I find some free time :)
Interesting discussion but one thing struck me about your initial post. You said WordPress beats October into a fine dust on ACL. Now am I missing something here? I don't recall WordPress having any proper support for ACLs aside from some very crude user role definitions (which are not really ACLs at all). In fact I would say among a long list of WordPress weaknesses this is right up there.
Oh, lol.So you didn't found the way how to add your docker-compose.yml to git repo? Override values? Have you ever heard of ENV variables? What is the reason of using preconfigured VM's? I remember the time we were using VM's as a nightmare. ]With that small docker-containers it becomes really easy. And no one in our team spend time to configure it. It's so simple so even Junior developers becoming familiar with all the tools they need for local dev in half of the day. &gt; make sure the database dumps are in the right place so the db's are initialized correctly, make sure the persistent disk storage is set up correctly for those dbs, and so on and so on There is no need to do it for every team member. Yes, someone needs to do it, but it's the only one person - your DevOps or Senior Developer. Others just use docker-compose up -d and that's all. You didn't get the idea of containerising your applications. Before, every developer needed to configure local development ecosystem, now only one developer needs to do that. And I've never said that docker is a silver bullet. It solves some problems, not all of them.
Drupal 8 started from scratch.
Pretty sure this is due to .lock being generated by different versions of composer.
I was stating a fact. I love PHP and was disappointed by the response time.
I guess I don't see what's surprising about an equivalent application being slower in PHP than it is in JavaScript. No one could expect any different
I'd be interested to know why you think it's not production ready, I personally run two massive systems with 100s of sites/apps each in production on Bolt, and the reason why I chose it originally (and disclosure I now contribute too) was because being based on Silex / Symfony and tracking their architecture and releases means it's pretty solid for enterprise systems. 
You can't minimize false positives without maximizing false negatives. It's the nature of heuristics-driven algorithms, which your applications seems to be an example of. I'm not saying you can't have made some amazing breakthrough, but amazing statements require amazing evidence. So far what we see is just a landing page asking for our GitHub account.
Are there some reliable benchmarks that you're using as a reference? Or is it just anecdotal?
Agreed. Acquia's done a great job leading the project into the enterprise and government spaces. In general, while Drupal certainly has its warts, it's a productive and well-supported platform, and each major version gets significantly better than the last.
&gt; Just that, Drupal as an org refuses to support shops for modules, making all that effort pretty null. Can you elaborate on this point?
I personally will answer why I hate it. The codebase is pretty shitty, and whilst that makes no odds to the end client, I just don't want to learn and write shitty code. I want to learn design patterns and other transferable knowledge. 
Drupals official repo of modules does not have any sort of 'shop' or payment system. They must all be open source. There is also a culture around Drupal that acts very much against commercial modules outside of hosting environments. For example, with WP, you can just buy some commercial plugins that are maintained by companies, like visual editors. In Drupal, nope. How it works with Drupal, is developers are sponsored by companies to spend their time making modules. What this does, however, is makes it so the actual product of it isn't sellable. Which is good for hosting companies like acquia, who sponsor a lot of work (thats they use themselves), but terrible for everyone else, especially developers who /have/ to make money to keep up with their software. https://www.lullabot.com/articles/why-paid-drupal-modules-fail-drupal-as-art ^ this is the reason we can't have nice things.
Tbh, I really like the fact that Drupal doesn't do paid modules, for me it's a feature. Commercial WP modules have no oversight and imo that's why there's so many shitty ones. I don't want to suddenly have to pay for a feature, that no one but that one developer maintains, that might not even do what I want, when instead there's a massive community contributing those features to the project itself. And I can contribute back to it too. I don't think it's bad for developers at all, it's much better imo. It's worked out very well so far, as 'there's a module for that' is pretty ubiquitous. It's been notoriously difficult to get to be a contributor for a while, but they've opened that up recently...something I'm on the fence about.
Horrible code. Official support of dead PHP versions. Their recent attempts at writing a decent official "REST" API to hook into from the outside have [failed hilariously](https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html). A graveyard of vulnerable oversight-free plugins all over the web being installed by unsuspecting devs every day. A useless built-in search. Slow and bulky UI. Etc. Yes these can all be fixed with plugins and whatnot, but at that point I am depending on more (badly written) packages than I would be if I went and built the thing from scratch. Working in it just doesn't feel good - everything feels like a hack, and I just don't feel safe, there's an insane amount of paranoia I feel at all times because of their lax security practices over the years and the all too frequent vulnerabilities. There's even a bunch of deprecated/dead PHP extensions they actually *require*, just to keep their old userbase alive. /u/sarciszewski would know more about that, though.
The whole issue with any CMS is, it's a CMS. And, in an enterprise scenario, a CMS is only one part of the whole business. Sometimes more a part, as in Sitepoint's case, and sometimes less (as with a brick and mortar business). As soon as anything is needed outside the CMS for business purposes, you need to extend the CMS and then you are caught in their "business model". Or, you build something so unique, it could almost stand alone, like WooCommerce. But, you are still caught in a tightly "pre-built" system. It is very opinionated and thus quite rigid. I too always go back to Wordpress, but like you, I am not a fan of it. If I have to dig deeper than the admin CP, I get that dirty feeling too. And when I add something like the divi theme system, then the ACP is also flooded with that dirty messy feeling and it is only because the default ACP of Wordpress just isn't flexible enough for their purposes (plus the divi builders obviously decided to go all out to make their users know they are in a different world, using their extensions, which is stupidity in my mind. But, oh well. I guess it starts with the inflexibility of the ACP.) At any rate. I share your contemplations and feelings about Wordpress and I highly doubt any CMS will dethrone Wordpress any time soon. At least not until the new kid on the block can offer something newer and way better, a better platform, than Wordpress offers. Scott 
cool stuff added
Yes there is - https://github.com/kenjis/php-orm-benchmark
Implying that you can safely update to the latest version in your composer.json. this might add bugs that are unrelated to what you were working on.
That's also the problem with the top answer too (deleting the lock file).
Sure that's possible, but unlikely (if you're getting a conflict now then the other repo would have been updated fairly recently). And your version specifications should be such that any updates would be non-breaking. And obviously your unit tests should help catch errors. 
Well, if you use a miniframework to make the front part and this php makes call to the Java backend I think it's possible. It will be a little slower maybe than a php single app but it could work. I would use nginx-php for the front and maybe tomcat for the back. 
We all agree that using blacklist never works , Shieldfy will monitor the code execution from request beginning till it flushed back the browser , looking for attack pattern [analyzing the request and how your code is handling it]. in that case code like "&lt;Script&gt;alert('xss')&lt;/script&gt;" would be attack in one website , and be a normal input in another one. We will add more explanation in the next few days , and we will send invitation every week.
&gt; If you've each required different repos then where is the problem? I made this in one branch and colleague done that in another. Then we want to merge into master. Both branches will contain slightly different versions of lock file. Given I merged first, then there is conflicts in another branch. To fix it, I found it best to just checkout lock file to --theirs and repeat changes (composer require or remove) again. &gt; you run a composer update This will cause all dependencies to update. For example week ago I updated to symfony 3.2.7 and it appears that it has broken autowiring so I downgraded it to 3.2.6. This kind of error was catched by my integration tests (unit tests can't find such errors). They are covering only positive cases to work with my infrastructure and I can't be 100% sure that everything will be find on update. And I don't want to specify fixed version in my composer.json, this just don't have any sense since you have lock file.
Yea , the balance between false positives and false negatives was the every WAF dilemma. What we introduce here is a new concept , Shieldfy SDK will load and monitor the code execution from request beginning till it flushed back the browser. So when we flag request attack in the beginning we will do nothing just flag it , till your code handle it some how ( DB Query , Throw Exception , Flush content to browser .... etc ). then we try to identify if your code handle it correctly or not , if not we raise danger flag and block the request ( in this case we avoid too many false positives &amp; negatives ) and will notify developer with what happens with extra details about the code and how the code responded to attack. Thanks for your feedback . We will add more explanation in the next few days.
For skim-readers, this is a podcast, and the [related blog-post is here](https://blog.tighten.co/the-magic-of-laravel-macros). 
You are right , we should explain our tech in more details and how we accomplish what we claim to do. In fact , The plan is to release SDK for each language. each language is different in the way it handles data and has its different attacks &amp; exploits. we will start with PHP for now. expand later. We will add more explanation in the next few days and maybe will publish some technical articles with deeper how it works.
Yes WAF , but we are trying to minimize false positives &amp; provide developers with real value which is find vulnerabilities in their applications.
XML? What is this, the early 2000's? JSON or GTFO.
hahaha... I'm old =( jeez. Using json tho...
http://phpversions.info/ is a great resource for seeing which hosting providers offer which PHP versions.
If your version constraints are bad or a package doesn't use semver, yes. CI helps, as always. :)
Oh, wow. The post on their website is so cringe-worthy. This whole situation and the company's reaction to it reminds me a lot of the Daniel Kerr / OpenCart interactions from the past.
Possible - yes. Beneficial - I doubt it.
&gt; why people are not updating to get most out of it. Try telling all the mom and pop shops that some web dev did their site 8 years ago on 5.3 that they need to upgrade. When someone comes in and informs them it's going to cost $500 to go through their code and upgrade, they are going to straight up say no. Also try being a host, upgrading to 7.0+ and 50% of the sites break because they are using deprecated code. Those sites are migrating to another host and you're losing a ton of money. 
Is this really comparing 1 to 1? With comparing the two most popular ORMs, Eloquent is AR and Doctrine is DM. They do different things which makes a world of difference depending on how your site is set up/how many entities you have/caching/how things are queried and hydrated/etc.
Yea, that's another thing that annoyed me about the article and the authors replies here. He never says `Doctrine/ORM` but my best guess(as he avoids answering questions apparently) is he's talking specifically about the ORM package.
This looks like an awesome way to entrench your codebase deeper into Laravel than ever before. I wonder if the stack traces are any worse than the current pile of `-&gt;make-&gt;alias-&gt;abstract-&gt;concrete` lines you get every time the IoC container is invoked...
First of all, php ist not a compiled language so you would have to run an interpreter on your phone, possibly a web server. A quick google search yielded [this](https://play.google.com/store/apps/details?id=com.esminis.server.php&amp;hl=en) as a result if you run android.
so basically php functions? brilliant
Ian't assembly the fastest of them all LOL I mean how much faster can you get? :P
Slightly off-topic but if you're looking for decent multi-language support in Wordpress, the [Polylang](https://en-ca.wordpress.org/plugins/polylang/) plugin is pretty solid if you've never looked at it before. There's a paid version but the free version does a lot too.
Web hosts do not update unless they need to. It took forever to get 5.3 on some hosting sites. You're better off going with something like AWS and installing your own versions of php.
Your system/server/code is screwed up, not Lumen.
Seems I need to give you something to read the. https://zedshaw.com/archive/programmers-need-to-learn-statistics-or-i-will-kill-them-all/ So u til you actually come with some evidence I will ignore you.
I did check that, but since the others run fine eg. No framework, and code igniter something else is going on. Apache sends 200 but php seems to have remove all header data, meaning it sends an empty return, but not just empty, but completely empty. So testing with AB or other benchmark tools everything is okay, but testing with JMeter and making it check the contents "Hello World" it fails as a lot of the requests returns an empty page. So in my tests I'm 98% sure it's neither port or server config error.
Evidence of what? My undergrad is in Psychology and I was preparing for a career in test design when I moved towards computer science. My statistics knowledge is pretty solid. I've scaled multiple web apps to millions of users and primarily focus on big data and on scaling apps as a professional concern. My current app processes millions of request per day in a Lumen API, with basically zero issues and certainly none related to the framework. You don't need to believe me, but that's a choice of your own detriment. I'm not saying you will never learn something from my config. I'm telling you that in my professional opinion you need to look elsewhere. Remember, you're the one having problems with Lumen while it just works for the rest of us. So, you might want to consider stowing your attitude for five minutes and take a good look at your own shit.
So you monitored ephemeral ports during your test? Tracked them against instances of failure, etc?
Maybe try using `$PWD` instead of the `.`?
That you're changing things unrelated to your patch. You're better off accepting the master and only update the packages you initially upgraded. _Then_ you could make a new patch where you update everything.
I doubt that for this scenario, since he says he wants to build a simple website with basic login and showing products. I think he probably wants to build a basic webshop as personal project or for a school assignment 
"Path D:\project\$PWD/vendor/foo/*/src/ does not exist".
&gt; easily do this with inheritance But this wouldn't be correct from type hierarchy point of view. The point of type-safety is that you could have different behaviours (`run` and `swim` for example) which requires different actors. And what you need is to provide this requirements in code implicitly. So you could use compile-type checks. Unfortunately PHP doesn't provide any kind of type-safety. Yes, you could verify that function only receives a string, but function must require email and you cant use type checks for that (you probably don't want to create a class to any small thing in your system). Or, for example, your function requires all string to be trimmed. So you want to write `function foo(TrimmedString $str): TrimmedString`. If we have that we will receive: - compile-time checks which cover large amount of test cases. - self-documenting code. It will describe itself As for boilerplate - we could always write some kind of code generator which will handle that for us.
Well, `composer show --tree` should do the trick.
YW. See https://demo.contao.org/en/ for a demo version.
Same reason web hosts are still offering PHP 4 or PHP 5.1 (yeah, really): because most people never update their code, because not everyone has shit tons of money to pay developers. As long as it worksâ¦
Wait, what!? Are you being sarcastic? If yes then that's hilarious!!!
Contrived examples like this do very little to illustrate real-world problems, and thus do little to convince anyone about the solutions. To be frank, the article is one big strawman - create an artificial problem as justification for a contrived solution. How about using some real world problem spaces and code to illustrate the banana/gorilla problem, and how conventional OO patterns and practices are insufficient for solving it. I'm all for using pure functions and *minimizing* message passing where possible in OO code, but why not illustrate some real-world usages of that? On a side note, this is quite a strange demonstration of type safety and OO naming. 
Be careful of neck pain and wrists pain when you do that. I would prefer read an ebook (epub) on smartphone rather than coding in it.
OP, I don't want to be a jerk, but in the name of honest &amp; constructive feedback... this is the most arbitrary transformation of code my eyes have seen in the last few months. It doesn't demonstrate any flaw in Object Oriented Programming. It doesn't represent Functional Programming either. What you did here doesn't represent anything in our industry that has a name (yet). Maybe the closest match would be Procedural Programming, circa PHP 3 and C, where you're using objects as dumb data structures, and procedures are moved to standalone functions, thus eliminating one of the most powerful concepts of OOP: *behavior polymorphism*. Look it up. You've added a ton of code duplication in the process, for no reason at all (that you've explained in the article). Before I refactor your code, I'd like to note you're using some popular terms and quotes of the day, but with very poor understanding of their actual meaning: &gt; The first common thought was: is it programming with functions? Yes and no. Found out that it is about functions... By the end of the article it's clear that you understand this as "programming with named global functions, PHP 4 style". To anyone trying to do functional programming in PHP: that's absolutely off the mark, because functions in functional programming require the following essential properties: 1. Abstract functions: a function with the same interface (input/output argument signature) can have multiple replaceable implementations (polymorphism). 2. Close over state: the function can hold implicit (immutable) state, captured from its initialization from its environment or others. 3. Partial application: it follows from closing over state, you can't partially apply without state. 4. First class: you can hold a reference to a function, pass it around, take it back. And I mean real references, not passing strings around. 5. High order functions: follows from first class functions, those are functions that take in or return function references. 6. You can define a function anywhere: this follows from all the previous principles, you can define a function within a function within a function, thus flexibly closing over necessary state, and thus passing and returning differently configured functions to callers and subroutines. If you understand Functional Programming and you know what I'm talking about in the above list, it quickly becomes apparent named global functions in PHP are nothing close to the functions FP is talking about. They are merely static procedures, the way you'd have in C, or the way you'd commonly program in PHP 3 and 4. To do effective FP in PHP you need at least closures. And closures are internally implemented as single-method *objects*, which says a lot. There's a saying "closures are poor man's objects; objects are poor man's closures." You can do FP with PHP closures. You can do FP with objects. You *can't do FP with PHP's named global PHP 3 style functions.* &gt; Anyway, this isnât about it, but studying FP and Functional Languages I discovered that OO isnât a bullet-proof concept, it has some failures. &gt; Design patterns, SOLID, GRASP etc, are principles in OO to solve problems that OO itself causes, not to essentially make it better. A bold claim some FP fans like to throw around, and like them, you do it with zero explanation and justification. Instead you said this: &gt; Ok, letâs dive into an OO problem. Imagine that now we have a Cyclist, but who can also swim(), like we see in triathlon competitions. Easy! EXTEND ALL THE CLASSES! Well, imagine that now we want a simple Cyclist, who doesnât swim(). How to accomplish it? Extract swim() to a Trait? SwimmerInterface? Cyclist and SwimmerCyclist? What if we need a Runner for a complete Triathlete? SwimmerCyclistRunner? A Triathlete who implements Interfaces and use Traits? Then classes will be only type declarations and implementations will be divided into Traits? How to test all this? OMG! OK, so what we learn from this quote is that *you don't know where to even start*. This is not automatically OOP's fault, unless proven through concrete OOP flaws, which the article is missing. Have you pondered maybe you just lack the experience to factor this properly? But I digress. I'll take the problem formulations and questions you ask above, and answer them below after I refactor the code. &gt; What if we split behavior from data into pure functions? swim(), ride() and run() as pure functions expecting exactly what they need to be called successfully? Indeed. What if? That's the issue, because the problem is so abstract it makes no sense whatsoever. You want to have some function, external to a Swimmer, which *does the swimming based on a Swimmer's name and wetsuit*? What exactly real-world issue is this trying to solve? Can I give you Michael Phelps's wetsuit and name and you can do the swimming for him? It makes no sense whatsoever. And may I point out, that functions which are called *swim, run and ride* are the worst possible examples of what a "pure function" is supposed to be? Your functions are pure only because they do nothing but return a string. If this was a real project, none of this would make a lick of sense. But let's be generous and put aaaaaall this side... I'll take your exact code as is, and just move the methods where they belong, and remove pointless code duplication: interface Person { function name(string $value = null): string; } interface Cyclist extends Person { function bicycle(string $value = null): string; function ride(): string; } interface Runner extends Person { function shoes(string $value = null): string; function run(): string; } interface Swimmer extends Person { function wetsuit(string $value = null): string; function swim(): string; } trait PersonTrait { protected $name; function name(string $value = null): string { return is_null($value) ? $this-&gt;{__FUNCTION__} : $this-&gt;{__FUNCTION__} = $value; } } trait CyclistTrait { use PersonTrait; protected $bicycle; public function bicycle(string $value = null): string { return is_null($value) ? $this-&gt;{__FUNCTION__} : $this-&gt;{__FUNCTION__} = $value; } function ride(): string { return "{$this-&gt;name()} is riding on {$this-&gt;bicycle()}"; } } trait RunnerTrait { use PersonTrait; protected $shoes; function shoes(string $value = null): string { return is_null($value) ? $this-&gt;{__FUNCTION__} : $this-&gt;{__FUNCTION__} = $value; } function run(): string { return "{$this-&gt;name()} is running with {$this-&gt;shoes()}"; } } trait SwimmerTrait { use PersonTrait; protected $wetsuit; public function wetsuit(string $value = null): string { return is_null($value) ? $this-&gt;{__FUNCTION__} : $this-&gt;{__FUNCTION__} = $value; } function swim(): string { return "{$this-&gt;name()} is swimming with {$this-&gt;wetsuit()}"; } } class CyclistType implements Cyclist { use CyclistTrait; public function __construct(string $name, string $bicycle) { $this-&gt;name($name); $this-&gt;bicycle($bicycle); } } class RunnerType implements Runner { use RunnerTrait; public function __construct(string $name, string $shoes) { $this-&gt;name($name); $this-&gt;shoes($shoes); } } class SwimmerType implements Swimmer { use SwimmerTrait; public function __construct(string $name, string $wetsuit) { $this-&gt;name($name); $this-&gt;wetsuit($wetsuit); } } class TriathleteType implements Cyclist, Runner, Swimmer { use CyclistTrait; use RunnerTrait; use SwimmerTrait; public function __construct( string $name, string $wetsuit, string $bicycle, string $shoes ) { $this-&gt;name($name); $this-&gt;wetsuit($wetsuit); $this-&gt;bicycle($bicycle); $this-&gt;shoes($shoes); } } See, we used traits. We even extend one interface with another! And it was just fine. It doesn't make things less testable or reusable, in fact, it's way more testable and reusable, now we can mock and replace the behavior of the swim/run/ride methods, where before we couldn't. But if you wanted to factor the solution in a truly better way, you would remove the public getters/setters (public setters exist here for no apparent reason, as stated in the problem definition), make the athlete configurations immutable (there's no need stated to make them mutable) and leave just *the behavior*. Because it's frankly none of some external caller's business which shoes a runner is using. Until needed otherwise by business needs, that is a runner's private problem. Which makes the Person interface not needed (for now) and leaves us with the following simple interfaces: interface Cyclist { function ride(): string; } interface Runner { function run(): string; } interface Swimmer { function swim(): string; } The methods "swim()/run()/ride()" here would **be pure**, by the way. Because I removed public property mutators, which you never used in your usage examples anyway, so they rely on immutable state, and they change no state, and produce no effects. Interfaces with a single method are sometimes called "Functional Interfaces", because they are much like *abstract functions in Functional Programming*. So moving back the functions as methods, and removing the getters/setters would make the code not just shorter, not just more clear, but it's also both better Object Oriented Code, and better Functional Programming. Go figure. BTW, just a side note. If you think this is cute and smart: return is_null($value) ? $this-&gt;{__FUNCTION__} : $this-&gt;{__FUNCTION__} = $value; ... it's not. Please just spell the name of the properties, don't give headaches to whoever will maintain your code after you :-)
Im gonna use my owl timer instead
So theres one main leader of the project working on his free time?
Thank you! And again, thank you for the very helpful, informative, and knowledgeable comment!
Binary.
&gt; I must have missed where they talked about casting an array to an object. They who? I'm not sure how you missed the 2nd sentence of the 3 sentence text post. &gt; I saw a lot of code where array represent the data type but object can do it better. The implication is that an object can manipulate the array "better". It follows that someone has cast an array to an object to make it "better". It seems you fail at comprehension. Just because "nobody engages to disagree with my crazy ass digressions" doesn't translate to "you are right". You're most certainly wrong, in this case. 
I see. Which plugin do you recommend? I had a quick google and I couldn't find anything that didn't look dreadful or abandoned or both.
I've used [graph composer](https://github.com/clue/graph-composer) before but this will only work on installed repos. Composer would need to pull everything down whilst resolving your dependencies anyway, so I don't think there's anything out of the box for this.
&gt; do you feel my example shows incorrect type hierarchy anywhere? Your example slightly violates open/close principle. Also I think that you are overDRYing this example. And I definitely against such usage of traits. Few years ago I would agree with you that this implementation is "OK" but now I think that by doing such things you are making code less cohesive and less easy to understand. As for boilerplate - your IDE could generate if for you. So I would call your example "premature optimization". &gt; and multiple inheritance is supported ... and a class can "inherit" multiple interfaces. There's a huge difference between "implementing interfaces" and "inherit classes". Simply speaking, your interfaces would not contain any state declaration not private/protected methods. Only this gives you much cleaner solutions.
Yeah, same as composer show, but pretty. Thanks, quite neat in itself
Heh, indeed precisely what I wanted to avoid but well, seems it's the only way "out of the box"ish
&gt; I shipped the final (forever) production version I sometime falling into a trap where "the same thing" over time became "not much the same". As an example - your Person trait could be a problem in future. &gt; One huge benefit of traits is that they don't expose type information outside the object Yep, this is just code copy-paste. And this is a problem. All logic containing in trait is by definition part of class which uses trait. You could easily break SRP using such things and this could lead to very coupled code. &gt; Like a private property, or a method. Well.. yes, but this brings more coupling and violates open/close principle. I like to use traits if my module/component is intended to be used through composition/decoration. In that case I could provide some boilerplate to client which could be used to simplify things. But this would be only very stupid code which will for example delegate responsibility from one object to another. &gt; it can go away But you must modify your code. With object composition I could just pass another implementation without need to change my code. &gt; there's no risk in using traits discretely to share implementation for a quick, lean start. Again, my IDE could generate this code for me. Traits doesn't provide me any boost in terms of development speed. As for lean start - I would prefer to duplicate this stupid code. This would give me much more flexibility. And yes, this would be perfectly OK from DRY point of view since it more about logic duplication (which is basicly signalling your about lack of cohesion and encapsulation). From the other side, I love to use traits during legacy code refactoring. 
Thanks for watching... http://www.valeednaeem.me/
&gt; https://gist.github.com/Nacoma/3a9a2f241ed27a700cfe66f299e416d7 This is very context specific thing, so in your particular example this could be OK to use abstract class. But in my experience it more often adds more problems that it solves. I understand developers. We (and I) are lazy. We don't want to write more code. Event more, we don't want to read this stupid boilerplate code. But this is a problem of our languages which are very verbose. Our IDE are solving this problem for us so I don't see any problem to create more smaller objects with simple interfaces. And there are very tricky problem with solutions which allows you to write less code by moving part to traits/abstract classes - you can't now just open one file and read all the logic. You will be constantly jumping from one file to another.
&gt; I sometime falling into a trap where "the same thing" over time became "not much the same". As an example - your Person trait could be a problem in future. Which is fine because you can stop using this trait at any point in time, **or** change it to simply proxy calls to a composed property like this: trait PersonProxy { protected $person; function name($value = null) { return $this-&gt;person-&gt;name($value); } } &gt; As an example - your Person trait could be a problem in future. There's no "future" here. I'm done with that. If you're afraid of "falling into the trap" where some refactoring is required, you'd *hate* "falling into the trap" where [you gold-plated your entire project](https://en.wikipedia.org/wiki/Gold_plating_%28software_engineering%29) using an effort of a magnitude higher than required, because you are afraid your code might need refactoring into the future. No matter what you do, your code *will* require refactoring in the future. &gt; Well.. yes, but this brings more coupling and violates open/close principle. To decide whether something violated the open/closed principle you need to know what problem you're solving first. And the problem in OP's article made no sense at all. All I did is re-organize the existing code to show you a few primitives we have in PHP and remove the silly procedural parts in it. We're very far from any place where even considering open/closed is possible. &gt; But you must modify your code. With object composition I could just pass another implementation without need to change my code. I'm aware of object composition, as I said. But all things equal, you have no idea if such specific type of composition flexibility is needed when composing a "Person" with a "Swimmer". Given this is a toy non-sense example from a blog post with absolutely no specific needs to it, the amount of gold-plating you're implying here would soon rival the [FizzBuzz Enterprise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) parody. &gt; Again, my IDE could generate this code for me. The implication is those get/setters would do something more complicated in a real class. Like have validation code, or more complicated internal logic. Your IDE can't do this for you, and using traits, which are "like copy/pasting" is much better than **literally copy/pasting**. That's the danger of toy examples in a blog post. Everyone sees whatever they want, and then argue past each other.
&gt; Which is fine because you can stop using this trait at any point in time This requires changes in my code. The thing I try to avoid. &gt; effort of a magnitude higher than required &gt; what problem you're solving first. That's why I don't see any benefit from discussing abstract examples without any context. My point it that you could spend 1 minute less time to write code using traits but then other developer would spend 30 minutes more reading it trying to understand. I found this really huge problem. &gt; The implication is those get/setters I don't use getters/setters much since most of the time I don't need them. This is a problem of naming things. &gt; Like have validation code. We are talking about generation of boilerplate like this: public function __construct(Runner $runner, Swimmer $swimmer) { $this-&gt;swimmer = $swimmer; $this-&gt;runner = $runner; } public function swim() { $this-&gt;swimmer-&gt;swim(); } Not "generating logic". Things like validation are not boilerplate.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; taking that to an extreme Any extreme point of view is bad (you could think it also as extreme point of view :)). I just like to think few minutes more on solution which allows me to extend behaviour without code modification. If I don't understand domain enough to predict changes, then I just will implement simple solution until I will get more clear understanding of how things supposed to be used. &gt; modify your code anyway I would add new implementation. No modification of existing code is required to do so. Also this new implementation probably will have different name and so on. The only thing that I have to modify is removing unused implementations.
This implies you trust the constraints set in composer.json, which would work if we live in an ideal world where everyone abides to semver.
&gt; It follows that someone has cast an array to an object to make it "better" That's your interpretation, which is not how I interpreted it at all. A lot of people use objects to represent data and methods to manipulate that data. I'm not arguing the correctness of that method, but that's how a *lot* of developers treat "OOP". &gt; Just because "nobody engages to disagree with my crazy ass digressions" doesn't translate to "you are right" What? I never went shouting how right I am and wrong the world is. 
I started my programming with PHP and moved to Laravel after about 4 months. From then I was focusing on mastering the framework. Recently realized that I've some gaps in my knowledge of the language itself and doubled back. I'm revisiting some PHP core concepts and feel much more confident with them, but I'm curious if anyone has ever felt like they've gotten themselves stuck in "framework learning"?
I wonder if I could find enough open source libraries and adequate community support if I wanted to develop a complex API on Kemal/Crystal
Well, a good framework would fully utilize the language's features, so learning them by using a framework should be fine... i think ... unless you're using legacy framework with no namespaces, no interfaces, no psrs, etc :D
If you want to learn it, then you should learn it. But please don't apply a solution where problem doesn't exist.
\&gt; `global variables` Please no
Publishing really bad examples and stuff like this is one of the reasons why people make fun of PHP. Thank you.
What about a step-by-step guide on a simple website, but following recommendations from http://www.phptherightway.com/ ? 
Having a single page application in the frontend that talks to a REST API in the backend is always a good start nowadays I would say
Hello co-worker from 2003!
You could probably throw together a "CMS" that edits static site generator files in under 1k loc (Not counting vendor)
A small framework with good documentation and unit tests and some sample apps. And be prepared to talk your way through it and justify technical decisions.
The writing style doesn't do much for me. But that might just be me. Not sure exactly what it is that bothers me. I find http://use-the-index-luke.com/ to be a really good resource for learning about indexes, from simple to quite complex, with working examples on a few different RDBMSes.
I am seeing similar results - some contributors have incorrect counts associated to them :/
Thanks for this! To elaborate for others on what needs to be done: - You need to have Docker for Mac - Edge installed. v17.04.0-ce-rc2 is not stable yet, so you won't get it through regular Docker for Mac. - You need to add `:cached` to the end of your volume mapping. For me, it was changing `.:/var/www/app` to `.:/var/www/app:cached` in my `docker-compose.yml` file. This definitely speeds things up considerably. Thanks again!
Right, I'm not saying it's the best, but AFAIK it still can't be 'decrypted' using today's tech.
I prefer not to put build-time secrets in my repo. You got a solution for that? 
It figures it out when you start debugging. Click Run-&gt;Start listening for PHP debug connections. Then send a request to your xdebug configured webserver. (You may have to set up path mappings the first time). If the server is properly configured, PHPStorm will pick up the request and let you start debugging it. All you need in the xdebug.ini file is something like: zend_extension = /usr/lib/php/20151012/xdebug.so xdebug.remote_enable = on xdebug.remote_connect_back=1 
If you are just interested in the stats you listed (ie you don't need javascript for metrics like screen resolution) you may as well just use a log parser like AW Stats.
Changing branches in git. I'm not rebuilding the entire image, just the app's dependencies (composer, bower, npm) and the front end. I'm sure some or most of that can be skipped for development most of the time, but at that point I have completely different Dockerfiles and environments for dev and production defeating the advantage of using docker. Needless to say, I'm not using it anymore in development, though others are. Still stuck with it in production, however, where it's just another useless layer of indirection. Basically, docker has created more fragmentation and work for my team and I cannot point to a single benefit we get from it. The biggest downside is that even more work is required to get rid of it. 
What I meant was that everyone I see hiring around me runs on rails or node.
You realize that you can just mount the volume right? So you can do anything you want with your code base and have the changes reflect immediately. 
&gt; Youâve landed on a premium project. In order to watch this livestream, you must have a premium LiveEdu subscription &gt; Starting from $9.99/month I think some promotional content might be OK here, but you need to state in your post that it is available for a fee. Still, at least the [repo is available](https://github.com/MuellerMH/hotelbookingwebapp) to look at. Hmm, no Composer used? It's not essential I suppose, but it does mean you're inventing the wheel inside your app.... 
Let's see: you've got the use of globals, direct use of unsanitized $_GET params . Great foundation for an example site demonstrating 'PHP: The Wrong Way'! Keep going. 
Oh, I did not know I'd heart so many people's feelings by using 'global'. I did not give it much though, but will fix it. :)
I was told Reddit is brutal, but I'm now experiencing this first hand. :) Please keep in mind that this is meant for an absolute beginner which has no idea what composer and git is. I wrote this for myself around 8 years ago. If I'd found such an example then, simple and clean, I'd be super happy. What make this a "bad example", if I may ask? 
As I said above, this is meant for absolute beginners who have no idea what Git, Composer, OOP are and have no idea how to interact with a database. Except the use of 'global', where do you think this example goes against 'PHP The Right Way'?
Thanks for your approval!
Id argue that a Dev who could make a good CMS or particular Dashboard is a Mid level dev already. A CMS and dashboard can be as simple or as complex as you make it. 
Urgh, this was cross-posted without declaration [to a Java sub](https://www.reddit.com/r/learnjava/comments/68enel/php_frontend_java_backend_running_on_xampp_is_it/). It has been deleted here, mercifully. 
1. PHP The Right Way is also meant for absolute beginners 2. At a first look: Security, Error Handling and Templating. People will never know about Git or Composer until they are introduced to it, not knowing those or other techs can't be a excuse to poor code, people can and should be introduced to good patterns as soon as they start, that is the whole point of PHP The Right Way, to make people start right by the well know community conventions and avoid common pitfalls.
Is there a walk-through or some material that will explain to the user what this is, and what to do with it? Beginners generally need a step-by-step guide (and they take ages to write!). 
If you are ok with video content, laracast free courses are a must, and the paid one if you liked it. [Here is the laravel 5.4 one](https://laracasts.com/series/laravel-from-scratch-2017)
I haven't personally used them, but I heard the Laracast PHP tutorial is good: https://laracasts.com/series/php-for-beginners AFAIK, the beginner's course is free. 
&gt; but I'm curious if anyone has ever felt like they've gotten themselves stuck in "framework learning"? Happened to me in another language (Java), and if you are like me, it's not related to framework, but more to how one learn. At first, you usually try to learn a new thing "by heart", like you would learn cooking recipies. That's the "What" part of learning. What calls a view, what is in a controller, etc., and you can recreate similar code again and again. But then, you have to learn the "How" and most importantly the "Why". Those come with time and diving deeper into the framework/language.
I second this. Haven't seen their PHP tutorial, but the ones I have seen are very good. And Jeffrey Way is just such a nice guy to listen to.
If you feel confident about programming and PHP is just a new language then there isn't a great reason to not use a framework. As you would with any other thing you'll learn, try to understand what's happening if you encounter things that appear magical but know that a framework will help you focus on the code that runs your app.
PHP frameworks used to be a monolith amount of code where people use just routing and database characteristics of it (since a lot of what we see is crud apps). Now they're moving to decoupled and "micro-served" little libraries, I think you should go for that too. Instead of using a fully-featured/all-in-one framework, try to compose little pieces of libraries and build your app bringing dependencies as it needs. You'll see this "movement" within current works like Zend Expressive and Symfony Flex.
How is this not more popular, and where are the web agencies that rely so much on Wordpress for their business?
Laracasts all the way! 
Pretty cool! The docker interpreter is precisely the missing piece of the puzzle last time I checked. Thanks for the hints.
This is really a "depends on you" question. For me, the first time I tried using a framework was CakePHP 1 circa 2009. I had been programming for 2 years. I felt like it was overbearing honestly. I didn't try again until a year or two later and went with a more bare bones framework, CodeIgniter 2. I can't speak to Code Igniter 3, but CI2 was the least frame-worky framework allowing you to still kinda code "freestyle" but still get your feet wet with routing and a semblance of an ORM. So I'd start with something basic and then go into one of the "bigger" frameworks that employers will want to see like Symphony, CakePHP, and Laravel. It's not necessary to know all of those, knowing one well will make picking up the others pretty easy. Some prerequisites if any: - Understanding basic security that the framework will handle for you (SQL injection, CSRF, XSS etc..) - How to build efficient queries (cause ORMs might make inefficient queries and you'll want to know when to break out) That wasn't really an answer, but there isn't really a right answer to this question other than you'll want a framework on your resume. Also despite the weight and learning curve, in the long run they really do increase your productivity. Stay away from the naysayers that cry performance foul, productivity is king until you need performance.
When you understand the mechanics of it. 
Consume some public API, maybe also some ajax code that works with long polling, show that you understand how try/catch works, and some basic unit testing. That stuff shows you kinda get how a big site works
Partnering with a framework is like a good marriage. Spend some time living together first to see if it works out. Eventually you will get to know each other quite well. Then you will wonder how you ever did without it. My recommendation: [October](https://octobercms.com) is a framework disguised as a CMS, with Laravel being a close but distant relative. Full disclosure: I'm a co-founder.
When you have a project big enough that you forget how it works each time you go back to add functionality.
When you get tired of rolling on your own. I'm pretty much at this point again. Was fun learning and piecing everything together, but ultimately what I was building was a framework and it's just tiring. My only issue with frameworks these days is they force coupling on you with a lot of magic and static methods. Which makes using frameworks to me not that enjoyable especially when you're trying to make everything SOLID &amp; DRY. I think the one exception is Symfony, but starting symfony is kind of rough. Hard to get into despite me knowing a lot of their individual component packages, I haven't wrapped my head around bundles and the project structure.
&gt; If you feel confident about programming and PHP is just a new language then there isn't a great reason to not use a framework. To be honest this particular sentence reads like: &gt; If you feel confident cooking and pie is just a new thing, then there isn't a great reason to not to microwave a frozen one you bought at the store. Frameworks are half-made apps. And the mainstream examples aren't often well made. An alternative is using individual Composer components and defining your own architecture in less than 100-200 lines of wiring code. 
I want a divorce.
&gt; I would rather people make a website that does automatic XSS and SQL injection prevention with a framework That's a really dangerous attitude... If you "trust" the framework to "automatically" take care of this, and you don't know how your information is interpreted and encoded, chances are you have XSS and SQL vulnerabilities on your site right now. And a framework is in no better position to "prevent" injections, than individual components interacting with DB and rendering HTML.
You either have to trust the programmer who just started to implement their code, or you trust the professional developers who have years of experience and created the (frequently open source) framework. Ultimately, you have to trust the people maintaining the website to keep it secure. Why not encourage those unfamiliar with best practices to follow in the footsteps of those with years of experience? Most frameworks I have seen now are fairly autonomous for XSS and injection prevention. You almost have to intentionally turn it off to fail. Again, much better than hoping a new programmer caught them all without any knowledge. Also, your earlier advice was "just grab packages off Composer" and I fail to see how that is much better than just using a framework if your concern is trusting the services new programmers use.
&gt; Frameworks are more like the worksheets you get in school which have the blanks you need to fill. If you'll be comparing frameworks to sheets of paper, writing an application is not like filling in a test, but like writing a novel. And this, of course, is a great way of writing novels, right? Someone giving you sheets with text, and you filling in the blanks... I think the frozen pie analogy was just as apt.
When you are bored with writing the same boring boilerplate shit every time and you understand what all the boring boilerplate shit does (routing, authentication/authorization, file manipulation, database interaction etc).
DI containers are in the post.
&gt; Your novel analogy doesn't fit, because I would never suggest someone just starting out with prose write a novel. You're still leaning hard on the "frameworks are for people just starting programming" idea, which really limits the scope of people frameworks are suitable for... &gt; We're talking about people learning. You can't just throw them in the deep end and expect them to swim. Especially when there is so much they can do wrong. Where did you get this idea that frameworks are *learning tools*? Because frankly most frameworks sell themselves as RAD tools, which is almost the opposite of what you're talking about. They're about this mid-level "worksman" type, who knows their stuff, but wants to fill in a few blanks (to use your phrase) and churn out mediocre product at a rapid rate, as they aren't too interested about the details, just getting shit done fast. That's who most frameworks target. And you keep describing them as education programs for programmers, given to us by the Gods above, who know better. Where is this defeatist attitude coming from? I can't understand where you imagine you sit in this picture. Do you feel unsure about programming and you feel the need to lean on a framework? Or do you write/maintain a framework and you're just terrified of the overall level of incompetence in the PHP industry and you feel everyone should lead on a framework?
&gt; It's not unique because there's only a fine line between frameworks and components. One of the major differences is exactly what makes frameworks better for beginners: they package together a bunch of components that play well together, include a relatively full toolkit for developing websites, provide various amounts of opinionated decisions, and include a sensible file structure. Basically, all things that a developer would have to do on their own at some point, anyway. So it's a very thin line and then you proceed to reject your own premise, that's weird... Ok. A developer who's good at what they do choose components based on the problem at hand. If you can't imagine your problem in any more specific terms than "a site", then you're not a very good programmer. And so by using a framework, you force upon yourself generic "opinionated" choices that by definition make your solution sub-optimal, because the framework knows nothing about your specific problem. &gt; But how is a new developer supposed to know the right components and file structure? Yes, yes, I got it already. You think frameworks are for beginners. I already addressed this. Many aren't. Symfony advertises its framework as: &gt; Speed up the creation and maintenance of your PHP web applications. Does it sound like anything close to "learn how to code"? Nope. It's for people who want to expend fewest amount of effort between getting an order and receiving a paycheck, even at the expense of quality and detail. That's what RAD is about.
You are obviously vehemently anti-framework, and I understand where you are coming from, but I believe you misunderstood me and the point of this thread. This thread is about a beginner trying to figure out if he is advanced enoughâ for a framework. Your suggestion was for him to learn how to build websites by scrounging for packages and writing his own architecture. A fine suggestion, but not one I support. I disagree with that being a suitable strategy, and instead believe the OP is best suited picking up a framework now while they learn. It gives them structure in an otherwise chaotic field. I don't know where you believe I said anything else professing the merits of frameworks or stating they are flawless. Just that - all else being equal - OP would probably find himself more comfortable on a framework than learning from scratch until he starts understanding what the framework is doing at every level. Personally, I think frameworks are fantastic and almost necessary for people getting serious about websites. I also relieve they're optional for experienced developers who have more understanding to make the decisions for themselves. I have seen businesses first hand that run very successful sites with and without frameworks, and I've seen them crash and burn by using a framework incorrectly or attempting to build their architecture by hand with Composer packages. It doesn't matter what tool they're using, it's how they use it and how well they know what they're doing. Therefore, the arguments about the merits for or against frameworks are fairly moot since the correct answer is usually "Depends on the business and if they know what they're doing." For beginners, though, I think a framework makes up for the lack of knowledge and that's great.
See my other comment, because I think it addresses a lot of your points here. To reiterate, this thread isn't about pros who know what they're doing so I'm unsure why you keep referring to this "developer who is good." Also, while I'm saying frameworks are good for beginners it's because that's the point of this thread. Pulling out Symfony doesn't make sense since OP is asking about Codeigniter (which I would advise against) so he is likely interested in Laravel, Slim, CakePHP and the likes. Also, I think you have a broad view of frameworks that isn't true for reality. Not all frameworks are equally opinionated. Some are barely, others have a lot. It depends, but ruling them all as generic is unfair. Especially when a lot of that generic stuff is boilerplate routing or sanitization code, or can be swapped out.
If someone else is going to have to work on your code, start NOW. It's a complete pain in the arse to work on a "legacy" codebase.
&gt; Does PHP 7 make me more money Absolutely. If you have 2x speed improvements then you can have half the servers needed than before. You can save a ton of money that way. Or you can switch to golang and save 10 times as much :p
Do you have forms in your app? Redirects? A login system? Anything like that that you don't want to have to rewrite for your next app and the app after that and the app after that ad infinitum? Or perhaps a desire to write something you'll still be able to manage in a year after you've been working on something unrelated for a few months? If so you might want to consider a framework. 
One to keep an eye on is [Craft 3](https://craftcms.com/3). It's in beta at the moment but I'm yet to find anything that is broken, it's just missing docs for some of the new features. The whole thing is installed via Composer, it has migrations, environment variables etc., made for developers.
I improved the docs a little bit.
Works for me every time.
You speak like you believe PHP 5.6 websites will stop working after 2018. They'll still run just fine on 5.6 servers - if they see no reason to upgrade, they won't upgrade. If upgrading will break more things than it fixes, they won't upgrade. If it will cost them x amount of money to do so when they can leave it working as-is, they won't upgrade. If being stuck at PHP 5.6 is something that truly bothers you, [set up your own server with a service such as DigitalOcean](https://www.digitalocean.com/) and configure it to your own liking.
I call shenanigans!
It depends on what orchestration tool you are using. For swarm you can use: https://docs.docker.com/engine/swarm/secrets/ And there are a lot of solutions like that. You can always encrypt and decrypt your data using SHA or anything else.
Here is what I would do with this code. You can decide for yourself which items are oversightes in the test code and which are things you want your applicants to pick up on. Also, I hope this test comes after an initial interview... if I received something like this before actually speaking with anyone I would be put-off. 1) We will add a strict_types declaration at the top of the file. 2) The code will produce fatal errors are there are no class definitions for the JobOpportunity, OOP, Symfony and Position/Developer classes. We don't need any of them, so will remove them. 3) We will create a new Applicant/Developer class to pass to the apply method, and add a void return type to that method while we are at at it. 4) We will remove the improveCode method, it cannot do anything as it has not parameters, no return type and no class properties or methods it can access. We will replace the method call to improveCode with something like $developer-&gt;getResumeAttacchement, which will need to be implemented on the Developer class. 5) We will a new Mailer class, and refactor the existing 'mail' call into a class method of this new class (method parameters will pass-through unaltered the mail method). The Mailer class will be added as a required constructor parameter to the RemoteJobApplication class, and stored in a private property. 6) I would create a unit test that mocks the Mailer object and prophecies that when Apply is called the mail method is called. 
As I checked and used PHP and Javascript wasn't very well suited to long running connections so I left both. then I use to integrate web push notification in chrome with App42. http://blogs.shephertz.com/2016/04/04/web-push-chrome-app42/ that is really simple and easy to use. I hope it will heplful for you. 
This comment should be printed and given to all coders to read before work every day. Thank you for cutting through the BS and summing things up so succinctly.
But how is anyone going to learn how to write OOP when they don't see any of it? Procedural PHP is old and should only be used when appropriate. To understand when it's appropriate you have to have a good knowledge of OOP.
Looks like exactly what I've been searching for. Thank you! 
Containers aren't, DI is. As it should be, anyway. That said DI is not "global data", so the author is kind of click-baiting the unsuspecting newbies. Mixed feelings about this ;-)
PHP pos is free now?
I built it in Symfony 3 as that is what I am most familiar with, wanted to kinda show off my good parts rather than go with something more riskier that might be a better tool for the job!
But don't build your public website yourself, if you don't know about security yet. Then it's better to rely on a framework.
If you want to impress a hiring manager, be passionate! You could build a damn calculator as long is you are passionate about it. Startups in the bay look for passionate people over skill. The question is not "can you do everything this job needs" because the answer to that is NO! The question is always "do you know how to find the answers and can you work with our team to achieve great things". TLDR; Build what ever excites you and you are passionate about
It's odd that I have found the path to be full circle. When you start out, you usually roll your own ... then you move on to using other peoples frameworks, then finally you end up with rolling your own again... Or at least that's what I have ended up doing. Rolling your own framework after being exposed to other frameworks is great as you can avoid a lot of the pitfalls of mainstream frameworks [coupling no use of interfaces to replace framework services... etc].
Nice. Though there's also [Chronos](https://github.com/cakephp/chronos), the drop-in Immutable-first replacement for [Carbon](http://carbon.nesbot.com/docs/).
Thanks! This library is immutable-only (no "toMutable" methods etc.) and has more convenience methods with obvious types instead of relying on string parsing. The sets of methods provided in their interfaces have quite some overlap, of course, but depending on what you need (and what you want to access or manipulate), either one may be the better choice.
Seems a lot of How and not enough Why. I think the author would need to show a more compelling example to convince me.
No, I meant can you give me an example of one of these projects... 
I've always considered the session part of the application or infrastructure layer, not the domain layer. For example, the **Current Customer** is part of the domain, but the fact said customer tracked via a session ID is an implementation detail.
It's "just" the interface. This library is much more convenient to use, but thus makes code also easier to read and write. There's nothing in it that you can't really do with "\DateTimeImmutable" in any way, but due to the various accessors and convenience methods, you will be more efficient with this library.
[Nope](http://i.imgur.com/uuk9DNf.png)
I thought it was obvious, given the link to [PSR-7 and Session Cookies](http://paul-m-jones.com/archives/6310). But I might be too close to the problem. For a beginning at "why," examine the following and think about the separation of concerns (or lack thereof): &lt;?php function start() { $id = (int) $_SERVER['HTTP_X_ID'] ?? ''; $file = "/tmp/$id"; if (file_exists($file) &amp;&amp; is_readable($file)) { $GLOBALS['DATA'] = unserialize(file_get_contents($file)); } } function commit() { $id = (int) $_SERVER['HTTP_X_ID'] ?? random_bytes(16); $file = "/tmp/$id"; file_put_contents($file, serialize($GLOBALS['DATA'])); header("X-Id: $id"); } ?&gt; This is a stripped-down naive representation of what's going on in the session extension when you call session_start() and session_commit(). That's a lot of mixing of concerns: reading input from a global location, reading/writing from the file system, placing data into a global location, sending headers, etc. If you saw that combining-of-concerns in the field you would be more likely to criticize it than not. So the "why" is to separate the concerns of collecting input (a header value) from the request, of working with a storage system to read and write data, and of sending output (again a header value) in the response. Doing so makes the whole thing more amenable to Request and Response objects. Further, the use of the data is almost entirely unrelated to user-interface concerns (i.e., collecting input from a request or writing output to a response); instead, its use is almost entirely exclusive to the domain or business logic. (This is not to denigrate the session extension, per se; it is well-suited to its purpose in a page-based include-oriented application, which was pretty much the mainstream when the extension was introduced. But when you have Request and Response objects, a lot of PHP functionality it positively at odds with them.) 
Xdebug is one of those "a-ha!" moments for PHP developers. It drastically changed my development habits after the first time I used it to track a memory allocation bug. Its so nice to see the build up / tear down of big frameworks too, just to see how they're put together.
&gt; I've always considered the session part of the application or infrastructure layer, not the domain layer. Sure; in Action-Domain-Responder, the "Domain" portion can easily be fulfilled with an Application Service (a la DDD), a Service Layer (a la POEAA), or even just plain old procedural PHP (preferably wrapped in a method). &gt; the fact said customer tracked via a session ID is an implementation detail. /me nods I might go so far as to say that it's not even an implementation detail; it's a user input element (and probably a presentation element). The non-user-interface portions of the code should have no idea (or care!) if it gets provided by one header or another, a query or post value, or even if it was typed in at the command line somehow.
dang it, spam :(
Hey Tanks! It's not so much an ADR thing, as it is a "Request/Response object" thing. The problem is the combination of concerns in the session extension. But you already knew that. ;-)
It is an ADR thing, because I have concern separation in my apps, but no such issue with sessions. Go figure, huh.
In my understanding, in ADR you have the Action creating a Payload for the Domain which generates a Payload that is converted by the Responder into a response. However, if your Domain works with a storage objects that represents only the session you can have that object wrapping a regular session object (Aura.Session or whatever) which exposes a limited API or has a different API altogether. The problem I see is this: The Session wrapper can be constructed only after the session object is created which happens either via middleware or in the actual Action thus requiring the Session wrapper to be part of the Domain's incoming Payload... which should be a very simple object, no? I would find weird to write `$payload-&gt;sessionStorage-&gt;set('key', 'value')`. I would prefer doing something like `$this-&gt;sessionStorage-&gt;set('key', 'value')` in the Domain. Where/how do you inject the sessionStorage into the Domain? 
Thank you. This is very interesting.
When you register you have tons of free content too. Thanks for notice ;)
&gt; PSR-7 For me a session (in combination with authentication) is a "mix" of application logic and business logic :-) How would you implement a session handler with PSR-7? Is it even possible?
That's a long feature list.
Yeah, this isn't a tutorial... This is a pay to participate course. Crappy title, go suck an egg dude.
You can try 1 day trial. And if you don't like it, you don't need to buy it.
&gt; How would you implement a session handler with PSR-7? Is it even possible? Yes, but it's ... trouble. See the elsewhere-linked article [PSR-7 and Session Cookies](http://paul-m-jones.com/archives/6310). You have to turn off a lot of PHP-provided functionality so you can intercept at the right times/places.
I did [something better](https://www.reddit.com/r/PHP/comments/68th28/what_is_the_best_way_to_handle_sessions_with_adr/dh1gpyn/). I hope you take a moment to consider what I'm saying seriously, and not just reject it because it doesn't match your pre-conceived notions... :P Feel free to integrate this in ADR. We can call it ADR 2.0.
&gt; in ADR you have the Action creating a Payload for the Domain which generates a Payload that is converted by the Responder into a response At first I thought that was a typo, but from your later comments it appears not. What happens is, the Action marshals input and sends it to the Domain; the Domain returns a result payload; the Action then sends that result payload to the Responder. The Action *does not* create a Payload and send it to the Domain; that description might be the cause of confusion below: &gt; The Session wrapper can be constructed only after the session object is created That has not been the case for me; the only thing needed for construction is the session ID, which gets pulled from a cookie or header or other user input. The wrapper and object get created with that value inside the Domain portion of the system. Does that begin to help clarify?
&gt; They are state, application state. I opine that they are input (user input) and output (presentation output) -- to be reused again as user input, and validated or invalidated by the server-side code. In that view, they are not themselves state, any more than me typing in my username and password are state. EDIT: &gt; When was the last time a browser "presented" cookies to your users? In an HTTP, request/response, client/server, over-the-network environment, the presentation element is the Response. That is where the server-side application presents the cookie value. Cf. [The Template Is Not The View](http://paul-m-jones.com/archives/5993).
You're right, that would be possible without much effort since such an instance is used internally, anyway. Thank you! The only reason why it's not there yet is that this use case has not been considered. The reasoning was that, most of the time, you would get a "\DateTime" instance by parsing a string, setting a timestamp or using the current time -- things that you could just do with the library instead. But the interoperability you suggested may be helpful when third-party components or your existing codebase return "\DateTime" instances, right? Will consider these two methods.
&gt; In that view, they are not themselves state, any more than me typing in my username and password are state. Even the HTTP specification disagrees with you: https://tools.ietf.org/html/rfc6265 &gt; HTTP State Management Mechanism &gt; This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Moving on... You said: &gt; In an HTTP, request/response, client/server, over-the-network environment, the presentation element is the Response. That's also incorrect, because in cookies this relationship is reversed. Forget for a moment we're talking about cookies. Take a deep breath. Now imagine you see these two messages: 1. "Set **foo** to 123!". 2. "Ok, my **foo** is 123". Which of those looks like the request and which looks like the response? Again, I'm asking what makes sense separately from HTTP, and cookies. Just in the abstract. If you're honest, your answer would be (1) is request and (2) is response. Now also look at this again, and tell me which is the **state mutation command** and which is the **state presentation**. Again, independently of HTTP, and cookies. If you're honest, your answer would be (1) is state mutation command and (2) is state presentation. Obviously with cookies, they have to hitch-hike the HTTP response for their request, and the browser has to hitch-hike on the HTTP request for the response. Because HTTP provides no other mechanism. But semantically, it's very clear what's going on here. When you ignore it, trivial things like managing cookies and sessions become **awkward** in ADR, because you refuse to acknowledge the semantics of these constructs and you lean on irrelevant technical aspects, that don't matter architecturally. It does a disservice to both your reputation and to your poor ADR users to keep deluding them about what's the best approach here, and ignore all logic and reason when presented with a better solution.
I don't get why people keep downvoting you. If you can stop 30% of the Internet from getting breached, you can stop one hell of a DDoS attack, which saves *everyone* some misery.
I'm not being avoidant. I'm excessively detailed and diligent in expressing my concerns, my solutions, complete with code examples outlining the concrete improvements I suggest. And you're replying before you get past the first sentence, which is *not* cute at all, believe me.
If calling SQL commands *presentation* is "argument from the absurd" then to call "Set-Cookie" commands *presentation* is also "argument from the absurd".
Oh, yes, that was another difference that I forgot to mention. Thanks :) The desire to have the "DateTime" interface as a "backup" does not justify the pollution of the API by blending two different interfaces, I'd say.
This is just too much magic, man. Imagine a Laravel newbie seeing `SomeModel::whereTldMatches('org', /*callback*/);` in your codebase - how is he going to find it? Is it defined in the model? The query builder? A scope? Who knows! I love Laravel but my god.
&gt; trivial things like managing cookies and sessions become awkward in ADR They're awkward *when you use Request and Response objects in PHP*, because the PHP session extension (and the `setcookie()` and `header()` functionality) does not allow you to easily intercept their values and behaviors. This is no more ADR-specific than it is web- (or pseudo-) MVC-specific. EDIT: &gt; store state (called cookies) at HTTP user agents That reads to me like *agent* state, not *application* state.
Awesome, thank you!
**tl;dr** Use utf8mb4 instead of utf8 in MySQL.
&gt; you're against any sort of headers being written in the controller because they're part of the response Correct, for the same reason I am against any sort of HTML being written in the controller: because it's part of the response. As usual, we are at an impasse; I am content to let you have the last word here, if you want it. 
I remember when this was discussed. "But won't it affect all code when it interacts with *strict_types* code?" and "Naaaaaah! What makes you think that?" they said. 
If the script calling `bar()` is not in a file with `strict_types=1`, then it will be coerced to int if `bar()` has type hints. It has no type hints, but the `actualBar()` does, thus ignoring the calling code's settings entirely and instead treating all uses of the library as if `strict_types=1` were enabled in the calling code. You could just do `bar(string $param, int $secondParam)`, but then you wouldn't give weak-type-users a `TypeError` when they pass `"123"` instead of `123`. The `bar()` prototype is typeless to prevent silent coercion when called from weakly-typed code. The idea is to take whatever's given, then fall through with strict mode enabled. The end result is: You get a `TypeError` even if you're using weak types and fail to cast to `int` manually. This forces users of your library to do more work to attain type safety.
So, another PHP quirk?
And then some wonder why Laravel is always in the last spot of every performance benchmark. Its author would go for any kind of obscure &amp; slow magical solution, to save himself a line of code.
Cool, thanks for the explanation. And the drawbacks are performance and memory management, right? In your last example 5 `Temporal` objects will be added to memory. Any papers on how PHP GC operates over this ghost clones?
Sql doesn't have synonyms
See the comment here: https://www.reddit.com/r/PHP/comments/68vqbp/introducing_the_trolololol_design_pattern_strict/dh1p19a/ Normally, it would silently coerce `string(3) "123"` as `int(123)` and proceed as normal. By using an untyped proxy method, **a TypeError is thrown even in code that doesn't use declare(strict_types=1)**. This basically forces people who *didn't* add `declare(strict_types=1);` into their code to still either be type-safe or catch `TypeError`s if they use the library. That's where the trolololol comes in.
`trait Concerns\ForceableTypeable`
https://twitter.com/dhh/status/859381934673338370
Elasticsearch it is.
No, works as intended.
Wondering if I can abstract this into `ocramius/proxy-manager`. Should be easy: subclass strips type hints (contravariant), then calls parent implementation (which has type hints). Same for return values. Subclass marked as `declare(strict_types=1)` Anyone wanna give it a shot? I'd accept it as `TroloProxy` ð [EDIT] or better: AST transformation that takes any function declaration and wraps it as shown above as composer post-install steps. I need to drink less.
Proper type systems plz: magic-method proxies are generally terrible ð
How does it handle concurrency?
* Work on your own branch, then make a PR * PR is reviewed by other developers on that project * Tons of adjustments usually happen here * PR is accepted and lands on DEV * Jenkins picks up DEV &amp; runs unit tests (in memory sqlite db scaffold), makes sure it builds * Jenkins sends it to a staging server filled with test data similar to production environment (via deployer) * Devs play with it in a production-esque environment and hope it all works (or laugh when it breaks) * If validation needed goes out to QA\System admin who requested feature * PR from Dev to master goes up at some point for a final round of everyone signing off that if shit hits the fan we at least all agree it shouldn't have * Jenkins repeats the whole process but instead sends it to production environment after build succeeds. Not too much magic thankfully. The only pitfall is if we miss something in the PR phase. Our local builds use the same seed as the staging server and we made sure the data was nice and similar to conditions of a working environment but ehh. shit happens. edit: we're working on a staging server being made when the PR is first launched but haven't gotten that far. This is a legacy project so we're feeling pretty great about the project even getting to this point with staged data.
Of you are really needing that many processes to be running, I question whether PHP is the correct tool. 
From 5 years ago? Seriously, does someone or something just randomly post out of date web crumbs? 
Well, now you don't have to. Welcome [Stern](https://github.com/paragonie/stern).
Yeh, I just like this stuff to happen transparently, no code changes needed ð
The file that defines `Foo` is strict. The file that *calls* `Foo` is NOT strict. The gist forces it to still TypeError, which is an inversion of what most people would expect. Without this design pattern, calling a strictly-defined class from non-strict code causes behavior to be non-strict. The expected result of "library uses strict_types, but my code doesn't when I call the library" is NOT TypeError. It's silent coersion. This makes it always TypeError.
Solr http://lucene.apache.org/solr/ https://github.com/solariumphp/solarium
+1 for badges that's how you know it's legit
Holy shit you can make more than simple to do apps with vue.js? Mind. Blown. ð
i would start simple and split the functionality between a web application that accepts user input and a worker application that processes the input and i would tie that together with beanstalkd.
It's trollish because you're betraying the user's expectations of being expected to opt in to strict typing, even when they're using libraries that enforce it internally. With this pattern, now they not only aren't forced to opt into it, they can no longer opt out of it. If you introduced this sort of change into, say, all of ZF4, you'd annoy people who were doing it wrong. Ultimately, it would result in better code, but people would be put off in the short term.
Building that into the release process for ZF3 would be fun. ;)
*facepalm* when Scott has too much time.
yeah that was my process. I started out "I'm going to do it myself", then laravel w/ 4.2 rolls around and I'm like this is great until I found out about SOLID (learned about SOLID/DRY way too late in my php career 4 years ago?) and I'm like this is bad too much magic, how do I pass certain classes as dependencies etc... and I moved on to silex and eventually SF3 for my current job which is fun and alright. I basically built around just the router &amp; middleware what not. Mostly the rest roll on my own, now I'm kind of just trying to find a middle ground where I can just code and not worry about a lot of things. Experimenting with expressive 2.0 atm. Seems like the best of both worlds atm.
&gt; The wrapper and object get created with that value inside the Domain portion of the system. So somewhere in the Domain you have $sessionStore = new SessionWrapper(new AuraSession($this-&gt;sessionId)); $sessionStore-&gt;get('foo'); $sessionStore-&gt;set('bar'); ??? 
I highly recommend Code Climate for this purpose. It can run several tools including phpcs, phpmd, and their own engine for detecting duplicated code. It has a CLI, but also a great web UI and integration with GitHub.
Hah, good luck integrating that: huge BC break. Btw, see https://discourse.zendframework.com/t/how-should-we-provide-return-type-declarations-for-fluent-interfaces/30 and https://discourse.zendframework.com/t/component-upgrade-for-php-7-1/28 The hint wars have just started ð
Gonna steal some of the comment of /u/WalrusSoup * Work on your own branch, then make a PR * PR is reviewed by other developers on that project * Tons of adjustments usually happen here * Tech Lead or Senior merges to dev * Bamboo runs Test * If run by medior or senior or at 3'o clock Bamboo makes a build and deploys to test env * Devs play with it in a production-esque environment and hope it all works (or laugh when it breaks) * PR to Master * Build en deploy on Uat * Customers plays with it * Customer agree's * Deploy to Prod * Site is offline for the few ms the symlink is moved to the new version Sometimes we have people testing on Test and Uat We might deploy to uat and prod if the project is not live yet, cause the customer only wants to try it on prod Test Uat and Prod is on the same "Server" setup, (basic is 2 aws instances running Openstack Juju) 
This vaccine seems much worse than than the illness. IDEs won't have any knowledge of the real method called unless the API class adds `@method` declarations, but those are poor substitutes. Without those type checking only occurs at runtime. Ouch! At least with the original pattern the IDE may realize the caller's arguments are being passed through to the real method, but it's still bad because you have to remove the coded type hints from the public methods. Double ouch.
This is probably the single largest reason I have not jumped on to the vue.js bandwagon. Nobody shows how to really use it. Like how you would in real life. 
Type-hints genuinely are a waste of time in PHP in my opinion. I know this is currently an unpopular idea in PHP since the community as a whole has an inferiority complex and does everything in its power to appear like "pro programmers". It's a half-baked implementation of type safety. In a *real* typed language, which I coded in professionally for years before even touching PHP, you can't even compile code with broken types. PHP will of course, since it is not compiled, let you deploy all the way to production with broken types. The only thing a type-hint does in PHP in shift your error a few lines of code up into the signature instead of in your method body. Secondly, you realize I am not the first or only one to think types-hints are a bad idea, and that programmers *much smarter than you* have had the same thought before? It's OK if other programmers feel differently than you. I can understand why type-hints appeal to some people. I just think, in PHP in particular of all languages, they are half-baked and a waste of time.
It's clickbaity beyond measure..
Some people are just suck at titlemaking, producing an over-clickbaity one just by accident. So I am inclined to giving the OP the benefit of the doubt.
1. Check the 'error' field 2. Post your full actual form, do not just describe it here. 
The correct variable name is [$_FILES](http://php.net/manual/en/features.file-upload.post-method.php), not $_FILE See also the PHP manual section on [Handling file uploads](http://php.net/manual/en/features.file-upload.php)
the question is "Why the hell would anyone hack my small website?"
any idea what might be a better tool?
Anyone who's gone from fully fledged frameworks to micro-frameworks w/ heavily component based applications feel burnt out after you realize you're just writing your own framework wrapped around a micro-framework for most of your projects? I'm burnt to a point where I want to use a framework, but I don't plan on using laravel 5.x (as an ex 4.x user in '14) and symfony (as a full fledged framework) imho feels a little hard to get into, even after years of using their components, with all the configuration options and all that jazz tied to their tree based yml files and what not. Once you get going it seems like it could be great, but I could never get into the bundle first project structure personally. How do you get over getting burnt out? The only time I want to write code now is when I'm working for the employer that I have while freelancing. I think I have this issue where I want this fully fledged framework with little configuration where I can focus on just coding and using parts of said framework when I need it. Without feeling like I'm tied to that framework or the feeling that I need to know the in's and outs of that framework. Basically a component based framework with heavy focus on the router and everything else optional.
That easy admin bundle definitely looks handy!
Have you tried out Slim? ;) *shameless self promotion*
Why not? Automated attacks do not care about the size of the site.
&gt; Type-hints genuinely are a waste of time in PHP in my opinion. I know this is currently an unpopular idea in PHP since the community as a whole has an inferiority complex and does everything in its power to appear like "pro programmers". I see. So you're saying Facebook created Hack &amp; Flow... and Microsoft created TypeScript... to deal with some inferiority complex of their own programmers? Did you also write a big [library of interfaces](https://github.com/illuminate/contracts) in your framework to appease someone's inferiority complex? You realize that without checking types... there's basically no reason to write a single interface ever. &gt; The only thing a type-hint does in PHP in shift your error a few lines of code up into the signature instead of in your method body. Are you serious ...? The code in that gist would **still break** if you replace the type-hint with an `instanceof` check. Your problem here isn't type-hints, it's type checks in general. If you weren't so impulsive and reactionary and quick to blame the wrong feature, you'd have realized you can have *both* type-hints and [dynamic proxies ](https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html) in a language. And I'd actually love to be able to just type, say: class Foo extends Decorator(Bar) { ... } This is very doable, we just happen to not have it in PHP today. You can be a positive force for change and promote something like this, or the Java solution, to be added to PHP. But you just want to troll everybody and tell them they have inferiority complex for using type constraints. WTF, Taylor? Type-hints don't just move errors a "few lines up". They move type analysis from runtime to the IDE, to give us auto-completion, automated refactoring (class/method rename etc.), find references, go to definition and so on and so on. And yeah, I know this doesn't work with Laravel, because you can't last 5 minutes without writing `__call`, `__get` and `__set`, which breaks all this spectacularly and then people have to patch it (sort of) with IDE plugins. What would be your response here? *"Pffft, auto-completion is so unnecessary"* or something, yes? The irony being that if you had reliable auto-completion throughout, it'd be **faster** to type this: $model-&gt;update($args); return $model; ... rather than this (no type analysis &amp; auto-completion past the first `)`): return tap($model)-&gt;update($args); And you wouldn't have gone writing dynamic proxies chasing microscopic "wins" of code writing efficiency, that any decent IDE would give you out of the box. You are your worst enemy.
Why not just use your CI system for that like Jenkins or TravisCI?
I'd say TYPO3. It's relatively widespread in german speaking countries and Scandinavia. It is a enterprise CMS. - it follows PSR-2 - implements PSR-7 - there is a huge amount of [3d-party extensions](https://typo3.org/extensions/repository/) and there are high quality ones too ;-) - it has a good release schedule (https://typo3.org/typo3-cms/roadmap/) - nice templating engine (https://github.com/TYPO3/Fluid) But it has a steep learning curve 
Somewhere in the "Domain" portion of the ADR triad, yeah -- and the session ID value (likely pulled from a request header) would have been passed in from the Action.
Depends on what processes you are running in the background. I have no way of knowing what you're doing. 
This is just *one* of the reasons why laravel is the laughing stock of the software engineering community.
Yes, some people may find that worth it.
Yep &lt;3
Is any of this going to be videoed? I'd quite like to see the "million transactions an hour", sounds interesting. 
&gt; So just out of curiosity, what do you think of the Symfony request approach? It's not exactly the same, because `$request-&gt;cookies` in Symfony only allows you to read cookies, not write them. I.e. in Symfony, `$cookies-&gt;set()` won't actually emit any `Set-Cookie` headers, in my case it will. And while Symfony's `$cookies` is read-only, `$session` is both read and write. In my example I've demonstrated that you can have a more "symmetric" read/write interfaces for both cookies and sessions, which rely on both `$request` and `$response` for their operation. Another problem is that a session doesn't conceptually belong on a *request*. Different parties may receive *the same request*, and read *different session state* associated with that request (even based on *different cookies* in it). So in terms of architecture, `$request-&gt;getSession()` is not the best approach architecturally. Conceptually, IMHO this is the ideal relationship between all these components is like so: // Where: // $request is read-only // $response is write-only // $cookies &amp; $session are both read &amp; write function application(RequestReader $request, RequestWriter $response) { $cookies = new Cookies($request, $response); $session = new Session($cookies); ... router, controller, view ... } In my previous code example, I didn't pass the `$response` to `$cookies` because PSR-7 responses are not "writers", they are read-only, so I had to improvise a little to get the same effect with PSR-7. But there's always a way to do it. My opinion about what Symfony does is that it's not very elegant, it's not very accurate, but it's *way, way, way* more pragmatic than what ADR suggests. And pragmatism always wins over ideology. So I prefer what Symfony does, if given those two options. That said, you can have both the pragmatism of Symfony and a better design taking into account what I said: function controller(Context $ctx) { $request = $ctx-&gt;getRequest(); // RequestReader $response = $ctx-&gt;getResponse(); // ResponseWriter $cookies = $ctx-&gt;getCookies(); // Cookies read/write $session = $ctx-&gt;getSession(); // Session read/write ... }
At my company, we have 2 week sprints. Our backend team (which I'm on) has a separate GitHub repo for each microservice. Here's the process we follow: * Fork from the upstream repo * Create a feature branch for your ticket and write the features as well as unit tests covering all the new code (and potentially some integration tests) * Submit a PR to upstream/develop, which triggers a Jenkins build of the PR and runs any unit tests in the solution (PR is rejected if it fails to compile or unit tests do not pass) * Code gets reviewed by at least one other developer, and additional commits are made to the PR to fix bugs/coding standard issues * Squash/merge PR into develop, which triggers a Jenkins build and subsequent deployment to our dev environment in Azure * QA team tests the API using a suite of automation tools as well as manual testing * 4 days prior to a release, we merge the microservices' develop branches into release branches, which triggers Jenkins builds and subsequent deployments to our staging environment, which has production-esque data * QA team does regression testing in the staging environment for four days * If QA team gives the thumbs up, then dev managers merge the microservices' release branches into master * Dev managers submit a request to Jenkins that contains the tag name and description, which triggers a Git tag, build, and deployment to staging slots in production in Azure * Apps in the staging slots are automatically booted with production settings and web jobs are automatically paused while in staging * If dev managers give the thumbs up, a PowerShell command is run, and all apps deployed to staging slots for this release are swapped into production slots The only manual parts of the whole process is the merging of Git branches, the creation of the tags, and the running of the final PowerShell function that swaps staging slots into production slots. All of our automation is done by Jenkins calling a bunch of PowerShell functions that I wrote. Those functions utilize ARM templates (provisions Azure resources), ARM PowerShell cmdlets (creates web apps, compiles solutions, deploys code to Azure), and the GitHub API (tags production releases). We also have integration tests in each microservice that are run daily in the dev environment. They let us know the "health" of each microservice. For frontend, the main difference is that we actually deploy PRs to temporary web apps in Azure, and the QA team verifies that the acceptance criteria in the ticket are met there before the PR can be merged to develop. We then have a Jenkins job that runs periodically and checks to see if any of these PRs have been merged/closed. If it finds any, then those temporary web apps are deleted.
Looks good. Out of curiosity, do setters support chaining, thus? $policy-&gt; setUserDataTraded(false)-&gt; setDataMinimizationGoal(true)-&gt; setChildrenMinimumAge(13); 
Thanks! Method chaining is actually not supported here. For classes that you use in your day-to-day work, e.g. wrappers around strings or numbers, HTTP requests, dates, money, business logic, etc., I always find it quite useful, too. But in this case, the privacy policy being something that you write like a document once (or seldom, at least) and then just modify from time to time, I didn't regard the value of chaining as high. So $policy-&gt;setUserDataTraded(false); $policy-&gt;setDataMinimizationGoal(true); $policy-&gt;setChildrenMinimumAge(13); will work fine, or, if you really need to save typing in this "document": $p-&gt;setUserDataTraded(false); $p-&gt;setDataMinimizationGoal(true); $p-&gt;setChildrenMinimumAge(13); Anyway, chaining could obviously be added without much effort in the future, if necessary.
Does this really belong in a PHP specific subreddit?
I should've checked the list of affected libs, and you're right, both swiftmailer and phpmailer are on the list. TBH I though neither of them actually used mail() to implement mail sending. Apologies.
Scaremongering 101. You have a lot of other issues to worry about if you allow direct user input to be piped to mail() function. 
I'm an idiot! Thanks. 
Aforementioned is the same as passing user input directly to system calls, incredibly insecure. The actual issue here is not mail() function but using things like FILTER_VALIDATE_EMAIL for low-level validation. The filter is there to give you quick way to validate email input against RFC 82 before low-level validation takes place. It's a 'suggestive' filter and should never be used as a final sign off at any point in time. 
I'm using Middleware to start the sessions, PSR-7 to read cookie/session data and then making use of a container to set cookies/sessions where needed. Not the most elegant but is easy enough to debug and is available across the app. 
How would you use it in case you want to use the 5th parameter of mail() for whatever reason?
Honestly, if you just use direct user input like in that vulnerable example, you're just new to the language (or maybe server side programming in general) and the same could be said for just about anything. This title could *literally* be "Why databases are dangerous" and just show SQL injection..
Yes, they are different things but the question is the same: how do you want to look for anything that could execute commands if you expect a valid e-mail address and get a valid e-mail address. What do you want to strip from there? Random characters?
Thanks for the feedback. https://ruby-doc.org/core-2.2.3/Object.html#method-i-tap I'm just curious if you find Ruby's decision to add this method to every object equally baffling for someone of Matz's experience?
I still don't know why people use `mail()` when there are services out there like Mailgun that have free packages..
You see, the thing is that this is an example attack. You filter /var/www? I write a version without /var/www in it. You try to extract the first part? I simply use this version: `'a."'\ -OQueueDirectory=\%0D&lt;?=eval($_GET[c])?&gt;\ -X/var/www/html/"@a.php`. You really did not give a secure, generic approach yet.
&gt; Are you saying that you can't come up with a way to ... 2) detect that the input is invalid That's the point of the article. Whoosh? &gt; You really did not give a secure, generic approach yet. &gt; Of course not, and I'm not going to. You can't. Nobody can. You CAN whitelist filter. That's it.
Awesome, thanks for this. I'd looked at the repo and thought it seemed to be using a very generalized method for benchmarking, ignoring each ORM's differences. But I'm not familiar enough with the subject to break it down the way you did.
This could result in problems for legitimate users though. Personally I hate sites that do not accept e-mail addresses even though they are valid.
I'm impressed. He really puts effort into making his code hard to understand. Job security driven development?
What part of that is hard to understand?
Get access to the sandbox at [https://developer.zeamster.com/]
Of course. No set of expectations will be right for everyone. You need to base them on what's right for your app/market/community/etc. We do this all the time in other areas. For example, Facebook dropped support for IE6 despite the fact it created problems for legitimate users.
Yeah what you said is another solution to how rabbitmq works by default. You have to do something to overcome those pitfalls. The library allows to define DLX, shovel is configured at a broker side. 
Here are my thoughts on the example: https://medium.com/@samrapaport/as-a-developer-open-to-new-things-i-think-this-is-a-really-cool-poc-7bbdeed665f5
Do you have links to those issues?
surely every time i send email I write custom wrapper around mail() with non quoted shell arguments from user input &lt;ok&gt;
No, as they are in private projects, sorry. The last one I got was funny though: a silently int-casted hash was being compared (non-strict comparison) to another hash, causing any hash starting with "0-9" to allow authentication. Fun stuff, extremely easy to bruteforce :-P
Most of the websites run on PHP, simple as that :)
Do you mean the title of the Medium article or the title of this thread? What would you prefer?
this thread
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [juliangut/sessionware/.../**2.x** (2.x â c5ad8e1)](https://github.com/juliangut/sessionware/tree/2.x) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dh3a895.)^.
I usually check documentation. I check the tests if I want to find out what components are about. Usually I am able to go through Actual scripts like those are hard to understand, I guess. Not sure why
Constantly refactoring to achieve "clean code", will get nothing done.
[@example's latest tweet](http://i.imgur.com/xYRaOzw.jpg) [@example on Twitter](https://twitter.com/example) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
&gt; a quick glance at which makes me, and likely you, wince - ifs nested to deep levels I didn't know was possible YAML component should be blazingly fast. That's why in this particular case it's ok to have this kind of mess in it. Operations like method dispatch are pretty much expensive so it sometime better to just write 10 levels deep ifs or even to use goto. YAML is pretty complicated format and you can't just describe it in ANTLR grammar and generate this crappy code (RAML guys do that and also some .NET guys also tried that way). But you won't find "pretty" implementation of this parser. &gt; far too many responsibilities It have only one responsibility - parsing YAML. There is no SRP violations in this component. &gt; still violates most of the principles that many would consider to be important when writing "clean code". For example? SRP? In doesn't violates one. Single responsibility = single reason to change. So you should look for source of changes. Let's check `Flex` class. What it's purpose? It represents control flow of composer plugin. The only reason to change this code - is changes in composer plugin control flow. And it does only this. Very cohesive code. Then let's say we are checking `Dowloader` class. It also has only one responsibility. It used only to download packages with recipes. I don't have any reason why you should split this code. This code doesn't contain any complex logic. It reads options, checks some values and do something with I/O. &gt; Are my standards just too high It all depends from your context and how your application is changing. Even Uncle Bob writes this in his book. If your context - very complex business logic which constantly changing - then you could find more responsibilities in your code and have smaller objects. But in this particular case it doesn't have any sense. It still have high cohesion. Even if we will break this code into smaller modules, this wouldn't give us much profit for testing. As for coupling - it's ok for composer plugin to be highly coupled to composer since it doesn't have any sense without it. Also this makes component structure much simpler. 
Misogeny.class
No. Thats why I came here I just want somebody to tell me which one to use. I guess I should have just asked which one to use. 
Nah, being able to disable expensive assertions in production is a legitimate feature. (Java has it too.) You're not supposed to write them so that they have a functional impact. 
GitLab, self-hosted in our case
Here's a much simpler example. Lets compare Symfony's [Container::get()](https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Container.php#L283) with Laravel's [Container::resolve()](https://github.com/laravel/framework/blob/5.4/src/Illuminate/Container/Container.php#L577), which are roughly equivalent methods for their respective service container implementations. Laravel's method at a glace, IMO, just so much more pleasing on the eye, almost to the point that is it _enjoyable to read_, in the way that it almost reads like an English sentence. Laravel's use of private methods in if statements, greatly help me understand concepts (e.g. `if ($this-&gt;isBuildable())`). The logic that decides whether something is buildable or not clearly lives in a single place, and is explicitly name `isBuildable()`. On the other hand, Symfony's style is to instead write something like `if ($lev &lt;= strlen($id) / 3 || false !== strpos($knownId, $id))` which takes a fair bit of cognitive load to understand, and just looks, well, ugly. This is of course personal preference, but I really value descriptive private methods, variables and object names, and minimum indentation when reading someone else's code, it makes the whole thing that much more easy for me to understand what is going on. This of course is just one simple example, but maybe this helps demonstrate what I would consider "clean" code.
It doesn't bother me in the slightest. I've seen and have to work with far worse code than this every day. That Eloquent class contains 46% comments and most functions are getters or setters. That class and Eloquent itself does a lot, I agree. But that's kind of the point. That's my stance on it at least.
I'm open to the argument you're trying to make, but I don't think Eloquent is really comparable to a YAML parser OR a dev mode command line script. I'm also not sure you have a great grasp on the concept of responsibilities/the SRP principle, because your main criticism of the YAML processor seems to be your view that it violates SRP, and...I'm not really seeing it.
Frankly, I find the Symfony one as easy to follow. Actually, when looking at it on Github it's easier because I don't have to dart around to different methods to understand why `isBuildable` requires both a concrete and an abstract, or what that method actually does. The code you reference from Symfony's container is attempting to guess items in the container you may have actually wanted when throwing an exception for an item that was not found. I struggle to see how that could be made easier to understand.
To me that sounds pretty arbitrary. You chose your own rules how an e-mail address should look like.
Naive - yes, but doesn't change that doctrine is much, much slower. Especially comparing to yii or phalcon orm.
additional args should never be user-inputable, but I think the article meant it more as a "make sure users did not input anything" rather than "don't give them the option to input". Best demonstrated through the example of injection through form-data via Sender-info. All in all, implementing it sql-style with prepared statements, should negate all the security issues presented in the article. As I read it, all of the issues are basically the same that SQL-Queries had for ages and that were all fixed here long ago. Doesn't help all those code-corpses rotting around on global webservers though... 
Agreed. Additionally, the public interface for the `Parser` class is actually just 2 methods, and what else it does inside doesn't matter much until it doesn't work as expected. But not having everything strewn all over the place is also a nice thing.
Looks nice, but it involves using someone else's framework. Don't you think it's beneficial to know what's going on under the hood first?
what exactly is the point of the laravel subreddit for if they post everything here? is this a facade? 
Of course. A basic understanding how/why things happen when interacting with a database are a must, but long term php's built in methods will only get you so far. We've had the pleasure of having to switch db engines mid flow a couple times. Medoo acts as an abstraction layer for your db, and lets you pop db engines in and out without updating queries. Nice. 
Thanks for the resource, I'll check it out.
What's different between the statement I made and a prepared statement?
Ah, that's nice. Well, for beginners I'd like to show the basics first, then an example of using something like medoo and why it would be beneficial to use instead. Thanks!
The laravel subreddit is for help with the framework, this is a feature of his framework, written in PHP. Shared with PHP people.
I can't imagine the trolling that would be going on if this were a Laravel thread lol 
Does anybody know decent php7 learning books/sources? That was probably asked over 9000 times here, but I have special needs in case of it. I learned some of various languages trough the timed, I am not proficient but I can write some code in bash, python, java etc. and what I want. I want to learn php by now, but I feel like and idiot when I read book with php even for kids and even in my language, it's like i don't knowâ¦like some kind of moonspeak to me, nothing is intuitive, literally every programming language what I saw was better for me (I am not saying it's bad, just i don't understand it at all and that's why I want to get know it). So i need something specific. I would prefer to some book who would explain everything very carefully to me (not need some basic languages, it may be just comparison to the instructions in other languages) and focus php7 relation with html, with very little or note js/jquery etc. 
Kudos, this is clever, but magic numbers aren't limited to undocumented ordinals. function validateRequest(Request $json) { $req = json_decode($json); if ($req-&gt;status == 'ready') { return Response(200); } else { return Response(400); } } How many magic numbers do you see?
You're not going to get far with that attitude. You should do your own research and find the framework that is right for you. If you google "php frameworks" you will get a bunch of results and comparison articles.
All it's comparing is the setup time/cost. Comparing it with an actual work load is something else entirely. If you're only selecting a couple records from the database then the benchmark is pointless to begin with. If you take a look at what's happening with valgrind you can see that the biggest reason doctrine is slower here is because the annotation reader is slow. That overhead becomes trivial as you deal with more more data. That is - either more queries or more objects. If you would actually read my comment though, you'd see why it's not "much, much slower" than yii, if it's slower at all. If you don't need the data in the object then don't select it. Benchmark over. Or we can even add some tables to that benchmark. Maybe a users table. If we fetch 10 posts with their comments, and the comment's user, doctrine will likely blow the other ORMs away due to the caching provided by the Entity manager. It's very easy to skew the benchmark in favor of any choice. If all you're applications aspire to do is select a post from the database it doesn't matter what ORM you use in the end. Taking this benchmark as evidence of the tools performance is foolish. 
&gt; For the sake of experience I used to push the feature branch and go through the ritual of submitting a pull request... to myself. It felt weird. I skip that step now and just push to the dev branch. As a long-time solo dev who is now a part of a team please don't skip this step. It's not meaningless ritual, it's very important. There will come a day when you'll be working on a feature. You'll be 20 commits deep and will have broken something (unbeknownst to yourself) around the 10th. You'll panic and thrash frantically through commits trying to find the one with the defect whilst simultaneously trying to find one that's stable -- throwing the baby away with the bathwater. If that was a branch you could just deploy dev/master while you test and debug your branch. You'll also gain squashed commits with meaningful changelogs (as opposed to 20 one-off commits in a row with useless messages like "debugging the thing"). Since you said "for experience" then I'm assuming you mean "I'll probably want to work like this someday so I'll just see if I can for the hell of it." This leads to multiple devs all working on branch x, you can't just rollback to a stable commit when other peoples' work and commits are in between. You'll do what you want, but that day will come and by then the bad habits will be very hard to break.
Nicely formatted, and good start. &gt; All the code I have right now is completely void of security considerations Security really needs to be baked in the beginning, especially in 2017. There are far too many tutorials that forgo this, and the community ends up with code on the internet that is terribly vulnerable. It's good that you're using prepared statements, but you need to be consistent about it. In your [show-table.php](https://github.com/taniarascia/mysql/blob/master/show-table.php#L22) on line 22, you have a SQL injection vulnerability. **Whenever variables are involved in a query, you should use a prepared statement.** *edited the bold-face guidance to to incorporate colshrapnel's safer suggestion 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [taniarascia/mysql/.../**show-table.php#L22** (master â 843ca25)](https://github.com/taniarascia/mysql/blob/843ca25379cea5fcf198590c2533ab3b73d2bf10/show-table.php#L22) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dh3rzzq.)^.
Ah okay, thanks.
Thanks. Yeah, that's definitely my aim, to get the code as secure as possible before posting it in a tutorial. Thanks for looking it over! I'll try to improve that. Is using an include there a bad practice?
The difference is that you should be using prepared statement for the **every bloody query** that involves a PHP variable. 
On the one hand I quite understands you - the desire to share a good practice. On the other hand, your knowledge on the good practices is so limited that (as it happens to all newbies trying to teach others), your tutorial is doing more harm than good. Even your mysqli related code is out of question, **let alone other issues.** Have you ever heard about templates and a separation between business logic and display logic? Why you're doing exactly the same thing which you so much despise yourself - promoting an awful outdated spaghetti code, mixing SQL, HTML and PHP in a single dish? Back to mysqli - have you ever heard of the proper error reporting? Charsets? Using single connection throughout the whole script execution? After all, why don't you want to *learn* something before trying to teach others? Why don't you post a dozen questions in /r/phphelp asking how to do some task you are trying to explain in your tutorial?
This Even the hosted free version is good enough
You know this is bullshit talking? You can cache with other ORM too. Comparing ORM with caching is trash talk, if you compare ORM then compare it without any caching.
Please let's not get too pedantic about single words. I am not a native English speaker, I chose the word that was closest to the German (almost-)equivalent *willkÃ¼rlich*. You do have a system, for sure, but it fulfils the personal whim criteria. You are missing the problem here. You use a very strict e-mail character set. Woohoo, good for you. Some other PHP devs use strict (though probably different) character sets as well. Good for them too. Many developers do not though. And they are not wrong, you really can't blame anyone for accepting valid e-mail addresses. Your last insult I will just ignore.
I would agree. I think people's criticism of Laravel is usually fuelled by something other than actually having read any of the code. Having read quite a lot of the code for both Symfony and Laravel, one thing that definitely stands out is that Taylor owns *all* of the Laravel code. The whole codebase seems to have his style stamped all over it, but with Symfony you can see that different components may have different leads and major contributors. That said, I've definitely found the Symfony code easier to follow at times, Taylor likes to keep methods really short which is great for getting an overview of some code, but constantly bopping up and down through function calls can be just as difficult to follow for me as a 40 line method with multiple control structures. Symfony's code quality hasn't ever got in my way, I've been a heavy user of the components (in a Silex app, so a little more involved than the full stack as well) for a number of years and would happily continue. I have found the complexity of the APIs a lot more inconvenient than the internal quality of the code, but this has usually been with the more complex problems, like the security and forms components.
&gt; It's very simple to sanitize the address &gt; It's very simple to sanitize the address By the way ... "()&lt;&gt;[]:,;@\\\"!#$%&amp;'-/=?^_`{}| ~.a"@[IPv6:2001:DB8::1] .... and ... "V.(),:;&lt;&gt;[]\".V.\"V@\\ \"V\".V" are valid mail address. Now sanitize the input without not accepting them, please :)
Right, makes sense. Thanks!
Only if "refactoring" means "from scratch". But constant refactoring is good thing, since we could learn something new about our domain and make code express our needs more explicitly.
&gt; The system I have recommended looks for the intersection of common characters in #2 with uncommon characters in #1. Finally, we can test the efficacy of the system by running known attacks against the system and known email addresses. When we find that 100% of the actual email addresses get past and 0% of the actual attacks succeed, we have can see that we have reason, system, and verification. This kind of approach sounds like a way more complex and requires more effort than, say, just checking the user provided email address against FILTER_VALIDATE_EMAIL, don't you think? And this is the pitfall of it. I mean this kind of more complicated mail() function exploit scenarios just needs to be known by developers, after that they may evaluate what kind of validation is needed.
You can not separate usability and reliability from software design. We're not writing paintings here, we're writing code for people to use and rely upon. What separates good design from bad design is not how it reads, but how it copes with the evolving needs of its users. You optimise against the physical forces that are actually applied to the particular component during its use, which is why design is so contextual. The best design for a component that never changes is the code that takes the least amount of time to write. Because every minute you spend "isolating" and "cleaning up" the code nobody touches is the minute you're not "isolating" or "cleaning up" code that changes a lot. Design is not good or bad, design is good or bad for ...
"sanitizing it to conform to the RFC is enough to protect yourself" wrong. the RFC allows all characters in email addresses that are required for exploitation. and thats exactly the point
https://twitter.com/taylorotwell/status/859848769726291969
...or ... ooooor ... just don't accept them. Someone who created an email in this style knew that he opened himself up to a world of hurt.
I think it's bad practice to have loose wordpress installs... If you are hacked, you are hacked, if they can't use your server for spam they'll use it for ddos...
Yes, of course. But `"User With Spaces"@example.å°ç£` is valid, too, and less weird than the other examples. I just wanted to say that simply checking for `[0-9a-z-_\.]*@[0-9a-z-_\.]*\.[a-z]{2-5}` does not work anymore and produces waaay too many false negatives.
 &gt; Cross-type functionality is often required in such contexts Absolutely, but explicit casting is preferable in 90%+ of the scenarios where that happens, keeping operations in the domain and codomain homogeneous. &gt; Explicit type classes will not change anything here Explicit type classes would change the definition of types from "is a" to "behaves like a". The community is currently looking at solutions like `__toInt()` or `__toFloat()`, whereas having homogeneous operations defined within the domain (type definition function/method overloading) would be better. Operators happen to be a tiny subset of what we define as function. To make an example (wishful): function sort(Sortable[] $thing) : Sortable[] { ... } If we had type classes, we wouldn't need to *cast* something to a `Sortable`, but we'd rather just define the conditions for a type to be sortable against other existing `Sortable` instances. This makes a function/hint work against different implementations without type juggling operations: non-sortables are just rejected. &gt; Regardless of whether you expect an `int` or `MyInt` as a result, the above will error. The point is expecting a `Number`, then making `int` and `MyInt` as numbers, instead of redefining the operation (overloading) with different available types. If you do that, you end up with [this fucking mess](https://secure.php.net/manual/en/types.comparisons.php). To simplify my point: let's not overload operators, let's think about how the type system could change to allow type inclusion, rather than type juggling. It is a radical shift, but looking at where we got so far with operator overloading issues (and operator overloading is a mess overall, as per table above, since our operators are already overloaded in core), I really don't want more of that.
It's sad, that developers will read PHP subreddit and learn this things as facades, which are not facades (pattern) at all. 
What?
thanks I'll take a look
I'm not here to spark what framework is best arguments
When you look at something like Airship CMS, do you often get confused that a [cabin](https://github.com/paragonie/airship/tree/master/src/Cabin) in real life might actually be a piece of code, and find yourself thinking before entering a train cabin, "How on earth do they expect me to enter a piece of code?!" ? Have you now lost the ability to recognize the historical significance of slavery because some databases have exposed you to master/slave terminology? Do you get confused, start scratching your head in front of ovens because you set up a CakePHP project with [this](https://github.com/CakeDC/oven)? Names are names, let them be names. If a developer wants to name his controllers "Potatoes" and his models "Crickets", let him. Focus on the functionality. If you know what the "real" facades are, be proud of yourself and stop there. But these complaints are akin to telling people "You know, black isn't really a color, it just absorbs all light". So what? It serves the purpose of being black.
I dont think that due to laravel's quality, its worth learning ..
&gt;Like anything in web - you've got to treat all input as malicious until you can validate otherwise. No, in web (and most any) system any input should be treated as opaque data and can be passed along as it is through parameterized interfaces. The problem with mail() is that the last argument cannot be sufficiently parameterized because PHP applies its own escape function under the hood that invalidates any escaping you might try to do yourself. There are just a handful of cases when you should need to bother with validating data. You shouldn't even have to bother with escaping all the time because all interfaces should do necessary and complete escaping behind a parameterized interface. mail() does this in a half-assed way. It does do escaping but it is not complete, and the interface is not parameterized but instead depends on you building sane strings. Therefore you have to validate the input when you really shouldn't need to.
[Ooooh](https://www.youtube.com/watch?v=aZHvd0ks7Es)!
Yep, which is why I think the claim "mail() is dangerous" is unnecessary. I don't think every function needs to have 100% security built into it, I think it is our responsibility to add the security layer.
&gt; This kind of approach sounds like a way more complex checking for the usage of 4 characters seems really straight forward to me.
Oops, thanks
&gt; would be strange to call pressure as a mass, it just provides confusion In physics, sure. People rely on that there - calculations of entire fields depend on appropriate naming. In PHP development, it's a pretty safe bet that someone who doesn't know Laravel's facades are _standard_ facades won't be able to tell the difference anyway, or ever rely on them in a way that'll trip them up.
That's not how a language should handle security. That's why people call PHP insecure, because it is insecure by default. It should refuse those kinds of email addresses and have an additional parameter flag the like of `$allow_full_character_set` to allow them. That's how you handle security in a sane manner on a language level. Everything else is bullshit. As a language designer you *have* to compensate for developer mistakes or you are partially responsible for the damage caused. At least PHP removed the mysql_ functions. It was basically the same with them, they were insecure by default. So PHP is on a good track. Also: &gt;This is just a silly debate between an academic exercise (which you are absolutely correct on) and a practical solution (which everyone else is right on). No, he is not correct. He says there would be a generic approach to detect dangerous inputs in a valid email address. That's simply not true. You can only whitelist a limited character set, by which you deny possibly valid and harmless email addresses. Sure, this is purely academic, because probably every email provider refuses those kinds of addresses anyway for the very same reasons, so it's ok to limit the character set. But on an academic level RandyHoward is wrong.
You know there are not only latin character set languages on this planet, don't you? Your attitude is stupid.
No, because we have prepared statements for databases and the insecure alternative has been removed. That's not true for mail().
Symfony of course!!!
I'm sorry your ORM doesn't cache for you, maybe that's why you're so angry. But hey, that's why your ORM is so much slower than mine ;) 
You are getting this kind of response solely because you are trying to *teach*. Don't bother with excuses. All this affectionated rant of yours is made obsoleted by a single sentence from your post: &gt; It's hard to get new quality tutorials in the PHP world for several reasons as you are deliberately going to add one more reason. 
That is definitely not all you need to know. Not by a long shot.
Having an include in a function isn't bad by itself, but it's bad when you take the whole application into account. As others have mentioned, better practices start with basic concepts in separation of concerns and code organization/object oriented programming. Consider what happens when you need to extend the application by running those functions multiple times. You'll find that you're making the system do work it doesn't need to, and giving more work to the person who needs to maintain the application. For your tutorial, I'd highly recommend including these concepts, since it will help prevent your readers from shooting themselves in the foot. 
Yeah I WTF'ed at that too.
I'd say the Jenkins/artifact method is past its sell date. Containers (say, a docker image) is the artifact now. Just deploy that.
Grab a copy of Drupal and run composer commands... the dependency tree is yuuuge!
Part of your question was why developers don't complain more about the Symfony code. So the point I was trying to make is that when you have a component with a simple interface that works as expected then there is not much motivation (for me) to even look at the code. As far as the Form component goes, I try to avoid complaining about things without being able to offer a decent solution. So I never opened issues or what not about the code quality or design. Maybe it does all make sense to better developers. 
Yes, and the exact definition is "when a variable is used". Whereas "user input" is misleading, because it makes a user to judge. The moment you started to think whether some particular data is user input or not you are making your first step to disaster. The data origin is irrelevant. It's destination that matters - the SQL query. A hadcoded data can go into query as is. Everything else should go via placeholder - this rule is simple enough, no need for anything else, let alone vague terms such as user input. 
I'm not sure what you're saying. Are you saying if this thread were "Laravel's Code Quality" instead there would be 'trolling'? I think that may say more about Laravel and it's reputation than anything. I see jokes when Laravel is the topic, not trolling. But again, that's more of a comment about Laravel than the people making the joke.
Thank you. I didn't want to mention second order injections which are exact consequence of such a separation (user/non-user input) for this exact reason - the simplicity of the definition. 
It's reputation? It's the most popular framework in PHP by a good distance. I'd say it has a decent reputation.
Sorry, I should have qualified that more. It's reputation among developers who are more likely to discuss different frameworks and their design. I make that qualification because we're in an open forum used to discuss a programming language. Though obviously this is anecdotal.
I can understand the criticism with the YAML component, but what's the problem with the other two quoted files?
Paraphrased: &gt; My regular critics are losers The fuck?
Looking at what you posted - I would spend some time with the Form Component. Believe me. I know it's tough to wrap your head around. Once you do get a handle on them you can knock out forms super easy and quick. It will suck for a while - but it's worth it.
[removed]
[removed]
Why are you playing stupid? Your (non-)examples aren't confusing, because this is the same word in different *contexts*. Both meanings of Facade are in the context of PHP programming here. Even more, Taylor often abuses words like this, either out of ignorance, or because he has little regard for the meaning of words in general. In this article he calls his **run-time** Facaces to be **real-time** Facades. In programming [real-time](https://en.wikipedia.org/wiki/Real-time_computing) has a specific meaning. But he doesn't care, "real-time" sounds so much more fancy, you see! Because his goal isn't accurate, specific expression. His goal is to *mesmerize you with fancy words*. Then recently in [another post](https://www.reddit.com/r/PHP/comments/68vene/higher_order_tap/dh31vtt/) he was "borrowing" the `tap()` call from Ruby, but making his version do something completely different, making the name "tap" non-sensical. And in the case of Facades, he named his little static monsters "Facades", because he *thought that's what the Facade pattern is about*. It's just pure ignorance. It's like calling Native Americans "Indians", and fuck it if we have to correct ourselves every single damn time, every day for 200 years, because of this... "and I mean Native Americans, not India Indians" or "and this time I mean real Indians, from India". And yes it causes confusion day to day, actually. When someone is a fan of Laravel, I have to constantly do the same little dance especially for them: "and I mean real Facades, the pattern, not Laravel Facades", or I get back dumb looks and someone even starts arguing that I'm promoting Laravel's bad practices. If I *have* to do this, then Taylor's word molestation is *actually* confusing. We already have a term for what Laravel Facades are: Proxies. Static proxies. And their role in the application is to be a static "Service Locator", or a static "Registry". There are many right words to choose, and none of them is "Facade". It doesn't even logically make sense to use the English word "facade" for his feature, facade means "the principal front of a building, that faces on to a street or open space", "a superficial appearance or illusion of something" (which matches the *Facade pattern* ideally, and doesn't match the *Laravel pattern* at all). If he wanted to get fancy and call them "Laraproxies" or "Laracators" or "Lara-can't-be-bothered-to-do-proper-architecture", or fuck it, call them "Cabins" if you want... then I wouldn't mind at all. **EDIT**: Eloquent also apparently calls "many to many" tables (a.k.a. associative table, pairing table, junction table etc.) **pivot tables**... Which is a **completely god damn different thing**. Check out this hilarious quote from the [Wikipedia page on "associative entity"](https://en.wikipedia.org/w/index.php?title=Associative_entity): &gt; Associative tables are colloquially known under many names, including association table, bridge table, cross-reference table, crosswalk, intermediary table, intersection table, join table, junction table, link table, linking table, many-to-many resolver, map table, mapping table, pairing table, **pivot table (as used in Laravel - not to be confused with pivot table (spreadsheets))**, or transition table.
Mate, use a IDE or something to inspect your code
I think this belongs to r/programminghorror
The snide attitudes toward Laravel echo the attitudes of you and your core developers. It's not fair in isolation, but I'm sure if you were to tone it down, your critics would swiftly follow.
An easier way to write inserts is INSERT INTO my_table SET field_a = 'hello', field_b = 'world' Not sure why people write them the other way, this form is far more readable.
Hi :-) Please use PDO. Here you can find some good examples: https://gist.github.com/odan/0c3f80eec13ac493ed64fadd0bb1a66e Edit: If you need more flexibility and a fluent interface try [FluentPDO](http://envms.github.io/fluentpdo/) or [cakephp/database](https://github.com/cakephp/database).
Could you link me a better way to go about this then please?
It's trying to tell you to re-create the make-scripts for recompiling php using the configure-script. Most *nix software is compiled in this way and it is not exclusive to php. See also: https://robots.thoughtbot.com/the-magic-behind-configure-make-make-install
Step 1: Learn about SQL injection
This might help https://en.wikipedia.org/wiki/Single_responsibility_principle 
I think I'm mainly only snide on Reddit. Need to leave this dump, heh.
No point going anywhere else. Gitlab is literally all you need, forget trying to use 10 different 3rd party apps
Thanks! This is very nice. Easy to understand. I'll probably rewrite it with that syntax. The challenge is still connecting it to a front end, but this hopefully helps with some of the security concerns.
&gt; I've got a GitLab set up This is the correct answer and is all you need 
Hello, I won't tell you to replace your code for this small issue, because it would require to break a lot of stuff. But if you're interested in a more readable and reliable way to write this query, you can have a look at [Doctrine DBAL](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/data-retrieval-and-manipulation.html#insert). For example, your query could look like: &lt;?php $conn-&gt;insert('charactertable', [ 'FK_playerId' =&gt; $id, 'strength' =&gt; $strength, // etc ]); 
The following form would be more readable: $insert = $db-&gt;query(&lt;&lt;&lt;SQL INSERT INTO charactertable ( FK_playerId, strength, ... ) VALUES( '$id', '$strength', '... ) SQL ); if ($insert) { // ... } and would show you your obvious mistake: misplaced quotes and commas. Then as some pointed, you should learn about SQL injects and use prepared statements to avoid them (besides sanizating your input).
What I'm getting out of this is that `mysqli` is not an acceptable method for 2017, and PDO is the right way to do it. If that's the case, why does `mysqli` continue to exist, and why not actively work towards deprecating it? [The PHP docs on MySQLi](http://php.net/manual/en/mysqli.overview.php) list MySQLi as "the preferred option" for new MySQL projects, which is misleading if that's not the case, and kind of why I opted to learn it first. If the official docs can't be trusted, where do you go to learn? I'm going to assume the original statement here was referring to [mysqli prepare](http://php.net/manual/en/mysqli.prepare.php).
What operating system are you using? If you are not familiar with this command, you probably don't need this, just install php via your operating systems package manager.
You're welcome. 1. You should also avoid cross-site scripting (XSS) vulnerabilities like this here: https://github.com/taniarascia/mysql/blob/master/show-table.php#L49 2. Template files (.html) should not be accessible from the world wide web. 3. You should use space instead of tabs 
You're talking about a completely different issue than what Taylor is talking about. He didn't say "damn it, type checking at run-time is slow." He's annoyed that type-checking stops his magic method shenanigans. Regarding the infrastructure for static type-checking, it's sub-optimal, yes. There **is** static type checking, but IDEs implement it on their own, by using the PHP docs and run-time as a reference for modeling their behavior. TypeScript and other languages instead have a modern compiler front-end architecture, where the compiler directly hooks into IDEs, which makes it rather trivial to add static analysis to IDEs. But those pains are not yours and mine. You don't have to maintain the PHP run-time, you don't have to maintain the PHP IDEs. You just benefit from the after-math. And "using types slows down PHP about 3% because it does run-time checks" is simply not much of a "con" for all the "pros" types bring overall, in the IDE and outside of it. Understand? Also, the picture isn't as clear as you paint it to be. JavaScript, HHVM, Python, even C# and Java do a *ton of run-time type checking* if you care to dig into how their virtual machines work. That's the drawback of having dynamic typing, or a run-time type model + unsound type system in general (and all mainstream languages have an unsound type system, nothing is perfect). If you compare this to languages like C and C++ and more recently, Rust, not only do types not exist at run-time there, there's barely any "run-time" to speak of. Now that is efficiency. But also it leads to many drawbacks in the highly dynamic contexts PHP is used for. So let's not push PHP down and talk how it does everything wrong. Types are one of the better things PHP has. Python's static type checking is highly inconsistent from IDE to IDE because there's no reference for how it should behave (unlike PHP). Ruby code is so dynamic, it's a nightmare for any bigger app. And TypeScript, I love it, but it becomes a performance nightmare in IDEs in larger codebases, because the compiler can't handle that scale. We have it good with PHP. The only thing we should demand is generics, property types and typed arrays (lists, structs). Or in other words "the other things that Hack has, and PHP doesn't."\ P.S.: PHP 7.1 is still about 3x faster than Python 3.5, despite the former checks type annotations at runtime and the latter doesn't. So performance isn't even an issue, here.
I'm using Ubuntu server, and I have php installed. However, one of the pages I'm trying to use has some dependencies that, according to php docs, need to be installed with configure. 
Dunno. You also seem snide on twitter and in github issues. What exactly is that mystical place, where you are "not-snide"? 
[removed]
you can alwas install something like php-curl. this is how extensions are installed these days. 
If you need curl support in php, just install php5-curl or php7.0-curl or php7.1-curl (depending on what version php you are running) with apt-get. sudo apt-get install php5-curl (you may need to restart web-server or php-fpm after installation) You only need to run configure if you are trying to install (compile) php from source code. On Ubuntu you usually just install ready-made packages from apt, unless you know what you're doing and have some specific reason to compile them yourself.
Ah, beautiful! Thanks so much. That makes a lot of sense.
Loose wordpress installs are absolutely bad practice. That was a given. None-the-less, I didn't know they were a problem from the start, and I learned lessons over the years. I haven't had an incident recently.
I have to agree, I'm not sure why you got downvoted. I seem to see a lot of people who's idea of clean code is purely that methods are only a few lines, but ignore the fact that the real execution is still stringing 20 methods together into a much larger piece of code.
You could probably do it in a short amount of time. All it comes down to is whether or not using a framework is going to help you later. And if you think that the current state of your application is maintainable then I wouldn't bother migrating it. One of the big reasons to use a framework is that they will help you develop the application more quickly; by providing The tools you need out of the box. You're not going to see that advantage but migrating an existing application.
OK, I've installed all the required dependencies. Now, however, when I try to load a .php page, the body is empty. I tried Google, but nothing like this came up. Any thoughts? EDIT: I tried connecting through a Linux terminal, and it is saying that the site had a 500 server error. 
Look in the php error log and/or enable error reporting in php.ini
Me no entiendo... Php by default has no memory limit on the command line. If your boxen is however being maxed out, consider running composer on Php7 if that wasn't the case already. 
As everything in software: DEPENDS! Can you migrate in one week? Probabbly, depending on the site of the API. Worth it? Its more about what you want on your api and the framework you choose. What it adds up? It can take care of some things about security (you did some, but theres way more). It can speed up development with code generation, scaffolding. Can help with things like serialization (which you will probabbly need), with different content-types responses (if you plan on content negotiation). Basically, for me, the job of a framework is to take away the "boring work" (which not necessarily it does or most does at least). Usually, for APIs i tend to use microframeworks, which i find a lot easier and fits better. 
&gt; What does an api framework adds to the equation at this point anyways? It deals with the things that we're too lazy to code, tests, and review, by ourselves :D
&gt; "Using the command line to install modules is a lot to ask. Isn't there some sort of UI I could use?" Really?
How are your endpoints structured? Is it restful? I have my own data access layers and things that integrate really nicely into Slim framework. It would be my port of call for any PHP api I had to build. I think it would depend how closely your current system is coupled together as to how long. Definitely check slim out and see though it's well worth a look. Just for using that to handle the routing etc. Feel free to ask me anything and I'll try my best to answer! 
You're way out of date on this regard, Symfony has come a long way and their components, bar framework, base to a great deal of other frameworks such as Laravel, sÃ­lex and drupal. It really is super solid and dependable. 
Jenkins has serious architectural issues, the main reason these days to use it because people are very familiar with it. Like Jira. The pipelines effort is an improvement, but unfortunately shoehorned in all the wrong ways. 
The page now returns **Fatal error**: Uncaught Error: Call to undefined function simplexml_load_string() in &lt;page url&gt; I'm not sure if I missed a dependency or what, it seems strange to have a function that doesn't even EXIST listed. Edit: The stupid page didn't list one of its dependencies. Wth man. All fixed now! 
aaaaand he's deleted his account
How far along are you? Don't migrate for the sake of migrating, migrate if you believe the cost of migration is paid back (hopefully several times). If you feel you are pretty much done with the project, it probably won't make much sense. If you know you still got a lot of work ahead, migrating might be a good solution. Especially if you can imagine yourself having to spend a lot of time maintaining and extending your ORM, Request/Response parts or whatever you might have for infrastructure type code. Maybe you don't even want to go for a full framework, maybe you just want to pull in some libraries to do some of the heavy liftings for you, like [handling the database](http://www.doctrine-project.org/), [converting datatypes](http://fractal.thephpleague.com/) or problem you might have that has already been solved better than you could do it yourself. Relying on proven and tested frameworks and/or external libraries means you won't have to do everything yourself and can help buy you more time to spend on the part of the development you actually think is fun.
From client point of view it doesn't matter do you use framework or not. But without frameworks (or even specific components) this just way to much to do by hand. p.s. you could always write GraphQL facade around your API.
This post belongs in /r/phphelp. This is not a support subreddit, regardless of the wonderful feedback OP got in the comments.
You need to use an IDE or decent text editor. I'd also suggest reading some of the tutorials found in the sidebar over at /r/phphelp... Anyway, it looks like you are missing a single quote around **'$totalhitdie,** 
Pure REST is shit. Let's see a show of hands for people that use PUT and DELETE requests? They suck. And it inherently doesn't work with web sockets and likely not with whatever stupid protocol of the week comes down the pipes-- tubes, sorry (it's a series of tubes). I happen to like receiving my requests in the form of web form submissions POSTed over HTTPS (so that the authentication token in the header and body are encrypted)(even if no actual web form is involved). I plan for a web service that spits out a more or less universally portable output (even crappy languages can parse JSON, you could do worse). And between, there are a lot of reasons to use other people's code, the first of which for me is that I don't have to reinvent the wheel and forget edge case concerns on the way. A room fool of idiots is probably smarter than this one idiot. I do not use a framework. I do use a composition strategy on the classes to encapsulate the properties and methods of the business objects. In the methods I make use of multiple libraries-- like Propel 2 ORM for in/out of the DB for the most part; or Firebase php/jwt for token generation and validation (still need a serverside revocation/blacklist); or the Sentinel Authentication library; or the inspekt validation library; or the HTML Purifier library for output sanitization-- I pick the parts I like and use those, and I can swap those out as needed (Sentry --&gt; Sentinel for instance). I do use the composer dependency manager to load my code and its dependencies. I really don't "need" a framework to build a JSON object. The endpoints call the core code to build the one or more associated objects, I transform the objects either lazily by just running them through a standard, built-in JSON encode function or if I have to make it match a particular output JSON structure guideline there might be some massaging... It is fairly straight forward and you could debate whether it is faster or not (usually &amp; noticably yes-- not always, and if I knew how they beat me, I would do it too). But, the ramp up time is almost nothing. The IDE seems to pick up the full path of the code. The pattern is the same for everything that is done.
My open source code is hosted on GitHub and I'll use Travis for those. Our proprietary code is hosted on Bitbucket cloud, which comes with their own service called Pipelines, which is pretty great for a service that just went out of beta.
It turns out that I just had to do `sudo apt install php-[extension]`. 
I use a hybrid GET + POST (GET vars override POSTed vars) which is handy for explicit testing and exposing pagination mechanisms to users. I accept simple name =&gt; value pairs, unless there is some complexity (arrays or nested values) in which case it's name =&gt; &lt;json value as string&gt; pair. I always return a 200 json with an object of form { success:bool, error:string, message:string} and an optional trace:string value. This is cobbled from experience and other public APIs that I have enjoyed. Now you don't have to worry about where you put try/catches for async calls in your Javascript framework. You're welcome. Route everything to index.php and if it's 404, you get the login with some canned error messages for permissions, auth, business constraint, parameter mismatch, etc. I use NotORM which is just a readable SQL wrapper. The application code handles application state. The webserver handles webserver state. The DB is manipulated explicitly. This strategy ports to most frameworks. P.S. I also use Firebase php/jwt for token generation and validation
I'm actually not a big friend of chaining different setter methods. Why? Because it requires them to return themselves, which actually feels wrong, as in my opinion they shouldn't return anything (void). It's a bit different with a fluent interface, e.g. when writing tests or creating database queries as this is more like a connected operation where you link them together and it might make sense. But with just simple setters, it feels wrong to me somehow.
the old dependency hoarder approach drupal has. "what if i need it?"
&gt; I constantly see you proclaiming that your framework to be the most popular, but that's hardly a measure of quality. Justin Bieber has sold millions of records, doesn't mean his music isn't shit.
Casting is a code smell! Not always, there are situations, but encountered in the wild and middle of logic, it definitely is. [Feel free to inform yourself about the opinions of others on this topic](https://www.ecosia.org/search?q=casting+is+a+code+smell). &gt; Explicit type classes would change the definition of types from "is a" to "behaves like a". Those are both the same. I see it every day that people think that âis aâ is meant for code reuse, but it actually is âbehaves like aâ. Adding more magic, like you are saying, will not help here. Of course it will be a necessary evil to get a hold of our type system. The *fucking mess* is the result of an incoherent type system that tries to make everything compatible to everything; as I already said. However, it is not a pro or con argument for operator overloading. Many people created bad software with PHP, does this mean PHP is bad? It must be, since that is the logic you apply here. &gt; The point is expecting a `Number`, then making `int` and `MyInt` as numbers, instead of redefining the operation (overloading) with different available types. You are assuming that `MyInt` is a `Number`, but what if it is not? What if `MyInt` is compatible to `int`, but `int` is definitely not compatible to `MyInt`. A typical example here would be `float`, or a complex number. JavaScript has `Number` which tries to be everything, and it is a pain in the ass. What you really need is proper interface segregation, and many, many, many types to cover all use cases. But keep in mind, the core language will never be able to foresee all use cases, and implementing all of them is also way out of scope. Plus, we actually do not want that, we want a language that allows us to define our domain on our own. Here is another example for you that might illustrate the point more clearly: (I am using generics to avoid excessive coding for type safety.) interface Summable&lt;RHS = self, RET = self&gt; { static function add&lt;RHS, RET&gt;(self $lhs, RHS $rhs): RET; } class Duration implements /*...*/, Summable { /*...*/ public static function new(int $seconds = 0, int $nanoseconds = 0): self; /*...*/ public static function add(self $lhs, self $rhs): self {} /*...*/ } class DateTime implements /*...*/, Summable, Summable&lt;Duration&gt; { /*...*/ public static function now(): self; /*...*/ public static function add(self $lhs, self $rhs): self {} public static function add&lt;Duration&gt;(self $lhs, Duration $rhs): self {} /*...*/ } $date_time = DateTime::now(); $duration = Duration::new(3600); var_dump($date_time + $duration); It makes no sense for `Duration` that `DateTime` is addable, however, it makes a lot of sense for `DateTime` that `Duration` is addable. It makes even less sense that any of those two are instances of `Number`, even though the *behave similar*. A *one size fits all* `Number` interface would thus never be sufficient. Of course it makes sense to have an `Integer` type that corresponds to `int`, and is extensible for custom implementations that are truly the same as an `Integer`. &gt; [â¦] let's think about how the type system could change to allow type inclusion, rather than type juggling. It is a radical shift, but looking at where we got so far with operator overloading issues [â¦] This is pretty much exactly what I was talking about, the ability to extend existing types to support new types. Rather than relying on castingâwhich is extremely error prone and spreads logic everywhere that should be encapsulated. To answer your wish. We need to implement the same hack that Java has, create objects that correspond to the primitives. As a matter of fact, some attempts on this were already started, and we already have operator overloading for other things in userland. `iterable` is an attempt to bring a primitive closer together with userland types, and `ArrayAccess` is an interface that allows us to perform operator overloading.
fuck my life. seems like I am missing out on a lot even though I do not know what swagger is nor JWT. but here is another question for you though: did you use any framework that just does not require composer or other cmd "god knows what the fuck is going on" things. something with an installation like smarty, just download a couple of classes add them and boom you are good to go.
&gt; "What it adds up? It can take care of some things about security (you did some, but there's way more)" Security is a concern but all else is peanuts. you mentioned there is far more to gain in the security department. what are the main ones? it is probably faster to achieve those then migrate. If you know a modular framework that I could just plug in to somehow handle security issues, it would be the most useful solution. Thnx for your time. If you reply to me expect me to annoy you more lol.
yes, restful it is. models are not that tightly coupled. Some models have customization to fit certain needs. I have heard a lot of things about slim. currently I am away from the workplace and will not be back until the deadline is due. if slim or any other framework you used before does not require cmd commands I'd really really consider installing. Thank you for your response man.
I've used Slim for some APIs and it was OK. Nothing extraordinary, but it handled almost everything I needed. BTW why are you afraid of cmd tools? I actually use only composer with PHP projects. No need to use npm, bower or any NodeJS related stuff. Composer is basically single file (phar) you can download yourself and call it like "php composer.phar install some/package". That's it. 
Composer is harmless. I do maintain couple of servers and there weren't any problems to date. It's just for your convenience. You don't have to manually open Github, click download, unpack...blah. Composer does it for ya in seconds. 
Run ./configure.
Swagger defines how your rest api is used. With it clients can be generated for a variety of languages and they have a web gui that can be generated on the fly which lets you/others test and learn about your api. if you are implementing on your own it basically boils down to there is a spec that tells you how to provide a special json file that defines how your api is structured/used. 
Maybe you should keep a little more up to date. [Laravel News](https://laravel-news.com/), [Laravel Daily](http://laraveldaily.com/), [Taylors Twitter](https://twitter.com/taylorotwell) and here are a few [podcasts](http://www.laravelpodcast.com/) by the guys at Laravel 
Get an RSS Feed, [FeedDemon](http://www.feeddemon.com/) though a little outdated works a charm, you also have more modern methods such as [Feedly](https://feedly.com/i/welcome). Feeds do help keep things organised, though it seems to be dying out little by little.
OK sure I'll run the method that isn't real. 
Yup i we have one application which is exactly designed this way. I really like this way but the amount of development resources and skills you need is greater than what is required while developing simple server rendered html forms.
Just do composer diagnose First on your workstation. After that, do it in production. See? That wasn't scary at all! It just checks that everything is OK. Now run composer init on your workstation and follow the steps. If you don't understand something, (great! we've all been there) just look in the docs to get an answer. Or SO if you're lazy / it's not covered in the docs. Whoah dude! You just did your first project with Composer (the package manager of php). Seriously... If you do php, you should know ~~composer install &lt;package&gt;~~ composer require &lt;package&gt; ---------- If you do python, you should know how to pip install &lt;package&gt; ----------- If you do javascript, you should know how to npm install &lt;package&gt; -------- If you do Ruby, you should know how to bundle install &lt;package&gt; -------- ...etc... 
Sounds like we're peas in a pod.
This isn't exactly a busy subreddit, I'm happy to just see some content that isn't about Symfony.
Most frameworks tend to, at least, cover owasp top 10. But you should consider specific things on your model too. I cant give you a specific framework or lib since its not my speciality but i will be glad to help you find them. And its no trouble. Reach me whenever you want.
not using composer and its autoloader nowadays is just plain crazy :) ..check out API Platform..it is a selection of bundles for Symfony..I also use Lumen and Phalcon..Lumen and Symfony can be downloaded as zip :D I think
Gotta wonder how much Taylor is getting paid for that. 
Honestly, why do you care? If Taylor can make money to further the development of the framework and hire more full-time people to help then thats good. Also, this is his full time job/life, so do you not expect him to try to do well for himself?
&gt; Could fuck up the server then get yelled without mercy. Don't run it on the server -- don't do development on the server at all. 
I think it's absolutely awesome that you are taking the time to help programmers progress in their careers. With that said, this code is not in par with your vision of helping people. You should use PDO, not mysqli. Mysqli is ok ,but it's proceedure, and not a good approach to teaching people proper practices, in this case, Object Oriented Programming. PDO has many excellent security features built in, one of which is helping prevent SQL injections. Because you are not scrubbing your data and using raw queries to interact with your database, you are leaving yourself wide open to injections. Since you are going to be helping people, it's best to have them have the proper tools and software architecture. Their minds are a blank canvas, so it's best to make sure you are giving them the best habits right off the bat. Another issue you are facing is your code is it not written in an Object Oriented fashion. By using classes,objects and methods, you will introduce a modular design that will help you and your students practice that will help them in the real world. It's a great first try, but you can do better. Good luck!!
Craft, Statamic, and Typo3 have been suggested to me multiple times. Craft 3 seems like it will be a fantastic choice.
Thanks! I rewrote all the code in PDO today. Still need some some work but it's a WIP. Still trying to figure out how to separate concerns.
Does it say somewhere on his Patreon page how much he is earning a month? I can't find it...
Maybe you could learn something by seeing some micro framework like Slim or Zend Expressive. They're basically a glue for PSR-7 and PSR-11. CMIIW
Absolutely! I'm out all weekend camping but I'll be back Monday to work on it. Really, my issue is that...HTMl and PHP are all intertwined. I know including that "show table" part in the middle of an all HTML file must be ridiculous. I was thinking doing an "If is a POST request" do the the PHP code, else show the form. Just any sort of basic idea of a relatively good but not completely overengineered way to separate processing from output. Plus figuring out the right way to sanitize. Writing this from mobile, so sorry if it's rambly.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
+1, I'd like to see this feature. Generics too :)
It will be streamed :)
Given their steamroller attitude and apparent seo skills, the result seems inevitable. 
No, and for good reason. There would be too much focus on the dollar amount. You can estimate how much he gets from business partners though. 
Mate, it's really none of your business. 
Most people don't use most of the features of any given technology they utilize. This doesn't apply just for SQL, but for PHP as well. And HTML, and CSS, and JavaScript, and anything else your apps uses. Most PHP programmers have no idea what PHP can do for them, or the framework they use. They just download framework-of-the-day (or CMS-of-the-day), Google snippets on StackOverflow, paste and tweak until it works. Whether it's "worth it" depends on the app you're working on. How big its code is, how complex it is, how long it'll be maintained. How big it should scale. Most things in a SQL database can be utilized in one way or another. Say materialized views behave in a categorically different way than logical views, you can't emulate this in PHP.
&gt; Does it? Or does your application come from the container? Considering it's not clear what their "application" class responsibilities are this statement doesn't really mean much. Say in my apps, the "application" is the top-level class, that boostraps the application. It accepts a configuration, which is injected into a bigger internal configuration, which is also the factory/container for all remaining services, at that level. My point is, there's more than one way to do it, and without context you can't boldly say "this is the only right way".
Honestly, I'm having a hard time with things like stored procedures and triggers; as much as I see the advantages, I'm always afraid that it obscures the transparency of my applications. I know it's probably just a matter of having a well documented solution, but my habit is to have the logic (unnecessarily) inside my application code. 
Actually a regular read-only view is just a syntax sugar. Though once I've worked for a company, where views were extensively used, due to weakness of their ORM. So they created views for the every more or less complex SQL and then a Model in PHP to map that view. A materialized view, however, is an excellent choice for the denormalization. I wish mysql supported them...
Don't get me wrong I do not mean anything bad, but I was like you the last few months with most js frameworks and due to my requirements (mainly having something I could not install) I decided to give vue a try, and although I am still a noob at it, I am enjoying it a lot. And honestly I have found it pretty easy to just get my hands dirty, I don't really consult tutorials that much, I basically use the properties of vue to organize my logic and add the reactiveness I needed on my apps and am pretty pleased with it. The documentation is pretty legible and understandable for what I am doing so far.
Your code can fuck up the server just as well... I'd really try to get past the learning curve and try composer. 
I use mainly MySQL and in it, I use store procedures and functions a LOT, triggers every once in a while. Normally my process of developping starts by designing the database structure, tables indexes, procedures (store,updates,selects,selects with filters) and my php classes always query these procedures never the code directly. Views, I only use them for when I want to check stuff on the database itself.
&gt; What I'm getting out of this is that mysqli is not an acceptable method for 2017, and PDO is the right way to do it. Although not strictly true, PDO is certainly a more preferable option in terms of flexibility and security. Unfortunately a lot of people just "copy and paste" really shit mysql code from the internet and put the letter "i" on the end and think they are safe and better off, when really it makes no difference. There are other reasons but it would take a good few hours to write them here so its best you just read this: https://phpdelusions.net/pdo this will explain everything you need to know. &gt; ist MySQLi as "the preferred option" for new MySQL projects You've mis-read that, "Recommended by MySQL", no surprise MySQL 'recommends' you to use the driver that locks you into a single database vendor, which just happens to be theirs. Yet another reason to use PDO is there is no database system lock in. &gt; If the official docs can't be trusted, where do you go to learn? The official docs are fine, its just the way you interrupted them without thinking about the bigger picture and the sources of whats being said. Overall the fact your're just 'learning' and your clear lack of in depth background knowledge on the subject really suggests you are at a junior level? and shouldn't be writing tutorials for others to *learn* from. I mean this in the nicest possible way, the PHP community gets constant ridicule from poorly constructed tutorials because it seems beginners feel it their duty to write shallow articles with only the basic of understanding and a few years commercial experience.
One very very simple distinction that can be done here is that `App` is not necessarily what you will get from the container if it is configured for dev, prod, debug, etc. I found the "let the container build the app" approach to be generally more flexible, although indeed static analysis is harder (also generally not necessary at this level btw, since the app runner is brutally simple in most scenarios). And yeah, it's an application runner, also called "front controller", we know what OP wants: he/she described it.
When I need a database I use MariaDB and I know my way round. But I only do the basic things. All other stuff is done in PHP.
`CatchAllErrorsApp`, `MakeMeSomeCoffeeAtEveryExecutionApp`, `LogAllTheCreditCardsInPlaintextApp`, `RunWordpressWhenGivingUpApp`
I've heard good things about Bolt (https://bolt.cm), and it's built with Symfony. 
+1 for F3.
Simple orthogonal concern handling. Most of that is done via decoration, when done properly.
No, I think we should get more specific, not less specific, for me to get it. :P
A typical use-case scenario I have for applications is to have a "global exception handler" before/after execution workflow, maybe with a registered shutdown handler. `new LogAllTheMajorCrashesApp(new App($allTheDependencies))` is what you would get. The container is just there to build it.
I know the existence of a few of them, but had no real case where I needed them.. Triggers would be a solution I probally searched in past time, but yea.. I know that we use a many of the features at work and that they are very big and complex, but never looked closer to them. For my next privat project I will look for triggers and how mighty they are. A video "x things you probally didn't know or used while playing around with SQL" would be nice with with some examples etc. 
So it looks like you're using "App" in the [Rack](http://rack.github.io/) sense (middleware etc.), where they pretend the application is a "server rack" and you have "middleware and apps" running on it. It's very cute terminology, but it's a pretend game, and kind of confusing to use this in general sense. Because I would do this *inside* the Application code, I'd chain handlers. I wouldn't chain "apps". You don't do this in any other application environment ever. And in the general sense, if you have multiple handlers like that, running them in order and having each of them fail before the next one can run is quite inefficient. Say I had four distinct modules in my site: - Blog, handling URL /blog/* - Admin, handling URL /admin/* - Internal (say for internal company stuff, internal news bulletin etc.) URL /internal/* - Public site at URL /* unless it's one of the above. What would be more efficient? - Loading **all four modules** and their dependencies, only to have three of them fail before the public site runs (and the public site would be under most load, on top of that). --OR-- - Having the code below in my Application. . $firstSeg = explode('/', trim($request-&gt;getUri(), '/'))[0]; switch ($firstSeg) { case 'blog': $handler = new WordPressBlog(...); break; case 'admin': $handler = new AdminModule(...); break; case 'internal': $handler = new IntranetSite(...); break; default: $handler = new PublicSite(...); } $handler-&gt;handle($request); Now we no longer need containers to nest apps that decorate each other and so on. If you want to catch exceptions, you can also write an explicit `try...catch` there and pass it to a logger, instead of making this implicit and make people dig into the chain to figure out when each one is activated. I'm just saying... sometimes it's best to KISS. It's probably the strongest advantage of not using a framework.
I'd simplify "framework" as "guideline on how to do stuff automated, that you otherwise have to do by hand" If you want to drill a hole, you can drill it by hand, use electrical tools or build a factory-robot to do it for you. In all cases you'll end up with a hole, but depending on whether you want 1 hole once or a bazillion holes hundreds of times per second, one or the other might be preferable. The same goes for coding. All a framework can do can also be done by hand. The question is, whether you want to do it by hand. Frameworks can automate a lot of stuff for you, but things you only need to do once ever are a waste of time to be automated. So choose your tools based on what you want to achieve. Imho, a framework that is supposed to grow over time can only benefit from using a framework. With smaller projects you might save some time if you don't use them though. 
Been there, done that, leads to messy configuration switches when you need what OP needs (env switching) at every layer.
Thanks for the advice but I started using the Form component back in 2011 when it was first released. Continued to do so for a number of years. Got pretty good (in my opinion) at hacking things together but never became comfortable with the design and maintenance was always a problem. I am curious to see if the developer will make more major last minute changes for the upcoming 4.0 release.
It can often be useful to defer to SQL for other things just as far as working on your data as well. I was doing a project once (early programming, so I probably wasn't doing it the best way anyhow) and I spent a lot of time working with the data I'd pulled from my database and grouping it certain ways, doing a bunch of weird loops to sum up things by date. I forget the details but it was messy as could be. After dealing with a bunch of php's datetime issues, I realized I could do the same in much less work by just querying the data properly with SUM and using SQL date features. It killed half my code. To more directly answer your question, I learned relatively early about the benefits of foreign keys, views, and procedures, (though I didn't use procedures much until I jumped into .NET) so I made good use of them and it made me like SQL quite a bit.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Google snippets on StackOverflow, paste and tweak until it works Had a lol at this, so many times when sending out job adverts I get "self taught" devs or "been working freelance for x years" responses. When you sit them down to write some code they have only the very minimal understanding of whats technically going on and you ask them to explain why they chose to do something a certain way they simply fall to bits in the interview EDIT: I'm talking in relation that the *majority* of "self taught" have almost zero knowledge of even the very basics in computer science. Trying to problem solve without even a very basic understanding of what the computer is trying to do leaves most people hanging hoping "there's a package for that" on composer.
What a really poor article, it offers less information than the official documentation. You clearly show very little understanding of the language and how to use it, please don't post this spam crap here.
[removed]
I already rewrote it in PDO yesterday. Let's hope that my poorly constructed tutorial in which I use PDO and continue to ask PHP experts for constructive feedback on how to properly structure and secure the code is at least slightly better than the mysql_ turorial that's currently at the top of the results.