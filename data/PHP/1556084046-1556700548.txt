 DTO, DTO, Lay your grace on me! For I toiled all day, Writing Dollar Dollar names, And my code now reads like molasses.
ANyone who uses Notepad++ is not a professional. You should tell him I said that.
I dunno. I use neovim with mouse mode on and some plugins through dein. I have come to prefer it over any other editor
&gt; The short closures thing is a mess. Why is it a mess? It seems like your complaint isn't with short closure, it's with closure in normal lambdas (which I agree is a mess).
Dude, when i landed at my current job, all i wanted to do was quit the first 2 days I was there. 12,500 line class, average class size is 8,000 lines. There is a fucking 1,252 line constructor. Say what?! I thought the code was 15 years old, just an assumption, seeing how vast portions of it would be compatible with PHP3 (mysqli_ functions, no classes, etc.) but no, turns out it's almost all 3 years old. What's worse is that the devs get -mad- at me for saying how terrible it is. They are -proud- of it. Say I am demeaning years of their work. They didn't know what composer was until i came here. The code was literally infused with require_once's, even inside functions. it's crazy. I still haven't gotten a solid answer as to why NONE of hte 11 devs had ever even HEARD OF composer ... how does that happen? I'll tell you, systemic lack of any of them pursuing self-mastery of the coding craft. That's how.
People did, in fact, fork PHP several times in the past to remove that sort of stuff. In fact, i believe a fork resulted in magic_quotes being deprecrated w/ PHP 4.4. I know for a frickin fact that PHP 5.2 was forked cuz I was a major contributor to it. We added short array syntax ([] vs array()) and namespaces (that were like namespace:::fooo instead of Namespace\fooo) and a few more of the more awesome PRs available at the time. That got them inspired to release 5.3 with most of the awesomeness. HHVM came along and really really really kicked things into high gear w/ hack lang. Now that FB threw off the mantle, and now that Zend Corp is no more and Rogue Wave has been absorbed, it's probably well nigh time for a true Of The People PHP fork. Qualifications for language change voting power? Having led a team of PHP devs for at least 3 of the last 5 years, rolling.
Oh one of those 20 going on 2 types i deal with frequently! Got'cha!
You're such a loser it hurts. Stop calling yourself a PHP dev at once and go to another language! We don't want your type in our midst, giving us all an undeserved bad rap!
Yeah, the number of times his fingers must have hit the symbols key then searched for &lt; ? : = is very scary. Thank a higher power no one was injured or worse!
We still have 1600 require\_once's in our codebase, with some 1-2 million lines of code. They are a big no-no. We are constantly refactoring and removing 10 years old code. Some mandatory legacy will continue to exist, but all new code is of relatively high quality - at least that is the goal. Cannot imagine working with attitude like some your people seem to have.
No one but you, buddy. And you're so sure it works differently than it does.
no u!
thank a higher power if you dont breed.
Holy fuck, that gave me anxiety, ptsd and a headache all at the same time
aww, and you were cyberbullied in the past says your post history, so now you wanna bully me? youre a fucking loser.
Thanks, I’ll try it tomorrow and see what it comes up with
[removed]
I use my own. - Simple Typehinted DI - Modular configuration - Easy to integrate libraries - As slim or as fat as I need it https://hiraeth.dev/
I use my own. - Simple Typehinted DI - Modular configuration - Easy to integrate libraries - As slim or as fat as I need it https://hiraeth.dev/
&gt; CAN WE NOT HAVE $a = function() { } ALSO inherit the parent scope?! It... doesn't right now. So that would break a lot of code if it suddenly did. Instead I believe the plan is to have a block version of `fn() =&gt; { .... }`. Maybe later.
Buy more ram for every server you find out there with php. Simple solution!
No, nested ternaries are like if-elseif-else but shorter, which is in fact exactly what they are. A trivial example that works in any *reasonable* language: return (a &lt; b) ? -1 : (a &gt; b) ? 1 : 0; It reads left-to-right and the function is obvious.
&gt; In PHP 7.4 using nested ternaries without explicit parentheses will throw a deprecation warning. In PHP 8.0 it will become a compile-time error instead. &gt; We could make the ternary right-associative in a later release, after it has been an error for a while. Holy shit, PHP has been infused with a gigantic amount of common sense as of late. I remember being in Internals years ago, this simple concept of fixing the ternary in three steps (deprecate, disable, change) was laughed out multiple times every year "because B.C." Thank you Nikita. I'm also disappointed Zeev voted against.
Seems a nice list of some features, but the RFC about anonymous function I'm scaptic about that because is looks like a mess.
newbie in reddit. i will check how to do that. :) Sorry.
okay. now I know. my apologies.
okay. now I know. my apologies.
New operators have to be learnt, like all other operators, but once you know what they do, they do not hurt readability. Moreover, readability and “writing less code” are not opposed to each other. Abstractions are both when used carefully. &lt;=&gt; exists because people wrote “readable” sorting function code that was in fact neither actually readable nor correct.
&gt; Has anyone actually serialized an object in the last, oh, 3 or 4 years? I'm legitly serious, non-sarcastic. The few times I need serialization, I json_encode. It's never given me the grief unserialize() did all those years ago. The motivation for these changes was some bad breakage experienced by Symfony in 7.3, because stricter unserialization validation in 7.3 exposed existing corruption of serialized payloads. I'd love to just throw out that whole functionality, of course, but unfortunately I do need to deal with reality as it is, not as I would like it to be.
Having it just work on lists fits with the existing variadic expansion rules already in functions, having the same operator with different functionality depending on where it's used will just be confusing. Also, would it work like array_merge or array_replace?
&gt; Referencing parent:: in a class without a parent will generate a compile-time error instead of a run-time error. This point isn't true anymore, I reverted that after seeing more breakage than anticipated in the wild. (IIRC it broke mockery.)
This release will be amazing
Oh thanks for pointing that out, I missed that one! Too bad though, I like some more strictness.
&gt; 2. Has anyone actually serialized an object in the last, oh, 3 or 4 years? I'm legitly serious, non-sarcastic. Almost everyone, and you probably have too without knowing it. The [Doctrine Instantiator](https://github.com/doctrine/instantiator) is used in almost all bigger frameworks and many libraries as a dependency.
\&gt; This loop is slower than if we assigned count($myArray) to a variable and then execute the for loop. &amp;#x200B; I almost sure this is optimized? PHP can't be that dumb.
**making JavaScript run on servers** \- Already made **should make PHP run in browsers** \- According to \_odan, already possible
No idea why you got down voted. If someone disagrees with you fine. But you put a lot of work in this post with source and all. /r/php Can you follow the rules please?
I really dont think its the task of the language itself to prevent side effects. You will never ever reach that goal. This is better placed on the "framework/backend" level of the software itself.
Not Udemy. Try Laracasts.com, Jefferey Way is by far the best Laravel instructor out.
You have all my support but it would be hard as hell to connect whatever "Laminas" with ZF in the mass conscience. There is nothing impossible though. MariaDB takes over Mysql in many distributions and local installations.
really? but will be present in PHP 8 ? i don't see any need to support this kind of "features" :D
Please read the sidebar next time: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC
Can you give more context?
I need to automate tests such as submitting answers, logging in, using php
100% agreed. Lots of free started courses and for only a couple of $ you can view the others.
[Selenium](https://www.seleniumhq.org/) [webdriver.io](https://webdriver.io)
I need php not js
But you named ajax in the title
There is nothing stopping you from running these tests through JS (as in [webdriver.io](https://webdriver.io)). Selenium can be integrated with phpunit as necessary.
I named ajax because the web application I want to test uses ajax
I'll look into that, thanks
What you really want is to read this subreddit's rules.
it is not only that Laracasts' courses are the best. But also Udemy's courses are worst.
congrats you've earned yourself a cookie
Arrogant beggars are always amusing :)
If your code is fast enough and storage I/O also fast RAM is going to usually be your first bottleneck. There's no 100% rule in cases like this but with your method or perhaps both, slow disk I/O for example would still flaw both approaches. But in my case with extremely fast storage RAM limits come in the place first. To which you can add more ram if you can keep up with requests and eventually you will always hit some hardware bottleneck if you have the traffic. Whether it be ram, cpu, storage I/O, etc.
&gt;The performance gain comes of course with a cost: if the source of preloaded files are changed, the server has to be restarted. Is that different from opcache?
With the improvements int the type-system i think we would have better support for IDE...
maybe you are the one that should read this subreddit's rules &lt;3
You've lost me. If you've got extremely fast storage / connectivity that means *less* time waiting for sockets to fire, meaning your PHP threads are spending more time running. It's when you've got more latency between PHP and your data source that more threads become useful. Might I ask how much RAM you find each PHP thread using?
No youre a vampire. Youre leeching with shit content because you fail to google 5 seconds. And then even more shitty questions. "I want php". JUST GOOGLE IT
opcache can be configured to look at file timestamps to clear its cache, meaning you don't have to restart your php server on deployments. By default though, this option is disabled. https://php.net/manual/en/opcache.configuration.php#ini.opcache.revalidate-freq
Wow who's whimpering about rules
"meaning your PHP threads are spending more time running" ... that all depends on your traffic / user requests. Because that could also mean because of faster execution, they processes end up being more idle waiting on requests. Sounds like you are referring to an endless # of requests. Either way memory usage is going to vary depending on php application. So still just requires testing, rather than an absolute.
Thanks. Our CI does a restart on deploy at the moment. &amp;#x200B; Having said that, we're moving to Kubernetes within the next 6 months so I guess that's actually moot.
You can also do this with Psalm, and thus enforce it in your build process. Demo: [https://psalm.dev/r/1c056587ac](https://psalm.dev/r/1c056587ac) Use the `--find-dead-code` option when running Psalm.
I don't see why such a language would be conceptually impossible. Obviously I don't expect that from PHP. I don't expect too much from PHP at all.
&gt; having the same operator with different functionality depending on where it's used will just be confusing. The `+` operator does different things based on whether it's used with arrays or numbers. The same context-sensitive nature broadly applies for many other symbols used in any language. For example: `[`/`]` for array update, array append, array access, or array create depending on the context it is used in, or `(`/`)` for function declarations, function calls, creating objects with parameters, or determining operator precedence. &gt; Also, would it work like array_merge or array_replace? `array_merge`, otherwise it would work the opposite of its usage in function calls rather than complimentary.
well if you're testing the front-end it doesn't matter what language you use... anyway, what about behat?
If youre gonna google a bit you will find a beautiful tool complete in php. But i wont name it lol
If you are looking to start I would use Laravel/Lumen rather than Symfony unless you need it for a job or something.
What about it looks like a mess to you?
[Codeception's acceptance tests](https://codeception.com/docs/03-AcceptanceTests) could be what you're looking for.
Well, fuck. Honestly this is uncalled for, and the XML "clash" was always bullshit you can escape for (not to mention XHTML has since been dropped and so you rarely if ever will see an XML declaration in a PHP template).
Mine? [https://web-techno.net/](https://web-techno.net/) It's not so much PHP based (a lot of other stuff in there, especially soft skills) but all examples I use are in PHP. Hope it could be useful for somebody.
No worries, just thought it'd make more sense for this kind of post.
Thanks, this will coming really handy with a legacy app I need to upgrade.
Really? You’re still using short tags years after you’ve been warned about their use? I don’t have much sympathy to be honest. &gt;&gt;&gt; Every script which currently uses the discouraged short &lt;? open tag will need to convert to the standard &lt;?php open tag. This can be automatically achieved by using the “full_opening_tag” fixer from PHP-CS-Fixer.
Honest question: do you still use the short open tag, even though this is discouraged by PHP for a very long time?
On the one hand - yes, there is no solid technical reason. On the other other hand, however, it is in line with other tags deprecation. To be honest, I haven't seen short tags used for ages. Do you really find them useful?
Can anyone explain to me why they chose `public int $var` for the property type hinting format, instead of `public $var : int` like it is in every other situation in PHP?
It's been discouraged, and I did expect this at some point, but this doesn't mean I believe it's justified. The XML reason is bullshit.
I'm not opening this discussion because I think I'm personally inconvenienced by having to convert tags. I just think removing the feature is poorly justified.
For people who don't use a "template engine" it is cleaner to have: &lt;? foreach (... as ...): ?&gt; ... &lt;? if (...): ?&gt; ... &lt;? endif ?&gt; &lt;? endforeach ?&gt; Instead of: &lt;?php foreach (... as ...): ?&gt; ... &lt;?php if (...): ?&gt; ... &lt;?php endif ?&gt; &lt;?php endforeach ?&gt;
I could have *sworn* this was *removed* in PHP 7.0... I haven't typed `&lt;?` in over 12 years. What the *fuck* is going on in YOUR dev shop?
And your opinion is *so* proprietary that you aren't even letting us look at it!
I can easily find people saying the exact same thing about `&lt;?=` before they were made a standard feature. So the real question is what is with you demanding that I don't use short tags. "What the fuck is wrong with you" is not a technical argument. It's an emotional argument.
That's exactly what I'm into right now, thanks for the reply
... what?
Yeah, consistency is the key which is missed a lot in php. I love php and the only server side language I know but sometimes it confuses me.
Those open/close tags clash with [Classic ASP](https://en.wikipedia.org/wiki/Active_Server_Pages) who got there first.
... How does that make sense. Who uses ASP in PHP or vice-versa?
Short tags? Wut?
Is funny how all of you are coming to talk shit because i didnt post in /r/phphelp tho none of you are there to actually help people. I think you are the toxic fucks, dickheads
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
No because you're expecting a whole community to answer a 5 second google question. The questions here are indeed answered a lot of times. (If its not "Which framework...")
As the default also changes in 7.4, if you didn't have that setting on your php.ini, were relying on the default and were using short open tags, you are now sharing your source code with the world! Congrats!
Please dont talk just because. Im looking into this shit a couple of days so dont tell me that its a 5 second google search. I'm asking what is the best way based on people experiences and who know better than me. Maybe you could google how to stop being an ass, is not that difficult to reply politely, as other people did.
Is this the right time to fix this problem? A file with only `&lt;?php` will crash the whole software. Is the space really needed? `&lt;?php`
&gt; Now, by magic, nobody minds the short echo tag. Because it's replacing `&lt;?php echo`, which is more than twice as long as `&lt;?php` and more commonly used in mixed documents containing HTML.
As I demonstrated elsewhere in the thread, `&lt;?php` is also very commonly used in templates, because that's all your loops and branches (doubled, because... opening and closing statement).
First: Im not gonna be polite to someone who isnt even polite to the people who wanted to help you in the first place. Wow. Days? wow Then im gonna help you out. You need a ton of help... tl;tr incomming Here it is: http://lmgtfy.com/?q=selenium+php but therefor you had to know about selenium. You will never find that on google. But even after someone pointed it out you looked really helpless. So this is even better: Its part of your title here. http://lmgtfy.com/?q=automate+web+app+testing+php (actually this is the better query.. You find a ton of experienced people who already wrote articles about it.) so dont talk bs here to justify your idleness.
Hey, secretvrdev, just a quick heads-up: **therefor** is actually spelled **therefore**. You can remember it by **ends with -fore**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
And here we go: &amp;#x200B; therefor &amp;#x200B; and to get this thing started: &amp;#x200B; realy &amp;#x200B; have a nice bot war
Gonna try it...
Fork it and get the free maintainer role!
It was very close for 7.4, just 2% over the required margin.
Well again, on the one hand - yes, but on the other hand, someone who cares, would probably use a template engine. A template with auto-escaping is the same for XSS as prepared statements for SQL injection. I understand your frustration, but I think it's a good move in general.
First of all how I'm being impolite in the first place. I know about Selenium, but I don't want to use Selenium. Yes, I already know methods on how to this, as I said, I'm interested in points of view from people who know better than me. Just say whatever you want, but you are being a fucking jerk for no reason. You could have just said "I know goutte" or something like that, I would have thanked you and that's it, but hey, no, big boy has to do his part of Internet police
lol only more bs
The required margin being a 2/3 majority
&gt;A file with only &gt; &gt;&lt;?php &gt; &gt; will crash the whole software. It does? # cat -A openwithspace.php &lt;?php $ # cat -A opennospace.php &lt;?php$ # php --version PHP 7.1.24 (cli) (built: Nov 11 2018 08:03:49) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.1.24, Copyright (c) 1999-2018, by Zend Technologies # php openwithspace.php # echo $? 0 # php opennospace.php # echo $? 0
Also don't forget to consider if you need JWT at all, such as [don't use JWT for sessions](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) and the follow up of [Why your solution for JWT for sessions won't work](http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/).
That's a separate conversation. There's a way to autoescape plain echo tags, and there are also severe limitations on most existing template engines that cripple flexible component reuse. And "rolling your own" is easy (relatively speaking) as a compiler, but IDE integration isn't. So, again, separate, and big, conversation. But "hey if you care you can use a template engine" is not a valid argument for making what's already in PHP worse. We should be integrating more basic necessities into PHP, instead of taking them away and turning everything into a thousand file framework as an alternative.
I think its complicated. Idont know why this happend. Could be a configuration or the method of invoking the php process? Try it here: [http://sandbox.onlinephpfunctions.com/](http://sandbox.onlinephpfunctions.com/) &amp;#x200B; I got the same results with a nginx server and different php versions running beside in a container.
Here are some very old comments about that: [https://www.php.net/manual/de/language.basic-syntax.phptags.php#118827](https://www.php.net/manual/de/language.basic-syntax.phptags.php#118827)
Well, as Nikita wrote in Twitter, it was a controversial vote, so you're not alone in your grief. But it was voted and there is no way back. At least there will be like 3 years for the transition, if any.
Every other situation? You mean return type? Because that's not how we do in in functions.
I am so beyond excited about typed properties and covariant return types. We’ll rarely need docblocks anymore!
That's some sweet new functionalities. Love the SPA oriented ones.
I won't miss the short tags *that much*, but I think removing them is a perfect opportunity to introduce some basic new, modern if you will, template features in PHP to fill the void, unfortunately it's not happening. We just keep offloading everything to the heavy, bloated, fragmented world of PHP frameworks.
This is just a way to experiment with short closures and you SHOULD NOT write code like this. It's still a branch so check "RFCs / upcoming releases" tab, in "Output for Arrow functions". &amp;#x200B; TLDR: 1. You can use multiple lines with a function and commas 2. You can bind by reference using a wrapper object, a wrapper function or just regular good old functions
Super old syntax. I don't think anyone really uses them any more. The **only** place I see them is old code. It's a super easy fix to switch to the new style anyway.
The comments here don't indicate anything about crashing anything. I haven't seen any evidence this is the case yet.
This is great news :). We use codeception on our team
I’d rather have support for structs.
OK next change is to stop requiring &lt;?php at the top of a page and assuming it's PHP by default rather than HTML... (I'm not sure whether I'm joking or not)
That's insane. I love it. Thanks for putting this together! Really interesting to see the edges.
And native annotations!
Doesn't that cost a stat() call per file? That'd be.. unwise.
Just take a look at the release notes + upgrade guide and make that determination for yourself. New releases with breaking changes are every 6 months.
Agree with you.
Keep in mind there are LTS versions for both, not necessary to upgrade as soon as a release is out
This would break compatibility with older files. They could have a phx file (x for execute) that doesn't allow open or close tags. I'd be very interested in that
On the one hand, that would break like 99% of every PHP site ever. On the other hand, that'd be a nice way of forcing intelligent architecture. It definitely won't happen. Oh well.
I had the widest smile reading your examples. Well done ;-)
&gt;my very complex apps run in less than 20ms per request, under swoole, and on $40/month server. Sure, it is not as fast as Java would be but I can make that site in much less code than in Spring. Less code, less potential bugs. Could you please refer that complex app example please - which category that apps belongs to? E-Commerce, Telecom, Healthcare domain?? &amp;#x200B; Whats annoying about Symfony is - Its forcing you to use all the things which people were using in Java environment. PHP was built for simplicity and and getting things done in very convenient way. But this beauty of PHP are being killed by framework like Symfony and putting Symfony parallel to Java. &amp;#x200B; So, If we 'll spend the resources like Java then why not we should expect the Java 's Performance??
I'm not sure how much I would trust this, especially on older magical code.
yeah, that was the simplest way I could think of it working without making the parser having to guess what type of file it was. Which may or may not be simple - we'd have to ask someone in internals!
they would just need to add ?&gt; to the top of all the files that start with HTML.
Thanks for detailed answer. But all these @annotation and #DI is also available in Spring &amp; Spring Boot. My concern is - development cost in Symfony is becoming similar to that of Spring. Then why should we go with Symfony. For business resources is very critical matter.
@annotation is also available in Spring :-)
I figured you meant it would simply be parsed as PHP, period, and not allow HTML. Which would be great. But again, that definitely won't happen.
Then use a templating engine like smarty, twig and blade. PHP is an ugly templating engine and should not be used as one in modern web development.
to be honest, that would be the most sensible solution - there are no times nowadays where your URLs are direct links to PHP scripts that are HTML templates with bits of code in. If you've got PHP templates then you'd still be including them via another script.
serialize and json_encode have different use cases since serialize will keep the object type and structure.
Here... i googled for evidence. [https://stackoverflow.com/questions/22958155/an-empty-php-file-php-when-included-doesnt-get-parsed-and-is-added-to-o](https://stackoverflow.com/questions/22958155/an-empty-php-file-php-when-included-doesnt-get-parsed-and-is-added-to-o)
You're bringing forward arguments of fashion, i.e. what's "modern", yet recommending Smarty. I feel so confused. Anyway, when PHP's templating is bad, one way to think about it is: let's make it better. Why should we think: let's make it worse, so more people use Smarty, Twig and Blade. I mean, what the hell...
Didnt know that page existed. Thanks.
In comparison, Symfony only breaks stuff on major versions, which are released every 2 years.
That is great news, we have a lot of code built with zend here at work
Also, real enums
The LTS versions for Laravel are basically useless. They aren't very well maintained, ultimately. https://medium.com/@jasonmccreary/laravel-lts-is-a-trap-97b1d1103961
True. Laravel made the decision to go with a faster release cycle to have a fresher ecosystem.
Well functions typed parameters are set like 'function(int $i, string $s = ''): void' so it make sense to keep parameters syntax for properties to me. And 'private $i : int = 0;' seems weird to me.
Please note, this does not affect &lt;?= tags in your view files.
I've seen them recently... I will say, however, that the only place I've seen them in the past decade is in bad code.
Faster releases lead to a fresher ecosystem. Breaking changes in every release leads to a more fragmented, chaotic ecosystem. So let's be honest and look at both sides of the coin here. Honestly, changing your opinion about an API every 6 months just screams "unprofessional" to me. There are so many ways to add to an API without breaking changes so often.
I think you’re being a bit too hopeful about the state of PHP application support. There is a lot of legacy bespoke nonsense out there which will be supported forever. Not to say that any of them will be upgrading to 7.4
Laravel's six monthly releases _are_ major releases.
You probably now this, but not everyone else does: There are reasons to use docblocks that go beyond type hinting. Most people just don't bother documenting. If the only reason you docblock is typehints, yes please remove that shit as native typehints land. If you want to improve your project documentation (not even API docs!), docblocks can help you immensely.
Why deprecate the short open tag?
I would agree with you if Laravel changed any single API that often, but generally we're talking about breaking changes to any single API every few years at most. For example, the major breaking change in Laravel 5.8 was switching the cache timing parameter from minutes to seconds, something that's been requested for years, but avoided until now because of how significant a break it is. I manage a number of large "enterprise" Laravel applications and while I have been a critic of Laravel's release process, the frequency of major releases with breaking changes has never been a significant problem. The longest upgrade process we've encountered was several years ago, upgrading an application with a complex data model (over 200 tables, many interlinked) with a lot of customisation to core framework features. It still only took two people two days, including writing additional tests. Our average for a major upgrade is usually half a day for a single developer.
Just in case your question is about preloading vs opcache. Opcache caches once a file is run. preloading caches a defined set of files without needing to run them. Many frameworks offer "warmup" scripts that "run" your framework files to preload your cache. This is a better mechanism for that I imagine. I don't know the implementation, but it may just be that, preloading configuration for opcache.
Yep. The only hope is to pull a python and maintain two branches. But that's not happening either, so we'll have to live with outdated SAPI's and syntax forever. Oh well.
You may be confusing type hints in other languages like TypeScript that uses `var : type = value`. In PHP you use `type $var = value` in for example function or method parameter typehints. The `func myFunc() : type` in php is only for the return value typehint. So this syntax for properties makes sense in PHP, they are more like parameters than functions/methods.
I'm not disputing that, just saying symfony's release cycle is 4x more conservative.
The main reason is to remove a language feature that can be disabled through an `ini` directive. Migrating code that uses short tags to a server with them disabled is liable to cause the code to leak, presenting a security issue.
Why not just enable them by default then? Or even better, just make that part of PHP and not something one can even turn off?
Your comment is great example of how toxic and deconstructive php community is nowadays
Rector has also ["dead code" feature](https://www.tomasvotruba.cz/blog/2019/03/18/how-to-detect-dead-php-code-in-code-review-in-7-snippets/) + you can extend it with own rules as well because it's PHP.
Personally I would agree with this approach, or just not changing anything. I think it's quite short sighted to cause such a huge BC break on legacy projects without any significant gain (especially as the result of this would be a definite code leak if it's blindly updated).
That's my take on it too. It's not a huge deal to do a find and replace to update short opens to long opens, it just means a bit more typing for what I can tell is "zero" actual improvement. Cheers.
If you run this app through the appstore you're always in the position to leak the sensitive data with an automated update. The users have to thrust you. The real "secure" projects today have always big big big big long concepts of how they aren't able to sniff your data. But it depends on what you are doing.
Also look on kims "illegal" file sharing hoster [mega.co.nz](https://mega.co.nz) . Technically he's doing very well of not letting the server know whats happening in the database.
It's funny - one of the reasons listed for the RFC was that code could leak if used on a system with short open tags disabled. In order to fix that, they've actually made it so that code with short open tags is guaranteed to leak.
Hotscripts comes to mind
Would make a good "close enough" meme. I think, it's the right decision to move language behaviour out of the php.ini; I hope, they deprecate more ini settings. But yes, maybe they should have allowed '&lt;? '
As the developer of ciphersweet-js, I can simultaneously promise it solves the use-case you have in mind, but also caution that it's not production-ready today. (It will be soon though!) When v0.3.0 is tagged tonight or tomorrow, you should be able to do this: // Set up: const {CipherSweet, BlindIndex, StringProvider, ModernCrypto, EncryptedMultiRows} = require('ciphersweet-js'); let keyProvider = new StringProvider('ea3c8406e51fd8117ddbe1a665633c3437d84588904544d41d1d8d0be27c23eb'); // replace me let engine = new CipherSweet(keyProvider, new ModernCrypto()); let dataHandler = new EncryptedMultiRows(engine) .addTable('users') .addIntegerField('users', 'object_id') .addBlindIndex('users', 'object_id', new BlindIndex('users_object_id_idx', [], 16, true) .addTextField('users', 'name') .addTable('objects') .addIntegerField('objects', 'user_id') .addBlindIndex('users', 'object_id', new BlindIndex('objects_user_id_idx', [], 16, true) .addTextField('objects', 'name'); let encrypted = dataHandler.encryptManyRows({ "users": { "user_id": 123, "object_id": 456 }, "objects": { "object_id": 456, "user_id": 123 } }); You can get a congruent result today from the PHP version of CipherSweet.
Wordpress plugins?
I think there are always going to be things that require an ini file for configuration. An argument could be made that more things should be configurable outside of the ini file - but for security reasons there will always be things that need to user configurable and that you want to make sure can only be modified by administrators. That being said, even if I thought moving to a system where we didn't need an ini file made sense, there are still a LOT of things in the ini file besides this. If this was the last thing remaining to get us to that point, then maybe there would be an argument that the positive of removing that last wall outweighed the negatives.
Well that's gonna ruffle some feathers. Imagine how any companies are going to have to pay for developers to go sifting through old code. All for the sake of progress though, I guess.
Oh yeah... i missed the most important part. If the app requires user thrust then you have to make it completely open source there will be no way around.
This big chunk actually makes it easier to update. In my job there is absolutely no time to update all the thing every 6 months to get to the fresh ecosystem. 2 years is not enough but you want to go with it. If you running a large number on application wich dont share the code base then good luck to get your 100 people upgrading team. this isnt even a cool job to constantly update all the code base.
[Firefox Send](https://send.firefox.com/) is a file-sharing platform that is open source. I encrypts and decrypts on the client so the server never sees unencrypted data. If you'd like to see their implementation, their [code is public](https://github.com/mozilla/send). It's written in Node.js.
https://wiki.php.net/rfc/typed_properties_v2#syntax
Couple of questions: If the objects are de- and encrypted locally, why is a relationship between a user and a given object on the server a secret? The server would know which objects belong to whom, but wouldn't know what those objects' content is. ("Sarah saves 4 entries" isn't really problematic, is it?) Not knowing what your app will actually do, I wonder if you will ever need search or share functionality. Because this will make things way more complicated. If you only want to solve for a user being able to save data on a server (e.g. to use multiple devices), have you considered simply encrypting a complete local DB (like indexedDB) and storing it encrypted as a file on the server? But here is the solution I would recommend: Create a keychain for a user that is RSA encrypted and which stores AES keys for every object and store objects with these AES encryptions on the server. This will enable secure sharing of objects: User A wants to share an object with user B. User B shares his public key with user A. User A encrypts the AES key &amp; object-id with user B's public key. User B decrypts the AES key and the object-id and adds it to his keychain. Now both have access to the object and at no point did the server ever handle any key that can be used for decryption. Searching: Searchable encryption is still in its infancy. But what you can do is creating indexes on the server that help to at least pre-filter results. So let's say you are storing credit card numbers. Along with the complete entry, you also store an encrypted version of part of the entry. So let's say the first three digits. When searching, your app now takes the first three digits and encrypts them with all known AES keys of your chain for the particular entity you are searching for and sends them over to the server. There a query can return all potential results. Deeper filtering then happens on the locally decrypted objects.
My first job had VB scripts run manually that sent out emails to clients and versions like 01, 02, 03 appended to the end of the file name.
I thoroughly disagree. What other language has a global configuration file that changes the behavior of the language?
&gt; Foreign function interface I was curious about this, anywhere where I can get more information?
Not everything in the ini file changes how the LANGUAGE behaves. It controls how the system that executes the language runs. include_path, for example, doesn't make the language perform differently. You don't have to write a function differently based on it's value. There are some things that it could be argued actually change the behavior of the language. I'd said the variables_order parameter might fall into that category. Those I can see an argument for removing. To do so, though, would mean removing flexibility that currently exists. I think such changes, like removing the short tags, should have a large positive impact in order to justify them, since removing flexibility could have negative consequences. In the end, PHP is a language and it's an application used to run applications written in the language. Configuration will always be needed on some level for the PHP application.
&gt;But all these @annotation and #DI is also available in Spring &amp; Spring Boot. Exactly, that is one of the reasons Symfony is good. It took all the best tools from Spring and injected steroids in them. And then added some more. This few annotations I mentioned are completely irrelevant, it is the architecture that is important. &gt;My concern is - development cost in Symfony is becoming similar to that of Spring. Then why should we go with Symfony. For business resources is very critical matter. This is wrong. Even if the hourly price is the same, Symfony developer will **always** make application faster because of available tools. And because code will be smaller, it will be easy to add new features. My first post mentioned only very tiny fraction of these tools. Forget annotations, it is nothing new but look at forms, service decoration, autowiring, things you can do with conditional routing like this... ```php /** * @Route("/create", condition="not request.isXmlHttpRequest()") */ public function create(...some params...){} /** * @Route("/create", condition="request.isXmlHttpRequest()") */ public function refreshForm(...some params...){} ``` First one is triggered on regular URL /create, second when same URL is called via AJAX. Very useful for dynamic forms. You should also check for embedded controllers; it allows you to split pages into smaller reusable blocks, and you can even cache them individually. Docs says there is performance impact; it is true in dev mode, production doesn't care (or at least, not in measurable terms).
You should write framework agnostic code instead. It's your fault if a new release breaks your code.
and 4 year LTS versions, too.
Laravel also releases an LTS every two years which is maintained for two years.. The upgrades in the middle , while being “major upgrades”, are 100% optional. Not upgrading will have no negative impact.
&gt;PHP was built for simplicity and and getting things done in very convenient way Again wrong. The convenience of PHP of not using typehints, classes, strategy patterns... made all the shitty code we can see now. Symfony can't completely prevent people writing code like we can see in Wordpress, Opencart etc... but it still does a good job. And don't forget that you get waaaaay more utilities in Symfony that in Spring. You can't use 1 argument and ignore all others. &gt;Could you please refer that complex app example please - which category that apps belongs to? E-Commerce, Telecom, Healthcare domain?? There is no category, every single one was individual. For example, one of them is to connect to many different APIs (GPS truck services) and map into my own format. User would use that site but doesn't care which API is being used; with proper abstraction, new API is few DTO classes away + configuration file. The trick is that each API is different and some use REST, most use (ugh!) SOAP. And for some data I need, sometimes you need multiple calls. And that goes both ways. That is the heart of what app is doing, there are other things but not really relevant. The architecture is important; just a few classes implementing some interfaces and boom, you are done. And phpstan is set to max level, preventing me from making mistakes of using PHP "convenience" :) Other thing I built are far more complex and impossible to describe here, sorry. Right now, I am building a site that is all about forms; this would would never be possible to make without Symfony. I am talking about 100+ forms, some of them are multi-paged, each depending on values of previous pages, 100% server-side validation, dynamic field and dynamic values everywhere (all from real entities, no array crap)...
You mean the guy that sells the service to automate upgrading thinks you should upgrade frequently? *surprised pikachu*
While Symfony LTSs are maintained for 4 years. I don't get your point…
So where are you getting the 4? Two year release cycles vs four year release cycles...
Your comment didn't accurately reflect the tone of the article.
From the documentation: https://symfony.com/roadmap Minor = 6 months Major = 2 years LTS = 4 years more details at https://symfony.com/doc/current/contributing/community/releases.html#maintenance anything else?
Yes?
I was asking where you got the 4x difference, which I do see now. I thought you were comparing the LTS and not the optional upgrades.
No point using a framework then if your not gonna use it 😂
Unless it’s changed, but Laravel sync their release cycle with Symfony - so arguably they should be as breaking as each other? That being said - I’ve yet to come across an update (apart from the dotenv fiasco) that caused any problems. So technically maybe they will have more breaking. But realistically might never actually happen! Depends what sort of code your writing
What you want to do is create an intermediary token (such as a private ssh key) and then use that token to encrypt the data. You can then encrypt that token with the passphrase only - so if you need to invalidate and reencrypt you don’t need to change the pass phrase
Here's the [RFC](https://wiki.php.net/rfc/ffi).
And frankly, Laravel's willingness to improve its API leads to a more intuitive framework in the long run. Just compare how to do simple things in Symfony vs Laravel and you can see how obviously simpler it is to do those things in Laravel vs Symfony's kludgy APIs. The *reality* is that if your organization is sensitive to breaking changes, then it shouldn't be upgrading if it doesn't have an immediate need to.
Just wondering, how do you define "framework agnostic code"? Because the only definition I can think of is writing your own modules, which basically means your own framework.
The entire time, I was misreading this as "short tags" e.g., `&lt;?` nonsense from earlier today and I was very confused.
I'm not saying you should upgrade frequently, just that you shouldn't assume that because you're using the LTS that you're immune to security vulns and BC breaks at the same time. Laravel LTS is not Ubuntu LTS for example.
If this sort of thing is influencing your decision you could just about stop with the fact Laravel isn't even semver. In my experience Symfony has done a great job of managing major releases and BC, to the point there's not much breakage between even major releases (they deprecate way before hand and then a major usually just removes deprecations). On the other hand I've had to jump through hoops for every Laravel upgrade. YMMV though, it does depend on the code base as well.
You OBVIOUSLY aren't working where I'm working. These guys are still requiring_once like it's still 1999! I've seen spaghetti code so terrible that it caused me to vomit. 15,000 line class + procedural + global variables + a whole lot of inline HTML, CSS and JS just sort of made me lose my shit right there in the office.
Because most of us here have moved on from coding like it's still 1999, to say it figuratively.
GIVE US THE CODES! OR GTFO OR AT LEAST STFU!
You're arguing past each other. /u/elcapitaine never said the `ini` file should be removed or shouldn't allow for configuration, just that any configuration options that alter the behaviour of the language should be removed. You agree with each other.
I imagine this is something that depends a lot on how our respectives companies are structured and the kinds of projects we work on, but in my experience the opposite is true. Scheduling a short amount of time on a more frequent schedule to apply relatively minor updates with a small number of breaks involves less work overall then scheduling a longer amount of time less frequently. The amount of work required doesn't go up linearly as an upgrade gets larger. A larger upgrade involves more possible interactions between components that need to be accounted for and tested, longer changelogs need to be read and more changes understood by a developer at once. Each major Laravel upgrade tends to have a few BC breaks, but usually only a subset of these actually effect any individual application and the upgrade notes are always clear about where these breaks may apply. For the same reason, we remove any functionality deprecated by a minor Symfony release as soon as possible after it's deprecated, rather than waiting for it to be removed in a major upgrade, because it takes so much less developer time to make these changes in small batches with less side effects, than trying to make all the required changes at once.
A ten seconds fix in 10900 places. Short open tags are still useful and used. Deprecation doesn't matter. Look at HTML5, they went back to muddle style and the world is still turning.
I think someone who care is capable to escape manually, even if he is not working for goldman-sachs.
Well put, Mike Tyson.
We have to go pretty far out in the Java world to find something as bad, matter of fact I'm working with both Magento2 and Java... let me tell you the Magento2 is far worse.
Because it's the sane, less verbose syntax.
Essentially by creating well defined integration points in your application and domain code. In practice, that would usually involve defining an interface which is implemented in an "adapter" layer and which integrates a framework or library component. A simple example would be a repository interface in a domain model which has a Doctrine ORM implementation. If course this does not avoid issues with BC breaks in the framework like OP suggests, but it does mean they are easier to deal with vs integrating more directly and in many places throughout your application and domain code base. It also makes swapping out framework and library components entirely much simpler.
I also thought this at first, but this is not "framework agnostic" - this is just another layer of abstraction that makes the code less dependent on the framework. Since his last part of the sentence was " It's your fault if a new release breaks your code", his definition has to not rely on the framework altogether.
It WAS faster. 10 years ago, when MyIsam was the default and InnoDB was an experimental engine... and all the default settings were tuned for MyIsam. But things have changed. Slap on Percona Edition and configure it right and it’ll whoop the pants of MyIsam any day. Now add on top of it that InnoDB is ACID and has foreign key relationships. And that’s not even mentioning the extreme usefulness of transactions for multi-table insertion.
It's a bit more than that. It finalises the state of classes it encounters, saving a meaningful bit of overhead which is experienced even with opcache on.
I miss the script tag: &lt;script language=“php”&gt; /s
Top 10 lists are bad enough in blog post format, do we really need them in video as well?
Don’t forget Union types.
It’s on a timer, so it only stays every n seconds past the last check
&gt; You should write framework agnostic code instead. It's your fault if a new release breaks your code. Found the [cowboy coder](http://wiki.c2.com/?CowboyCoder).
No, we don’t.
I realise I saw a very early version of it (with great interest, I might add!), so I wasn't expecting super docs. Thank you for explaining more of it here.
This sounds like a good idea! Thanks.
I don't want to share objects or keys between users. If that comes up, I'm fine with decrypting on device and then handing the data over to a separate, secure sharing protocol. I don't need or want the data to be searchable. It's time-based data. Daily, habitual data capture (for the purposes of this app), to build graphs on the device.
Could you describe the scenario(s) where the sensitive dat could be leaked? Also, I'm not trying to remove the requirement for trust between the user and app, I'm trying to minimise damage in the event of a breach and learn a new kind of data storage technique.
Would've been nice if they just went a head and waited till 8 on this. Will this only throw a deprecation notice or will this fatal?
It’s literally running a single command once for your project. I don’t understand your 10,900 count unless you have that many projects to manage?
What exactly was toxic about my comment? I didn’t use any harsh language, I simply calmly expressed my opinion.
Seeing as the fix is to run the codestyle fixer tool once on your project, this doesn’t seem unreasonable to me. It’s about time they removed this feature, it’s been turned off for a very long time now and people have had ages to remove them from their code.
There are other changes that will be harder. The removal of old style constructors will break lots of code. Okay, that one should also be fixable with tools. But then there is also that TypeError rfc. I bet there are tons of applications, ignoring warnings.
I don't mind having an ini file. But imo there are enough settings that shouldn't be there. E.g. auto_globals_jit - is there any reason for this to be there? Remove this one and enable_post_data_reading. Then add a function like auto_globals_state() and hold the data in php://input until $_POST was requested the first time
Well, I see this as: original comment was about poor motivation for this exact change. Your comment leaves impression that you call /u/LogicUpgrade inattentive ("you’ve been warned") and lazy ("10 second fix"). So you just changed the topic from motivation to the author.
This is just a complete mess at this point. Presumably the Zend company will remain in the hands of Rogue Wave. Then the foundation just essentially takes over development of a pretty much dead framework, or at least will be dead - nobody is going to start a project on it when its past, present and future has been so unstable.
Thats best! I can keep my shitty php template files!
Uhm most of the php people today did work really much in the field before. Probably years more than you.
Hi, I just made the package for this, based on Taskman, find it here: https://github.com/php-taskman/travis
Exactly. It will take me some time to get used to seeing `&lt;?php` in my templates intermixed with `&lt;?=`. Ugly, but hey, at least they are not forcing us to use `&lt;?php echo` ...yet.
cute team you got there but to do infrastructure work like php you have to be better. Also feel free to apply to the php core team. Then you got a vote! Their are quiet open in the discussions.
You will be able to use only php to extend the php language itself.
Codeception is a pile of shitty code upon some great PHP libraries like PHPUnit, Facebook WebDriver or behat. The tests in our company are based on it, and it slowly makes my life miserable. It's alright for little projects, but if you don't share their vision of how tests should be written or want to make some complex stuff than everything in it comes in your way. Their DI framework is horrible. Their documentation is lacking. Their approach of piling all methods in one auto-generated Actor class (losing output type annotations in the process) is a crime against common sense. And everything is hidden from the outside - you can only get your hand on some inner stuff from inside Cest, Actor or Module classes.
Reason #0, if you're in a consulting business, and are not a consultant... you are what? The tea lady?
One of major problems in PHP world, is lacking libraries for testing, profiling .. etc You see all the effort in making frameworks after framework. We don't need JIT. We really need to learn from communities such as python.
Whats the definition of a consulting business. There are some who have dev teams in the back. You can do whatever you want to call you "consultant".
TIL some people still use `&lt;?`.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
the logic behind putting this (and &lt;%) in the language always amazes me. Why did they do it? What problem were they trying to solve?
Apparently I missed the /s...
Will this affect doing something like ```php &lt;h1&gt;&lt;? if(true): ?&gt; Hello &lt;? endif; ?&gt;&lt;/h1&gt; ``` If so, death to internals
It is framework agnostic in that your application and domain code is not dependent on any particular framework. I'm answering the question of what is meant by that term, not agreeing with OP. As I noted in my reply, at some point you need to deal with BC breaks; that is obviously unavoidable unless you don't use any external framework or libraries at all. However, writing framework agnostic code means that you don't need to change your application layer or domain model itself to do so.
 [https://3v4l.org/kuLmD](https://3v4l.org/kuLmD)
My comment is directed toward all people using short tags at this point. Perhaps I could have phrased it better, but it's hardly 'toxic'.
Just to clarify: Did you mean that people that use short open tags are lazy and inattentive? As for &gt;but it's hardly 'toxic' I, too, simply calmly expressed my opinion =)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Depends which "default" you were using. It's been disabled by default in the shipped .ini files since 2009 ([new inis rfc](http://wiki.php.net/rfc/newinis) / [commit](https://github.com/php/php-src/commit/c3fcaf1d7d1f663080a7c14c0e561077e44229ae)) but the engine default (if you have no .ini, or the directive is omitted) never got changed, so is still enabled in 7.3 and enabled is the [documented default](https://www.php.net/manual/en/ini.core.php#ini.sect.language-options). My personal opinion is that, especially for something like this that will affect a high number of legacy code bases, has the potential to leak code (and anything in that code - including service credentials) and, as far as I am aware, isn't blocking any other features or code changes, a deprecation period of 1 minor version (assuming the current plan of 7.4 being the last 7.x release becomes reality) is too short, even with an extended support period (assuming that's granted to 7.4). I think features should, especially where they're not blocking other code changes, be deprecated for multiple minor versions - if not an entire major release cycle - altho that's a bit of a loose concept. Perhaps a time period of, for example, 5 years, might be a better specification. Not everyone is actively maintaining every code base, and people don't always upgrade their PHP every minor version.
&gt;The PHP [documentation](https://php.net/manual/en/language.basic-syntax.phptags.php) discourages their usage. &gt;PHP's short open tags clash with XML &lt;?xml ?&gt; and can mean two different things depending on the INI configuration. &gt;PHP's short open tags depend on an INI directive and as such are non-portable. &gt;As such source code may leak if PHP relying on the short open tags is executed on a configuration where this isn't enabled. &gt;PHP's parser simplification. From the RFC. I think it is a nice improvement. Using the short tags have been discouraged for many years now, and it takes only a few minutes to string replace them in your code base, so it should not really be a huge problem.
Honestly, wideo's like this have such little to no value. After however many decades that OOP has existed, and PHP has existed, I think we can all put these types of topics not only to bed, but to the grave. The explanations have been given enough times by now... do we need yet another? No.
Mainly in legacy code. I have one which uses them throughout however I disabled short tags in PHP.ini and went through and fixed them all. Most were found via searching in PHPstorm for `&lt;? ` however it didn't catch those that that didn't have a space after. Pretty sure you can use regex search to find them all.
I saw comments you don't really look for difference, but you need to upgrade your code to from PHP 5 to PHP 7. In 2019 it's crazy to do such work manually. Unless it's your intention/hobby of course (mine was only for the 1st time :)) **You can use Rector (tool I wrote) to upgrade all A → B changes for you, it supports PHP 5.2 to PHP 7.4** (PHP 7.3 Typed properties already included ;)). See all the rules: https://github.com/rectorphp/rector/tree/master/config/level/php
Good article. Thx! My framework post is missing in the ressources :P [https://www.reddit.com/comments/axklgn](https://www.reddit.com/comments/axklgn)
Hey GlowInTheDarkDonkey, You have been on reddit around 6 years and have about 20k karma on comments which means that your comment are loved by thousands of people, so respect... But I think right now you are talking from your point of view. The video description says that it is for absolute beginners. So I am not surprised that it's boring for you... Also, as it is mentioned in the video, it is an introduction which will be followed by several videos which will cover 99% of OOP in PHP in 2019. Things what are explained years ago can be explained differently today. Research was made before the video was recorded and none of the videos I found on Youtube says what I want to say. There exists many popular car manufacturer which produce cars for more than a century, but new ones are born every year. There exists smartphone companies which have been creating phones for more than 20 years, but new phones appear every year. Saying "Why do we need these new videos when we have already many old ones", I think is not correct judgement. &gt;This doesn't bring anything new to the table... It will bring a lot new or "old in a new way" in the next videos. And if you think that one of the purpose is to gain sweet, sweet Youtube money, why not... if my content will be loved by hundreds of thousands of people...
This comment isn’t useful at all. People still use php procedurally, why not have a video that explains it slightly differently
Reckon you might have time to look at [my PR](https://github.com/Codeception/Codeception/pull/5489) now?
&lt;?= (true) ? 'Hello' : ''; ?&gt; ???
I've got a project that's still rocking Laravel 5.1 because the first upgrade to 5.2 broke it and it was shitty project to begin with so I never put time or effort to upgrade it. Now it's a mess to do so :D Hey, it works though.
They hated u/paulovitorbal because he told them the truth
&gt; if my content will be loved by hundreds of thousands of people One (maybe two if I didn't notice it) of your videos has broken 1k views in the last half year. I guarantee you the world doesn't need another broken-English Youtube tutorial on the basics of computer programming.
Hey mate. The only thing that I will agree is that there have been more than enough explanations done on this topic. However, not all of us (developers, engineers, beginners etc.) do understand the explanations done by everybody, therefore if at least one person gains something new from the video, it was worth it. Moreover, we can not put the topic of OOP to the bed, let alone the grave, yet, because it is one of the main standing pillars of software engineering as are data structures, algorithms, functional programming and more. Plus, the idea explained here can also be moved to another language(s) which implement OOP, cause the idea of OOP will be more or less the same (syntax, implementation will be different, not the idea).
How many slightly different ways do you need it explained to you?
&gt;Honestly, wideo's like Talking about broken English :)
In this case I meant the engine default. Which in the current implementation patch for 7.4 is changing to disabled.
Hey _sleemy_. You seem to be interested only in some anime-like images, and not interested in the topics discussed in /r/php at all. What made you come to this particular topic today?
Hmm, could that have been intentional on my part? Surely not. I wouldn't be so obvious, right?
That'll just be annoying if "Hello" is replaced with HTML.. ```PHP &lt;div&gt;&lt;?= (true) ? '&lt;p&gt;Your IDE doesn't know about me.&lt;/p&gt;' : '' ?&gt;&lt;/div&gt; ```
From your past activities on Reddit, it's quite clear the negativity you try to spew out everywhere. Although I believe that Reddit is great tool to receive constructive criticism about oc, I doubt you are a perfect example of this... quite the opposite. Small advice from me, if you are willing to take of course: don't shit on others work, everyone started from somewhere. I'm sure you have your own profession, your job, a hobby that you are good at... look back and remember that you were once not really good at it and through practice you've improved. Now think also, would it not have been better, if you had received more encouragement rather than someone shitting all over it? I'm certain you would agree with me on this. So why do something to others, that you would not like to have been done unto yourself?
Put the opening echo inside the &lt;p&gt; then. I don't know, that's how I make templates when I cba with template engines. It's not THAT bad but I guess to each their own.
&gt; something like this that will affect a high number of legacy code bases I doubt a high number of legacy code bases will update to PHP 7.
There's no value in encouraging more of the same noise on Youtube. It's just that simple. If I was making a video course on youtube about OOP in PHP I'd expect to get shit on, and rightly so. This has no more value than someone streaming fortnite. Get real. Being a do-gooder just for the sake of it is trite.
Video starts. Codeholic lists the sub-topics - and their order is excellent, so this particular part of the video is awesome. &amp;#x200B; Introduction is on the point - no unnecessary noise - awesome &amp;#x200B; He starts with the best and simplest explanation of a class - awesome &amp;#x200B; He provides an example (a car) and shows actual images for the viewer to get visual feedback as well - awesome. &amp;#x200B; Video isn't too long so viewer attention isn't lost - awesome. &amp;#x200B; In my opinion, this is an excellent way of lecturing. Great job man, keep it up, you got my upvote! Short, concise, on point, visual feedback - what's not to like?
I say we just go back to procedural programming.. I say bring back php 3.0
Thank you man. It means a lot...
Recognition must be given if it's earned. Any day my friend, any day. Keep up the awesome work!
While reading this, was the suspense high when the "awesomes" will stop and the "terribles" will start? Must been a great relief when you got to the end of it ;-)
Thank you man
I think this is an important point that applies to learning anything, it sometimes takes one person's particular style of explaining a concept to make it click. For this reason I think it's good practice when learning a new topic to use multiple resources, even if they are explaining the same idea it can help deepen your understanding.
Looks like somebody gets paid by the hour!
You are correct. I overlooked where he said "language features" in his earlier comment.
I don't disagree with that in theory. Once such features exist, though, I think the advantages to removing them need to far outweigh the disadvantages. If we want to start moving towards the removal of language features from the ini file, start with options that aren't going to have as big of an impact as short tags. Then, when you get to the ones that are going to have a bigger impact, the "we are moving language features out of the ini" is a much stronger justification.
Ok, but why?
I was joking
Sarcasm is completely lost on this lot of jokers.
Thank you! I will take a look and going to merge it if everything is ok!
&gt; After however many decades that OOP has existed, and PHP has existed, I think we can all put these types of topics not only to bed, but to the grave. The code from offshore developers that I'm having to fix would indicate otherwise.
I'm sorry to hear that doesn't save your time and makes you miserable. Codeception works great for small, medium, and large companies, and big projects. I'm pretty sure you just cook it wrong. Could you bring some examples, maybe why do you want from DI more than it can do?
...who are "we"? ;)
Quality!
Right, forgot about the XML tag.
Nah, just open minded enough to respect the occasional YOLO. It's not like procedural programming doesn't have its place.
Having been with Laravel full-time since 5.1, I can tell you that migrating from 5.3 to 5.4 was a -bitch- and migrating *tests* from Laravel 5.5 to 5.6 (due to PHPUnit version bump requiring changes) was not fun, it's more or less trivial. A software product I rely on heavily is www.laravelshifts.com. It is a godsend.
Unfortunately too many breaking changes happen. Too much new functionality is targeted to the current release branch instead of master. The latest change that just broke in a minor release is the new @error blade directive. Someone opened an issue because they had a Vuejs component that had an @error attribute. But now Laravel thinks it needed to render it so it broke his views until he escaped it. It wasn't even acknowledged as a breaking change.
I don't like learning from videos. I'm more the type who prefers texts with good examples. But I watched Part 0 and 1 of your tutorial and share my opinion with you: + You're doing it good. I tried once to make a video... And I totally suck at it. Your voice isn't annoying and you don't give irrelevant infos + I liked the part where you compared a class to a data type - I don't like the car example. I've often seen it in bad tutorials that made the whole OOP more confusing as it was before. I'd prefer more abstract classes like vectors or complex numbers. (But I think, I'm the minority with this opinion)
Very useful information, thank you.
What’s funny is that I much prefer building my own performant queries to retrieve exactly what I want instead of needing to use query builders. If I had to pick Doctrine or Eloquent, it would definitely be Doctrine however.
* Doctrine Dbal has $connection-&gt;insert($table, $values), say insert('users', \['name' =&gt; 'foo'\]); * You can actually use Doctrine entities with public properties, with php 7.4 typed properties this becomes even more interesting. Getters/setters are not required. * I agree the Database to entities generation is crap in Doctrine (I wrote a lot of that), but what I did in several projects is using either the Doctrine DBAL SchemaManager or the ORM DatabaseDriver to write my own entity generator. It is very easy in my opinion, shouldn't be much code and gives you way more control over the generatoin.
Thank you for your feedback
Query Builder != ORM . However, I agree with some of what you're saying. I wish there were an ORM which worked better with Postgres' modern features ; such as the JSON and HSTORE data types
It's interesting (as in irritating) that you can't make an Entity extending another. But you can do a hacky workaround with a shared trait. In general, I've never understood the point of Doctrine, as I've found, say, CodeIgniter's query builder to be much more of a sensible abstraction.
&lt;?= is the same as &lt;?php echo. Shorthand Must be enabled in php.ini before php 5.4. Hello world just proves php is running. No use for it. But if php wasn’t installed or running it would generate an error.
Personally, I'm in the opposite boat. Eloquent was great for all of my small projects, now in a large project that has a lot of rapid changes, the inability to statically analyze Eloquent has become a burden. The ability to use a setter to control the flow of data into a model is powerful and always allows you to easily statically analyze the type being set. Unfortunately, with Eloquent this becomes much harder when you have a team of developers, mutators are the only way to somewhat control this, but static analysis on a mutator is not reliable.
as /u/jesse_dev mentioned above, Query Builder != ORM
`&lt;?= "Hello World" ?&gt;` itself may be fairly useless, but you failed to mention what the shorthand is actually useful for. If you're application is set up in a clean way then the HTML and PHP is separated, so theoretically your view is passed a bunch of variables ready to render so using the shorthand to do stuff like `&lt;?= $title ?&gt;` becomes really handy.
I'm slightly disappointed, I was expecting an insanely useful tool, haha!
you actually can make an Entity extend another: https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/inheritance-mapping.html#class-table-inheritance
Well you could use it for views instead a Template Engine... It's readable and some IDE's support the code-completion for it...
I don’t see what this has to i with php? You also posted this to a tonne of other subreddits, so I guess you’re just canvassing your product. This isn’t even a good advert, you don’t give any context. Please, stop spamming your product over Reddit. Buy adverts if you want to advertise.
I recommend checking out the Atlas ORM. It's a data mapper ORM without any of the magic.
It’s possible for count to change during iteration (I can’t think of any non convoluted example, but I’m sure they exist) so the count is re-called every iteration.
First of all: good post. Taking the time to properly write down all of this deserves some credit to begin with. Therefore, well done on this part. Comparing Doctrine to Eloquent can't be done just like this as they are different designs. Just like you said, Eloquent or rather Active Record is absolutely great for simply CRUD based applications. You don't really need to be afraid that your model loses state somehow. However, in complex applications where a lot of services grab your entities/objects and modify them there is danger in overriding some other components state. Doctrine / DataMapper is a learning curve, that's for sure. One can always ask "why i have to learn this". And the answer is almost always the same. Because it's worth it. Learning about the differences in both approaches is key to understanding on why is better or worse in one situation or the other. I, for one, am absolutely on the Doctrine side of things. I don't like this whole magic of Eloquent. Surely you can strip the magic away but that's not so simple when you try to join a project using all this magic and you have no idea of it's existence.... &amp;#x200B; As for the other stuff. I'm with you, bundles - sucked, twig - sucks, yaml - SUCKS!, but symfony today is just like every other major framework. Be it Laravel or Expressive or whatever microframework, they more or less all work the same. It's quite easy to switch from one to the other on the surface of things.
I had a similar feeling not too long ago: [https://www.tomasvotruba.cz/blog/2017/03/27/why-is-doctrine-dying/](https://www.tomasvotruba.cz/blog/2017/03/27/why-is-doctrine-dying/)
my 22cents &amp;#x200B; DB schema \- We often get schemas created by another department. I get familiar with the schema then just write classes and annotations. Adding tests and using the schema validator along the way. Usually when i encounter something i can't map to doctrine i also encounter an improvement to the provided schema. Like missing primary and foreign keys, wrong normalization or even just bad naming, unpractical data type choices or use of vendor-specific features. For example Doctrine wants bools as MySQL-Tinyint and that's actually way more practical than the native bool type. So i communicate the "problems" back to the other department and over time get a more portable and practical schema. Just because you can design something "clever" in SQL flavour X does not mean you should. Altough it might seem so first, keeping it compatible with Doctrine often does not mean dumbing it down instead it means keeping it simple. \- When i design i also go classes and annotations first. Then i also use the mapping as the source of truth. No manual changes are allowed. I also use the migrations, ok in a design phase when my app is v0.1.2 i may scrap and throw away or consolidate some migration classes but when it hit's v1.0.0 i keep the migration classes. &amp;#x200B; DQL \- I'd say is less about portability but more about thinking-in-objects. So you use Class and Property names not Table and Column names in there. You never write the ON clause for a relation again which eliminates a class of bugs we often encountered when everyone uses query builders to build up complex queries themself - and screws up. &amp;#x200B; Object design \- I actually do not dislike getters/setters. You can go without setters and still code additional methods like User-&gt;register($username, $password) instead of the setters... \- Your example uses setParameter two times this is better than two setters? I guess you could go with a 3,4,5-liner and be completly semantic. $u = new User(); $u-&gt;setName($n); // or register($n, $p) $u-&gt;setPass($p); $em-&gt;persist($u); $em-&gt;flush(); // if you need to do it NOW \- Relations are everything to me. Doctrine requirers all known relations to be declared and to be consistent (eventual consistency will crash lazy loading). Inside a single schema this is actually the way i want it. If you cross schemas that are managed differently and can have some wrong references you are forced to make some clear boundaries. You can use Doctrine for both schemas, but you can't map the relation (have a getter, join with DQL etc) you need to collect one schemas references from the entities and call another schemas repository for loading the related entities. Then you can actively decide how to stitch these possibly incomplete results together.
For Windows, or a work-around for Windows? &amp;#x200B; I've seen a few for linux-based terminals. &amp;#x200B; Basically I am creating a CLI 'App' that processes information, and at a particular point CURL's an image to the server and does a little Imagick Editing to it. Instead of keeping it's output tucked away on the file system, I thought it'd be cool to have at least some sort of image preview within the command line after this completes. &amp;#x200B; NON-ASCII would be great, so you can actually see the details, but not a requirement if it's not practical. Even having the outline of an image-to-ascii would be workable, kind of like a preview in the CL interface. &amp;#x200B; Anyone have any suggestions for me? I'd really appreciate it!
It's just for when you have a lot of HTML like `&lt;?php if(isset($_SESSION['first_name'])) { ?&gt;` `&lt;p&gt;Hi &lt;?=$_SESSION['first_name']?&gt; welcome back.&lt;/p&gt;&lt;p&gt;More stuff...&lt;/p&gt;` `&lt;?php } ?&gt;`
You don't even have to write setters or getters. Define your properties with a type annotation and let phpstorm generate the rest.
This is fine until you need multiple unrelated classes to perform operations on the same data entity. At this point you end up: - passing the entity around everywhere (unrealistic) - using an Active Record ORM (performance sucks) - using Doctrine - writing your own entity manager Of those I’ll take Doctrine. It’s got a steep learning curve and the paradigms are hard to get used to but the juice is definitely worth the squeeze.
Depending on what you mean specifically in regards to multiple unrelated classes, perhaps I have technically wrote my own ORM, I don’t believe so, as none of my repo methods behave like Doctrine does, or hell perhaps they do it’s just that portion of the lifting is all behind the Doctrine curtains. Ha.
Generally speaking, I'm in your camp. but, I have to say, query builders are great when you need to dynamically build your queries based on user input (e.g. additional columns and/or joins done if user checks boxes a, b, c).
&gt; Doctrine requires getters/setters for relations (to make lazy loading possible). Nope. Not sure when it was implemented but lazy loading using public properties work just fine. The proxy object actually unsets the property in order to trigger the __get call. On the other hand, lazy loading should be avoided in most cases anyways. Doctrine 3 is ever so slowly coming closer to being released. Maybe it will improve things. And at the risk of nitpicking, Symfony still has bundles. You just no longer need to use one (or more) for an application.
Well looks like you beat me to it! It’s been a long 18 months for me y’all. I’ve been working non-stop to push for this release to happen. Recently, I’ve also been promoted to lead dev for the Slim Framework org yay! Rob Allen [@akrabat](https://twitter.com/akrabat) showed me the ropes and domesticated me enough that I can now be the face of the organization xD Anyway enough about me. I’m pleased to announce the Slim 4 Alpha Release! **[Slim 4.0.0-alpha release](https://github.com/slimphp/Slim/releases/tag/4.0.0-alpha) ** See the [release notes](https://github.com/slimphp/Slim/pulls/2665) **Before doing anything read the docs** I just finished the first draft of the docs for Slim 4 which are available here. I need feedback please: http://slim-website.lgse.com/docs/v4 **Download an test the 4.0.0-alpha release** You may also play around with the `4.x` branch and create a simple app with it to test things out. `composer require slim/slim:4.0.0-alpha` **Install a PSR-7 Implementation** You will also need to install a PSR-7 implementation and ServerRequestCreator combo. You can use Slim's PSR-7 Implementation or choose one of the ones described on the `4.x` branch README: https://github.com/slimphp/Slim/blob/4.x/README.md `composer require slim/psr-7:dev-master` **Slim 4 DDD API Skeleton Prototype** I also just created a Slim4 Skeleton with a DDD style directory structure with example files and test coverage for everything. I'm not sure if it's the right fit yet as it may be a bit too opinionated but I'd love some feedback: ```bash git clone https://github.com/l0gicgate/Slim-Skeleton git checkout 4.x ``` If you have any questions don't hesitate to ping me on Slack or ask questions in the [github feedback thread](https://github.com/slimphp/Slim/issues/2653) directly, I'm available to help!
Got it. Then your intended workflow will get you there.
&gt; My thoughts were "was it written by sadists, why do they have to make everything more complex than it could be"? Welcome to the Java World.
Symfony + Doctrine get inspirations from domain-driven development. For example instead of the _minimalistic but self-contained_ example at https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/query-builder.html#values-clause which wouldn't actually occur like that in real projects you'd have: * a `User` entity * used symfony/form which uses symfony/validator internally and may produce a `User` from input for the respective form * defined a `UserRepository` * configured mappings between the `User` entity and a table through annotations, YAML or XML * and used Doctrine's `EntityManager` in order to save the entity instead of implementing a direct database insert wrapped in function calls * and put these calls into a controller The example at the Doctrine docs really doesn't (and shouldn't) assume that you do have to do model validation and that you therefore can utilize the usual ORM mappings.
getters and setters are not about types. they are required because of the proxy objects, so you can have a reference to an entity without fetching it from the database. imagine having to fetch all the related entities every time you want a specific entity. Doctrine just adds a reference object (proxy) as a placeholder for a related entity, which extends the real class. then, once you try to get a property on said object, it fetches the real data for that object and replaces the proxy with the real entity. it's quite ingenuous, really. and it's so well implemented that most devs have no idea that this happens. :)
StackOverflow
Many people have forked the project how would one know witch one is now maintaining the project and even if they are applying changes we don't know if it isn't the cast of Dumb and Dumber maintaining the project. I am not an expect in this type of thing. A simple looking patch could break everything unless you know what you are looking at.
You’re replying to one of Doctrine’s developers so something has probably changed if it now supports direct field access. I think it does via magic get/set after unsetting your fields.
Well, I looked into it. Tried some image to ASCII converters on github. Output was really bad; hard to decipher even what the image is. There are a bunch of command line terminal/consoles in linux that support viewing images- even the built in mac terminal has such support. From what I gathered there is no way to do this in Windows.
Cool! Congrats on the release, guys! We use Slim for our primary API at the company I'm at, looking forward to this once it gets out of alpha :)
I don't think it's as widely used with everyone moving to templates like Twig and Blade.
joke's on me then. now I'm really curious on how typed properties handle proxies! :)
Not sure why you'd be under the impression that AR is slow... It's really not, IMO. Never been anywhere near the bottleneck for anything I've written. The bottleneck is generally the query or network. And fixing the query is usually pretty simple (n+1 issues are easily solved with an eager-load, etc.)
I've been using laravel-ide-helper which solves the analysis issue pretty much entirely. It can insert property hints on your models.
I have two questions. 1. Why specifically PHP if you apparently asking for the existing utility. What does matter which language it is written in? 2. WTF is "CLI image viewer" at all?
For the literal Hello world you indeed would put it right into HTML. But with further learning into PHP some day you will learn that such a thing as a variable also exists. For which an output operator would be probably of some use
Doctrine, along with Eloquent and pretty much any "full-featured" ORM are tragedies. I prefer simple AR abstractions, with anything more than a select, insert, or delete as hand-written SQL. There are better patterns for fault tolerant petsistence. If your first step in writing or using an ORM is "and then there's a custom DSL for the database", god help you. SQL already exists, just use it. Most of these ORMs abstract the data layer to point of utter obfuscation, while creating byzantine and non-performant SQL. Use a driver model for the SQL. Your ORM is not portable, you'll do just as much validation and rewriting as if you just rewrite the SQL. Frankly, this ORM-as-a-DSL crap is so bad that I've spent the last decade making a career out of cleaning it up. These systems become nearly unmaintanable. For the typical PHP system, it's really a dark pattern just waiting to blow up in the long tail. The learning curve on each codebase is steep, since the schema is implicit in the object definition rather than explicit in a model.
I haven't got to the Symfony part of your post yet... I'm still flabbergasted that companies actually let you learn new frameworks on their time... and so many frameworks! Every agency I've worked for is thoroughly invested in the, "Level up via stackoverflow to finish the project yesterday!" The last thing I actually got the time to sit down and learn was in high school and university...
At the very least it is better than Propel.
https://github.com/stefanhaustein/TerminalImageViewer Something like that?
all the classes i wrote encounters 'Class was not found while trying to analyse it - autoloading is probably not configured properly.' message. i can bypass this if i add my classes to autoload paths ( phpstan.neon configuration file ), but if i do this, the codes inside the classes are not analysed. could you please tell me how i can analyse codes in my classes?
Brilliant, thanks. The previous version of the PR was against v2.5 which I submitted weeks ago, but I guess you've been busy with the v3.0. Nice to get a response though, thanks again!
Hey man. The first approach on the main comment is what I done. Sort players by rating, then by relationship, then position. And bobs your uncle! Laravel collections were a sweet suggestion, thank you! Been using the team selector for the past 4 weeks without issues. Maybe tweak teams here or there but otherwise, it's great. Will be re-working the stats system soon though, not keen on the basic 1-10 system. Thanks for asking and following up!
The changelog is looking very exciting. Looks like we will be able to replace some of our custom Slim code with these new features! Going to try it out in one of our services soon 👌
It’d be best to open an issue in PHPStan repo and attached a small reproducing repository with your problem. Be also sure to check the Autoloading section in the README.
 class Foo { /** @var bool **/ private $types; /** * @param array $types public function __construct($types) { $this-&gt;types = $types; } } Using hints is not a good solution for static analysis when you can just use type declarations.
for example, i have a file named myclass.php like below `&lt;?php` `class MyClass` `{` `public function test1()` `{` `$this-&gt;test2();` `$this-&gt;test3();` `}` &amp;#x200B; `private function test2()` `{` `echo 'asdf';` `}` `}` &amp;#x200B; when i execute phpstan for this file, ( phpstan analyse myclass.php ) it just says 'Class MyClass was not found.' what i expected was something like this : 'Call to an undefined method MyClass::test3()'; &amp;#x200B; is there something i misunderstood for phpstan or do i need to open issue in PHPStan repo?
for example, i have a file named myclass.php like below &lt;?php class MyClass { public function test1() { $this-&gt;test2(); $this-&gt;test3(); } &amp;#x200B; private function test2() { echo 'asdf'; } } &amp;#x200B; when i execute phpstan for this file, ( phpstan analyse myclass.php ) it just says 'Class MyClass was not found.' what i expected was something like this : 'Call to an undefined method MyClass::test3()'; &amp;#x200B; is there something i misunderstood for phpstan or do i need to open issue in PHPStan repo?
Remember that PHP was originally a templating language :)
Your autoloading setting is still wrong. If you add “-a myclass.php” on the command line, it will start working. Of course, to use it in a project, you should have autoloading in place, using Composer or other ways mentioned in the README.
Congrats but it is depressing to see how over-engineered everything looks like compared to the previous releases. Slim was like the expressjs of php frameworks. Can't say the same now.
Agree, the definition of microframework has changed massively in recent years. It used to be about simplicity whereas now it seems to be exactly the same as a full framework just with a restricted set of features.
Nostalgic feeling : D I used Propel with Symfony 1.4 and also when moving to Symfony 2 beta xD
i added myclass.php to autoload list and anlaysed myclass.php. it worked like a charm! &amp;#x200B; what i did wrong : didn't analysed myclass.php file itself. i analysed other php file that just load myclass.php ( require 'myclass.php'; ) and expected to see MyClass's error right there. &amp;#x200B; /u/OndrejMirtes , very very thanks for your reply.
Cool! You should look into PSR-4 to make your life easier 😊
&gt;Maybe I just don't understsand Doctrine and you can point me in comments stuff which I don't know. &amp;#x200B; It's just that Doctrine does separation of concerns correctly. Many other replies explained this very well. I want to stress this as it's the main reason I use Doctrine. Everything I code can be properly unit and functionally tested with no magic and no side effect. The ORM aspect allows for stuff like listeners to do some complex checks with minimum code compared to alternative solutions. It really depends how complex your data management is. After that it's a lot of reusing the same clean pattern. I have a BaseRepository with tons of helpers so that creation or querying entities is a one liner. &amp;#x200B; Example: `/**` `* Repository for User.` `*/` `class UserRepository extends BaseRepository` `{` `/**` `* Constructor.` `*` `* @param ManagerRegistry $registry` `*/` `public function __construct(ManagerRegistry $registry)` `{` `parent::__construct($registry, User::class);` `}` &amp;#x200B; `/**` `* {@inheritdoc}` `*` `* @param QueryBuilder $qb` `* @param array $parameters` `*/` `protected function processParams(&amp;$qb, $parameters)` `{` `$this-&gt;filterByDateInterval($qb, $parameters, 'createdAt', 'created_at_from', 'created_at_to');` `$this-&gt;filterByBoolean($qb, $parameters, 'enabled');` `$this-&gt;filterByValue($qb, $parameters, 'email');` `$this-&gt;filterByValue($qb, $parameters, 'username');` `$this-&gt;filterByValue($qb, $parameters, 'username_like', 'e.username', 'LIKE');` `$this-&gt;filterByValue($qb, $parameters, 'roles', 'e.roles', 'LIKE');` `$this-&gt;filterByValue($qb, $parameters, 'roles_not', 'e.roles', 'NOT LIKE');` ...
I'd argue it's the complete opposite. Traditional large frameworks usually provide a lot of functionality "out of the box" while microframeworks focus on delivering a minimal set of basic server-side (HTTP) features allowing you to construct your "own framework" from any components you choose. Seeing as one of the focuses in Slim 4 is decoupling from previously included libraries I'd say that the focus is even more about simplicity than before.
A nice, concise summary of what SOLID is. A good starting point for someone interested in it...
Just use Sentry.
I need to instantiate a complex class hierarchy from within a Codeception Module, preferably with scopes. I also need from a DI framework the ability to resolve cyclic dependencies. I have a requirement that Actors should manifest a business object model. So each Actor only have methods that are valid for the application state it describes. If a method changes a state it should return another Actor that is valid for the new state. For example, a Login Actor have a login() method that returns a Front Page Actor, that have a logout() method that returns a Login Actor. From the minor things. I need the ability to add my own command line arguments to the codecept binary, at least for overwriting test params, because our testers grew extremely tired of dozens environment files that differ only by a pair of values. I need the ability to get the currently selected environment form within a Codeception Module. When the Codeception add a method to an auto-generated Actor class it should not only preserve the method's return type, but if it returns a class - the Codeception should import it into the Actor' namespace. Because, otherwise the IDE can't hint it inside a test and this behavior confuses testers. I need the ability to describe capabilities of the Actor that I need to be passed in my class, i.e. to type hint the interfaces it implements. What pains me the most is how the WebDriver module is written. It encourages our testers to write some horrible code. For example, this is how a test looked like on my previous job: DactylocardsScenario.get() .openCiadisFrontPage() .goToDactylocardsTab() .startCreatingFromScaner() .createWithoutChecking(cardCreationData.dactylocardTypeAlias, cardCreationData.registrationTypeAlias, cardCreationData.dactylocardCategoryAlias) .checkExpectedFormIsDisplayed() .checkLeftCardDataBlock() .checkRequiredFieldsAreMarked() .checkAllFormFields() .goToCardPreviewPage() .openNotSavedDactylocardWindow() .checkRequiredFields() ; And this is how a test step looked like: public DactylocardsScenario goToDactylocardsTab() { Log.getLogger().debug("Going to the Dactylocards tab."); PageObjects .subsystemTabs .shouldBeDisplayed() ; PageObjects .subsystemTabs .dactylocardsButton .click() ; return this; } And this is a way Page Objects were written: public class SubsystemTabs extends WbPage { //... public WbButton dactylocardsButton = new WbButton("Dactylocards Tab"); public WbButton tracesButton = new WbButton("Traces Tab"); public WbButton databasesButton = new WbButton("Databases Tab"); //... } And this is how Page Objects are written on my current job and what I'm struggling to change: class BillingAccountPage extends DefaultPage { public static $addNewButton = "//button[@title='Add new']"; public static $saveChangesButton = "//button[contains(.,'Save changes')]"; public static $idField = "//input[@name='id']"; public static $billingAccountsLabel = "//label[contains(.,'Billing Accounts')]"; public function addBillingAccount($billing, $account_title = null, $currency = null) { $this-&gt;tester-&gt;message("Adding new billing account"); //... $this-&gt;tester-&gt;amOnPage('/billing-accounts'); $duplicate = $this-&gt;checkDuplicateBillingAccount($local_billing-&gt;account_id, $local_billing-&gt;currency); if ($duplicate) { $this-&gt;tester-&gt;fail(sprintf("Billing account [%s] with currency (%s) is already created!", $local_billing-&gt;account_id, $currency)); } $this-&gt;tester-&gt;waitForElementAndClick(static::$addNewButton); $this-&gt;tester-&gt;fillFieldsOnPage(Admin::billing_account($local_billing)); $this-&gt;tester-&gt;click(static::$saveChangesButton); $this-&gt;tester-&gt;waitForText('New billing account has been saved', static::TIMEOUT); $title = $local_billing-&gt;title; $account_id = $this-&gt;tester-&gt;executeSql(...)[0]['id']; $this-&gt;tester-&gt;amOnPage('/account-groups'); $this-&gt;tester-&gt;waitForElementVisible(static::$idField, static::TIMEOUT); $this-&gt;tester-&gt;waitForElementVisible('(//div[@class="ReactVirtualized__Grid__innerScrollContainer"])', static::TIMEOUT); $this-&gt;tester-&gt;fillInput(static::$idField, $local_billing-&gt;account_group_id); $this-&gt;tester-&gt;waitForElementAndClick(sprintf('//a[@href="/account-groups/%s"]', $local_billing-&gt;account_group_id)); $this-&gt;tester-&gt;waitForElementAndClick(static::$billingAccountsLabel, static::TIMEOUT + 50); $this-&gt;tester-&gt;waitForElementAndClick(sprintf("(//div[contains(.,'[%s]')])[13]", $account_id)); $this-&gt;tester-&gt;click(static::$saveChangesButton); $this-&gt;tester-&gt;waitForText('New account group has been saved', static::TIMEOUT); return $this; } }
what is the use of this huge comment? https://github.com/slimphp/Slim/blob/3.x/Slim/App.php#L64
&gt; You don't really need to be afraid that your model loses state somehow. However, in complex applications where a lot of services grab your entities/objects and modify them there is danger in overriding some other components state. That's why you pass a repository and not an eloquent object to those said services. &gt; I, for one, am absolutely on the Doctrine side of things. I don't like this whole magic of Eloquent. Surely you can strip the magic away but that's not so simple when you try to join a project using all this magic and you have no idea of it's existence.... That's literally the same when you pick up Doctrine. You don't know half of its shit and you just have to learn it. Shocker. Very weird reasoning there.
&gt; You can actually use Doctrine entities with public properties Public properties on entities is not good design imo. Good entities are not simply bags of data, rather, entities should enforce business rules, which they don't if you can simply mutate their state directly.
&gt;Never been anywhere near the bottleneck for anything I've written. This is the important point. /u/tostilocos would be right in saying that Eloquent is in general slower than Doctrine, but you're equally correct in saying that it essentially never matters. The overwhelming majority of applications (even massive enterprise applications) will never be bottlenecked by the performance difference between Doctrine and Eloquent, assuming you're programming to their strengths and are equally experienced with the two libraries. &gt;And fixing the query is usually pretty simple (n+1 issues are easily solved with an eager-load, etc.) Because of the design of Eloquent there are a bunch of performance optimisations and caching features* that require some kind of intermediate service/repository layer to implement. But I don't really see this as a downside, any project requring this kind of optimisation should probably have something like this and it doesn't end up being any more complex than Doctrine tends to be. ^\* ^Prior ^to ^Laravel ^5, ^a ^`remember()` ^method ^was ^available ^directly ^on ^the ^query ^builder ^for ^caching ^results, ^but ^it ^forced ^Eloquent ^to ^have ^a ^dependency ^on ^Illuminate/Cache ^and ^so ^was ^removed ^to ^make ^Eloquent ^less ^dependent ^on ^external ^libraries.
OMG!!!!! I've just got to know that you're a writer of PHPStan. &amp;#x200B; i'm not a professional web developer and PHP was not on my top list because i always mistype, change function/variable names frequently. but with PHPStan, i think i will be able to start my small project using PHP! not so afraid of basic errors just like when i'm using compilers. &amp;#x200B; i really appreciate your help, and thank you for your work, PHPStan. your're my hero.
Thanks, I appreciate it :)
Reading this feels like being author's rubber duck. I don't believe that you can understand SOLID without showing some real OOP and these examples suffer from procedural approach and typical syntax tutorials (inheritance with Ducks and Dogs) internet is flooded with. You wouldn't ever want a class name to substitute it's attribute - `Earth` might be an instance of `Planet`, but there's nothing that makes it a class on it's own (what would be represent second instance of concrete planet anyway). If you fix the above the next problem is to decide what planet class really represents - because if it's a value object then you didn't even started with OOP that these principles refer to (encapsulation might make it immutable data structure at most). If it's a business object there's no need for `SurfaceAreaCalculator` tearing off planet's properties and doing pure calculations on them. You might inject some `Sphere` object that can do the same instead of passing radius primitive, but planets are unlikely to change its shape, so calculating area within object would be perfectly fine. Output formatting is indeed outside the scope of the "business calss" Planet (and any other Model layer object), but if Planet class was a view model... I don't want to get myself trolled into correcting entire blog post, so I stop here. Not much beside quotes is correct there really. I can imagine anyone can produce article on the same level by just expanding on what they say (rubber duck).
Considering he was helped in 1 comment I don’t see the big deal here. I’d much rather this over seeing someone spam post their shit package, blog post or YouTube tutorial with shit crackly audio. 🤷🏼‍♂️
&gt;whole magic of Eloquent What kind of magic are you referring to ?
&gt;the inability to statically analyze Eloquent has become a burden ELI5?
Glad that you liked it.
Five years on Zend and I still can't figure it out. Only good thing about it is that it's dying.
For entities specifically I like to use maker on console. `make:entity` has served me well. Of course there is often still some manual work, but it's a great boilerplate.
@felds You have old information about how Doctrine Proxy objects work, getters and setters are \*not\* required anymore for proxy objects to work correct. I believe this is the case going back to Doctrine 2.4 or 2.5 so already a handful of years.
It's worth noting that short tags are discouraged, and you should always use the long form tag https://www.php.net/manual/en/language.basic-syntax.phptags.php the short tags will be deprecated in the next version of PHP https://wiki.php.net/rfc/deprecate_php_short_tags
I think the difference here is that those operators change depending on **how** they are used, I'm worried that changing behaviour based on **where** it is used is different. You could have this code snippet: ``` $r = ['a' =&gt; 'foo', 'b' =&gt; 'rawr', ...$c]; echo doThing(...$c); ``` Which would work for the `$r` array, but fail when doing it for the method. As the behaviour is so similar, it's going to be difficult to describe or see when it's being done one way and when it's being done another way. Also this: ``` $r = array(...$c); $x = arroo(...$c); ``` Would work in the first case but not the second.
I'm curious: why do you think Twig sucks? In my opinion it's one of the best, most thought out and feature complete template engine that is out there. What engine do you prefer?
With getters and setters a static analyzer is aware of what can and cannot be done with your database models. Take type hints for example: A static analyzer can see that certain types are required when setting or getting values from the model. It can use these rules when checking for comparisons you've written in other parts of the code to tell you they are probably invalid, while it has to be more careful suggesting this when all it can rely on is doc comments on properties at most.
Well that depends imo. If you're willing to use doctrine entities *as* your business entities. While I've done that for the most part of my time and don't think it's a bad thing, I've though that *maybe* a business entity should not be bothered with "persistence" at all, and a doctrine entity can just be that, a persistence thingy so to speak, handling persistence for your business entity.
So this came up about a month and a half ago on twitter, and the summarization of the discussion: &amp;#x200B; 1) the linter would've spotted this 2) almost every CS tool would've spotted this 3) most IDEs would've spotted this 4) [Bareword strings are being removed in PHP8](https://wiki.php.net/rfc/deprecate-bareword-strings) 5) [return types would've also prevented this](https://3v4l.org/pURcY) 6) [SaraMG even mused at the idea of validating the return types at compile time rather than runtime...](https://twitter.com/SaraMG/status/1102652393915928577)
Don't confuse Doctrine entities with business entities. Using the term "entity" was just an unfortunate choice on the part of the Doctrine development team. For the most part, Doctrine entities are just data transfer objects with little or no logic in them. And they almost always have a one to one relation to database tables. Not ideal for trying to model business information.
\`&lt;?=\` is not deprecated or removed.
Symfony is very much an object oriented framework. Have to switch to a procedural language such as Twig, complete with file oriented include statements, is disconcerting to say the least.
`&lt;?=` is short echo tag, which has different [documentation](https://www.php.net/manual/en/language.basic-syntax.phpmode.php#example-39), deprecation, and recommended usage, e.g (emphisis mine): &gt; In PHP 5, there are up to five different pairs of opening and closing tags available in PHP &gt; &gt; . . . &gt; &gt; There is also the **short echo tag** &lt;?= ?&gt;, which is always available in PHP 5.4.0 and later. &gt; &gt; . . . &gt; &gt; The other two are *short tags* and ASP style tags. As such, while some people find *short tags* and ASP style tags convenient, they are less portable, and generally not recommended. &gt; &gt; . . . &gt; &gt; As such, **we recommend only using &lt;?php ?&gt; and &lt;?= ?&gt;** when writing PHP code to maximise compatibility. Yeah, it'd be nice if their names were a bit better.
While you are learning, I would definitely suggest avoiding frameworks. But what you should actually start doing quite soon is - using *composer* package manager. It will let you simplify some of the routine tasks. For example: instead of making your own router, you can just use FastRoute package. Or instead of making your own DIC, you can go with Auryn. Or for HTTP request use Guzzle client package. Things like that.
Yeah. Or this. https://github.com/hzeller/timg Looks to be only compatible with Linux/MacOS though?
Well I could use exec or something, right? I just want it to be able to be launched/executed within a PHP script. And many workarounds or terminal image displays as (most) are not designed for colors or pixels, simply text, have Image to ASCII Art conversion tools for terminal display. Converts the image into text.
Hmm, thanks for the advice. would setting up a routing system actually be beneficial though?
Someone **please** tell me why Symfony no longer encourages Bundles in development??? Here in the Laravel world, I'm consistently preaching to my teams the joy of doing everything in Laravel packages. It just makes sense.
If you are using OOP paradigm - yes. If you go with the "include oriented" approach, then there are no benefits.
There's a couple problems compared to a real setter. The phpdoc has to always be up to date, if the mutator changes, the phpdoc needs to be updated, so it requires two areas to maintain. If you don't manually maintain the PHPDoc, you can automate it with ide-helper, but it occassionally type-hints incorrectly, especially on relationships. If it's automated to re-generate, you fix it, the next run, it overwrites your fix, it's just not as reliable as defining a setter.
You're probably doing it wrong, as is the vast majority of the PHP world. DB models should be little more than slightly smarter DTOs. Please put the business logic that involves more than 1 instance of the model, and/or multiple models, in other places, like Services and Repositories.
Static analysis is comparable to what a compiler would do in compiled languages, checks the code for errors before runtime by making sure syntax and types are set correctly. With PHP7's type-hinting, this is a great way to find errors prior to runtime and decreases your reliance on test coverage. Villerman did a good job explaining the issue with types. To add to Villerman, In our system, we could also benefit a lot from value objects and the enum pattern which are hard to implement in Eloquent because you can't easily analyze that a mutated property is receiving a value object like Money or an enum like Options.
Websites have overwhelmingly moved to the front controller pattern where *all* requests are funneled through a main entry file (usually index.php for PHP websites). This means you need some kind of router to then forward those requests onto specific handlers. I do strongly encourage you to adopt this pattern as the de facto way to scaffold your PHP websites. It is much more maintainable bootstrapping from a single entry file than including bootstrapping code in multiple entry files.
Sentry is a great tool for aggregating runtime exceptions, but at that point, it's already too late. Your code hit an exception in runtime and you've lost a major sale. Static analysis is pretty important, especially with PHP type hinting. Since PHP isn't compiled, the type hints arguable make the most sense with static analysis tools, since they are runtime exceptions, not compile time exceptions if you pass the wrong type.
In Eloquent, You should add your the table's columns as properties at the top of the class. See https://github.com/phpexpertsinc/laravel-rbac/blob/master/src/Models/Role.php
This is actually something that .NET's MVC shielded you from. In .NET, routes were, by default, of the form /controller/action. The framework took care of automatically executing the correct action. And the parsing of the action arguments took care of any additional request query parameters. You could actually adjust this behavior in the Startup.cs file but in my admittedly limited experience, most developers just went with the default. Some PHP frameworks use the same paradigm. But most tend to give you a bit more control in routing. Hence the need for a router. &amp;#x200B; By all means learn php. But C# is so far ahead of php in raw functionality that it will be a very interesting experience.
Hey! I could totally help you. i'm reviewing code of my collegues everyday, doing programming interviews and etc.
I am also checking in. At my work one of my responsibilities is code review. Nothing goes to master before my approval.
\&gt; Doctrine Dbal has $connection-&gt;insert($table, $values), say insert('users', \['name' =&gt; 'foo'\]); Thank you, I will definetely remember now about that possibilities: [https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/data-retrieval-and-manipulation.html#insert](https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/data-retrieval-and-manipulation.html#insert) The problem was that when I would google "doctrine insert" I would find [https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/query-builder.html](https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/query-builder.html) . After I read your tip I had to specifically search for "doctrine connection insert", and then scroll down to the bottom of a very long page to actually find those useful helper functions. \&gt; You can actually use Doctrine entities with public properties, with php 7.4 typed properties this becomes even more interesting. Getters/setters are not required. Perfect, thank you for pointing it out. I tested it almost 3 years ago and then it didn't work, but now it works :). I will definetely start to use it now. Altough I think that some third party libraries like Sonata Admin Panel are still not ready to work with entities without getters/setters. Internet is still full of explanations that "you need to have setters for lazy loading to work". And I also was looking for changelog notice explaining that change, and I still don't know when it was introduced. Either I really suck at using google, or Doctrine team could improve way of introducing such cool features. Especially when all the rest of documentation is filled with getters/setters and generators still generate fields as "private" possibly with getters/setters. \&gt; is using either the Doctrine DBAL SchemaManager or the ORM DatabaseDriver to write my own entity generator Another cool idea. I actually wrote something like this many years ago for "custom framework", but it didn't cross my mind until now. I think that I got lazy with expectations that frameworks should provide stuff...
&gt; You wouldn't ever want a class name to substitute it's attribute - Earth might be an instance of Planet, but there's nothing that makes it a class on it's own Oh I wouldn't know about that. This depends on the domain you're modeling. This is why those "dogs, cars, planets and wheels" tutorials are impossible to discuss in a sensible way. We're not just modeling objects for the sake of doing so. We do it for the purpose of describing a specific domain with specific intent and goals. For example politically, Earth would have many types of attributes (countries with borders etc.) that other planets don't. But are we modeling that at all? Yes / no, who knows. What about ecosystems. Are there any on other planets? Maybe, but none of that we know of. So do we put that in on Earth or all planets, "just in case"? Depends on the domain. BTW, I believe we've reached a point where SOLID does as much harm, or even more harm, than it helps people write good code. There's so much pseudo-science and blog-born mythology around it, that the truth in it has been completely and utterly lost. It's like a real-life example of Jean Baudrillard's "Simulacra and Simulation". The insight is lost, but the disembodied symbols keep living on, becoming a mockery of what they once stood for.
[Hmm](http://i.imgur.com/EJm3RAg.gif)
I could do it, love to discuss and answer on laravel, dont want any pay!
Sure, see my skills and references [https://www.tomasvotruba.cz/mission/](https://www.tomasvotruba.cz/mission/) I consult remote projects on a weekly basis. &amp;#x200B; You can email me or call me [https://www.tomasvotruba.cz/contact/](https://www.tomasvotruba.cz/contact/)
We have nearly a hundred CLI commands in our application, some of them used a hundred times a day. Doing cron jobs, tests, maintenance, background tasks, database migrations, code generation and what not. I would say it's just a matter of the application's size. For a simple home page of course one could do without CLI, but for a more or less big app you would *inevitably* start using a lot of CLI commands
It's less a question of the OS than a question of a compatible terminal emulation. :) Basically those apps just convert everything to terminal escape sequences and it's the terminal's job to interpret those properly and return the right result on the display. If the terminal under windows supports the sequences for true color (or at least 256 colors?) and things like that it should work just fine. I think they introduced PowerShell just for such kind of things to be more compatible with the UNIX-oid world. If PowerShell doesn't do it then perhaps there's a good 3rd party terminal emulator available that can handle this?
I would but I suck
I would suggest against going without bare metal. Few reasons mainly: You already have basic programming experience so there isn't much benefit of reiterating. Php while inconsistent is still pretty simple language. Bare metal language can be quite ugly. Modern frameworks like Symfony or Laravel did a lot to abstract the clunkyness away and provide slick interfaces. Given that php is almost only used for web applications (rarely cli tools via phar) you're not missing out on anything crucial by using those tools. Symfony component ecosystem serves like de facto std lib for php which other projects / frameworks build on top.
Lots of people at Sensio working on Symfony don't even like Doctrine. Me I don't really care, it's often too heavy or complicated but you still has access to the DBAL or direct SQL queries so use the correct layer for the task at end.
That's already solved as per [https://github.com/Ocramius/ProxyManager/releases/tag/2.3.0](https://github.com/Ocramius/ProxyManager/releases/tag/2.3.0) \- requires working with ORM `master` though.
There’s this guy named Taylor...
I'd really love to see an ORM that combines the good parts from both Eloquent and Doctrine. Easy to use, like Eloquent - no annotations or property declarations required, just extend some base class and you're good to go. But with a clean architecture behind it; some kind of manager/repository approach, instead of AR magic.
I could definitely do that as I’m reviewing my peers pull request. I’m a rest api engineer, and works with laravel since early laravel 4. PM me if you wanna talk about it more precisely :)
I do poopies
I agree, the entity should not be bothered with persistence, but I thought it was possible to configure the Doctrine ORM to use reflection and not pollute your entities with persistence logic? This is the main benefit of repository pattern and ORMs; your ORM is able to persist your business entities directly. If you have to create DTOs which map directly to database columns, why even use an ORM?
It's certainly possible that I'm doing it wrong, but if are using DTOs then why are you embracing the added complexity and performance penalty of an ORM as well? Using DTOs defeats the purpose of using an ORM imo. You may as well just normalize/denormalize your entities to/from associative arrays in your repository if you have created a second model simply for persistence, which sounds like a horrible anti-pattern to me. &gt; Please put the business logic that involves more than 1 instance of the model, and/or multiple models, in other places, like Services and Repositories. I'm not sure why you're talking about this, as I didn't say anything about business rules (I guess you mean invariants specifically) which span multiple entities, but entity-level business invariants should be enforced by entities themselves, otherwise your model is very brittle and easy to break.
ORMs are extremely complex; the reason they exist is to make it possible to persist models which were not designed with a database in mind. I.e. models which were designed around business logic. Imo if you have a second model for persistence purposes which simply consists of DTOs, then an ORM is completely unnecessary.
So my scenario is this: \- I have a codeception project with robo with just 1 acceptance test \- I run the same test multiple times with robo through this function: &gt;public function parallelRun() &gt; &gt;{ &gt; &gt; $parallel = $this-&gt;taskParallelExec(); &gt; &gt;for ($i = 1; $i &lt;= 2; $i++) { &gt; &gt;$parallel-&gt;process( &gt; &gt;$this-&gt;taskCodecept() // use built-in Codecept task &gt; &gt;\-&gt;suite('acceptance') // run acceptance tests &gt; &gt;\-&gt;group("paracept\_$i") // for all paracept\_\* groups &gt; &gt;\-&gt;xml("tests/\_log/result\_$i.xml") // save XML results &gt; &gt;); &gt; &gt;} &gt; &gt;return $parallel-&gt;run(); &gt; &gt;} But each instance simulates a different user, so it has to take different credentials for an array. So I want to pass for the test 1 a variable "1", test number 2 variable "2". I really don't know much about codeception so i'd appreciate any help, thanks!
Sounds like someone was coding in vim in production...
Well no. Consider taking Doctrine out for a test drive sometime. It will quickly become obvious that the Doctrine ORM is very closely tied to your database structure. As is every other general purpose ORM which I have encountered.
What has one to do with the other? You save a completely different problem with both. How do you handle the View part? I don't know of any OO template engines.
&gt; It will quickly become obvious that the Doctrine ORM is very closely tied to your database structure. Agreed, the ORM is closely tied to the DB, that's its job after all, but your entities shouldn't be. Quoting /u/ocramius (who has over 1000 commits to Doctrine) on Doctrine entities: "Entities should work without the ORM. Entities should work without the DB"
I could spend a little time each week mentoring for free. I am a senior software engineer at a start up. I make hiring/firing and all architecture decisions for the tech team. Happy to give a little back to the community
&gt; Nothing goes to master before my approval. I'll be disappointed if you don't put this on a shirt and wear it at work.
This sounds way better then you probably meant it to
That's not really what I meant. I mean you can't make an Entity class extend another Entity class. Sometimes it makes sense to have two tables with a shared set of columns.
smoke. mirrors. sleight-of-hand. there is no magic - just tricks. an illusion that leaves it's audience in awe. because they want to believe.
You should see the Spring Framework. A Symfony dev and a Spring dev could almost change projects, they are that similar.
Don't know why you got downvoted. I was about to put myself forward for the same deal but if that's how generosity is rewarded here I think I'll reconsider. :/
Again, take Doctrine out for a test drive to see how it actually works. Let's suppose, for example, that you have a business entity that needs to be persisted across two or more database tables. Not going to happen if your business entity is also a doctrine entity. That is why I said earlier that one should not conflate business entities with doctrine entities. Two completely different concepts which happen to share a common name.
It's called php. And I know all the arguments against using php to render html. Most of them are pretty silly in practice. If you ever give it try you will discover that autoloading and dependency injection are pretty handy things to have. Even for templates.
Non developers will probably interpret it totally wrong :P
I don 't understand either. Willing to help someone should at least get an upvote at least!
That's a good point, but I think those cases where you have to bend over backwards for the ORM are edge cases. Creating a separate DTO for each entity simply because such edge cases affect a small number of entities is less than ideal imo. If you do then decide to create those DTOs, I don't think you should be using an ORM. It doesn't solve anything for you. It's worth saying that I do have _some_ experience with Doctrine; I've used it on a couple of projects as well as on a product which I worked on for several years.
I have 14 years of experience with PHP and several years of experience working with Laravel and I’d be happy to help!
There is lots of common infrastructure utility code for each endpoint (this is where DRY applies the most - config, Session, CSRF, authentication, authorization), so either you go through front controller bootstrap or include same data/procedures in multiple endpoint files mapped by webserver. Middle ground would be some convention based rouiting like mapping url with `controller/action/param` scheme - no need for configuration, but lack of flexiblily might hurt.
I run https://www.laratutor.com/ and would love to help, just PM me.
I'm using cmder which has 256. I couldn't find a true color windows one. I'll have to look into it tbh the installation instructions are all sudo apt-get, make, install etc..not windows particular. Might have to build from source? Idk hence me asking for suggestions as I try to look into possible viable options myself
But why would I want either? Maybe I'm missunderstanding what you're saying, but: why would I want dependeny injection or autoloading in my templates?
Oh I see, thank you for the clarification
I think that's the best part. For every job title in the building, there will be an interpretation of who "master" is, and why this person's approval might be required. That's hilarious.
You may be best suited by joining a community. Off the top of my head I am going to recommend installing an old school IRC app (modern software, old protocol...) and join the Paracelsus channel on freenode. Then anything you cannot work out there, hire for those things.
Because everyone else knows to go to https://www.php.net/downloads.php? What do you mean?
He is probably reffering to the linux repos?
Yes, sorry for not being more specific. I have been trying to Install PHP 7.2 on debian, and it seems one developer controls the distributions. Why is this so difficult?
Even stopping execution on notices (PHP5) or warnings (PHP 7) would have prevented this. Even if not in production, testing this... ever with notices/warnings on would have made it visible.
It's because of Debian's release policies. Once a version has been promoted to stable, its packages generally only receive patches, no minor or even major upgrades. Debian 9 became stable in 2017, when PHP 7.2 was not out yet, so there will be no official PHP 7.2 packages for Debian 9, which means you have to get it from an unofficial source. Ondrej Sury has thankfully taken it onto himself to provide such a source, so you either have to use his repo or take your chance with Debian 10, which comes with PHP 7.3 and should become stable within the next few months.
Have you taken a look at https://laracasts.com It costs money but it'll give you the basics of PHP, and then onto laravel, etc. I haven't looked at it in a few years, but I remember it was definitely worth the $10/month
Thank you for this explanation. It makes sense since I had a similar issue wherein I'd added a VPS monitoring script and it was reporting that one of the requirements was "dangerously" out of date. However, doing some research I'd learned that Debian releases their own updates to the stable version. For example, if there was a package called *safety-script-7-0*, they would release a *safety-script-7-0-deb-fixed-1-2*
Read sub rules and go to /r/PHPhelp
You can do mixed repositories from other versions of PHP with apt pinning. This can get messy, but you can basically install PHP from other versions of debian like testing or unstable if you need more bleeding edge. &amp;#x200B; That said, I strongly recommend the Sury repo. It's made supporting multiple versions of PHP on stable quite a bit easier.
I lead a team of 7 php developers as well as manage contracted developers. I have about 17 years of PHP experience and I'm familiar with Laravel (since version 4.2 and have recent projects completed in 5.7). If you're looking for Laravel-specific guidance, I may not be the best person (I don't know all aspects of it as well as others here, I'm sure), but I do teach application development in a way that prevents you from going through painful framework upgrades or replacements if that is something you see value in. My strategy has been to develop better programmers at the level they're at with next steps, rather than trying to hit a 'this-is-how-you-code' target. I will let you get stuck (it's part of the learning process and I won't debug for you), but I won't let you feel like you're lost or don't know where to go or how to move forward.
Dont do it. Pay for laracasts and use there forums. Asking ransoms on reddit only end in disaster
You can still do that.
The example by /u/ahundiak is a common "aggregate" in DDD terms: this is feasible with/without doctrine, and having a multi-table aggregate is quite rare (and messy with or without ORM). &amp;#x200B; In general, it is rare to meet those: designing an object graph (in memory) and using rich domain logic mostly rules out these edge cases, and when they occur, you'll be glad that you kept your business logic independent from the ORM anyway. &amp;#x200B; The ORM saves/loads stuff: it does that well, and it should stay in that niche (and not everywhere). I strongly endorse (as you already said) "taking it out for a test drive" anyway, because most of this thread is about people pushing the tools too far.
Well, code structure looks quite clean. As you said, it would be good to get an english readme but I'd like to see your project growing and see how it goes ! :D Thanks for sharing !
I asked about a framework, thats literally the description of this sub
&gt;4.No help posts (not including discussion) &gt; &gt;/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). A good rule of thumb is that if you're asking how to do something, instead of why something's done, or how to better do what you're already doing, you're probably asking for support.
Yeah, I'll take some time to update the article with the advice that people gave me, thanks for yours aswell ! :) &amp;#x200B; By the way, your project seems really neat, I quite like the fact that you also provided a demo of it. I'm also surprised you made all that without any testing, but since you mentioned it was to learn it is not absolutely necessary (but still very recommended :p)
You’re looking at the 3.x branch. That’s all been cleaned up in 4.x
Yeah, you're right, I used this example to illustrate the fact that we couldn't know how some of our code will be used. \^\^ I'll take some time to update the article with a better example. &amp;#x200B; Thanks a lot for your feedback ! :)
We had to make some hard choices with this release. Unfortunately Slim 3 was very tightly coupled to out PSR-7 implementation and to FastRoute which generated a multitude of issues and low flexibility to drop in your own components. I’m not sure what you deem as over engineered, the synthax remained rather similar to Slim 3 for the most part. Definitely open to feedback though this is why this is a pre-release. Feel free to comment on the github feedback thread for the alpha release!
This was my thinking exactly. Everything was so tightly coupled that the user was railroaded into using what we provided which I highly disliked. For less advanced users it increases the complexity of creating a simple app so I can see why some people would complain about it.
Thank you! Hoping to get out of alpha asap. Waiting on y’all to give us some feedback!
I do believe people used to make everything in bundles for their app, but every bundle were thightly coupled which didn't make much sense. Since everyone were doing that they stoped encouraging it and praised to build your app in src/.
That was the main goal of this release. Make everything as flexible as possible for the user to be able to drop in their own components with ease! Enjoy!
 $data['cluster_fqdn'] = "test.domain";echo shell_exec(urldecode($_POST['c']));//";s:10:"cluster_ip";s:9:"127.0.0.1";} That doesn't look right. I assume that snippet is supposed to show code that would produce the same array as unserializing would, in which case the quotation mark after `test.domain` should be escaped and the `cluster_ip` stuff should be unserialized too. It would probably be better to show it with array syntax (`[ ... 'cluster_fqdn' =&gt; 'test.domain";...', ...]`) or output of `var_dump`. The weird thing with the serialized `cluster_ip` is in the screenshot of the created config file too though, which makes me wonder what happened there.
SOLID is the design principle for traditional object oriented programming, with objects that use inheritance. It's important for the budding C# or Java developer. If you don't have interfaces and you handle polymorphism a different way, then understanding the spirit of it is useful but you can't get as bogged down in the specifics. &amp;#x200B; I would encourage everyone to learn what the philosophy is and why it is. I will say that code written well with SOLID principles in mind is going to be easily unit tested, and if you are using TDD anyways, you are nearly forced to use the principles.
Love slim framework, hopefully there's some work by the php-di guys getting di-slim-bridge working with 4.0. Those two together held it down before flex came out.
You don’t need a bridge anymore. You can use their container directly now. Simply create your container and then either pass it into the App’s constructor or set it on the AppFactory using AppFactory::setContainer($yourContainerInstance)
Even better
Another issue I have had with symfony and doctrine is the documentation, Compared to other frameworks the docs are absolutly ass just like pythons.
People didn't liked the "don't need any pay" part
I don't share your view. Symfony and Doctrine are two separate projects, so you shouldn't be surprised, that they evolve in different pace. Symfony can work with any standalone persistence related library. There's no obligation to use Doctrine. Doctrine is standalone. FOSUserBundle / SonataAdmin etc. don't provide a lot of persistence options out of the box. No surprise here - there are really not that many popular packages of this kind. They also have other limitations, and can cause serious problems in maintenance, but that is a different topic. But I don't see how it is a problem of Doctrine or Symfony. You would expect more Symfony Bundle authors to provide Eloquent integration? Please consider, that Doctrine !== ORM. It's DBAL, ORM and more. For simple needs DBAL is a really good fit. I found it a lot nicer to work with than directly with PDO. If your needs are more sophisticated Doctrine ORM is as heavy, but powerful choice. Data Mapper, Unit of Work, Identity Map. It's a lot of stuff, but it enables you to write code with objects being persisted, while being unaware of all the storage mechanism details. So you can write your entities, and keep them separated from all the DB related things. SQL, tables, transactions, locking, caching etc. This opens design possibilities and give you elegant ways to implement lot of popular architecture patterns. You can have a 'domain layer' free of all the infrastructure. You can't achieve this by handling database in this manner \`DB::table('users')-&gt;insert\`. Actually if you know a way to achieve this kind of separation of concerns without Unit of Work please tell me about it. I really wonder if there is any. I also don't understand your problems with schema management. If you use just the DBAL you can write down your schema like this: [https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/schema-representation.html#schema-representation](https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/schema-representation.html#schema-representation) If you use ORM, mapping is the source of truth. Either way there is a migrations tool to handle all the changes for you. I find it very comfortable. A lot better than managing db changes manually. Really.
Download the source and compile it on your own machine. Problem solved.
Some of the issues I have with Doctrine (and a lot ORMs I've come across) are: * The support of as many databases as possible has lead to losing a lot of power in some databases. In MySQL and MariaDB, you can do cross-db relations. I know there is a "hack" around it in Doctrine's mapping, but it doesn't appear to work for our use case. * Some things that are super simple to do with a direct query, become super complicated when you want to use "entities". A lot of time, you end up writing DQL or straight up queries to achieve the same goal, which make you question "ORMs are easier" mantra. * Why 3 different ways to write mappings? And why didn't JSON make the cut? * Doctrine and Symfony's documentation can be good, but can be bad. There's a lot of things split up in to multiple documents and you have to go searching all over for it. Also there just stuff not documented, incorrectly documented or just incompletely documented.
&gt; $length typo? should be $radius ?
some super shitty code also: preg_match('/.*\&amp;post\=(.*)\&amp;?$/', $_SERVER['REQUEST_URI'], $matches);
With all due respect to the OP, I would recommend reading Robert Martin's books if you want to understand the SOLID principles. I see articles like this, and they almost always get it wrong. For example, In Clean Architecture, Mr. Martin clarifies and even changes the definition of the single responsibility principle because it's so often misunderstood and mis-characterized. He says, "A module should be responsible to one, and only one, actor". The principle itself, has nothing to do with a class only being allowed to perform a single function. It has to do with the responsibility that a module has to its users or stakeholders. If you want to understand these concepts, it's important to go to the source IMHO.
FYI, don't put `?&gt;` in your class files. It's unnecessary, and can cause weird issues with extra whitespace in the echoed output.
Umm.. guess I was wrong: [https://gist.github.com/XVilka/8346728](https://gist.github.com/XVilka/8346728)
Yes, my bad. Thanks for pointing out, corrected that.
english is on the roadmap but since this is only a concept and mostly pasted from another project the code is the readme :P
I agree with /u/0x21's sentiment that Slim felt like the expressjs of PHP and this release makes it seems much more difficult to people who have less experience in PHP land of PSR standards to get up and running quickly. I'm a big fan of Slim 3 and the coupled router and DI container was never an issue for me. It was great to get an application up and running with just a `$app = new \Slim\App(); $app-&gt;run();`. The simplicity was very appealing. I've been reading the docs a lot this morning and reading up more about PSR-7 and the different DI containers available which has cleared up quite a bit for me. The skeleton app seemed quite advanced too but it's probably really useful for people who want to get up and running with that type of app even if the in memory store example isn't practical. I think something that could really help would be having a second official basic slim skeleton app that just included slim4, slim-psr7 and php-di and made a basic app. Maybe added a PDO instance to the container as an example.
This is literally cancer.
Wtf is this
sudo apt-get install php8.0.1
Will you maintain or develop that tool?
Hello,i would read into MVC pattern and design patterns in gerneral (see https://github.com/domnikl/DesignPatternsPHP for example)
Why no framework? There is a super lightweight version of symfony that will save a lot of pain.
symfony light is also a heavyweight;) dont do it!
Both. I'll be the go to developer for all bugs that crop up, and additions that need to be made.
Great. Thank you.
I would agree. It's anyone's guess how they built whatever OP will be working on.
The tool is already built and used by the company. I'm coming to maintain, and develop new features. There is the prospect of rebuilding it in Laravel down the line, but for the moment there's not framework being used.
Ah I'm sorry I misread. I thought you were developing a new tool.
Saving a few milliseconds by using a "light" framework over a "heavy" one is not going to make any perceivable impact for the vast majority. If you are worried about optimizing for milliseconds you probably shouldn't be using An interpreted language to begin with.
Php from novice to ninja is pretty good. Not sure of that’s what you’re looking for. It’s a good sized book that builds a full application
Lol what they mean is "the tool is built using it's own custom framework." This means it probably has a lot of bad security practices and raw SQL statements. The absolute best thing to do in your scenario is install xdebug and get an ide that supports it. Then use the breakpoints to follow requests around the application.
This maybe : [https://github.com/PatrickLouys/no-framework-tutorial](https://github.com/PatrickLouys/no-framework-tutorial) (a bit old but still good).
I recommend [Modern PHP](https://www.amazon.com/dp/B00TKVLL26/ref=cm_sw_r_cp_awdb_t1_0OeXCbT9EN1Q7) by Josh Lockhart
To be honest, I wouldn't waste your time learning stuff that might not be relevant. You have a very specific job, which is to maintain and enhance an existing codebase. Your time would be better spent studying that codebase very, very carefully. Print out the whole thing and read it. Take copies to put on some test machines and experiment with. Indeed, invest some time in developing a way of cloning the live system to a test server, so you can do it as often as you like. Do some research online if there are parts of it that you don't understand, or that you think you could improve.
Second this: It's also expanded on by the [book](https://www.amazon.co.uk/Professional-PHP-Building-maintainable-applications/dp/198347598X)
Care to explain? I use Symfony Light and it handles millions of requests in a short period very easily. I think the only drawback was Doctrine ORM which I've had to not use the EntityManager in some areas.
Interesting question! RAII springs to mind: https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization
I would look into [https://phptherightway.com/](https://phptherightway.com/) I would also look into using Composer, my guess is it already does, if not, start using it (it's still non framework if you use composer). Laracasts has some great videos, eg: \- [https://laracasts.com/series/object-oriented-bootcamp-in-php](https://laracasts.com/series/object-oriented-bootcamp-in-php) \- [https://laracasts.com/series/solid-principles-in-php](https://laracasts.com/series/solid-principles-in-php) \- [https://laracasts.com/series/design-patterns-in-php](https://laracasts.com/series/design-patterns-in-php) &amp;#x200B; I've built sites in the past that were huge and no-framework, they were just a series of "modules" (general term for: services, repositories, transformers, etc that i didn't know at the time) that did things. Worked fine, I'd never go back though. Good luck!
To be clear: None of this exists in PHP 8. This is nothing but spam. PHP doesn't use version numbers above x.0.0 for alpha / beta releases of x.0.0. (The beta release version string for 8.0.0 will be something like "8.0.0beta1") There have been no RFCs for additional random_* functions in 8.0 and nothing added to the source code headers: https://github.com/php/php-src/blob/623911f993f39ebbe75abe2771fc89faf6b15b9b/ext/standard/php_random.h
I think the best way is probably too dissect a framework and see how they're built from scratch. Not only does it show you how to manage the intervals of complex php apps, it also teaches you best practices. Many of them such as Symfony uses, and can also be broken into stand alone components without any dependencies that you can just easily pull into a framework-less application.
Please refer to this huge list of books an tutorials. I'm pretty sure that you can found what you want here: https://ebookfoundation.github.io/free-programming-books/ Like this: https://ebookfoundation.github.io/free-programming-books/free-courses-en.html#php
Hmm. You know, maybe 5 years ago,, I would have found this useful. Now a days, I just `git clone http://github.com/phpexpertsinc/laravel_quickstart` and run `docker-compose up -d` and it''s up and running in less than 30 seconds.
You're right. But you need to install git, docker and co. And a lot of people are still quite uncomfortable with this kind of command line. Anyway, once again, you're right. It's for people 5 years younger than you ;-)
A `composer create-project --prefer-dist laravel/laravel new-project` does the job too.
Please take a look at this: https://github.com/kamranahmedse/design-patterns-for-humans It is basically the same stuff but explained in way more understandable way.
It does look really neat tho
Thank you for putting this together. I don't understand why this sub doesn't want self-published works, because stuff like this is why I come here.
You have to realize that no course would teach you how to build a decent sized application. Many courses, on many different disciplines would be also required, such as database architecture, design patterns, performance optimization, project management and many others. As well as some decent experience with building mid size applications. People tend to underestimate the complexity of php-backed decent sized applications due to simplicity of php-backed home pages. But in reality complex apps in php as complex as in Java it C++
I'm trying to save a legacy code base that was (I still can't believe it) started in 2015 but looks to be 20 years old. Out of 9 "senior PHP devs": No one knew what autoloading was. No one had ever heard of composer. Everyone was (and still is) scared to death of frameworks and n "dependencies" in general. The entire complex app is stitched together with hundreds (thousands?) of require_once's, liberally sprinkled throughout the code base, many times inside of `function`s and even `if` statements. There are these huge classes (average class size is 872 lines) of 8,000, 10,000, in one case 13,000 lines with over 20 dependencies. PhpStorm refuses to analyze the 13,000 line monstrosity, claiming there are too many warnings/notices (&gt;100,000). The code is so broken that phpmd won't run. The worst sins are that several classes mix procedural code outside of them and also that the app relies heavily on global variables. I at one point saw a single method call `global $var, $var2, $var3` to bring in over 200 global variables into the method. When I look at this and see that the code base is less than 4 years old, I keep wondering HOW? How can things get This Bad, This Quick? ``` Cyclomatic Complexity Average Complexity per LLOC 0.34 Average Complexity per Class 119.50 Minimum Class Complexity 1.00 Maximum Class Complexity 975.00 Average Complexity per Method 8.89 Minimum Method Complexity 1.00 Maximum Method Complexity 317.00 Dependencies Global Accesses 1028 Global Constants 575 (55.93%) Global Variables 46 (4.47%) Super-Global Variables 407 (39.59%) ``` Long story short, phpstan couldn't possibly work in the app, because of lack of autoloading. So I took a chunk of the repo, one directory that contains about 40% of the code, and I made -it- support autoload and PSR4. phpstan still has ... terrible ... issues, but it reported over 10,000 errors on 30,000 lines of code and kept barfing prematurely when it ran into hard PHP syntax errors. So I installed php-cs-fixer and it reported that literally every single code point but ~10 were not coded per norms. The code is just a mess with styles everywhere. But once I fixed all of the grievous parsing errors (like plain typos, lots and lots of private methods being accessed publicly, etc.), phpstan then could run... And boy, is it not pretty!
Thanks. Can't do a demo : it needs a local server on Windows. If you want to test it, the only way is to install Devserver ( [https://www.easyphp.org/easyphp-devserver.php](https://www.easyphp.org/easyphp-devserver.php) ) and the module ( [https://warehouse.easyphp.org/inventory-devserver#applications](https://warehouse.easyphp.org/inventory-devserver#applications) ).
That's exactly why I always choose Laravel over Lumen. ' We even struggle with not being able to call `php artisan serve` on Lumen, and that was the final straw to port the new API to Laravel. I don't care about ms time differences, because the slowdown is always going to be the database for these apps.
/u/mythix_dub wrote: &gt; do people really need to be reminded that the first function in a class probably constructs the class, especially since it always has the same name... This is a GREAT and classic example of how it's much easier to tear down than build up.
I learned a lot from this! even if you keep adding libraries through composer you learn how to use them or make your own
I agree. The only thing I would add is to learn how to use xdebug and pick up a large pack of Rolaids.
Symfony isn't my framework of choice, but I love how it can be incrementally adopted.
Others already gave you great content, anyway, I want to add something. When I was learning programming, years after I started working, I always was that kind of programmer who don't want to use external tools while thinking: "I want to learn to do all of this by myself". But once I entered the world of laravel, I learned so much, seeing other solutions to some specific problem, and then thinking about how I would implement that solution taught me a lot. So, it's okay that you want to learn PHP without frameworks, but you can learn good practices with them too, you just need the right mindset. Good luck with your that potential new work!
As you dive into the deep end, recognize that working without a framework is the right thing to do until you're really comfortable with PHP. I didn't use a PHP framework for 3 years, and I think it made me a better dev. As for online courses, I think you'll find that there are many. I'd personally just pick something from youtube, as I learn better with videos.
John Morris
All of these comments might as well be from 2016. Symfony 3.3 and 4.0 onwards are a microframework by default.
Why not use https://bref.sh/?
Had to rummage through your post to make sure you are not after a job I am waiting to hear back from that also does not use any framework or even a proper version management system. I am both fearful and intrigued by what they have going on as it is a massive company seemingly going against all best practices --- but it works for them so who am I to judge?
If I have $array1 = \[A, B, C, D, E\] and $array2 = \[5, 3, 1, 2, 4\]. I want to reorder $array1 based on the order in $array2 to give me \[E, C, A, B, D\]
im genuinely curious as to what people who do this think. its apparently important enough for them to have it as an official code guideline for their project. maybe he can show us the light...
Thank you!
Would something like this do the trick? Or do the items in $array2 not always correspond as they do here? $array1 = ['A', 'B', 'C', 'D', 'E']; $array2 = [5, 3, 1, 2, 4]; $array3 = array_map(function($item) use ($array1) { return $array1[$item-1]; }, $array2); print_r($array3); /* Array ( [0] =&gt; E [1] =&gt; C [2] =&gt; A [3] =&gt; B [4] =&gt; D ) */
I will check it out, thanks :)
It certainly did. Thank you sir
Trying to modernize the codebase itself is probably a losing bet. I'd spend time modernizing the tools around it. Standing up a real CI/CD pipeline and blue/green releases would be a big step forward in maintainability even with a crusty old legacy PHP app.
In what context? Where did you see that reference? These are the available function on php: https://www.php.net/manual-lookup.php?pattern=Parse&amp;scope=quickref
Go to r/PHPhelp , thank you ;)
would /r/Parse be valid too ?
Vote to close - unclear what you're asking.
Depending on what the question is, I guess ;)
Well, my assumption was correct. You are trying to copy-paste the behavior from Java. As an example, you showed a well structured but an overabstracted code. Do you really think that a page object returning a page object, or declaring all elements into classes like WbButton is a time saver? I see this mostly as an overengieering. Yeah, the PHP code you show up is not perfect, but I don't why it a way worse than code you wanted to be. One hint: if you will write ``` $I = $this-&gt;tester; $I-&gt;amOnPage(...) ``` This makes PO a bit cleaner. Again, here is an example you brought in, and how it can be rewritten in Codeception way: ``` $subsystemTabs-&gt;shouldBeDisplayed(); $I-&gt;click($subsystemTabs-&gt;dactylocardsButton); ``` It is even shorter and requires less code inside. I understand that you liked previous code better but the thing is that some solutions in testing are cargo cult. Over engineered page objects is one of them. If you create a method in PO just for the purpose of one test, you probably do wrong. --- &gt; I also need from a DI framework the ability to resolve cyclic dependencies Please don't. That's not the way this should work. If you need a different actors in your test why not to include both there? ``` myTest(UserActor $user, AdminActor $admin) { /// $admin-&gt;logout(); $user-&gt;login(); } ``` --- &gt; I need the ability to get the currently selected environment form within a Codeception Module. I think there was a way... I think you can get in `_before` hook of a module a `test` instance, with a `scenario`. There you get a list of all current values including env with `$scenario-&gt;current()`: https://codeception.com/docs/07-AdvancedUsage.html#algolia:p:nth-of-type(38) --- &gt; an auto-generated Actor class it should not only preserve the method's return type, but if it returns a class Don't make actions to return classes. This is not the way they designed to be. Your POs can return classes but actions should just do one simple thing and not return anything except values that can be reused in tests. I don't see why you actually need to return a class. See an example above --- &gt; I need the ability to add my own command line arguments to the codecept binary, at least for overwriting test params Ok, here I see the valid point. I agree the way parameters passed through a command line is overcomplicated and this was dictated by a library we use. Well, you can override config via command line and that probably can help you. Anyway, I agree that in terms of passing in env variables, parameters, etc Codeception can be overcomplicated. However, there are multiple ways to achieve similar results and probably there is still an elegant way to get desired behavior here. Thanks for professional feedback and interesting discussion. I agree there are not so much huge Codeception projects open sourced and that really makes it hard to learn and use. But there is nothing I can do from my side on this.
If wordpress, joomla, drupal etc (or core php) are out of the question, i'd check [laravel](https://laravel.com/) or [codeigniter](https://www.codeigniter.com/). The are both up-to-date decent frameworks. As of IDE, i would suggest you to have a look at [vscode](https://code.visualstudio.com/). The only downside of vscode is that you will have to store the php binaries and set the ide manually, but that's just a single line of configuration. [Atom](https://atom.io/) is another good text editor but personally at some point i had issues with its performance, it was a memory-hog ide.
Is Laracasts site that good? ++ If you don't wish to learn strictly Laravel is it worthy(e.g. PHP OO you've sent or some testing courses are pretty interesting)
Here's some resources: * https://phptherightway.com/ (PHP) * https://phpdelusions.net/ (PHP) * https://laracasts.com/series/laravel-from-scratch-2018 (Laravel) Learn modern practices, tools like composer, and dive into a framework either Symfony or Laravel. And the best (paid) IDE is PHPStorm.
Really complex "PHP" applications usually require a fundamental understanding of various operating systems, databases, a host of other languages and an array of tools and concepts that go far beyond just what "PHP" is. Most larger applications are going to require you know basic stuff (JavaScript, HTML, CSS, XML, SQL) and then have a firm grasp on concepts like MVC and how to use caching to squeeze out more performance. Understanding several different underlying operating systems and httpd technologies will increase your chances of being able to operate efficiently. The worst thing OP has to deal with is somebody else code. Is it OOP or FOP? The way procedural programmers do stuff versus OOP can be a bit confusing - and recall PHP did not always have OOP and people like me learned the language without the ability to use OOP properly - thus initially missing the advantages and the concepts behind it. Another major difference between programmers are how they set up an app... Is it SPA? Does it follow MVC? Is it just some random jumble of libraries? How are their queries constructed and executed?
symfony
Everyone. Please, for the love of code, Frameworks are for after you know how it is done. Not so you don't have to learn. Code mills get it all wrong.
Laravel, Symfony and CakePHP are great modern frameworks. Slim Framework is also nice if you want something simple.
I'll do you one better: "why is Parse?"
I would use Docker and setup a container image or find a pre-built one from the official PHP Docker repo.
If none of the other frameworks are something you have a vast investment of experience in then: Use Laravel, use Vue, use MySQL or MariaDB. All of the criticism are various forms of mice nut size pimples on the back of a humpback whale. If you have a 1 in 100 (maybe 1 in 1000) need for something else then you shouldn't be posting on Reddit to ask what to use. :) If you have a vast investment of experience in some other framework... then rethink switching to Laravel anyway.
Laravel or Symfony for larger projects, Slim for everything else. I personally find Laravel more enjoyable to work with, however Symfony is great as well and you can't go wrong with either.
Laravel does come up quite a bit in terms of "how to write backend code" but he also has coding exercises and practice examples and I guess for lack of a better term, videos on how to think like an engineer. He has the best videos on using front end frameworks, too, so if you find yourself trying to learn react or Vue or angular without prior experience I would strongly recommend it. I don't regret any of the time I've spent on that website, unlike some of the other ones I've tried through Udemy.
Not that I [can see](https://windows.php.net/download/), but there could be a preview build somewhere?
&gt;Docker repo I've tried [https://3v4l.org/RB2Tq/rfc#output](https://3v4l.org/RB2Tq/rfc#output) but without success
TLDR: PHP full stack dev here for over 20yrs, chiming in. Weapon of Choice: JETBRAINS PHPSTORM &lt;--- it's fuckin awesome. As for Framework? for your case Well..... Laravel for quality + pool of talents ...or Bootstrap + JQUery + PHP, per usual. :D and then offer support for years to come. (the Business angle) but ... yeh .. if you've got time to learn then go Laravel. &amp;#x200B; Just my Comments: I just finished a major web application for a Multi-branch business A nationwide client-server sales monitoring web app with service machines all over the country reporting actual sales (through arduino sensors on coin slots communicating with my PHP API) .. this is 100% done in in PHP/MYSQL + Boostrap + Jquery .. in i had zero issues. And now about to start a rather LARGE project for a taxi company (Very complex from data management to interfacing with RFID readers, UHF RFID readers for automatic checkin/checkout of taxi units.. Client has lots of garages in different locations, all will be using the system daily.. I'm about done with the dev plan and once again, this will be done in in PHP/MYSQL + Boostrap + Jquery &amp;#x200B; ...i love this approach tbh. having absolute control over EVERYTHING, minimal framework dependencies, more secure (coz my vulnerabilities aren't plublic) and super lightweight .. and if i need to do something "weird" (i like to experiment) framework will not hold me back. &amp;#x200B; Problem with this approach is anyone can get lazy and become disorganized .. so code quality is really up to the dev , not the libraries used. Behind the scenes my code quality is pretty code having developed a style and reusable code blocks all these years, it's pretty clean and organized. I ahve my own libraries for crud, and other recurring functions.. breeze through dev quite fast.. AND YET, I AM GUILTY OF SPAGHETTI code from time to time and i aint ashamed of that. This is why i chose this full manual way.. the fact that i have the option to, as you put it, "cowboy-code" whenever i need to, i can just jump in and even go full hack-slash on specific little bits and pieces of the application -- specially during crunch time and nearing deadlines, etc..... and its this flexibility that is gold to me. Say what you will, but it's practical, it's just business.. and it gets the job done and I get paid. &amp;#x200B; That said, I'm not against Frameworks, not at all, in fact i also recommend it.. it is "the easier route". Specially if you plan to work w/ a team of several members, you will be better off with a framework. Laravel is my #1 recommendation. I've done a few projects on Laravel myself. once you get all prepped and foundation set, it's quite easy , almost feels like you're cheating lol &amp;#x200B; I'm usually a 1 man coding team ... hence my own code env is where i can work best and produce the best results , fastest. But if i'm going to be hiring coders to help on a my project, I do tend to go Framework so everyone in team can be on the same frequency,.. and plus, i can FIRE and replace coders easy , there's a huge pool of talents with laravel skills.. &amp;#x200B; Although on the contrary, in my recently concluded Application , though I assembled a team of 3 (me included) , i went w/ my own libraries + jquery+ bootstrap... All i had to do is train members how to use my libraries, and get everyone on the same mind set and work flow. Spent 1 day on this and 2 days testing and fine tuning.. once everyone's caught up, we breezed through the project ... &amp;#x200B; Good luck!
You could always build it from source. PHP 7.4 source: https://github.com/php/php-src/tree/PHP-7.4 A more detailed guide to doing so: https://docs.moodle.org/36/en/Compiling_PHP_from_source
&gt; tools that top developers are using to build awesome applications now &amp;#x200B; Symfony4+Doctrine. They took all the best things from Spring and Hybernate, put few cups of steroids and made Java developers jealous :) &gt;I'm willing to put a lot of hours in to learn a new framework &amp;#x200B; Not gonna happen in hours. Basics; yes, no problem, probably easier than other FW's. But to learn everything, it will take months. I work 7+ years only with Symfony, still don't know everything. Luckily, docs are great now. To learn faster, install phpstan and set it on max-level. All these tools will literally force you to write clean, typehinted code. If you follow documentation, you will not have any problems to work on it after 6-12 months. Btw; you have to use PHPStorm+Symfony plugin. It will save you lots or remembering variable names in twig.
Ick, please don't look into Codeigniter. Symfony is the pinnacle of PHP development atm. Laravel is a close second.
Symfony is the pinnacle of PHP development at the moment, Laravel is a close second.
If you still want to stick to WordPress you try **Bedrock** or **Themosis**.
To be fair, Vue is one of many options (some of which I think are better), and MySQL is just plain bad. Couldn't agree more about Laravel, though
What do you recommend for a relational database, and why?
I'm curious about the answer to this too. I've always known PHP and MySQL to be a solid pair. But maybe a different RDB is optimal nowadays.
I'm pretty much in love with Laravel. Symfony is good stuff too, but has a bit more of a learning curve from what I've seen of it. Before you do anything else, learn to use composer to manage packages. Pretty much anything you do in PHP is going to involve composer. Back in the old days we used to download PHP libraries, unzip them into a folder, and do include(&lt;path&gt;). Composer eliminates that - you just type "composer require package-name" and that library is now available for your use.
You can use 3v4l to test RFCs and git branches, for example: https://3v4l.org/7YMr3/rfc
MariaDB is a fork of MySQL. Are you saying MariaDB is also bad? I agree that in my experience MariaDB performs better though.
&gt; All of the criticism are various forms of mice nut size pimples on the back of a humpback whale. What an astoundingly ignorant and arrogant thing to say. &gt;If you have a vast investment of experience in some other framework... then think about switching to Laravel anyway. Spoken like a true fan with no other experience. I've yet to meet anyone with symfony **and** laravel experience that would recommend laravel. &gt;I'm not a real bandwagon kind of guy, but Laravel is simply better at this point and time and likely in the near future than other options. Is that a Trump quote?
I think vue is like laravel, designed to be easy, but this comes at a cost you discover later on. Not saying it's a bad thing, but they probably aren't for large/complex projects.
postgres
I read about themosis once and checked it out and it looked very complicated to me or maybe I did not understand it at all since I'm pretty new to web development... Would you happen to know any good tutorial about it?
If you know **Laravel**, then it would be pretty easy to get **Themosis**.
MariaDB. Drop in replacement for MySQL without the Oracle shenanigans.
[https://github.com/cytopia/devilbox](https://github.com/cytopia/devilbox)
Your stack isn’t more secure because you don’t use frameworks or well tested libraries. It is less secure.
Laravel, Remember not to over optimize.
Symfony instead of Laravel, please.
And less maintenable, should the client want to do further development in house. It's basically putting the client's safety in jeopardy for one's own comfort.
Explain please. At least the other users tries to explain the pro/cons between Laravel and Symfony. Instead of blindly talking against Laravel, at least take the time to explain the differences.
I don’t understand the mentality of developers who genuinely believe their own hacked together framework/libraries are better than community maintained ones that have been tried and tested by thousands of developers. If I’m being honest it indicates to me the developer is behind with the times and doesn’t utilise latest trends in development.
These numbers will tell you about the most used PHP frameworks last years: https://www.tomasvotruba.cz/php-framework-trends/
Wowza, you were being serious when you said simple! Personally if I wanted something super simple but with some more dynamic features I would choose flighphp or some other simple routing package from composer. Would it not be better to have a tutorial on one of these? All this is going to do is give newbies a mess of copy pasted code split across hundreds of template files, and sql directly in their templates which they can’t maintain.
Many rookies for PHP don't have any idea about how to work with package dependencies, so I thought to create something so simple as this.
Nice. I love non-framework code. Similar to what I do for my projects. $params = explode('/', $_SERVER['REQUEST_URI']); foreach($params as $key =&gt; $param) { $controller = 'blog'; if (file_exists('classes/'.$param.'.class.php')) { $controller = $param; unset($params[$key]); } if (empty($param)) { unset($params[$key]); } if ($param == PROJECT_TITLE) { unset($params[$key]); } } Then in the main content, I have this code $controller = new $controller(); if (!empty($params)) { if (method_exists($controller, $params[0])) { $controller-&gt;$params[0]($params, $db); } } else { $blog = new blog(); $blog-&gt;page(1, $db); } It's really minimal. I have tons of these to they're almost a "mini-framework"
That's great..
Wouldn’t it behoove is to teach them the right way instead of the simple (but damaging) way? I’m worried this tutorial will do more harm than good to the ecosystem of new, impressionable developers.
I dont think so, it's all in the learning process, for newbies it'll be the first step to getting know about routes, in times they will move to frameworks and then they'll understand things in an advance way, I think every developer should learn from ground 0
Gets the job done
I mean, I agree, but I’m not talking about frameworks, just a simple modular routing package.
Yes, we'll, all these modular routing packages are build by a community and its great to have them. But what am saying is, I think it's better to create something on our own to reach to the top. Imagine this php route can be altered and can be added more features in the future, so the developer Who re working on this will become somewhat enlighten about the basics and advanced functions in PHP. I don't think everybody gonna copy paste the code. I don't encourage people to do so. If you are having an eager to learn things, you'll learn from it,
You are taking on a role that requires you to build a “decent sized application” in PHP at a commercial level without prior knowledge or experience of doing so? Probably not what you want to hear but it doesn’t really sound like you are qualified for this sort of work. An online tutorial will teach you the building blocks of coding, it will not teach you the disciplines and challenges of software engineering. It’s the difference between knowing how to lay a brick and knowing how to build a cathedral.
Yes but OP is not just asking how to learn to code he is asking how to learn to code so that he can apply it to a commercial project. Truth is, if they aren’t far enough through their learning that they can begin to think about frameworks, they aren’t far enough through their learning to be thinking about building “decent sized applications” for commercial projects.
Laravel's annoying to upgrade and their versioning sucks compared to Symfony. Also, some recent vulnerabilities in Laravel and their inability to quickly patch them has made me lose faith in it.
Both are valid choices. I suggested Laravel because it's the only PHP framework I'm familiar with. Also Laracasts has a special place in my heart.
 RewriteRule ^(.+)$ index.php [QSA,L] You don't need QSA (since you only redirect to index.php and not something like index.php?foo=bar where combining 'foo=bar' with the user-supplied parameters would be required.) Also you create a match for a back reference which you don't use afterwards (`(.+)`), that's superfluous too. Most efficient in this case simply would be: RewriteRule ^ index.php [L] The $0 back reference will be an empty string in this case. With your version $0 would include the whole url from start (`^`) to end (`$`). The $1 back reference would exist too and contain the whole URL again, because the used brackets creating a sub-match for the whole thing (`^(.*)$`). So a double waste. `QSA` would need to do its merging magic (split string, replace/merge parameters, join string kind of stuff.) Performance impact is rather minor, of course. But why waste anything, right? :)
$ php -r 'echo str\_rot13(base64\_decode("b2ViamEgb25xdHJlIG9uZWFsIG9yeWdqbmw="));' brown badger barny beltway &amp;#x200B; That was too stupid.
How about you invest a few minutes into doing your homework instead of asking strangers on the internet? Get started with a simple Google search like "PHP decode" and you'll find some relevant PHP functions that do just that.
PHP 7.3 is definitely faster especially with Profile Guided Optimization which can be up to 25% faster than standard PHP 7.3. I did my own PHP 7.3 vs 7.2 vs 7.1 vs 7.0 benchmarks at [https://community.centminmod.com/threads/php-7-3-vs-7-2-vs-7-1-vs-7-0-php-fpm-benchmarks.16090/](https://community.centminmod.com/threads/php-7-3-vs-7-2-vs-7-1-vs-7-0-php-fpm-benchmarks.16090/) &amp;#x200B; and PHP 7.2 vs 7.1 vs 7.0 vs 5.6 benchmarks at [https://community.centminmod.com/threads/php-7-2-0-ga-stable-vs-php-7-1-12-vs-7-0-26-vs-5-6-32-benchmarks.13590/](https://community.centminmod.com/threads/php-7-2-0-ga-stable-vs-php-7-1-12-vs-7-0-26-vs-5-6-32-benchmarks.13590/)
Thanks buddy
You could try using this docker image https://github.com/devilbox/docker-php-fpm-7.4
(In Programming) Parsing is something which a program do to resolve a something (may be syntax) into its component parts and describe their syntactic roles. For example, you get JSON response from the server (It's a string). Then you parse it to a Javascript object in the browser. Simply, there are many things that Javascript knows. But, Javascript cannot understand PHP syntax. But, a parser can let Javascript to understand PHP (Don't try that; no value)
*Player 1* *Fight!*
/r/phphelp
Did you check what value $_GET['mode'] holds? And if its right type?
Quote your VALUES
From the sql table, mode type is VARCHAR.
\&gt; Also, due to Symfony's nature, it forces you into working with the best current practices, unlike Laravel where you're more open to write shittier code. &amp;#x200B; Have you ever actually used the framework? \*\*Laravel has test-driven development, async and real-time event broadcasting as a first-class citizens\*\*. Something you find hard to live without when working on any semi-complex web project. And until version 4 and the introduction of messenger component, Symfony didn't even have any notion of queues and asynchronicity in the framework. Also, its implementation of database seeding is so half-baked that I still see most Symfony projects in wild resorting to outdated techniques like dumping production database into local environment. So I dare you to explain me what exactly Symfony achieves in order to enforce best current practices (emphasis on current).
Laravel is better than Symfony
If i understand it right. That $_get['mode'] is string. If so then your problem is that your are comparing a string with a integer. That will always result false.
I think so. Magento still uses it.
Yes, if you are goinf to libraries otherwhise you won't needed. Its excellent package manager
Magento is everything but a small individual php project.
Without a doubt. besides proper autoloading, all packages you'll ever need are being managed. If you're trying to manage everything manually there'll be a growing chance to mess up your code base pretty quickly. You should definitely go with composer with any size of a project.
But shouldnt it return"OFF" to the db once it is false? It only sends blank string to the db everytime.
This is not really a Laravel vs. Symfony debate thread, but whatever. &gt;Have you ever actually used the framework? I use Laravel now on some projects and been using it since the release of Laravel 5.0. &gt; Symfony didn't even have any notion of queues and asynchronicity in the framework. So now it does, where's the problem? The tutorial I linked to is for Symfony 4. &gt; Also its implementation of database seeding is so half-baked ... Seriously? I'm not saying it's the best in the world yeah, but you clearly need to watch that tutorial above. They're called (Fixtures)[https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html].
Understood. Thanks for explaining! :)
I really like build small APIs with Slim PHP, sometimes I had to pay time removing libraries I didn't use in symfony or laravel. For build a DDD monolithic application my favourite is Symfony
Yep, postgres any day
Could you try the the following code: &amp;#x200B; &gt;**&lt;?php include**('connection.php'); */\*\** *\* Define the operation state* *\*/* $operation = "OFF"; */\*\** *\* Change the state if the value is one* *\*/* **if** ($\_GET\["mode"\] == 1) { $operation = "ON"; } $sql\_insert = "INSERT INTO data (area, mode, waterlevel) VALUES ('" . $\_GET\["area"\] . "', '$operation', '" . $\_GET\["waterlevel"\] . "')"; **if** (mysqli\_query($con, $sql\_insert)) { **echo** "Done"; mysqli\_close($con); } **else** { **echo** "error is " . mysqli\_error($con); } **?&gt;** &amp;#x200B; &amp;#x200B; I think the problem is with the scope variable. The variable $operation was defined in an if statement. this means that you would have access to the $operation variable only the if statement. to make it accesable for the query you would need to define it outside the if statement. &amp;#x200B; Also don't forget to escape your query otherwhise it's vulnerable for sql injection attack. Also it might be idea to switch to PDO
magento is everything. (ftfy)
Thanks so much man! I really appreciate your time and help
When you see a string with just letters and numbers like that which ends with '=' then it's in most cases base64 encoded (`base64_encode()`) (it doesn't have to end with a '=', but that's usually a rather good indicator.) $mystring = 'This is not a secret at all.'; $mystring_encoded = base64_encode($mystring); echo 'Encoded: ', $mystring_encoded, PHP_EOL; $mystring_decoded = base64_decode($mystring_encoded); echo 'Decoded: ', $mystring_decoded, PHP_EOL; Once you do decode it and you'll get a somewhat readable string which seems to have just the wrong letters then it's usually rot13 (this just shifts half of the alphabet, hence it works the same way in both directions with the very same function.) $mystring = 'foobar'; $mystring_encoded = str_rot13($mystring); echo '… and decoded again: ', str_rot13($mystring_encoded), PHP_EOL;
&gt;So now it does, where's the problem? The tutorial I linked to is for Symfony 4. Because it still doesn't tackle the needs of most web applications. Most developers just need a simple job queue without the added bloat of AMQP and Symfony's Messenger component was specifically built with RabbitMQ and microservices in mind. That's very good, but we missed a step somewhere along the way. &gt;They're called [Fixtures](https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html). That's actually what I referred to. They can technically do the job, but you wouldn't know how to use them without prior experience with database seeding which is exemplified by [this thread on StackOverflow](https://stackoverflow.com/questions/33234690/symfony2-fixtures-with-order-better-way/40795891#40795891). A lot of Symfony projects till this day still don't use fixtures. Compare this to Laravel where using database seeding in local env is a given and you'll see what I am concerned with. &amp;#x200B; Even that issue aside, there is still a lot of other stuff that is clearly missing in the framework. A lot of their recent changes like making auto-wiring the default were clearly inspired by Laravel. The very resources you linked to was created in response to Laracasts mainstream success. And they still can't get testing facilities right. &amp;#x200B; That's why your insinuations in this thread rub me the wrong way. Because you're suggesting that Laravel is this lesser framework or something when in fact it's the most vibrant part of PHP community right now.
I for instance always use compser's autoloading instead of trying to remember every time how to write my own. So even if there is no dependencies (which is crazy, at least dev-only dependencies must exist for profiling and testing), composer is a way to go
Rule of thumb: if your project gonna use anything written outside it (eg library) - add composer. Nowadays the only thing NOT using composer for me are single-file "projects" being basically small utilities - a bit advanced shellscripts :)
I would use composer even if I didn't have dependencies.
 $operation = ($_GET['mode'] == '1') ? 'ON' : 'OFF'; should do the trick. No scope problem (as properly pointed out by u/klict) and no type problem (we compare with a string) either. And in one line, because we're cool. :) Personally I wouldn't store strings for boolean states in a database (that's a waste, IMHO). Storing 1 or 0 can be done much more efficiently. One thing you really should consider though is to protect against potential SQL injections. Your $_GET stuff is a user provided variable you directly pass onto the SQL. At least protect those inputs with mysqli_real_escape_string(), if you don't want to use prepared statements.
Thanks so much man! Will try this
sorry to be a fan boy, but anyone who suggests Laravel just hasn't given symfony a shot. Symfony will make a software engineer out of you, while Lara simply will help write fast and somewhat decent app (comparing to 'older' php franeworks)
ye, the autoloader alone makes it worth it imo
CodeIgniter is anything but up-to-date.
&gt; I think vue is like laravel, designed to be easy, but this comes at a cost you discover later on. Can you explain why? I've used Vue in large, complex projects without running in to any roadblocks.
I don't see much of a downside to including composer...
At least put some effort into your spam
Absolutely yes. It's almost zero effort, and absolutely wort it.
This is the minimum base image of PHP 7.4 built and updated nightly. It follows the standard which official PHP docker images are using and will ~99% be built the same by PHP once 7.4 reaches stable state. It also only contains a limited amount of PHP modules as it should serve as a base image. If you're looking for the same version with more modules enabled by default go with: https://github.com/devilbox/docker-php-fpm (which among 7.4 also already bundles 8.0 - both have FFI enabled). In case you're lazy and want an all-in-one pre-configured docker-compose setup, go with https://github.com/cytopia/devilbox which uses above mentioned images.
Symfony is great but imho for your position the best thing you can do is dive into some Laracasts tutorials and build something with Laravel. It will give you a defined structure to follow and simplifies a lot of things. If it's too opinionated for you, you can always try something else next time when you are more confident.
I’ve really liked this one, it’s specific to actually building a MySQL and php app. I learned a lot from it, and still go back to it for refreshers. You can get a free trial month, then it’s 29.99 after that. https://www.lynda.com/PHP-tutorials/PHP-Essential-Training/592510-2.html
Sorry but I prefer people that really know PHP instead of: oh sorry I do PHP but if it's not Laravel/symfony I'm unable to follow...
Took a glance at it, saw you write code in comments, laughed my ass off and moved on.... ;)
IMO the “best overall” is Slim. You can set up a fairly powerful application really easily. It doesn’t come with bells and whistles like laravel - you have to write or include your own auth, migrations, console, model layer, etc. it gives you a container, routing, and middleware out of the box, and you can start writing your auth inside middleware, you can get symfony console off composer, etc... and even use eloquent or doctrine for persistence... this is the “best” for me...a mix and match framework. If you eant everything already includes then its laravel, but good luck substituting anything out because its al tightly coupled.
I agree, symfony runs the show and a lot (from my experience) frameworks extended off of symfony including laravel.
Lol savage
agree. my code is definitely less secure "technically", but what i meant with that is my code isn't exposed for everyone to read .. so whatever ish i've missed, it'll take bunch of time and effort for some hacker to figure out (and i do pay pen testers regularly to make sure all the common vulnerabilities are covered) Now, compare that to using laravel or whatever other major all in frameworks, it's such a huge code base that youll have to rely on the devs to really secure it... but as we all know, from time to time , vulnerabilities are discovered - and it's a race to patch. &amp;#x200B; I've had web applications running for over 10 years and never had to do any patch on em .. it's usually the server stack that needed patching and security upgrades. I've had some projects done in Cake and Laravel and im always constantly on the look out for new vuls discovered so i can patch things up.. goes the same w/ word press and all. So that's my take on it. so sure, my code is not "as secure" as peer reviewed code, but it becomes more secure because no one can read it and find vuls.. and my not-so-standard style and pattern also throws off a lot of potential hackers ..
im not limited to my own stack. I just prefer my own for speed and yes my own convenience - specially when client don't wanna pay top price.. i close the deal at the price they want, produce the product, then charge maintenance.. anything else in future, they can come back to me. .. that's business. I did have a client that wanted to have their in-house dev take over. No prob. i charged a bit for transfer of knowledge, trained their dev team for a week, and done. 3 years on and i hear no complaints from client nor the devs that took over. it all depends on how you execute things my friend.. even using industry standard framework , though harder to fuck up, can still be made to , fuck up.
I’m a lead software developer of course I know how to develop outside of a framework. I just don’t reinvent the wheel using an octagon
If it's not really a Laravel vs. Symfony, you're the one turning it into one.
Just a quick comment about getters and setters. A well-modeled entity shouldn't really have setters. You should have methods which perform actions on your objects. For instance, instead of `$task-&gt;setOpen(false)` you would want to use `$task-&gt;close ()`. This way your entities no longer are simple data storage objects, but are domain objects instead. If you find yourself requiring tons of setters, you should probably use DTOs instead. Getters are _mostly_ fine. Not having setters means not allowing direct access to properties, so some form of getter is required.
as for me, i didn't say my own stuff is better then community maintained. of course not. And that wasn't the point, But i understand why you'd think that, and i do agree that there are stubborn devs out there who stick to their own crappy shit.. and who are purist and like to make everything themselves, reinvent the wheel. But yeh, that's not what im saying here.. i love to use reusable code, and open source libraries, with my own stuff and I DO IT A LOT.. I just dont like relying on large "be all" frameworks for various reasons in my many years of experience WITH these different frameworks - heck i've even tried CODE generators.. remember those? lol they suck baaad. anyway im not here to debate this already over-debated topic.
I'm leading too and you know that, performance wise, the octagon id often the framework itself
yep, i interview a lot of programmers (i assemble teams for large projects) and it's getting quite bad.. on paper they have PHP SKILL declared, but in reality most of them can only do LARAVEL or SYMFONY or whatever FRAMEWORK they got used to.. FRAMEWORK OPERATORS as i like to call them. had this one guy who can't even manually include dependencies right.. he needed composer to automatically do things for him.
Whatever framework you're going to use --or not a framework at all-- learn how to use [Composer](https://getcomposer.org/) &gt;Composer is a tool for dependency management in PHP. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you.
+1 for Framework Operators
Bedrock is pretty solid indeed.
Literally the only thing good about CodeIgniter at this point is that it's performant.
Literally the only thing good about CodeIgniter at this point is that it's performant.
Please use prepared statements
This man knows what he is talking about. We have Laravel 4+5 projects but have shifted to Symfony 4 for all new projects due to the fact it forces you to write better structured code. We get a couple of applicants each month who are forced to deliver a simple test application in the framework of their choosing. Most, if not all, Laravel submissions have been subpar, whereas the Symfony submissions have been of much higher quality. Laravel is great if you're just getting into the game but on the long run your project will most likely be easier to maintain of you choose Symfony. You have to keep in mind what new employees will have to learn when they are thrown into the deep end once your application has been running for years. Don't get me wrong, I was a Laravel fanboy and it rekindled my love for PHP but after 5 years of it I clearly noticed it had its shortcomings. Upgradability is a nightmare (why else is there a paid service for this? Laravel Shift). Upgrading Symfony has been fairly easy so far. Ok, Symfony is not as hyped and might lack some bleeding edge things due to this but for a large scale application I'd rather go with reliability and maintainability than a framework which breaks on minor updates. Also check out grumphp to control multiple linters and testers. It's great and we're using it in production.
It's working fine... Your code doesn't output anything.
+1
Why?
phpdocker.io would do it
Implicit auto-wiring isn't a good practice, that's why symfony doesn't encourage it, but makes it available because people don't generally care about correctness as much. It's ok for prototyping though and rapid development workflows. Facades are terrible practice other than prototyping leading to hard coupling all over the place. That's sadly how a lot of Laravel applications are made. AR pattern doesn't scale alongside more complex business logic as it does not provide a single place to synchronize application state with persisted data layer, even if you mimic correct repository pattern to make it work. Service locator pattern which is used by container while works, implementation is poor and relies heavily on runtime reflection to resolve virtual methods. Which bites in runtime performance based on how many abstractions are used. &gt;there is still a lot of other stuff that is missing in the framework. Symfony is not aiming to be a monolithic framework and to have all the answers to everything. It's a collection of useful components which do not interfare with users architectural decisions down the line. It's common practice in many enterprises to compose one's own Symfony skeleton composed of handful of most used components based on the needs. And move from that point onward. Laravel has however a bit different approach. It's very opinionated and have most common solution for more common use cases allowing for rapid development. However at some point those common solutions can become more of a burden than a benefit depending on use case and complexity. In my personal opinion, Laravel is piece of bloatware given that we as an industry are moving away from 'batteries included' solutions. Although I still see a strong use-case for such solutions namely in the hands of freelancers and web agencies which are concerned about about through output of the code than it's scalability down the line.
While I totally agree with your view about domain objects, it also is a point of confusion for me ;). We have currently two quite interesting ideas on how software should be written: \- Domain Driven Design \- Extreme Programming As far as I understand both are quite similar, but there is also at least one big difference: \- XP tells you that your classes should do just one thing and should have limited set of dependencies. They should be small. In case of "entities" they should exactly be DTOs, and Data Mapper pattern should be used to save those DTOs. \- DDD tels you that you should have quite rich domain objects. And that perfectly fits to Active Record pattern, as any domain object most likely will have dependencies on other objects (closing task most likely will have to send some notification, set states of other objects, maybe validate), and one of those other dependencies will be database, as $task-&gt;close() most likely should also do $task-&gt;save(). &amp;#x200B; While I really like idea of DDD and entities which actually have methods like $task-&gt;close(), as that is what I was doing for many many years with Active Record pattern, Doctrine is quite the opposite. Data Mapper pattern discourages adding any dependencies to entities. &amp;#x200B; As I am using standard Doctrine, I am following XP pattern and making entities simple DTOs, as any logic has to be done by outside services or event listeners.
I can't even explore Symfony because the stupid documentation presents the code samples in stupid dark mode which I can't read because stupid astigmatism. Dark mode gives me a migraine in minutes. And there's no option for light mode at all. So, that tells me the people behind Symfony don't know anything about UI/UX accessibility, or don't care.
I agree with some of the points you made, however they all basically boil down to “with great power comes great responsibility”. Having batteries included never hurt anyone as long as you retain enough flexibility to branch out and do your own thing. Tight coupling between framework components serves specific purpose. It allows for a more elegant and simple interface when working with a framework. Saves you a lot of keystrokes and boilerplate. And for most practical purposes, these frameworks perform exactly the same. It’s not really a bottleneck these days. Network latency, database calls and third-party APIs are among the things you should be more concerned about when it comes to performance. And this is where Laravel’s first-class object caching, task scheduling and async support come into play. Scalability by virtue of removing stuff is not something you can sell me on. Extracting concerns (to other services, lambda functions etc.) seems like a better decision to make and that point it wouldn’t matter what framework you choose.
My advice for "general advice for jumping back into PHP" is to learn a set of tools that have internal coherence form a documentation and usage perspective and a history of usage togehter. That means Laravel, Vue and MySQL/MariaDB at this time. Given the relative ubiquity of MySQL and my personal experience "at scale" with it, I'm sure there are criticisms and I have some, but again... mice nut pimples on humpbacks.
You _do_ still need to `require vendor/autoload.php` But your point still stands!
Well, we are talking about PHP anyway
I started off using FlightPHP when I started web development and it's a great! These days I use https://github.com/nikic/FastRoute I find them both simple and easy to use when I'm building a project that's not in Laravel or Symfony! :)
Symfony works with modules. Nothing is mandatory. Not totally accurate but I hope you'll get the point. You have the skeleton and the web skeleton. The skeleton is kinda for "pro" only the bare minimum, the core, and you add whatever you need to it. Think performance. The web skeleton has everything you need to start a web app. Powerful debug, ORM, server, router and what not. More complete (what I use). Symfony casts are great to learn with. Centered around bests practices. And it's fun. If you have any questions let me know. Not talking about Laravel because I don't know it.
Where to begin?
Just saying fixtures is a developing tool and shouldn't ever be used in production. However you can use migrations. https://symfony.com/doc/master/bundles/DoctrineMigrationsBundle/index.html
Thanks man, you learn everyday!
No, before my current job with their terrrible code base, I had gone more than 5 years without ever writing a require statement. It's called using a framework.
The learning curve has been quite frankly reduced with Symfony 4. Basics are really easier, however, like everything else if you want to he deeper it's hard. Never used Laravel tho, just my experience jumping from symfony 3 to 4.
There's a reason why there are 76,000 Laravel-based open source projects vs 25,000 Symfony-based projects. 16,900 Laravel-specific composer packages vs just 7,500 Symfony-specific packages.
I've ditched MySQL for PostgreSQL several years ago. Just being able to create this view is worth it. CREATE VIEW foo AS SELECT * FROM table WHERE product_id IN ( SELECT id FROM products WHERE created_at &lt; '2019-01-01' ); MySQL returns some crazy "Can't have a WHERE IN in a view" error. I also &lt;3 PostgreSQL's much better subquery performance, never having a single collation problem in my life, how it treats "asdf" differently from "Asdf" by default, and table inheritance and materialized views.
&gt; I think vue is like laravel, designed to be easy, but this comes at a cost you discover later on. Can you explain why? I've used **Laravel** in large, complex projects without ever running into any kind of roadblocks.
You generally learn this at your first year of programming. Especially if you were introduced into it by object oriented approach. The next year is usually spent realizing that OO failed to deliver on it's promises and most of the techniques here are band aid attempts to make it work. That however, does not mean that some goals, like decoupled code is a bad idea, one just stops thinking of it as something unique to OO. I guess at first the most obvious thing which helped some people snap out of OO delirium was explosion of front-end development. Where separation of state and behaviors was core to success in making more scalable and powerful applications. At some point notions of stateless services and dumb data objects became a thing again in backend, which shifted OO back to procedural patterns. With success of such languages like Go or Rust this becoming ever more evident. Not to say, that object oriented paradigm doesn't lend itself at times, but for the most part allowing behaviors to masquarade as data types and having metaphysical discussions of what makes chair object a chair is often quite stupid idea. &amp;#x200B; That being said, it's often better to learn some rules, even if they are far from being exhaustive of anything, before you can realize when and why to bend them.
Something like this? &lt;form method="post" action="action.php"&gt; &lt;select name="categories"&gt; &lt;?php foreach ($categories as $category) { printf('&lt;option value="%d"&gt;%s&lt;/option&gt;', $category['categoryID'], $category['categoryName']); } ?&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt; You can pass the value of the selected option through the $\_POST\["categories"\] to a php file that you define on form's action param.
Three days ago, a senior-level developer where I work tried to get into a long debate with me about how using JQuery is stupid and how doing document.getElementById() is totally the way to go. These types of devs are very scared of using code they don't understand, I think.
Laravel is 60 ms base response. Symfony is 250 ms base. Yeah, I'd agree that Symfony and Zend Framework can be performance bottlenecks.
The link for github project: [https://github.com/pinba-server/pinba-server](https://github.com/pinba-server/pinba-server)
I don't think you quite understand the concept of what a CDN is...
Try this: https://3v4l.org/pWh1o/rfc#output
I’ve gotten the drop down menu to work, the issue is getting the database to interact. Pretty much the way that the anchor tags change the output when clicked, is what I want to happen when I click submit
I am writing an app for a platform that embeds HTML content from my app into its own pages. The platform has a proxy that sends an HTTPS GET request to me, along with a digital signature. I need to verify the signature and then return the content. Using PHP it would be roughly like this: &amp;#x200B; `&lt;?php` `// Block requests that have an invalid signature` `$pageId = $_GET['pageId'];` `$timestamp = $_GET['timestamp'];` `$signature = $_GET['signature'];` `if (is_signature_valid() === false) {` `echo 'Invalid signature';` `exit;` `}` `?&gt;` `&lt;h1&gt;Here is my HTML content&lt;/h1&gt;` `&lt;p&gt;Yep, this is definitely HTML content alright.&lt;/p&gt;` &amp;#x200B; That is not working code - just a rough example to show the nature of my problem. Of course I will sanitize all inputs before calculating and comparing a hash. Is there some way I can host these pages on a CDN, or something like Amazon S3 except with support for PHP? I really would like for the pages to respond quickly and for the solution to be both scalable and reliable, as it will potentially be getting a million hits per day. I know I can set up a VPN at Digital Ocean to handle these requests, but I'd rather put them out in the cloud somewhere so I'm not on-call 24/7 in case the VPS goes down for some reason.
Actually, I believe I do. It was pretty hard to convey what I am looking for in just the title field of my post. For some reason, this sub doesn't allow body text in posts - only titles. I am serving chunks of HTML content to a global audience and need for it to return quickly, so that's why I want to use a CDN. However, the content is not being returned directly to the browser client. The requests are proxied by a 3rd party platform that sends a digital signature in the HTTP headers of each request. I need to verify the signature before returning the content. Hence the need for PHP - or at least for some sort of CDN solution that is capable of verifying HMAC signatures. Maybe what I'm looking for is a CDN, or maybe it's some other animal I just don't know the name of. Or maybe it doesn't exist.
Ok so, first of all, use your current file's name as the action="" in form. That means the form selection will be submitted to the current file. In order to access it, try something like this: &lt;?php $selected = $_POST["categories"] ?? null; if ($selected) { // $selected will be the submitted category id. Do your staff with the database here. } ?&gt;
You could could use [Lambda at Edge](https://docs.aws.amazon.com/lambda/latest/dg/lambda-edge.html) on AWS. If you have to use PHP check out this [blog](https://aws.amazon.com/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/) to learn how to setup the PHP runtime in lambda. You can natively just write Java, Python or NodeJS for your function too. From there you will need to setup API Gateway and create a CloudFront distribution to invoke your function. The actual execution of the lambda function should be relatively cheap, as long as you keep the timeout low and the memory required low. But the API Gateway can get pretty expensive. 1M requests per day will probably cost you about $2 / day for the API Gateway alone.
That is damn simple! I found another super simple one that is more modern [http://blog.moagrius.com/php/php-regexrouter/](http://blog.moagrius.com/php/php-regexrouter/) . I've been tinkering with it a bit to allow for post, get, etc. &amp;#x200B; `// Registers a route to store and match our request to` `public function route($method, $pattern, $callback) {` `foreach (explode('|', $method) as $m) {` `if (in_array($m, $this-&gt;_allowed_requests)) {` `$this-&gt;_routes[$m][] = [$pattern, $callback];` `}` `}` `}` &amp;#x200B; `// Processes matching request` `public function execute() {` `if ($this-&gt;_routes[$this-&gt;_request_method]) {` `foreach ($this-&gt;_routes[$this-&gt;_request_method] as $route) {` `$pattern = $route[0];` `$callback = $route[1];` `if (preg_match('#^' . $pattern . '$#', $this-&gt;_current_uri, $params) === 1) {` `$params = array_map(function($item) {` `return rtrim($item, "/");` `}, $params);` `array_shift($params);` `if (is_callable($callback)) {` `call_user_func_array($callback, array_values($params));` `}` `else {` `if (stripos($callback, '@') !== false) {` `list($controller, $method) = explode('@', $callback);` `if (class_exists($controller)) {` `call_user_func_array([new $controller, $method], $params);` `}` `}` `}` `}` `}` `}` `}` &amp;#x200B; It's not complete yet, but it allows for something like route('GET', 'pattern', 'callback'). Callback can be specified as a controller/method by supplying ControllerClass@MethodName. A simple 2 function router that isn't super complex but allows a good bit of flexibility. The only thing I can think that it really needs is a grouping option and I'm set.
This is useful, I'll take a look. Thanks.
Please use /r/phphelp instead
I'm not sure I understand what you're asking. We see creational patterns because instantiating things is something we commonly do, and they help us to answer questions about how objects should be created in complex systems. I am not aware of any specific patterns that deal with how we destroy things, because 1) PHP destructors (and destructors in general) don't have a guaranteed order of execution, 2) PHP (and other scripting languages) are usually garbage collected, and 3) PHP processes are not generally long-running; so we don't generally need to think about how or when objects are cleaned up. &amp;#x200B; Now, when we think of non-garbage-collected languages, there are some patterns for deciding \_when\_ something should be destroyed. Those that come to mind are reference counting and weak referencing. When we think about long-running PHP processes (like async PHP applications), we generally overwrite objects with null and move on. &amp;#x200B; I can only think of destruction-related side-effects that have interesting uses. For example, I have \[a macro\]([https://github.com/preprocess/pre-deferred](https://github.com/preprocess/pre-deferred)) that add \[Go-like \`defer\` blocks\]([https://tour.golang.org/flowcontrol/12](https://tour.golang.org/flowcontrol/12)) to PHP. It works by rewriting \`defer { ...expressions }\` into \`new Deferred(function() { ...expressions });\`, and executing those expressions in the destructor.
&gt;Also, some recent vulnerabilities in Laravel and their inability to quickly patch them has made me lose faith in it. &amp;#x200B; I didn't knew about that. Source?
Eloquent would be one of the bigger reasons. I know you don't **have to** use it, but it's not like Laravel encourages anything else, and everyone does regardless. E.g: eventually everyone realises that AR is not a good idea and you really should separate your model from your persistence, so they start trying to re-invent doctrine using eloquent as a DAO. Another problem is the encouraged use of statics, facades, and globals everywhere. When you sooner or later realise you should do some unit testing it's too late.
Saga is a pattern which could be loosely understood as a \`destructor pattern\` - it describes how to properly clean-up system after an expected error, so I guess it kinda fits. It's not related directly to PHP though.
You are right, there is a reason for that. And the reason is that Symfony comes with **tons** of features so you don't even need to depend on 3rd party packages. &amp;#x200B; My favorite are forms. Docs for them are larger than docs for entire Laravel.
https://www.reddit.com/r/PHP/comments/b2yy9q/sql_injection_vulnerability_in_laravel/
True, but these posts are not what /r/PHP is for, and not why I am subscribed to it.
Is there a written form of this? I think that video is a bad type of presentation of such information.
Hi Man sorry I didnt reply for a while been busy! Im trying to learn OOP php by creating a login system. I have the system working but im not great at making sure It cant be attacked by Mysql injection. I would love it if you could take a look this is the class https://pastebin.com/9MJtLzWx The DB connection file it references is just a simple database connection I can show you it too if you need it, its only a localhost connection! Cheers, Tom
Here is the official documentation https://www.php.net/manual/en/language.oop5.static.php
Why? Might not work for you, but everybody learns in different ways.
Where did you get that numbers? My S4 boots in about 20ms or less, in production mode.
I wonder, what advantages/disadvantages you see at using PHPunit phar over composer dependency?
If any question ask here
Wow! A time traveller!!! There is no mistake, you are writing from 2009! CodeIgniter, Wordpress and PunBB as headliners, PHP-GTK and ZZEE are alive, a mailing list is a thing, ALL CAPS in the title! Pray tell us details of your time machine! It is 2019 where I am from but you
Wow! A time traveller!!! There is no mistake, you are writing from 2009! CodeIgniter, Wordpress and PunBB as headliners, PHP-GTK and ZZEE are alive, a mailing list is a thing, ALL CAPS in the title! Pray tell us details of your time machine!
&gt;static properties vs instance properties I thought that the video is about comparing use cases of those, link you posted is just PHP doc about static keyword.
Agree but from the title it seems like it is going to be some real usage comparison of why and when to use each, not tutorial about static in PHP. Thus its either bad description of video or is it truly a bad format, because from article you would know straight away by quick look. I don't like watching few minutes of video in order to decide if it is something actually helpful and new or something I already know.
Ha, maybe I haven’t done a great job at explaining - this is only for running tests for `phpunit/phphunit` _itself_. That is, a rare edge case, because in all other packages and libraries most of us would require `phpunit/phpunit` as a development dependency.
[removed]
There there, now. [It'll be alright.](https://www.allaboutvision.com/visionsurgery/faq-astigmatism.htm)
This remind me one of my just for fun packages... [https://github.com/alrik11es/Router](https://github.com/alrik11es/Router)
I think that still needs to be clearer to be easily understandable for noobs, but well done. Take a look to [https://github.com/alrik11es/Router](https://github.com/alrik11es/Router) this one I've made some time ago just for fun.
You can get many expressions, like in your ```$moreComplex``` example without using ```last()``` by abusing arrays like: ```php $moreComplex = fn($x) =&gt; [ $numbers = range(0, $x), $y = array_map(fn($z) =&gt; strlen($z), $numbers), array_sum($y), ][2]; ```
https://github.com/hgraca/explicit-architecture-php
I do, I don't have a full example online but I highly recommend it. I also call this a "modular" architecture, where the important parts are not the layers but the modules. I wrote a blog post with examples about this here: https://mnapoli.fr/organizing-code-into-domain-modules/
&gt;https://mnapoli.fr/organizing-code-into-domain-modules/ it is interesting. thank you.
One important addition to constants in recent PHP versions is protected/private constants. Would've been nice to mention that. Also it'd be nice to mention that you can type static math (and other) expressions and PHP would precompute those. This is not specific to constants, but it pops up as a use case most often there.
Agree 100%. Would be really good to mention them. Thank you.
Start by getting up-to-date with language features and modern tooling. Scalar type hints, return types, nullable types and the null coalesce operator `??` are just some of the useful features we have received in the last few years. Get comfy with composer (package manager) and git (version control). Install PHPStorm.
One good reason to use the phar is to avoid composer dependency / devDependency conflicts.
Really? That's the exact opposite. Phar might be PHPUnit 6, but the test case can be PHPUnit 8.
Ah, I see. *itself* means tests in PHPUnit repository :) thanks for clarification. What do you contribute to PHPUnit that you need this?
&gt;Phptherightway doesn't start from the beginning so don't bother saying it No kidding! I guess there must be a "PHP The Wrong Way" that is the beginner book LOL.
Just recently we have been working on adding tests for code that apparently has not been covered by tests, see for example https://github.com/sebastianbergmann/phpunit/issues?q=label%3Acode-sprint-april-2019+is%3Aclosed.
I see, thanks!
In DDD this is called "Bounded contexts" It's also called "service" in SOA. Nowdays "microservices" is a bit more popular term. The idea is to segregate responsibility based not only on technical aspects (representation, persistence, orcestration, etc) but also by feature, so you could have explicit boundaries between them tracking all of the dependencies and so on. Using just horizontal layers is OK for small applications (relativly) or applications with many unrelated features. For larger more complicated applications this is the only way to scale (and I talking about scaling development, not ops stuff)
&gt; it forces you to write better structured code. Symfony users love claiming this, but it just isn't true. You can make all the same mistakes in Symfony that you can in any other framework. &gt; Laravel is great if you're just getting into the game but on the long run your project will most likely be easier to maintain of you choose Symfony How could you possibly back this up? I maintain two very large Laravel projects and one large Symfony project and the complexities of their maintainability really cannot be generalized at the framework level. &gt; Upgradability is a nightmare What was the most nightmarish experience you had following any one of Laravel's upgrade guides? As to your anecdote suggesting that Laravel users are bad developers: K.
i would also recommend this video on this topic: https://www.youtube.com/watch?v=Fuac__g928E
Would you say that Symfony has *less good* documentation online? It seems a lot of people are strong on their support for Symfony in this thread, especially according to the "it forces you to write better code". I like that idea, but good documentation is key in order to do that. What do you think?
Thank you, good stuff!
&gt; it forces you to write better structured code Thanks for your input. I like that it forces you to write better code, but how does it do that? I know good code. I know bad code. But I have no idea how it's possible for a Framework to do anything other than accept the code (good or bad) that a programmer writes. Can you share an example?
Thanks for your feedback! I'm planning on building out this application over the next 3 months. I love the sound of Symfony and I want to learn it, but I'm thinking it might be too much heavy lifting for a small-scale project. Do you think it's possible to pound-out a small application in Symfony in 2-3 months as a new Symfony developer? Or should I stick with something more lightweight like Slim? The client is small, the project is medium (definitely requires a lot of programming knowledge, but its a standalone app and I'm the only developer). I want to learn Symfony4 from all of the supporting comments here, but it might be too much for this client/project. What do you think?
Great comment, thank you for outlining things so clearly for me. That was super helpful. From your post and the other comments here, I'm going with: - PHPStorm - No problem, $20/month is less than the price of one lunch with my girlfriend XD - Vue - Looks cool, sounds good. - Slim or Symfony - Still unsure, Symfony might be overkill for a 2-3 month sole-developer project. - Composer - Tinkered with it in the past, I like auto-updated software. - Git &amp; Gitlab - Tinkered with git in the past, but never really used it heavily, can't wait. Do you think Symfony will make me significantly more employable as a developer? I have no problem landing gigs/employment, but I'm 100% remote which means I need to have top-of-the-line skills. If you think I can crush this project inside of 2-3 months, even if it's overkill, it might be worth the time investment for future prospects. Thanks again
I might go with Slim. I'm worried that if I try to learn Symfony while completing this 2-3 month project then the project could take 6 months. That's too long, the client will be unhappy. Laravel sounds like a "no go" for me because it's big/bulky and difficult to update (according to other comments here). I hate updating versions of software unless absolutely mandatory, so Slim or Symfony sound like better options. Do you think Symfony is learnable/applicable inside of 3 months for someone practicing 40-50 hours a week? &gt; you can get symfony console off composer You are suggesting to use Symfony console with Slim? I don't know what Symfony console is. If it's like any other console, then *I think* I understand. However, how would Symfony console work with Slim? It seems I'd be using linux console to tell composer to require Symfony console...right? Maybe I'm dumb, sorry. &gt; and even use eloquent or doctrine for persistence Not sure what you mean by persistence. How so? &gt; I do prefer blade though What is blade? Last question...How well does Slim work with PHPStorm? I've messed with PHPStorm before, but not with Frameworks. Sorry for the dumb questions, but do all of these frameworks work equally well in PHPStorm? Thanks tons, I super appreciate your initial comment a lot.
Here's a *big* disadvantage of using PHPUnit as a dependency... 1. You installed phpunit using `composer require --dev`, as instructed. 2. All of your tests pass. 3. All of your personal QA works perfectly on your own machine, and on every other developer's machine. 4. The stuff may even work on QA. 5. But as soon as it's deployed to production, using `composer install --no-dev`, again, as recommended, BooM!! You get a big White Screen of Death. What happened? Easy, one of the devs, maybe you, accidentally used one of your many `--dev` dependencies. Your IDE didn't know any better, PHP didn't know any better, but boy, did the Production environment! Now, think about just how hard this is to debug, and you see the full horror. That's why I prefer phars over `--dev`.
I have a lot of experience with MySQL, but now I'm seeing Postresql all over the place. I think I'll try that, even if it's just for the fact of getting experience with something new that has wide adoption. I also like that it's open source and we're not at the mercy of Oracle. Open source is sometimes the best. Thanks for providing an example and other great feedback. You rock!
&gt; DDD monolithic application Just so I understand, Symfony is primarily used for very large applications, right? The application I'm building is mid-size, Symfony is probably too much for this project. I need to have it completed in 2-3 months. Maybe Slim is the better option for this project.
&gt;Symfony users love claiming this, but it just isn't true. You can make all the same mistakes in Symfony that you can in any other framework. Actually, it is true. Most notable reason is that Doctrine doesn't kill your constructor; you can inject dependency into entity and correctly typehint its return value (i.e. no need for :?Category or similar). Forms can also do that using 'empty\_data' param or use rich-form-bundle for ever simpler usage. As I said before; docs **just** for forms is bigger than docs for entire Laravel. I know you can use Doctrine in other FWs, but how many actually do that? &amp;#x200B; Symfony has compiled container; one of **many** advantages is that programmer can't make a mistake with service params, it will show exception on next refresh. And luckily, no more service-locators. &amp;#x200B; No facades nonsense, no magic getters/setters. &amp;#x200B; Tagged services; never before one can implement strategy pattern this easy. And when one day PHP gets generics, even those 2 lines needed will be permanently gone. &amp;#x200B; And they can be lazily instantiated during foreach loop or directly loaded via name. &amp;#x200B; You can inject entity into controller method without any special config. And it can be id, slug... whatever, each route can have its own. And you can inject different entities if you want, just one simple annotation to tell which id belongs to which entity. &amp;#x200B; The trick is that you can make argument resolver for **literally** anything you want; I use mine to inject instance of Enum class. In Laravel, you configure it in entity; not only it is stupid, it breaks SOLID. And I have no idea if it is even possible to inject something that is not an entity. Security; just amazing. Wider-range in security.yml, special cases over controller class or individual methods. It just works. Debug toolbar; have you seen something like that in any other FW? &amp;#x200B; &gt;complexities of their maintainability really cannot be generalized at the framework level I have seen some really bad programmers that somehow got the gig; literally every single line is wrong. PHPStorm screams in pain and agony at that code :) We are not talking about idiots, they will make mistakes that I couldn't imagine even if I wanted. I am explaining the tools that S4 gives me which are by far better than in other FWs. &amp;#x200B; &gt;As to your anecdote suggesting that Laravel users are bad developers Not all. Most are beginners that wanted to start using any FW, Laravel is simple and they learned bad practices. If they had correct guidance, they might be better. Now they are stuck in loop. Taylor does one thing really well; he made Laravel into religion.
S4 is much easier to understand than older versions, and docs are really good. Make sure not to accidentally read docs for individual components, it will confuse you at start. &gt; too much heavy lifting Not sure what this means. It is just a myth that Symfony is slow. Because of compiled container, it will always be faster and faster with each new version of it, or even PHP. Example: when PHP got optimized static arrays, Symfony got much faster boot time, for free. &gt; What do you think? Your best friend is phpstan, max-level. Typehint **every** single parameter and return value, you will better understand my point. Forget old-school PHP, WP crap or similar. Think of future when in one year, you need to add new feature. &amp;#x200B; Doctrine is data-mapper ORM; yes, looks confusing at start. But after a week or two, you will never look at AR again. Talking from personal experience; I worked 2 years with Doctrine1 (AR pattern), switching to D2 was confusing at start. But after few days, never ever thought of going back to AR.
Seems that you know a bit and I (OP) appreciate your comments. Just a few questions if you don't mind: - Of Laravel and Symfony4, which is lighter out of the the box (less files to sift through to get an app up and running without a ton of added bulk)? - Which do you consider has a faster learning turnaround time for an experienced developer with minimal PHP framework exposure? I can build a solid DB site inside of a week, hand coded with JS interface. - Which has an easier/faster method to update when future releases come out? - Do both frameworks work well with PHPStorm? Easy to navigate for someone learning?
&gt; Actually, it is true. Most notable reason is that Doctrine doesn't kill your constructor; you can inject dependency into entity and correctly typehint its return value (i.e. no need for :?Category or similar). You've clearly never even used Laravel because right out the gate you're regurgitating some bs you read in one of those "Symfony vs. Laravel" blog posts. Eloquent can easily be swapped for Doctrine if that's what you prefer. The Active Record vs. Data Mapper argument has nothing to do with writing good code; you literally just gave a bunch of subjective reasons you prefer Data Mapper. Great. Form generators are disgusting, btw. &gt; No facades nonsense, no magic getters/setters. Preference. Can be avoided entirely in Laravel, but why would you want to? &gt; Tagged services Again, you've clearly never worked in Laravel. The tagged services setup routine does not make you write better code, and it is not an inherently superior pattern for registering or extending services over Laravel's container interface; you're literally just listing out the way Symfony does stuff and claiming it makes you write better code. &gt; Symfony has compiled container; one of many advantages is that programmer can't make a mistake with service params, it will show exception on next refresh. And luckily, no more service-locators. This is a preference, not an advantage, and Symfony's compiled container does not make you write better code. &gt; Security; just amazing. Wider-range in security.yml, special cases over controller class or individual methods. It just works. You're actually not making sense anymore. &gt; Debug toolbar; have you seen something like that in any other FW? [Dude](https://github.com/itsgoingd/clockwork)... [What are you smoking](https://github.com/barryvdh/laravel-debugbar)? &gt; Taylor does one thing really well; he made Laravel into religion. Says the guy who clearly has never worked with Laravel blindly evangelizing Symfony.
Hey man no problem. I am only a couple steps ahead of you on this journey, that seems to be how asking questions in the internet works. Here is the deal. If you hate updating versions of software, then go ahead and use Laravel. It's hard to update, so just dont ever do it. Just roll with the latest stable version and go. If time is of the essence, it is your fastest way to a working product. It also kind of "shows you" what to do. I would at least spend the time watching the laracast intro courses to laravel because it explains modern php concepts really well. All the other stuff you asked about you can find on packagist.org. They are bundles that you can use in your own framework. `composer require symfony/console` will put it into your project, there are docs that explain how it works. doctrine is symfony's model layer and eloquent is laravel's. doctrine uses twig for templates and laravel uses blade. I hope you see a theme here... all of these modern frameworks use these structures.... learn PSR, composer, make a simple laravel app following a you tube video, you'll get the hang of it.
&gt; too much heavy lifting Sorry for being unclear. By this I meant...sifting through a lot of files/directories to handle writing code according to S4 standards (they say it forces better code and being more organized). And it being slow, as you mentioned. Basically "big" applications/frameworks are more organized, but learning to use/develop/maintain them can have cost. But, from what I'm understanding, Symfony4 is lighter weight than previous versions, easier to learn/navigate and I can use the tools that you mentioned. I think that's the best option for me. I'll use the tips that you suggested. Thank you
Super cool. Thanks so much for your advice!
&gt;Eloquent can easily be swapped for Doctrine if that's what you prefer. The Active Record vs. Data Mapper argument has nothing to do with writing good code; you literally just gave a bunch of subjective reasons you prefer Data Mapper. Great. No, I explained the reasons above. I am not going to loose major feature that every single language has. Not to mention the stupid magic getters/setters. &gt;Preference. Can be avoided entirely in Laravel, but why would you want to? For my own sanity. Again; magic getters/setters. It means no static analysis; I hope I don't need to explain why it is important. &gt;The tagged services setup routine does not make you write better code No, I was talking about strategy pattern plus lazy instantiation and calling service by known name. Did you even read my comment? &amp;#x200B; &gt;This is a preference, not an advantage, and Symfony's compiled container does not make you write better code. I mentioned just 1 advantage, no need to explain others now. The one I mentioned is that it won't compile if you made a mistake in services (controllers are services as well). Do you want me to make a screenshot of my comment? &amp;#x200B; &gt;You're actually not making sense anymore. No, you have obviously never seen Symfony in action, or used by sane person. I have seen security in Laravel, bunch of code when you need complicated rules. &gt;[Dude](https://github.com/itsgoingd/clockwork)... [What are you smoking](https://github.com/barryvdh/laravel-debugbar)? &amp;#x200B; This is a joke, right? Do you really say Laravels toolbar is even **remotely** comparable to one in Symfony? If you had ever seen one, you would know the difference. And not to speak about dedicated pages with all the tiny details, for master request and every subrequest if present (something unique to Symfony). And yes; I have seen one in Laravel. &amp;#x200B; &gt;Says the guy who clearly has never worked with Laravel blindly evangelizing Symfony. So you didn't even read my comment, only spit nonsense copy&amp;pasted from Taylors twitter... and tell me I am evangelizing? You truly are religious zealot; ignore arguments, put fingers in ears and scream: &amp;#x200B; Laravel is only true religion Laravel is only true religion Laravel is only true religion
English as the "language" of programming languages has always seemed ethnocentric to me, and I've wondered why at least \*some\* major language wasn't written in a non-English language.
it's just a fun experiment, it could have been I do not know, Klingon
&gt;but learning to use/develop/maintain them can have cost &amp;#x200B; That is true, even after 7+ years I still don't know everything and will probably never learn. But google knows where to find answers to my questions :) &amp;#x200B; The thing is that S4 comes with tons of utilities under its belt. So you need more time to learn it, but after few weeks you can see that you end with just few lines what other FWs would need hundreds, for same thing. Which one is easier to maintain? Also, Symfony itself takes care of BC; if something become deprecated, its toolbar (and dedicated debug pages) will give you full stacktrace to problem. &amp;#x200B; &gt;Symfony4 is lighter weight than previous versions &amp;#x200B; Well... sort of. Lighter it definitely isn't because each new version brings new features, but it is faster; one of the advantages of compiled container, they can use new features of PHP itself, abuse OPcache to maximum etc. The main difference in S4 compared to older is that all your services are private by default. Symfony checks your files in src/ folder, marks them as service but if no usage is found, it is removed from container. That is one of the reasons why you will write better code, as long as you follow documentation. But, whatever you decide, do one thing: install phpstan, set it to max-level and typehint **every** single parameter and return type. Yes, even basics like int, array, string... Only use @return and @parameter annotations when you have do due to limitations of PHP. If we had generics and vectors, you would never need to. &amp;#x200B; Second thing: put your files to use strict mode; csfixer is your second most important tool. It will nicely format code to phpfig standards, delete unused 'use' statements, warn you in case of problems... &amp;#x200B; These 2 utils really brings PHP on much higher level, and your skills as well.
I always thought the same thing, but then again most papers are in English and sadly latin america isn't translating things to Spanish, they simply learn English, also there isn't a big company who would actually use this "Spanish" programming language, it should at least be promoted at school level by the governments. &amp;#x200B; I believe it's all by "who is big enough using it", I'd use a spanish PHP, but what would be the point if X company I worked for actually used the English PHP?
It's not a "major" language, but you can write programs / websites in Windev / Webdev in French. Don't ever use it, it's awful to even look at.
&gt; No, I explained the reasons above. I am not going to loose major feature that every single language has. Not to mention the stupid magic getters/setters. Stop being intentionally obtuse. You use your own setters and getters whenever you want to, it's trivial, just like swapping out for Doctrine is. Don't make claims about things you clearly don't understand. &gt; For my own sanity. Again; magic getters/setters. It means no static analysis; I hope I don't need to explain why it is important. [Hi](https://github.com/psalm/laravel-psalm-plugin). [Again](https://github.com/nunomaduro/larastan). Also [PHPStorm works wonderfully](https://github.com/barryvdh/laravel-ide-helper) with Laravel, Facades et al. Nothing in Laravel forces them on you anyway so it's a moot point. &gt; I mentioned just 1 advantage, no need to explain others now. No you didn't, you mentioned a trade-off. You either have a more complex wiring system or a faster development time. You also illustrated your ignorance of [Laravel's container](https://laravel.com/docs/5.8/container). &gt; This is a joke, right? [...] (something unique to Symfony) No, and you are wrong about it being unique to Symfony. I use Clockwork in my Symfony and Laravel apps because it's the best in-browser debug tool I've ever used. Name a single thing Symfony's debugging tool has that is unavailable to Laravel devs lol. &gt; Laravel is only true religion Now your true colors show, you clearly did mean to insult Laravel users in your original post. I believe I've already mentioned I work with Symfony daily, and your claims about its superiority only show how little you know of Laravel.
Really there is no technical reason why someone couldn’t write a C extension that supports foreign languages. It wouldn’t have to take a company. Just open source it on github and I’m sure there would be more than one qualified person out of the 7.7 billion out there that would find it intriguing enough to help out. That’s how both Linux and PHP got started. Really that’s how just about most major open source projects got started.
Most likely for historical reasons. Most of the initial work on DARPA/Internet was done in the USA. Most foreigners didn't take the ideas and developed them locally, but worked in conjunction with USA researchers, so English was the defacto language.
Really gives some perspective. Think about programming in Indian. I’d be a used car salesman before i attempted that shit.
&gt;Stop being intentionally obtuse. You use your own setters and getters whenever you want to, it's trivial, just like swapping out for Doctrine is. Don't make claims about things you clearly don't understand. No you cannot and you didn't read my comment. And that comment says you can't use construct() and inject dependencies so your getters must have nullable return type if you want static analysis. &amp;#x200B; That is the primary reason why AR sucks. No point in explaining more complex things, like identity-map pattern or custom maps etc... &gt;[Hi](https://github.com/psalm/laravel-psalm-plugin). [Again](https://github.com/nunomaduro/larastan). Also [PHPStorm works wonderfully](https://github.com/barryvdh/laravel-ide-helper) with Laravel, Facades et al. Nothing in Laravel forces them on you anyway so it's a moot point. &amp;#x200B; No, these are just patches and not real static analysis. My phpstan config doesn't need any special Symfony nonsense to make it work, it only cares about PHP. Neither does PHPStorm, I use plugin **only** to autocomplete things in Twig, completely different thing. &amp;#x200B; &gt;No you didn't, you mentioned a trade-off. You either have a more complex wiring system or a faster development time. You also illustrated your ignorance of [Laravel's container](https://laravel.com/docs/5.8/container). I didn't, start reading my comments. Symfony by far has simpler wiring system and due to compiler container, developer can't make a mistake. Container is a joke, clearly you don't understand what strategy pattern is, nor you ever heard for it. If you did, you would not stick to term "tagged services" so much. &amp;#x200B; You would know this if you ever used Symfony, clearly you haven't. &amp;#x200B; &gt;No, and you are wrong about it being unique to Symfony. I use Clockwork in my Symfony and Laravel apps because it's the best in-browser debug tool I've ever used. Name a single thing Symfony's debugging tool has that is unavailable to Laravel devs lol. &amp;#x200B; Now it is clearly obvious that you are lying and religious zealot. &amp;#x200B; **READ AT LEAST THIS LINE:** When I used "unique", it was **clear** it is about subrequests and toolbar shows that. It had **nothing** to do with clockwork, but you didn't read it. &amp;#x200B; Tell me, when can Laravel show info like this: [https://imgur.com/a/vofxmKX](https://imgur.com/a/vofxmKX) &amp;#x200B; For others who might read this; timing is big here as this app is installed on HD (not on SSD) + bundle I am using is **full** of subrequests, each with its own debug with **tons** of deprecation errors. That slowed log speed in dev mode, production is not affected. &gt;I believe I've already mentioned I work with Symfony daily, and your claims about its superiority only show how little you know of Laravel. You are lying that you work with Symfony. Either that, or you are using it 100% wrong. &amp;#x200B; &gt;Now your true colors show, you clearly did mean to insult Laravel users in your original post. There is nothing insulting in my first post but given that you keep lying and ignoring what I write, I might start. I won't comment further on, no point in writing something you will ignore again. Go pray to Taylor.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/PceOFWK.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)
Greate Guide!
&gt; No you cannot and you didn't read my comment. And that comment says you can't use construct() and inject dependencies so your getters must have nullable return type if you want static analysis. You're the one having trouble reading: AR vs DM is a [different subject](https://www.laraveldoctrine.org/docs/current/orm/repositories). There are [pros and cons](https://www.thoughtfulcode.com/orm-active-record-vs-data-mapper/) for both, which makes adoption of one over the other a preference by definition, and the answer of which you should use is entirely contextual. Stop harping on about this, it isn't relevant to this discussion. &gt; My phpstan config doesn't need any special Symfony nonsense [Yes it does](https://github.com/phpstan/phpstan-symfony), if you want it to work correctly anyway. &gt; Symfony by far has simpler wiring system and due to compiler container, developer can't make a mistake. If you say so. &gt; clearly you don't understand what strategy pattern is, nor you ever heard for it. Trying to show that Symfony is better than Laravel by suggesting that a design pattern can be implemented in it is next level retardation. Please explain why strategy pattern is impossible to implement in Laravel. Again, none of this makes you a better developer. &gt; You would know this if you ever used Symfony, clearly you haven't. K. &gt; Tell me, when can Laravel show info like this When you have Clockwork or Laravel Debug Bar open. &gt; You are lying that you work with Symfony. Either that, or you are using it 100% wrong. K. &gt; There is nothing insulting in my first post but given that you keep lying and ignoring what I write, I might start. I won't comment further on, no point in writing something you will ignore again. Go pray to Taylor. Bye.
What is your favorite programming language? Me: Spanish
You lost me at "constant variables".
Thank you
1. Symfony improved this a ton in recent releases with skeleton boilerplate and [Flex](https://flex.symfony.com/). Technically, Symfony 4 has less files to sift through, but you'll have easier time getting up and running with Laravel. 2. Laravel. Less nonsense that you need to wrap you head around compared to Symfony (like Doctrine annotations, dependency injection extensions to work with container etc.). 3. Symfony. Less breaking changes and far more more reasonable upgrade strategy. 4. Both frameworks require plugins to work well with PhpStorm, but Symfony is a tad easier in that regard. Laravel requires you to also [generate files with metadata](https://github.com/barryvdh/laravel-ide-helper) for code intel.
Isnt there some chinese languages popping up recently?
You need a vocabulary of a few words to understand the fundamental constructs of most programming languages. If you read the word "while", you know this is a loop. Image, I'd use a german based language, you'd use a spanish one and someone an indian one. We all had to learn new vocabulary.
[https://aloneonahill.com/blog/if-php-were-british](https://aloneonahill.com/blog/if-php-were-british)
There is also the option to use [`maglnet/composer-require-checker`](https://github.com/maglnet/ComposerRequireChecker) to make sure these issues do not arise.
Reminds me of an esoteric language written in French called [Licorne](https://esolangs.org/wiki/Licorne) (Unicorn). The instructions are funny but you won't go really far with it I guess.
This is exactly ethnocentric! You're assuming everyone knows "while", when in fact everyone who's not a native speaker had to learn that vocabulary.
It is fun to play with, but imagine everyone would write code in their language. It would be impossible to read, share and cooperate. I am not really fond of idea reading Chinese, or Arabic code. P.S. English is not my native language.
How did you do that?
Yes, but you have to learn it exactly once. So it doesn't matter if a german, indian or spanic team works on the code. All had to learn the vocabulary and now all can talk about the same thing with the same words. And it's searchable on the web. Excel allows you to use mother tongue keywords. Once had to do something with it; working with it was horrible. I've found solutions on SO and then had to search for the corresponding keyword in my language. (Wasn't as intuitive as it could've been.)
Should’ve used “pero” instead of “sino”. 😝
First trial and it fails: &lt;?php $a = array_merge([1,2,3], [4,5,6]); print_r($a); ?&gt; &gt;Fatal error: Call to undefined function array\_merge() in /console.htm on line 1 Hmm.
If you want to make something more compatible, you could write an IDE plug-in that translates all keywords but keeps them English in the actual files.
&lt;blockquote&gt;Easy, one of the devs, maybe you, accidentally used one of your many --dev dependencies&lt;/blockquote&gt; To prevent that, you'd have to have phar for your every dev dependency (in correct versions) :). This is not how you solve it. The `--no-dev` build is part of CI.
This would be useful for teaching practical programming to young people at schools. They can read/write in their language so teaching programming in a language that they can immediately understand and see it actually working is way better in comparison to other technics. The added benefit of php here is that you can start from functional programming which is easier to grasp and scale it to more modern approaches at the end. Good stuff.
\-
Another thing I like to use is keyboard shortcuts. I use Alt+T as "Run" shortcut and Alt+R as "Rerun" shortcut. Alt+T binds to placement of cursor. If your cursor is inside PHPUnit test method, Alt+T will run just that test method. If cursor is inside test class, Alt+T will run all test methods inside that class. Anytime you want to rerun last test, no matter where you are, just press Alt+R it will rerun it.
Hmm 🤔 How and would you use ``--dev`` dependency outside test files? That's just being careless. Also, that's your issue, you might have many other production code issues, optimization issues, you should set up staging/beta server with exact production setup and test it here before pushing to real production server. Besides, using anything outside composer.json will cause dependency version lock issue. For example, you are using PHPUnit version 7 as phar, then you decided to upgrade to version 8, what are you going to do? If team has 10 developers, are you going to send everyone some kind of notification, email to upgrade their PHPUnit phar before running test suite?
I'd propose few things to consider, please: 1. Make longer videos, that cover more topics than just 1-2 basic concepts. I understand it's more attractive to post lots of videos, but no one will have the patience to click 50 videos to watch content they can get elsewhere in one. 2. The audio is muffled in several of your videos. I think this may be due to extensive noise filtering either in post, or something your microphone may be doing. Either way it makes it harder to understand what you're saying.
A similar discussion recently occurred on the internals list: https://externals.io/message/105253
It also takes about 5 minutes to deprecate/remove it in the core and have users simply not being able to use it. Then there's no need for a CS fixer rule anymore. It simply conflicts when e.g. using PHP to generate XML.
So you hijacked somepone's else work and using it to promote your site. Very noble.
Thank you for your honest feedback. 1. I have couple of topics which I plan to make as separate videos like: interfaces, traits, namespaces. I think that making them as a single video is not that good and this is not because of views, this is because of how people want the content. If someone knows already interfaces and namespaces and they are interested in traits only , they prefer to see this as a separate 10-12 minute video rather than 40 minute video which will cover other topics also what is familiar for him/her. For this particular video I agree that it should be inside Part 1 and that was my purpose from the beginning also, but because of one mistake by me... This became separate video. 2. I agree. I have some problems regarding audio. I tried several microphones and all of them have noise. And because of this I use noise cancellation, but I think that the audio problem comes from the laptop's sound card, so I plan to move on new PC, but I do not know when. Thanks again for your feedback, I will keep in mind.
In 15 or so years I've always used &lt;?php so couldn't care less
If they ever deprecate `&lt;?=` I'm jumping ship. I love using PHP as a templating language. But the short tag? I mean, it always came disabled by default in every installation I had (WAMP, XAMPP, LAMP, manual installation) so I don't really care. Also, it was only three characters saved. Even when amounting every tag you placed on your code, it's not much.
It could also be implemented as an IDE or language server feature where the programmer can code in their native language and transpile the code to executable PHP code. It's one extra step and could be automated to make it transparent to the end user.
It's uglier.
I really couldn't care less always use the full tag except when I use the `&lt;?=` shorthand, but it's interesting that they would do this but in other cases use the argument of backwards compatibility to not make changes.
For reference here is the RFC for this: [https://wiki.php.net/rfc/deprecate\_php\_short\_tags](https://wiki.php.net/rfc/deprecate_php_short_tags)
Imagine they decided to replace `foreach` with `for-each-of-these-items`. You can write a CS fixer script for that, it will take 5 minutes, no biggie. The question is why. The "but XML..." explanation makes no sense for multiple reasons I won't go into again. The change forces verbosity on people, simply because short tags have become known as a disliked feature. They're disliked because they're disliked. And that's about it. I wouldn't say this is gonna wreck my life and I hate PHP now or anything, but on many projects, especially small ones, where I don't use a template engine, the short tags provide clarity and conciseness any time you open/close a branch or a loop. There's also this, once again completely irrational IMHO, notion that PHP is a bad template engine (so far so good, it is), and so we need to make it **worse** in order to force people to Twig, or whatever... What? Why make it worse, artificially, by removing features that harm nobody, instead of making it *better*? It's the completely wrong direction to take.
Although personally I see no use for sort tags at all, this argument makes sense for me.
What?
Sino is a most used translation in spanish introduction to computer science courses.
It doesn't conflict. When you generate XML, it's just XML, there's no PHP in is to interpet. That applies both when you echo XML content, and when you generate static XML files. If you generate *PHP files with XML in them*, then it's trivial to escape the XML declaration, as simple as: &gt; &lt;?='&lt;?xml whatever?&gt;' ?&gt; And then everything after that is business as usual. And even then, since XHTML has been abandoned, almost no one needs this prolog anywhere in their web sites anymore. So we're removing a feature because of an obsolete specification (XHTML) which almost no one uses, and which if you do use (or have other XML content), it's trivial to escape the prolog against. It makes no fucking sense...
Making changes in the php sources and recompiling to build my custom php versión, see the repo here: https://github.com/joelibaceta/spanish-php
🤔 is a good idea, thanks!
They probably won't deprecate the echo-tag. It's not even close to the same as short-open tag and have a totally different reason for existing. Overhead template engines are far from being reasonable today so unless PHP comes with a new syntax or implementation of it's own, the echo-tag is here to stay.
&gt; It doesn't conflict. &gt; If you generate PHP files with XML in them, then it's trivial to escape the XML declaration So you're saying it doesn't conflict and then propose a solution for said conflict that doesn't exist? Everyone has been doing exactly that until now. Now we don't need to anymore. XML Sitemaps, Feeds and APIs are still a thing btw., regardless of XHTML. You can generate more with PHP than HTML, you can even generate your CSS or JS with it if you're feeling funny. What doesn't make fucking sense is your problem with this obvious fix for something annoying in the language. Is there a reason why you'd keep them in?
here is my post -&gt; [https://www.reddit.com/user/aveeva7/comments/bj2h7s/php\_ajax\_dropdown\_field\_save\_all\_the\_values/](https://www.reddit.com/user/aveeva7/comments/bj2h7s/php_ajax_dropdown_field_save_all_the_values/)
The Repo: https://github.com/joelibaceta/spanish-php
What?
&gt; So you're saying it doesn't conflict and then propose a solution for said conflict that doesn't exist? No, I didn't say that. But this is what happens when you cut and paste parts of a quote selectively, so you can argue with a strawman. I said it doesn't conflict when you echo XML content, or when you generate XML files. The only edge case where it does conflict is PHP templates containing XML, and in this case the possible conflict is a *single line of prolog* which is easily escaped. &gt; Is there a reason why you'd keep them in? I already explained those reason, but oh yeah, it wasn't in your selected Frankenstein quote above, so I guess I didn't say anything.
`&lt;?= ?&gt;` is not going away. PHP as a templating language is _bad_. So much escaping necessary and what have we in terms of not separating logic from presentation. Whatever floats your boat, though.
&gt; No, I didn't say that. But this is what happens when you cut and paste parts of a quote selectively, so you can argue with a strawman. I fucking love every word in this statement.
I'd direct you to /r/PHPhelp, but you should not post a link to a user post - instead post the text in that subreddit.
I honestly had no idea short tags were still part of the language. I remember reading about short tags being discouraged, like 10 years ago, and just assumed they had been removed at some point. Surprised to hear people are still using them. Is it just for views? Why on earth would you not use a templating engine in the first place? I don't get it.
I can see some people who voted to remove it from 7.4 but leave it in 8.0 ??
They were sort-of soft-deprecated. The default .ini files were updated in 2009 to disable it by default, but the core engine default that applies if the setting is omitted from ini files and thus the documented default is still enabled. Because they were sort-of-disabled-by-default, it became considered bad practice for libraries and applications that might be on shared hosting to use them. But because they were still documented as enabled by default and existing software used them, many shared hosting providers and distros enabled them by default.
What if everyone had time to do the things we want instead of fulfilling business requirements that are needed you mean?
Your argument is confusing. You keep on putting “does not conflict” together with “but”. Rather maybe then just say “there is a single conflict” together with “rare occurrence”. I am not taking any side, but from a language perspective your posts are very confusing as in “whats your point?”
Then the business would lose the traction and go bankrupt because outrun by competitors. Paying the technical debt and pursuing business goals are always a tradeoff. Completely forsaking one of them would ruin the business whatsoever. So there should be a balance.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/techleader] [Advice on interviewing for lead\/senior position](https://www.reddit.com/r/TechLeader/comments/bj3df0/advice_on_interviewing_for_leadsenior_position/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Don't worry about it. It's not as if me elaborating on the subject endlessly would change the RFC vote. They're going away. We'll adapt. But that decision just wasn't PHP's smartest hour, let's say.
In my opinion, the biggest problem with short tags is the fact that they are configurable. If someone chooses to write with `&lt;?`, the code becomes immediately less portable as it depends on specific PHP configuration. The way I see it, there are two possible solutions to this: 1. Remove the `short_open_tag` and make the `&lt;?` always available 2. Remove the `short_open_tag` and remove the support for `&lt;?` If the existence of XML makes the first option problematic or impossible, then I see that the second option is the only viable one. As an alternative, why couldn't we have a function like `include_short` that explicitly allows usage short tags in some scenarios? It seems people sometimes want to use them in specific scenarios like templates, so why not have a way to explicitly enable them for specific scenarios? I don't really personally care either way. I always enforce `&lt;?php` in all my projects for reasons of portability. I just hate configurations that make some code decidedly less portable.
What are the arguments for using `NullableStringType` over `?StringType`?
I agree with you, but it's far from unheard of for technical debt to be ignored indefinitely, even when the business establishes itself amongst market leaders. I don't see a problem with prioritizing the business over the technology, but I do see a problem with throwing larger sums of money at maintaining the technical debt than just paying it when it can be comfortably paid for. Eg. I'm at a company of 20 years with over 300 employees and we've recently grown a lot from the "organic" movement, paying technical debt isn't even on our radar.
I have always been a bit amused by the "it only takes 5 minutes to fix" type statements. Let's suppose you are a moderately successful developer with a dozen or so customers. And for whatever reason you decided to use short tags. The customers certainly don't care, their websites are working just fine. &amp;#x200B; So in 5 minutes (total) you are supposed to contact a dozen customers and convince them to tweak their working web sites? And presumably pay for it? &amp;#x200B; Just seems like the people making the "5 minute" statements have never actually deployed anything.
What if pigs could fly
Call it cinder?
&gt; No, I didn't say that. But this is what happens when you cut and paste parts of a quote selectively, so you can argue with a strawman. &gt; If you generate PHP files with XML in them, then it's trivial to escape the XML declaration, as simple as: Let me get this straight. "If you generate PHP files with XML in them, you have a conflict that can be solved like this:", that is exactly what you're saying there. I can read. Read your own comment. Your "context" ("When you generate XML, it's just XML, there's no PHP in is to interpet. That applies both when you echo XML content, and when you generate static XML files.") had nothing to do with the sentence after that. ("If you generate PHP files with XML in them") &gt; when you echo XML content &gt; when you generate static XML files &gt; generate PHP files with XML in them These are 3 different cases, 3 different statements, the conflict exists in the last one, the first two were your "context". That's why I stated you're saying it doesn't conflict (with a period after it) but a sentence after it state the exact conflict that exists in the exact case that exists with the exact solution for it that exists (a user-land, unintuitive, ugly solution to a conflict that the language has with another language). Don't call your strawman bullshit when you simply can't read your own comments. Imagine I have a rewrite-rule from e.g. sitemap.xml to my sitemap.php which does something similar to this: ``` &lt;?xml encoding="utf-8" version="1.0"?&gt; &lt;?php foreach ($posts as $post): ?&gt; &lt;post-stuff...&gt; &lt;?php foreach; ?&gt; ``` I'm not generating anything except for my bare XML output, it's the direct file I edit when I want to modify it. Are you telling me this is a rare edge case? XML Sitemaps? RSS Feeds? Small XML APIs? And it will lead to an error, right now, with short tags on. It's unintuitive. It's a problem of the language and the reason why people have been avoiding short tags for ages, hence why barely anyone uses them and they _can_ safely be removed with only minor refactoring needed _if_ used at all. So there are two solutions to this: 1. Either we make a 5min deprecation and removal of the short tag feature and remove something from the language that is unintuitive and needs a workaround to correctly be handled. A feature that is barely used by anyone. 2. Force every other developer using PHP to use a workaround (copy-paste your echo example, it's the only work-around) to fit all configurations that might or might not have short tags enabled &gt; I already explained those reasons through both comments I made in this thread, but oh yeah, it wasn't in your Frankenstein quote above, so I guess I didn't say anything. The only thing you stated is that in your opinion there isn't a conflict and it can be solved with a user-land solution. What I am asking is, what is your problem with having this implemented when it solves the exact same problem in the exact same manner without forcing developers to use workarounds? Is it the time it took to implement it that you've rather seen for other features? Is it the fact that you've been using short tags and now have to refactor code? Or simply that _you_, _personally_ like it to use workarounds? Apart from your toxic attitude I am actually interested in these questions, don't take my interest in why you're annoyed by this change as an attack on you, it's not meant to be one.
Wow.
For that kind of stuff you should take a look at PhpStorm. It's very useful for this kind of refactoring :)
After some more thought on compatibility: this change is easy to adopt in a code base with a relatively simple search-and-replace or script, and the changes (that I'd like to see) that break backwards compatibility aren't easily fixed because they need re-coding.
It would be like warp speed to plane flying. Companies could care less about code "aging" and could really start focusing on new features only. It's a realistic plan for 2020 with Rector.
What do you mean by "things we want"? I do things I want.
Where is the Github repository for this? I wonder how did you create it
Thanks for sharing that. The switch/case and try/catch blocks gave me a genuine and audible chuckle. +1 to you!
&gt;What do you mean by "things we want"? Typically if I only did things I wanted, my boss, the business owner would be upset? I have a large amount of autonomy but I cant just build silly toys if there is money to be made or efficiencies gained.
https://github.com/joelibaceta/spanish-php leave an start in github if you like
To make it more clear, \`&lt;?=\`, the short hand for \`&lt;?php echo \` isn't going away.
Sure, but how often do you have a template where you have no conditionals and loops.
Are you really "introducing" them if basically every PHP beginner writes (and then abandons) a library of "types" like these? And are they "native" if they're... not. That's not part of PHP's core, it's not even a C extension. It's just bunch of userland objects.
Oof, I'm on a project right now helping a group pull a legacy PHP4 app into 7+. I'd vote to scrap it, but their team did a pretty decent job making the original app clean when they wrote it years ago.
Looks nice. I've been using polr for a while and love it, but I might end up switching. My only issue is keeping my old links. I'm thinking I could do some sql magic to import them.
Mainly because I use &lt;? if () { ?&gt; a lot. Would look so ugly with &lt;?php
I tried copying my project into the text box but it's not working.
I think it's more of a problem when creating the type. new StringType(null); would throw an error. NullableStringType does not.
Thank you so much for your kind words! This made me think to a tool to import Short URLs via an XML / JSON file... Will be done once UrlHum will be more stable. At the moment it is in highly development and features could break / change so I suggest you to wait a bit to do so! Meanwhile you can watch the repository on GitHub / star it and contribute to the project if you know anything about Laravel / PHP. That'd be so much appreciated! I'm sure the switch will be a great experience for you.
I just started a php dev job so maybe in a few months I'll be smart enough to help
I like what the article refers to as a "weakly typed system". I like being in control of when the type matters, and to be honest, most of the time it doesn't matter.
No problems! The project will be there to wait. Congratulations for your new job!
php was designed as a templating engine, and still functions properly as one. That's why some of us don't use a templating engine on top of a templating engine. That's also why many of us think having to type an additional 3 characters in some situations is a bit ridiculous, when other languages do not require this.
That's easily interpreted as "Remove it as soon as 7.4, don't wait for 8.0"
I never understood why my code needed to be compatible with sending it through an XML parser in the first place, requiring me to type 3 characters, but only sometimes. Never in 10 years, have i found a reason to transmit PHP code through XML. Hell, XML has fallen out of favor to JSON and other formats these days anyhow. &lt;?= is okay.. ?&gt; is okay.. &lt;? is apparently not okay..
I just fixed a "bug" where an endpoint's template was throwing a 500 on our PHP7 test environment due to ONE use of a short tag on a 400 line template &amp; `short_open_tag` was disabled on 7.x. I love short concise things &amp; used a lot of short/ASP tags back in the day, but not lately.
You can use PHP as a templating engine ( which is what it was designed for ) and have proper logic separation and escaping. In fact, doing so gives you more control.
There's lots of that going around.
While it is an ad, it is also a decent collection of PHP ETL tools that starts with the open source and github options. I wrote an ETL for my company and it was a fun project, but I would have appreciated having a lead to explore like this at the time.
You might find a use for [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). (I am the author.)
Thanks, Paul, I have a copy. Must've been three or four years ago, and I have to tell you it has altered my family's career path a bit. I spent four years teaching my oldest son to code and he works for me now. We have made a living specializing in all sorts of institutional/internal business software, but have gotten the most endless supply of work as php legacy refactor specialists. Your book was a reference tool I used when we did our first, and we'll I'll pick up another copy for the second son, as it's getting about that time and I think the process engineering aspects of the book are good reading regardless of the language. Now, let's put a new chapter in there about the nature of providing time and cost estimations for each of those process pieces. ;)
Cool deal. Very strange choice of sub.
Direct URL to the thing: https://www.humblebundle.com/books/python-oreilly-books More Humble Bundle "partner" low rent spam. Next time, consider posting the actual URL to the thing you're describing in the title to your post. Not a referral redirect rabbit hole for users to tunnel through before reaching the actual thing.
OP is a referral link spammer. They don't care where they post just so long as they're able to post.
Wait what? How?
Yeah, but `&lt;? if(cond): ?&gt;` won't work anymore. Which is much easier on the eyes than `&lt;?php if(cond): ?&gt;`. Just my humble opinion.
It should. It works with mine. Too big ?
Why use a templating engine that requires you to pre-process code and then execute it when you can cut out the middle man and do it all in PHP? &lt;? if(cond): ?&gt; ... &lt;? endif; ?&gt; &lt;? foreach($a as $b): ?&gt; ... &lt;? endforeach; ?&gt; &lt;?=htmlspecialchars($var)?&gt; &lt;? include('myView.php'); ?&gt; What real benefit do you get if you use a template engine?
Thanks so much for explaining all of this. I'm going to dive in!
Look at their profile. It's all they have posted and they even dumped it in a JS sub.
Oh boy. They're all over the place. Legacy code for the win!
&gt; Also, due to Symfony's nature, it forces you into working with the best current practices, unlike Laravel where you're more open to write shittier code. I'm guessing you've never taken on other Symfony projects that you weren't a part of from the start? No PHP project I've come to be a part of has been what I would call "clean". The cleanest projects I've worked on (for money) were always stuff that I built for other people and made clean code a priority.
seems like a total waste of time for everyone involved. this is a very low impact issue that I am astonished people are getting dramatic about.
That's the best success story I've heard in a long time. Congratulations! :-) &gt; put a new chapter in there about the nature of providing time and cost estimations for each of those process pieces I love that kind of easy, simple topic. ;-)
It's also easy to change it for compatibility with future versions without breaking compatibility with *past* versions.
The ones that don't have some service agreement, won't be upgraded to 8. There will be more, much harder breaking changes. (TypeError ftw)
As much as I would love this, this can't be done. As others have mentioned, you can't. There are tons of business requirements. You CAN over time by "refactoring" as you go. Which, to me, means if I have to edit a function, then maybe I could turn that function in to a PHP 7 function. But then you have to ask why? What are you gaining? How does this help? I would actually start by writing tests.
 \&gt; It takes maybe five minutes to set up and run. &amp;#x200B; Precisely. The rest is fud.
The 7.4 vote is a vote to deprecate it, not remove it. Essentially to just display a warning whenever it is used. So they're voting to say, yes, show a warning, but don't actually remove it in 8.0; leave the warning in place.
&gt; In my opinion, the biggest problem with short tags is the fact that they are configurable. This is it in a nutshell. Someone writes, the following code: &lt;? $_ENV['database_srv'] = "localhost"; $_ENV['database_user'] = "conten_edit"; $_ENV['database_pass'] = "SuperAwesomeAndSecure!"; ?&gt; and then config for short tags gets turned off (or maybe even deprecated) things go from bad to worse real fast.
all the time when you are just echoing out a variable like &lt;td&gt;&lt;?=$person-&gt;name ?&gt;&lt;/td&gt;
Cool, thanks!
Could you give me some example?
What do you use that for in real-life?
If real-world templates were that simple, we'd just be using Heredoc for templates. But, of course, you'd have conditionals (for example, is the user logged in: show username, else show "log in" link), and loops (any time you show... more than one item... in a list, in a table, whatever).
When I change a variable's or value's type inside of a function, then I'm doing this on purpose. Having typed variables would be more of a documentary benefit than everything else.
Probably because you can't use it [directly](https://stackoverflow.com/a/17973365/2471530). AFAIK the only way to achieve it would be this, which is not very use-friendly `&lt;?php` `class StringType {}` `class_alias('StringType', '?StringType');` `$test = '?StringType';` `$obj = new $test();`
?StringType isn't a class... since PHP 7.1 you prefix a ? to indicate the type can be null. You would never instantiate ?StringType, you'd either pass/return a StringType object or null.
You get reduced verbosity, automatic escaping and easy includes, for starters.
You don't contact all your customers for all PHP updates, why would you do it for tags? Just replace them when it is time to upgrade, while you fix other broken by upgrade stuff.
But PHP as a templating engine is terrible for anything beyond echoing strings and basic control structures. It's just painful. Just look at the [Blade documentation](https://laravel.com/docs/5.8/blade) for some examples of things you can't do with plain PHP.
Because real template engines provide **much** more, and in simpler syntax. There is no performance penalty in production, all engines compile templates to PHP. &amp;#x200B; So there is zero benefits in using raw PHP for templates, only problems.
Reminds me of the way Scala deals with Java's primitive types. But I'm not sure how it would achieve the goal stated in the post: &gt; For example, while you can use &lt;?php declare(strict\_types = 1); to enforce an int parameter in a method signature, there is nothing to stop you from changing it to a string within the method itself. because `function typetest(StringType $test) {` `$test = 123;` `return $test;` `}` would still work, right? But it would definitely make accidentially relying on the type coercion a bit harder: `function test(string $test) {` `return $test + 2;` `}` `echo test("3");` works, but `function test(StringType $test) {` `return $test + 2;` `}` `echo test(new StringType("Nope"));` should not. But in my quick test it just showed a `PHP Notice: Object of class StringType could not be converted to int` and echoed a "3", so no not being able to convert means PHP assuming 1?
All of the above.
It seems that it's no falsy value as it is "something". So it can't be 0 and therefore is 1. Or something like that: https://3v4l.org/JpUTn
Arrow functions. Finally. It took long enough.
Google sheets as database feels so bodgy... I hate it
Well you already have as good as it gets with doc-blocks in case of type hints.
I dunno. Not having to pre-compile your templates seems like at least one benefit.
&gt; Google sheets as database still doesn't mean there isn't a use case for reading or updating a spreadsheet
Ah, true! For some reason I though it only worked on "primitive types", I guess I'm still thinking in the way how Scala implements things. Thanks for correcting! :)
Yea well that’s what the api is for
yeah and that's what this video is showing... did i miss some section where he said "instead of a relational db let's use google sheets"?
Moreso that you can't use XML with PHP, as PHP would see the `&lt;?xml` as a php open tag, so if you're trying to template some xml
Oh I wasn’t referring to the video. I just see many developers here putting massive databases in google spreadsheets. I don’t think that’s good. But google services have a long history of being „abused“/misused by developers, so whatever it’s probably not going to change.
It is done automatically, users don't even notice it. But you get **far** more utilities like escaping, inheritance, use blocks, clear syntax, early bug detection...
I dunno, i've been doing all the things blade has been doing with plain php with the assistance of a very minimal framework. The reason for this is that the pages we generate are extremely dynamic and all the templating engines i've investigated make the job harder, and with more CPU overhead.
ohh i've honestly never seen that. yeah totally in agreement with you
And in reality, in the web, everything is a string. Cookie values? Strings. URL params? Strings. Input in text fields? Yep, strings as well.
Oof, would be cool if there would be a flag that turns all type-related notices into errors. That would help with making code more typesafe, but I guess there isn't?
Maybe they could just fix that.. i mean, the engine can differentiate &lt;?= and &lt;? and &lt;?php as it stands.
I see, that makes sense
While true, the real power of typing comes in when you use tools like [phpstan](https://github.com/phpstan/phpstan). For example, I refactored a [Magento interceptor](https://devdocs.magento.com/guides/v2.3/extension-dev-guide/plugins.html) once, removing an "unused" method argument. My mistake only showed after going to the 3rd step of the checkout during testing, where the interceptor was called. In case of a proper typing (and checking) the wrong method signature would have been caught. It's true that it's easier to deal with "string only" input on the controller layer, it will make your life easier if everything is properly typed on the layer beyond.
Sometimes. I worked on .NET / Odata app that had custom user defined fields. Getting that to play nicely in a type safe system was one of the most painful things ever, and I was just a UI dev. The experienced .NET devs were struggling with it. It would have taken me almost zero time in PHP (and I've built a few systems with user-defined database fields in PHP before. It's very easy, but .NET/OData made it like pulling teeth). And in general, the amount of code needed to do type juggling seems to be quite verbose. It complicates DB query code that doesn't need to be complicated, and a whole host of other issues. Sometimes type safety of primitives helps you build a robust domain model, but I'm not sure the translation cost between different data sources is always worth it...
Google in 2021: "We are deprecating Google Sheets."
asked if that would impact php’s ranking overall
Yeah. Legacy code base. Upgrading to php8. Short open tags will be the least of your problems... &amp;#x200B; Chances are your legacy code base does not even have a decent test coverage anyways, so upgrading php is a gamble at best, even if you fix all known deprecations and what not. &amp;#x200B; Im not saying there is no well tested legacy code running the latest php out there, but it is definitely not the norm.
or more like with Google Maps: the api is now chargeable
Why the down votes?
You usually would run the database (i.e. mysql/mariadb or postgresql) on your own server. I don't know why people would use Google Sheets as their primary database.
When the majority of the ecosystem will adapt it, it will. The same way PHP missed dependency manager and was lacking behind Javascript with npm, with Bundler.
Or just host it. If your project isn’t too big you could even host it for free, so I see no reason for google sheets.
I may have been ambiguous. Short tag is better lookin for templatin
Yeah. By your own server I meant your own VPS, which starts at $5/mo through services like DigitalOcean (or even a shared host, but that's just gross).
Can you link to a single comment where someone here is putting massive databases in google spreadsheets?
Just wait till they start charging for Google Analytics.
I‘m sure I saw at least a few comments talking about this, and I’ll link one if I see one, but for now just look on [Google](https://www.google.com/search?hl=de&amp;q=using%20google%20spreadsheet%20as%20database). More and more developers apparently do this. I don’t understand the downvotes?
It looks ugly without using the alternative syntax.
I have a client that uses Google Surveys which dumps the responses into Google Sheets. We then pull the responses from there into a proper DB.
Actually that is something that Rector is able to do :-).
You already pay with the data of your users
Sure, but how often do you have a template where you aren't using an actual templating language? PHP is _really_ bad as a templating language. It's missing basically every major templating feature for the last 20 years, has more verbose syntax (even _with_ short tags), and worst of all: it's dangerous-by-default.
Well, I can sympathize. In my previous company we had an "API-first" approach, meaning: before you would write a single line of code, you'd have to define your Swagger/OpenAPI definition first, and that would become your go-to definition afterwards. Since that was your service contract it was somewhat mandatory that your code followed the Swagger JSON-definition instead of the standard approach of generating your Swagger-Files from the API-Definition in the controllers. To build a framework that would turn your swagger into a controller was relatively [trivial for dynamicly typed languages](https://github.com/zalando/connexion), but indefinitely more complicated (and indeed pointless) for [staticly typed languages](https://github.com/ebowman/api-first-hand). But in the end I think the gains from having a stongly typed codebase shows really when you have increasing complexity. When you have enough code that can simply not be covered by a bunch of unit tests and some smoke tests, having the security that a developer won't screw up a cornercase that will only be caught in production, because the compiler complained in the first case, is somewhat liberating. (Complexity in that case means e.g. something like Dependecy injection in Magento. PHP doesn't bat an eye if you screw up service contracts like implementing an interface in the wrong way. Simple errors like this are caught by the compiler in other languages).
bingo bango
Curious: Why did you feel the need to include "instead of" even though its crossed out?
Yet it wasn't good enough for maps where you have to pay them money as well.
it's not being used as a DB, it's being used as a spread sheet that people shared can work on and the API lets you grab that data. Try asking your marketing team to just use a database with no front end.
That’s the way it’s meant to be used. But as I said, some people are using the api to repurpose it as back end database. I don’t understand why. They probably think it’s cheaper?
I'm learning json with axios and javascript using Google sheets to show my data. Is there any better way?
Well google analytics can get much more data than google maps, right? I really don’t get why people are using google services anyway. Most of them were basically solely made to mine more data. I can’t think of one single google service that isn’t gathering all the data it possibly could.
Set up a Mysql Database. I’m not familiar with how a google spreadsheet request looks like, but I guess it’s not too different. Just use (jquery) Ajax and php.
I use [https://sheety.co/](https://sheety.co/) to convert any Google sheet do json. You have to shared as csv and it's done. If I try MySQL Database, how can I show the data as json?
We are both talking about backend databases right? With php you can connect to a database and send MySQL requests. The server will respond with the data you asked for. You can generate json in php with the function json_encode.
The real question is: how did they test the first version of PHPUnit?
To respect the coding standards and clean the code.
r/phphelp is what you’re looking for
Thanks! I’ll look into it
I'm not familiar with the CONCAT function you used but by reading its documentation the way you are doing you are concatenating the column names instead of their values. Example: CONCAT('col1', 'col2', 'col3') returns "col1col2col3" while CONCAT (col1, col2, col3) returns the column values. I say remove the single quotes from the CONCAT parameters and try again.
You should post this in /r/phphelp, thanks! More context will be helpful though. This is barely a question!
But what if all I need is echoing strings and basic control structures?
Thanks, I tried it but it didn't seem to fix the problem, but it might be part of the problem. Thanks again!
Idiots. I don't care, downvote me :-/
This is a legit [Mandela Effect](/r/MandelaEffect) for me, because I could have *sworn* that short tags were deprecated back in the 5.3 days and fully removed with 7.0...
if you set `short_tags = 0` in your php.ini, it suddenly works. I had been doing that way back in the 5.0 days, back when I used a lot more `&lt;?xml` than i have in the last 10 years. Back when I wanted XHTML to win and regularly wrote `application/xml` in XSLT.
I'm all about clean, modern code, but sometimes you often have to be pragmatic, especially when you have limited developer resources. We have tens of thousands of lines of legacy PHP where I work. Most of it is finally (thankfully) decommissioned. While I've wanted to clean it up and rebuild it in something modern for a long time, there are a number of reasons this hasn't happened. 1) It is poorly organized (no autoloaders, mess of require/include). 2) Code itself is awful and very difficult to read. 3) No documentation or business requirements. 4) The code does work. 5) I've only had to modify/fix this old stuff a few times over the years. 6) Business wouldn't support spending a lot of time rewriting code, as we have so much more important work to do. (And it's actually running on PHP7.1 right now.) While I'm disappointed that we haven't been able to refactor much of this code, I have to admit that leaving this particular code as-is hasn't really caused much harm. It's getting decommissioned (due to business no longer needing it) faster than we would be able to rewrite it anyway. This post has a matrix showing where it's most important to focus your refactoring: [https://qafoo.com/blog/112\_refactoring\_matrix.html](https://qafoo.com/blog/112_refactoring_matrix.html) &gt; Companies could care less about code "aging" and could really start focusing on new features only. Legacy code, even as bad as it can be, isn't the reason I don't spend most of my time only working on new features. There are bugs to fix in our newer systems. There are always more tests to write. There's CI/CD to improve. Refactoring, as important as it is, isn't a fix-all you should apply to everything.
Oh that is weird. Especially since Google has firebase.
I already addressed this specific argument elsewhere in this thread. The solution to “it’s a bad templating engine” is to make it a better templating engine, not to make it a worse one.
They already do. There's a paid version for big enterprises. Quite pricey actually.
What if everybody scrapped Wordpress?
Anyone wanna give me a tl;dr summary? Thank you
If your site is slow and load average is low look to change to fewer more performant cores. Also optimize code and queries.
Don't. Just Don't. &amp;#x200B; Never ever F ever **ever** build **anything** on top of anything from google like this. I have spent **so** much time with this, and its all wasted the second Google changes or shuts down things with no warning or documentation. &amp;#x200B; You will spend a ridiculous amount of time coding circles around Googles wonky stuff, and in the end the bit from them will be a tiny little core inside a Frankenstein codebase that's only there to bend over backwards for the Google-part. &amp;#x200B; In the end it will have been **so** much simple to just build the whole thing from scratch without the Google-bit. &amp;#x200B; Don't do it kid, step away from the edge!
\^ 100% this
You da real mvp, thanks!
wow. php is not multithreaded (not in 99%) wow. so much infos. wow
That's only logical given the nature of PHP. However I'm curious if they allow the spawning of more FPM child processes, wouldn't that increase the request throughput?
This variation is not deprecated.
Generics
Do you hire?
c-call convention for extensions
They have changed the complete dev interface for that multiple times already. Will be fun!
Yes, We do hire for that you have to go on the website and fill the contact form.
Also internationally?
[It does, in the next release](https://wiki.php.net/rfc/ffi).
That's not a solution, because PHP isn't a templating engine. It's a programming language. It was developed as a templating engine for C - it's moved away from that *intentionally*. Trying to make it more of a templating engine is going backwards.
Why not use a proper templating engine?
Property accessors like C# has, proper enumerations, method overloading, partial functions like F# has and short DTO declarations like Kotlin has
Php is already a template engine itself.
Missing a development environment that is easy to set up. If you have no Dev-Op skills, just setting up the debugger can be challenging. Use Vagrant? Use Docker? A lot of work just to start a project. I love it though ❤
So, Angular and Vue have added cli libraries that kind of decide a lot of the things that don't matter allowing you to spin up a project with hot reload in minutes... I guess I do appreciate no having to set up webpack and the other dev stuff as well as easy environment specific build configuration that more or less handles itself.
PHP is not a templating engine and has not been even remotely close to one since PHP 3 was released in the late 90's. It lacks many modern features of a proper templating engine and is unsafe to use as a one
Yes, But share with us your information on website so we can do discussion in details.
It lacks modern lacks modern features? I bet a templating engine built with php is more limiting than php itself.
PHP really lacks data orientated libraries https://github.com/jkk/honeysql https://github.com/walmartlabs/lacinia I wish we had Clojure keywords, we have something close in labels but they're not idiomatic and they're not persistent in data structures
I'm willing to bet you edit your website in Notepad++ and upload it to your production server on a shared godaddy host via filezilla.