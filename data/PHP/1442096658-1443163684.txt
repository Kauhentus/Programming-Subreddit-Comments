&gt;I once saw someone on reddit cite 0.1+0.05 as a reason why JavaScript sucks... Python (a language used by statisticians and data scientists far and wide) has the same problem. Welcome to the world of floating point numbers. Complaining about this shows a lack of understanding of how these languages handle numbers.
&gt;I didn't miss the point **you aren't writing sleep loops** &gt;Not putting the delays in a control loop is a syntactic side effect. It does more than that. The sleep function delays the program execution. Even settimeout doesn't do that. &gt;The node.js terminology is, as I have tried to describe, completely irrelevant. You are literally saying that **what you are writing** is completely irrelevant to **what you are writing**. I would say you missed the point. Maybe code readability just doesn't have an impact on what you write, and nor does blocking. I don't plan on abandoning PHP anytime soon, but if I am calling sleep a bunch of times, I probably shouldn't be writing it in PHP. 
$10 - $15 / hour ? Are you f**king kidding me? No ones time is valued so little.
Well put. It's not without its warts, but they don't discount it as a valid language.
Ah, I thought something might be missing from the post, this is better. :-) I see your point. This is a "generic repository" of some sort. If this is specifically targeted at Laravel users, then Eloquent is already a "generic SQL repository". The purpose of a repository is to be as narrow and tight as possible, to have the minimum number of features a *specific* service needs in order to do its job, because this repository will have to be mocked for service tests, it'll have to be maintained for possibly multiple persistence implementations and so on. So I think calling this a "repository" as in DDD is indeed misguided, as it defeats the purpose of a repository.
note that the fractal author recently threw his toys outta the pram and quit the tech industry completely: http://eev.ee/blog/2015/06/09/i-quit-the-tech-industry/
Technology: A Fractal of Bad Design
http://tonyarcieri.com/all-the-crypto-code-youve-ever-written-is-probably-broken Proceeding with a complicated design that implements cryptography vulnerable to chosen ciphertext attacks when a simpler, equally effective and more secure solution strikes me as an unwise choice. [You can't have secure encryption without message authentication](https://news.ycombinator.com/item?id=9865276). If your client is okay with extra complexity and a larger attack surface, that's all that matters, but I still caution people against making bad architecture decisions when ever possible. Look at https://paragonie.com/audit/2QB0t20PnxjevVA0 and tell me how many audits are in our database. Protip: You can't; it's randomly generated. (Only one is public right now.)
PHP is *basically* built for web applications. It just isn't great at anything else. It can *do* other stuff, but it's not great at it. PHP's niche is web applications. I'm a full time PHP developer, and I would never pick it for a CLI application (unless it's just some utility for a web application, like Symfony2 console stuff). A wrench *can* drive nails, but that doesn't make it a good choice. EDIT: But with that said, I'm certainly not going to bash somebody that chooses to pick PHP for a CLI application. At least they're making something, which is cool with me.
&gt; It takes 9 parameters. Most of them are just globals. My sides!
&gt; but it remains poorly designed and full of strange warts kept around to remain backwards compatible with decade(or more) old code. Yeah, that tends to happen when a massive majority of the internet runs on a certain technology. I'm sure all of the Zend engineers wish they could just rip out its core and re-build, but that is entirely unrealistic. Sorry. &gt; for example only very recently shifting away from telling people that shit like like "mysql_query("select x from y where z ='$z'");" is okay. That is *most certainly* not a recent event. The important thing is that PHP is moving in a very positive direction. PHP7 has huge improvements in a lot of areas, and I bet it's faster than or at least as fast as all the cool new hipster shit these days. It's not PHP's fault if you write shitty code.
I'll take your word for it. The last time I Googled "php mysql tutorial" was probably sometime in the late '90s. The scary thing though is that those tutorials I found back then, they probably _are still out there_.
Actually I wonder, can anyone explain the difference between repository pattern and data mapper pattern? To me these two are about the same, I can hardly tell the difference. 
Technically? There's little difference between the two. Conceptually? They are quite different. A repository is intended to be a domain pattern, with expressive methods that describe the business needs with respect to data fetching. $repository-&gt;findAllActiveUsers(); $repository-&gt;findProductsWithZeroOrders(); // Or criteria/strategy pattern. $repository-&gt;findByCriteria(new ProductsWithZeroOrders); $repository-&gt;saveOrder($order); $repository-&gt;updateOrder($order); The "concept" here being that a repository lives very close to the domain, and expresses the domain needs in ways that the business would understand, while a data mapper lives closer to the data layer and describes data in ways that the software engineer would understand: $mapper-&gt;findByAttributes(array $attributes); $mapper-&gt;map($object); $mapper-&gt;store($data); It's not uncommon for a DataMapper to be a more generic re-usable data filter and object mapper, that a repository will use and wrap in an expressive domain language, but there's nothing that would prevent a repository from performing the same function as a data mapper or vice verse.
&gt; What are you thoughts on having findWhere($field, array $where), findByField($field, $value) methods in a repository? As /u/SoftwareArchinept correctly noted, Eloquent already does many of the things various conceptions "Repository" in a generic implementation does. You can still create e.g. entity (or better: bounded-context)-specific repositories on top of that, which can make sense for example to simplify querying logic, or restrict user capabilities for persistence concerning certain Domain objects, like audit log entries or account ledger entries, which may not be modified after having been created. In general, I have to disagree however that repositories are necessarily meant to be as narrow as possible to fit one specific service. There are several valid approaching to defining the roles of repositories, each with its advantages and drawbacks. Making repositories as ways of providing collection-access with extended querying capacities to domain objects in front of switchable data-mapping and persistence technology is certainly one of them. You can make persistence interaction leaner than Eloquent and provide repositories as mediators between basic object-persistence and domain-logic so that e.g. Aggregate Roots (like Sales Documents consisting of a header and lines) can be retrieved, with the repository coordinating the logic involved in resolving the composition-relations in and out. Structurally and conceptually, data-mapping is closer to the persistence-layer side of the application, while repositories are closer to the domain-layer. It doesn't have to mean that a repository should fit only one specific (micro?)service - though they can be used like that. In general, I would argue it means it's the repository's job to simplify domain-logic interaction with collections of domain-objects that are persisted somewhere. For many application tasks, it is optimal to have all the generally available entities available as a collection with extended querying capabilities. When there are many and complex aggregate roots, the querying (and persistence) logic that general data-mappers provide are too coarse, and the responsibilities of the data-mapping too close to dealing with persistence technology that duplicating querying and persistence logic can become a real issue, and the responsibilities of mere data-mappers are stretched. In such cases, repositories as an additional abstraction layer can do a lot of good - precisely because of the extended domain-side capabilities (extended and/or customized querying, constraint-impositions etc). Hence the description in PoEAA of a Repository as something which &gt;Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects. Of course - in the end it's about what leads to more easily maintainable, modifiable and improvable code. It's always a multi-dimensional payoff-balancing act, and there is no general "right answer". But it seems that having extended "find"-methods in repositories is part of what makes them useful in the first place. On the other hand - if you're using eloquent, and find that cluttering controller- &amp; service-code with implementing details of aggregation-resolution and collection-access isn't a problem for you - such a kind of repository isn't needed. Here are some interesting resources: http://www.sitepoint.com/handling-collections-of-aggregate-roots/ https://lostechies.com/jimmybogard/2009/09/03/ddd-repository-implementation-patterns/ https://lostechies.com/jimmybogard/2008/08/20/ddd-repositories-and-orms/
Thank you for the feedback. I agree with you that there can be many implantations of a repository pattern, but I have to disagree on having findWhere, findByField, and other finder methods in a repository. They really do not fit into a repository. A repository doesn't have to be super narrow, but it should not be generalized to have findWhere and findByField.
If you use a lot of classes I highly recommend generating UML diagrams from your code. If there isn't clear organization and interaction start making changes there. A nice bonus is that the diagrams are good for helping newcomers understand how things look from a distance – something that is hard to do in a file editor.
Most calendar tools (Google Calendar, Outlook) kind of do this for you. Start an event and you can see everyone's schedule and what conflicts they have. Of course, this means everyone has to keep a calendar of their own schedule.
My god man. I was looking this for 2 years!! THIS video changed my way of writing code. Love you man. Have more? :p
Yeah, this is not good. Aside from the `findWhere` and `findByField` references, it also has eager loading references (`with()`), query scoping references, and all sorts of leaky abstraction crap. Eager loading is an Eloquent implementation detail, and in fact is an *optimization detail* that the domain should know nothing about. I tend to agree with your assessment that this is a meaningless object on top of Eloquent. It provides almost no meaningful abstraction except maybe for the `findByCriteria`method. Fundamentally speaking, I don't think a repository is even something that you can or should turn into a library. By definition, a repository is supposed to be a very application-specific API that consumes whatever the persistence layer of the application happens to be.
That's a lie. Many people have gotten their bitcoin wallets stolen this way. There are rainbow tables of lyrics, books, etc. 
As I understand, repositories do not express business needs or logic. They are supposed to act like a dumb collection, hiding persistence details from domain-aware classes. 'Expressive methods' don't belong there.
&gt; What are you doing, you're just ignoring all I said and repeating what you said? Sorry, I thought maybe hearing it from other people would cement the fact that the advice I'm offering is sound and based on an understanding of cryptography. You seem to have a personal vendetta against me and I want you to know that most (if not all) cryptography experts agree that authenticated encryption is the only way to stop chosen ciphertext attacks. &gt; The first link says "if you encrypt you can still tamper with a message". Yes, that is the entire point here. &gt; It's not the purpose of encryption to stop modification of the message. Look, the reason I stress authenticated encryption is simply that most developers don't *know* they need authenticated encryption. Outside of cryptography circles, this isn't common knowledge. If you walked into a PHP User Group meeting this month and asked them, "Hey, is AES-CTR secure by itself?" most of them would say yes. You're arguing about the color of [legos](http://www.cryptofails.com/post/121201011592/reasoning-by-lego-the-wrong-way-to-think-about) here. No, the role of encryption itself isn't to stop tampering. But any developer who wants to encrypt information in an application, securely, where any other device (especially the end user) will have access to the ciphertext **NEEDS** to authenticate the ciphertext. And the safest construction for doing so is Encrypt Then MAC. &gt; How would tampering a URL break an app, if they authenticate, say, the message ID you request against your user? It won't. So why try to protect against tampering at all? The user won't gain anything from it. It serves no purpose. In theory, no, I would agree with you. In practice? It depends entirely on the application and the implementation. What if they `unserialize()` the result? Then a forged message could result in PHP object injection (or, if the recent PHP changelogs are any indication, breaking out of the PHP interpreter and exploiting a memory corruption vulnerability). In general, adding encryption where it's not needed just increases the attack surface. Adding encryption where an attacker can exploit chosen ciphertext attacks is taking two leaps of faith where none were necessary. &gt; I'd have to call you on the phone and have you dictate that ID you pasted in the URL to me, because believe it or not, that's sometimes a goal for a public ID. Swap out `base64_encode()` with `bin2hex()`. &gt; It's apparently possible for people have different goals! The goal here is to obfuscate an identifier so that it doesn't reveal the incremental ID used internally in the database, nor leak any metadata (e.g. how many records exist in the dataset). My point is that using a random, unrelated identifier is fundamentally safer than a deterministic transformation of your sequential identifier. You're arguing that your obfuscation method will prevent casual observers from learning this information. The bad news is that the only people who might be interested in this data (investors, competitors) are the only ones who would even try. At best, weak obfuscation is [security theater](https://en.wikipedia.org/wiki/Security_theater). "Hey, people who aren't interested in this topic, look at this protection we implemented to prevent it from leaking out." "Oh hey cool, never would have even though of that; rock on." And then your competitor has a small number of people sign up and then they do basic cryptanalysis and now they have potentially sensitive business information. &gt; You can't just come in like a bull in a china store and wreck everything, and then say everyone is doing coffee cups wrong, because they're not safe to a bull attack. And yet this is the premise behind many of your articles. The premise behind many of my articles is, "Unless you have a damn good reason to do something unwise, default to a secure approach." When you give cryptography advice on the Internet, you have no idea how it's going to be used. Someone could use it to guide the development of life-saving tools for organizing activist efforts in hostile regimes, someone else could use it for designing a crypto-currency, still another might use it for communications within a drug cartel. Cryptography engineers will already know the nuances of what I'm saying and, if their requirements either allow or expressly... require... them to do something funky, they'll know how to do it safely. I write these posts for developers, and I write them to stress being secure by default. That's kind of a recurring theme in everything I do. &gt; Protip, you're arguing with a straw-man again, because I didn't say you can guess the number of ids from a randomly generated id, go read my post again. Jesus you really love this fallacy, don't you? It was no fallacy, it was a challenge. No matter what cryptanalysis you perform and no matter how many audits I publish, you will never gain any information about the number of audits, nor the sequence they are recorded in the database. Can we say the same about your method? Results speak for themselves. If you're unwilling to take up my challenge, by all means back down.
http://php.net/manual/en/function.session-destroy.php
yes
&gt; Actually, no it doesn't. When you type in the unique identifier, it's stored in the database. If you look N columns to the left, you have your sequential identifier. Aren't relational databases great? I don't use a relational database, I connect to an *existing* system them uses incrementing serials and I don't control the API where the entities are stored. I said both of those, but you ignored them and assumed whatever was convenient again. &gt;Just because they don't know or don't care doesn't mean that the security of what they're implementing remains unaffected. Just because your goals were defined by people ignorant of the risks and technical details involved in a problem doesn't magically make them not exist. I'm not talking about people "ignorant" of the risk, but people who have different **goals** than you. In my system for example, tampering with ID is possible, but it doesn't result in a security problem. Is that blowing your mind? &gt; We both know yours isn't. Am I wrong to propose a better solution? Or are you just bitter about the use of a strong tone? You're hopeless, aren't you? How can you *offer a better solution if you don't know the problem*. You imagine security issues (such as tampering the id is a problem to the system) and then solve the imaginary issues, and declare yourself a victor. I'm not "bitter", simply astounded how deep your hand is in the sand.
It's not set in stone: you get persistence-style vs collection-style as one differentiator in Repository styles, and generic vs domain-oriented as another. In my own practice I try and avoid generic naming: $productRepository-&gt;find($sku); $productRepository-&gt;add($product); $productRepository-&gt;delete($product); in favour of domain-oriented: $catalogue-&gt;lookUp($sku); $catalogue-&gt;list($product); $catalogue-&gt;withdraw($product); (obviously the specific domain language depends on the business domain experts)
For me I don't feel like a generic Repository is something that is needed, certainly not for the way I work. When I use the Repository pattern I define an interface inside my domain model that expresses the persistence operations the repository will need to be responsible for, for my domain model to operate correctly. That's the starting point. Then for whatever implementation layer (eloquent, doctrine, flat files, web service) I want to use to store those entities, I write a Repository that is an adapter that implements my defined interface. There is no way for a generic tool to capture this.
&gt; How is your password recovery advice which says "don't do it or use public keys" an example of availability? Strawman. The article said: &gt; Password reset features are a back-door. For many apps and services, they are inappropriate and should not be implemented. and &gt; Don't implement back-doors if you can help it. That didn't say "don't implement it ever". Reading comprehension is a thing. &gt; How is ignoring the goals of a system with regards to id use (entering via numpad, dictation) availability? The model I proposed can easily be implemented in any well-designed system with your requirements. Yours might "work", but that doesn't mean it's a good design that you should recommend to others. Yes, people's goals matter, but what you see as "perfect theoretical security" isn't some academic exercise with formal proofs left and right, it's simply part of quality engineering. Maybe secure and quality aren't goals, they're after-thoughts. But as I said, if your goals preclude best practices, by all means ignore our advice. Our advice will still be applicable to most peoples' needs. [Solve the 50% problem, not the 99% problem](http://blog.ircmaxell.com/2014/10/an-open-letter-to-php-fig.html).
&gt; Those are separate, and completely independent things This is not correct. Please read about adaptive chosen ciphertext attacks (search for IND-CCA2). 
This is not really repository pattern. I would call it a "helper class" that "does good job" but also introduces unnecessary boilerplate. Well, we are using Laravel here. Laravel comes with something that they call "ORM" but it is in fact ActiveRecord (I believe wrong naming is a tribute to CodeIgniter that Larvel based on early, because in CodeIgniter they claim to have "ActiveRecord" which is query builder in reality). Active Record is not good for repository pattern, using repositories in Laravel is just a weird hack and it does not encapsulate class at all. You may have your UserRepository, PostRepostory,whatever but you *CAN* still use User::find(5) and bypass your user repository carefully crafted logic, and you can do it anywhere in code, even in view :). I have created few large projects with L4 and L5, SOLID oriented, with unit tests, etc. I have tried project with repository pattern and without, and I do not like using this pattern in Laravel UNLESS YOU ARE BUILDING A REALLY LARGE APPLICATION (but if you do, you'd better decompose it to few projects anyway). So, please, all guys here, do not complicate your lives, do not use pattern with a tool not designed to do so. Either use Doctrine or other ORM and THEN use pattern or if you want stick with Eloquent then... just treat Eloquent model as both database-row-emulator and repository at once. Just make your "repository" to work as static methods in Eloquent model, and override defaults to prevent unexpected behaviour. If your user repository should have 'find' method that will fetch only users that do not have flag "findable" then just override Laravel's method "find" and insert your where there. 
&gt; This is not correct. Please read about adaptive chosen ciphertext attacks (search for IND-CCA2). Authentication is one of *many* ways to avoid this attack, and in some cases no measure has to be taken as the system doesn't provide the feedback necessary for this attack to be carried out. Encryption and authentication are separate concepts. That's like claiming salting is always mandatory when you hash, because there's an attack possible on unsalted hashes in certain circumstances. They're still separate concepts, and dictionary/rainbow attacks don't apply to every usage of a hash. Security is like cooking a meal. Pouring everything in the pan isn't the best recipe. You need to build a threat model of the system and design for that model.
You're not solving the 50% problem, you're solving the 0.1% problem. Your audience is mostly people whose job is writing WordPress themes and Drupal plugins, and you give them guidelines that are more extreme than what a bank would do. I suppose spreading subtle FUD and telling everyone they're incompetent is part of the business model.
Next you're going to tell us that MAC then Encrypt is perfectly acceptable too.
&gt; Next you're going to tell us that MAC then Encrypt is perfectly acceptable too. Straw-man is still strong with you. I was actually going to next tell people to eat babies. If you can't answer a specific point, don't bother replying, by addressing something no one said. It looks pathetic. 
Dumb yes, but *also* specific. There is absolutely no benefit from wrapping yet *another* abstraction layer on top of a repository. A repository is and should be the last abstraction layer you put on top of retrieval, else you're just abstracting for abstraction's sake. Other persistence can get more abstraction, like a command that places a new order (which can use the repository to add a new order to the collection), but as far as getting data from the database is concerned, repository needs no other abstraction.
That is exactly right, and it does look like reinventing the wheel - server side rendering. The use case here itself is not that brilliant, but the idea is to be able to reuse the same code twice. Once your application grows in size and complexity this might be more of an issue. Once you share the code, you can pre-render the first state your JavaScript application. Your front end application will then pick up from there. An alternative approach from Facebook's React: https://github.com/facebook/react/tree/master/examples/server-rendering Here are a few good articles for and against this Isomorphic JavaScript (not a great fan of that term) approach: - http://blog.neutrondrive.com/posts/252697-isomorphic-javascript-is-not-the-answer - http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/ Hope this clears out the motivations for building such a kludge.
At 10:18 when the array_diff function is added, wouldn't that then cause the function to erroneously return false if the product had optional fields?
&gt; The use case here itself is not that brilliant, but the idea is to be able to reuse the same code twice. Once your application grows in size and complexity this might be more of an issue. Once you share the code, you can pre-render the first state your JavaScript application. Your front end application will then pick up from there. I think the point is that the server and client have a distinct role in an interactive app. The server provides the data as semantic HTML, both to the browser JS and to search engines, and the browser JS handles the presentation. So there's no need to run the same code twice. One *could* organize it this way (with an initial server render), but there's no hard reason to do it this way I can think of. In other words: if you do have the same components on server and client, sure, you can be symmetric this way. But if you don't, there aren't compelling reasons to drive people to find a solution to do it this way, even in complex apps.
Sure, this is by no means necessary - as discussed in the articles. But if you want to send pre-rendered piece of more complex HTML to the browser for the initial render, then sharing logic and templates to produce a representation of that state will make sense. But this concept itself is more up for debate in general, as can be read from the articles. The overhead for this needs to be nonexistent-to-minimal for this to be worth it. And this is what the POC does, it's an example of rendering components with no changes to the developers regular workflow.
Well, it obviously can not generate an authToken. Maybe internet/network or validation problem could be the cause. Generally, error-related questions should be resolved in [/r/phphelp](https://www.reddit.com/r/phphelp) 
How can you hide persistence details from domain objects if the interface isn't written in the domain language?
&gt; Just make your "repository" to work as static methods in Eloquent model, and override defaults to prevent unexpected behaviour. If your user repository should have 'find' method that will fetch only users that do not have flag "findable" then just override Laravel's method "find" and insert your where there. I've had experience with this technique, and overall it's a bad idea. Overriding Eloquent's ORM methods to prevent unexpected behavior will actually lead to more unexpected behavior down the line and bloated models with tons of mixed concerns. An eloquent model is already pretty much a god class with 100+ public methods and 3500+ lines of code. For any project larger than a very small CRUD app or prototype, treat it as either a domain object or an infrastructure object, **but not both**. Treating it as both will lead to bloated, difficult-to-maintain class with lots of weird or unexpected behaviors.
Store files to the fucking database. This would then not happen.
Hello, I am one of the guys behind elephpant.com with @elroubio, the creator of the mascot. We have tried to sell them at the smallest price possible and this is the best we managed to do. We invested a lot of our own money and spent a lot of time to create a company (Open Goodies) to handle the elephpant project in a professional way, even though it is not something we are supposed to get a lot of money from. Before that it was managed as a small part of other companies so all the costs (accounting, taxes, logistics, ... ) were mixed with general costs of the companies behind. We try to make it more professional and safe (they are now tested for both Europe and US now), to be able to deliver anywhere in the world and to bring some fun in the PHP community. At the end of our first year (2015), 10% of our profits, if any, will be given to an OSS project. We have a lot of ideas to make new objects for the PHP community and we need at least a small margin to fund them. BTW, you can buy the Laravel one here: https://laravelelephpant.com/shop/laravel-elephpant/ Christophe
&gt; I am confused about this description. If this function destroys all session data, then why the global variables associated with the session are not unset? Why can we use the session variables again? &gt; If we read the description carefully, we can find what this function does is to delete all the data for the current session rather than the variables associated with the session. Well, that sure cleared all of my confusions!
I usually design it like this: interface Repository { public function query($filter, ...); } class MySqlRepository implements Repository { ... } The repo understands domain criteria (so it *is* written in domain language) but it doesn't construct them, it only cares about (mindlessly) satisfying them. The detail (mysql) is hidden.
I also use the domain-oriented interface, but I would call that a service and wrap it around a generic repo. I always think of the repository interface as the boundary where you would replace e.g. a mysql implementation with an in-memory one. I think that's a useful boundary to have since then you could (hypothetically) do such a replacement without actually touching business logic. If you write a domain-oriented repo, do you still have that boundary?
I get the impression that mysql in hhvm is not implemented very well, I submitted this issue in April: https://github.com/facebook/hhvm/issues/5119 I'm not sure what that issue's current status is. Even if it has been fixed and the issue was overlooked, bugs like these do not inspire much trust. HHVM is certainly interesting, but I wouldn't put it into production.
As far as book recommendations go, I would highly recommend Building Microservices by Sam Newman. I haven't finished it cover to cover but I do pick it up and read a relevant section whenever I get the "Am I architecting this the right way" thought.
Instead of self deleting at 0 you should probably give yourself a buffer. Otherwise you give the first person who sees this the power to decide if it stays.
Is there a non-insane way of using inotify with PHP and a long-running shell script listening for new files in a directory? I see examples with a while(true) loop and tests for exit conditions that *break*, is this the only way to achieve this?
I have a response from an online payment processing gateway, (moneris), which is then serialized, and later unserialized. Due to something in the serialized array, unserialize($serialized_array) returns an empty string. There is most definitely a serialized array, but it cant be turned into an array again. Is there some way to sanitize a serialized array so I can unserialize it normally? 
Yeah, you are right. I could get around that using multiple requests or something similar. It's workable though. I don't think there are 20 'php' questions per minute in SO. 
Does it fail with json too?
Err.....did you try the extension? http://php.net/manual/en/book.inotify.php Oh wow, that sets a new record for a lack of documentation. There appears to be an example of how to use it in the https://pecl.php.net/package-info.php?package=inotify&amp;version=0.1.6 // Watch __FILE__ for metadata changes (e.g. mtime) $watch_descriptor = inotify_add_watch($fd, __FILE__, IN_ATTRIB); // generate an event - this is just for testing. touch(__FILE__); // Read events $events = inotify_read($fd); // it may return something like this: array( array( 'wd' =&gt; 1, // $watch_descriptor 'mask' =&gt; 4, // IN_ATTRIB bit is set 'cookie' =&gt; 0, // unique id to connect related events (e.g. // IN_MOVE_FROM and IN_MOVE_TO events) 'name' =&gt; '', // the name of a file (e.g. if we monitored changes // in a directory) ), ); 
Misleading title, the blog mentions nothing about static methods.
Yes! base64 encode works wonders! I just posted saying similar to you.
The function serialize behaves differently on 32 and 64 bit machines. base64 encoding like /u/kyriakos said can fix it, but if it is JSON and you are using json_decode and it returns an empty string, it might not be formatted properly to decode. 
Check out [Phinx](https://phinx.org/). 
Nasa isn't exactly known for there top quality websites though right? http://pluto.jhuapl.edu/soc/Pluto-Encounter/view_obs.php?image=data/pluto/level2/lor/jpeg/029878/lor_0298787094_0x630_sci_1.jpg&amp;utc_time=2015-07-09%3Cbr%3E22:32:55%20UTC&amp;description=OpNav+Campaign+4%2C+LORRI+1X1&amp;target=STACK+EXCHANGE&amp;range=5.4M%20km&amp;exposure=petah%20was%20here
I don't think OP's separating code into layers, but cohesive modules. It doesn't make sense for the layers to be highest level structure. It's a bad practice that started with RoR and everyone's been picking up since. Modules first, layers second. Whether controllers are business logic depends on the code in them. Ideally controllers would be front-end logic, and business logic would be in a service layer. But many people don't have a service layer. So whether controllers belong there or not is a deeper topic that would require us to see how controllers are used. 
Since its a piece of loose code, the refactoring example assumes there are no business rules and that all objects should be complete. It is as I usually mention a very flawed way of validating stuff, but the focus here is on the refactoring so i let it slide.
Ah..I see. What do you mean by it's a bad practice? I don't see how separating my core domains from other layers a bad practice. Separating domain codes into a organized directory structure didn't start from RoR. It's been used since more than a decade. It's general idea. Added: If OP's intention was just to have modules, then I really don't mind having a controller over there. If OP's intention was to clearly separate his domain from Laravel code base, then the controller should not be there with bunch of other non-related classes.
Let's say you need to sort people into large offices for effective communication. You have multiple projects: Foo, Bar, Baz; you have multiple positions: manager, designer, engineer. Would you sort all engineers in one office, then all designers in another office and all managers in a third office so on? Or do you "sort" them by project, so the manager, designers and engineers working on the same project Foo are in one office and can talk to each other. Which makes more sense? I think it's obvious: project first, type of personnel second. So to go back to code: modules first, layers second. Seeing layer folders as the top level of a project is a strong sign that the project is relatively monolithic. The more the project grows, the bigger the layers become, and it becomes hard to manage. One needs to have boundaries within parts of the layers according to their domain responsibility. And the best way to have boundaries is to think if your project as many small projects communicating with each other to make a bigger whole. And the best way to express something is a "small project" is to put it inside its own folder, and have the layers inside.
Is there any good solution for my development machine's workflow? My company developed some applications on production machine, using yii framework and postgres database. The problems are those apps using SSO with saml (with yii simplesaml extension) and each app using different database schema in one huge postgres database. We plan to use git and use development machine to, well, develop. In the past, i just copy all working code and database to my local computer. Add a bunch of code then push to dev machine. Here we (5 developer) have to ssh and ... you know the rest. What are your suggestions?
I agree with you on 'sorting' stuff. I don't think I disagreed with you on the module first part. Did I? I would not create multiple directories for each layers then have the same module for each layers . I wrote to OP that it's better to separate his classes into a organized directory structure within a module (basically what you're saying as far as I understand). "I like that you have a concept of modules, but putting middleware, controller, and domain objects into a single directory is not good in my opinion. I would create domain, application, and infrastructure directories within a module directory. You just put framework specific classes into your core domain."
Yes indeed! But I am a person who programs for practical reasons. Like, I am using SOLID and TDD because it is just practical, its better. From your point of view I should divide my logic to domain, application, infrastructures, that means every module should have their own directories/namespaces with domain, application, infrastructure directories. Now I would want to ask why this is practical, whats the purpose of separating this concerns? I am saying that your point is invalid, but I would want to know why? Because whenever client asks me to change some feature, eg. modify business logic of application, I will have to change application (controllers) and infrastructure (middlewares,tasks I believe?) as well, so it is basically the same thing. I am probably missing some important point here, so if you would explain me I'd be thankful :)
The problem is that the directories are a reflection of one's architecture. The architecture is not a reflection of one's directories :) So we all would need to have a long conversation about architecture first (with specifics about the product etc.) and then directories emerge naturally.
Like @PHPPun mentioned, it's contextual. If your intention was to have a directory that have all the related classes regardless of their responsibility, my previous point is invalid since it assumes that you were trying to separate responsibilities of your classes within your module. I apology if I was wrong. Domain, application, and infrastructure were just an example. Directory structure is decided by your actually use cases, but I just wanted to make a point that having classes from a framework and your own objects is not a good idea. There should be a clear line between them. Again, since there's no actual context, I can't answer your question. It would be wrong if I do. However, why would I need to change all those three classes just because a logic changed in my application? Even if they do, they are simply placed in a different directory for better organization and intention. I personally never add a class that came with a framework or a 3rd party into my module directories whether that is a controller, middleware, or a route. Usually classes from a framework are really cheap to change as long as you don't abuse them since they usually depend on your domain objects. I don't see a big issue with your structure at this moment. The problem is that we tend to work together as a team and a project can live more than a few years. There are many future developers who will put their classes into the same directory without considering responsibility of classes because that's how it is structured. After a few years, such modules will be big and very hard to maintain. I would not even separate a directory if I were just testing my idea. I don't really care architecture or whatever it is called when I'm just testing my idea. I just want to see the result. When I'm certain that my app will live for a long time (When we re-write an already working application), even if it looks a little bit over engineering for the current use case, I will do my best to future proof my design for myself and any future maintainers.
My boss: nahhh, it's ok, it still works. No?
Is there any easy way to find the balance between stability and being up to date? Finding it hard to know when to update
&gt; It's time people realize that the most effort they put on questions they ask better and faster responses they'll get. Someone really needs to learn their grammar. &gt; It's time people realize that the more effort they put into the questions they ask, the better and faster responses they'll get.
Thank you, fixed.
So basically do it like you should do Windows, wait for the first major update and then just keep updating?
Seems nice, but I have to wander, how do you fetch data with python and submit to database using PHP? This is not like html-php or javascript-php thing, they are 2 different languages and can not reconcile the two.
You're using a nerdcast shirt, lol. Awesome talk, btw.
I've been working a little bit with Silex after having learned Symfony, but i'm having trouble understanding middleware or even finding examples of middleware or how to use it. Can anyone explain it to me?
Well it's mostly compatibility I guess, since not everything instantly supports new versions for deprecated things that were finally dropped.. Idk, is there really any issue?
Red Hat/CentOS will still be supporting it, right? They've got 5.3 listed here with maintenance till 2020 and 5.4 maintenance till 2024: https://wiki.centos.org/About/Product
CCK looks bloody awful.
Rest in Peace good soldier! You will never be forgotten!
You could've said "Cloud 9 is a cloud IDE, not cloud hosting", and I'd understand. You wrote an article in there. :-) The solution is then find why the app needs a "real" server and emulate it in "php -s". I've done this. In my case, it meant serving static files from the PHP script. That's about 80 lines of code which you can reuse for all your projects. Other dependencies will likely be similar (say, mod_rewrite rules can be ported to a few preg_match() lines). If you mention how your app breaks, I can give a suggestion. There's nothing you can't do in php -s.
I mean it looks good.
Correct, they will be supporting it. 
Thanks, saddest part is that we are stuck at 5.2 or 5.3 due to our use of Joomla (1.5) /weeps/ Hopefully this will change in the next couple of months if things stay on track.
Does 1.5 just outright refuse to run on 5.5? We're using CakePHP 1.3 on 5.5, something I thought would be difficult. Turns out, it wasn't :)
I really wish Enterprise Linux distributions like CentOS would offer several versions of PHP rather than older and out-of-support versions. CentOS 6 still only offers 5.3, CentOS 7 offers 5.4. At least with Amazon's Linux AMI (it's very similar to CentOS) they give you a choice of either 5.5 or 5.6.
Of policy so far: we update when a customer sends a security alert because of old version when they are doing an audit. Worked so far. 
Time to bump the minimum required version on my next releases of my libraries. Generators are so useful! Thanks again for those, /u/NikiC.
Joomla 1.5 :( I'm working on migrating their infrastructure right now to something a bit nicer and we are working on code upgrades as well but there is a lot and their service was built up on top of Joomla many years ago so prying them apart isn't an easy job. All new services/API endpoints are getting written in Laravel 5.1. Additionally, they were still running suPHP instead of fast-cgi, Apache 2.2, and MySQL 5.1. Pretty much they got the site/service running and never upgraded anything after that.
Yes. The changes introduced will typically be purposeful deprecations introduced by the recent minor/major version. So you will have to make the same changes in your code whether you upgrade to PHP 7.0.0 or 7.0.9. 
Wow I really dig that policy structure from that gist. I'm planning on using Laravel's built in authorization + traits for redundant `isMemberOf`, `isResourceOwner` type of checks, but can I see how you made that array of callbacks for authorization?
You mean two modes of a content page or something? I'd build read-only first and then add controls for editable, but the question is pretty vague. Can you explain more?
Is this a good way to handle basic dynamic URLs? 1. Create a slug field in the database and create a URL with numbers, letters and dashes. Like Stack overflow. 2. Grab the slug from the URL using get and URL rewrites in htaccess. 3. Remove any characters from the get parameter that are not numbers, letters or dashes. 4. Search the database with for the sanitised slug value? I'm currently using ezSQL for PHP and not sure if it has any function like this built in. I'm not sure if it has pdo functionality either. I'd like to hear your ideas.
&gt; You're asking for something that can satisfy an interface while at the same time subverting it? No, this is not true: I have three types of classes: 1. A PolicyContainer that takes N configured policy definitions and policy responses 2. A Policy interface 3. A PolicyResponse interface From that, I want the following type safety behavior: 1. I want the `PolicyContainer` to reject attempts to use a non-`PolicyResponse` object, hence the `PolicyResponse` interface. 2. I want the individual `PolicyResponse` implementations to reject attempts to pass in `Policy` types they can't handle. **For example, a `DeletePostPolicyResponse` should only accept an instance of `DeletePostPolicy`, but still be considered a valid `PolicyResponse` by the `PolicyContainer`.**
Slight correction: if(password_verify($entered_password, $password_hash_from_db)){ if (password_needs_rehash($password_hash_from_db, PASSWORD_DEFAULT)) { // $password_hash_from_db was hashed in a way that is no longer considered good practice. // Call password_hash() again and store the result just like you do when the password is set the first time } $is_logged_in = true; }
Yeah, my bad, should have included that myself. This just shows the many benefits of using the built in password function. No need for writing redundant code, and it is reliable and secure.
One thing I could think of is: interface PolicyResponse { public function handlesPolicy(Policy $policy) public function checkPolicyError(Policy $policy) } Your `PolicyContainer` would then only invoke `checkPolicyError()` if `handlesPolicy()` returns true.
Thanks for the response, as PHP7 approached I feel a lot of pressure learning some of these new designs and I guess it's safe to say leave it alone until it gets unavoidable.
Don't rely on $_SERVER['HTTP_USER_AGENT'] - very easy to fake.
I'd be interested to learn of a use case for using them (except the coroutine-multitasking thing)? (haven't met the need yet, but maybe it's because I didn't realize they could be useful)
Understandable but there is something to be said about ease of use for the customer. Also if you do auto lockouts after 5 password guesses brute forcing isnt a problem (unless they steal your db).
What's the alternative? This is just the default value.
Press for change, worse case scenario if it fails you'll get fired/resign, which ultimately is what you should do anyway if you don't get anywhere. It makes it difficult when you have a good working environment with your team, but as a graduate you should be looking to get as much experience in as many different technologies as possible, or at the very least, get at the leading edge of the technologies you're working on.
&gt; are there any working examples of using PSR-7 in a standard application (skeleton) [Radar](https://github.com/radarphp/Radar.Project) and [Spark](http://sparkphp.github.io) are two.
it is stored in the db, yes. Base64encode() is a really good idea. 
good idea, possible, thanks. 
Server-Side there is no reliable option, unsure on client-side. It will be correct in most cases, just don't expect it to be correct all the time, since it can be faked easily as eurosat said.
A lot of it is going to depend on how open to change your workplace is. If your workplace is not open for change, start job-hunting... If they are open, take time assess the situation. You will look like a rockstar if you go to your director / PM saying that we should change because we can save money. Upper management is always looking for new efficiency. Come up with some numbers and ask them for a time to present a new change you want to make. It literally will need to be like a business pitch. Some quick stuff you can try. if we use vagrant, we can cut our development time by x hours. Explain where the efficiencies are. if we move from wordpress to X technology to Y technology we can decrease development time by X%. Bonus points for finding white-papers that support your cause. Do Not Be Disappointed if they tell you that they are not looking to change immediately. Change takes time and they will need to evaluate everything. Most of the outcome will depend on how you approach your managers. Remember they are very cost focused. if you can tell them we can use X technology for free to save Y time they will be 1000000% more responsive than by quoting some "php" guy off of the internet. And for the conferences I have never seen any added value there at all. If i have questions or want comments on a particular problem, I have reddit and irc to fall back on. pmjones's twitter and blog can be quite enlightening.
OP said good.
&gt; Try doing a base64_encode on your serialized string before storing it or sending it elsewhere. Then do base64_decode before unserialize it fixed my problem instantly. I am going to try that. 
I need it for my [other project](https://github.com/FlameCore/Gatekeeper) to see what the clients pretend to be. Then the request gets analyzed to tell if the visitor speaks the truth about the user agent or not.
Will do thanks!
Yes perhaps there is not much more to it than that.
Thanks. Within the next week I'm leading the migration onto a virtualized infrastructure behind a load balancer leveraging fast cgi and nginx to increase performance and get us in position to test and implement new versions. I also have all of our new API endpoints getting written in Laravel 5.1 using PHP 5.6. Someday we'll get everything cleaned up, but I'm just hoping that soon we'll get out of the gutter.
As others say, you need to press for change. How much dev work does the director do? If you're the lead, then you should have a say on the tech stack at the company. If he doesn't do any development any more, then you have a stronger case. Make a plan of what the company should do (composer, frameworks, dev/production hosting etc) and find a business case for each of the points. E.g. "Laravel/Yii/ZF will enable us to complete projects 20% faster because x, y and z". Subtly point out that the company will be left behind with the current way of working. I don't think you need to write swathes, keep it simple. Show it to him and organize a meeting for you to discuss, possibly away from the office. See how this goes. Hopefully he'll come round, but don't discount the possibility of getting a new position somewhere else. 
I personally didn't like CakePHP when I tried it but that was some time ago, support for it was quite low at the time so not sure how that has changed. I've used Yii a fair bit and v2 is vast improvement on 1 and a good framework to get quick results from. Phalcon is super fast really for micro instances and under heavy development so that gets my 'new kid on the block' vote. I find Zend Framework 2 fiddly and too elongated, great for corporate projects perhaps but I would not use it for a personal project. Not sure if thats helpful or not.
Can you give some examples as to when Laravel wouldn't be an option? Edit: Apparently I need to clarify this question. Frameworks are pretty interchangeable, in that you can use whichever suits your development style and goals. If you can use Laravel, you can use pretty much all of them. Now, if you have a situation where you *can't* use Laravel, it would be nice to know *why*, so we could recommend an appropriate solution. This had nothing to do with Laravel being a perfect solution that can do anything...
yeah but 90% of the time an app is some basic CRUD level stuff, and when it's that complex this question makes sense
Haven't tried it myself, but many of the online IDE's use [firepad.io](https://firepad.io). [Examples](https://firepad.io/examples/#code-6y0G5yKkl4)
Same here. I've graduated from a university. Before the graduation I've worked here few times in summers etc. The company wasn't using any version control. Deployment was done over FTP. I've asked to move to Git but the owner of the company said that it is waste of time. Eventually I've made everyone use Git, Bitbucket, Hipchat, and Deploybot. There are no more than 4 programmers or less than 3, the owner, and a salesperson, owner's wife deals with taxes etc. Some of our customers are in top 100 in Turkey. Now, I ask him to let us move to InnoDB because MyISAM is like prehistoric engine. He says that they had problems with InnoDB thus we should stay on MyISAM. I've suggested to sell our product to foreigners, he said that "we have to talk with custemer etc, there is language barriers etc, blah blah blah". I'm sure I can learn more in other companies. Until the end of the year I'm either leaving or I'll open my own company. I've done my best. It looks like the owner of the company has no plans to get bigger, he likes it this way. Some one here on Reddit or Hacker News or programmers.stackexchange said to me something like this: "move on, some companies are successful and some are going to fail. It is not your problem, it is management issue."
Symfony has great documentation and a strong community (especially on IRC), two key metrics when evaluating any external dependency.
then the answer to such question would be *. Even a simple php file is good enough for CRUD. People really need to ask a better question. https://www.reddit.com/r/PHP/comments/3kw62f/rtfm_read_this_freaking_manifesto/
PSR-7 middleware is basically a protocol for allowing things to plug into the middle of the flow from HTTP Request to HTTP response. So this could be things like routers (if the request has a certain URL format, run this controller command, then return the result as an HTTP response), authentication (if the request has the right cookie, authenticate them, otherwise return a 401 Not Authorized) In practice, I'm surprised that there's so much talk about it. In general, I don't personally think there will be an awful lot of use in the protocol, once a routing component grabs the HTTP request, it will probably want full control over the HTTP response and there isn't much use in having "hot-pluggable" middlewares operate on it. But maybe I'm just not experienced enough to have seen places where this works. Here's a github repository listing some common PSR-7 middlewares with basic implementaions: https://github.com/oscarotero/psr7-middlewares You can see that each suggested tool somehow plays around with the HTTP request, and would affect the response in some way, and the idea is that a dispatcher would run each request through each middleware to figure out what the "correct" response is. 
I liked the Cake 2.x Easy to do simple things ( much easier than Laravel). Never used for larger projects. It depends, you know? If you want a fast to make it run and to template, ultra-high-compatibility with servers and for some blog-cms-type site, Wordpress is the best choice. If you want to make an eCommerce easy to start and with a short deadend, Magento would do fine. If you want to do a high scalable project, Symfony would be my choice. It depends of what do you need/want. I used to work with Java and using Spring + other stuff for a simple blog is overkill in all ways imaginable.
I never said so, I just explained the reasoning of eurosat and stated that there is no alternative.
Yii is good
I highly recommend [Prism](http://prismjs.com/), which is JavaScript based and works great for PHP. We use it on all The PHP League sites. For [example](http://glide.thephpleague.com/1.0/config/the-server/).
"What are you talking about? We'll just restore it from backup like we did last month when the landing page was replaced with gore".
The support period is not enough. developers release projects in less than a year like 6 - 9 months. Then you get two years to maintain and release features and bug fixes for your project, but the last years you should be running alpha versions of php and moving your project. I could understand that for wordpress users is easy to get with php, but for a ecommerce or a web app in php it does not look okey. But probably those people are already considering on moving to an more long term supported language. 
Just last week I updated to PHP 5.5 on my cPanel.
Nope!
Oh nice, that's actually a huge improvement. Massively less of a pain in the ass than what I currently deal with when building s bunch of stuff locally that isn't ready to go online anywhere yet. 
Please checkout my channel and support me! :)
Personally, I would have jumped ship ages ago. I did a 6 month stint at an agency when I first started in PHP, it wasn't all that bad, but some of the practices were clearly heading more on the dated side. The company I work at now is mostly modern technologies thanks to an accomodating upper management and a proactive lead dev. If you've been there 4 years and still can't push through changes then it's going to be a continuous uphill struggle. Most importantly i'd be really concerned about my own personal development too as the work you're doing is probably not taxing you. Anyway, you're young and presumably don't have huge commitments outside of work. Don't be afraid to just get up and leave. There's a fairly decent demand for web devs right now so just go for it.
I think it'd be pretty obvious that the passwords were MD5 if hackers ever saw them...
No guide/screencast etc in the world will tell you which one is the best for YOU. Why not try a couple to see which one you like? You'll learn along the way too.
There is none, this person just has no idea what they're talking about.
I've once been working in company that used old technologies (codeigniter) for about 5 years. finally I have moved to very different location in my country and had to change work. after that, Ive started working in new company and after a 1 year I've learned sass,gulp,grunt,responsive web design, a lot of css, solid programing, symfony framework, laravel framework, node.js, mognodb, test driven development, knockoutjs, typescript etc (ofc I ma still learning, nowhere near being expert). in only one year I made a lot of progress because I met new technologies in my new company. And I feel like I totally LOST previous 5 years, because I wasnt making any real progress then. So my personal advice, gtfo this company and look for one using better technologies.
Can we use versions with it?
&gt; More like, doc when I'm not feeling well what is the best way to get better? Most of the time a painkiller will do the trick. Describing a framework as a painkiller is even scarier. :-) Painkillers are uniquely broad as a class of medication. You know why? They simply turn off your biological error_reporting() in order to hide the problem. They don't fix it, so the problem can get worse and worse, until it can't be hidden anymore. I can't be so cruel &amp; say frameworks are like that, although the popular ones do tend to make certain poor practices bearable, until a point of no return, that we euphemistically call "legacy code".
While it may not be for everyone, I've had much success using SaaS products instead of trying to manage it all myself using Capistrano, Ansible or the the like. The biggest challenge wasn't even the configuration (which can be nightmare), it was onboarding new developers. Dealing with permissions, keys, passwords and the like can get unwieldy in a real hurry. If you're working with small to average sized projects, my recommendation is to spend a few bucks, and use something like [Envoyer](https://envoyer.io/), [Deploybot](http://deploybot.com/) or [Codeship](https://codeship.com/). I actually gave a talk on this at Midwest PHP earlier this year. If you're interested, the slides are [here](https://speakerdeck.com/reinink/practical-deployments-for-average-projects).
Yes, if the versions are properly tagged in the git repository.
Our deployment process is so simple that we've kept it to just using [rundeck](http://rundeck.org/) to execute a `git pull` on our servers (currently about ~40 all told but only ~10 of them are web-nodes). So long as you keep your .git folder above the webroot and haven't committed any sensitive information to your repo then you're okay and purists be damned. Initial server set up is done with ansible and configs are kept in that using ansible vault, if we have a config update we update ansible, push it, and commit it after vaulting. 
It looks very good for a project with a few local repos, because you have to clone sub-repos first (imagine with 10+ dependencies and with 5 developers on your projects, you have to clone manually 50+ repos). With micro-services dependencies, it seems to be a pain to handle this without existent plugins like [Shared packages plugin](https://github.com/Letudiant/composer-shared-package-plugin) or [Studio](https://github.com/franzliedke/studio). This is a great improvement to avoid using plugins/third party apps in the future with a full Composer bundle.
I know, but money. You know. 
I'm not sure how composer reads version information from SVN (is there an equivalent to Git tags?), but it should work just fine.
Agreed, that immediately stood out to me as well when I set was configuring it for the first time. I'm hoping they'll add this in the future.
I actually use docker to deploy. I set config variables using https://github.com/kreuzwerker/envplate at runtime. When I push an update to the docker repository, the docker servers are set up to automatically pull and recycle the instances. I tried a few deploy tools in the past and never liked them. Switched to docker and haven't looked back.
Same here. With the added bonus of really bad management and no planning. This is a very dangerous combination. My boss goes over the planning done by the technical manager, promises worlds of functionality to our clients, and changes the project all the time. On top of that, he discards the improvement of the code, the use of new libraries / techniques and requires the quickest solution all the time. Every time I have to push code to a project, I find bugs, a mess of my own code and lots of copy-pasted stuff in the API's. There is stuff I don't even want to call "my work", just because the code is a complete utter mess. The only progress I make is outside work hours, and every time I use new tech, he warns me that all the extra time I "waste" learning how to do things a different way, is on me.
I'm not sure I like this approach. When returning to a previous version of my software in Git, I would want to see the version of the dependencies (local or otherwise) I committed, not the one I've just been using. If I am regularly moving between different versions, I don't want to `.gitignore` the `vendor` folder, else I'll have to keep using `composer update` every time I `git checkout`. I would rather use `composer update` every time I update my local dependency (which will be less often), and keep my `vendor` folder in sync with each commit.
I never say that my code is unmaintained. 
toran proxy could do this i think
I posted some detailed info on middleware in a thread a few weeks back: https://www.reddit.com/r/PHP/comments/3ikfnc/zend_announces_expressive_a_minimalist_psr7/cuhmfz0
I think this might help you https://developers.facebook.com/docs/graph-api/reference/user/photos/ :)
Dang, thanks!! I searched through the graph API and couldn't find this... You rock!! 
To add to /u/Turtlecupcake comment, you can't have a "members-only" area with Amazon S3 alone, since that wouldn't be static. You need to look into an alternative such as renting a VPS or using a service like Heroku.
This is great. No more needing to constantly `composer update` when developing on a module dependency. Small pain but it was real.
I've used Aptana Studio 3 almost exclusively and have for years. Really good IDE for my needs.
https://github.com/FlameCore/UserAgent/pull/1 This should do the trick. I implemented /u/akeniscool suggestion of making the object immutable with static factories, added 'Links' to the list of known real browsers (Links is a unix text-mode browser - lynx is the windows equivalent, and somehow it was listed, but links wasn't), and made a minor modification to the README on the install section, to reference the `dev-stable`, since you don't have a stable release tagged. All tests are passing.
Go to Facebook &gt; Settings (https://www.facebook.com/settings) Click the *Download a copy of your Facebook data.* link. It includes all your photos.
All except for the pictures that your tagged in... That's the only reason I'm not going that route :-/
There's a function that does that in [Symfony/Filesystem](https://github.com/symfony/Filesystem/blob/00e0462cfe48c7fdd142d0867e827cb0d17e4e23/Filesystem.php#L327) component.
Thanks for this, I was supposed to be sleeping and decided to watch a few minutes... watch the whole thing and spend the next few hours lying awake thinking about refactoring code ;) great talk though. I don't think I'll ever get my head around the read side of event sourcing - even though I love the idea of it.
The use case is when you're developing a separate component, like something that will be a composer package. You don't want to have to commit every change you make and run composer update just to check it works OK.
I was thinking the same but since OP was including files manually it seemed, I assumed he wasn't using Symfony.
[removed]
For starters, an api should have all it's public methods documented. With so many references and methods that return references it's very difficult to figure out exactly what's going on. Any reason in particular you chose to use return references?
We've been using Deploybot with overall success at my agency. It has worked well for basic deployments. It does have a ceiling when your deployment process becomes more complicated, but that can be said for a lot of tools.
IntelliJ IDEA (PHPstorm) is my go to IDE (and also for all my coworkers)
*RE: Any reason in particular you chose to use return references?* Yes, returning a copy would mean copying the entire hierarchy inside the target used in the Pointer. When a operation is applied via a Pointer, it is meant to affect the original target. $target = ['foo'=&gt;[]]; $pointer = new Pointer($target); $pointer-&gt;set('/foo/bar', 'baz'); is meant to behave exactly as: $target = ['foo'=&gt;[]]; $target['foo']['bar'] = 'baz'; 
Thanks for the borderline spammy email you sent regarding your project. If you were looking for developers, at least type out something else than just a copy and paste of your homepage / twitter. 
I just started getting confident to the point that I can solve issues on my own. So I decided to volunteer for an organization that needed a large amount of work done creating an entire system to capture and store volunteer information for various reasons. We had a go live date that came up way faster than I expected and we had to go. We launched and it worked, but I had a few warnings on go-live, and a login failure, however the hours were young. Managed to fix that within the first 6 hours and things just started to work. Learned a lot on a real piece of code and not just a test environment where there were people filling out forms like people fill out forms
The homepage tiles are simply perfect.
Thank you. That was really good information to know.
PhpStorm
I use RapidPhp. It gets the job done, and a friend drunkenly bought it for me when we both were looking for ides to use. However, I don't like it. I do not enjoy the fact that I can not declare my own functions, but I do like that it reminds me of what every function does. I like it's built in ftp, because my other computer serves as the entire home's server. It is great there where others lack. I like that I can color everything the way I want it to be, but there are too many bars, and I cannot customize the ui of the ide. I like that I can run remote queries, but it is rather lacking there in ui. I wish it would give me auto completion for if, foreach, while, class, etc. Just as Atom does. It really is a love/hate relationship with this thing. If it did not have the reminder of why each function was, I would be looking for a new one. Everything I have tried so far just does not fit what I feel is needed.
my first ever script? The Google GET requests were about 50x my bank balance.
They all do allow community-developed plugins. I use Eclipse (Zend Studio).
In other words, you're treating local variables as if they were objects?
Personally I'm not sure, I didn't actually write any of code, I was just subscribed to a GitHub issue relating to this and when the PR was merged and no one else has mentioned it here I thought I'd share with you guys.
Made a fairly functional forum for school friends back in 2000. Used all my prior learnings of ColdFusion and translated them across as best I knew. Stored all user data in cookie. Posted peoples uuids in dropdowns to message each other, change uuid, change user. Got hacked by my school nemesis. Posted on frontpage that I sucked. I re-live the experience every time I run a TinFoil scan or go for code review. :(
There is really not much of a chance to push better practices, and for a reason actually. Agencies focus on the end product and deadlines, if a project price is fixed tue faster they finish it the larger the end profit (since the spare time can be used on the next project). Code quality is rarely a factor there, and you wont change that. So first try introducing things that save time, those will usually fly by any management. 
&gt; The framework application class will extend the container. Its preferable not to use inheritance here. A container is the *environment* of your application, it's not your application. It's not out of the question you may end up needing two containers for two modules in your application and then you'll regret using inheritance (say, public site, admin site). I suggest composition: class App { function something() { $this-&gt;container-&gt;doThing(); } } &gt; The way i see it the alias keys are the 'interfaces' on top of that the dependencies that are used implement contracts so when i work on changing the class the contract still defines the class requirements. When designing a method for specifying dependencies, think "would I do it this way, with aliases in an array, if I had to instantiate those classes manually"? You wouldn't, right? It's not a very convenient way to have to loop an array, read strings and match them against parameters in order to create something. It's only convenient to your container. A container should simply be an *aid* in creating *regular* classes that specify their dependencies in a *standard* way. Deviating from this still works somewhat as you show, and other containers do it as well (with annotations and what not), but you also lose some of the benefits of dependency injection, namely container "neutrality", and ability to instantiate classes that *you have not authored yourself*. Think about it: someone else's class won't have aliases. Will you be able to instantiate through the container? Nope. Container instantiated classes, including your classes, shouldn't be aware that there's a container outside that's going to resolve its dependencies. If you design your classes like any other plain PHP class, and your container can handle that, it means your container *can handle any other plain PHP class*, that you get, say, from GitHub somewhere. &gt; Do i need to create a contract/interface for EVERY class that i create including controllers, or are interfaces used on classes that are dependencies only? We have a bit of a language barrier issue here. Can you reword this question?
Phil stepped back from PHP a while ago ;) He still does it, just wants works on other stuff as well. He probably got fed up of people claiming he was trying to take over the world.
I was about 13 and made a website about counter-strike, I could post news and I just echoed $_POST['title'] etc, I didn't know how to actually write into the database so I gave up for a while.
&gt; Most existing containers don't require you to write you class in a specific way. That's a mistake I made myself when making PHP-DI (the first version): it would only support annotations. Because of that, every code I would write was coupled to this container (and to annotations). That's why in the next versions I made this completely optional and made an effort to make sure developers don't have anything to do in particular in their code to make it work with the container. That's interesting &amp; refreshing to see people realize the architectural issue of embedded annotations in classes for DI. Many PHP, Java and C# frameworks are still making this mistake (it's even a JSR standard with Java). How does PHP-DI propose to disambiguate same-typed, or untyped parameters in a constructor though? Like: function __construct(PDO $userDb, PDO $postDb, $useCache, $useStrictMode) {}
Answering the last question first: &gt; How does PHP-DI propose to disambiguate same-typed, or untyped parameters in a constructor? When you reach that situation autowiring stops being useful and you end up with the same solution as with other containers: you have to use [configuration](http://php-di.org/doc/php-definitions.html) to set up your dependencies. Same if you don't want to use autowiring: you can use configuration all the way just like with Symfony for example. &gt; Many PHP, Java and C# frameworks are still making this mistake (it's even a JSR standard with Java). Problems with `@Inject` (or related annotations): 1. code coupled to annotations 2. code coupled to `@Inject` of a specific container 3. classes cannot be instantiated without the container, which is a problem in tests I don't have a big problem with 1 even though in PHP annotations are not really an official stuff, and some people have a big problem with it. Anyway, if annotations are part of the language, that's a non issue IMO. The second issue is a bigger problem, but it can be solved through standards. That's why I think Java's JSR for `@Inject` is useful. You can switch containers and it will still work. That's why [I suggested that in container-interop](https://github.com/container-interop/container-interop/issues/27), but since not many PHP containers use annotations that might not lead anywhere. The last issue is the biggest. And that's why I don't recommend using annotations in code that you would test. However I don't *unit* test controllers (they don't contain any application logic). I don't unit test my (integration/functional) tests too. So using `@Inject` in them is fine IMO. All that to say that I believe annotations still have a valid use case. It's just a small one, and probably not for everybody.
Trying to make work some mods on a PHPbb forum, good times.
PHPStorm is bugging hard in our projects (tested with the latest EAP). Says that method and variables don't exist when they exist in the extended and instanced classes. We have a proprietary framework, but it shouldn't have these bugs, our autoloading logic is very common (Zend Studio doesn't have this problem, it always finds all the methods and variables). But I agree, in my personnal projects, I enjoy it a lot. My top 3 : 1/ PHPStorm (when it works) 2/ Zend Studio 3/ Notepad++ (I know, not an IDE...)
Built a stock ticker for a Canadian bank in 2002. I introduced PHP which at the time was all java. It was only for simple intranet newsletter site but it was a real-time ticker ;) 
Thanks for the insights, /u/Auburus. For next project i think my employer want to use Yii2 or something, so perhaps using composer is a viable choice ^(next ^time).
&gt;I managed to get by with vi for the longest time. I also used Vim quite a long time. There are lots of good Vim plugins to make it a really good IDE. And things like Vundle make it easy to manage plugins.
I started from HTML, php-fusion because we had very good community of it wich still exists: http://www.phpfusion-lt.com/ I got my first 600lt (~150$ at that time, i was 14-13 maybe) for making local newspaper webpage on PHPFUSION!
Considering objects always get passed by reference, yes
I was referring to interfaces for classes. If it is necessary to create an interface for every controller, every modal, etc. Basically when should an interface be made, for what type of classes, all of them, or just classes that are used as dependencies?
Downloading code from hotscripts.com, looking through it and learning from it.
I agree the docs need a lot of love, as for into worth getting into I'm not so sure, will be interesting to see what they do in 3
&gt; I was referring to interfaces for classes. If it is necessary to create an interface for every controller, every modal, etc. Basically when should an interface be made, for what type of classes, all of them, or just classes that are used as dependencies? Let's start with no interfaces. That's our baseline. Nothing *has* to have an interface, whether dependency or not. From this point on, interfaces have essentially two complementary uses. 1. A potential class has multiple written implementations, you want people not to care which implementation is running the show: make an interface and have all the classes implement it. 2. A class has no implementation at all (i.e. there's no class), you ask that the caller provide the implementation for you, by asking for an interface that you wrote, and some caller-determined class should implement. In the first example, you write the implementations, so you can determine over time if a group of classes can have the same API (a subset of it at least) and need an interface. In the second example, this is inversion of control: you ask for it, but you don't care about the implementation and you don't know, from the PoV of the instantiated class, about a class that implements that interface. You don't know and you don't care. Not your issue. This aside, you'll also be requesting specific classes as dependencies as well, and that's also ok. Interfaces can be a technique for asking *for less*. Let's say you need an ORM for your ForumApp. You can ask for Doctrine, that's ok, but if you only ever end up using a few basic features of it, and not all of it (Doctrine is very complex) it can be better to make a simple interface with just what you need: getPost, setPost, addThread and so on. This will allow the caller to implement this via Doctrine, or *something else*, which makes you more flexible.
Regarding performances, we both know reading annotations can be cached. Containers can also be compiled. For example in PHP-DI both PHP configuration, autowiring and annotations has the same impact because they are all behind the same cache (I'm also playing with compiling the container lately). &gt; And inability to instantiate manually is not just an issue for tests, but any application which prefers to compose classes itself without the heavy abstractions of an automatic container. Yes, but you don't always need to do that. For example in integration/functional tests, it's pretty useful to be able to create a whole environment (container) and inject some services in the test class with `@Inject` instead of writing a `setUp()` method. I've never needed to instantiate PHPUnit test classes manually. Same for a quick and dirty micro-application that you are writing to solve a small need. Just like small CLI script utilities, all applications don't need to be written with SOLID and OOP. E.g. if I want to write an application called by a GitHub webhook that will trigger something like a CLI command, I don't need to overthink it.
&gt; Regarding performances, we both know reading annotations can be cached. Containers can also be compiled. For example in PHP-DI both PHP configuration, autowiring and annotations has the same impact because they are all behind the same cache (I'm also playing with compiling the container lately). They can be cached, but this often doesn't eliminate the overhead, it merely makes it tolerable (to a degree). We should be comparing the *cached* code with the complexity of *clean, "plain PHP"* solution, to really say if there's a cost to it or not. There is a theoretical way to compile container magic into very, very lean code that's equivalent to the simplest plain PHP solution. But I haven't seen containers which quite do it that way. And when they do, it makes you wonder... "why not write it in plain PHP directly"? Especially when in some containers the container configuration ends up *more verbose* than the compiled code, and harder to maintain (no refactoring, no static error detection, no autocomplete, hard to follow or implicit rules, etc.). &gt; Yes, but you don't always need to do that. For example in integration/functional tests, it's pretty useful to be able to create a whole environment (container) and inject some services in the test class with @Inject instead of writing a setUp() method. You don't really need @Inject for this, I think? It's a matter of organizing code well, not about annotations, reflection and codegen. If you're interested, paste a sample making use of what you describe and I'll refactor it to plain PHP with the same benefits and terseness. **EDIT** Funny thing is, in my projects, I literally have a class called "Environment" which creates the entire environment (both for tests, dev, and production). So I think our mental models of this align well. 
[removed]
When I was 19-20yrs old I was doing a internship at a secondary/high school as a system admin, but what they really wanted was a website. I ended up making a entire CMS from scratch with logins for all the teachers. For each class (math, science, economics, etc) they had their own page to edit for each of the three education levels. Teachers could also upload files which would be downloadable from the class-page, which they gladly used for tests/quiz docs, required reading material and so on. For the students I made a form where they were able to search on their student ID and find their personalized class roster/schedule and rooms/date/time of exams. The scheduling software the school already used could output shitty html pages of rosters (literally hundreds of files), but I was able to process these files using php to make the info readable. Lots of regexp filtering going on, it wasn't pretty but it worked just fine. I also created a script to display multiple pages of daily news/rosters/schedule updates, which was then displayed on TVs throughout the school. This was maintained by the scheduling staff guy who liked it so much, when he got a job at a different school he hired me to do the same thing over there. The school where I did my internship used it for about 5-6 years, then had a new intern create another website from scratch. It's now just a bunch of static html pages and they've lost all functionality. Probably for the best though, I doubt my code was really secure back then as I had never done anything like it before. The code was a mess too, in part due to the never-ending stream of requests and ideas to add. A hideous cake of additions upon fixes, changes and more additions.
They're declared using php comments because that was the only way that it could be possible in PHP without the support of the internals. `and you cannot remove or edit the comment and be sure that the code still works.` That's because they're interpreted as annotations, you should no longer call them comments. If you delete an annotation in python, you'll see the same result. I don't what you found unexpected in this behavior.
Regarding performances, what you describe is the overhead of a container with plenty of features. Annotations or not is not the question. &gt; And when they do, it makes you wonder... "why not write it in plain PHP directly"? That's a good question and I try to keep it at the core of what I try to do: make the whole thing more practical, stop when it's not. Writing initialization manually for all services is not complicated. It's just boring. For some devs it's not an issue, and that's fine by me. There is nothing wrong with writing everything manually. But for the same reason that ORMs, form builders, etc. exist, some people would rather like to avoid having to write all that. That's why `@Inject` in a test class saves you maybe only 2-3 lines of code, but once you've tried it it's just so pleasant to use. And it's not less explicit. &gt; Especially when in some containers the container configuration ends up more verbose than the compiled code, and harder to maintain (no refactoring, no static error detection, no autocomplete). Agreed, that's a very valid question. There's a balance to find between custom DSL/YAML config/etc and "just use damn PHP code" (for example in a closure). But IMO the balance exists and can be found. For example (PHP-DI's syntax): Authenticator::class =&gt; object(TokenAuthenticator::class) IMO nicer to read and write than: Authenticator::class =&gt; function (ContainerInterface $container) { return new TokenAuthenticator($container-&gt;get(LoggerInterface::class), ...); } But I can understand some people prefer the 2nd. I know it's impossible to satisfy everybody :) And if the configuration for this service was 10 lines long (because of many things to configure and inject), then I would probably switch back to the closure (because the PHP code would be more readable, and refactoring-friendly).
It wasn't my first php experience, but the first codebase of php I was given was a complete mess. We eventually threw the whole thing out and started again with cakephp.
I meant adding constructor injection to handle vendor classes ( wont be specific to vendor classes just an example ) but keeping the var list to meet my preference for the app. This will mean i would have to keep this implemented in my container, app, or injector but for me at least i feel like the trade-off is worth it to simplify classes ( less bloat of large constructs setting data etc. and i can config if needed ) i mean the issue with it is that i cant typehint? so the alias key could be anything since the interface isn't forced? What about di is it that i am missing/losing out on? 
Totally. There is no one right answer for this. I have a ton (50+) small sites I maintain, and I have them all setup using Git. I jump into these projects every few months (or even years), and I really don't have time to figure out all the deployment information (and credentials). A tool like Deploybot allows me to just get work done. I simply push to master, and the deployment is handled by them.
My first project was a simple web-app that I used to log my foreign language reading and listening practice. It sounds simple, but I learned a lot from it: reading get/post requests, generating HTML structures, reading from and writing to an SQL server (and even sanitising inputs) as well as user authentication (a bog standard one with usernames and hashed passwords stored in an SQL database). It was a bit frustrating, but not as frustrating as my first experience with Javascript and its lovely asynchronous functions.
Didn't know databases yet, created a personal website which rendered pages based on content stored in XML.
You mean an MVC that uses a model for each action? I hope not. The most basic MVC that uses that file structure will be one you write with that file structure. Grab composer and a few packages. FastRoute + Illuminate/Database + Some template package = success
I ran cmd.exe with admin privileges and did a composer update with an empty vendor folder on windows 7 pro (with uac enabled). It did just copy it - no symlinking with the relative path. I also did a composer self-update. Any tipp?
Wierd. Try doing the same but use composer install, not update. At least the first time.
So I'm curious, is there a full talk where we can learn more how did the idea for this product originate and how it came to be?
I think you should document/demonstrate that with a simple example in your readme.
Will add that. Thank You.
The first step is to identify the behavior you need. Forget what *supplies* the behavior for a second, just describe that behavior to yourself in plain English: **"I need a JSON representation of a Blog"** or **"I need to transform a Blog into a JSON representation"**, or something along those lines. THAT is the behavior your application needs. The second step is to give that behavior a name: transformBlogToJSON(Blog $blog) Put that into an interface (call it BlogTransformer, I know you already have a BlogTransformer class, so give it a different name if you need). There is the contract that your controllers (or any other parts of the app) can depend on. The third step is to provide an implementation of that interface. class FractalBlogTransformer implements BlogTransformer { public function __construct(....&lt;inject fractal dependencies here&gt;...) { } public function transformBlogToJSON(Blog $blog) { // transformation code here } } In that class, you will inject the various Fractal-specific dependencies. This class is now known as an adapter - it adapts a third party library's API, to an API that your application has specified it wants to use. This is how you create interfaces for third party libraries - they require TWO classes: the contract interface, and an adapter which implements that contract and takes the library as a dependency. The fourth step is Laravel-specific, and it's to bind that specific `FractalBlogTransformer` to the `BlogTransformer` interface in the Laravel IOC - either in the `AppServiceProvider` or somewhere else. The fifth step is to change your controller: class BlogApiController { private $blogRepository; private $blogTransformer; public function __construct(BlogRepository $blogRepository, BlogTransformer $blogTransformer) { $this-&gt;blogRepository = $blogRepository; $this-&gt;blogTransformer = $blogTransformer; } public function show($blogId) { $blog = $this-&gt;blogRepository-&gt;findById($blogId); $resource = $this-&gt;blogTransformer-&gt;transformBlogToJSON($blog); return Response::json($resource); } } Just want to clarify something that might be confusing. You already had a class called `BlogTransformer()` that Fractal used to do the actual mapping, and I called the interface the same thing simply because I couldn't think of a better word. Feel free to change class names however you need, or just use namespaces to avoid collisions. Also note that I'm returning `$resource` directly in the `Response::json()` call. I think this might cause an error with Laravel because for whatever silly reason, `Response::json()` wants an array that it converts to JSON for you, instead of just saying "Oh hey, this is already JSON, I'll just set the headers". So that might need some clean up, but you get the general idea. The key here is that you have an interface, and an adapter for that library.
"classes cannot be instantiated without the container, which is a problem in tests" WTF ?? annotation prevents you to instantiate the class manually ??
Don't expect to have a perfect understanding in two years. 4 and 6 year computer science/software engineering degrees exist for a reason. 
Komodo Edit is pretty decent, that's what we use here in my office because paying for a license for an IDE seems insane to me.
 Gotcha. I do online marketing for myself, and have over 1,000 websites in my portfolio (long story) that I own and work on. Was thinking because PHP is so integrated into what I do on a daily basis (setting up websites, etc) it might be a quicker learning process for me than most.
I wonder ... do you really need it? Maybe your could try a different approach like using an autoloader? "composer" has a nice one supporting "psr-0" and "psr-4". And always working from the root index.php with a little api/dispatcher/router could solve most problems with relative paths. Or do you really have a very rare situation where you really must do that? Anyways, have fun! ;)
&gt; Good design means allowing your infrastructure decisions to be made later with little to no impact on the domain
I get the joke, but I'll be the buzz-kill: it's a false dichotomy. In the range of solutions for your data access layer, there's more than PDO and ORM. Heck, even from one ORM to another, the approach varies wildly. They're not all ~~Hibernate~~ Doctrine wannabes.
Thank you for your suggestions. $userAgent-&gt;browser-&gt;name(); // firefox $userAgent-&gt;browser-&gt;version(); // 3.6 $userAgent-&gt;browser-&gt;engine(); // gecko $userAgent-&gt;os-&gt;name(); // linux This is also what [uap-php](https://github.com/ua-parser/uap-php) does.
Thanks for a great response, I understand the difference between the two blog transformers, and also I'm aware of the behaviour of the Response facade, but thanks for being clear anyway. :) Now I realise I was thinking about it in the wrong way - I assumed each aspect of the Fractal package would need an interface and a corresponding implementation (e.g. one interface and implementation for each class that I'm currently using in my code base - Manager, Item, Collection etc). But, of course! My implementation of what I want to achieve can of course can make use of multiple Fractal-specific classes that I write, which I didn't consider before. Generalising more, to make sure I understand correctly, lets say that I now have News and also Event entities along with my Blog entity. So I would have to create: `NewsTransformerInterface`, `FractalNewsTransformer`, `EventTransformerInterface` and `FractalEventTransformer`. Then, in terms of integration testing my Fractal implementation of my contract, I would create a new instance of each Fractal transformer, say `FractalNewsTransformer`, and pass it a real `News` entity, and assert that it returns what I expect in all possible scenarios. I could then safely unit test my controller using test doubles to ensure that the message is correct messaging is being passed to my implementation, and use stubs to ensure that my controller handles the response from my implementation correctly. However, I would **not** unit test any of the transformers Fractal uses to do the actual mapping (that extend their TransformerAbstract). Is that correct? Thanks again for your reply, it really helped me approach this from a different angle.
Hi, let's stay constructive and respectful :) Here is an example of what I meant: class Foo { /** * @Inject * @var Bar */ private $bar; public function doSomething() { $this-&gt;bar-&gt;doSomethingElse(); } } $foo = new Foo(); $foo-&gt;doSomething(); // error 
Those guys are a joke :) Anyway, answering your question. Using Doctrine ORM: - [Sylius](http://sylius.org/) (E-commerce) - [Ez Publish](http://ez.no/) (CMS) - [OroCRM](http://www.orocrm.com/) (CRM) - [Scrutinizer CI](https://scrutinizer-ci.com/) - [Wallabag](https://github.com/wallabag/wallabag) Using Illuminate/Database: - [Flarum](https://github.com/flarum/core) (Forum) - [PyroCMS](https://github.com/pyrocms/pyrocms) (CMS) Regarding Hibernate I don't really know where to look for honestly. I know it's used in [this major french e-commerce website](http://courses.carrefour.fr/).
GitHub uses Rails ActiveRecord. Any Rails app probably? Shopify, Soundcloud, etc.
Sounds like my previous employer ... they had a custom built framework for this HUGE database system app and the developers (who have been with the company for over 10 years) were all focused on features and not actually fine-tuning their app. They were still on PHP 5.2 when I left in 2014. As for actual projects that use ORM in production ... well, I don't have any real examples to show. I do know that some ORMs have ways to cache (with query and bytecode) the objects rendered. The one that is stuck in my mind is Phalcon's ORM, which they tried to make with production servers in mind. I can state though, that Disney uses Zend Framework and it's ORM exclusively on ALL of their web properties, including the Parks and Resorts booking app, all of their travel agency APIs, and various support apps. Good luck. I hope that you'll be able to convince management that they should use your system, and hopefully get rid of the toxic people that will potentially harm the company.
This is what I have been looking for, in a similar situation with an internally hosted Gitlab.
I'm sorry I can only give you one upvote for *actually answering OP's question* instead of waxing theoretical. 
&gt; This will let your app remain decoupled from SQL, Doctrine, or whatever you choose to use, it'll even allow you to implement the repository using NoSQL or plain files. No limitations But the danger here is that if you do things like straight up return the data from the ORM that powers the repository, that's a leaky abstraction. // If you return the straight Eloquent collection, this is a leaky abstraction $users = $userRepository-&gt;all(); // Eloquent lazy eager load leaky abstraction $comments = $commentRepository-&gt;findByArticleID(53); $comments-&gt;load('authors'); At a MINIMUM, you need to make sure that what your Repositories return are collection interfaces you control, and entity interfaces you control. Then you can attach those interfaces to the underlying ORM entities or POPOs or what have you. But it's not quite as simple as just using a repository interface, you also have to make sure what the repository *returns* adheres to interfaces as well.
Additionally to what Levi said, they're also useful as incremental state machines. The nice part is that you just can do `while (\strlen($buffer) &lt; 5) $buffer .= yield;` (where 5 is how much bytes you need at least for the next parsing step to complete) and to continue you just `$generator-&gt;send($next_bytes)`. It allows you to write the whole logic in a nicely structured way. No need to have a big array of state constants which then tell you where you have to `goto` to or what the next callable to try is. Advantage is also a much clearer indication where parsing branches, how the flow through the parser is etc. (as opposed to random tiny methods). Additionally you avoid spamming the code with too much `$this-&gt;` (I mean, no need to back up every tiny change in the class properties). To return the value, you then usually pass some callback to the Generator when creating it, or, with PHP 7, you also can just `return` it in the Generator and fetch via `$generator-&gt;getReturn();`.
holy fuck your senior developers are retarded. I literally LOL'd so hard when I read that.
Have you looked into Sybase ASE? They have an "Express" edition that is free for production use. Limits to 1 engine but that can do a surprisingly large amount of work. 
I suppose these guys think that mobile won't ever catch on and that git is just a fad too? Orm was practically made to make the database interaction agnostic. Its saves loads of development hours and when written well has little to no performance loss. Not that the performance issues even matter considering how fast and cheap hardware is nowadays - we arent writing php on pentium 4s. If they can't figure out how to work in it effectively maybe they need some classes to earn that senior designation they have.
A lot of products have custom rolled ORMs because they started before a lot of projects like Doctrine2 were mature. SugarCRM has a custom rolled orm centered around the concept of 'beans' (very EAV like) http://support.sugarcrm.com/02_Documentation/04_Sugar_Developer/Sugar_Developer_Guide_7.5/70_API/Classes/SugarBean/10_CRUD_Handling/ Magento has a custom rolled ORM based around their EAV model: http://alanstorm.com/magento_advanced_orm_entity_attribute_value_part_1 Elgg also rolled their own around the EAV model Not to mention the heavy usage of the Entity Framework in .NET with is an ORM (ActiveRecord, IIRC). ORMs are slower, yes but that really only comes into play with you're dealing with volume and even then there are several techniques per ORM to mitigate it. Your devs just sound like they have NIH. 
Gah! Thats like renaming tomato paste to red fruit mash in recipes. But at least you have a job. :) Still though, the company is going to stagnate if the techs insist on using the equivalent to windows xp of software development.
unless you have every single solitary line of SQL code written by hand, with 100% manual escaping of every single input, you're going to be doing some variation of 'ORM' - any function that copies data from an object and creates an SQL statement out of it will be approximating part of an ORM. This is not at all a technical battle - this is 100% political. "Confronting" them with actual real evidence won't actually sway them. If they've been doing software development for 10+ years and do not see any benefit at all in having an ORM in place for data management... they won't be convinced by a list of OPP (other peoples' projects). You'll hear people argue "right tool for the right job", and people will argue that ORMs are or are not the 'right' tool. The thing people often ignore is... you can have both. Most projects I'm involved with use an ORM for the majority of the work, and then we drop down to 'raw' SQL for the (few) situations where the ORM isn't a good fit. Being able to write person.properties = params person.save() and having the person object be updated with incoming parameters, escaped, transactions handled appropriately, but still being able to have a 'person' class encapsulate all the custom logic (and intercept save() calls, etc) is insanely productive. Knowing how/when to drop to particular 'naked' SQL (or stored procedures now and then) when appropriate is key to being a "right tool for the right job" developer (instead of a "the right tool is the one I already know" developer). Most Rails projects are going to be built around ActiveRecord. I happen to know transcriptmaker.com and reachapp.co are both built on Rails, and successfully serve tens of thousands of visitors per month without fail or performance issues (and both are using ActiveRecord extensively). &gt; because they are "too limiting" and have "serious performance issues". Without some centralization of your data access, you will have naked SQL queries in dozens of places around an app. *With* some centralization of data access, you've already introduced some 'overhead'. Perhaps a rebuttal might be "Wordpress doesn't use an ORM - it's not got all that 'overhead' nor any of those 'limitations' you speak of, but... it's got a long history of being a security nightmare." *CORE* WP seems to be generally OK, but the entire ecosystem has no standard ORM to build on, and every plugin I see has swathes of raw SQL queries without a consistent approach to data escaping. If part of your company strategy is to be able to be database portable *some* form of an ORM will end up being immensely useful, even if it's not used for 100% of data access.
&gt; in random directions it can be a little slow sometimes. It's hard to decide what you need without explaining what "a little slow" is, how fast you need to insert words, etc. I'll just suggest, you can represent a matrix of letters (ASCII single byte) as a *single string* with length H * W characters, where H and W is height and width. So instead of this: $array[$x][$y] = 'F'; You can read and write letters like this: $string[$x + ($width * $y)] = 'F'; Basically mapping a 2D matrix in a flat region of memory. If you need Unicode support is gets a bit more complicated, but it's still doable. - If you need to search for words quickly in this matrix, you can also separate rows with a delimiter (so rows become one char longer) to avoid false positives, and search directly in the string with strpos(). - To search vertically, create a matrix projection as a string that's transposed and reuse it. Likewise for diagonals. - For reverse, you can reuse the same matrix, but reverse the word being searched and search again (for many words, projection of a reversed matrix will be faster).
Making my employer pay for it doesn't make it any more sane to me. Its still money spent that doesn't have to be.
I am going to voice an unpopular opinion again, so watch this post get downvoted. So imho it really depends on the suze of your production and the features of the database vendor you will be using. The seniors are right in that large companies rarely use ORMs, because they usually use their databases to the max, and sometines even write their own databases for their specific use cases. But those companies can afford that because they have a huge development staff. If you have under 10 devs you cant. Having actually built an ORM for PHPixie I can vouch that a lot of work goes into that. But by using an ORM you are making a flexibility trafeoff in the long run. If those devs are there for 10+ years and you are not, I would advise against fighting them. If you win this, an ORM is used and somewhere down the line the app is slow you will be blamed for that. And thoae guys will happily burn you when that happens. If you insist on fighting this the only ace you have is the size of your dev team. If you dont have the staff as large as facebook does, continuing without an orm is going to seriously extend your deadlines
The repository interface idea is nice, but crumbles as soon as you need relationships. Those are usually very ORM specific and require a lot of work to become agnostic
A repository handles an aggregate, so it handles the needed relationships. If you have a big ball of table relationships, repositories (and service layers in general) will force you to split it into several aggregate roots, and honestly that's essential for having a modular, maintainable persistence model anyway. You need this. I do understand your point, though, I've struggled through some of those in past years. If something seems unclear how'd it look in a repo, ask me. 
I have nothing to add, I just want to tell you that this is a really good response.
&gt; still though, lazy loading..eager loading...those are tricky if you don't use an ORM. When you access remote data, there's no lazy loading, only eager loading. Lazy computation at a high granularity like an ORM does is a technique that should only be applied for local objects &amp; data, because then the latency of asking lazily is smaller than the burden of building eagerly. Remote data isn't close, latency is big, performance is bad. So the alternative is being able to specify what you want, and get exactly what you specified, eagerly. "I want these fields, and these relationships, I want up to 100 results at offset 50." If this sounds a bit like SQL, it's no coincidence, because SQL folks found out how to query remote data stores efficiently over 40 years ago. :-) &gt; It would be nice if you can show us a small example. I always wondered how people implement aggregate root nicely without using an ORM. Can you give a scenario, and I'd give you a possible rendition of the API. BTW, note this is independent to whether you use an ORM or not, inside the repository. We're discussing modeling repository interfaces, right? 
Well what I meant was when you want to preload relationships ( especially nested ones). You have to be aware of that eager loading for that to work, and that is tightly coupled with ORM. You'll end up with methods like -&gt;findAllWithCategoriesAndAuthorsPreloaded() etc
&gt; Well what I meant was when you want to preload relationships ( especially nested ones). You have to be aware of that eager loading for that to work, and that is tightly coupled with ORM. You'll end up with methods like -&gt;findAllWithCategoriesAndAuthorsPreloaded() etc Or you can have: function findAll($fields) {} And then specific fields, trigger retrieving the needed relationships: $results = $repo-&gt;findAll(['id', 'name', 'categories', 'authors']); In this example, "id" and "name" are normal table fields, and "categories", and "authors" are relationships with other tables, that represent collections (lists of items). Notice that the repository doesn't have to expose your internal table layout as the interface is uniform. You may decide to store "authors" as a JSON array in a TEXT field, and nothing will change in the API.
If you learn *programming* rather than PHP then you shouldn't be particularly dependent on the PHP job market. A good programmer shouldn't have much trouble picking up a different language.
&gt; well but then you'll also need to add a query builder to that and the result will still look like an ORM (although it will proxy things to the actual ORM you are using). Well, first, I didn't say "don't use ORM", in fact I specifically said "implement the repository with an ORM, and let the other guys implement it without an ORM, and let the better implementation win". That's the point of a repository: implementation agnostic. Second, a query builder is not an ORM. It's one layer above raw SQL: - It's not fully (or at all) RDBMS vendor agnostic. - It doesn't run a query, it builds it and returns it as a string. - Then you pass the string to your $db-&gt;query($theString); or $db-&gt;execute($theString). There are several orders of magnitude difference in the complexity of an ORM like Doctrine and a basic query builder. Or we can also concatenate a query from strings, like savages. :-)
Hi PHPun, could you show an example of this working in code please?
And people use this pile of shit in their "enterprise" apps...
Sure: Nope::$nope-&gt;nope(); Seriously though, I won't just sit down and write *the whole program*. If you have a specific question I'd be happy to clarify or write a snippet.
Mark?
The problem is I don't know precisely which aspect you want an example of. My past &amp; current projects have a rich context, I can't express briefly without knowing which exactly is the stumbling block for you. And my mind can't operate in vacuum, I need to see the problem so I can give a solution. :-) For example /u/dracony in this thread posted a problem and I offered a solution: https://www.reddit.com/r/PHP/comments/3l63a1/i_need_examples_of_some_successful_products_that/cv3vqk3
Mark speaking, who is this.
And they seem to be pretty big...
And people delete that file before they do anything else. It does nothing but provide a landing page to confirm to you that the installation worked.
Ok....php it is lol. Yeah, I understand there is a syntax/etc that needs to be followed. 
*son
Did you came here to talk about PHP, or how cool you are?
I think I see what you're saying. Thankfully I don't need to the class/model/whatever you want to call it to be able to search. It just needs to represent the board to be easily turned into some sort of JSON object for an API. I'm about to put up a Gist of what I have now, so you have a better idea of whats being done at the moment.
Here is a Gist of what I am doing right now, hope it makes sense. https://gist.github.com/hskrasek/43e97992a0e61204b38c
What example would you use to introduce a repository pattern to a person who never used it? I'm looking for that kind of simple example with an aggregate root without using an ORM. That's all. That's why I mentioned an ecommerce example since everyone uses it lol. May be I'm asking too much.
Sounds like a pretty smart guy. I'm glad he gave you a chance to show that ORMs can be a good thing.
Clearly not doing TDD.
Let's not forget Ruby on Rails - which powers a lot of sites, like all the basecamp company's properties!
I formerly worked for a company that made large adult dating platforms. They were at one point the largest symfony install in the world and they used doctrine. Current site with several million users is using SQLAlchemy for Python.
I was at the Louisville laracon. The reaction was mixed, but basically anyone who was working making Saas with laravel was stoked. I'm more excited about the new authorization interface.
What does Jr level pay (per year) out of curiosity? Do you (personally...as a php developer) have any options of "going solo" and working from home? Are 6 figure salaries only for guys with 10 or more years experience?
It's not suitable for more complex deployment processes where lots of things need to be built and wrapped up. Our application will build on-the-fly as needed, so we don't worry about those things. Most of the downvotes are probably just puritans, but I advocate using the right tool at the right time, and this was what was simplest. *shrug*
You're one of those knuckle draggers who writes interspersed HTML globally with hundreds of echos commented out with "for debugging" comments next to them? Mad you lost the job you were barely qualified to get?
There's no better way of representing the board. I have a feeling you're asking something else. So I've taken a quick look. First, initializeBoard() seems wasteful. Why fill a 2D array with nulls? $board = []; for($r=0;$r&lt;$rows;$r++) { $board[] = []; for($c=0;$c&lt;$cols;$c++){ $board[$r][] = new \stdObject; } } Word positions also seems unnecessarily strange. Word Position need 3 things. The ordered letters, the direction, the starting coordinate. Make a data structure with that information or better yet, store it in the $board. function placeWord($board, $weighting) { $randWord = $this-&gt;getWord(); // when you get direction, you should limit how many are horz vs vert vs diag (or reverses) // by randomization weight // [weightH, weightV, weightD, weightHr, weightVr, weightDr] $randDir = $this-&gt;getWordDirection($weighting); $randPlacement = $this-&gt;getWordStart($word); // returns [xInt,yInt] if(!is_array($randPlacement){ return false; } $board[$randPlacement[1], $randPlacement[0]].letters = $randWord; $board[$randPlacement[1], $randPlacement[0]].direction = $randDir; // if you want to get fancy, calculate the position of every letter based on direction // add another property: $board[$randPlacement[1], $randPlacement[0]].letteridx = 0; // for each place a letter goes, alter that object as well. Later, when you have words // that can cross you want to store arrays of data in the objects. return $board; } Next you place a bunch of random letters around your words placed. Since you know the patterns of any given direction
As you point it out, I would have to agree filling the board with nulls right off the bat is wasteful; Not sure why I didn't notice that up front. Word positions is a helper array since in the response JSON, each row is made up of letter "objects", which can have an array property "words", which contains the UUID of what words the letter might belong too, basically just a helper array. The WeightedArray thing is what determines the percent chance of a direction being chosen, based on the boards difficulty. I think I see what you're saying with the above placeWord function. I think. The more I look at the code and read your comment though, it sounds like I could make this better if I upgraded the representation to use more than an array of arrays, and filled each slot with either a stdClass object, or even an entity class so that I'm not iterating over the matrix over and over just to create and render the board.
&gt;Please written in PHP, and compatible with PHP 4 I'll bite.. why? You'll have a hard finding a developer with access to such an old deployment. &gt;Remove all unit tests ?
Well, laravel does suck actually.
www.phptherightway.com is great, but is a ton of info to take in right away. IMO, part of being a good programmer is the willingness and ability to learn whatever it is you need on your own. You have to figure out the problems yourself without asking for help as a first reaction. You'll always be learning new things and you can't rely on other people to help you all the time. Learn to Google everything you need to learn. Go to /r/phphelp and ask away when all else fails. (tip: things gets outdated fast, so using the "search within the last year" option can give you much better results in google) 1 hour a day doesn't seem like a lot though. Just as a comparison, I was doing 8-18 hour days for months before I felt ready to put my name out there as an "entry level" developer with my Github profile and a home-brewed SaaS as my resume. Read /r/php and /r/phphelp every day, and follow higher-profile community members on their blogs/twitter etc, always chase after best-practices, read up on security considerations, etc etc. It'll get easier the more you do it, the more you learn. It's not magic :)
&gt;let the senior developers implement the repository interface I think they are not going to agree on them having to writing code that hydrates the nested objects, the kind that OP might be creating using an ORM. &gt;A repository is not very hard to implement in most cases.. Mmm. It is hard to implement it reliably. For example, you need to maintain some kind of Identity map for each entity that goes out of the repo. Subtle bugs in you repository code can be a big headache down the road. So I think this is a bad advice to give to OP. Either you use ORM, and use it's provided method to write raw SQL and let it do the hydration. Or you deal with two dimensional arrays created by a result set everywhere.
What about this: Music related website (a lot of semplifications but I think this will cover much of the problems with working with relationships) You have **artists**. * in a table you store basic information (name, sort_name, type [person/band/..]). * in other table you store detailed information (birth date, place, activity dates, ...) 1:1 with previous table * table for meta data a sort of key value store N:1 with artist base table (you store here all the reference that you like (reference can be a value like a url or a specific value like a guid, so you have also a column that describes the value type). Examples can be soundcloud url, musicbrainz guid, youtube channel url, offical homepage, deezer id * table that stores the relationships with other artists (e.g. Paul McCartney played with the beatles) Each record contains 2 artist id fields (from, to) the type of relationship and the direction of the relationship * table that stores the aliases of an artist (1:N) You have **news articles** (single table) each of them can be associated with one artist N:1 You have **photos** (single table) each of them can be associated with one artist N:1 You have **photo galleries** (single table) each of them can be associated with one or more photos N:1 You have **records** (single table) each of them can be associated to one of more artist N:M Questions that comes to mind: * How would you design an artist repository / entity? A single object graph that describes everything an artist is (with base data, meta data, aliases, relationships) or would you split it in different components that can be used independently? * The former may be useful for editing, you load everything in one place, you change something in the graph, you commit and a data mapper / ORM persist the related changed. If the former how would you handle the load of the graph? You eager load everything all the time or you would give the possibility to load pieces of informations to avoid wasted querying? * The latter may be more complicated on the editing side but more performant and easy to use when informations need to be fetched * How would you handle the news? You'd put them on the artist side $artist-&gt;getLatestNews($limit); or on the news side $news-&gt;getArtistLatestNews($artist_id, $limit); * Same applies for the other tables **EDIT:** formatting
All right. Well, if you just need it for an API probably a flat array of strings is most intuitive, every string being one row. It strikes a balance between compactness and ease of understanding.
A repository is modeled after the specific domain it needs to service. So if it was a Reddit repository, it'd have methods like: addThread, nukeThread, addPost, editPost, deletePost, nukePost and some slightly more specialized ones, like: getTopCommentsInThread($threadId, $ratio, $maxCount). As for e-commerce, you'd be storing orders &amp; their progress. I tend to track orders through event sourcing. So we'd probably have a cart API and an orders API, each with their own internal repositories. Because carts are small, and always needed all-or-nothing, I'd probably outright have the cart repository take my Cart object with items inside and serialize it somehow, without bothering for higher granularity: setCart($userId, Cart $cart) getCart($userId): Cart deleteCart($userId) And that's all. If you don't need carts to persist between sessions, you can easily implement this repository through $_SESSION, and have yourself a SessionCartRepository in a few lines of code. Another implementation may use a database. Etc. As for orders... again I keep thinking event sourcing, so... damn it let's go there then, it'll be sort of like this: addOrder($userId, OrderSnapshot $initialState): orderId addOrderEvent($userId, $orderId, OrderEvent $event): eventId // If we specify eventId, we get state at a given point in time, else we get latest getOrderSnapshot($userId, $orderId, $eventId = null): OrderSnapshot The events are a set of simple value objects that hold order changes, like, say "AcceptedEvent", "ProgressUpdatedEvent", "ItemsArrivedEvent", "CanceledEvent", "CompletedEvent", "RefundRequestedEvent"... And the repository will of course have some more report-like overview methods to make it practical for the admin site, say. getOrdersOverview($userId, array $fields = [..default...]): array This doesn't quite show shining examples of complex aggregates, because they don't come up *as often* when you have separate small aggregates, compared to a big monolithic connected schema. So if there are specific situations from *your* project that you draw a blank on, it'd be better to discuss that, I think. :-) BTW, refer also to this answer I gave to another user: https://www.reddit.com/r/PHP/comments/3l63a1/i_need_examples_of_some_successful_products_that/cv4iq5b One thing to notice: the liberal use of **$somethingId**. When you specify an item in a remote data store you don't have a *reference* to it. Either it's there locally after you fetch it and you can have a reference to it, or it isn't and you need to address APIs via its serializable entity id. This is an important thing to understand, which ORMs often try to obscure for no good reason (through magic like lazy-loading), and leads to confusion about what's local and what isn't.
&gt; Give a simple Blog example. Post has many Tags , has many categories , have one author. All right, I'll assume for this example that "many" is a reasonable number that can be eagerly read. When you read the post, it can accept a parameter $fields. Some fields will be just table fields, some will trigger relations to be included in the response: function getPost($postId, $fields = ['default', 'fields', ...]) { ... } getPost($postId, ['title', 'slug', 'author', 'tags']); What happens if we have potentially millions of tags? We can provide field options. Now, you'll excuse me for this example, I'll start using array in a very specific way mixing list and associative. In my actual project I have a simple builder with a fluent API for this, but array also works: getPost($postId, [ 'title', 'slug', 'author', 'tags' =&gt; [ 'mostPopular' =&gt; 100 ] ]); Now the system will fetch the most popular 100 tags only, not all tags. Check how Facebook's GraphQL API works it's very similar to this. The trick is to make the API just the right amount of expressive, so it stays domain-specific, but yet flexible enough for people to represent exactly what they want.
I've had some similar design-issues at work, currently: * The domain model has repository *interfaces*, that say what kind of "findWidgetByProductCode" methods are needed. * The domain model's unit-tests have implementations that just juggle objects in memory * The production code supplies implementations that delegate/wrap Doctrine (and Doctrine's own definition of "repositories") to get the work done. 
&gt; I think they are not going to agree on them having to writing code that hydrates the nested objects, the kind that OP might be creating using an ORM. OP will have to write the objects in question, they need to just hydrate, using facilities which are most likely also shared (but if not, no biggie). Using the principle of charity, I'll assume they know what they're doing, they just don't like ORMs. So mapping to DTOs won't be much of an issue for them. &gt; Mmm. It is hard to implement it reliably. For example, you need to maintain some kind of Identity map for each entity that goes out of the repo. Repositories don't maintain identity maps. ORMs do, repositories don't. Let's not confuse the DDD Repository *pattern* with the Doctrine repository. Not same thing. You may have an identity map for whatever reason, but it's not exposed through the API, and it's not mandatory. Repositories take data in, they get data out. That's all they do.
Hi, Very detailed question, love it. :-) &gt; How would you design an artist repository / entity? A single object graph that describes everything an artist is (with base data, meta data, aliases, relationships) or would you split it in different components that can be used independently? At least on first read, I'd split it very closely, nay, *exactly* the way you split your description in paragraphs, isn't that curious. :-) So we'll have ArtistRepo, NewsRepo, PhotoRepo (galleries can be rolled into this one), RecordRepo. This is the modular approach. More on that later. Let's discuss the monolithic approach first: &gt; If the former how would you handle the load of the graph? You eager load everything all the time or you would give the possibility to load pieces of informations to avoid wasted querying? Both. Eager all the way (no lazy-loading), but also the API should be structured so you can express *exactly* what you need, in a language that maps well to the *domain*, not the particular persistence implementation. I gave an example for this here, so we can reuse it: https://www.reddit.com/r/PHP/comments/3l63a1/i_need_examples_of_some_successful_products_that/cv4ibkg An API designed like this can be as complex &amp; granular or as simple &amp; "large-chunked" as you need it to be, control is in your hands. The best way is to start simple, and refine over time in a B.C. manner, which is really easy if you think about specifying the results in terms of "fields" and "fields options" nested ad infinitum. Back to modular approach: &gt; The latter may be more complicated on the editing side but more performant and easy to use when informations need to be fetched Yup. Also keeps the API complexity I mentioned above spiraling out of control. Every repository will likely represent 2-4 tables (can be more), so some relationships and nesting will be present, but it's best it doesn't get big. Simple is better. &gt; How would you handle the news? You'd put them on the artist side $artist-&gt;getLatestNews($limit); or on the news side $news-&gt;getArtistLatestNews($artist_id, $limit); Absolutely *100%* on the news side. I'm strangely specific and certain here, because an "artist" represents a very special kind of entity: a person (when I say a person, imagine I also mean companies and other person-like entities). Now, we're a society of persons, so person entities are important to us: most kind of entities in our models are attached (directly or *indirectly* though another entity) to some sort of person. So you don't want all those related entities to be in the person repository as that will quickly become a giant monolith. A person also has another quality: it's stable. It's introduced once, and it stays relatively stable over a long period of time. It doesn't disappear a second later, it doesn't merge with other persons and it doesn't split into many persons. Of course, exceptions exist to this: - Companies splitting and merging (also, family account + divorce...). - Migrating accounts from one system into another and finding conflicting accounts pointing to the same person But those are rare situations handled best in context. In general you can give a human, or a company, an "account" representing their person and that's it. You don't even have to have an option to delete it, you can instead hide it and slowly, slowly fade it out (say after N months of inactivity, or N months after hiding it or some such). Because a person is connected to everything, you don't want their entity, repo, service burdened with *absolutely anything* that's not an intrinsic part of their person. This leaves things like name, current email, profile photo and basics like that. An artist may have news, but tomorrow the system may choose artists no longer have news. This decision shouldn't be something that affects the person repository, so news shouldn't be part of a person. And because persons are stable, it's very natural for all other entities to refer to them by their entity id (a number, a string), because they're stable, as I said, then don't merge, split or disappear often, so having to maintain their stability with force through foreign keys or other means is not as necessary. So, tl;dr: when you identify an "account" or a "person" or an "artist" or a "user" in your project, split it off to its own repository, and its own API. Don't attach any transient info to them like news, gallery photos, records. Just core person data. It's a good rule of thumb.
He doesn't have to be using Symfony to use Symfony components - just drop it in composer.json and go
Yeah but if he's manually including files, OP probably isn't using Composer otherwise the autoload.php would be the only thing he would need and even then probably would need to find the relative paths since he could set the files up in a namespace to be loaded.
Very good stuff, I like how you used existing services termbin.com or imgur.com to make it very easy to set up!
In both of them I can immediately see that I'm getting an array at the end, but its much easier to identify what that array will have in it in Code #1. I'd have to think about it for a few seconds in Code #2. Code #2 is cooler though. 
&gt; The problem is that PHP arrays are not actually arrays. They are hash tables. If you switch over to actual arrays you should see an impressive boost in efficiency. Coming in PHP7, by the way. :)
Taken as-is, I prefer the first one. It's more readable, it's faster than mapping, &amp; it's how I typically work in my code. However... The second one is more decomposable (you can receive a function from some other place, etc.). This can make it more configurable, and can make it more readable if it evolves to become more complicated over time. So it really depends what the bigger picture is, and each approach has its strengths. ---- P.S.: Both samples could make use of some blank lines, between "paragraphs" of code. It's just like in English. 
First, definitely. I try to stay away from returning multiple times where possible.
&gt; In packed tables there is still some overhead. It is an array, but some extra fields are around which aren't used. But there's also overhead in mapping a C array to a PHP object as SplFixedArray does it, so, you know, if you use PHP, there's always some overhead. It'll be interesting to test which will be faster &amp; more efficient in PHP7, I'm willing to bet on array().
Neither, they're both horrible, to the extent that I'm not even sure what the code is meant to be doing. You seem to be operating on the groups in place for the second example and are not doing that in the first example, instead creating a new array. I am guessing that the intent of the code is to actually do this: $fnTranslateAgeGroup = function(Agegroup $group) { return $this-&gt;translator-&gt;trans( '%agegroup% år', ['%agegroup%' =&gt; $group-&gt;getName()], 'Bundle' ); }; return array_map($fnTranslateAgeGroup, $this-&gt;getAgegroups()); And yes, naming closures so that they have some semantic meaning when used, is much preferable to declaring them and using them in the same place, where you have to read the code to understand what it is doing. By doing that, the actual work of the function is done on a single line, where every bit of that line is understandable in place.......which means that you don't need to understand several lines at once. btw array_map preserves both the keys and order of the ~~ordered HashMap~~ array, so the faffing around with IDs that you had isn't needed.
I use __get() a lot (for 2 or 3 cases that make my code shorter and less repetitive). But I heard this magic method is kinda dangerous (EDIT : for readability/maintenance), you have to use it with caution.
First one. Definitively. Also, you forgot a semi-colon.
&gt; Neither, they're both horrible, to the extent that I'm not even sure what the code is meant to be doing. You honestly can't understand a single foreach loop?
&gt; Is it really bad performance wise? It's obviously worse than direct access, but it's only slightly slower than a simple method call. Is that "bad" depends on your use case (chances are it's not). I think a more interesting question is... what are your getters *getting*. There are ways to avoid the whole thing with alternative designs, but you need to describe the use case. &gt; Are there any hidden "gotchas" that I don't know about? You can't get by reference. And you need to document those virtual properties via stuff like: /** * @property $foo array Does this and that, when that and this. * @property $bar string Does this and that, when that and this. */ class Baz { ... } This is so IDEs can see there's a public property exposed via __get which is not in code.
&gt; Easily change some logic inside of them (e.g. wrap trim() around the input into the setter or the output of a getter) in one place, instead of all over the app. You can do the same with the __set() magic method. function __set($arg, $val) { if ($arg === 'PropertyThatNeedsTrimmng') { $this-&gt;PropertyThatNeedsTrimming = trim($val); } } That’s part of the idea behind the __get and __set magic methods. It allows you to access properties in a slightly more concise manner without necessarily sacrificing their protection level.
Good. Thank you for the post :) You have addOrder, addThread, nukeThread, and etc in your repository...? It feels like your repository is acting like a factory in that case. Why not let the models create themselves and let the repository simply persist them? Even for the events, why not simply emit them?
authentication isn't related to ORM. Most of it requires to implement your own user provider. Also you can consider things like [JWT](http://jwt.io), which doesn't requires any database for authentication.
By using magic methods instead of proper ones you forfeit docblocks and typehints.
Ahh, great points. Thank you.
Exactly, which is why I would never do that. Creating "virtual" methods for properties in the form of control statements makes code unnecessarily hard to read. Imagine if that's what PHP did at a language level? "To add a new method to a class, add a new if statement or switch case to __get()"
Yeah. So you gotta stick to items that don’t need much more than a type check and light formatting. Anything that needs a *very* specific treatment *should* have its own specialized method. 
I guess we have to agree to disagree. not 'just' save it. I don't see any reason to have creation methods in a repository. I mean..you can, but why? Not that I'm expert on it, but I think I understand what an event sourcing a little bit. I've never seen your method in Greg young's examples - paid videos, blog, or just articles.
&gt; I guess we have to agree to disagree. not 'just' save it. I don't see any reason to have creation methods in a repository. I mean..you can, but why? I'm still not sure what we disagree on, precisely. The add() and persist() methods in our examples are identical. &gt; Not that I'm expert on it, but I think I understand what an event sourcing a little bit. I've never seen your method in Greg young's examples - paid videos, blog, or just articles. Which method? The "addOrder()" method creates a new aggregate context. And "addOrderEvent()" ... logs an event, or to use your terms, "emits" it.
Because you find it more pleasing to use function __set($arg, $val) { if ($arg === 'FirstName' || $arg == 'LastName') { $this-&gt;$arg = $val; } } rather than function setFirstName($fname) { $this-&gt;FirstName = $fname; } function setLastName($lname) { $this-&gt;LastName = $lname; } Note that there is no string type-hinting pre-PHP 7. So in both cases, adding type safety also includes an `if (is_string($arg))` check. But, yeah, come PHP 7, adding a type-hint to the setters does make that simpler.
I'm not disagreeing on add or persist. They are basically the same thing, just a different name. That's totally fine. I'm disagreeing on having model creation methods on a repository. I'm not saying that does not work, but should be avoided. Sorry, I should have mentioned it clearly. "addOrderEvent" method. If you have those methods in your repository, any code can run it without actually running a business logic on your model. That's leaky API. Isn't it?
&gt; I'm not disagreeing on add or persist. They are basically the same thing, just a different name. That's totally fine. &gt; I'm disagreeing on having model creation methods on a repository. I'm not saying that does not work, but should be avoided. If add() is a creation method... and it's the same as persist()... and persist() is fine by you... how does that logic work? I can't make sense of this. :-) &gt; "addOrderEvent" method. If you have those methods in your repository, any code can run it without actually running a business logic on your model. That's leaky API. Isn't it? A repository is only accessible to its respective service. The service enforces the business logic. Everyone else interacts with the service. So it's not leaky.
I don't like __get() and __set() because like every magic method it makes things less obvious and pretty much breaks IDEs. Now I think [this proposal](https://wiki.php.net/rfc/propertygetsetsyntax) is brilliant because it's the best of both worlds : You don't need to litter your classes with getters and setters, you can use public properties and then add getters and setters later without refactoring anything else, and as an added bonus I think $foo-&gt;bar looks cleaner than foo-&gt;getBar().
__get() can be useful in some scenarios and I'm extremely grateful that PHP supports it. That said, I avoid magics with very few exceptions... It is great, but it should not replace common programming practices. I'm a subscriber to the idea of every property being private/protected and then adding public getters and setters *when it makes sense* for very much the same reasons that phpdevster mentioned. __get() can make this *seem* easier to implement. I've even seen __call() used to create dynamic getters. (e.g. getFoo() will magically retrieve the $foo property). There are two common implementations I've seen. public function __get($name) { return isset($this-&gt;$name) ? $this-&gt;$name : null; } public function __get($name) { switch ($name) { case "foo": return $this-&gt;foo; } } The first variation seems fairly pointless since you could just make the property public; in reality, there a couple of "features" to it. It could be used to avoid PHP warnings when pulling undefined property names. It could also be used to create a read-only property in absence of __set(). The second variation is more common for the cases you are talking about, I think. That's making properties public without having to write a bunch of getters that all look almost identical. My honest advice is simple, "don't do it". There are a few specific reasons: 1. Maintainability. Yeah, it's easy to write, but when you need to perform maintenance, you're in there touching a nest of conditionals putting everything else at risk. This becomes even more the case if you have additional special logic embedded in there. (e.g. trim this, type check that, throw exceptions here, quietly fail there.) And what happens when it gets so messy in there that you decide to break it apart into proper getters? Well, now you have to update every reference in your code which calls $instance-&gt;foo to $instance-&gt;getFoo(). And what's worse, is I don't know of a refactor tool that will help you do it so you're stuck doing it manually which is prone to error. (Not to say there isn't such a tool... I rarely use magics, so I also haven't looked very hard.) 2. Performance. Let me start by saying, I'm not a "micro-optimize" guy. But magic-anything is dynamic. Dynamic is something PHP does well, but at a cost. It simply requires more resources... Whether that's because of running through a (potentially) large switch block every time you get *anything* or because it has to evaluate the variable to see what property you really want (e.g. $this-&gt;$name). 3. Documentation. You have phpDoc on all your code right? right? :) I'm a big believer in it... I've been slapped by my future self too many times. Formal getters allow you to do this in with as much detail as you want. Sure there are official class-level phpDoc tags that can help you with this (@property, @property-read, @property-write), but go ahead and try to document that passing an invalid type for the 'foo' property throws an exception using those tags... The tags just aren't robust enough to give you the documenting power necessary for well-documented code. Okay... all that said... I suppose these are "just simple getters" and you hate wasting the time writing the boiler plate code. I get it... yeah... that sucks. Especially in today's ever-sprinting world of development. My advice. Get a good IDE. PHPStorm is FANTASTIC. It has code generation tools such as "Generate getters" and "Generate setters" that does all that for you. If you want something more custom, it also supports "live templates" which can take care of pretty much any of your repetitive coding needs. In summary, use the magics when they solve a problem which can't be solved in a more direct way. Hope that helps! 
Not sure how passing $id helps. You can pass an object as well. That's how a traditional repositories work at least. Repositories work with an object. Not exactly sure how that makes your app more secure. Injection or not, a class can be created from anywhere. Having a method that emits a domain event in a repository is same as having a global function. Anyone can execute them from anywhere. The model should remember because a model is where our core business rules stored. You execute a business rule on a model then the model emits/queues "hey I've done this" and that's about it. Your example works. That's for sure, but I just don't think it's a good implementation of a repository from my own experiences and from all the examples I've seen from DDD books and even Greg Young's examples.
I prefer #1, I feel like array_map and closures are not as simple as a good old foreach, but that may just be me. Also note that in most IDEs you don't need /** @var AgeGroup $group */ if you have properly documented getAgegroups() as returning an array of AgeGroup objects like this : /** * @return AgeGroup[] */ protected function getAgegroups(){ //return an array of Agegroup objects }
And now that PHP &lt; 5.5 is unsupported, there's basically no reason NOT to use it.
I think in that scenario, if that Response object is just an immutable DTO (data transport object), then 50 public members is perfectly fine. No need for getters, no need for `__get()`.
If the wsdl is totally fucked and creating all sorts of headaches, then your best bet is using something like https://github.com/jbarciauskas/wsdl2php If PHP just _wont_ then what I've done in the past is use SoapUI to build a request, grab the xml, and turn that into a phtml template.. it's evil, but.. in times of need one must fight evil, with evil. 
Please read this: http://ericfarr.net/ddd-anti-pattern-1-not-accounting-for-commands-and-queries-as-separate-concerns/ I think it captures the core of our entire argument.
Full disclaimer, I work on the project! **[Laravel Doctrine](https://github.com/laravel-doctrine) is a suite of tools to help integrate Doctrine 2 into Laravel 5+** We offer: ## [ORM (Object-Relational Mapper)](http://www.laraveldoctrine.org/docs/1.0/orm) * Easy configuration * Pagination * Pre-configured metadata, connections and caching * Extendable: extend or add your own drivers for metadata, connections or cache * Annotations, yaml, xml, config and static php metadata mappings * Multiple entity managers and connections * Laravel naming strategy * Simple authentication implementation * Password reminders implementation * Doctrine console commands * DoctrineExtensions supported * Timestamps, Softdeletes and TablePrefix listeners ## [ORM Extensions](http://www.laraveldoctrine.org/docs/1.0/extensions) * [Behavioral Extensions](https://github.com/Atlantic18/DoctrineExtensions) -- Like Loggable, Timestampable, etc. * [Query/Type Extensions](https://github.com/beberlei/DoctrineExtensions) -- Support for database specific functions in DQL ## [Migrations](http://www.laraveldoctrine.org/docs/1.0/migrations) * Full support for Doctrine migration commands * Generate new migrations from metadata information * Versioned migrations * A Laravel-like Schema Builder ## [ACL (Access Control List)](http://www.laraveldoctrine.org/docs/1.0/acl) * User can belong to Organisation(s) * User can have Roles * User and Roles can have Permissions * Seamless integration with Laravel's Authorization system 
&gt; The cost is unique here. You will need to test the cost on your own server, and try to get the timing between 250ms and 500ms. Just a note about this mentioned 250-500ms hashing time. This recommendation seems way too hight for typical web app situations (interactive login handling). With such work factor DoS risk increases quite much and it is good to remember such aggressive password stretching is kind of "bandaid" (where proper strong password would be the right solution). In general, aim &lt;100ms for interactive logins.
Thank you! Laravel 5 is slower than Symfony 2. By using this package, we will slow down Laravel further! That's a good news!
Not sure if the site is metro and modern or just made by an incompetent designer.
Yeah, I like how C# does this.
Any idea when the [php7 ppa](https://launchpad.net/~ondrej/+archive/ubuntu/php-7.0) will be available for production use? Is it only after the final release?
[removed]
There's a script on the .net man page that auto-calculates out a cost for you. I find that on most systems I get a 12, so it's probably a safe bet. 
Is there a repo for Ubuntu apt-get ready yet?
Do you really have nothing better to do with your life? Go get a girlfriend, or more realistically in your case a fleshlight.
excited
I'm leaning heavily toward incompetent, given that the white navigation against a black background turn dark grey on hover.
I can almost taste it.
&gt; Spread the word: after months of development the first stable version of the API Platform framework has finally been released! I would... but, you guys aren't exactly making it clear what API Platform is and what problem it solves. The feature list looks like an assortment of various things the authors like, spanning everything from the database to the public interface. This would be ok, if it all came together to solve a cohesive purpose, but I'm not sure I see it. It says "API development", but I don't think *creating my DB schemas* falls into the realm of any sort of tooling that keeps itself to the API layer. ---- P.S.: The body text on your blog ^^^is ^^^really ^^^tiny.
Not to dampen your spirits further and this may be specific to the service but I worked at a place where we had a PHP file processing application that had to communicate with a SOAP API, it worked but often times it would return errors. So, we setup a .NET app to do the request instead and noticed that the success rate was 100% with no errors compared to the PHP request.
Yeah but you can see "69% upvoted" so you know some are down voting it.
[Basic math and deduction](http://i.imgur.com/7jsMaIc.png), we're getting off topic now more so than before.
&gt; FHQK.com So... uhmm. How is this pronounced, again? Let me put it this way. How many times can people pronounce the name of your site in a PG-13 movie?
&gt; I readed fabpot telling that multiple connections are a bad idea or something but I readed some posts on internet Can you link that, I'd be curious to see the context? One obvious limitation of sticking with one connection in a modular app is that if you have two or more services that *think* they *own* the connection, both may try to change its state in an incompatible or unexpected way. Like: - Open a transaction from one, and the second one will fail to open another. - Doctrine has a basic provision for "fake" nested transactions, which doesn't quite solve the issue, because now the second one can't independently roll back, while the second commits. - The above can be solved with SAVEPOINTs, but now another problem: what if the *first* service tries to commit before the second one? Oops. - They can't have separate isolation levels within a shared transaction. - If one locks a table, the other, instead of seeing a locked table, will be able to write to the table. - Change charset from one service, the other sees a surprise change of charset. - Call INSERT from service A, call service B. Service B calls INSERT, service A tries to read insert id from its INSERT. Surprise. etc. Long story short, one connection is doable only in a monolithic design, and in there, indeed, one is best. But with decoupled modular design, you need to be ready to open a few at a time. I deal with the performance problems by doing it on-demand from a request-shared connection pool. I log how many connections I *really* open at most in apps, and most of the time it's 1-2. In a very small percent of requests it's 3-4. So it's not that bad.
`makePathRelative` is pretty neat for generating static HTML and linking to CSS/JS files. Autoloader or composer won't help there.
But it does not look to be the same thing that we are talking about. Cause it looks like multiple connections are to achieve concurrency in the same database while the other is related to have different databases in the same app. 
No, it's not related to having multiple connections. But it's even worse, in Symfony's case, because having different databases is such a basic thing to have. It's a symptom of the same "we don't need more than one" fallacy which keeps tripping developers quite frequently. Singletons in disguise.
The blog post is just an announcement. Problems solved by this framework are explained in depth here: https://api-platform.com/doc/1.0/getting-started/ n.b: I've updated the blog post to make this link more visible.
Awesome, thank you.
I'm probably being stupid, but where are the docs?
 Hah: else { echo 'the fuck'; }
Schema.org has evolved a lot since "bunch of microformats about e-commerce products and movie ratings that produce little rich snippets in search results": http://www.w3.org/wiki/WebSchemas / http://json-ld.org/ You can insert the return of a JSON-LD API straight into a &lt;script&gt; tag in JS: https://developers.google.com/structured-data/schema-org JSON-LD is even the recommended format by Google for a while... &gt; JSON-LD is the newest and simplest markup format: it lets you embed a block of JSON data inside a script tag anywhere in the HTML. Since the data does not have to be interleaved with the user-visible text, it's much easier to express nested data items (say, the Country of a PostalAddress of a MusicVenue of an Event). Also, Google can read JSON-LD data even when it is dynamically injected into the page's contents, such as by Javascript code or embedded "widgets". 
Cool! I did not know about that tool! Yeah we can definitely add that to the docs. I was using Mitchell's package too (you may have even used my fork which fixed it for L5!) -- make sure you check out the [upgrade guide](http://www.laraveldoctrine.org/docs/1.0/orm/upgrade) in the docs, I built a laravel command to migrate mitchellvanw config files to our package so that should ease the pain a little :) if you have any questions feel free to ask me or join us on [slack](http://slack.laraveldoctrine.org)!
may be wrong here but: I think he's asking for a resource where he can download PHP 7 in a Linux environment. Example: you have Ubuntu Server 14.04 because it's the latest LTE version. When you install PHP on that system, you get, for instance, PHP 5.4.5 no matter how much time passes and newer versions of PHP come out. Unless you add a 'ppa' that tells the system: "no! download PHP from this place, I know what I'm doing so install this version hosted on this server instead". That's what I understand for PPA at least https://askubuntu.com/questions/4983/what-are-ppas-and-how-do-i-use-them
Redhat and CentOS are patching/supporting PHP 5.4 through the year 2020. CentOS is run on 1/3 of Linux servers. If your app is open to the public, dropping support for PHP 5.4 might not be viable for a number more years.
Great news foxx! I had to extend Mitchell's package as well to get it to work,but gave up as it was working well enough for our db interactions. I have your fork currently in an in-progress lumen install and will be glad to update composer. Cheers for taking this on
bcrypt ftw!
Well, that's their decision. They take full responsibility for it. I do not.
Given it was reported *yesterday* and appears quite active? 
Well, 1 hour a day until I feel confident enough to create an account on a php coders forum....so I can talk shop with everyone without sounding like a total noob. Would then try to make some online friends and help out with a project they're working on (for free) just to get some real world experience. Unpaid internship etc. But thanks....I realize there's a ton of work/study ahead. But better than sitting on my ass playing video games at night.
Month 8, month 9, what's the difference? Pffffft.
Well, they can support it until 2020, but it does not mean that clients won't be able to request php 5.5 or 7.0. It just means that customers that are lazy about migrating their code will have until 2020. The main reason PHP 5.4 will stay is mysql is gone and replaced with mysqli... (which is easy to migrate sadly). PHP 9 will be out and people will still be looking for PHP 5.4 programmers :(
I'm disappointed scrypt hasn't taken over. It's a bit of a moot point, Argon2 should be kicking in soon enough. Let's hope PHP gets on board.
Very nice article and good information
Actually, APC changing has been a significant issue for me in migrating some stuff out of 5.4.
Lumen is even faster than silex too. And I'm a silex user. 
I think this is a good suggestion; though personally, I'd suggest just leaving the cost parameter out and accept the default (just as I'd suggest `PASSWORD_DEFAULT` over `PASSWORD_BCRYPT` as the algorithm). It's currently at 10 which some may consider low, but not problematically so. While tuning it to your environment is a perfectly reasonable thing to do, I think the majority of folks will forget to bump the value over time as hardware improves. By leaving it at the default, it can get bumped for you in a minor point release of PHP (and if you've implemented the `password_needs_rehash` stuff correctly, you don't even have to think about it)
something something negative date ranges
Bookmark this list https://github.com/ziadoz/awesome-php That being said ctrl+f for soap only returned one result :-/
Lol. We are too. Try checking out the wrapper called Rocket Ship It. It's cheap and has a much slicker interface than just manually creating SOAP requests. Works great for FedEx and UPS for us. Haven't tried their DHL service though. 
The php app was poorly designed then. We use nusoap which admittedly has flaws, but handles close to 25,000 incoming requests per day for us with no issues whatsoever. 
&gt; I downvote people not able to read a doc and speaking with confidence about technologies they don't know at all ("JSON-LD is an extremely simple format"). If you think that json_encode() is the right tool to create complex hypermedia API, we have nothing to talk about (not even speaking about security issues of such naive approaches). You kind of drifted from talking about the JSON-LD microformats that Google reads (which **are** simple and you've said nothing demonstrating otherwise) into full-blown Hydra, whose value remains entirely theoretical as of yet. What warranted this "seamless" transition? Is Hydra even a *recommendation* at all? Can you link me to a list of popular Hydra APIs in use? I don't mean W3C drafts and obscure FOSS products. I mean actual uses, with actual value. Like some reasonably big company publishing a Hydra API someone would use, for a reason different than "Look! A Hydra API!" As CORBA and SOAP demonstrate, "dealing with complex APIs" is not a problem people need solved, *they just go for simple APIs*, unless the complex APIs are actually good for something. Something other than handwaving about the future of REST clients. Until there's a case to be made for going full-blown Hydra, people will simply echo json_encode($data) and get the job done. And even in the case of useful, but complex APIs, it's extremely unclear what your framework does. There's an implied assumption I'll design my entire infrastructure starting from a set of JSON-LD formats. This is *completely backwards* from the only sane way to go about it: start from my actual *domain* and adapt data from it to JSON-LD formats as I need. *"Hey I went to the store, and bought this random assortment of really, really complicated professional tools... I'm trying to figure out what I can build with them."* Is this how people think? No. Well, some people think like that. Tinkerers, hobbyists. The kind of people who are typically found waxing poetic about hypermedia APIs. You need to show what the heck is your product about. The closest thing to an example on your site is a broken demo "blog app" which returns "Post published." when I submit an empty form, and throws exceptions when I fill in some data: &gt; DateTime::__construct(): Failed to parse time string (What the hell.) at position 0 (W): The timezone could not be found in the database What a nice demo of user-friendly error handling in a form. "What the hell" indeed.
Whenever I think of salt, I think about 4chan's "random" salting mechanism. "LOOLOLOLOLOLOLOLOL" http://www.reddit.com/r/programming/comments/23umjd/4chan_source_code_leak/ch0qlo9
FTA &gt; PHP executes code from HTML scripts and runs them on server. This ensures a high degree of security. That makes absolutely no sense.
Java is a good language to learn on. If you have zero programming experience, I would highly suggest Java. The main reason is that PHP is primarily used for web development. Java, and many of the concepts associated with it can be applied to a large group of technologies. 
On my phone so I cant give a thorough reply but doctrine supports mappings in yaml, xml, and plain php as well! Annotations is just one method of mapping.I use yaml mappings for a large project I'm working on actually. Check out the docs for orm -&gt; metadata configuration
* YouTrack - Kanban / issue tracking * Slack - IM / notifications * YouTrack to Slack Bot (https://github.com/cinchcast/youtrack-slack-bot) * Jenkins - CI/builds * Github - code review w/pull requests / source control * Rollbar - exceptions * Logentries - log aggregation * Hubot - devops / fun team building stuff 
So you just released 1.0 and you're already moving onto breaking changes? I like your spider mascot though.
&gt; Next up came the salted passwords. The developer would take the users password, generate a random md5 hash that was the salt, and then md5 the user’s password with the salt. The salt was saved in the database in plain text, or possibly encrypted. When the user would sign in, the developer would take the user’s password and stored salt and md5 them the same way. After that, you simply compare the hashes. &gt; &gt; The Issue: Compute power is cheap and easy to get. This means that you can build a custom rainbow table on each stored password. Using video cards hackers were able to get 348 billion hashes per second. Compute power is not that cheap. Those custom video card systems are expensive to run (or Ec2-rent) -that famous machine used 25 top-end GPUs. If you assume a search space of 10 upper/lower/number/punctuation characters, that's still (26\*2+10+34)^10 = 6.64E19 necessary hashes = 190,804,597 seconds to hash all possible combinations at 348 gigahashes/second - 53,001 hours on 25 GPUs, or 1.3 million GPU-hours total. An 8GPU Amazon unit runs $2.60/hour, so that would work out to $2.60 \* 1.3E6 / 8 = **$422,500 per password**. Governments can do that (though few targets are worth spending that much). Hackers cannot. Also &gt; custom rainbow table A rainbow table is a mapping from hash to cleartext password, used for avoiding hash recomputation. You would not use a rainbow table on a salted password, since a different salt would map a hash to a different password. 
It is more about code design here. If you declare all of those variables private and then define a getter for each of them, you simply defeat the purpose of using private in the first place. Edit: and setter
☑ Barely says anything ☑ Poor grammar ☑ Hyperlinks on common words like 'php' ☑ Statement of support from someone who themselves has a history of posting links to the same site Checks out.
Did you read the feature list? https://api-platform.com/#api What do you think about exposing an entity in just a line of conf, built-in pagination, built-in validation system, built-in filtering and ordering, automatically generated human and machine-readable doc (Hydra), serialization groups, optin relation embedding, standard error serialization, automatic JSON-LD context generation... Useless? Doable in 2 lines of PHP? Why do you think of tools such as Loopback, Apigility, FOSRest, JAX-WS... Useless? And thanks for your feedback about the demo. It has been done in a hurry and lack of some polish. We'll rework it soon.
&gt; Did you read the feature list? https://api-platform.com/#api Yup. &gt; What do you think about exposing an entity in just a line of conf, built-in pagination, built-in validation system, built-in filtering and ordering, automatically generated human and machine-readable doc (Hydra), serialization groups, optin relation embedding, standard error serialization, automatic JSON-LD context generation... Useless? You can only automate all this with a line of code if your framework *creates the domain that's exposed via an API*. This means you have a cookie-cutter empty domain that's not connected to anything, it's just CRUD for schema.org entities. The perceived lack of value comes from that architectural choice. It's like throwing away your clothes and painting a jacket &amp; pants on yourself. It'll serve its social function from afar, but you'll still freeze out there in the cold, cause you have no clothes on. It's a facade behind which there's nothing. And this is why I said it's misleading to call it an "API Platform" because it doesn't keep its concerns in the API layer, its responsibility is not connecting existing domains to a public API layer. Instead, it wants to do *everything* from database to HTTP API, and couple it all into a big monolith. I wouldn't call it "useless", but I struggle to identify the value in there. I'm not saying *there isn't value*. I'm saying it's hard to tell what it is. It looks more like a configurable monolithic app with predefined models, than a platform. &gt; And thanks for your feedback about the demo. It has been done in a hurry and lack of some polish. We'll rework it soon. I'd strongly suggest you come up with a sample app, which *makes sense* as a Hydra/REST app. Blog isn't it.
You didn't get it. The model generator and the API system are two standalone fully independent components. You can use the API system with any domain model, even if it is entirely custom. You can even use POPO and skip Doctrine if you want to.
&gt; And what happens with "map it with pagination, sorting, error reporting etc. with one line of code" then? Poof. All those features will work in one line of conf with your custom domain. It is the interest of the API system. They are already two separated components: * API Platform Schema Generator: generates a set of POPO with metadata for ORM, validation and IRI support from Schema.org. Can be used to standalone (apps not API based for instance) * API Platform API bundle: expose any data model with ease (validation, pagination, filtering...) as a REST level 3 API. The model can come from anything (including but not limited to models generated with the other component) I was thinking the site was pretty clear about that... It's the same spirit as with Symfony. You can use the Validator and the Serializer components are standalone and decoupled but you can use them together.
To give a little more "consumer" level numbers. A modern GPU can do ~2 billion hashes per second on MD5 and costs ~$300. Assuming just cost of video cards and wanting to get a hash to under 1 week to break you would need 55,000 GPUs ($16,500,000). However, a mere 10 can crack 8 characters in 4 days. A 9 character can be done by 1000 GPUs in the same amount of time. Huge increase.
&gt; This problem still stands if you take ORMs out of the equation. You read some data from the database, do some transformation on it, and write it back. Unless you have acquired a read lock on the row(s) when you read it, the data might have been modified by something else, by the time you write it back. An ORM can actually help you with this, if it supports some kind of versioning. The problem stands only if you take ORMs out of the equation, then reimplement the same approach as ORMs use, which is that you're describing. An alternative which doesn't suffer from this problem, is modeling domain interactions through commands and queries, and I don't mean fancy Command Bus patterns, or CQRS setups. I mean something as simple as modeling domain interactions as simple method calls to service APIs, that do the actual job. Relational databases have all the facilities we need to update a row in a consistent manner (as you mentioned various levels of lock granularity, transaction isolations etc.), but they're not available when you explicitly decide to treat SQL like a dumb key-value store. As for versioning, I assume you mean optimistic locking, that's a good technique, but not always applicable. Not a silver bullet solution, especially if the resource is highly contended (which means your optimistic locks will fail most of the time, destroying performance), or the scope of the transform isn't strictly limited to a specific row or set of rows with a version.
Awesome stuff! I actually wrote my own doctrine integration including the diff generator and creation of normal migration files (pretty similar to yours based on the docs). Had planned to tidy it up and open source it but been a bit busy actually using it so not had the chance. Good stuff! 
https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence
Feature toggles.. Makes sense, TIL. Will star and try it out next time i need it, looks well written.
I assume the annotations parser uses [ReflectionClass::getDocComment](http://php.net/manual/en/reflectionclass.getdoccomment.php) which is a real thing built into PHP. They're not just parsing the file as text. It's a bit weird to see something "documented" on php.net but also say "Warning This function is currently not documented; only its argument list is available." I haven't tried it but don't think annotations work if your code is encoded with something like IonCube. That said, I've used annotations in Symfony applications and really like them.
I would definitely recommend codecademy. First of all It's free, you can switch and try different languages without installing any extra software which can be a blocker for some. Another alternative is codeschool but this one is more expensive. Another thing is if you have a bit more time it would be worthwhile going through this [free course on introduction to computer science](https://www.edx.org/course/introduction-computer-science-mitx-6-00-1x-5).
&gt; 'd suggest just leaving the cost parameter out and accept the default (just as I'd suggest PASSWORD_DEFAULT over PASSWORD_BCRYPT as the algorithm). It's currently at 10 which some may consider low, but not problematically so. In many cases this indeed sounds a reasonable approach. From the cracking side, PHP's current default cost of 10 is a definite pita. There are some statistics from (a year old) [presentation](http://www.openwall.com/presentations/Passwords14-Energy-Efficient-Cracking/slide-50.html) and the most efficient device tested, Zynq 7045, manages to perform 226,3 bcrypt crypts per second (cost of 12). This would mean ~905 c/s against cost of 10 (in reality a bit more). If there's an array of 1000 of those devices used, it'd be ~905 000 c/s, which is still not "that much" (when compared to weak hashing schemes). AM bcrypt hashes had 12 as the cost and it was a trouble to test even the most common passwords against each of them (I don't think anyone even proceed to try them all, tests were done only against a smaller shuffled subsets of the full list to gain some statistics). But well, maybe we never get to know because of the [nasty mistake](http://cynosureprime.blogspot.fi/2015/09/how-we-cracked-millions-of-ashley.html). 
&gt; softwaredevelopersindia.com Checks out
Is it supported in other languages? Say my database is also accessed by Perl and Python scripts... will they all be able to save and verify the passwords compatible with this PHP function?
Do the same math for a 6, 7 and 8 character password... Also, that ignores that over 50% of passwords can be found with as few as 1,000,000 guesses from a password file (modified dictionary attack)...
I don't know and I don't care to investigate this. It follows the `crypt(3)` format so in principle it should work.
+1
This is pretty much identical to their existing subscription plan then. I suppose the only difference is that going forward you'll have to opt out of the subscription if you want to stop instead of opting in like you do now.
Java is used in a fuck-ton of technologies. Everything from refrigerators to Android devices. 
How did you do this securely? EDIT: Deleted post claimed they backported [password_compat](https://github.com/ircmaxell/password_compat) to 5.2.
It opens a lot of questions, most interesting of which to me is: will they ensure I can port settings from v5 to v4 or will I lose all my IDE &amp; project settings when I revert to a previous version? Seems like a very neat way (for them) to make me keep paying indefinitely, or always pay in 12 months bulk. It'll create curious edge cases, where I subscribe, get v2, then in one month v3 comes out. I'll need to pay total of 24 months to be able to use v3, despite I've used v2 for only a month. Make you wonder, why the heck is all this necessary? **EDIT**: A possible tweak that fixes the above problem is you get perpetual license for any version you've used on subscription for over 12 months. So you subscribe for v2, one month later v3 comes out, you'll need to pay total 13 months to keep v3. Fair, no? What say you, JetBrains? **EDIT 2**: It seems my "tweak" is actually what it is (thx /u/sanmadjack). The wording in the announcement left me with a different impression, but this graph here clarifies: https://sales.jetbrains.com/hc/en-gb/articles/204784622-What-is-perpetual-fallback-license-
&gt; You pay a fee and get a license. If you pay 12-months worth of license fee's you get a perpetual license for the version you're on month #1 of your purchase. Every month you buy gives you access to whatever the current version is. You're not addressing the edge cases I specified. A new version won't come out exactly every 12 months and exactly before you renew. This means you may for up to 23 months in order to keep a version you prefer. Logic. It's a bitch. &gt; Because they had completely removed the option for perpetual licenses. I don't mean why *this* update to their conditions was necessary, but why are the rules deliberately inconvenient.
I'm sorry. I forgot to realize you want everything to work out in your favor every month :D I pretty much guarentee they wont do the 23 month example you're talking about -- people would be irate. So I see this as a non-issue. They're goal is likely the release some bug fixes, and some updates every month to say "hey -- look we're giving you convienant timely updates ... as per your subscription". Right now with yearly licenses they dont have incentives to do that. I dont see the rules as inconvenient. You can't have your cake and eat it too all the time. Our voices got back perpetual licenses -- be happy with that :P or find yourself another product (such as Emacs or Vi) where none of this matters.
I don't know why you're getting downvoted. What you are saying really is an issue.
From what I understand, if you purchase under the current model, you get to keep whatever version was last released when your year of updates ends.
Your "possible tweak" looks to be how it actually is, check this page: https://sales.jetbrains.com/hc/en-gb/articles/204784622-What-is-perpetual-fallback-license- 
Thanks for the suggestions; most of the semantics are worth considering. I originally considered that configuring the bucket granularity would be a desirable feature, but we decided to go for 10 buckets at first in the interest of getting things done. 10% increments works well for us. However, configuring the number of buckets will probably land in a future version of the lib. I'm not sure if scheduled releases would fit in the core library, but I do like the idea on the surface. Maybe as a plugin, or companion library that depends on Swivel... 
Well I was thinking about using this for A/B testing, I guess i could do something with 5/5... but having the amount of buckets configurable would be super awesome.
This hits home
A/B testing is *definitely* a good fit for Swivel. In fact, with the current 10% granularity, you can do a couple of things: 1. Run a risky A/B test on only 10% of your users. If it converts better, increase the size to 20% (2 buckets), and continue doing so until it rolls out to 100%. If it converts worse, you only affected 10% of your users instead of 50%. 2. Run several tests on groups of users at the same time, with a control group. Imagine testing the color of a call-to-action button. 10% of your users could see a green button, 10% a purple one, 10% a blue one, etc. If that's too granular, you could do it with 2 buckets for each test.
Yeah, interesting... Just seemed a natural extension to have it configurable.
I should mention that we also made a CakePHP Plugin [swivel-cake](https://github.com/zumba/swivel-cake), and a companion javascript library [swiveljs](https://github.com/zumba/swiveljs). They are both pre-release versions, but they're generally stable and follow the same (or very similar) api conventions as the core library.
To be fair though, php storm now only costs me 53/year + I get another year for free + they brought perpetual licensed back in some form at least they won't forcefully take my tool. I'm not even that mad. https://www.jetbrains.com/toolbox/
I actually have a mandated (by court) limit on the uses of the word "troll": once per month. I chose to use it here. So it's kinda like a little reward, actually. *StormPath, I bestow thee the title of "troll" for the month of September! Congratulations!*
It's all in jest. You could say I'm tro... oh wait, I already used up my September quota, *damn*. A serious question, folks, if I understand this right, this is a SDK which relies on a service, you're hosting the keys &amp; serving auth requests, right? It's an interesting idea, but from the PoV of a user, it's somewhat awkward to use a 3rd party service that's just hosting my API keys and handling auth requests, while everything else is hosted with me. It seems like one would want the API and the auth in one place, unless you're integrating with something bigger (or you *are* something bigger, and need to go "distributed"), which provides value for the users, like the convenience of logging in through Facebook and GitHub. So, I'm saying. I understand your business plan. But I don't understand your value proposition. I feel pretty much the same SDK can be produced which is hosted where it's needed, and which doesn't depend on a third party service. 
Yeah, this is huge and I'm amazed that people aren't upset about it. The whole problem with subscriptions was that you lose your IDE when you stop paying. The way I see it, getting dropped back 2-3 versions is basically just as bad as losing it completely. Why bother at that point? The feature set of 3-versions-ago will probably be on par with the free/community version at the time anyway, so what is someone really getting? Ultimately their goal is to keep people subscribed without upsetting them anymore than they already have, but it just seems to backwards that unless you pay for another year forward in your subscription, they take away what you already have and push you BACK a year.
Wait a minute, first I need a tutorial on how to turn on my computer.
It's even worse. If they release v9.1, you get v9.0.
You have to resubscribe for 3 months. That seems fair to me. Otherwise you aren't paying for the whole new v3. You are expecting to get the WHOLE v3, by only paying for 3 months of it. Thats not how business works. And in your other example, if they ramp up version releasing, who's to say they wont alter this particular issue.
That's correct -- eg: Stormpath is an API service itself, which allows you (a developer) to store user accounts, API keys, and other auth-related things in a centralized database. For users, I think it makes sense to use something like Stormpath because you get some cool benefits you don't necessarily get using a typical web framework, eg: * Central database you can access via an API from anywhere: cron jobs, scripts, CLI, web UI, etc. * It has client libraries in a variety of programming languages, so if you're building large (or complex) projects with multiple components (service oriented architecture), it can be a lot easier to access auth stuff without doing hacks like sharing a database server between services, etc. * It provides a nice UI dashboard for managing applications, users, permissions, etc. -- So if you're a company with multiple independent projects, you can consolidate your view into one place. * It does all sorts of smart caching / optimization to retrieve user information / auth requests. * It handles complex authentication scenarios: hierarchal permissions, groups, roles, etc. * It handles integration with other authentication sources: social login providers, AD / LDAP. * It provides single sign on support for people building apps that span across multiple domains / subdomains. * We handle all the email flows too: password reset / account verification / etc. I think overall, it's honestly useful for a lot of people (depending on requirements). And since we host all the data, it makes it really easy to simplify the developer code. We can magically abstract a lotta stuff that would be hard to do otherwise. Hope that helps explain it a bit. And also: thanks for the feedback ^^ This is really useful to hear.
That's how the CURRENT system works.
for fuck sake dont use this tutorial, please
&gt;The way that php communicates with a database is through the MySQLi object. So to start you have to create a MySQLi object and by doing that you use the following code: &gt;$con = new MySQLi(); What, does PHP refuse to work with Postgres, SQLite or anything by MySQL now? Even MariaDB is out of the question? PDO isn't in the language anymore? It is, at best, extremely misleading to say that. &gt;I usually set these arguments in variables to make things clearer and more understandable: &gt;$hostname = "localhost"; &gt;$username = "username"; &gt;$database = "databaseName"; &gt;$password = "password"; &gt;$con = new MySQLi($hostname, $username, $password, $database); [Best practices right there.](https://www.reddit.com/r/netsec/comments/g76um/tumblr_security_leak_caused_by_developers_typo/) 
All of this is really hurting my head.
Yes. That is what I said, and what the linked doc says. That is not what you were saying.
Well put. The AM example is a great one of why security is so damn hard. Provided you're using bycrpt/scrypt/pbkdf2 at all (and correctly), the stored hash is almost certainly not going to be the weakest link anymore. Unless the attacker is targeting a specific account, they're going to look for other vectors because bruteforce becomes fairly impractical against passwords that aren't utter garbage.
The blog post currently include this; I don't know if it was inserted after your post: &gt; You will receive perpetual fallback licenses for every version you’ve paid 12 consecutive months for in a rolling fashion.
no, because you pay upfront for the new upgraded version currently.
Holy fuck, between this and the [Codeigniter Example](http://codesok.com/programming/php/codeigniter/calling-sql-server-stored-procedure-from-codeigniter/) post, it's no wonder /r/lolphp exists.
I hope this style of documentation and site design takes off. Taylor might be pissed, but if *all* software were documented like this, it would so much easier for everyone to learn how to build software. 1. Generous whitespace 2. Logical organization 3. Rich with simple examples 4. Just enough prose to explain concepts that examples alone can't show I honestly wish the ACTUAL Doctrine documentation was formatted and organized like this.... I know the Laravel site is open source already, but Taylor should make the Laravel site into an "official" library/skeleton for documentation, and/or make it a theme for readthedocs.
&gt; What, does PHP refuse to work with Postgres, SQLite or anything by MySQL now? Even MariaDB is out of the question? PDO isn't in the language anymore? It is, at best, extremely misleading to say that. I don't think PHP uses any of these databases. It uses the Doctrine and Eloquent databases.
I actually have no idea how I'm even typing this. Please send help.
The reason that the subscription model works for Adobe is because their product line is just SO damn expensive, so the subscription is a hell of a deal. In the case of PHPStorm the cost of the software isn't that expensive so, it's no deal for the end user. None. It only confuses things. Sorry JetBrains, I'm not sold. Not even a little. Although I love your product, I don't want to feel tied to your subscription. This is a perfect opportunity for one of your competitors to step up and grab some new users.
You'd need to create a doctrine implementation of `UserInterface` and `GroupInterface` along with their respective `Provider` interfaces. Given that the Active Record pattern is baked into the interface, that'd be...clunky, at best.
I'm very excited about the other 63. I'm a hipster myself.
So, you declare all those variables private and only create a getter for whatever you need to expose.
Honestly, this is one of the things I like about Ruby, where you can automatically create setters and getters for specific variables via attr_accessor, attr_reader and attr_writer, while at the same time, creating your own methods using the same convention without conflict. The caller isn't aware if he is accessing a variable via attr_accessor, attr_reader, attr_writer, or a custom method.
Not neccessarily scheduled releases - I can emulate those easily - but the ability to deploy to a fraction of users (and retain the previous fraction, if any) would be great, I think. It would make the library much more flexible.
3rd variation: public function __get($name) { switch ($name) { case "foo": case "bar": return $this-&gt;$name; } }
Congrats, I've been waiting for it for a while now!
Ultimate was pretty expensive. 
&gt; What I have a problem with is renting software. Read every license to the software you use. You don't own software. &gt; Unfortunately, as I said, it's an illusion. An illusion for what? They're not trying to hide anything. They're pretty straightforward.
&gt; Following the best practices for persisted login And when I follow the link, I see this: &gt; The login cookie contains the user's username, a series identifier, and a token. The series and token are unguessable random numbers from a suitably large space. All three are stored together in a database table. I'm not sure if I would consider storing the user's username a best practice. The article in question was published in 2006, while most research on timing attacks in web applications that I've found is newer than that. [The model I proposed](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2) is both zero-knowledge (the cookie doesn't store a user ID or user name) and designed to mitigate *useful* side-channels (e.g. timing attacks). I'd argue that this is better in general, but maybe the 2006 best practices is good enough for your users. If anyone sees any weaknesses in my design, please do speak up, because I'm going to be implementing it in a project of mine in the next couple of days. ;)
No. Not at all. I mean Java. Not JavaScript. They are completely different. 
Hopefully they'll actually focus on better QA for that extra $3
Huh?
Then you're only paying 1 month for the newest version. Which is counter to the entire 'pay 12 months to get a license' thing they're evidently trying to do.
Yes, and in PHP 7 we'll be able to do this $x = $foo ?? 'default_value';
Yeah, I was going to talk about that in this post. I am excited about it. I wish it would deal with empty and isset. :(
 $isTrue = $foo === 'bar' ?: false;
I did not know that you could leave that part out. Sweet learned something :D
The native one isn't always compatible. I find myself overriding the request/response handlers in order to manipulate the XML directly so PHP doesn't throw a fit about it / fail to automagically parse the data.
yeah, only difference is if the first part is true it will always return true. So it's almost like a shortcut for `isset()` and not if:else imho. I use it 90% of the time on form inputs that handle toggle settings like checkboxes, I can't actually figure out a use outside of that. PHP 7's `??` will be the bees knees though because it's the best of both worlds.
[Jetbrains PhpStorm](https://www.jetbrains.com/phpstorm/)
Lesson learned... never announce two announcement on one. Announce the 2nd version development later ;) .
&gt; I wish it would deal with empty and isset. :( What do you mean?
I'm definitely happy with this. The criticism is valid though. If you want to carry on as always the significant change is that if you choose to leave you'll lose all updates and bug fixes for the last year, while before you got to keep them. The reason is probably that now everybody will be on some sort of EAP and it will be impossible to distinguish beteeen fixes and new features. EDIT: apparently you get to keep all minor versions as well. So the only remaining complaint would be that they will release new versions more often. In reality you would probably have to go back half a year or so. Maybe they'll follow the browsers' lead and come out with a new version every 2 month, then you'd be going 10 months back. All-in-all a very attractive proposition in my view.
I tend to avoid it as much as possible, because I feel it is less readable and understandable (thus less maintainable) than an 'if' statement. Also, I try to avoid 'else' as it is usually not necessary when you use guard clauses or default values. if ($someCondition) { return $someValue; } return $otherValue; Or: $someVariable = "default" if ($someCondition) { $someVariable = "special" } Understandability trumps conciseness in my book. Edit: was using wrong markdown
In this example, you don't need the ternary at all.
The timing attack would not work in this case, since you have a single try to guess the token, after which it is deleted. Additionally a timing attack relies on being able to generate tokens that result in a particular hash, in this case it would not be possible, since the hashed string is 40 characters long and must start with a seriesidentifier. It is impossible to be able to generate tokens like that that result in a specific hash. so even deleting the token is not needed in this case. I actually saw your article when implementing this, but the stackoverflow thread with the 2006 approach and the updated 2015 is super popular and has been analyzed back and forth a bunch of times: http://stackoverflow.com/questions/244882/what-is-the-best-way-to-implement-remember-me-for-a-website The resulting consensus from other threads was that 2006 approach is actually more secure than 2015 one. The actual token handling code is here: https://github.com/PHPixie/Security/blob/master/src/PHPixie/Security/Tokens/Handler.php (token handler) https://github.com/PHPixie/Auth-HTTP/blob/master/src/PHPixie/AuthHTTP/Providers/Cookie.php (cookie handler) If you have the time to take a quick look I'd highly appreciate any input on possible security improvements. 
I missphrased that, I did not mean that your strategy can lead to a logout. I was saying that since the cookie is used so rarely and in the worst case you just have to relogin removing the token entirely when theft is assumed is the most secure option.
From what I read for strings of that size md5() is suffiicient. Since the same token approach can be used to allow a cookie-only sessionless login too, I did not see much of a reason to run something heavier than md5 on every request. I have never seen a rainbow table for 60 character long inputs )))
Not OP, but i guess he means that you still have to check for empty strings like this: !empty($value) ? $value : 'default'
There are two common scenarios: The variable is there, you care if it's empty: $value = $value ?: "default"; Or the variable may or may not be there, you care to create it if it's not there: $value = $value ?? "default"; Probably in some scenarios you expect both situations and both are meaningful. Not a common case with clean code (not mine, at least), but if I'm wrong, expect this in PHP8: $value = $value ??: "default"; Until then you can achieve the same via... $value = $value ?? null ?: "default"; Or if you're a really lazy typer: $value = $value ??0?: "default"; As a bonus this will produce questions marks not only in your source, but also in the heads of people reading it. Ok that's enough non-ternary ternary combos for today...
MD5 is [broken](https://en.wikipedia.org/wiki/MD5#Security) as an algorithm. If you legitimately need a fast cryptographic hash, use SHA512 or something.
I use it if the resulted line is not too long.
I typically break them up over several lines. $foo = (count($a) &gt; 0) ? "bar" : "No entries"; Which I find is more readable than if...else and a single line ternary expression.
Also http://natmchugh.blogspot.fr/2015/02/create-your-own-md5-collisions.html
This sub varies between more advanced stuff and pretty basic stuff
Use prepared statements. Dont use the old mysql extention. Use PDO or Mysqli instead. 
### This article is misleading. Maybe even harmful. This article makes the same mistake a lot of articles on SQL injection makes: It attempts to "teach the controversy" by proposing that input escaping and prepared statements are two equally viable methods to prevent SQL injection. **[Prepared statements should be prioritized over input escaping](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide).** Here's why: 1. Prepared statements (when not being emulated by PHP) are provably secure against SQL injection: the query string and the parameters are sent in *separate packets*. 2. Input escaping has [fallen to Unicode disagreement issues](http://stackoverflow.com/a/12118602/2224584) before. 3. When you escape your input, you are necessarily corrupting your data before it's inserted. Even if it's a "desirable" corruption. You might benefit from reading [A Gentle Introduction to Application Security](https://paragonie.com/blog/2015/08/gentle-introduction-application-security), which proposes a new model for conceptualizing security vulnerabilities without instilling a checklist mentality. Always try to use prepared statements. If you cannot, then use a very strict whitelist. As long as you do this (and make sure you turn off the "emulate prepares" setting), you can kiss SQL injection goodbye.
PHP Storm
I don't use it if it has a likelihood of becoming a more complex set of cases or checks.
True. I couldn't think of a better example at the moment.
I assume the purpose is so you don't need to share session cookies across servers (although the problem of sharing session *state* remains... not sure if you have any). In this case I'd propose local cache: you decrypt a cookie the first time, then you query the local cache (by looking it up as a key), which means the crypto can be very slow, but it'll only need to run the first time it hits every server. Say a Memcached solution would be very suitable for this.
&gt; The whole purpose of hashing is not to store raw tokens anywhere. Putting them in mamcached entirely defeats that purpose. Its same as storing in database. Way to miss the point there, but I won't hold it against you. Cache is not state. You can create it, replicate it, lose it, and create it again. The point of cache is to run faster when you need to recompute the same thing over and over in a cohesive block of space and time. &gt; And the purpose is not to handling mulltiple servers, but ensuring a persistent login. A session only lasts until the browser is open Great, well, then use a cache, and when a cookie is not used for an hour, remove it from the cache. Then when the user opens their browser again, you'll compute the cache from the same cookie again. 
Well your cache is going to store valid cookies in that case. An attacker that gained access to your memcached can login as any user
I've used jEdit, Notepad ++, Eclipse, and PHP Storm. Eclipse and PHP Storm I would say.
&gt; Well your cache is going to store valid cookies in that case. An attacker that gained access to your memcached can login as any user You can run Memcached as your user, and connect through a unix pipe. It's exactly as secure as your source code is. I have a suggestion: instead of constantly changing your arguments and fighting back like a cat backed into a corner, just accept a good advice and consider it. I'm not giving you useful feedback to feel better about myself, I'm giving it so you can implement it and have a better product. It's full of caching solutions out there which are local to your user, or even local to your PHP process. It's not smart to use MD5 for performance reasons and ignore the obvious performant and secure solution. 
By same logic you can say your Mysql is also as secure and dont hash password at all. You dont seem to get the idea of "dont store critical info anywhere"
If it's not violating our rules then we let it stay. We don't want to start moderating posts on how advanced their content is because that is a very slippery slope. That said, we *do* remove the obvious spam that does little more than copy/paste the manual, or links to tiny one or two paragraph posts that add nothing of value.
cookie pointing to username is considered password equivalent. thats why you hash them in the first place
I am glad that you understand the advanced topics when it comes to PHP. However, PHP gets that bad rep because we have people write spaghetti code and not optimizing well. I am trying to provide value as I can. I mentor a lot of teens and adults on PHP and I see a lot of these simple topics lost. Also I did not work with the MySQL tutorial, but I think it was good effort. The internet does not forget, so we need to over power the older out-dated tutorials. I would love to have suggestions on advanced topics anyone would like to see.
I can honestly say, of the "basic PHP" articles we've been getting last few days, yours is the best, because it doesn't blatantly disregard security or show mind-boggling ignorance that leads people astray. It's just a neat article about the ternary operator. It's just that last few days this subreddit's been flooded with beginner-level stuff of questionable quality and I kind of mentally added your article in that pile, as well. But it doesn't belong there, so apologies. :-)
And, what, use `rand()` for salt generation?
How come? If you need the user space caching, there's apcu, which is APC minus the byte code cache. It was labelled as beta, but we've been using it successfully in production on a very high traffic SaaS app for a while already.
It's extremely hard to do zero-downtime deployments around extension swap and conditional function presence, and the code in question had next-to-no test coverage. Plus the developer working on that wasn't particularly productive. If it was a personal project where nines of uptime weren't an issue, yes, that would probably have been my approach.
Just an FYI. If you continue like this, you'll surely get banned sooner, rather than later. Reddit is not for promoting your own content. Read the rules, read the reddiquette, check out the article on [self-promotion](https://www.reddit.com/wiki/selfpromotion). A general rule of thumb is that 10% or less of your posting and conversation should link to your own content. Currently it looks like this: Recent Submission history for cweaver87: domain submitted from|count|% :-|-:|-: [shylor.com](/search?q=%28and+site%3A%27shylor.com%27+author%3A%27cweaver87%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|2|100% subreddit submitted to|count|% :-|-:|-: [PHP](/r/PHP/search?q=author%3A%27cweaver87%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|2|100%
&gt; Well they are slow on purpose. No they are not at all. If SHA* was designed to be slow, we would get developers arguing in favour of MD5 that it was supposed to replace. The SHA3 selection competition actually excluded several contenders because they were too slow. &gt;The thing is that with 60 character long input the hash function really does not matter You've heard the whole thing about Chrome removing support for MD5 signed SSL signatures right? Those certificates are longer than 60 bytes, and yet Chrome disables, for your own safety, any site using an MD5 signed certificate. This is like someone trying to write their own version of MySQL_escape_string and then presenting arguments as to why "it's good enough for my purpose". Every single Rails session uses two separate SHA iterations in creating an HMAC, and no one has ever suggested things would speed up if they used MD5 (although I still get upset about the base64 encoding of base64 data).
Simply put - compile yourself from source code. Even worse advice - try looking for the .dll in google, but I not only do not take any responsibility on what happens next, I will blame you directly for any issues that will happen. Long story short - you are forced to update. Period. PHP versions have support of a 3 year window since 5.3/5.4 - 2 years active support, one year security fixes only. Most external modules follow that now, and with PHP 7 rolling in with it's big changes on the internal side, expect even more modules just to stop supporting PHP 5 branches in current versions. The chabges are big and serious to the point that most extensions will not have the manpower to support any old PHP versions, even still technically active once.
I'm assuming they used the official Laravel.com source code then modified it to suit their needs. The Laravel.com code is [available on GitHub](https://github.com/laravel/laravel.com).
&gt; I will push for updating the PHP version whenever it's actually necessary. Unnecessary work is frowned upon! I can taste deep sarcasm and some resentment I know the feeling...
the rollback/fallback is just stupid
I was trying to do the same a while ago. I wasn't able to make it work in Windows so I ended up using vagrant with linux. I write the code with my IDE in windows, and push it to linux for testing.
Might be Stockholm syndrome, but I actually kinda like SOAP... I used [wsdl2phpgenerator](https://github.com/wsdl2phpgenerator/wsdl2phpgenerator) for a recent project, and it saved me a load of time. Just run the WSDLs through that and you can get started building your own classes on top of the auto-generated ones. I didn't find a need for any of the other SOAP wrappers out there, the PHP built-in classes and the auto-generated wsdl2php classes are good enough to extend and build upon. You can use [SoapUI](http://www.soapui.org/) to fire off test requests.
Would a transcribing on Youtube be worth the effort?
&gt; eZ Publish was gradually written to a **Symfony** 2 Full Stack application from a PHP application dating back to 1999. &gt; ... &gt; Learn more here: Want to be a Drupal 8 Expert? Start with **Symfony** &gt; ... &gt; Typo3 had a renewal strategy with their own framework, but I find the unofficial effort of integrating **Symfony** Full Stack Framework with Typo3 more interesting. Huh. :-) Author is not biased or anything? All examples of "modernizing" PHP are about becoming dependent on Symfony 2. Not sure that's quite representative of what modern PHP is about. 
"or higher"? I hope you don't intend to use 7 in production (yet)? Otherwise I agree with you
People would be more likely to watch it I guess. It's up to the transcriber.
Recently I started in a new job, it's my first coding in PHP, and I began to modernize a 13 years old PHP application. I'm using Code Igniter and Twig. CI is a very simple and plain framework, even for me who never coded in PHP before. It was very simple to start with. This application is in fact a lot of subsystems, with a multiple ways to login, next week we'll push to production a unified login system. CI was very helpful in that, by not staying in the way about the approach we choose to integrate the new and old systems, populating the $_SESSION global and passing it to the legacy apps.
It's a polite way of saying "I'm nearly 100% sure that is not a best practice" and implying that you're open to conversation about why it might be. Nothing wrong with what they said.
I've used this project a lot. It is very handy. Can't wait for PHP 7.1 with enum support (hopefully will get through) to get rid of many IDE warnings around string / type warning on the generated PHPDoc 
We are not seeking to make it today modern, we are seeking to make it more modern than it is right now. Pasting the comment from the blog post: I was waiting for this. :P We are treating this rewrite as a intermediary rewrite. After this is finished we'll start another one to ~really~ modernize the applications. There's a lot of bad practices, security holes, etc. There's no tests, no documentation, no structure, it's a pure mess, we are even a bit scared to upgrade the PHP version in the production environment. So we choose to stay with the most simple and easier to learn, to do it fast. The DB is a Oracle legacy database, ORMs and such has no use to us right now. That's why we choose a simple framework without conventions or bit tool chains. Laravel looks nice to start a new project but it doesn't look like it play well with a big messy old code base. We need to provide 100% compatibility between each system during the migration and Laravel requires a newer PHP version. Maybe Symfony will be our choice for the next step.
CodeIgniter is pretty much a legacy framework at this point. It's ok if you have an old project that still uses it, it's at least better than most vanilla PHP apps, but it shouldn't be used for new development now that there are modern frameworks available (notably Laravel, but also Symfony and others). Aside from that, I did something similar for a while where I had the new framework code running on some pages, but deferring to the old code for other pages. It worked, but it's a pain to maintain and we're pushing to get everything moved to Laravel now so that we can more easily upgrade the way the database and code work.
Maintainer of wsdl2phpgenerator here. I am glad you found the project useful.
One important thing you should be aware of is that there are two different versions of php 5.3 for windows that carry the exact same version (don't ask! Read /r/lolphp if you need to vent). You can download both from php.net somewhere, one will not work while the other will. What I had to do was to install the right one in a windows vm to get the dlls and then copy them over to our production server - which, because of unfortunate circumstances, was a windows server. I don't recall the details anymore, only that I had to make some frantic magic on a server without proper access^\* up to the last hour before an extremely important deadline. Maybe the whole installation has to be from the same package, maybe you can get away with only copying over the relevant modules. The crazy thing here is that both working modules and the non-working ones would report the exact version, so the only way I could distinguish was by meticulously keeping the separate. \*: I could access the server but couldn't up- or download. I could however start IE and download to the default download folder. So I would place the files I needed on my own server somewhere accessible from the net, then log in to the prod-server, start IE and download files (of course certain types had to renamed to not get blocked). Imagine now after a night without sleep, under extreme pressure keeping track of two identical (but different) set of php dlls, uploading, renaming moving, restarting server, testing, repeat until success. One of my worst surprises with php and windows ever.
I'm curious. How are you telling that a PHP Code is a modern code ? I'm doing a huge refactoring, so I would like to know if I'm missing something ;)
I've got to disagree with a lot of what's written there. You should judge CI for what it is, not what it isn't. It's not a modern framework, but it is a great lightweight framework for simple sites. The default symphony install is something like 5x the size of a CI website I've been maintaining on and off for 3 years.
http://blogs.technet.com/b/srd/archive/2012/06/06/more-information-about-the-digital-certificates-used-to-sign-the-flame-malware.aspx
What, you think RHEL is gonna find and fix core security bugs when not even core php developers are doing so anymore? 
As a guy working on a project for 1.2 years and at 40k SLOC (JavaScript, PHP, Bash combined), is it too late to use ORM? Is there a strategy to start using it now? I think it would help our code become more testable and more structured.
A good follow-up would be how to write your app as to be independent from any framework.
 foreach ( $array['data'] as $entry ) { var_dump( $entry["firstname"] ); var_dump( $entry["lastname"] ); } 
If you don't need something macro sized, you can try micro frameworks, such as Silex, Slim or Lumen. Apart from not being modern, the biggest problem CI faces is relying on builtin libraries, which aren't compatible with other projects and heavily coupled to CI. For example, let's consider CI's ability to detect an operating system. Modern frameworks either: a. Create a component that rules them all, such as Symfony components that can be used in other projects. b. Integrate open source projects into framework's core. Why? Because everyone learned interoperability and decoupled components are very important thing, and that's what keeps us from reinventing wheel over and over again. Back in the days we had no Composer, no namespacing so Code Igniter couldn't do much apart from writing an Operating System library. However, since CI slowly disappeared from the scene and that Operating System library isn't compatible for outer projects, it received no pull requests or updates. As a result, CI recently got ability to detect "Windows 7" machines. Nowadays, we can simply go to packagist, write "browser detect", find a package that is constantly updates with loads of features, and integrate it into our application with a single command. Like everything, software and frameworks evolve. Just like how we have almost self-driving cars nowadays, but 15 years ago automatic gear was a big thing. 30 years ago diesel engines were the hype, 70 years ago cars didn't even have side mirrors. Every person, every company and every project has different requirements, and the best programmers are the ones who can analyze the situation and use the best tools. To me (no offense) I feel like there is a little point in rewriting a legacy APP in CI. Sure, it could be their requirement. Perhabs they run alot of applications on the same server and cannot upgrade their versions? Could be. Perhabs they want to slowly integrate the legacy app into CI? Could be. But, you'll still be creating a technical debt and face the exact same problem in the next 4 years. &gt; but it is a great lightweight framework for simple sites. CI was abandoned few years back and literally didn't receive any updates meanwhile. What would you do if someone found a security hole and could easily hack into your 3 years old project because there is a flaw deep inside the framework's core? The community closed their public forums, literally nobody checks the code-igniter tab on Stackoverflow, Google searches returns nothing. What would you do? Just because you worked on a project for 3 years (kudos to you there) and so far it did well (e.g no troubles) doesn't mean y &gt; 5x the size of a CI website Size doesn't matter at all. Having a big application only gives you a trouble if you: a. don't have a proper deployment method and need to upload 100MB of files via FTP. b. Your shared hosting gives you less than 100MB of storage. The only thing that matters is the footprint. How many classes are being loaded? How dependant are you on those? How much resources does your APP take on each request? Is it big because it has enterprisey features or just bloated? Can your "small" application scale with PHP 5.2 to the point where my "big" application can scale with PHP 5.6 and Opcache alone? What can you do for scalability, where I can always rely on Laravel Queues and offload work to other servers, which is the reason why framework is big in size because it is included with useful tools? To be honest, I can't think of a situation where CI would be a better alternative compared to PHP 5.6/Silex/Composer.
 $firstnames = array_column($your_array['data'], 'firstname'); $lastnames = array_column($your_array['data'], 'lastname'); Only works in PHP 5.5+. Or you can do a loop as suggested by another user, which might be better if you want the first names and last names together.
Depends. For small projects, relying on reusable packages and writing reusable/testable classes which are not directly coupled into your project, while using a package manager such as Composer and using modern software development practices and patterns would be enough. For example, I wouldn't call a Laravel 5.1 project as modern if you did all the work on god classes and have messed up relations with zero documentation. For big projects, you may want to extend it. Your code could be modern, but it is not enough to call your whole project as modern just for three table application. Ask yourself, is your frontend modern too? Is your routes compatible with REST? Do you write tests? Do you have a proper frontend workflow? Can your app scale by throwing more nodes at it? Are you using the best tools industry has? Do you write tests? Do you make checks with continuous integration tools? Is your project bloated with unnecessary features? Is your project performant? Does your project obeys SOLID principles? Do you have modern deployment plans? Do you have modern provisioning tools? Can I join your right now and get your project working in my laptop in 10 minutes? Can I be greeted by a documentation of your project? Also, I personally care about the architecture and your whole stack. How likely is your application to run in 3 years without making major changes? Do you have dependency on [insert something about to die] instead of [something that looks very promising]? Does your dependencies live on outdated LTS branches instead of master? If you're interested just in the PHP side: check how modern frameworks and packages write tests and how they use CI tools. Check how frameworks rely on certain architectures and patterns. Check how they seperate tasks into seperate classes. I don't know any projects but I'm pretty sure you can read the code of php league member's packages. It may give you an insight.
Have you tried these ones: http://windows.php.net/downloads/pecl/releases/imagick/3.1.2/ What exact version of PHP? 5.3.? and TS or NTS? Are you using mod_php or cgi?
Old timers be like "PHP is not C#" and "we can do this already with feature x/y/z"
Since you are working with JSON, you could have also used [JMSEPath](http://jmespath.org/). There is a [fully compliant PHP library](https://github.com/jmespath/jmespath.php) as well.
Just Google it. I'm sure you'll find tons of tutorials 
http://www.phptherightway.com/ http://shop.oreilly.com/product/0636920033868.do https://laracasts.com/ Have fun, good job, and good luck!!
That's not my code. Just thought it was relevant to the "PHP 5.5+" thing...
No problem, just watch out since the issue with most PHP literature is just wrong on when you think about how the "modern" php paradigm works. Though depending on how legacy your company's proprietary framework is you probably wont use anything you read to a point and just need to learn how "they do php". One major clue would be to see what version of PHP they use :3 
Try `php -m` if you have shell access. Otherwise just make a script with `phpinfo()` and search for ImageMagick.
When accessing an internal property of an object is there any reason to do so via a getter method rather than directly referencing the variable? [X-Post Link](https://www.reddit.com/r/PHPhelp/comments/3lr86c/referencing_object_properties_directly_vs/)
By using setters/getters, you have more control over exactly how the properties are updated. Super simple example would be if you wanted a log message to be printed whenever the object's property gets updated while debugging. Another benefit is that it's a layer of abstraction, so if you needed to update the underlying object down the road, you can reflect the changes in the getter once rather than trekking through your code and updating every instance where it's used! There's lots of other reasons but those two are the ones that bit me before I started using getters/setters. For more discussion on the topic, check out [this stack overflow question with loads of great answers](http://stackoverflow.com/questions/1568091/why-use-getters-and-setters)
If i want to upload an image to imgur with their API with a form submission, I want a separate loading screen while it handles the curl request, how do I do that? Since all it does for now is just "wait" for the request to finish and then transfer it to the page.
No. 
&gt; I thought about making an offline browser based application. No, there is really no such thing as a offline browser based application with PHP. But install a local webbserver at your friends computer, like XAMPP, and he can run it like any web application through http://localhost/.
With PHP and MySQL you can definitely do it. I've done similar projects before. Hopefully it is a small hotel though, because you are looking at a big commitment versus what an out-of-the-box solution would provise.
&gt; Here's a snippet I found to see if it's installed: And the outcome is "loaded" or "not loaded"? If its loaded, make a [tiny example](http://php.net/manual/en/imagick.examples-1.php) just to be sure that it really works and that you have the right path to the image. &gt; More than anything else, I want to write text to an image file. If its not loaded. Try using GD which is more likely to be supported.
Yes, checkout PHPdesktop. It uses nosql for storage and has its own browser. They won't even know how it's built and it really doesn't matter. They will use it just like any other application on the machine. It's pretty easy and a slick setup. And from a logistical standpoint if, in the future, they need access on multiple computers you can always move the app online or to an in house server and set it up as an API. Wrap the JavaScript and you keep the "windows" look and feel. You could also go as far as using something like ionic for a mobile app. Seriously sounds like a fun challenge. As with any app backups are important, bugs do exist, and people are lazy. Have fun, good luck, and let me know if I can lend a hand. 
The first sentence says "on the remote server", I think that's the reason it mentions SSH but ... Let's assume your scripts runs as web-user or any other user. There might be the case you need to create a cron job that runs under another user on the same server. You could still use SSH to connect to localhost with that user and manage the cron jobs.
Does it make sense for it to offline? Yes there are security concerns with having an online system like that, it would probably contain peoples personal details. However would it not make more sense for it to be web based? That way the data can more easily be backed up. You avoid any issues with running php on windows and your friend can possibly use it on other devices in the future (i.e.: ipad, iphone, android ect ect ect) Really depends on if you need to do any physical hardware interaction too.
&gt; don't be a php only developer. Learn more than one language, for the same reasons as above. Make sure you learn at least one where you have to manage memory yourself. This is good advice but I think it's generally oversold. If you want to be really good focus on learning one thing. The point where you should be learning other programming languages is roughly when when you know the difference between when to use an interface and when to use an abstract class. Learning other languages is good but make sure you can use one language well before filling your head with other idioms. Too often do I see people who can use 2-3 languages but can't use any well.
First and foremost, grats on the job! PHP Development and Web Development in general is an exciting field to be in. The key to my own personal success has been to never stop learning. As cliche as it sounds, it's the truth. Force yourself to learn something new everyday from every aspect of the LAMP Stack and you will see how quickly you start applying your knowledge over and over again. From the PHP perspective, learn to see how OOP works. The design patterns book by Matt Zandstra that you mentioned is an amazing resource that I read time after time again. There is also this book called Rework (http://www.amazon.com/Rework-Jason-Fried/dp/0307463745/ref=sr_1_1?ie=UTF8&amp;qid=1442819706&amp;sr=8-1&amp;keywords=rework+book) that changed my thought process as well. It is a very easy read from the guys over at 37 Signals that is a 'take it or leave it' advice book about the software world. It completely changed my perspective on how I go about solving problems and addressing a project's priority. Just keep yourself actively engaged, don't be afraid to fail, and learn when you break things. You'll do just fine. :)
I suggest you ignore that one and find a different tutorial... That one seems to be about writing a PHP+SSH tool to script changing cron settings on a remote machine. (A rare problem, at best.) Cron really has nothing (directly) to do with PHP. It's simply a standard OS feature for running commands (programs, PHP scripts, python scripts, etc.) on a recurring basis. If you already have a PHP script and you just need to make it run regularly, try a guide [like this](https://help.ubuntu.com/community/CronHowto). 
Yes, just install XAMPP or similar. And run it via **http://localhost/hotelmanagement.php** or whatever
&gt; if all things happen in the same machine then why would we need a ssh2 lib? You are correct, you don't. The article you're looking at is discussing how to \*manage\* (i.e, change the settings of) a crontab \*by using only\* php, on a different machine. I'm betting that's not what you intend to do. You probably just want to schedule the execution of one or more scripts that are written in PHP. Correct?
I would still recommend hosting this application online, if he wants new features or you want to bug fix you can just fix it from your home. 
If you were to create, let's say ... a model for a comment script, how would you make it SOLID compliant? How would the classes be like. All I can think of is creating one `class{}` class that posts, edits the comment, which I could inject a pdo instance to the constructor. So, in other words it wouldn't be SRP.
It can be done, but "just because you could doesn't mean you should". I would consider other alternatives, PHP isn't really designed for offline applications.
That's not quite true. Those people are the same people who will do terrible things in other languages. Also those people are just poor developers who don't care. It's not learning other languages that makes you better, it's caring.
It's useful to know the principles described in phptherightway.com, but especially with a proprietary framework it may be more useful to pay attention to strategies used by successful higher-level engineers at your workplace to do things like refactors of heavily used objects. Knowing where to draw the line in a refactor and how to "shim" new code into old code is a valuable thing and it really differs by team and system. I work in a team of about 400 engineers, at least 100 of them exclusively PHP "back-end" programmers, and one of the most useful things I've learned is some of those strategies around how to get your changes out iteratively and safely (or at least relatively safely). If you have a unit test suite (hopefully you do), learn how to write good tests as well.
That's stupid. &gt; PHP is not JavaScript, we can already make arrays with `array()` no need for `[]` etc
Agree with most of this but at a basic level you don't need to use source control. Or at least, you don't need to push up to the server with it, using SFTP is perfectly fine even if you are using git locally.
Two pieces of advice from someone who entered the workforce circa 2001/02 as a wide-eyed Java developer: 1) always remember that someone else will eventually have to read and use your code 2) have patience. Becoming a good programmer takes years and years of persistence and practice. You'll get there eventually and even after years slinging code, you'll wake up and realize that there's still so much more to learn.
SQLite wouldn't be a bad choice in this situation. 
I would write it in JavaScript as this will make it more portable. Make the data storage use an interface class, so you can easily choose the best data storage option for each platform (iOS, Android, Desktop app etc). PHP is not best suited for local apps.
as long as I get a license to something after I stop paying ... 
I've been a developer for years, but 99% of the time a sole developer, and so have bred many bad habits. One of these is never doing unit tests. I don't know where to start; reading phpunit docs it seems it assumes a certain level of understanding of unit testing, which I don't have. Any links / dumbed-down tutorials on unit testing, and phpunit in particular, would be most appreciated. Or a nutshell explanation of it at least &gt;.&lt; Thanks!
How boring is your life, captain safety pants?
&gt;Fourthly, be prepared to make mistakes. I accidentally deleted every single row in a very mission critical table (think `users`) during my first week at my first major php job. By the time I quit I was a lead developer with a team of my own. Mistakes make the man.
&gt; don't focus on one framework. Another advantage of this is that you will get a better sense of where a framework typically ends and business code begins. As a noob coming into a huge code base this isn't always clear, but once you've got a few frameworks under your belt you start to have an intuitive sense of it.
Generally if you're using the assert() method in PHP you're doing something silly. The only example I can remember was something using it to find out if an edge case existed in a production class. Then he used ini settings to hide this from happening in production. This is bad because you should throw an exception if an edge case exists and assert for an exception being flung in your unit testing tool. 
I could imagine cases where you want to make strict test during development and be less restrictive in production.
I always import, mainly just because it looks slightly prettier to read IMO. I've never really given it any more thought than that. I cant think of any reason to care enough to ever raise it in a code review one way or the other
http://zaemis.blogspot.com/2012/10/php-assertions.html
Well, for one thing, you have absolutely no dependency inversion. Stuff like [this method](https://github.com/rmrhz/pugs/blob/266eb9226045be61e3ac10eb20d416e1529e3842/src/Pugs/Provider/Database.php#L33-L42) should only exist in container configuration and a fully instantiated `Capsule` should be injected in `Database`.
I really hope you are not a public facing website with consumer data.
For some reason, I still need to go further into Eloquent. As its inner workings is still magic in my view.
The thing that helped as a developer and one of the first things I teach my juniors is not learning how to write {insert language here}... But instead to learn the art and how to write code cleanly. I know that may not make much sense... Take a look at books like [Clean Code](http://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?ie=UTF8&amp;qid=1442842442&amp;sr=8-1&amp;keywords=clean+code) by Robert C. Martin. It will help improve your productivity and your understanding of what write code is about. Making code work is only half the battle; The other, and most important part IMO, is maintaining it. **tldr;** Learn the art of writing code, not a language.
Eloquent isn't any better than what you do. Many people here are very vocal about inversion, but then they propose something which has the same issues. All major frameworks screw up inversion as well, because they imitate each other. Symfony, Laravel. So I'm saying, you're in a good company there... so try to improve, but no rushing. ---- As for critiquing your architecture: it's a fundamentally flawed question to ask if architecture is good here, because we don't know your goals and needs, and architecture can *only* be judged based on how well it serves your goals and needs. Without this, expect people to skim through your code and tell you superficial things. Superficial things like: I find your code clean and readable, and that sets it apart from many other projects posted here, so good job (I mean it). :-)
[Yes, you can](http://www.brian-driscoll.com/2013/01/stop-asking-whether-you-can-build-it-in.html)
If I take a big children's book, and whack you over the head with it, it doesn't make *children's books violent*. In exactly the same way, assertions aren't bad because you saw someone using them badly. Put aside the fact that they are poorly implemented prior to PHP7, and pretend we are talking about PHP7 ... I've forgotten how PHP5 works already, so that's probably a good thing :) There is a distinct difference between error handling, and assertions. For programmers, there is no such thing as the unexpected: Code should be prepared to expect the unexpected, which might mean error out, take some other or even exceptional code path; The point is that code should be prepared to deal with whatever input it is given, whether "code" refers to a function, or a program, and "input" refers to variable, or stream of data. It should always hold true that you should deal with whatever you are given, if you cannot, because of the parameters of the program (the specification, if you like), then handle the error is what you must do. Assertions are not a form of error handling, they are distinct, in that they deal with errors in your *programming*, rather than in your *input*. To help to you apply this (new) knowledge, and be the hero in this story: private function mine(string $thing) { assert($string); /** use string **/ } If you understood what I just said, then you are screaming "that's wrong"; We know very well that a string might be null, but is still a valid string, our code should be dealing with that input. If you can see the value in testing, then you acknowledge that it is important, and valuable, to test the assumptions we make during design and implementation. Assertions should be used in the same kind of way, to test our assumptions to catch programmer errors, to verify before code ever gets to production that our programming is correct, and our assumptions hold true.
Was in the same boat as you :) . Recently I got around to watching http://code.tutsplus.com/courses/automated-testing-with-php, which finally made me compatible with unit testing... The above course ain't free though.
&gt; Well, for one thing, you have absolutely no dependency inversion. Stuff like this method should only exist in container configuration and a fully instantiated Capsule should be injected in Database. To play devil's advocate, what happens if I just go in my editor and: s/class Database/class ContainerDatabaseConfiguration/ 
I don't know what kind of access you have to the server and my answer might be a little 'off' . I would strongly suggest using command line tools to do the job : Something like scp / ssh ( in a cygwin with oh-my-zsh environment) not windows command line. Using version control (mercurial) would makes things simpler (if you can set it up, which would be hard I think at this stage) , But I think at this stage request -&gt; if you don't already have, request/setup ssh access -&gt; download file using ssh/scp , edit , upload using ssh/scp
Can I ask for a tip? One thing that bugs me about assert() is that sometimes I need to write a few statements of code *preparing* to make an assertion. You can stuff quite a lot in an expression, and you can abstract away checks as functions you call within assert(), but sometimes... you just need to write a few statements. We can disable assertions and now we can eliminate them from the opcodes. But what about the other statements? Right now, I do it the pragmatic, ugly way: define('ASSERT', false); if (ASSERT) { ... ... assert(...); } I wish PHP provided this constant for us, and could filter *the entire if block* if the only condition checked is this flag. In other words, I need: #ifdef ASSERT ... ... ... #endif
LOL...it happens sometimes when you write too much too fast. nice catch though
In PHP5, I dunno, some ugly string generation trick, yuk ... in PHP7 [this](https://3v4l.org/nioub): zend.assertions=-1 krakjoe@fiji:/usr/src/php-src$ phpdbg -rr -p* assert.php function name: (null) L1-5 {main}() /usr/src/php-src/assert.php - 0x7f528d275000 + 3 ops L2 #0 ASSIGN $things "thing" L3 #1 ASSIGN $here "here" L5 #2 RETURN 1 zend.assertions=1 krakjoe@fiji:/usr/src/php-src$ phpdbg -dzend.assertions=1 -rr -p* assert.php function name: (null) L1-8 {main}() /usr/src/php-src/assert.php - 0x7f74eb076000 + 14 ops L2 #0 ASSIGN $things "thing" L3 #1 ASSIGN $here "here" L5 #2 ASSERT_CHECK J13 L5 #3 INIT_FCALL 128 "assert" L5 #4 DECLARE_LAMBDA_FUNCTION " {closure}/usr/sr"+ ~2 L8 #5 INIT_DYNAMIC_CALL ~2 L8 #6 DO_FCALL @3 L8 #7 SEND_VAR @3 1 L8 #8 NEW "RuntimeException" @4 L8 #9 SEND_VAL_EX "nope!" 1 L8 #10 DO_FCALL L8 #11 SEND_VAR @4 2 L8 #12 DO_ICALL L8 #13 RETURN 1 function name: {closure} L5-8 {closure}() /usr/src/php-src/assert.php - 0x7f74eb065460 + 6 ops L5 #0 FETCH_R "things" @0 L5 #1 ASSIGN $things @0 L5 #2 FETCH_R "here" @2 L5 #3 ASSIGN $here @2 L7 #4 RETURN false L8 #5 RETURN null But remember, no side effects ;)
I'll just mention an alternative: do unit tests, but don't use a unit testing framework. Many testing frameworks tend to reinvent common PHP features through assert methods and annotations.
&gt; One thing that bugs me about assert() is that sometimes I need to write a few statements of code preparing to make an assertion. Can you provide a concrete example of this so we can provide more specific feedback?
I would choose the newest most stable framework out there, which at the moment is Symfony2 and Laravel. Of course all have their pro and con, but both (at least Symfony2 is) are fully compatible with PHP7. Its future proofed. CI 3.x was written to be compatible as far back as 5.2.x.
Laravel 5 requires PHP &gt;= 5.5.9 Symfony 2 requires PHP &gt;= PHP 5.3.9 That's exactly the point, we don't need nothing future proof, because we'll rewrite it again. What we need is a simple framework compatible with the legacy applications and their software requirements. Also, you didn't answer my questions, or you pick your development tools just for the sack of enjoyment and coolness?
I always import, the leading backslash is plainly ugly, and very error prone. I dont think I have seen any other programming languages doing the same thing with their namespace separator(Do you see .javax.swing, or .System.String? I dont). The fact that PHP forces you to use leading backslashes or import such classes in the very first place, means that its namespace feature is flawed. As you see, PHP's namespace resolution does not start at root level, which is the reason why you have to use \Datetime or to import it, as otherwise you end up with the class in your own namespace like YournameSpace\ YoursubNamespace\DateTime. It's a problem with PHP as a language, the very fact that it's namespace feature is poorly designed.
I always import. It's easy to forget to put the leading backslash so I just save myself the trouble by importing at the beginning. Plus it's a little prettier to read.
I'm guessing what you are looking for is [preg_replace_callback](http://php.net/manual/de/function.preg-replace-callback.php). For learning the ins and outs of regexes I recommend highly [the owl book](http://shop.oreilly.com/product/9780596528126.do) - it's the driest computer book I've ever read, but when you've slogged through it, you will sling regexes like a dark wizard. Till then I'd suggest using [the regex coach](http://www.weitz.de/regex-coach/). A free tool for testing regexes. Very helpful!
How is Symfony2 the cool factor? Symfony has been around for ages.
It seems like you have proper routing (at least from the description) but you feed it $_GET['url'] instead of $_SERVER['REQUEST_URI']. So it's a one-line fix. :-) And no, don't autoload everything, instead do one of these: - Give Slim little closures which instantiate (each) a given controller and run it. So one route, one closure instantiating one controller. - Directly pass a string with the class and method to call: '\Your\App\Controller:methodName' Check Slim docs for more. Oh also another option: - Don't use Slim just for the routing, use it if you need the rest as well. I have a feeling you don't, but can't decide.
All information stored in memcache is wiped on server restart. Memcache is a **cache** server, a key-value pair caching system, much like Redis, for caching information. It is not a persistent storage for information. It is absolutely **NOT** the purpose of memcache. Do **NOT** ever use memcache as a storage device.
Which part of the use case described isn't part of the general use of assertions? Only real change I can see if you can make it throw exceptions. So it's a nicer if statement, which you can toggle? I'll quote a document co-authored by yourself. &gt; Assertions are a debugging and development feature; the programmer should not take code to production with catch blocks to manage AssertionExceptions; the ability to manage the AssertionExceptions exists during development in order to aid the programmer in debugging the exception, the only place where it can be raised. This is slightly worrying, why? Because if bad things are happening in my code base in production, i.e. LogicalExceptions I should be capturing them and logging them and squashing those bugs like they've been calling me names. These LogicalExceptions can be used the exact same way assert is being prescribed. Except you can leave them in there because they have a purpose. I am not against assert, I am against having logical checks only in development when they should be in production so you can log and squash bugs in a clean manner. The fact you only care you code is broken in development seems completely nuts to me. Hell I only really care if my code is broken in production that's why I test it as much as possible during development.
&gt; imaginary qualifications for storage Well, I'm sorry. Didn't know actually storing the information in a persistent way was an imaginary qualification for storage. Go ahead. Use memcache as if it were a database.
Absolutely unrelated to PHP. Another spam post by /u/ben0078. 
I can't. Why would I care more about my development env than my production env? Can you give an example of such a case?
Oh, I feel silly now.
Thanks. btw, this is, no joke, by far the most useful interaction I have had on Reddit. 
DUDE, MEMCACHE **DELETES ALL DATA** UPON SERVER RESTART. IT IS A **TEMPORARY** STORAGE FOR **TEMPORARY** (CACHED) DATA. DO NOT BUILD A SYSTEM ON IT. IT'S RIGHT THERE, IN THE NAME: MEM**CACHE**. I never even mentioned SQL. Memcache does not **store** information. It **temporarily holds some information on memory** until the information is manually released or until the server is shutdown. You cannot build a hotel system using PHP + memcache, unless you want to lose all customer/booking information when there is a power outage, when the server freezes or something like that. You suggestion was just plain stupid, and you can't even see what's wrong with it.
¯\_(ツ)_/¯
Well. It was a very easy answer to give. No ifs and howevers. :-)
Great point at the end. You *can* do it in PHP; but you can also do it *better* in other language. For the time/effort in building the CSS styles, HTML implementation and stuff, you can just learn C# or something alike and build a great full native-integrated app.
I always import even though I wish I didn't have to. I get fucked by it either way. My first instinct is to just use `new DateTime` without the leading slash, which means I've either forgotten the leading slash, or forgotten to import the class. Either way, it's impossible to use DateTime without potentially forgetting to make it usable in the class in some way, which I hate. That said, as annoying as it is is, I'd rather PHP's system of "everything in the standard lib is global" than have shit like `import foo from bar` at the top of my file, and have to remember that foo lives in bar in the standard library.
 assert((function(){ // php7 is beautiful // php7 is beautiful // php7 is beautiful return $result; })()); 
Why I do $_GET['url'] is because I redirect everything to index.php and the rest is treated as a GET request and then torn apart as an array to call the controller/method/params. What I want though, is be able to use routing properly instead of calling my controllers by what I want the url to look like. So if I was doing a reddit ripoff and I wanted subreddits to be under rabbit.com/r/subreddit1, I don't want to call a controller "r". I guess what I could do is simply add my own router class that tries to match the $_GET['url'] value to a route and if it match.
Yea, "offline" or "localhost" may be the same, depending on how you see it. In my response it was not. My interpretation of "offline" was just to dubbel click on the index.php in the file manager, and that does not work. Since you want an application using HTML, CSS, JavaScript and PHP you also need a webbserver. XAMPP is one choice, or you can use the [builtin web server provided by PHP](http://php.net/manual/en/features.commandline.webserver.php). Your computer does not need to be connected to Internet or an external server, you just run it on your own machine, localhost. You can not make it work without a web server (since you want it browser-based). But just put any web server on your local machine and your ready to go. The phpdesktop-solution as you see suggestions on above, has an embedded webbserver. 
&gt; Can you provide a concrete example of this so we can provide more specific feedback? The inline function call others gave an example for is very handy and solving lots of the use cases. Although I'm still struggling to convert this one: if (ASSERT) { $val = new Validator(); $val-&gt;require('foo')-&gt;isInt()-&gt;isMin(0)-&gt;isMax(31); $val-&gt;require('bar')-&gt;isString()-&gt;isRegexMatch('@^\w+$')-&gt;isLengthMin(1)-&gt;isLengthMax(8); $val-&gt;require('baz')-&gt;isObject()-&gt;isInstanceOfAll(Foo::class, Bar::class); assert($val-&gt;validate(func_get_args(), __METHOD__)); } This is a bit of a contrived example, but it's representative of the kind of problems I have. I have various assertion builders which take a few lines to, well, build. 1. I build a complex set of rules of the function arguments (which can't be expressed through typehints alone). This requires multiple statements. 2. I call the validator in assert(), but I need to pass data which I can't directly pass from a parent scope. How would you refactor this?
`new ¯_(ツ)_/¯DateTime();` `use Symfony¯_(ツ)_/¯Component¯_(ツ)_/¯HttpFoundation¯_(ツ)_/¯Request;` I like it. Someone make an RFC.
This is a pre-condition, for testing what your caller does while using *you*. It's by definition not the job of a unit test, to test the behavior of some *other* unit from your unit.
Quite. I was getting rather ahead of myself! Using something like TypeScript will help here.
The word "manufacturing" makes me think of a factory. As far as I'm aware, the elePHPants are hand-made.
I changed the password of root in my first week and locked everyone out of the server until we could get our Server Administrator in to look at the problem, whom was on vacation. Now I am the Server Administrator...
That function worked great. Thank you so much. Now I have to figure out why my [ and ] characters aren't reading from the database. Edit: Fixed it! Previous preg_replace in the class to slim down injection attempts wasn't allowing [ or ]!
&gt; It's big, legacy project, where relations are sometimes made with a lot of data duplication, and objects are linked in crazy way. https://en.wikipedia.org/wiki/Disjoint-set_data_structure
Actually it is for the reason that HTML and CSS is eathan traditional OS GUI that projects like nw.js exist so that you can develop GUI applications in HTML, CSS and JavaScript instead
I don't want to write an additional line to save a character thank you
I haven't so far seen a composer.json file that was so large that it needed to be split up into multiple files.
It's a Hotel Management app... I'm fairly certain that *actually* persisting the data is a requirement. Using memcache, a simple power cut would cause you to lose all past, present, and future data. I think you either realised you were wrong a while ago, or you're trolling. 
+1 from me for plugins &amp; modules. I instantly saw the use case when you mentioned "plugins". I hope the feature passes. 
Misinformed about what? Posting in /r/lolphp is not a feat.
&gt; I'm fairly certain that actually persisting the data is a requirement. Persisting data for how long? If you want to persist over a restart, you can persist to file or _another data storage_. Your comment is about a topic that isn't relevant to the discussion about the question of memcache as a database for storing information. It is. The people arguing senselessly here is part of what makes PHP look like it's used by idiots and amateurs.
Well, you're certainly unemployable. If you're not trolling, you should find another profession before you do real damage to a business' bottom line.
Well, you seem like a smart and helpful individual. About this exposing the app to the world by binding on a public IP --&gt; whathca talking about? Are you telling me that I can run XAMPP on my computer, and have people connect to the sites I create? I mean clearly I wouldn't want it in production like that, but can I access my desktop sites? 
Isn't this basically what `require` and `require-dev` do?
&gt; Are you telling me that I can run XAMPP on my computer, and have people connect to the sites I create? Yes. You may need to forward port 80 on your router though.
I'm not arguing against what memcache is. It IS data storage. I'm arguing that it's simply the incorrect technology for this particular use case. 
&gt; I'm not arguing against what memcache is. It IS data storage. For some reason, naroga can't help but make assertions to the contrary, while pursuing his derail. 
Thank you for sharing your work with us, but I'll just be direct and tell you: you won't get much positive feedback, and the problem is your marketing, not your libraries. I realize this is your personal FOSS repo, but the rules are the same as for any other product. Unfortunately a good product can't be recognized based only on its intrinsic qualities. It's a process of educating the public and getting them interested in your wares. In other words, it takes work to get people to recognize your work. The way you presented your list of projects (the sheer number of which is impressive), feels like a burden to review by the people who'll see it. They'll probably skim through a few of the repos, and post some superficial remark about your API design, code formatting, or whatever they can figure in order to critique. To get people interested, take one of those libraries. Just one. Then make a nice page for it with a neat hello world sample, explain in simple language what problem you think people have and how the library solves it, and then you'll get someone interested. Rinse and repeat. :-)
This is quite a bit of a project but you can focus on something that bundles the webserver/app/and storage so you will still need something online. Not a small task but it is possible for it to host everything in a WAMP server install and just render the page in http://localhost
&gt; manage the cronTab with PHP This tutorial isn't about setting up the cron deamon to have something happen regularly in PHP, it's the opposite: it's about setting up PHP that can change your cron deamon.
I think there's a lot of fatigue with MVC frameworks lately, so probably not many people would look for this reason alone. This doesn't mean it's a bad idea to write one and learn. But if you want feedback I think you need to ask pointed questions, like "look at class X; the way I designed Y is it suitable for Z" and so on. Nobody can provide feedback on everything, without knowing what you're trying to achieve, in terms of specific goals for distinct features of the framework. Oh and also... you forgot to post a link. 
&gt; The people arguing senselessly here is part of what makes PHP look like it's used by idiots and amateurs. I just choked to death on my popcorn and died.
I usually import core classes so I can look at a classes' use block and quickly see what classes it uses outside its namespace. 
Honestly, of the three possible options, I think that's the worst one. `\DateTime` isn't perfect since, as others have pointed out, already, it's easy to forget the `\`. And `DateTime`isn't perfect, either, since it's not immediately obvious that you're using the `DateTime` object in the default namespace, among other things. But for all the problems they have I think aliased namespaces present even more problems. IMHO.
If you think Zend makes their money selling software, you don't know much about Zend.
That would a lot more useful than including local paths for repositories. You could include a subproject within your project but not necessarily a composer project, similar to gradle.
Man some of you can't even eat properly. I thought he was kidding.
At that point, most people would have admitted that they are wrong or at least seriously reconsider their point. Your post history suggests that you are neither entirely stupid or a troll, so please, for the love of all that is holy, reconsider your post. It wouldn't be cross-posted and laughed at in another subreddit if it made the slightest bit of sense.
untapped market.
gotta love anonymous functions // start assertion assert((function($args, $method){ $val = new Validator(); $val-&gt;require('foo')-&gt;isInt()-&gt;isMin(0)-&gt;isMax(31); $val-&gt;require('bar')-&gt;isString()-&gt;isRegexMatch('@^\w+$')-&gt;isLengthMin(1)-&gt;isLengthMax(8); $val-&gt;require('baz')-&gt;isObject()-&gt;isInstanceOfAll(Foo::class, Bar::class); return $val-&gt;validate($args, $method); })(func_get_args(), __METHOD__)); // end assertion
Stripe/Braintree will easily handle all these credit card transactions for you. No need to be PCI compliant anymore.
Sorry if this is off topic, but a catpcha just to VIEW your site? Sorry, but ain't nobody got time for that. Tab closed :(
Um.... and you'd like to ask for help with one of the least detailed statements available for use.
"You can think of it as a short-term memory for your applications." From http://www.memcached.org/about second sentence If you use Memcache for "persistent" storage you are an idiot and deserve to lose all of your data
Having been instrumental in my company spending hundreds of thousands for zend server, and thousands for training, I find this hard to believe. Also, screw the elephpants. I ironically want the double claw hammer!
I just use `\DateTime`, but I'm weird.
I agree with Hlogen. Something like [https://gist.github.com/matthew-james/892c93e7f14c7141ab93](this) will work. Look into the [jQuery .post](http://api.jquery.com/jquery.post/) function. It will allow you to call your upload script using javascript, passing parameters. You specify a 'callback', which is basically a block of code that will run when it gets the response back from the server. 
&gt; while offering no real benefit to the PHP project. To be fair, what I assume to be [the official site](http://www.elephpant.com/), says they give 10% to open source communities. Admittedly that statement sounds kind of vague.
I agree, though I've grown accustomed to Laravel. I also have knowledge in other frameworks. The only thing that's boggling me is the feel of being productive when inclining to one. In the end, the argument falls for personal preference. It's like that in my country. Though I would really want to try out getting to understand how the low level works.
Even if they wanted to print forms, they shouldn't store the data in memcache, as it could simply be discarded without notice.
I had a pagination class that I held on to for a few years, but the idea of keeping a collection of "snippets" seems out dated these days. Packagist potentially has [hundreds of such classes](https://packagist.org/search/?q=pagination). It has hundreds of [contact form systems as well](https://packagist.org/search/?q=contact%20form). There's no real need to hold onto code when I can get the functionality I need by adding a single line to my composer.json file.
[React PHP](https://github.com/reactphp/react) gives you non blocking IO in PHP. If you have something that is currently blocking (i.e. a query) it will not allow you to execute that code in a non blocking fashion. For that I would look into using a job server like beanstalk.
That's not the Original Poster. That's someone else making assumptions about requirements. The pattern of "I know how to do this" has muddied the discussion.
If I store it for 5 seconds, it was persistent. If you lose all the data on restart, that might be acceptable. Nobody knows if you don't know what you're building.
I didn't suggest that. Memcache might be useful, MySQL might be useful, maybe... oh I don't know, he doesn't need a DB? How did everyone lose their minds over what they imagine the OP wants?
i kind of see what you are trying to say but the definition of [persistence](https://en.wikipedia.org/wiki/Persistence_%28computer_science%29) is "the characteristic of state that outlives the process that created it".
Since we're discussing a php system (ostensibly), the php interpreter is the process that inserts the data into memcache. I think that counts. That being said, I understand it when someone make outrageous statements because they don't understand the concept or forgot or don't care or they don't know the difference between persistence and [durability](https://en.wikipedia.org/wiki/Durability_(database_systems\)). Pushing the agenda that you need reboot-survivable "persistence" (if that makes anyone feel better to misuse) is possibly a need for an imagined scenario. You can't use memcache for that.
He should use a database. Memcache is not used for persistance; it's used for frequently used data on top of a persistance layer. That persistance layer could be flat text, binary or a more sophisticated datastorage system, but it cannot be memcache. Memcache and similar systems often has a retention policy. It can be hours, it can be memory pressure or it can simply be until the system is stopped. It is however not considered persistent data. For that you need something else. OP cannot use memcache for this. He doesn't have to use a full fledged database either, but he cannot use memcache.
Second sentence of the wiki article: "Without this capability, state would only exist in RAM, and would be lost when this RAM loses power, such as a computer shutdown." Do you have a source that uses the word persistence to mean what you are describing?
&gt; I simply use the . Alright I'm confused
I understand what you are trying to say but I don't think that anyone makes this distinction. Whatever, this discussion isn't really going anywhere.
"The position of this RFC is that the ==&gt; symbol is too similar to the =&gt; (double arrow) sign, and would cause confusion." &lt;-- Its weird that he doesn't assume ~&gt; symbol is too similar to the -&gt; sign,
Meh... I can see why some people might like it, less lines of code, but I think it comes at the cost of readability. Other languages have it and it's popular, so I guess it's nice to have as an option.
Trying to turn PHP into a functional language?
Totally. Well, PHP is already providing ways to write functional code. It's about supporting every paradigm. Each paradigm has its uses and should be equally supported. We're not forcing a specific paradigm on the language (unlike Java for example)...
I really hope for your sake that you're trolling right now, because if you're not you are dumb as shit.
I did that for a couple years. I'm over it ;)
That's nice.
I like the PHP syntax for its verbosity. The short closure syntax feels too much like Perl or Coffeescript. I think this code is a nightmare for readability: usort($array, ($a, $b) ~&gt; $a-&gt;val &lt;=&gt; $b-&gt;val); I personally prefer the longer syntax: usort($array, function($a, $b) { return $a-&gt;val &lt;=&gt; $b-&gt;val; }); But I guess this is all subjective. I can understand why some developers may prefer a more terse syntax. I just don't like giving a lot of significance to 1-2 character tokens.
This is very late 90's and Early 00's thinking. Today you really need to learn a framework, or two. 
Not only exots like coffeescript or Perl. Even mainstream languages like C# (https://msdn.microsoft.com/en-us/library/bb311046.aspx) or Javascript (ES6) (https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Arrow_functions) all support that syntax. But ultimately, yes. It's all subjective. I just can promise you that avoiding the function and return keyword weren't the only reasons for the short Closures. It's a nice side effect. It's shorter, it's not needing `use` (in case of longer functions I absolutely am in favor of being explicit, but for real small Closures, it's just redundant)… But actually, the main reason why that RFC was drafted at all is the functional use case (Closure chaining), where it drastically helps improving readability actually.
Are these somehow not solved with `require-dev` and version constraints? The latter is certainly made easier provided developers of the dependencies strictly adhere to SemVer, but I've personally never had this come up as an issue. I have no use-case for this feature, but don't care if it's added either.
&gt; It's shorter, it's not needing use Unless you need to modify the variable.
I've been using them extensively with ES6 of late, and for my taste they have vastly improved readability when used for one line closures because you can scan what's going on faster.. customers.filter(function (customer) { return customer.active; }); vs customers.filter(customer =&gt; customer.active); Bringing this to PHP might not be as much of a win due to comparably less use of callback functions, but I don't think that it really costs readability if used sensibly. And if you feel it does then don't use the things :) 
I suppose it's something I can get accustomed to using. I'll have to play around with the white space a bit. This feels more readable to me: usort($array, ($a, $b)~&gt;{ $a-&gt;val &lt;=&gt; $b-&gt;val }); Maybe my real hang up is with the optional curly braces. *shrugs* &gt; it's not needing use Oh, god, yes.
That top line is so Perl it hurts
PHP is an imperative language so when you add features to it, it's a good idea to design it so it fits *PHP* &amp; not Haskell. Do you enjoy the fact you can't autoload user functions in PHP? Well... - If you're writing code like in Java then you don't use functions... - If you're writing code calling user functions, then there's always "require". I hope you see my point now.
&gt; User-provided data has an unhealthy way of making its way to unexpected places, and even stupid configuration changes can cause a lot of havoc. The "unhealthy way" may be not checking your input strictly at the boundary where it's still clear it's user input. :-) I know what you mean, but you can't check literally everything at runtime. It's not practical. Yes, it's PHP so we shouldn't care about performance and so on, but I still care *a little bit*. Say, when C++ code is compiled, it literally has no types at all at runtime, yet, no one is raising that as a problem, and the stripping of types is not the cause of most C++ code security issues. Some invariants can be ensured when code is being developed through assertions. One simply needs to debug their app with assertions on (I also enable it when running the test suite). In my case I tend to add assertions for things I'd *never check at all* if assertions didn't exist. So it makes my code better, not worse, for having them.
Lets say I'm developing app in any new, clean and MVCed framewor like Symfony or Laravel. I'm wondering how you guys handle very easy problem which probably occurs everywhere. Problem: I've got 'Link' Model. I want to store information like 'Category' and 'Quality'. 'Category' can be one of the 6 like ('Sports', 'News', 'Policits', etc.). 'Quality' can be 'low', 'medium', 'high'. My solution: I store private properties in the model ( see: http://wklej.org/id/1801526/ ) and store integers inside the DB. In views I present selects, with values being integers and Model's string being the visible text. Wondering, how can I improve that solution to make my code better? Do you have any ideas? I'm about to refactor big portion of app, I've always used that kind of logic.
It COULD persist. That doesn't mean it WILL persist. A write you make could evict some key that you wanted, which is why it's a *cache* server. If you want to use memcache as a database, try redis.
&gt; The "unhealthy way" may be not checking your input strictly at the boundary where it's still clear it's user input. :-) Agreed, but that's also the basis of my comment about not knowing how a library will be used. It also tends to become more of a problem as a development team grows; way less of an issue on smaller teams and projects. &gt; In my case I tend to add assertions for things I'd never check at all if assertions didn't exist. So it makes my code better, not worse, for having them. Shoulda started with this one ;) And as I said - there's *nothing* wrong with assertions, they just tend to not be that helpful for what I personally work on (which *is* a lot of handling user data). The C++ argument doesn't particularly make sense - if you had (passing) type checking at compilation time, and you validate data when creating objects of that type, those problems really just go away. The types aren't so much removed as proven to be accurate before you've even hit runtime. There are entire programming languages, fields of research, and branches of math dedicated to this kind of stuff. Obviously if you do stupid type-casting, or just use scalars everywhere, all bets are off.
Thanks for that answer I'm gonna look into that link when I got home. Again thanks !
&gt; The C++ argument doesn't particularly make sense - if you had (passing) type checking at compilation time, and you validate data when creating objects of that type, those problems really just go away. The types aren't so much removed as proven to be accurate before you've even hit runtime. Assertions are intended for invariants which can be proven accurate, before code hits production. I agree it's not *exactly* the same, because an assertion isn't static (it'd be neat if they could be...), but its role is to fill in for static checks the language and IDE don't provide when using an API.
The concept is fine, it's the syntax being lifted from functional languages that's going to be a problem. `~&gt;` doesn't exactly scream "oh yeah, those variables you just read to my left are actually *function arguments*, oh and here's a one-statement function that just imported the local scope" to *normal* PHP developers. Someone on internals suggested the alternate syntax `lambda(args, body)`, which would have fit in with the rest of the language without too much trouble. It makes me sad that instead of adding this as a readable alternative, the authors have decided to go down the functional language route and severely hamper readability *by mortals*. If this RFC fails, it will be because of the foreign syntax, not the actual functionality of the feature.
Going back to what has been said earlier, it all depends on what your potential client's needs are. If it something where you just need a couple of landing pages that sells the user a product, then perhaps going with a framework may not be the best idea. However, if you're going with a client that needs a website that requires a user signup/login process, managing db records, grabbing data from APIs, etc., then you're better off going with an MVC Framework such as Laravel or Zend Framework. As long as the framework has a standard license (most of them do), you shouldn't run into any licensing issues.
I disagree. Plenty of imperative languages have leveraged some functional syntax to great benefit. Sure there's new syntax to come to terms with but the same is true of any addition to the language. &gt; It makes me sad that instead of adding this as a readable alternative The assumption here is that somehow ~&gt; is unreadable, which is pure opinion. And since we're talking about pure opinion, it is my opinion that lambda(args, body) would hurt readability.. it is nowhere near as clean a solution as the proposed lambda expression syntax. I'd have personally preferred fat arrow be used because I disagree with the notion that it would confuse people with regards to arrays etc.. the context is incredibly clear in my book, but you can't win 'em all. 
Okeej, I will give one a try ? And the standard license is ? MIT ?
Not sure what you are sayin... Also why the down vote, it was a question.
Yup. Laravel has MIT, Zend Framework has BSD.
&gt; memcache is perfectly fine as data storage Saying this is like saying that the people who lived millions of years ago should've used a block of ice to carve their drawings rather than the wall of a cave. You might see it right after you make it *but it will be gone eventually, and you have no control of when!*. Hence making a hotel-booking system that needs to keep *persistent* vacancies in anything that isn't a permanent storage (saying "database" or "storage" here does not matter - what matters is whether it's "persistent" or "temporary"). `memcache` is named so, because it will save (`cache`) data in `memory` (which, if you know anything about hardware, will lose *all* of it's data when it runs out of power). Stuff like the frontpage of reddit for a single user (that won't change until a few minutes have gone by) or info about your user (no reason to keep querying your database if memcache has the contents - memory is *always* faster than your disk).
They're primarily a services and consultancy business. Obviously I don't have their financials, but I'd wager that most of their income is from selling services such as training, testing and support, as well as software consultation. They probably make a good amount of money on their software, but IMO it's more of a means to the end that is selling support and being "the PHP company".
&gt; hotel management app Let me get this straight, what would you think would be the requirements of a *management* app? To keep temporary data?
I don't think it's anything other than a webpage. That's all that he described.
And both of them i can use for business purposes without any trouble ?? Need I to reference them ?? 
Or use [/u/ircmaxell's](https://www.reddit.com/user/ircmaxell) [password_compat](https://github.com/ircmaxell/password_compat) lib for PHP &gt;= 5.3.7 if &lt; 5.5.0.
Yeah, you could, but why wouldn't someone just upgrade to a higher PHP version?
For better or worse, people are going to try using elements of FP in PHP because they picked it up working with something else and found it useful - and it is. Would I write a full FP program in PHP? Certainly not. But when you realize that immutable data prevents a lot of stupid problems, elements of it are incredibly useful. Bearing that in mind, making it less awkward isn't a bad thing. If you don't want it in your software, don't use it - there's a huge amount of stuff in the language that most of us ignore. I'm not saying this is the right way to solve the problem, and I'd say that until the core array functions are less grotesque it's probably a largely wasted effort. But let's not pretend that *supporting* a style of programming is going to force everyone to use it. Remember, spaghetti code littered with globals is supported too, but that doesn't stop competent developers from wiring good code. 
I agree, this should be the default (and vice-versa). It just reduces cognitive load on developers, and makes it that much easier to learn either language. If there's a very good reason, sure - but FB is very thoughtful and pragmatic about this stuff from what I've seen. When it comes to software, they usually make good calls. 
http://www.serverphorums.com/read.php?7,1300671,1300810#msg-1300810 ****as I noticed many people expected typehints to work (they don't due to parser limitations)**** ------------------------------------------------------------------------------------------------------------------------------- &lt;-- Did he really mean that we cant use type hints there... da fuk!!!
I think the point he's making is that it's hardly ever written as $x -&gt; $y; It would most likely be one of these: $x-&gt;$y; $x-&gt;{$y}; And even that is uncommon. But that said, what is to stop people from doing this (assuming it's valid syntactically)? $x~&gt;$y; In the end though, I think if Hack has already settled on ==&gt; I see no reason for PHP not to do the same. EDIT: it seems the Hack devs asked that PHP not use the ==&gt; syntax...
Did it ever go to a vote? Seems like if this was brought up again now it might get more support.
Awesome! Even if you're not an expert, I'm sure you'll be able to teach me something and it's always nice to meet new people! Will PM me you soon!
Having recently been through this myself, I can tell that we were looking for three key things: 1. A level of engagement 2. Familiarity with the tools we were using 3. Communication skills **A level of engagement:** We are looking for someone who is more than a 9-5er. Not that we want them to work more than 9-5, but we want someone who is engaged in their craft. Not someone who has simply completed the necessary college courses and is now looking for a job. We based this on a whole bunch of things, such as: - Twitter activity - GitHub activity (are they engaged in open source) - Stackoverflow activity - Familiarity with the PHP-FIG standards - Whether they've been to a local user group or tech conference - Do they have any projects/products that they've created - Have they written any blog posts or guest articles? - General awareness of design patterns, testing, and other modern-day programming techniques **Familiarity with the tools we were using:** In theory, any decent developer SHOULD be able to jump into a project and be productive despite the framework and tools be used. However, when we hired we didn't want to take that risk. We really wanted a developer who was familiar with the tooling we used, evening at a basic level. Here are some things we look at: - Git - PHP framework - Composer - PHPUnit - Database (ie. MySQL vs PostgreSQL) - Amazon - Heroku - JavaScript framework - CSS framework/processor **Communication skills:** This one is real simple, but maybe the most difficult to change if you don't have it. Can you communicate in an effective way? If we're going to be chatting every day, I don't want to have to fight for responses or input. Are you friendly? Can I see myself enjoying our time together?
Have you got something in particular you want looking at?
No custom salt set in the application? For shame.
Quite the opposite. PHP automatically creates cryptographically secure salts for you, as part of the hashing process, and the option to set a custom salt has been removed in PHP7. http://php.net/manual/en/function.password-hash.php
/u/reinink is spot on, though perhaps leaning a bit too much on the intermediate+ side. I look for the following: - open source code I can inspect. The code should be well written, clean and well documented, and should solve a specific problem. Yet another fibonacci generator wrapped in a class or something similarly pointless isn't something that could impress me. - familiarity with PSR-3 and PSR-4 at the very least. - familiarity with Git, Composer, PHPUnit. These seem like humble requirements, but I think they're realistic for a mid-level dev. Anything beyond is already touching on senior waters, and anything below is junior level imo. Besides, anyone who was able to learn all of the above usually implicitly has enough mental capacity to learn any other tool I might throw at them as well. One other thing that's absolutely crucial when I look for people: - ability to write properly. Not grammar and phrasing (not everyone is a native English speaker, and that's fine) - though welcome - but properly punctuated and capitalized sentences, and no abbreviations like "u", "r" and so on. If you can't be bothered to properly write out a sentence, I can't trust you to produce a proper line of code.
The salt is embedded in the hash.
I asked this same question a while back. It makes no sense to me that `use Namespace` is relative to the root while usage within the code (e.g. `new Namespace\Class`) is not.
But the former is much more distinct while the latter is easily confused.
We don't have to have this unfamiliar syntax to eliminate "use". I'd much rather just have an automatic "use" (maybe the lambda suggestion above).
What exactly are you looking at when you look at someone's Twitter feed? I'm not looking for work but on Twitter I don't tend to talk about development that much in comparison to other things like music, politics, videogames, and dumb comments
One doesn't, unless one is also an expert hacker who can crack the MD5 algorithm ;) I assume you have a full table of users who use your application. You should create a column "password_new" and let your users change their password -&gt; save to password_new after you have hashed it using password_hash(). Meanwhile, accept logins using both "password_old" and "password_new" values for each user. See [this](http://stackoverflow.com/questions/18906660/converting-md5-password-hashes-to-php-5-5-password-hash) question as well.
Even better, everytime you hash a password, a different salt is used!
I would do similar to /u/blurrywindows but make it a little bit easier on the database in exchange for creating potential legacy issues. Create a function to identify if a password hash is MD5 (32 characters). Modify the database table to accept the new max length so the same "password" column can store more than 1 type of hash. If it validates as MD5, you recreate it using password_hash since you should still be in control of the plain text password at that point.
Fair enough, but I'm trying to answer the original question as honestly as possible. This is how we did it. Hiring is HARD. You look at whatever you can. Clearly we would be willing to hire someone who has no Twitter account and no GitHub account/activity, if other metrics checked out.
Reading the internal mails there's a suggestion it's not *quite* the same as the hack approach because of a lack of support for typehints in the PHP implementation, so an argument can be made that simply copying the hack syntax would add confusion because of an expectation that the code would always be completely portable. I might be totally wrong on this point, but I think I heard someone once say that Hack/HHVM has some pretty nifty code rewriting tools which allow them to change the syntax of the language and have their code safely rewritten to reflect that change - if that's the case it might be a case of agreeing in the spec on what lambda expressions look like and then changing their side to handle it.
if you go back to the discussion thread, /u/ircmaxell points out the following: &gt;Typing on closures is outside the scope of this RFC. &gt;With that said, I'd love to hear and see examples of this. It's something I definitely want to do, just haven't come up with a good enough way to do it... Fairly pragmatic approach - rather than holding up a vote on a broadly useful feature because they are unable to find an elegant solution for an optional typehint, they'll come back and address it later when a decent solution presents itself. In the meantime we can busy ourselves with collapsing horrible array manipulation callbacks into single line lambda expressions (which is where this feature will get the most use I imagine).. which is a good thing. 
Is it unfamiliar because of the `~&gt;` choice, or because lambda expressions themselves are unfamiliar?
10% is bugger all. He's profiting off an opensource projects mascot. I'd have (only a little) more respect for the guy if he gave at least 50% back.
The salt is just certain length of random bytes (encoded a certain way) and that's it. I'd be surprised if bcrypt (or password_hash with automatic salt generation) broke due to the usage of salt. About MD5, it is frankly still "secure" if used for password hashing properly (what comes to the broken collision resistance of it, it doesn't apply for the usage with password hashing). (NOTE I'm not suggesting to base your password hashing scheme on MD5 or any other home made construction).
If you have a project that can be opensourced, upload it to github! Then ask friends (and us) to check it out.
&gt; Twitter activity &gt; &gt; GitHub activity (are they engaged in open source) &gt; &gt;Stackoverflow activity When I see this in a job proposal, I decline it. Because it's suspicious.
Also don't forget to do `password_needs_rehash()` check *after* verifying the password. What this does is it allows you to implement stronger hashing algorithms over time (e.g. whatever `PASSWORD_DEFAULT` points to) and stronger work factors as hardware gets more powerful. Then when users sign in and are authenticated, their passwords are automatically re-hashed to be stronger. The full logic would look something like this: if (!password_verify($password, $existingHash) { // return not authorized } if (password_needs_rehash($existingHash, PASSWORD_DEFAULT, $configuredHashingOptions) { $newHash = password_hash($password, PASSWORD_DEFAULT, $configuredHashingOptions); // update user account with $newHash } // return authorized
You're awesome!
Actually, I agreed with you by the time I drafted the RFC. But actually, as we are technically unable (well, without a major Engine rewrite on multiple levels) to use actual closing over behavior (`$a = 1; $b = 2; (() ~&gt; { $a = &amp;$b; })();` would have no effect when we take arguments by-ref). So, to avoid inconsistencies, by-value. Also, if you really want that (you most often don't), there's always long-form syntax.
Who are some good people to follow?
I'm sorry, but what you said is kind of a nonsense. I mean people have a fatigue with it, because it's full of MVC frameworks and it's a well studied problem. MVC is an implementation detail and REST API is an API. They're not mutually exclusive. You can take an MVC framework and make a REST API with it. Microframeworks implement the same exact architecture as the bigger ones, BTW. 
I can't believe I'm doing this, but see http://followphpdevs.com. Also, be sure to read through the comments, lots of other good recommendations there.
&gt; EDIT: it seems the Hack devs asked that PHP not use the ==&gt; syntax Source? This doesn't make sense to me.
Both the aforementioned options are insecure, as they leave MD5 hashes in your database. Thus if your DB gets compromised, you're still storing md5 passwords. Simply put: hash the existing md5 in password_hash. Flag these passwords as legacy. If you're about to verify a legacy password, md5 it first before passing into password_verifiy(). Once they log in with a legacy password, *then* hash the plain text password (before you md5'ed it) with password_hash(). Store this new hash back into the table and unset the legacy flag. Don't forget to use password_needs_rehash() when a non-legacy login happens to make sure you're using the new options you've set. The above will mean that the moment you move over to using password_hash(), you're no longer storing md5 passwords in your database. To give an example, let's say you have the following users table: id|username|password| :--|:--|:--| 1|admin|21232f297a57a5a743894a0e4a801fc3| 2|user1|5f4dcc3b5aa765d61d8327deb882cf99| 3|user2|5d41402abc4b2a76b9719d911017c592| Step 1: flag them all as legacy: id|username|password|legacy| :--|:--|:--|:--| 1|admin|21232f297a57a5a743894a0e4a801fc3|1| 2|user1|5f4dcc3b5aa765d61d8327deb882cf99|1| 3|user2|5d41402abc4b2a76b9719d911017c592|1| Step 2: password_hash them and store them back into the database: id|username|password|legacy| :--|:--|:--|:--| 1|admin|$2y$10$AYgl2jqkdjsI4qLjKIRuy.LuW5xuAlpC12nMUGPsWUApl1cv42XZi|1| 2|user1|$2y$10$3NpwiQeUMWZgerwkpiutROjsq9sCsZiPZdm0I.6Exy4t06AxgYNbS|1| 3|user2|$2y$10$nrBLkBONdb4DjuJuIenZOeSYUryQtRrNOKYCnxXErFqi9yk8NP59q|1| Now, lets say admin logs in, so your code now does something like this (note this is a quick example code!): function login($username, $password) { $options = array( 'cost' =&gt; 10 ); $userdata = 'query to find the user in your framework/PDO prepared query'; $plainText = $password; if ($userdata['legacy']) { $password = md5($password); } if (!password_verify($password, $userdata['password'])) { return false; //or a not-authorised error or whatever. } if ($user['legacy'] || password_needs_rehash($userdata['password'], PASSWORD_DEFAULT, $options)) { $hash = password_hash($plainText, PASSWORD_DEFAULT, $options); //store $hash in the password field // set the legacy value to 0 } return true; //or an authorised flag, etc } Your table might now look a bit like: id|username|password|legacy| :--|:--|:--|:--| 1|admin|$2y$10$UfizxZ65X9g2lQ34./xbi.iNALbwzDAT5UqmAgDWBQBh91a/cdcNi|0| 2|user1|$2y$10$3NpwiQeUMWZgerwkpiutROjsq9sCsZiPZdm0I.6Exy4t06AxgYNbS|1| 3|user2|$2y$10$nrBLkBONdb4DjuJuIenZOeSYUryQtRrNOKYCnxXErFqi9yk8NP59q|1| Tada. You're now no longer storing md5, and at no point did you need to do anything magical with the md5 hashes other than hash them again. 
Any constant salt is not secure. The point of using a randomly generated salt is that every password has a different salt, which invalidates the use of rainbow tables. I would trust the people who wrote the bcrypt algorithm and the people who wrote the PHP implementation of it far more than I would ever trust my own abilities to write secure code. MD5 was not considered secure 5 years ago. While it was 2004 (~10 years ago) that a number of more serious flaws were found, it was 1996 (~20 years ago) that people started recommending against its use.
I'm not advocating a constant salt. I'm advocating adding an extra salt component to the hash. Also.. 10 years ago already? Fuck now I feel old.
Cool, so, what are you looking for in a mid level developer when hiring a remote PHP guy?
As a few other developers have already pointed out. Typically setters (mutator methods) allow you to validate any data which is being inserted into the object. Setters and Getters also allow you the added benefit of hiding implementation details so you can modify class property values without having to refactor your entire codebase. ie: if posts.name becomes posts.title then it's no big deal since we can simply update the appropriate getter and setter method implementations.
User function autoloading.
In fairness basically any job is going to take a look at your social networks to get a sense of who you are. If I was hiring someone and I knew they had a GitHub account, I would definitely take a look.
&gt; the official mascot of PHP Just so you know ... the ElePHPant is not the official mascot. At all. There is no official mascot of PHP. And if you look at php.net you'll see no mention of the elePHPant at all. It was Vincent who came up with the idea himself of turning the PHP logo into an elephant because of it's design, and he had fun with it and shared it with the world. The PHP community then went OMG THAT'S AWESOME and started wanting to use it, to have a plush of it, etc. But it's never been made an official mascot (nor would it be, since it's Vincent's design)
You dont understand what I was saying at all, did you read? It is System.out.println, not .System.out.println. See the difference? No other programming languages force you to use a leading namespace separator(like . or \), only PHP does it awkwardly. Its ugly and error prone. 
&gt; User function autoloading. Function autoloading was an example we've suffered from for the entire 5.x series. And it'll still be the case for 7.0. &gt; It just is still missing Saying "it just is still missing" isn't changing the fact that it's been over a decade of inconsistency in the way functions and classes operate in PHP. &gt; nothing we'd left out by design. That's incorrect. There's a big issue preventing an efficient, well-designed function autoloader (and the real reason it wasn't added after 5.3). Classes have no fallback to global namespace precisely due to autoloading, and functions do have a fallback. Any correctly engineered fix would require B.C. breaks and so a major PHP release, so that ship has sailed with 7.0. How would he keep B.C. with the fallback *and* have an autoloader? Just trigger the autoloader every time we call a global function, and have it fail once every time? Global functions that shadow local ones (that would be hilarious)? Anything else? What? Don't add half-baked features to PHP, we have enough of that already. And this is precisely why I don't like your RFC for short closures. It's half-baked, you haven't shown any willingness to evolve it based on feedback, and it'll add a flawed solution for short closures to PHP that prevents us from having a proper solution down the line. I don't want a RFC implemented by someone who says this in their RFC: &gt; Type Hints are not added due to technical problems in parser and **the RFC author is not sure about whether they should be really added.** You're not sure if function arguments in PHP should have typehints and defaults? *You can't just decide this piece-meal for one construct when the entire rest of the language has it.* It's such poor craftsmanship, I'm amazed you got so many votes!
1. Demonstrates ability to write clean code with clear consideration for separation of concerns. 2. Open source contributions or at least commenting on open source issue trackers. 3. Diversity of programming skill beyond HTML/PHP/JS.
It's more similar than (note: no whitespaces) $x ~&gt; $y $x-&gt;$y Also, I'd accept the accessibility issue in case we weren't using `~` already for the bitwise not operator. I'm not trying to not take it into account. I just have people here who prefer to not reuse the Hack syntax (even Sara from the Hack team preferred it) … and people who don't. Hard choice who to listen to ;-)
Quoting the RFC: &gt; Additionally, I was asked to not reuse the ==&gt; syntax (http://chat.stackoverflow.com/transcript/message/25421648#25421648) as Hack is already using it. Hence ~&gt; looks like a great alternative.
If only it was that easy in the real world.
For entertainment purposes, this is how that appears on my screen: http://i.stack.imgur.com/uJ4wG.png Even knowing that there is a difference, it is hard to distinguish the squiggle vs the dash.
The syntax is very implicit. For instance no `return` despite returning? That's inconsistent with the rest of the language. Consistency is king.
&gt; Also, I'd accept the accessibility issue in case we weren't using ~ already for the bitwise not operator. When is the last time you've used the bitwise not operator? I haven't used it at all for probably over a year. It's not intellectually honest to compare the design choice for an obscure rarely used operator with something that's supposed to be a common construct in the language like closures.
perhaps. I believe googling and reading good articles is a lot more efficient then reading twitter feed 90% if which is garbage anyway.
I also don't use twitter, but isn't the feed simply the aggregate of whatever you subscribe to? In other words, if 90% is garbage, unsubscribe from that 90%...?
&gt; Twitter activity Really? The rest I agree with, but twitter? Really? (the last 'really' said in a higher, squeakier voice) //look at codepen.io stuff too, thats where I have all my recreational javascript code or CSS experiments. //I dont do twitter other than follow (lurk) other devs, and only maybe once a week. 
I work for [Fulfillment.com](http://www.fulfillment.com/) and we just did a massive overhaul of our system of which one component was moving to Doctrine2. * 10,000+ api requests/daily * Most expensive api response time (root entity with 12+ child entities) &lt; 500ms * Load time for all metadata (boot time) is 10ms with 40+ entities Smooth as butter. And we aren't even using heavy-duty instances on EC2. Your senior devs are rooted in legacy. 10+ years ago they may have been right about performance IF your app was performance-sensitive but now they are just being luddites.
&gt; None of the use cases presented by you suggest memcache would be a suitable tool. None of the use cases for tools presented by anyone else as possible solutions, are applicable to the project, so I'm sure you'll let everyone else know? Bye Felicia. &gt; Memcache is meant for caching things. Period. You're limiting yourself. Some high frequency trading systems use memcache to store simple throughput counts of message systems because it's a simple and effective in-memory storage.
I've entertained this stupid argument so far, so I'll respond one more time. You can argue OP did not present any specifics which would require a fully featured database, or even a persistent model. However, there are absolutely **no** use cases for your PHP + memcache stack without a persistent layer. You can't rely on memcache to not randomly delete data, so you might as well store temporary information on variables. If you need x-request information, you will have to use a persistent model, as memcache is not reliable. The only use for memcache is cache.
Hmm, well. Probably depends a lot on what code you are working on, … I've even used it today. Besides from bitflags, I also often use it as regex delimiter...
There is more to people than just the code they write.
&gt; I've entertained this stupid argument so far My arguments are not about using memcache for some purpose. I have made it a point to say that memcache is a database, it has persistence, and there is no need for any specific type of storage based on the stated project..the rest has been clarification, iirc. You seem to be flailing to convince me of some agenda.
Downvote for not mentioning password_needs_rehash() in the article itself (who reads internet comments :p )
Yeah its just that the twitter one stands out.The rest seem work related. Twitter, the joke is, has had 2 billion tweets and not one useful one yet. Or funny. If you want to know what more there is to a person, just ask what they do for fun. Beats the hell out of depending on twitter.
Funny, I'm working on something like this right now, but in Codeigniter 2.2. I have the opposite problem, I need to carefully validate the data because it's user facing. So I parsed the CSV and created a JSON object. But it allows detailed feedback to the user about what might be wrong in their data or what is wrong with the upload. This is a great solution when that's not an issue. I want to see what other people have to say about all this. Thanks for posting. Edit: do it in the browser up to 10k lines is pretty fast, but I have a recursive check for duplicates so, it slows down around there. 
Right now it's pretty easy to get filtered out before you even have a chance to show them the obvious value you could bring to their company. They might as well be asking if you prefer Iron Maiden or Metallica, and there's no room for you if you like reggae. I think part of the problem is that companies need to stop looking to other companies to do things "the right way." None of them have it down. Not Google, not Amazon, not your competitor, not the random blog post you found about that one simple trick to hiring developers. You will never see many of those companies' problems that constantly burden them, and many of them will go unspoken unless you specifically ask about them from the people that work there. [edit] By the way, one of the best developers I know spends almost all of his free time with his family, brewing beer, and working on the occasional electronics project. Dude didn't do much programming before college, only did a few side projects that he keeps on a private server, but he's still an excellent developer because he's just smart like that. Other technical people could instantly recognize that if they talk to him, but he would easily get filtered out in the beginning based on current trends.
Drupal 8 is doing fine, it's just slow. Be happy that there's a big CMS project willing to take risks in order to adopt modern good PHP practices.
@snlacks, Stay tuned for part 3 of my Import CSV blog series. It covers importing in background which will allow you to get full stats on the file import.
This trend is mostly at companies you're better off not working at, however. There are plenty of good companies both small and big where people are not so shallow and closed-minded (expecting a github profile with a lot of actual code is both). There are lots of good developers working in no-name places and having a great time. Even in places like the bay area, there are companies that are not totally closed minded and have decent hiring practices and working conditions. They're *very* hard to find in the bay area, and somewhat easier when you get to saner metro areas / remote. Anyway, don't let this trend get you down. There are plenty of developers with kids, who are older, who have all the traits that are discriminated against in a lot of startups that have great jobs. Also, whatever's written on the requirements section should be taken with a grain of salt. Education, for almost any position, is irrelevant. Most frameworks are irrelevant (though they help if you have them). At the best companies, even languages are irrelevant. Those companies are also hard to find, but they do exist. Those are the type of companies that hire talent for talent not for the next 6 month project. So no, you won't have your resume thrown in the trash at the places where you'll want to work, and yes, there are a lot of those places if you're good, which I'm sure you are. :)
Well, Laravel has a lot of moving parts and abstractions as the OP image kinda indicates. To an even greater extent, there's Ruby on Rails. Each request allocates thousands of instances of classes. Then there's something more bare-bones like http://www.slimframework.com/. I'm not saying complexity is inherently bad. But it is a cost. For example, you have to credentialize in more code to understand what Laravel is doing behind the scenes. The cost is often worth it. I think that's what you said in your comment that I'm replying to right now. I agree with that. And depending on what you're doing, it might not be worth it. But it's a decision that you make regardless.
I have 3 years in the industry, 7 developing code. I used to use Code Igniter but recently switched to Laravel. so If you have framework questions I can help you out with those too. I have experience with a lot of CMS as well.
Very true. Development in the real world rarely offers the opportunity to do things perfectly and I suppose, like anything else, "it depends".
Depends on what I'm hiring for. If I'm hiring for a high-mid to senior position I need to see a passion for your craft. As a lead I need my mids and seniors dependable and knowledgeable. Low-mid to juniors? Sure be a clock puncher. Technology and company needs change, sometimes really quickly. Keep up or get out of the way.
Passion for craft and clock punching can go hand in hand. Lots of my devs do both. Open source is not the only way to show passion.
These kind of RFC's just tickle my bullshit spidersense. Couldn't resists but write a rant about it :) https://medium.com/@chrisramakers/php-short-closure-syntax-and-symbol-choice-fa4699497107
Wait, so you're posting in a PHP forum, telling people to keep up with trends? It would be silly of me to dismiss your company for using PHP, wouldn't it? The same logic applies to filtering candidates based on them not being active in social media or having ample code on Github. In fact, because it's now trendy, it doesn't even mean they're a good developer if they do all of those things. In the end, communicating with a candidate is still the answer.
Well, I am more than happy to hire incredibly productive workers who work smarter, not harder, and therefore have no public github/stackoverflow.
If you show me something you've done, I'll probably be able to recognize if your way of writing code is any good - regardless of how tested your stuff is. So it's okay even if it's a hobby project - we all have our one-offs, and many often have impressive parts. However, I'd still suggest you find some time for projects. Pick one, and make a habit of spending at least 5 hours a week on it. Iron it out gradually, make it impress you. Make it worthy of sitting in a portfolio trophy case, even if you're the only one using it. You'd be surprised how much you can learn from struggling with yourself on your own designs and architecture, not to mention the ton of new technologies you'll get introduced to which would, in your closed-source day job, simply pass you by otherwise.
I agree. I also feel like over-dependence on callbacks is a bit of a code smell and makes code harder to reason about. I'd hate for the language to encourage design obscurity. For an inherently synchronous language like PHP, closures are great for doing things like in-line sorting comparison functions here and there, but if your architecture is heavily dependent on "lazy execution" through callbacks, then I would argue a short syntax that encourages this is not good.
Sure you would. That's obvious, right? But it's the other way around here. See, when I recruit people I never EVER require any social media info. I'd require resume, passing interview, and maybe some code test. However if candidate does mention social accounts and/or social coding accounts then I check them out, but I don't look at activity, but rather "what's there, just to gauge it"
So... Vincent has no role in it, except that you have to go through a process he's defined which makes sure he gets royalties from it. That's some pretty sketchy logic. Also, you not liking the Ukrainian ElePHPant design doesn't mean that it shouldn't exist. If Vincent bullied them into shutting down, I'm going to be livid.
Yes. Standard practice in cases where they've agreed to a legal settlement of some sort. They'll usually direct people to the incumbent as part of the settlement. I'd really like to know if this was the case.
That's what lists are for, set up some topic focused ones and you will stay productive.
&gt; But actually, as we are technically unable Yes, I figured as much. PHP variable and reference semantics are truly a pain :) But then why suggest a short syntax at all? If you look at ES6 fat arrow syntax, it's a nice addition especially because it *fixes* the broken `this` binding. Who cares about the keystrokes? This RFC otoh actually *adds* yet another gotcha... &gt; Also, if you really want that (you most often don't) Actually, I think you'll find I do :)
Gitignore any sensitive stuff. Still dangerous but is one solution. 
I don't have time to do open source. All my work is very private and technical not owned by me. Full time dealing with medical data and side projects for startups and small business owners. 
If You really want to go to conferences try to sell that idea to higher ups. Chances are they can be persuaded to sponsor Your trip and chuck it into work-expenses. I don't care about social, but with contributions there's one easy way: if You need something for work and You need it baad, and project you are using would benefit from it and Your work too - work on it on company time. If Your boss is anything like me, he'll understood and will allow it. Outside of work: you have family, friends, hobbies etc. So you're clearly right about "ain't nobody got time for dat!"
A lot of shared hosts will disable this due to [security issues](http://dev.mysql.com/doc/mysql-security-excerpt/5.0/en/load-data-local.html).
When you say you don't let them use a framework do you also not let them use any composer packages? 
And you're welcome to do so. Though again, nothing I said about the people I've talked about work harder instead of smarter. They tend to be more aware of the technical landscape, best practices, and can lead other developers to meet their career goals and business needs in more efficient ways. As such I promote and compensate them accordingly. It has been my experience that individuals who don't work to expand on their knowledge and skills beyond the 9 to 5 don't have those previously mentioned qualities. As such, even if they provide raw benefit for the team they get looked over for promotion.
&gt; password_needs_rehash No it's in the article, check again ;-) 
Tools familiarity and communications skills are ok. Well, partially. I don't agree with Amazon &amp; Heroku. After all they are paid tools. Sure may have free plans but i'd rather teach new hire to use proprietary stuff we use than expect to hire already somebody already experienced with proprietary stuff (except in rare cases when I need somebody experienced in that particular tool... but it's very rare). With communication skills I've noticed that more often than I care to admit, introverts and quiet guys are far better than friendly guys. Both in terms of coding skills and efficiency. But **level of engagement**? Seriously? During interview I can check PHP-FIG standards and level of knowledge. I can and will look at social profiles, but only if candidate underscores that he/she wishes so. I'd like to pinpoint some: &gt; Twitter activity Seriously? I mean *really* **seriously**? I know You've explained. but hell, I wouldn't even THINK about checking that one out. I really don't care about candidate's political views, jokes (or lack of humour), photos and whatnot. Shall I check their instagram too? or snapchat? or myspace, facebook, and/or others? Damn, the only social profile i've ever checked was linkedin. And only because person said to look at it. &gt; Github activity What for? I've got 3 guys one time. 2 had github profiles with stuff like "see me pointlessly implement shitload of patterns nobody uses" or "i can fork everything and have it on my profile, yay". third guy got none. 3rd guy had best skills and knowledge of all interviewed that day. Seriously - I only contribute to stuff that I use in work and only for work. I really have waaay better things to do while not working (like for example spending time with family, doing some woodworking...). Here You're chucking out people that either can't contribute during work hours or don't like to contribute (I have nothing against those). &gt; Stackoverflow activity I have no reason to believe that this can be of any revelance to anything outside stackoveflow careers. Can You elaborate on that? Isn't this any different than participation in any programming forum? &gt; Whether they've been to a local user group or tech conference What about introverts? I like introverts very much. They aren't people's people, so they don't go to hang out... Or what about those with problems with travel/commute? Quite honestly - I've been to like one conference and I didn't like it. I;d rather meet all those tech people in person or via mail/chat somewhere where it's less crowded/noisy and I'd rather avoid all those sales person shoving their new evolutionary tech product everywhere. &gt; Have they written any blog posts or guest articles? Hey! I did! Want to see my jewellery/art stuff? I'd rather not write anything programming-related since it was my free time :) Nobody has yet paid me to write blog post but it maaay change, so... Ok, WHY even look at somebody's blog? To see if it's related? Why should it be? Don't people have other hobbies outside work? Seriously.. Are You looking for tech writter or mid level dev? (joke) &gt; Do they have any projects/products that they've created So work experience, right? But the way You've worded it sounds dangerously like "PERSONAL projects/products that they've created". I wouldn't like if somebody had asked me about personal projects that I've programmed, because outside of work most days i'd rather not spend too much time with computer. 8h daily is enough, plus "ain't nobody got time for that". If You'd like to see some stuff I did while in work? Sure, sing this NDA, get access from my previous boss etc. But I can code tons without even browsing manual :D And I finish this pinpointing by once again communication skills: I guess that from above wall of text you'd rather not enjoy our time together ;)(see how lame my jokes are)
I'm VERY OK with OS work on the clock. I'm very not OK with OS work being now requirement (what I can see from many responses here)
I do ask people when interviewing them, if they have worked on any open source projects, but what's important to me is not necessarily that they regularly contributes back to those projects. Whats important to me is that they have experience outside of some highly proprietary in-house built system. That kind of experience can be problematic if it's most of what they have done. That said, yeah... Get paid for work you do. That's disgusting that companies would force free open source work without pay. I wouldn't do it unpaid *for* someone else. I would do it unpaid for the community or myself.
Well someone who codes in their spare time instead of doing other things is likely to have more experience programming and be more passionate about it.
With your approach the main issue would still remain. The issue is that using request as a parameter bag enforces no contract. You have to rely on the user to be stored under the 'user' keyword. There is no typehinting, and the middleware has no idea what it is actually working with. As for collisions this is hardly an issue with middlewares, since they are chained. Its the responsibility of the second middleware to "look before it leaps" and not set a user if its not needed.
Yes please!
If you're needing LOAD_DATA, a shared host is probably not going to work well long term anyways.
This is a nice importer /u/ThePsion5, I've got Part 2 Validation and Part 3 Background importing in the oven to complement this post.
Figure most apps are going towards the SOA standard, so it's great to see if they actually understand that architectural approach. On top of it, it REALLY helps to see how they structure models, etc. I have met a lot of devs who get OOP and MVC, but do crap work when it comes to actually structuring something. The models are always a big problem. Glad you like the idea! Hope it works for you guys!
The *de-facto* standard is for middleware to work with `RequestInterface` and `ResponseInterface` objects; i.e. `function(RequestInterface $req, ResponseInterface $res, callable $next)`. I don't love it. This becomes *really* awkward because of their immutable nature - the "data bag" thing doesn't work particularly well, and in any case the de-facto standard still requires a lot of boilerplate in every implementation to work as expected (`if ($next) $response = $next($request, $response);` or similar). I think the whole thing needs a ton of improvement before a community standard is established. I'd like to point out that I'm *not* suggesting using the request as the data bag, but the `attributes` that are (currently) defined in `ServerRequestInterface`. Which is not great for the aforementioned reasons, but certainly better than throwing parsed objects in the HTTP Request object. The issue I have with the contexts as presented is that: a) we need a lot of them defined in PSR-*X* so they can be built in an interoperable way, and b) You have to litter your actual application with `if ($context instanceof SomeContext) $context-&gt;doSomething()` because you have one class implementing a bunch of various context interfaces. This is somewhat of a language limitation of PHP, since it's impossible to typehint an object that implements multiple interfaces. I think a better community standard may be a tweak on (a) that defines interfaces for middleware to * modify a request - `public function modifyRequest(RequestInterface $req):RequestInterface;` * return a piece of data from a request - `public function getData(RequestInterface $req):mixed` * modify a response - `public function modifyResponse(ResponseInterface $res):ResponseInterface;` The first and third are basically a SRP-friendly version of what we're already doing, while the second is how you'd do e.g. authentication while avoiding the naming collisions on a data bag. Note that all of the above is based on the assumption that the actual end controller (you know, your actual application) *doesn't* follow the same middleware signature. Honestly I'd bet we actually have pretty similar thoughts about this and have just been working in slightly different contexts - we're certainly identifying the same problems with what's currently being done as a clumsy workaround.
Laughed pretty hard at $noodles = 1; class noodles { var $noodles = 2; function noodles () { $noodles['noodles'] = 'noodles'; } } function noodles() { return new noodles; } $noodles = noodles(); var_dump($noodles); and laughed really hard at * variable class names, e.g. `$strudels = "noodles"; $noo = new $strudels;`
The syntax. As many others have said it's completely different to everything else in PHP. But the point I'm making is not about the syntax, I'm saying if the aim is to remove "use" then this method is the wrong way.
Ah I see your point now. But on firther thought I feel that the whole idea of 'attributes' is foreign to the HTTP request representation, since there is nothing like that defined in the HTTP protocol. Adding attributes to the request object was just a thing that all frameworks did, and thats why it was also included in the PSR. But if you think of just the HTTP protocol, attrubutes are sort of an appendage. Actually if attributes were separate from requests and a middleware processor signature was `function ($request, $response, $attributes = array())` or something this would solvve both of our concerns. Your criticsm of contexts is also very true, they would definitely need a bunch of interfaces defined in a PSR. But due to the modular nature of the idea it could be incremental, e.g. it might be enough to start with a simple HTTPContextContainer. As for littering code with `instanceof`, that would probably be very rare. I would imagine that most middlewares would only ever need a single aspect of the context, and could just typehint: `function (HTTPContextContainer $context, ...)`. If a middleware only needs the HTTP context it would just typehint to that particular interface (since the main context container just implement a bunch of smaller interfaces). I did not quite get the idea behind the `modifyRequest()` method. Since middleware can already substitute the request with a new one and pass it along instead. Can you show an example with it ? text would probably be enough 
You can do some pretty amazingly ugly things with PHP's syntax. &lt;?php namespace Windows\System32 { const explorer = 'delete';} namespace { const C = 'lolwut'; const exe = ' system32'; const off = 0; echo off ? C:\Windows\System32\explorer.exe /* # put other malicious stuff here */ ;} And yes, [this actually executes](https://3v4l.org/MGtAn). (Might be a good way to create a lot of antivirus false positives.)
I currently work for a business which uses all in-house systems that I've learnt whilst here. I want to contribute to some Open Source on Github but very lost as to how to do this. I've seen some projects that have issues but it all looks very impenetrable to a newcomer and from a practical point of view I don't know how to start. It looks like issues are assigned etc... so should I contact someone first? or do I just find something and do it or fix it? Very confusing to be honest.
And is also likely to have no social life, around 20-25 years of age, probably unfit/not healthy and heading straight into "burnt-out" department ;P And I wholeheartedly disagree that "more coding in spare time equals more experience". more coding may help, but may also enforce bad habits or may further skill in language/framework not needed for job or any future jobs ;) Should be done IMO for fun and nothing more.
Quick question regarding the test. What were you looking for from it, specifically if I may ask? Spotify has their own REST interface so I would obviously use that and wrap it in order to separate how the communication to Spotify is handled, and the rest of the application (in case the Spotify interface changes you only change the minimum). Is this what you mean? Trying to see if I've just missed something really obvious.
More like "How to design a mobile unfriendly website" amirite. 
 $string = @file_get_contents($file_path); Didn't OP write something about **large** files?
The aim wasn't to remove use, it was to provide lambda expressions. Removing use is just a nice side effect. Lambda expressions are a common and useful feature in many many many languages - the syntax is far from alien (even if the ... well.. tadpole operator... is). 
It's consistent with how lambda expressions work in other languages though. Consistency for it's own sake is often a poor argument. Removal of return for one liners, given that they are typically used in places where a callable must return something (i.e. any of the callbackable array functions), leads to vastly more expressive code. Again, plenty of C style languages have adopted lambda expressions, complete with the self returning nature. If you've never used or seen it before I suggest going and grabbing the Babel compiler for javascript and start using them for a few days... The benefits become apparent very quickly
&gt; is this Java implementation more or less equally efficient? Much more. https://www.techempower.com/benchmarks/#section=data-r10&amp;hw=peak&amp;test=query&amp;l=w0
Exactly. If all you want is a code monkey then fine. But most jobs will require some level of interaction with clients, hiring people who do nothing but coding is not a good move.
&gt; This becomes really awkward because of their immutable nature - the "data bag" thing doesn't work particularly well, and in any case the de-facto standard still requires a lot of boilerplate in every implementation to work as expected (if ($next) $response = $next($request, $response); or similar). I think the whole thing needs a ton of improvement before a community standard is established. I don't understand that part. You are not supposed to do `if ($next) $response = $next($request, $response)`, the whole point of a middleware is that you have a choice to do custom logic and call/not call the next middleware. It's basically the decorator pattern. And the immutable thing makes much more sense for the whole thing. I've used middlewares like this and it works really well, I don't think there's anything to improve except this "request attributes" problem.
http://api.symfony.com/2.7/Symfony/Component/Security/Core/SecurityContext.html =) I liked the idea back when I used symfony2, so when I was doing the http component for Pixie, I placed users session and cookie handlers into a HTTP Context. And then it kind of grew on me to where i try to put everything request-related in a context. This way the instantiated framework itself is always stateless, and the state is just int he context. Btw, actually passing the container multiple times to satisfy multiple interfaces is exactly what Im doing in my components =) The problem here is that the middlewares now cant have a common signature since they accept different number of paramters, which kind of defeats their purpose =\
The context container is created before calling the first middleware, so its the users responsibility to ensure that it satisfies all middlewares it will path through. So adding some methods to it on the fly would obviously not be possible. Your approach with calling `$user = $this-&gt;auth-&gt;getCurrentUser($request);` would work if the user object would only ever be needed inside the controller itself. But there are a lot of things that might request it earlier, for example some firewall component that allows only certain user roles to access certain pages. Thise would have to call `getCurrentUser($request)` too and so you would actually process users login twice(ot would have to handle that in some way so that its only done once). Injecting services into middlewares is kind of cheating, since then you might as well inject a $http service with a `getCurrentRequest` method and have no need for any action parameters at all =)
&gt; The context container is created before calling the first middleware, so its the users responsibility to ensure that it satisfies all middlewares it will path through. So adding some methods to it on the fly would obviously not be possible. I think the problem you're trying to resolve is global variables in disguise, which is what attributes are. But the solution, as proposed, is singletons in disguise. So, an improvement (at least things are typed), but not a final solution. I think middleware need a channel through which they can read and write data which is specific to them (to one middleware, and not shared among all in the chain). Then the caller (who sets up the chain) can orchestrate how middleware pass non-standard information to each other, like auth info.
In my final year software engineering topic, another student group used their presentation to explain how md5 is a secure cryptographic hash for the foreseeable future. This was in 2013. Some people are completely oblivious and ignore the warning signs even when I pulled up Wikipedia during question time and pointed out the warning.
Laravel's creator is an ASP.NET developer. He modeled a good chunk of Laravel after it. Say, the similarities between ASP.NET's Razor template engine and Laravel's Blade go way beyond just their name. You should be writing basic things on your first day in ASP.NET and 3 months is plenty of get up to speed, if you commit to it. The ASP.NET stack is made to be convenient first, and well engineered a distant second (they're doing serious work to improve architecture &amp; performance in the new release, but it's a new direction for them). As a result, half the ASP.NET users have no idea what they're doing either. They just do the first thing that works, and it tends to work. ASP.NET dictates some basics of project layout and naming conventions, but knowing the core principles of good architecture and clean code in it is just as important as it is in PHP, or you'll end up with a big ball of mud. Don't blindly rely on ASP.NET to save you from shooting yourself in the food. Write, sigh... sorry for the cliche, but... write SOLID, modular code. Be particularly curious what you co-workers' conventions are, what practices they follow, what they think is good and what they think is bad. Ask for read-only access to the codebase you'll be working on, if possible. This will probably make or break the new job for you, rather than knowing all the .NET APIs by heart. Visual Studio is *great*, BTW. &gt; How would you begin? Learn C# first? ASP.NET MVC? Both. C# is essentially Java + extras, and Java is essentially "static PHP". So you won't feel it too foreign. Start a new ASP.NET project and play. &gt; What are your favorite learning resources for these? MSDN obviously, Freenode's relevant channels, also check on YouTube the "ASP.NET 5 Community Standup", they talk about latest developments on the new ASP.NET beta.
&gt; C# is essentially Java + extras, and Java is essentially "static PHP" &gt; hahaha... wait are you serious?
&gt; hahaha... wait are you serious? Yeah, basically I am. I realize it takes experience to get that high-level look on things, but you know, it's a chicken and egg situation. If you think they're vastly different, you'll be too afraid to learn and eventually figure out they're not. If you want to see why I find PHP, Java and C# to be similar, try something truly *different* like Haskell, or Erlang.
I think parse it line by line using fgets is more suitable
&gt; Not being able to use it comfortably sets you back some 10-20 years in the kind of web experiences you can build. Come on now, not even today's cutting edge technology comes near `marquee` and `blink` combined.
Write down a complex plugin for Wordpress, and focus on the features that are requested everyday.
Here are a few concepts you may want to investigate. [Object-relational mapping](http://www.slideshare.net/rob_knight/object-relational-mapping-in-php) [Data mapper pattern](https://en.wikipedia.org/wiki/Data_mapper_pattern) [Active record pattern](https://en.wikipedia.org/wiki/Active_record_pattern) Activerecord and data mapper are both object-relational mapping (ORM) solutions. ORM translates database tables to objects, and activerecord/data mapper are patterns for working with those objects. See [What’s the difference between Active Record and Data Mapper?](http://culttt.com/2014/06/18/whats-difference-active-record-data-mapper/) Personally I prefer the data mapper pattern. See: [Doctrine](http://www.doctrine-project.org/). &gt; Do you have a blog object that gets posts, and then a posts object that gets the comments? The short answer is yes. You may have an `Author` object which contains `Post` objects which contains `Comment` objects. It's almost never _quite_ that simple in real life but you have the general idea.
Here's one I've experienced IRL. Don't use properties in your classes. Just use magic methods and giant switch statements.
I posted a comment on the article, but I'll copy it here too: &gt; What are your thoughts about this informal proposal? https://gist.github.com/morrisonlevi/5c3869df9fc438848ccf &gt; I am gathering feedback on it and may go forward with it.
You aren't restricted to the standard library, you know. Here's an example from my [Algorithm](https://github.com/morrisonlevi/Algorithm) library: &lt;?php namespace morrisonlevi\Algorithm; require __DIR__ . '/load.php'; $odd = function($value) { return $value % 2 &gt; 0; }; $mul2 = function($value) { return $value * 2; }; $algorithm = chain( filter($odd), map($mul2), sum() ); var_dump($algorithm([1,2,3])); // int(8) Obviously this is a bit simplistic, but note that this exact series (`filter`, `map`, `reduce`) is used in production code where I worked. Being able to write it in succinct transforms like this is concise, highly readable and highly unlikely to be sources of bugs. Being able to use a shorter anonymous function syntax is a big boon to making it even more readable. Here's how it would look with my [alternative short-closure proposal](https://gist.github.com/morrisonlevi/5c3869df9fc438848ccf) that I may submit to the list: &lt;?php namespace morrisonlevi\Algorithm; require __DIR__ . '/load.php'; $algorithm = chain( filter(fn ($value) =&gt; $value % 2 &gt; 0), map(fn ($value) =&gt; $value * 2), sum() ); var_dump($algorithm([1,2,3])); // int(8) It's not as arcane as `~&gt;` but it does add a new keyword (`fn`) but even without it the result is still okay: &lt;?php namespace morrisonlevi\Algorithm; require __DIR__ . '/load.php'; $algorithm = chain( filter(function ($value) =&gt; $value % 2 &gt; 0), map(function ($value) =&gt; $value * 2), sum() ); var_dump($algorithm([1,2,3])); // int(8)
Ah, another rube goldberg blog post.
So you don't think all these achievements look good on your CV? If I was looking at what you did, what does look better: "Introduced massive positive changes" "Just showed up every day a place where everything was already perfect". 
Yes that's right, however I was not referring to single iteration if MD5 (you can stretch just plain MD5 scheme as much as you like, just like you can adjust bcrypt cost). And note I was just showing a point that MD5 is not "broken" for password hashing (as it is broken for something that requires collision resistance for example). There has been such stretched MD5 (or SHA if you like) schemes since 20 years ago and while they are not even close as efficient as bcrypt, they are still not "broken".
Sorry I don't understand what you are trying to say. Care to elaborate?
I am guilty of not doing unit testing. I never know what to actually test in standards applications :(
I scored 6/7 on bad practices. I know these are bad, but I have to write my code really fast and there's no team, just me. Will refactor eventually.
 "~&gt;" really?????
Nice article! I spotted an error in your article tho, you mixed "defined order" and "no defined order" up. Ordered list has a defined order, Unordered list has no defined order, not the other way around. &gt; * Dictionary, an associative array that consists of a key and a value. &gt; * OrderedList, a list that contains any number of values in ~~no defined order~~ &gt; * UnorderedList, a list that contains any number of values in ~~a defined order~~ &gt; * Set, a set of values that contains no duplicates. 
It absolutely will! You're right. Although I'm not gonna get those unpaid overtime hours back. Another lesson there :D Luckily I've had a chance to get into Magento while I'm here and locked in some serious dev time. With that behemoth. Moving on soon anyway, so all good. 
TBH, in this day and age, please name and shame. Replacing scrypt with md5 is intentional weakening of the security of the product. They *should* be called out on this until they revert that change.
You've hit the nail on the head there! And it's exactly why I handed in my resignation about a month ago. Got a chance to move onto Magento in the company here and have had some solid custom work with it for about a year. (While maintaining that inhouse framework) So I figure there should be some work out there for me with Magento.
Upvote for honesty.
1. CMS and landing page are the bare basics, your personal website should already be an example of this. Get some real example of a basic working system into your porfolio at the real minimum i'd say. 2. Learn a framework. There's only so much basics you can learn without being exposed to some kind of real, sensible implementation of the language. I'd probably start with Laravel for beginner friendliness and popularity, but definitely start playing around with a few others after you're more familiar with MVC architecture (Symfony is a good bet, but on a bit of a higher tier of difficulty to Laravel). Check out their various features and figure out some good practices. 3. Learn all the Javascript. I imagine nearly all PHP developers end up having to employ some form of JS at *some* point. It's relatively straightforward after you get over the initial syntax hurdle and some of the more unfamiliar concepts like prototypical inheritance. I wouldn't say you have to be proficient, but you want to be able to have enough knowledge of it to be able to easily use any library necessary for the job. 4. Some resources: * http://www.laracasts.com - great for basics and primarily learning Laravel with a flavouring of frontend and testing. Mostly free for what you'll need, but it's not expensive to get all the content for a few months. When you start appreciating patterns and architecture a bit more: * http://designpatternsphp.readthedocs.org/en/latest/ * https://github.com/phptodayorg/php-must-watch I get a lot of random bits from: * https://www.udemy.com - has £8 course deal sales, i've used it mainly to buy up some Javascript/Java courses which have been pretty helpful.
https://youtube.com?v=URSWYvyc42M From ruby conf a few years ago but it's not anything specific to ruby, the ideas should translate into any OO language.
Couple of notes: 1. I would expect creating a set from a list would dedup for me. For example, in Python: set([1,2,2,3]) == set([1, 2, 3]) // True set([1, 2, 2, 3]) == set([1, 2, 3, 3]) // True Having the set constructor, and the withValue method dedup for you rather than throwing an InvalidArgumentException is much more consistent with other languages Set functionality. 2. I would expect that a set has a constant lookup time when checking an element is in a set. Using `in_array` guarantees an O(n) lookup time for `hasValue`. The set should be implemented as a hash map. Using `array_flip` during the creation of a set would be good here (it would also handle the deduping). Basically, I would expect a set in PHP to look something like this: class Set { private $data; public function __construct(array $data) { if (array_values($data) !== $data) { throw new \InvalidArgumentException( 'Set structures cannot be indexed by keys' ); } $this-&gt;data = array_flip($data); } public function hasValue($value) { return array_key_exists($value); } public function getData() { return array_keys($this-&gt;data); } public function withValue($value) { $copy = $this-&gt;getData(); $copy[] = $value; return new self($copy); } }
Just roll with it, that's what I'll do. Puff out your chest and insist on calling them 'kiddo' while looking smug...
&gt; And if someone asks why Notepad, be ready to explain: it comes with Windows (the only OS for today's productive programmer)
Salting primarily defeats attackers ability to test multiple candidate passwords at the price of one, attackers ability to use rainbow tables (or just plain pre-hashed lists) and attackers ability to see if two or more accounts share a password (or does not share a password). In addition to that, salts which are unpredictable to the attacker, like salts generated automatically by password_hash, happen to defeat attackers ability to fetch hash information via timing side-channel (ie. when the server validates hashes on login using === comparison). But this attack is probably so damn hard to pull off that at least I'm not aware of such of an attack has ever happened anywhere. So the salt that is automatically generated by password_hash will be just fine and there is no place where you could add this "extra salt". However, you could encrypt the hashes using a secret key and that way possibly increase security, but this is a whole another topic.
&gt; These benchmarks don't make it clear if the PHP code is being OpCached, which would give it a large performance boost. These benchmarks execute code in a loop. Which means opcode doesn't matter as PHP isn't restarted. And yes PHP is less memory hungry because it's reference counted (GC is just an extra) and doesn't JIT compile to machine code, while Java is entirely GC based (this creates more dead data on the heap until it's collected). In fact, if you add opcode cache to PHP, for these tests, you'd only see greater RAM usage on the PHP side for the opcode cache, without better performance (as it's not used).
&gt; All good advice. I would tackle Javascript before frameworks though. I've been freelancing full-time for 2 years now as a full stack one man shop and have yet to see a need to touch a framework. Well, that's the thing. I tried to hint a framework matters mostly when the people one works with also use it. One man wolf packs are free of such concerns by definition. I'd tackle JS first as well, though. There are many frameworks, but one JS, and it's essential. 
1. Yup, I should be less sellsy from time to time. I agree. Can't help myself sometimes. Anyway, I should separate the "general ideas for the benefit of humanity" posts from the "buy my stuff its great" posts. Noted. 2. Nopes, please don't commit secrets to git. It is not a good idea. Inject those into your environment.
I also have an announcement to make. That old Pentium III box that I forgot in a crate in the basement now also supports HHVM. I installed it yesterday. This is now a crate based PHP PaaS (Pentium as a Server).
If you want to write unmaintainable PHP code, just use radicore from Tony Marston. Just a quite note, it has a class with 9000 lines! I mean, 9000! http://www.radicore.org/
$noodles results in an object: object(noodles)#1 (1) { ["noodles"]=&gt; int(2) }
its not called bullying its copyright law, and to quote you "just because you think it should not be copyrighted, does not mean it should not be" :P He does get royalties, that is called "getting paid for something you created". Totally fair IMO.
I didn't want to flame OP's announcement, I just didn't want to post a new thread about it, so I posted my announcement here.
I see where I misunderstood you - call it a class, not an object :) A class is the definition, an object is an instance of a class. And within an object, they're termed as methods rather than functions.
I must [admit](http://www.onislam.net/english/oimedia/onislamen/images/mainimages/15-6-15_How-to-Repent-and-Return-to-Islam.jpg) i write a program of more than 300 text files, i hate comments, i dont write one.
Where I work, we acquired a website that was basically coded using this article as a guideline. Literally, the guy has a function named a(). I still don't know what it does. I would *love* to refactor it, but... when we bought the site we signed a 2 year contract saying we wouldn't refactor the code.
for all who commented, thanks for your help. for now I wrapped the admin area with an IP whitelist. I'm sure it'll stop all the external attacks. Need to find time to refractor this.
All I'm looking for is comments and well-reported issues on peoples' github history. If you use libraries, you find bugs, and if you find bugs, you should report them. Pull requests are a definite plus. If I can't find any of your past work in a portfolio or on github or some other online place, I'll depend on your references and job history. It then becomes pretty obvious whether you have the requisite skills or not. Then I decide whether to interview.
This is fine and dandy, but really the fundamental problem is the stunted nature of the database schema. Give us a clean, structured schema that doesn't ignore the 'relational' in relational database and we can start building out APIs in other languages beyond PHP and truly de-couple from the WP core for presentation.
Im not a php developer, but i have some experience with asp.net. Asp.net mvc is definitely a great way to get into the microsoft paradigm, dont bother learning c# first, its just another object oriented language, it has some funky features because microsoft has been developing its features into oblivion. Lynda.com and pluralsight both has great tutorials on asp.net mvc. But the official documentation is pretty good and i surgest starting out with their MVC example at http://www.asp.net/mvc, to get the hang of it, when you're done with that, you should take one "complicated" topic at a time, you should get a good grasp of the EntityFramework, and decide whether you want to do the code-first or database-first way of generateing your DB schema. Learn LINQ, which is a query language that you often use to fetch stuff from EF. Repository pattern, in general just read about common asp.net mvc design patterns. Learn the IdentityFramework, which is their authentication, user &amp; role implementation. Learn about Migrations for the database. frontend stuff, then its great to know about stuff like Razor, ViewModels, some javascript framework to keep track of clientside state like KnockoutJS or Redux, styleing framework like bootstrap, maybe a instant messageing framework like SignalR. i think for the frontend if i was still on the microsoft bandwagon i'd try the react thing aswell. 
This came to mind when I saw that. http://i.imgur.com/XUbkeFR.gif
I think what you want to look at is ... https://github.com/vlucas/spot2
fgetcsv **
Thanks for catching that! I've fixed it.
A non-modified instance of the object is no different than the original object. Most (all?) PSR-7 implementations make the same assumptions.
I understand that, and I'm not particularly against the implementation. Just that it has room to be misinterpreted. Even I missed this part right underneath: &gt; If we add a duplicate value to the set, nothing will be changed I don't have a better solution, just an initial observation. I haven't done a ton of work with immutables so the reality of using them might not really have any problems with this. I would suggest creating documentation, though. :)
If it's immutable then there's no problem in return $this because any attempt to truly modified the object (ie. modifying its value) will effectively return a new object. What's important is the value, not the object per se. What the object guarantee is that the value will remain unchanged. If he had added a `sameValueAs` method I think it would have been more clear IMHO.
Are you sure the bottleneck happens when actually generating the PDF? Maybe it's when retrieving data, or generating the bar-code. Try to profile bits of code and see which takes the most time for 1 record. Then, maybe assign this process of generating the hundred records to a job which will be triggered by a cron and mail you when it's finished. Should work, provided it doesn't keep your server in load. I don't think changing libraries would be of much help, unless you see that the most intensive process is indeed the PDF generation itself.
That's some organizations believe. Rewriting legacy apps just for the sake of rewriting is seen as a waste of resource. Especially when the legacy app shows as secure with pen testing, is relatively easy to maintain and works reasonably well. 
It could be this: http://codingexplained.com/coding/php/solving-concurrent-request-blocking-in-php See https://secure.php.net/manual/en/function.session-write-close.php &gt;as session data is locked to prevent concurrent writes only one script may operate on a session at any time. If the long-running script is holding the session data open for writing, PHP will block other processes that need to access that session until the long-running process is finished. If that's the problem, calling session_write_close as early as possible will allow other scripts to run. Beware though, that if you change anything in the `$_SESSION`, those changes will not be saved and I don't think you get any warning or error if that happens.
That does make sense and explains why the SPA isn't running anything. Adding that works to fix the concurrency issue, as I only need it to access session variables for the purposes of running a script.
This is an excellent choice. Similarly, I have used [PhantomJS](http://phantomjs.org/). For PHP users, the [phantomjs-installer](https://packagist.org/packages/jakoch/phantomjs-installer) makes it REALLY easy to install using Composer.
&gt; What's important is the value, not the object per se. What the object guarantee is that the value will remain unchanged. Definitely agree there.
That's exactly what I was expecting. Basically an API wrapper. I know it's kind of circuitous, but it has actually been pretty fruitful. 
This is pretty typical. The fact is, everybody writes shit code. Today's passable mess is tomorrow's untenable trainwreck. Don't even sweat it.
&gt; The guy was the old-school kind of guy that believes that having the code compiled makes everything faster That's simply wrong. I could write assembly to connect to and query a database, and *it would not go faster than PHP*, because the code calling the database in PHP *is already compiled*. It is never the language that is the bottleneck in a web service or application, it's always data sources and repositories, it doesn't matter one iota what language you interact with these things in, not even a little bit. It's really not worth talking about the speed difference between Java and PHP, it doesn't matter to us, it never has. To be frank, I would walk away, working with Java is soul crushingly boring, and whatever you do, you're going to have to work with Java ... I think ... Yep, I'd rather kill myself.
&gt;Build a framework. Then you inevitably become The Architect and your authority is unquestionable. someone has to do it and ill be damned if I rely on someone named taylor 
It is stateless: subsequent calls to the same method with same parameters should return the same result. Calls to `$auth-&gt;getCurrentUser($request)` will always return the same result. In a PHP setup handling many requests in the same process (or e.g. in CLI processes, tests, etc.), calls to that method with different parameters will return different results. And this is what you want, this is stateless. On the contrary, `$auth-&gt;getCurrentUser()` will return different results depending on the current requests (if you handle multiple requests in the same process). That's not stateless, because the result of the method *depends on the current state* (request).
It links that very article, but in its full length: &gt; Inspired by the most excellent piece "[Writing unmaintainable code](http://mindprod.com/jgloss/unmainshoemaker.html)" (must-read for anyone interested in keeping their job) [...]
Oh brilliant, I was hoping that I had not missed something quite obvious and that perhaps you were expecting something much lower level.
It looks stateless, but your internal cache is the state. You can easily have the same with $auth-&gt;getCurrentUser() but clear it after the request has finished processing. Since the request are processed one after another it would be the same thing. By having internal cache you are just hiding the state, not remoing it
&gt; He may be old-school, but he's not wrong about Java's performance, which is from 20 to 80 times faster than PHP. &gt; Although with PHP 7, soon to be "only" 10 to 40 times faster than PHP. Yup! If you're implementing mandelbrot. If you're writing real-world systems, the performance difference quite often drops to being margin-of-error. I'm 100% with you for right tool for the job, but unless you're doing pure computation (which is exceedingly rare), raw CPU performance is rarely your bottleneck. So talking about it is completely disingenuous. I know of one specific company that did a rewrite from PHP to Scala because PHP was too slow and didn't scale. Guess what happened when they launched? They had the same performance characteristics. Because the language wasn't the bottleneck, it was how they wrote the code and their I/O constraints were identical. &gt; Now, you see also here and there mission-critical services running on Node.JS, Python (say, Uber) and it's possible to do in PHP, but PHP has no advantage in the pure backend services niche. That I will disagree with you on. The type model alone in PHP is superior to Python and Node.JS (which both incidentally avoid the ability to type at all, and no, PEP 0484 doesn't solve that problem in the least). And that definitely matters when you're talking about scaling engineering teams. If you want to talk about Go/Rust/Java, perhaps. But definitely not Python/Node.JS. They are popular because they are sexy. But if you look at large scale teams, many have or are moving away from them in terms of core code, simply because it's hard to scale an engineering team without the safety that types give you. There's a reason Facebook moved to Hacklang. At the end of the day, Python, Node and Ruby are the languages people talk about building big modern systems in. Yet if you look at the numbers, PHP is being used orders of magnitude more than each of them. There is a reason there. 
&gt; That's simply wrong. I could write assembly to connect to and query a database, and it would not go faster than PHP, because the code calling the database in PHP is already compiled. You don't know of OP's task is database-bound, so you're kind of arguing with a straw man. OP later shared the data being sent from at least one of the services in question are genomes. So it's quite likely in processing this data a lot of raw number crunching is involved, as well.
&gt; You don't know of OP's task is database-bound What web services are CPU bound !? Having a compute heavy section of code is not the same as having a CPU bound application. CPU bound applications do not belong inside web servers (where PHP is), they don't fit. You can have an infrastructure that contains components that are CPU bound, but you don't put that in your web server, or anywhere near it, no matter what language you are using, it doesn't make sense. Made some assumptions, sure, sensible ones ...
&gt; What web services are CPU bound !? You seem to have a very narrow view of what a "web service" can do these days: - https://developers.google.com/apis-explorer/ - https://aws.amazon.com/ At least a dozen of those can be considered CPU bound. I'll just pick out one specific example which is not too much out there to ground the conversation: Google Charts renders images on demand from their server based on data you supply (they've been moving to SVG etc. but the image renderer is still there). &gt; CPU bound applications do not belong inside web servers (where PHP is), they don't fit. When we talk about serious web services, the "web server" is nothing more than a thin front-end for the actual service, and as I acknowledged, PHP belongs in the front-end. So you're right, I wouldn't stuff CPU bound application in, say, Apache (where PHP is), but also you're missing my point, we have to separate the front-end and back-end of a web site (or service) and I said PHP is great for web site front-ends &amp; simple APIs, but that's it. When you have a complex back-end, and a brutally simple front-end (no sites, no templates, no CSS, forms, just a JSON API or plain streaming and downloads), PHP has nothing to offer. &gt; You can have an infrastructure that contains components that are CPU bound, but you don't put that in your web server, or anywhere near it, no matter what language you are using, it doesn't make sense. I'll call those folks and tell them they're morons: http://deepdreamgenerator.com/ &gt; Made some assumptions, sure, sensible ones ... I'm afraid in 2015 the assumption "everything on the web is cheap I/O bound CRUD stuff" is no longer sensible. The assumption web service is public, free &amp; unmetered is also not sensible. A lot of paid APIs out there. If it's expensive to offer and maintain, you can charge for it, or limit it. People are exposing some quite crazy stuff over the web. Say like terabytes of genome data, with queries over it which are both I/O and CPU intensive. 
No comment... I can tell you why the benchmarks are such an improvement… architecture and too much code being run. Also, we have very minimal latencies when we bench our code on databases sitting on localhost. And you're saying it with _if engineered right_. That's a big problem with many PHP apps. They're loading the whole world and the heaven first, just to later use the hell and be done … and then unload it again to be redone at each request. In Java you just have that persisting. You are actually comparing great Java code with bad PHP code ;-) But state in RAM… how do you scale out here? When a single machine isn't enough… you need to still exchange the states. Also, PHP in general is fast. The point is that PHP apps also need computations sometimes and then it sucks. _This_ is the case why /u/ircmaxell needs it. In general it doesn't help that much. What do you want to optimize there a lot around when we need to setup thousands of objects and fitting it in arrays? Not a lot possible here. If you have long-running cli applications acting as server, then you don't get that much of an advantage... We're just trying to eliminate the common misconceptions about PHP… And you are naive by the way you are comparing things.
Well you can always design a public API to make it appear that your code is stateless, when it actually is. You would still need to clear the cached user after the request has finished processing, so your code would actually work in exactly the same way simlply using $auth-&gt;currentUser() and clearing it afterwards. Run your test for a 1000 different requests and suddenly you exhausted all your memory caching user objects. That is not a stateless system. A truly stateless ssytem would get the user, his labguage, etc and keep all that in local scope.
&gt; No comment... Ok. &gt; I can tell you why the benchmarks are such an improvement… But... I thought you said "No comment"? &gt; architecture and too much code being run. Also, we have very minimal latencies when we bench our code on databases sitting on localhost. You're not addressing what I asked, instead gently dancing around it. Here's it, again: *How can those two statements be true at once:* - *Language performance is irrelevant to apps using a DB, so Java being up to 80x is irrelevant to app performance. Just a margin-of-error!* - *PHP 7 runs apps using a DB twice faster than PHP 5. With the same DB. Not just a margin-of-error!* &gt; But state in RAM… how do you scale out here? When a single machine isn't enough… you need to still exchange the states. Well I gave you links, you can read about it. I'll just say that this model is at the basis of CQRS architectures, which are the most scalable (and best locally performing) way to design a read-write model that I'm aware of, especially compared to typical SQL-backed CRUD. By your questions I can tell you're not quite familiar with the architectures being discussed, enabled by Java and co. And it's a good idea *to be familiar with something before you dismiss it as unimportant*. &gt; Also, PHP in general is fast. The point is that PHP apps also need computations sometimes and then it sucks. Well you're backtracking into precisely what I said at the top of the thread. So basically we agree now? PHP's performance doesn't matter for web front-ends and simple back-ends. But it's a poor choice for complex back-end services with high demand for throughput and compute. &gt; In general it doesn't help that much. The problem is that your point of reference for "general" is "a general PHP app". It's a self-confirming bias. Say, Google wouldn't implement their Google Translate web API on PHP, you can trust me on that. &gt; What do you want to optimize there a lot around when we need to setup thousands of objects and fitting it in arrays? ...Wat? &gt; If you have long-running cli applications acting as server, then you don't get that much of an advantage... ... Wat? &gt; We're just trying to eliminate the common misconceptions about PHP… And you are naive by the way you are comparing things. What exactly is the misconception you're trying to eliminate. You're essentially *repeating my first post here*. Here's what I said: &gt; Speed doesn't make or break a web language, so I doubt he told you PHP is "rubbish" for this reason. Maybe it's "rubbish" for their particular goals &amp; projects, and that's possible. Just like sometimes Java is "rubbish" where PHP would work better. Right tool for the job, you know? So. Where is the **misconception** here? I think the right way to describe what happened here is /u/ircmaxell knee-jerked, and then you knee-jerked after him, and now you're backtracking into softly agreeing with me without saying it. 
&gt; I dunno what those API's are, pretty sure though, they have that same kind of infrastructure, or else they are painfully slow ... You keep arguing with straw men. I never said "put heavy tasks in your web server threads". But I guess this is kind of your only point, and so you're keeping at it. &gt; I haven't had to wait for 15 seconds for a page to load since the late 90's ... sure, that belongs on the web ... pfft ... This conversation is going nowhere, I'm out ... Well that's mature. 
Thanks! I was expecting a constructive answer like yours. The thing is, I need a job... And I lack a lot of knowledge and confidence
You're absolutely right - I just expect that, on average, it will have fairly low adoption until filter/map/reduce-type operations are chainable in the standard library. This isn't a reflection of the implementation, but mostly because searching Composer/Packagist is awful. php.net is the top hit for queries like "array filter php". In fact, the next time I have to do array composition work, I'll probably use your library now that I know about it! As you say it's a little syntactically awkward compared to more FP-friendly languages, but that's just the nature of PHP arrays not having object operators. Of course, RFCs that try to address a large swath of these problems at once tend to fail (more opportunity for arguing and politicking :( ), so it's still very beneficial to pass something that *needs* to be done natively.
FYI Python, Ruby, Java and Rust - all of them - accept duplicate values in their Set implementation and discard them without throwing an error (the `add` function may return false or equivalent to let you know that nothing has been added). It makes sense. It should not be the caller's responsibility to ensure no duplicates. The element uniqueness is a feature of the Set, not of the code using it.
I *strongly* suggest you consider renaming things away from cryptographic terminology and towards stuff that's more newbie-friendly before giving it the 1.0. Stuff like symmetric vs asymmetric encryption will require most people to, at best, look up which one is which every time. This is a criticism I have with nearly every library out there (and cryptography in general). While we'd all like to think that developers will do their research and use what's appropriate, all of computer security history has told us this is very much not the case. People can't even get public vs private keys correct, let alone a/symmetric encryption modes. In terms of features, I think it's mostly there. The things that are at least non-obvious to me are key storage and rotation. Both of them are really damn hard to get right. You do have this little tidbit: $stored_key = \Sodium\bin2hex( $encryption_key-&gt;get() ); However saving the key itself in plaintext is kinda dodgy, and it's certainly unclear from the docs what best practices are around this - like, for example, not putting the damn thing on github. This is a mix of docs and functionality, I think. Functionally, it's not clear to me how I'd use/import a third-party's public key to verify and decrypt a message they've sent me. This may just be another documentation issue. I have plenty of other documentation-related feedback, but seeing as you said you're working on it and asking for use-case feedback, I'll hold off unless you ask more :) On an implementation note, I'd consider masking the internal values for your `Key` classes to avoid accidentally dumping them in a stack trace. Something like [PhutilOpaqueEnvelope](https://secure.phabricator.com/book/libphutil/class/PhutilOpaqueEnvelope/) gets this done nicely. Huge props for making it appear to be pretty damn near zero-configuration though. Having spent years working in a PCI-DSS level 1 environment, it looks like this covers the majority of the use cases well. Overall, it looks well thought out and comprehensive (although, between GPLv3 and the requirement to install an extension, probably would not work for my typical needs)
I'd definitely suggest doing so. git submodules always felt very awkward to me, and really end up being a last-resort for situations where there's not a better submodule management system (e.g. my dotfiles with a bunch of vim plugins) If you're already using composer for some stuff, there's basically no reason not to use it to manage your internal libs/submodules. Your code and deployment are both simpler (single autoloader, fewer setup steps, etc). I wouldn't make the conversion priority number 1 when migrating SCM (i.e. it shouldn't be a blocking issue for converting), but I'd at the very least do all *new* features as composer-friendly libraries.
Some of your projects are really interesting, but the documentation seems a bit lackluster, for example https://github.com/FlameCore/Synchronizer This gives me no info at all on how to use it, neither does your concrete implementation https://github.com/FlameCore/DatabaseSynchronizer I am actually seriously interested in your DatabaseSynchronizer project, but i have no clue what it does nor how to use it..
5.6 will be supported for quite some time. When you've got some time to breathe, maybe check out the book [Modernizing Legacy Applications In PHP](https://leanpub.com/mlaphp).
I'm sure whoever wrote this is far more competent than me but I'm sure you can do a lot of this using native PHP. 
&gt; If I'm hiring for a high-mid to senior position I need to see a passion for your craft. I read that as, "You want someone who works overtime for free because they cannot stop thinking about things."
Eh, how it's structured is just semantics. I don't much like the way they broke it apart either, but all the code is easy to understand which is way more important.
So its a library of code to demonstrate what php can do natively? 
Thanks everyone for all the suggestions, I've started tackling JavaScript! 
I do not agree that shying away from the words symmetric and assymetric are valid complaints to make. While certainly you have experience to back up your claims, "symmetric or assymetric" is really the basics of the basics of doing anything, I consider it hard to belive that it requires "most people to, at best, look up which one is which every time". Seriously, how hard can it be to remember symmetric and assymetric? One is one-way, the other is two-ways. Honestly I think the library author's done an excellent job of generalising the terms used e.g. Key::generate(Key::CRYPTO_SECRET_KEY | Key::AUTHENTICATION);
&gt; benchmarking of those little pieces of PHP code which are doing the same thing, but each one of them is doing it in slightly different way than the other I thought about building a benchmark the other day that would do this for me. I had created about 4 ways to do this one problem that is a critical piece of code that will be used every request. Well looks like I don't need to spend time on that, I will instead scrutinize and survey phpcb in the morning! Now there are other profiling options that I could go with but I never really felt like using them until this submission.
Thanks so much for the info
I'm in the process of building an automotive inventory system using Amazon CloudSearch. So far it's proving to be fast but simple technology, but once you want to go past 10,000 records in a result set there's a few things you need to account for.
Definitely learn Javascript. Put your effort into learning PHP/OOP. That knowledge is applicable to everything. If you learn a certain framework, your knowledge will be very specific. Using one for the HTTP glue is ok though, but it should not have to do anything with your actual application. Use libraries for that (you are using composer, right?). Make sure you really understand dependency injection. Stay away from service locators that a lot of frameworks use. [This tutorial helped me a lot](https://github.com/PatrickLouys/no-framework-tutorial/blob/master/README.md). [I can also recommend these resources.](http://stackoverflow.com/a/16356866)
I want to see the exact code you wrote. This a lot of the time is ignored by applicants. Some git repo is the easiest for me to inspect, and someone who fixes bugs in other peoples projects I can be assured they can fix problems in mine. I don't care much about stackoverflow. Whether or not you can answer even a very difficult question matters little in regards to how well you actually code. By that I mean, able to architect systems that by design prevent bugs, misuse, and are reasonable to read and understand. What I'd like to see from each candidate: * A full project you have written. Easiest way to determine if you are competent. * A list of projects you've worked on, what specific technical problems you encountered and how you solved them. * Evidence you aren't a slacker or a massive cock. This is hard to prove, but a series of completed projects with others and/or constant git stream is good indicator. * Knowledge of system. If you can't tell me how to set up a web server is how the fuck are you going to debug some software that intermittently fucks up without any error log. You wont be able to, unless you rush your ass to stackoverflow and let actual developers solve it for you. Great 1 day delay on something someone should be able to debug in an hour. * Solid knowledge of more than just php. Knowing just one language is a nearly sure sign of incompetency. * Knowledge of tools. If you cant use git (by this I mean using branches, merging, doing reasonable commits) I think you are a fraud. If you cant use composer or debug its errors, likewise. * Friendliness. Too many people never say: "hey how's it going?" when they haven't heard from you in a day or two. Being able to have some sort of social relationship is good. People who don't do this almost always waste a ton of time on trying to fix some issue without talking about it. * Professionalism. This is (usually) past hire but still important. Why did you not commit for a day at all and not say any reason why. Look directly above, friendliness and professionalism go a long way. Even if it is an at home test, saying: "ok, got X and Y completed, just working on last part now" is better than silence. * A lot of "pro" devs like to sprinkle retarded design patterns and put everything under 5 layers of abstraction. These people are worse than people who have no clue what they are doing. Keep your shit simple. Nothing screams absolute shit like some convoluted class hierarchy that could be solved with a few methods. It isn't impressive that you need that much abstraction. So in a nutshell: clean, simple, easy to read code written by developers who have a proven track record, who aren't limited to only php, that know how to use their computer and tools, and whom are pleasant to speak to. 
ITT: people who haven't actually read the project page's description of the project. • it handles more than just HTTP/HTTPS (ex. Web sockets) • aligns with PSR7 • has some friendly methods that aren't available in PHP
I'm sure you could do all of it in native PHP, mainly because it's all written in native PHP (Is there non-native PHP?). By why would you want to? With PSR4, you are only going to load the files you need so all of those extra files really aren't doing anything when they aren't being used.
there's no php library that exists that you can't do without that library.. 
&gt; I just released a tiny light-weight library for speed benchmarking of those little pieces of PHP code which are doing the same thing, but each one of them is doing it in slightly different way than the other. I'll just say: if they do the same thing, it technically means you don't have to decide which way to go. :-) Put it in a function with a stable API and decide later when it becomes a problem. Of course, when "later" comes, your tool can be quite handy. Some tips: 1. When you do the inner for() loop, it's faster to loop in reverse like this: for ($i = $count; $i--;). A micro-optimization for a micro-benchmark. Optimizationception. 2. You should do an "empty run" on the loop, while calling an empty closure, and save the time it takes, then subtract it from the user supplied closure run time. This way you don't end up counting the time for the actual loop, and calling the closure (which distorts the results). With number 2, you should do this at the time the other closures are executed on user's machine, don't optimize it as a constant. :-)
I'm the author of the library and I understand where your comment come from because I used to think like that too. If by native you mean `parse_url`, `parse_str` and `http_build_query` then you should read the documentation about these `native` functions on http://php.net. Here's the TL;DR: - `parse_url` **is a URI parser not a URI validator**. Since the main algo pre-date RFC3986 it does not parse correctly all URI: https://3v4l.org/KeUGe and definitely does not validate the result. A parsable string does not equal to it being a valid URI!! - `parse_str` modifies the query string by design to comply with PHP's variable syntax (ie.: converts `.` in query string key into `_`) https://3v4l.org/cEulL - `http_build_query` assumes your query string is an associative array even when it's not (ie.: adds numerical indexes to the generated query string even if you did not want them) http://url.thephpleague.com/4.0/services/parser-query/ 
Have you seen http://smimp.org? I'm going to be working on this in January if nobody beats me to it.
&gt; Optimizationception :D ..nice, thank you for the tip! About that empty run - that's probably a good idea, and it somehow occured to me, too. I'll consider doing it this way. Thanks :)
&gt; The documentation is unfinished to be sure, but I can't stop people from choosing to do foolish things if they really want to. Hah, no. Of course not. I'd just suggest adding a big fat red warning about the importance of decent key storage, and maybe a link to a best practices article. That particular problem will never be solved by a library on its own (if only)
What description are you talking about? The [introduction](http://url.thephpleague.com/) has very little information on it. What you wrote should really be at the top of the project page's description. Even with that, I *still* don't really know what it does. I think it's also confusing that the page title says "URL - URL manipulation made easy in PHP" (repeated later on), but the term "URI" is used as well.
Also the best torrent client for winblows..
Can you give us some information about the differences between Halite and Defuse ( https://github.com/defuse/php-encryption ) You have recommended defuse in the past, and you are listed as one of the Authors of the project, for someone who didn't use either one of both, what are the main differences?
Oh. Well. You can just use `Symmetric::encrypt()` and `Symmetric::decrypt()` to facilitate encrypting arbitrary string data; be it email addresses or anything else.
I'm still on the fence. On one hand I can see how templating engines might make templates look more concise, on the other hand I had so many burned hours having to step through some obscure smarty2 routine to find out why my template wasn't displayed at all, only to find out that someone saved it in an incorrect character encoding... My feeling is that templating engines add a whole big another layer without actually giving an equally big amount of easing things up.
Well, if it stands against pen testing, is easy to maintain and works well, it can't be complete bullshit from the get go?
I created a small lib with an array wrapper and an Object-to-Value map - just in case somebody is interested https://github.com/cundd/ArrayObject
I think the best opinion for key management is to offer some sort of "keytool" which will be able to create proper keys and save them to, say, a file as a serialized array. Then a small component to read from that file and feed the keys to the underlying crypto routines. I have done this with [TCrypto](https://github.com/timoh6/TCrypto) and it seems a reasonable "self-contained" approach (in the realm without external containers or encryption devices or so). Allows easy key rotation, no fear of weak user supplied keys etc.
aye thats more or less what i do at the moment, just without any salt per row or anything, so there might be more secure ways to do it than what i do at the moment :)
Didn't know about Phabricator. Looks interesting, I'll test it once I'm back home.
Its a nice piece of software, but I'm more familiar with the Agile style of development (even as a sole developer), which it doesn't really support the workflow of.
I've updated the package documentation to clarify the words used and why they are used. - http://url.thephpleague.com/ - http://url.thephpleague.com/4.0/definitions/
As far as I know, reddit use this system to do what OP says &gt; &lt;input type="hidden" name="thing_id" value="t1_cvcdjt9"&gt; where t1 I believe is tier1 comment and the id is after the low bar "cvdjt9"
Yeah, I'd prefer a daily digest of current RFCs and their voting status.
Looks like hell.. a lot like the lolz in the OP. It was cleaned up a couple years ago at least security wise. Native mysql were switched to PDO and prepared statements. 
The other comments in this thread are bizarre. "Too many files" "Too complicated" Wha? Really? The code is clean, well documented, well tested, and looks like it does exactly what it claims to do. I think the people critical of it simply don't understand the problem it's set out to solve. This is a good looking package /u/nyamsprod , good work! Carbon has too many files! Just use DateTime! I clearly need my coffee this AM. I'm far too cranky to be on Reddit.
The reason why companies want to see participation (and it doesn't mean tons of after-hours participation) is the following: * Do you tinker or maintain projects on the side, no matter how trivial or unpopular or small? * Do you use open source projects and contrib/commit back to them based on findings with work you are doing? * Do you have a curious or ambitious nature to learn? These are a few generalized points as to why it is being asked. It helps us to see: * Your level of experience, AWAY from a resume * How you approach problems If I can't view code or projects someone has worked on, I don't even want to see the resume. I want to see actual proof you can do the job and are experienced. Almost any developer with passion and a love of this craft I have came across has always had GitHub or scripts and code ready to share, not because it was "I used to do this before I quit" but because they think its interesting and cool. But I totally get and have seen the other side where you filter through developers just looking for a paycheck. If you're hiring a mid level developer, we're going to want to see something that shows experience, quality, and then if you're a good fit. It isn't an immediate disqualification, but it makes it super hard to even get to know the applicant even post interview if we have nothing to see from them. *What* do you do, what are you like, _who_ are you? Have you written any code, if so what, or is the resume just fluff? Social media interaction is a non-point and I can't believe anyone would care about that. &gt; However, when it comes to those of us who want families or have interests outside of programming, what then? Am I going to have my resume thrown in the trash because I enjoy having a beer with my Dad, hanging out with my wife, or playing catch in my backyard with my 3 year old twins? Fairly straw man point there... I do all of those things (I don't have kids though but I have nephews) and that is largely an issue with time management, not specific to "bro do you even code at night" sort of mentality. This sort of statement is applicable to any career, not just programming. It's all in how you manage time every day no matter what you do.
&gt; - Uses MySQL with no option of a different database (I prefer PostgreSQL) &gt; - No foreign keys in the database I'm not sure why you would care about the internal implementation of the tool?
Yes it does. Agile has nothing to do with the tools you use. Also Agile isn't a single way of doing this but an idea/principal. Scrum is an Agile framework. XP is another Agile method. Neither of these fundamentally rely on you having a specific set of tools.
Because she/he wants to sound really smart. 
&gt;Yes that's right, however I was not referring to single iteration if MD5 (you can stretch just plain MD5 scheme as much as you like, just like you can adjust bcrypt cost). At that point it's debatable whether you're really even using MD5. Not to mention the number of developers who could do stretching correctly is tiny compared to the number who would try. The most common method I've seen is doing multiple MD5 rounds which doesn't work. A GPU can outperform your server's CPU by a factor of thousands. A work factor of 100ms on your site is going to be nothing for it. &gt;There has been such stretched MD5 (or SHA if you like) schemes since 20 years ago and while they are not even close as efficient as bcrypt, they are still not "broken". I assume you're referring to PHPass. The fact it's holding onto PHP 3 compatibility should give any developer second thoughts.
I would not put the foreign key in the form at all.
You might need my [patched phpunit](https://github.com/sebastianbergmann/phpunit/pull/1795) for writing the unit test.
Hah, my first thought was *Damn you!* I started working on something very similar about 2 weeks ago. I like your implementation: it's straight-forward and easy to use. Mine is over-engineered in comparison, but that's because I tried to practice [object calisthenics](http://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf) and have more features. e.g. running tests for at least one second to get stable measurements. If you're interested I'll clean it up and put it on Github. Maybe we can join forces :)
I usually adhere to RESTful url's so in this example to create a comment for a post i would send a POST http request to /posts/{postId}/comments. 
Why would foreign keys in the database matter? Performance wise it's actually a benefit, less writes and CPU checks.
Actually we already [have a facility](http://php.net/manual/en/function.assert.php) for this kind of errors, without having to get cheeky. BTW, this IdiotException creates a constant called MESSAGE_SUFFIX but reads a constant called MESSAGE_PREFIX. Will this exception throw an exception if you run it? InceptionException?
No issue here. Doctrine does not assume an HTTP request context. I can confirm this as I am a contributor to the Doctrine project. I think what you are referring to is the identity map which is maintained in memory. In-between each event being processed in the worker I clear the identity map.
Newb here. RFC is a request for change?
Agreed. I feel sad about OP though, what an arrogant and naive attitude. When will people realize that you should review your colleagues code as if you were reviewing your own code, 6 months in the future.
That part wouldn't matter at all to the user, I was referring more to the fact that he wanted it to be able to use Postgres. But I'm just guessing really.
I'm looking for simple one with design like this or template like this. Thank you
It mostly depends if you want to spend most of your time maintaining infrastructure or working on your product. Github and Bitbucket are awesome tools which you have to spend 0 maintenance on. Phabricator / Gitlab self-hosted / Redmine / Trac / etc. all takes time to maintain. Let say it costs you ~30$ an hour to maintain these tools then spending more than 3 hours in a year pretty much makes github / bitbucket free. Same goes with continuous integration ( Travis, CircleCI, etc. ) EDIT: When evaluating tools, always include your hourly wage in the total cost. EDIT2: Quick example: Gmail for business = ~5$/month Github Micro = ~7$/month ( for private repos ) CircleCI = Free for 1 concurrent build If your hourly wage is more than 12$ an hour and you spend 1 hour per month on maintenance those services are cheaper. 
This isn't the subreddit for generic web development questions. You'll need to customize an existing off the shelf solution or write your own.
I agree with this. Encrypting the data, without logically protecting the operation, is just a variation of security through obscurity.
I understand what you are looking for, but you wont find that. Maybe with a hosted solution you will find a *similar* template, but you wont find the exact one. Shopify has a hosted solution that comes with templates, so you may want to check them out. 
I tried Phabricator out a few months ago, on quite a large SVN repo (to me - 50,000 revisions). * There are quite a few different components - so it's somewhat more complex than just having svn+trac somewhere (what I'm used to). You probably need to spend most of a day customising/setting up the various components and getting things "how you want it". * Sync with/to a remote SVN repo took a long time and it seemed quite resource (I/O) intensive. * Install was actually quite easy - the docs were easy to follow and there weren't that many steps. * I tried rsync'ing the svn repo so it was local, but this didn't seem to work very well (I don't remember why) Boss then installed gitlab somewhere; probably from a docker container. It seems better/as good for what we need ... so Phabricator was rm'ed.
I recommend http://www.amazon.de/Working-Effectively-Legacy-Robert-Martin/dp/0131177052 It has one chapter that specifically addresses dealing with monster methods. Also, it contains lots of useful dependency breaking techniques which will help you to get the code in a better shape over time without adding too much overhead to your regular development. Legacy suffering high-five ;) 
I like it. You could add a few of these benchmarks to see if the results are consistent: http://www.phpbench.com/ Also, I see you're using call_user_func. Have you benchmarked that vs using a variable function? I think you could reduce some overhead in the profiling by doing that. EDIT: I'm not sure I understand (or like) you scoring. For example, please explain the percentages here: http://i.imgur.com/untiHaJ.png They are basically tied, but with the scoring it seems they're vastly different. I would prefer to see scoring like 100%, 103%, and 104%. This way you get a relative sense of how they rank compared to the best time, instead of a percentage rank from 100% to 0% like a grading curve. I also think the "percentage of total" is surpluses, and can be removed because it really doesn't add anything. You should also use number_format instead of round so the decimal zeroes don't get truncated.
If it's an inside joke, why post it on reddit then? Or only funny within the context of a particular piece of code of a particular team? 
I think this article is conflating APIs with DSLs. A DSL is something that has its own syntax, often in the form of strings or annotations. A Laravel DSL for route handling would be something like `'Controller@method'`, while the Symfony's equivalent is `'AppBundle:Blog:show'` Doctrine has a DSL called DQL (Doctrine Query Language): http://doctrine-orm.readthedocs.org/en/latest/reference/dql-doctrine-query-language.html
I get where you're coming from. Obviously this example was a part of an API. But I was trying to focus more on the process of abstracting the syntax out into its own style. I'll try and update it to include some more examples :)
Clearing items at some point is managing state. Since there is state to manage the app is not stateless
Foreign keys have multiple advantages, such as onDelete behaviour. Meaning, if sometimes you will remove a type all cars can be deleted too, or changed, or whatever. Also, I think you are limiting yourself. I know that you said, it won't happen, but with a table car_type you can assign multiple types to a car and if you - at some point - have a frontend, you can't just add another type, because you have to do it inside the code. If you need more pros and cons of using foreign keys, I recommend this popular stackoverflow question http://stackoverflow.com/questions/83147/whats-wrong-with-foreign-keys
What if you want more data? E.g. on a site I worked on, we wanted 4x4 displayed as SUV - I added a display_name column to the table and all was good. In your example you can't do that. Also, if you want new body styles (coupe, sedan, crossover, limousine, van etc) you'll need to change your code, rather than simply add a row to your DB. We do your style for fuel type however (petrol, diesel, hybrid, electric).
What kind of image was it? PNG? Adobe is really picky with some image formats.
Well, of course we can't make these things 100% foolproof - there will always be that special person who refuses to learn. While if you were arguing your arguments on the mcrypt extension I would agree, this library looks decent.
Yes, your second example is better than mine. It's like /u/dwalker109 said, it's best used for internal object states. 
I realize that, it's just that I don't want/need the hassle of an extra table. Thanks for the link, interesting read. 
That depends. Do you?
I'm just saying there's further room for improvement IMO, not that it's seriously flawed.
Not php but vb6. The transition from xp to Windows 7 they changed the data access tools to so.ething called back compatability or something along those lines. Best part is it is not compatible in Windows xp. I have tons more but that's 1 of the worst.
I'm not sure why you would use the stretching example I pointed out as wrong. You would literally need to do over 2 million rounds of MD5 to have the strength of bcrypt.
Not yet, but it's the stuff of programming nightmares. I'm assuming here, of course, that project A depends on package B and package C, and both packages depend on different, backwards-incompatible versions of package C.
Any WordPress project using more that 1 external plugin typically tries to load 20 jQuery versions. The only way to "fix" it is loading any of them all and find one that's compatible.
As far as I know, this is exactly the definition of dependency hell. And no, composer does not behave like it should, or at least it didnt back when I tested this out some time ago. But even if the dependency manager notices this, you're still in a though spot. How would you solve that, without touching the packages code itself?
Do you want us to read your mind? You didn't post any questions. 
That example was just something that could be in real use, 2^18 rounds of MD5 takes approx same than bcrypt with cost of 14 (on PHP7 inside VirtualBox in one server), ~100 ms. As said, bcrypt is a lot stronger, but it doesn't make MD5 based scheme broken (just weaker). After all, it boils down to the password quality. A quality passphrase will be just fine even on plain non-stretched (and non-salted) MD5 "scheme": md5(pass). But on the other hand, no matter what algorithm you use (say, bcrypt with cost of 14) is going to save passwords like "12345".
Have you tried using Mocks? In order to write a acceptable unit test, you should just mock the method if it just a part of the crm. Best would be to just test your own code. If the crm is untested, well.. create a test suite separately. Now you need to dig into the software to understand how its working. 