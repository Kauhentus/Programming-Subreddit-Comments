Currently we use Gitolite and Fabric. We use Fabric to checkout timestamped releases. Each new release is automatically used for preprod. When we've tested it and made sure it worked, we use the release for prod. If the release has bugs, we can rollback to the previous release. (Still with Fabric.) 
I swear that me and this guy just happen to have the same name: [@thinkvitamin](https://twitter.com/thinkvitamin) ;-) but look at the tweets "he" sent to people to see which programmers and bloggers are worth following. offhand I could tell you that Chris Coyier, David Walsh, and Nick Petit are worth following. 
OP: here's what I did with Fabric: [Fabfile for WordPress](https://github.com/YellowSharkMT/fabfile-for-wordpress). Amateur stuff, to be sure, but I use it every day, for 3 different clients.
You probably want to copy the site and use a symlink to switch over to latest release. Otherwise requests will come in for half updated site. Also allows trivial roll back. I think this works better than git flow for web http://scottchacon.com/2011/08/31/github-flow.html
Rocketeer: https://github.com/Anahkiasen/rocketeer Amazingly Simply
Well the API is locked down with oauth so they can't do much unless they have a valid access token, or a valid client id and secret AND a username and password to get in. Out DB seeding puts a client and set of users in, one of which has a known access token and behat uses that. Sounds complex, but isn't really. Otherwise we'd use HTTP Basic and hardcode the username/passwords in somehow.
Absolutely. This is a fairly new workflow as we've only recently got in extra devs and got things working with Jenkins. While we're a small team and im the merge-master it's not as horrible as it will be when we're bigger. We COULD open it up so that Jenkins fires off of all branches, but I don't want to have a millions of builds going off, and for now people know they should be running their behat tests before they commit anyway. If you're using open code, then integrating Travis-CI is an awesome way to get green-lights right in your Pull Request. We use this for PyroCMS and its lovely.
I'm struggling mentally to make out your point. Unit tests apply to code, functional tests apply to the system as a whole (or some subset of the system). No-one is saying stop at unit testing, but from the OP's description it seems fairly obvious that unit testing is what is required: he wants to test that calculations are being performed correctly. 
It seems to me that `array_search` is what you're looking for: $array = array('a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3); //get the value paired with 'b' echo $array['b']; // echoes 2 //get the value paired with 3 echo array_search(3, $array); //echoes c If you want to be able to get the paired value without knowing which side of the pair it's on, you could write a function to do the lookup (thus saving you the memory of storing each pair twice): function pairLookup($search, &amp;$array) { if(array_key_exists($search, $array)){ return $array[$search]; } else { return array_search($search, $array); } } $array = array('a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3); //get the value paired with 'b' echo pairLookup($array, 'b'); // echoes 2 //get the value paired with 3 echo pairLookup($array, 3); //echoes c
Why not just return $array['b']?:array_search('b',$array);
Because this: php &gt; $array = [1 =&gt; 'a', 2 =&gt; 'b']; php &gt; echo $array['b']?:array_search('b',$array); PHP Notice: Undefined index: b in php shell code on line 1 Notice: Undefined index: b in php shell code on line 1
Because what if your array is: $array = ('a' =&gt; 1, 'b' =&gt; 0, 'c' =&gt; -1); Of course, the if statement above could be written using the ternary operator, but your ultra-short version doesn't account for values in the array the evaluate to `false`
Well, that's what @ is for. :)
I think you're looking for isset($array['b'])...
Start by forgetting that you've ever heard the term "unit test" and concentrate on the problem at hand. 1. The calculations are done with PHP code. 2. The data to drive the calculations are stored in a database. 3. Presumably there is more data in [2] than can be easily recoded in a test framework. How would you test for... * All calculations complete without throwing an exception or entering an infinite loop * Performance is acceptable for all calculations * All calculations for version 2 of the application return the same results as version 1 A database-driven test can answer these questions and more. 
I generally prefer array_key_exists('b', $array) cause there is some weird edgecase with isset() I can't quite recall.
Great idea. I'm not too wild about the syntax though. Ellipsis has a specific meaning in the programming world. Using it as an operator for expanding an array into an argument list is confusing. I would do something like: func( &lt;= $args =&gt; ); It's a bit more evocative visually.
That is definitely not what `@` is for. 
If it's set to null, which is why I generally do not use array_key_exists and try not to use it. 
You could still post '/../../../' if you knew the current working directory or post ';exec(some command);' and it'd also work. It's never a good idea to use unsanitized request vars in a path. Edit: if you absolutely must, use require rather than include so a fatal error is thrown and execution stops. Include only throws a warning and continues.
while I realize that, if I posted '/../../../', the include would get test_/../../../ which is an invalid unix path, and it would fail to include anything. Also, you couldn't just put '; command();. Post is a string, and unless using eval(), strings are not processed, as far as I know.
never acces $_VARs with a lot of caution, in this case i would run at least a regexp on them dropping all chars that are not a-z_-0-9 
Use the form input to choose from a hard-coded, safe list of files: &lt;? define('DOCUMENT_ROOT', '/home/foo/bar/templates/'); // ... switch ($_POST['test']) { case 'news': require(DOCUMENT_ROOT . 'news.php'); break; case 'press': require(DOCUMENT_ROOT . 'press.php'); break; default: require(DOCUMENT_ROOT . 'unknown.php'); } ?&gt;
I think it would be ok, but there's probably some case where it would not be. In situations like this, I'd rather scan the directory for valid targets, make a list, and then see if the POST param matches any of those. If so, use the value *I* generated as the include. This way there's just no chance they'll be worming their way to an unexpected file.
Ah my mistake, I'm on mobile and I thought you were evaling the include. Regardless of that there are always going to be issues with it being unsanitized. It might not work currently, but in the future what happens if someone makes a directory called 'test_old' inside that directory to back up old files or something? Then there is a valid route to backtrack from. Also, the include function is open to many vulnerabilities that people have found and more will be found in future, the best thing to do is sanitize the input then use it. This future proofs your code. https://www.owasp.org/index.php/Top_10_2007-Malicious_File_Execution
I understand how to make it safe, I'm asking specifically how to hack this, since the 'test_' string before the file variable seems to break any sort of exploit I throw at it, if it was just $var.".php", it would be incredibly unsafe. Thanks for the comment!
**When ( in | not in) doubt, profile.** Strictly speaking, if you have each value pair and the array size is less than big/2, storing them doubly and using array lookups is fastest. This is because array lookups, while technically O(n), [approach O(1)](http://stackoverflow.com/questions/2473989/list-of-big-o-for-php-functions). If you expect memory limitations to rule this out or other issues to push you past O(n), you could always fake links by using the positional relationship of the pairs*: $arr = array(a,1,b,2,c,3,d,4,e,5); #numerically-indexed function getMatch(&amp;$arr,$key){ #O(n) $needle = array_search($key, $arr); if($needle === false){return false;} return $arr[$needle + (($needle%2)*-2) + 1]; #right for even, left for odd, 0 % 2 acts even } getMatch($arr,'a'); #1 getMatch($arr,3); #c *beware of functions that bork your indices In general, math, boolean operations and hash lookups are very fast, and built-in functions are faster than equivalent user functions. Use array_merge, array_filter and array_map, but prefer direct assignment to array flip (if you are the one creating the array in the first place). The more often you have to lookup values, the more time you will save by double-storing the values. edits: punctuation, profiling 
Thanks, i do know security pretty well, I just thought of this offhand, and have yet to be able to break it in my sandbox, since anything but a single file string seems to break, since 'test_' is added in front of everything. Attempted changing paths using /../../ would end up 'test_/../../' and fail, same thing with a url. Thanks for the comment.
This is usually how I do it, I was just asking more of a theoretical questions, vs an actual implementation. How would someone get around the 'test_' string being added to the front of anything, nullifying URLs and Directory changes? 'test_http://web.com/evil.php' is invalid test_/../../' is invalid
I actually never us variables in includes in production code, this is just a curiosity I thought of. In all honesty though, if someone was scatterbrained enough to create a folder with the same title as include files in the same directory, they kinda deserve to be hacked.
 php &gt; $file = chr(8).chr(8).chr(8).chr(8).chr(8).'other_file'; php &gt; echo 'test_' . $file . '.php' . "\n"; other_file.php Now, I don't know how you'd sneak a backspace character into the post request, but...
That actually may be close to the answer I'm looking for, never though of using backspace ascii for deleting beforehand text, Thanks for the idea! 
sure, just post anything that starts with a /../ in test and you'Re in the same dir again i.e. i created 2 scripts test.php &lt;? include 'test_' . $_GET['test'] . '.php'; test2.php &lt;? echo 'gotcha' now just call test.php with ?test=/../test2
This might make a good starting point. Beware that this doesn't handle all the fun cases like key/value space overlap or null keys/values. &lt;?php class TwoWayArray implements ArrayAccess { private $_keys = array(); private $_values = array(); public function __set($name, $value) { $this-&gt;_keys[$name] = $value; $this-&gt;_values[$value] = $name; } public function __get($name) { if (isset($this-&gt;_keys[$name])) { return $this-&gt;_keys[$name]; } if (isset($this-&gt;_values[$name])) { return $this-&gt;_values[$name]; } return NULL; } public function __isset($name) { return $this-&gt;__get($name) != NULL; } public function __unset($name) { unset($this-&gt;_keys[$name]); unset($this-&gt;_values[$name]); } /* * ArrayAccess implementation */ public function offsetSet($offset, $value) { $this-&gt;__set($offset, $value); } public function offsetExists($offset) { return $this-&gt;__isset($offset); } public function offsetUnset($offset) { $this-&gt;__unset($offset); } public function offsetGet($offset) { return $this-&gt;__get($offset); } }
Forms are not really hard coded these days. Just open up firebug or chrome's developer tools, and you can post whatever you want
You ask a really good question, it's always good to want to know why security practices are in place. I looked around and it seems you are correct, there aren't many ways to exploit your example. The one thing that might happen is if the prefix happens to be something usable. For example, prefixing with php would be bad, because then a base64 attack could be used with a poison null byte. Something like: ?file=%3A%2F%2Finput%00 Then use the post body of your request for the actual payload, and bam, you can execute arbitrary code. It's usually a good idea not to risk using a prefix that might be usable in another attack, hence why the entire practice is considered unsafe.
Thanks! Right now I'm working for a side project using Laravel and I will sure use this :)
Git makes me cry. My brain does not get it
While in practice it's /okay/, it's wrong in principle. First, it uses untreated user input, and you should always have an air-gap between what users give you and what your script executes. shaunc's suggestion of running against a whitelist of approved files mitigates this. You know what files are okay to run, so make sure that nothing else gets run. Alternatively, you could call `realpath()` on the filename before `include`ing it, ensuring first that `strpos($file, __DIR__) === 0`, so that no matter what happens, at least the resulting file is not outside of your project's directory. But then… Secondly, it establishes a precedent for a code structure that could be repeated elsewhere in your code without the prefix or suffix, leading to disaster. What if you refactored later to make `'test_'` into `$prefix` and `'.php'` into `$suffix`, reasonable changes that would make your include more reusable and flexible, and then a few months down the line, you call it from elsewhere with a blank prefix or suffix? Code defensively. Finally it's inflexible and implies a poor design: * It ties your code's behaviour to both the file system and the `$_POST` superglobal, which makes it less portable and testable. * It explicitly sets your code and content's file structure. What if you moved your `test_xx.php` files or `whatever.php`? * If you're using the `include` to import procedural code to handle specific input, your code's probably too complex and needs to be abstracted or redesigned. * If you're using it to load functions or classes specific to a form variation, then you should be using autoloading instead. The only `include` your app should need (and thus `require`, not `include`) is the one that loads your autoloader. * If you're loading code to display a response specific to a form variation, then you might be better off redirecting instead, so that users don't double-submit upon reload. 
(and yes, it's *entirely* possible I'm reading way too much into a single line of code :)
No, the backspace character doesn't delete anything from the string, it just causes it to look for a filename containing that character.
What does that have to do with anything?
This "bug" was an example, merely a pretext to explain how MetaModel and MetaConsole work. The goal of this project is not to provide a debugger, but a tool to traverse object graphs, data and maybe perform occasional maintenance tasks. This is a tool, use it however you want, I see plenty of usages for it, I'll present some of them soon.
It seems that my firefox strips the %08, but using telnet as a HTTP client does not. In my include.php file: &lt;?php $include = "test_".$_GET['test'].".php"; var_dump($include); include($include); Running the following in telnet: GET /include.php?test=%08%08%08%08%08unsafe Gives me this var_dump: string 'unsafe.php' (length=20) Inclusion doesn't work, file_exists returns false, and realpath returns an empty string. Remote inclusion using the same method also doesn't work. It seems that /u/crackanape was right, it looks for a filename containing that character.
php has sooo many array_* functions. you can never be sure that you know even half of them.
The switch is hard coded. Modifying the form to submit non-existent value would either do nothing, or in the examples case a default and safe operation.
Currenly Apache, APC, MySQL.
You could always just set `allow_url_include = off` in the PHP.ini if you have access. This would be the better way and wouldn't allow URLs to be used at all. http://php.net/manual/en/filesystem.configuration.php
Maybe not entirely the same, but this is how all of ZF1 was named. Dom/ Dom/Query/ Dom/Query.php Zend/Feed/ Zend/Feed.php etc 
You have misunderstood what he is saying. He is saying to check the POSTed value and ensure that it is within a limited and safe and known subset of values. If the POSTed value is 'news' a certain file is included. So in this way, if someone posts garbage, nothing happens.
I think that would stop path traversal and stuff from happening. I think remote includes can be disabled from php.ini too.
You can also look at webistrano (a new version is dedicated to GIT projects).
Reading through the comments here it does seem you have a decent grasp of basic PHP security, however... You're taking the wrong approach to this, in my opinion. If you're questioning the security of something, there is a high chance that you're already doing it wrong. Using an approach because nobody in this subreddit can suggest a way to bypass it is a bad idea. Most of the folks here, while adept developers and likely very knowledgeable in PHP are not black hat hackers. You're just adding one more potential attack vector with this approach.
Because the ternary operator [always copies the value](http://fabien.potencier.org/article/48/the-php-ternary-operator-fast-or-not) (or was this fixed yet?).
When I worked in the banking industry we did bond calculations. These are incredibly complex, especially when you factor in call schedules. Hand writing a test case for every possible combination would be impossible due to the combinatorial explosion. So instead we used our actual data as our test case. Sure there was a small chance that a new bond outside the normal parameters would be issued, but at least we knew with 100% certainty that our program worked with today's data. We also used fuzz testing. This is where you supply randomly generated values, both inside and outside the acceptable range, just to see what happened. With this we found subtle combinations of parameters that failed and were able to improve our validation accordingly. Performance, range analysis, full range, fuzz... there are far more ways to write tests then just "unit" and "functional". 
As for testing add(x,y), I don't do that anymore. My goal is to detect errors. I can detect errors in trivial functions via the tests for the more important functions that use them. I know some people try to justify their obsession with unit tests to also say they are documentation, and specification, and a debugger, and a work queue, and blah, blah, blah. But I have specialized tools for each of those, leaving my tests for actually testing.
If you want a meaningful answer, you might want to add a bit more information than that. 
I elaborated a bit, hopefully it helps :)
&gt;These are incredibly complex They don't really look it. At any rate, it's just a formula. You know what it should do, you write code to do that and you write tests to make sure it does. Using a massive data set is the equivalent of using every number to test add() and reeks of incompetence. It's like saying "well we know it adds 1 and 1 together properly, but try with 3 and 4, just in case ..." &gt;So instead we used our actual data as our test case How does that even work? The data changes, so you'd need another program to calculate what the results of your program should be - or do it by hand? It's nonsensical. &gt;We also used fuzz testing These are unit tests.
If you put them in HTML, people could just parse the HTML for the answer. It would make much more sense to put them in a database.
Thank you so much! This sounds very, very reasonable!!! Although there won't be wrong and right answers, they will be at least be able to see where the different answers would lead them, which is not desirable!
&gt; How does that even work? You start by hand checking known values to ensure a good starting point. The same thing you would have to do anyways when writing unit tests entirely by hand. This gives you your v1 calculator. When you are ready to test v2 you perform an A/B test against the same dataset, noting any differences. Said variants are hand checked to determine if v1 or v2 is correct. Since you are running against a copy of production you don't have to worry about the data changing mid-test. 
Though I'm not one to argue about definitions, most people consider fuzz testing to not be a form if unit testing because it involves randomly generated inputs. They claim that unit tests should be deterministic.
&gt;They don't really look it. How many formulas do you deal with that take 50+ parameters?
I've written an extremely detailed tutorial on "How to setup a (or multiple) server/LAMP-stack inside a virtual machine for local development with Vagrant and PuPHPet", which might be highly related to this thread here. http://www.dev-metal.com/setup-virtual-machine-multiple-vagrant-puphpet/
Database would be very reasonable. create table page ( id int unsigned, content text, ); create table option ( id int unsigned, page_id int unsigned, content text, destination_page_id int unsigned ) insert into page (id, content) values (1, 'It is dark.'), (2, 'The room lights up.'), (3, 'It is still dark. You might be eaten by a grue.'); insert into option (id, page_id, content, destination_page_id) values (1, 1, 'Turn on the lights.', 2), (2, 1, 'Cry in a corner', 3) PHP to show a page: $stmt = $db-&gt;prepare('select content from page where page_id=:page_id'); $stmt-&gt;bindParam(':page_id', $page); $stmt-&gt;execute(); $data['content'] = $stmt-&gt;fetch_column(0); $stmt = $db-&gt;prepare('select id, content from option where page_id=:page_id'); $stmt-&gt;bindParam(':page_id', $page); $stmt-&gt;execute(); $data['options'] = $stmt-&gt;fetch_all(); And then the view &lt;p&gt;&lt;?=$data['content']?&gt;&lt;/p&gt; &lt;p&gt;What do you do?&lt;/p&gt; &lt;?php foreach ($data['options'] as $option) { ?&gt; &lt;p&gt;&lt;a href="?choice=&lt;?=$option['id']?&gt;"&gt;&lt;?=$option['content']?&gt;&lt;/a&gt;&lt;/p&gt; &lt;?php } ?&gt; Then you'd check what choice they picked and direct them to the destination page. Rinse and repeat until there are no options which would be an ending. True to random internet person form, I didn't actually run any of this, but it should be good pseudo code if nothing else.
Oh wow!!!!!!! You are so priceless!!!!! Thank you!!!
I must admit I was not aware of the addition of this new function. I think it is truly useful! Do you know what the complexity of this function is? As for your addition I really find it interesting. Callables are a great idea. I hope your patch works and we will see it in a next PHP version. Cheers! 
The complexity when using callables is probably O(n). With array's its slightly more expensive, but because of the way PHP handles array's internally, its still O(n). (It's just a loop over the data once, and then a search to find your column key and index key)
[array_walk](http://ca2.php.net/array_walk) won't let me index the array the way I want it. I used to do [this](https://gist.github.com/kriswallsmith/6514704): $widgets = array_combine( array_map( function($widget) { return $widget-&gt;getId(); }, $widgets ), $widgets ); Now you can: $widgets = array_column( $widgets, null, function($widget) { return $widget-&gt;getId(); } ); **EDIT**: Had a mistake in code earlier. ~~I just realized this is actually broken in the implementation, cannot pass in null right now as second parameter~~ (fixed). (Need more testtttttsss) 
The Facebook Graph API is also a well-built API - they have tools that make it easy to debug API calls as well. 
[httpbin](http://httpbin.org/) would be good for this. It basically spits back whatever you give it. It's meant for testing HTTP clients, but it's useful if you just want to write a few requests and not worry about dealing with the OAuth dance and such. Httpbin is written in Python and [open source](https://github.com/kennethreitz/httpbin) so you can go poke around and see what the server side of things is doing as well. [Instagram](http://instagram.com/developer/) also has a nicely documented API and most of it can be used with just an API key.
&gt; You start by hand checking known values to ensure a good starting point. The same thing you would have to do anyways when writing unit tests entirely by hand. Except with unit tests you only have to do this once. Your way you need to hand check every calculation every time you run tests. That's insane! This is the exact equivalent of hand calculating x+y for whatever values happen to be in the db **every time you want to run tests**. 
What the hell can you test if your tests are not deterministic ??? If you're talking about this http://en.wikipedia.org/wiki/Fuzz_testing then sure, but this has nothing to do with testing calculations do what they are supposed to.
Looking at wikipedia it has 7.
Vagrant is also worth a look. http://www.vagrantup.com/
Or just use [Homebrew](http://brew.sh/): brew tap josegonzalez/homebrew-php brew install php55 [josegonzalez/homebrew-php](https://github.com/josegonzalez/homebrew-php) being the de facto standard repository for Homebrew PHP brews. The PHP brews were [even updated to work on Mavericks](https://github.com/josegonzalez/homebrew-php/pull/597).
Now I'm wondering if compass producers actually have testing chambers with mock northpoles to ensure the validity of their compasses...
&gt; Write an RFC if there is interest. Don't think there is a need for this, a pull-request is enough. &gt; Is this a feature you would be interested in? Absolutely **yes**.
Could you please distinctly describe the method of operation of the new function? Just because what you pass in is now a "callable", doesn't mean I have any concrete idea of what you want to do with it, what arguments it should take, what it should return, how it changes the operation of the function, new error cases, etc.
This is exactly the reason why I was against this function in the first place. It only covers one narrow case (array keys) but can be easily solved in a much more general scope using list comprehensions: // this proposal $result = array_column($records, function($record) { return $record-&gt;firstName; }); // list comprehensions $result = [foreach ($records as $record) yield $record-&gt;firstName]; // this proposal $result = array_column( $records, function($record) { return $record-&gt;firstName; }, function($record) { return $record-&gt;id; } ); // list comprehensions $result = [foreach ($records as $record) yield $record-&gt;id =&gt; $record-&gt;firstName]; This is how I'd rather solve this problem and really 95% of all array operations in general. As an added bonus, this would even work if `$records` wasn't an array at all but something like a `PDOStatement`.
I'd love to see list comprehensions come to PHP. I don't read the internals lists; is this remotely going to happen?
I feel like you'd *really* enjoy working with python.
To follow up, they never did authorise the comment.
Yea this is a million times better. Also, upgrading is as simple as brew update &amp; brew upgrade.
There is [a package](https://packagist.org/packages/dcelasun/extract_property) that works like `array_column` for an array of objects.
Might work to directly register/trigger a listener / an event directly to the instance of a certain class - but I guess it would be much help when dealing with a centralized event dispatcher. Correct me if I am wrong :)
Or just use a virtual machine...
You array_map version is exactly what I would have done. IMO `array_column` shouldn't have had the key option to begin with. It's just another case of conflating sequences with associative maps, and it's not generally as useful as a simple pluck.
Interesting, but what's the difference with array_map in the first case?
[@phpdeveloper](https://twitter.com/phpdeveloper) curates PHP related content, less overwhelming than an automated aggregator
If your calculations always do what they are supposed to then there isn't any reason to test them. We found that our calculations, when faced with garbage data (or really unusual valid data) would occasionally result in yields that were nonsensical or worse, never settle leaving the approximation engine in an infinite loop. (Bond yields can only be calculated by repeated approximation, there isn't a formula for direct calculation.) Non-deterministic fuzz testing was essential for understanding the behavior of calculations. But even when I am not dealing with 50+ parameters I find the technique to be quite valuable. If you only test the cases you thought of... well then of course your tests are going to pass. But so what? It's the cases that you didn't think of that are going to cause most of the trouble.
You aren't paying attention. Once you have a base line future tests compare the current and previous versions of the calculation. If they both return the same results, then by definition the new one is just as correct as the older, hand checked version. Really, this is a rather basic technique that you should have seen in school.
You can do similar in javascript with this converter :) http://www.jsfuck.com/
If the bond expires in 30 years and is callable every six months that adds 30 x 2 x (call date + penalty) = 120 extra parameters. Though that is a bit of an exaggeration because once the penalty hits zero you can ignore the later call dates as they will always return a yield greater than the previous one. Bond yields are always calculated for the worst non-default scenario. Of course then you have to deal with bonds whose interest rate varies with time. Or has non-standard interest payment days. And I haven't even touched on the insanity that is CMOs.
array_map won't let you change the keys (not the 1st case, but in general)
Agreed. It's a 5 minute job.
Even if you're a happy vagrant user (like myself) you want to install PHP 5.5 locally if you're using [static analysis tools](http://philsturgeon.co.uk/blog/2013/08/php-static-analysis-in-sublime-text). Even if you install it in a non-standard path alongside other PHP versions having it installed SOMEWHERE and having your IDE know about it is very useful.
VMs are epic, but if you use static analysis you want your local version to match, or your IDE/Editor is going to pitch a fit about short-array syntax, the yield keyword, litteral array dereferencing, etc.
You are right. I was waiting and trying to gauge the interest so that I could go ahead an write an RFC (if required), and it would include all the above. I will try to update the content with some good examples, but for now Nikic's comment already includes some examples.
Wow httpbin will be awesome for teaching the fundamentals, before going to consume a 'real' service, I also consider https://apigee.com/console so the students can select a service and practice before coding, thank!
Also, I would recommend using Guzzle over HTTPFul http://guzzlephp.org/
Nice! Guzzle is now part of Drupal 8 core and powers the official AWS SDK for PHP I wanted to try it before, but the PROD server I had to use had an old PHP version, but now I have flexibility with that.
[related](https://puphpet.com/)
Which is ... nice?
The [Github API](http://developer.github.com/v3/) is really cool.
maybe this belongs in /r/laravel instead?
This is more common in statically typed languages, where it's called a "bidirectional map". If you know the types of your keys and values are going to be consistent, then created something similar to what @original_evanator has done with ArrayAccess would probably be the best option. Is this definitely what you need, though? Don't be afraid to take a step back and look at your problem differently - they may be another way to tackle it that doesn't require such a structure.
laravel is a thing of the past.
Interesting that you used migrations but note views?
Curious. You know none of what you just said makes your original statement correct right? It was just you basically blowing your own trumpet on certification and experience (none of which is all that impressive in the community by the way). So, I'm not a laravel user. Tell me. Why is it a thing of the past? Edit: sorry, half asleep. I missed this: &gt; Laravel is a thing of the past &gt; Codeignitor Lol. 
I think he was trolling, dude.
I decided my array wasn't that big, so I just made a second with an array_flip. PHP has tons of features/functions that I'm learning about every day (including array_flip), so I was mostly curious if it had some sort of bidirectional data structure. The answers here helped me a lot to better understand how others would tackle the similar problem.
[**philsturgeon**](https://twitter.com/philsturgeon/status/379659737853591552) thanks for the news :)
Does anyone know of an authentication tutorial that does not lock the user database to the local Laravel database? I so often need to authenticate users against external systems (which also hold the user profiles and authentication information) but none of the tutorials I find cover this. I suspect L4 will be particularly good at this, but where do I hook into the stack?
Obviously. Python and Ruby have a lot of ex-PHP users who were lucky enough to be in a position where nobody cared what language they use, and now shit all over everyone who ever suggest that PHP might be able to get the job done. Sad. Really sad.
I feel bad how many down votes he is picking up. The scripting language is just one cog in a big machine nowadays when you're spinning up a web application. MVC, ORM, plenty of libraries and a large talent pool. Sounds perfectly reasonable to me. I don't understand why anyone would throw out the benefits of the language over some naming faux pas a decade ago. I just get tired of that being the point of argument when it comes to PHP-- it has come so far and a lot of people seem to be blind to that because *they were working in &lt;whatever stack&gt; before it was cool*. 
You might want to use interfaces to specify which behavior is passed along, instead of what type of very generic Abstract base class. Another solution would be having specific Builder classes that take a stdClass and converts them into a specific object. Such builder serve no other purpose than converting objects. I think the best solution however, is to just **be more specific**. When *you* don't even know what kind of object a method returns, then how does the next programmer know? Just name the method getPostsWithTags(). KISS. Dynamic returned generic objects that make little sense? YAGNI.
"If all you have is a hammer everything looks like a nail" Whether it's programming languages, tools, frontend libraries, operating systems, whatever... You should pick whatever suits you best for the job at hand. Like you say, /u/Iroxtion is absolutely right. 
For my 2c, as someone who dips the toe in PHP, it comes down to the idea that you don't need to know every corner of a programming language, you just need to know where to look when you are chasing some type of function. When the naming convention is all over the place it makes everything slower and more difficult and hinders production of code, and then you have deprecated functions, unsafe functions, etc. Any time I'm looking-up something it takes me half an hour or so just to read-up on all of the hints and tips and warnings and suggestions and blah blah blah that others have noted online. If PHP was a computer it'd be one that has a lot of garbage toolbars installed, a temp file of a few gigs, everything installed onto the main OS drive, and a few choice pieces of malware floating around the system. It needs a good clean-out, malware scan, and a defrag. It's mostly fine if you have no need to look-up something you are unfamiliar with, but as soon as you do you lose significant amounts of time just trying not to cut your own foot off doing something wrong. I know I'm just beating the same dead horse, but that horse had it coming.
Right. You can do literally all of the same shit in PHP/Ruby/Python/Perl. Sometimes there are better libs are doing X in a different language but SoA is a thing so just wrap that shit in a HTTP interface or background job it up and get on with your day. I use 3 of the 4 above and they're all just fine.
Or because most of us don't have anything to prove, so we don't troll around other subreddits looking for shit to complain about.
http://www.cs-cart.com/
This is the first I've even ever heard of QB. Is this sometime I should be using, or is it only beneficial in niche architectures?
I have never heard of anyone who have abandoned an entire php website to re code it in ruby... but there are plenty the other way around.
I'm with that other guy, never heard of this before. Have heard of and even tried hip hop when it was a compiler. I've also tried other php compiled things. It looks interesting and I'll definitely try it out on my CPU intensive algorithms.
Just added this to the docs: http://laravel.com/docs/extending#authentication
The de-facto options are basically it. That was the whole point of Discourse--to shake up the stagnant forum situation.
I'm not actually using this, I never use dynamically loaded includes because of the risk they pose, This was more of just a curiosity question, but I found out why I was getting different results, turns out Unix hosts will treat 'test_/../' as an invalid directory, but Linux and Windows will allow invalid names, as long as part of it could be valid. 
In production, I never use dynamic page loads, and everything is fully sanitized, serialized, and escaped before anything happens to it. I would rather not have a XSS attack on my hands.
the table can store any type of object the developer wants to create. this is why its impossible to tell. 
Unix fails the path traversal because its more strict with pathnames, but Linux and Windows will still allow an invalid path as long as part of it is valid, 'test_/../' fails in Unix, but will work on a Linux, Or Windows host.
Yeah, reverse transversal, But, turns out Unix is more strict then Linux, and Windows, and invalid paths won't work at all,
It was more of a curiosity question, I used fixed includes only, and disallow access outside of set folders. I know security, I was just curious to find how someone would get around preceeding strings, but it turns out that Unix hosts are much more strict, and fail if the path is invalid, where as windows and linux will allow 'test_/../' as a path. 
Taking sides really isn't all that stupid or toxic. taking sides drives competition. Competition is the mother of innovation. Although fanboys do suck. A fanboy is a special classification of an asshole who is so blindsided by their own love of one thing and the need for it to be better than everyone else's thing. They don't help anyone, and the worst is that most of them speculate and merely regurgitate the already inaccurate information they've been fed by their fanboy piers. I love PHP, plan and simple... I've made php my bitch. But at the same time, I know what PHP isn't the tool for the job. I've moved into C and C++ to gain more knowledge of my field, and even of PHP. If you know C you can make your PHP better (because you know how the parser/compiler works) Part of being a good and successful developer isn't just knowing what tool to use for what job, but it's also knowing how to just shut your damn mouth and USE the right tool.
Poor /u/frozenfire will have to redesign /r/php!
I agree that he should have at least mentioned array_column in the readme, but this isn't really "stealing" is it? The code is tiny and the license (MIT) allows it. And honestly, after seeing the reasons behind ircmaxell's departure, tiny forks like these are easier/better than getting upstream to modify array_column :)
vBulletin and PHPBB are still the common go-to ones, but there are a few others too: ##Open Source I use [MyBB](http://www.mybb.com/) a lot, I find it pretty nice to use, has a great administration and moderation tools. There is a sizable community and collection of plugins. It uses its own home-grown templating system for themes. [SMF](http://www.simplemachines.org/) I've used, but I'm not a huge fan, personally I find it quite a mess, themes are mostly a a few files with a bunch of mixed up PHP and HTML being called from various functions, plugins installs are just simple find/replace against the core files. ##Commercial I've not used [XenForo](http://xenforo.com/) as an admin, but I've spent some time as a member on several boards that use it and I've quite liked it. From what I hear it is a lot better built than a lot of the older PHP forum systems. There is also [IP.Board](https://www.invisionpower.com/apps/board/), but the last time I used that would've been back in high school on InvisionFree, so I have no idea of the current state of it. I do remember it being fairly nice to use though. Seems to have moved on to more of a social/community kind of platform. There isn't really anything 'special' like Discourse is, but I've been throwing the idea around in my head to start my own one with more current-day kinda of things (like Discourse tries to offer), but not sure how far down the development path I'd get before I got bored of it.
&gt; Move to MariaDB...but that just does not sound as cool or as standard One should point out that MariaDB is supposed to be a drop-in replacement for MySQL. This means you can use it without changing a line of code. &gt; Somewhere out there the Perl guys are also just waiting.... I'm generally interested why Perl is never mentioned. It's like a web holy war between PHP/Python - "PHP sucks! Python is awesome!". But I'm just sitting on the fence going "...what about those other languages?"
Dat certification though
&gt;If you know C you can make your PHP better This is very true. Conversely, PHP actually gives quite a nice intro to C-like languages, and the jump from PHP to C itself is easier than from Python or Ruby to C. Certainly something like Go is very easy to pick up if you know PHP - if you're looking for more performance and concurrency than PHP, it's a no-brainer to pick Go rather than Python or Ruby. For all its faults, PHP can be a better gateway language than those others that are very invested in their own ways of doing things. After Ruby, you only have ... well, more Ruby. 
nice
good exampkle
Sublime Text.
Hey that's great! Would there be any advice for someone who had to integrate a legacy auth system where the only thing you can do is ask it if a user is logged in and if they are what their username is?
Nope, you're good. Most recent release is 5.5 and there are a ton of servers that aren't even running that (although most are 5.0+). 
The reasons people don't like PHP extend far beyond the inconsistent naming and parameter ordering. PHP has never had any vision or strategy, nor apparently any code review once git/svn accounts were awarded. As a result, PHP has the world's worst bytecode compiler (no AST!) with inflexible syntax that only supports certain specific combinations of accessors when executing a function. And don't get me started on some of the horrible bugs and API design. EDIT: I write this as a frustrated PHP user who has been blocked from doing things by the insane parser. Also also as a frustrated internal dev who has looked at the internal code and had to fix bugs which code review could easily have caught.
I can assure you plenty have. EDIT: Like me, for example!
Python has been around for 22 years. 
Version, IMO, matters somewhat less than quality. There are an *awful* lot of terrible PHP tutorials out there promoting horrendous worst practices.
Geany!
PHPStorm. Best IDE I've used, hands down.
Member access must be overridden to provide safety ... think about it carefully, if you were allowed to pass in a reference and then manipulate that reference, what would happen !? Trouble, would happen ... You should take a look at the examples bundled with pthreads, they cover all this kind of thing in great detail ... In summary, passing some object like: &lt;?php class MyCounter extends Stackable { public $counter; public function __construct(){ $this-&gt;counter = 0; } public function run(){} public function inc(){ return ++$this-&gt;counter; } public function dec(){ return --$this-&gt;counter; } public function add($num){ return $this-&gt;counter += $num; } } ?&gt; to both threads will do the trick ...
To be fair, PHP.net's previous redesign was a bit harsh on the eyes. The current one is much better and more in-line with PHP's established brand.
Perl is just a dieing language on the whole. The things it doesn't have: evangelism, outreach, new blood, intense debates on how awesome / sucky it is. You need those for a language to survive. Of course it always takes ages for any language to actually die, but it ain't getting any better.
Cool, thanks. I'm often using SugarCRM (for my sins) as a back end, with users being registered as CRM contacts. My intention is to create a package that handles the storage abstraction layer of that. Sometimes a local user table may be needed to store additional user details (that don't need to go into the crm), and sometimes it does not. Either way, the user account with authentication functionality is on the CRM at the other end of a remote API. I have it working on L3 with a bit if a hack http://www.changeagents.org.uk/sustainability-jobs/ but want to make it more a plug in solution for L4.
So your argument is that people who are used to a language's stupidities, eccentricities, quirks, and nuances aren't all that adversely affected by said stupidities, eccentricities, quirks, and nuances. Congratulations, that means nothing. Good languages aren't defined based on what a person **experienced** with the language can do with it **in spite of its failings**. We must consider: Are the stupidities, eccentricities, quirks, and nuances of this language **at all justifiable**. For example, is there any **sane** reason why things like intval("hi")===0 // true are present in the language, rather than immediately obvious alternatives such as: intval("hi")===null // true PHP violates the principle of least surprise wantonly, and its facade of beginner-friendliness is the most dangerous and awful part about it. Sure, once you're experienced with PHP you know to sprinkle your code liberally with ===, but what about when you don't know that? Does this create noticeable problems -- i.e. your code won't run? No. Does it create security holes and odd edge cases where a rational person would not expect them? Yes.
[way too many](http://www.reddit.com/r/PHP/search?q=ide+php&amp;restrict_sr=on)
&gt;Also IMO, but any site that has a tutorial still up that uses mysql_ functions should be immediately written off as a bad source of information. I see so many poor souls in /r/phphelp with mysql_ functions, it's obvious Google has led them astray. (PDO and mysqli are the replacements) Actually, I've come across an awful lot of shared hosting companies that refuse to allow PDO and mysqli (god only knows WHY), so if you're wanting to get into development, learning all 3 is a good plan (but really, your preference should be 1. PDO, 2. mysqli, 3. mysql, as available).
It depends on what you are developing for. If you know the target distro you are planning to release on, then research what the current numbers are. For example, RHEL might have an older release of PHP like 5.3.x (not really sure the exact number, but this is just an example), Debian *could* be even older with a 5.2.x release, while Ubuntu might be more current with a 5.4.x release. In terms of books/resources, I would stick with something current (in the last couple of years) if you are paying for it. But generally, you should be good with anything over 5.x.
PhpED
I find it easier to write unit tests for a database by changing the DSN to a test database, then the unit tests can load/save to a copy of the database with affecting the product itself.
No, the 'test_' does not stop the ability to change a directory. If someone passed "/../xx" into the POST var, it would include the script xx.php in the same directory as any of the "test_*" scripts.
So true. We get this question every week...
&gt;Congratulations, that means nothing. Actually, it does a pretty good job of proving that PHP's inconsistencies aren't really a problem. You either get used to them or framework around them very quickly. Could it have been a lot more consistent? Sure. Is it important that it isn't? No. Congratulations, *that* means nothing.
Netbeans, purely for the fact that I can run Unit tests within the IDE, and I can Click through to methods using Ctnl+Click, It's got some great plugins for coffee and less and is a general all rounder for me.
Eclipse PDT from zend
you can also look in this thread http://www.reddit.com/r/PHP/comments/1crtfj/what_is_your_preferred_ide_for_php_dev/ its still pretty up to date and has any info you might want or use the search, theres a lot threads to that topic already.
Linux, har har har
/u/nikic actually has implemented array comprehensions alongside the generator, and expression generators on a feature branch. The fact is that in 5.5 only the generator made it in.
Use the [PHP downloads page](http://php.net/downloads.php) to determine whether the PHP bundled in your WAMP/XAMPP is up to date. If you are using 5.3, then it must be 5.3.27, 5.4.19 for 5.4 and so on. If you are using Linux, most distributions specify what version of PHP they are shipping. E.g. for [Debian](http://packages.debian.org/wheezy/php5). As you can see - it is behind the recommended release for 5.4 - 5.4.19. So we use repositories like [dotdeb](http://www.dotdeb.org/) to stay in sync with latest PHP releases. Once you have settled on your PHP version, pick up your resouces. For tutorials, limit your searches to 12 months old or newer content. Same goes for books - check when they were published and pick the latest editions. You wouldn't want anything written when PHP 5.2 was "current". 
I prefer many technologies over PHP out of my personal preference, style, api, environment and community, still as sane person I have to acknowledge that PHP is a valid, powerful and performant scripting language. The problem I encounter with PHP is the morons that make utter crap with it. The low barrier of entry with PHP makes it a target for coding idiots, who have no quality level, hack away as if it is their last day, refuse to learn from others.... 
Basically, anything before 5.3 is too old for security and other reasons. You should be using 5.5 if at all possible.
What method are you talking about? Remote includes or the `allow_url_include = off`?
While I haven't installed and played with it myself, I'm seeing [esoTalk](http://esotalk.org/) pop up more and more. e.g., www.laracasts.com/forum
PHPStorm for IDE Sublime Text 3 for editor
I've done it, but only because I had a lot of spare time and wanted to learn Ruby. The website was in need of a rewrite, and it didn't matter what I rewrote it in.
He's picking up an intense amount of upvotes and downvotes mostly because it was linked in this post here.
Couldn't agree more.
I love Sublime Text for some quick editing etc, but per definition, it's not an IDE. 
are you sure ? http://www.php-fig.org/ 
I also run @phpquickfix for links to other (usually shorter) content
I've never heard of twitter using any PHP. IIRC it's mostly a mix between Ruby (on Rails) and Scala, with some other stuff sprinkled around for back-end systems. If they do indeed use PHP anywhere, could you let me know where? I'm not saying they don't, just that I've never heard about it, and am curious to know if I'm mistaken.
People just love to blow off steam on the Internet. That's all it is. If all the various language fans were sitting in a room together, I'm sure they'd all be a lot more understanding and cordial.
Well, you start with `class`... Really, this is the sort of question to write a book about, not a paragraph answer.
Wow those controllers are huge: https://github.com/esotalk/esoTalk/blob/master/core/controllers/ETConversationController.class.php Static methods everywhere and not a unit test in sight, no Composer support, custom framework, logic-full views mixing PHP and html. "Modern web technologies" indeed ... 
+1 for Sublime. It is not an IDE, but it is a little IDE-ish. For me it is the right balance of light-weight fast editor with a few IDE-like features. Sublime is highly customizable, so it let's me work the way I want to and not the other way around.
Unrelated, but the keyboard clacking is making my migraine more migraine-ish. Your mic is tooo close to keyboard.
Successful troll is successful.
I think you might want to restrict the scope of your question a bit.
At the very minimum, php 5.3. In the best case, you'll use the newest stable.
&gt; Taking sides really isn't all that stupid or toxic. taking sides drives competition. Competition is the mother of innovation. In theory, yes. But people have been criticising PHP's inconsistent function library for years, and all the devs have done is put their fingers in their ears and say *"la la la la, use an IDE"*. While other parts of the language have improved tremendously, the biggest criticism of PHP hasn't changed.
On us1.php.net I get &gt; Test Page for the Apache HTTP Server &amp; InterWorx-CP
It sounds like you are you asking if there are known include exploits for that particular method? I don't believe there are any that are known, but there obviously could be unknown exploits (like path truncation, dot truncation, reverse path truncation.) I doubt anyone has put much effort into testing it, because, like you point out... it is bad practice and probably never used.
But how do you go about following solid principles?
It's fairly new. I'm trying to get the word out about it. QB is designed to give PHP an extra umph to make it suitable to do audio-visual work. I wouldn't say it's a niche area, but it does involving lower level programming than usual. Hopefully, in time people will build components that allows more novice PHPers to take advantage of it.
Don't write off 5.2 &amp; 5.3 so fast, they comprise 90.5% of usage, as of Sep-1-2013: http://w3techs.com/technologies/details/pl-php/5/all That's not changing anytime soon.
Sonofabitch.
So would it only be beneficial if you're doing a lot of raw number crunching? Is this something typical websites would benefit from, is what I'm asking.
This makes me so happy. 
As far as I'm aware, it's APC with the opcode caching removed leaving only the user caching, and thus it should be as reliable as APC was. I'm using it in production with no problems.
try this $tire_sql = $wpdb-&gt;prepare( "SELECT item, size, group, description, sort4, sort5, sort6, price FROM _tires WHERE size = %d AND sort5 != '' ORDER BY price ASC", $size );
Keep an eye on the github issues. I was playing around with it and ran into [this issue](https://github.com/krakjoe/apcu/issues/38), which required setting "apc.serializer" to "php" in the php.ini, otherwise it corrupted my cache.. which is odd because that option isn't even documented in [the manual](http://www.php.net/manual/en/apc.configuration.php). There's also reports of [segfaults](https://github.com/krakjoe/apcu/issues/36) and [hung apache processes](https://github.com/krakjoe/apcu/issues/19), amongst other issues. With that said, I've been running it on an nginx server via php-fpm with a site that gets a reasonable amount of traffic (50k page requests a day) and have not experienced any issues other than the serializer bug.
5.4+
because thats how processors works, why shouldnt your progrgamming language?
That's really neat, thanks! :D
Yes. PHP is fast enough for basically anything that requires less than 1 million ops. Outside of image processing code, one typically doesn't do that many calculations in a web app. On the other hand, image processing not really a small niche. Images are used quite a lot on the web after all. The ability to make adjustments to images on the server-side could be quite useful in a CMS, for instance. 
&gt;Okay neat. Should I stick to the i[ClassName] convention, or [ClassName]Interface? Personally, I go with the latter, since that's what the [internal interfaces](http://php.net/manual/en/class.sessionhandlerinterface.php) that are affixed do. 
I have sadly seen the same with JavaScript. I'd still say that the ease of getting started with either is a boon to the language, particularly with things like StackOverflow helping to raise good examples up high and bury the bad examples.
&gt; For example, is there any sane reason why things like ... It's perfectly sane, predictable even, if you're coming from a C background, which many people were back when all this "awful" stuff was invented. http://msdn.microsoft.com/en-us/library/yd5xkb5c.aspx http://www.cplusplus.com/reference/cstdlib/strtol/ 
If you are your own boss for choosing hosting or you know for sure that trustable people are above you, then you can start right off 5.5 even. If not, I recommend 5.3, BUT take note of what functions are 5.3+ as there's still a chance you'll have to deal with 5.2, especially if you're going to be new in your carrier. 5.1 I haven't even seen in over 6 years so you are guaranteed to not have to worry about it
Or just use https://github.com/amcsi/amysql :D
I'm not surprised as almost nobody has a budget to upgrade their entire websites' PHP version every couple years. I'm just saying, that as a newbie, you don't want to be learning about magic_quotes and register_globals when you could be learning about namespaces and traits.
FWIW, I'm running a Debian Stable server, and it's [running 5.3](https://wiki.debian.org/PHP/#Available_versions)
Well I tried it again, and the bug was marked as wont fix awhile ago(one I did previously) and the local history feature has moved _no where_. So the bugs I filed a long long while ago never got fixed, so I'm going to stick with netbeans as it's way better for a number of reasons. a) it's free, and does what komodo does. b) it actually works with me not against me. c) I don't have to write macros and such to get the thing to behave like it should. d) I'm able to move around it very simply, and I don't have to retrain myself to code how it wants me to.
Ruby for at least 18 years (wikipedia says mid-nineties). 
Amen sir. And don't forget generators! It'd be a wonderful world if we could get the hosting companies to move quicker on this front... on the other hand, perhaps they might have a word or two to say about PHP's history with backwards-compatibility. I'll put in a plug for HostGator here though, I just discovered that I simply needed to [mod my `.htaccess` file in order to enable PHP 5.4](http://support.hostgator.com/articles/hosting-guide/hardware-software/php-5-4). (the section about legacy servers isn't applicable anymore, they migrated my two accounts last week, and 5.4 is now available.) Those sites have been on 5.2 since forever ago, and I wouldn't have found this out if I hadn't read this thread and decided to do a quick google. So thanks! :)
Not in Unix i Discovered, 'test_/../xx.php' is an invalid Unix path, and will be refused, but it will work on linux, and windows.
I'm talking about not using dynamic includes that are determined by data from an outside source.
But... you're in a thread complaining about people complaining about PHP. You're the top comment of this thread, complaining about it. You're also in that /r/Python thread a couple times. Let's not act like PHP programmers never take sides and Python/Ruby programmers are just big ol' meanies.
You can't style a page that doesn't exist. When a browser hits /Dropit/uploads/imageName.jpg , it will kind of do the user a favor and instead of downloading the image to disk, it will display it within the browser using its own internal style sheet (basically something to make the background white and display the image in the middle of the screen, and maybe scale it). You need to direct the user to an actual webpage with the image. Something simple could be /viewer.php?image=imageName.jpg &lt;?php $filename = $_GET['image']; ?&gt; &lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="YOURSTYLESHEETHERE.CSS"&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="/Dropit/uploads/&lt;?=$filename;?&gt;" /&gt; &lt;/body&gt; &lt;/html&gt;
Thank you very much, I highly appreciate it. This was the piece of knowledge I was missing.
&gt;You can't style a page that doesn't exist. mod_rewrite?
Why would someone use that over PDO?
Because this can do the same and more than PDO, and there are no ext dependencies at all
Hey, this is Java guys we're talking about. /me hides
Unfortunately files named like `api_builder_includes/class.API.inc.php` are a bit of a putoff, as they suggest a certain PHP homebrew approach. The code bears this out, but since it's only 2 files this might actually be a nice learning project to apply some of this to: http://www.phptherightway.com/ I won't go into coding style issues, only to mention that it's really important to be *consistent* above all. The PSRs will help with this. All the static methods are something you'll no doubt want to rethink as soon as you write your first unit test. "API" and "Database" are just too common as class names for you not to namespace them, etc. Apart from the general utility, which I doubt, the main thing is the Database::clean() method and $_GET. There's no excuse at all these days not to be doing it properly via [prepared statements](http://php.net/manual/en/pdo.prepared-statements.php), and PDO is broadly accepted now, no need to hard code a dependency on a MySQL backend for something like this. 
Good point.
 ini_set('session.cookie_domain','.website.com'); should do it
I'm in /r/python because I am a happy python user and I read python related news. When people are being dicks for no reason I like to respond, letting them know they're being dicks.
I would recommend OpenCart for ease of use. This article breaks down the differences between Magento and OpenCart and brings up some of the things that you mention. http://www.wiredtree.com/blog/opencart-vs-magento-which-ecommerce-platform-is-right-for-you/
What is $domain set to? For the cookie to be accessible to/from subdomains, it needs start with a . before the domain name, like in my example: .website.com 
Yeah, it's .domain.com on both pages. Do I have to change it for one?
Are these domains on the same box? Are they using the same place for session storage? If `website.com` uses `box1/tmp` for session storage and `marketplace.website.com` uses `box2/tmp`, it won't pick them up. You'll need to use unified session storage of one kind or another.
If those websites are on different boxes, you'll have to come up with a solution for shared session storage. Memcache is usually the easiest.
I have a hard time wanting to go anywhere near this, as a lot of smarter people than I have said things like this are a bad idea. From http://philsturgeon.co.uk/blog/2013/07/building-a-decent-api &gt; Never Expose DB Results Directly &gt; 1. If you rename a field, then your users are fucked. Convert with a hardcoded array structure. &gt; 2. Most DB drivers [for PHP] will show integers as numeric strings and false as "0", so you want to typecast as much of your output array as possible. &gt; 3. Unless you're using an ORM with "hidden" functionality, people will see passwords, salts and all sorts of fancy codes. If you add one and forget to put it in your $hidden array then OOPS! Manually declare your output, do NOT just return Users::all(); In addition to that, you'd also not want to roll your own authentication. That's rule 1 for security, unless you're way into cryptography ;). /u/public_method had excellent points about static/naming/consistency issues. Read the link provided.
I'm glad somebody else linked to my API article for me. This seems to be a common story: "You're building your first API. You've got your database all set up, you've got a query sorted, now what do you do? Well.... you return JSON right? Done. Oh now we have v2 of the API. We've had to rename a bunch of tables, status values are different because of a new step we introduced, we've removed a step of normalisation here and added another one over there and we've just drastically changed our output... Ok well fine, v2 is different." But now you're v1 is fucked. Good job. I ALWAYS put a layer in between the data and the output. At the _very least_ this needs to be a hardcoded array, more likely some more complex "Presenter" logic. But whatever you do, don't do this.
I also try to have the interface using the "generic" name, like "Connection", and implementations named with more details, like MysqlConnection, … It makes more sense IMO and it forces to think and name things correctly. Another example: UserRepository -&gt; DoctrineUserRepository (implementation using Doctrine). Or again: Notifier -&gt; EmailNotifier/GrowlNotifier/SMSNotifier… When I can't, I fallback on the PHP-FIG convention.
I like it. The content feels more compact. Still the contrast and scannability could be improved. I don't just want my docs to look pretty... I'm making stuff right now and want to be educated fast, instantly, please! So yeah, legibility by contrast would be awesome for the next iteration.
\#beta
I think some would argue generic names and even I[Name] is less readable, but that's mostly theoretical baloney. In reality when you've found yourself working with a class or interface you know the exact context without looking at the name. Besides, many of PHP's internal interfaces have generic names, eg Traversable, Iterator, ArrayAccess, etc, and any confusion I had (is that a class or interface?) was quickly removed after 3 seconds of looking at docs, which I'd have to do anyway regardless of the name.
That's not true at all. First of all, it seems you're misunderstood the term "Prepared statement". It does not mean preparing a MySQL statement by escaping the "bound" variables and concatenating them into a single string. It means passing the query and the parameters to the database engine separately so that the database engine is aware of the statement, and the values to fill it with. Your code is giving an easier way to call escape functions on input. Using MySQLi over PDO is fine, but you should be using MySQLi's statement prepare / value binding functions ( http://www.php.net/manual/en/class.mysqli-stmt.php ). Additionally, where PDO supports many database engines, your code only supports MySQL. It's great that you are developing and creating open source libraries, and if PDO is definitely not available and changing hosts is not an option, then your library fills that gap nicely. However I'd never recommend using that library over PDO, perhaps if you supported PDO first and foremost with PDO prepared statements and fall back to the current method if PDO is not available, it would be more versatile. 
That's why I say client-side. May I honestly hear a good reason why I must use prepared statements server side as opposed to client side? Also, mysqli does't support named binds, regular mysql doesn't support server side prepared statements, and as far as I know, client side prepared statements are just as fine as long as they are implemented well. If I were to support all the other db types, would I fill the remaining gaps of my library?
ha, wo... that is pretty bloated. if you're after something composer based / unit tested, the Laravel based next release of FluxBB is going down that path https://github.com/fluxbb/fluxbb2
Or in a cookie.
The most important thing that's missing is: **good books**. Currently there are 3 books, that are even marginally acceptable: - [Beginning PHP 5.3](http://www.amazon.com/Beginning-PHP-5-3-Matt-Doyle/dp/0470413964) (2009) - [PHP Object-Oriented Solutions](http://www.amazon.com/PHP-Object-Oriented-Solutions-David-Powers/dp/1430210117) (2008) - [Guide to PHP Design Patterns](http://www.amazon.com/dp/0973589825/) (2005) As I see it, what we have are two almost five year old books for learning basics and one close-to-10 year old intermediate level book. And that's it. It's the Q4 of 2013th already.
The thing that comes to my mind is generics ( http://en.wikipedia.org/wiki/Generic_programming ). While many don't like them, there's tons of duplicated code and manual checks (and horrible inheritance misuse) deriving from the lack of this feature.
As a PHP book author (and prolific blogger); could you elaborate specifically on topics you feel do not have enough literature? Maybe I can remedy this! :)
We use 5.1 at work... :(
I might be missing something here but .. emm ... generics are basically loose typing loophole for for strictly typed languages.
Don't do this. If you store it in the cookie, you're sending however much data back and forth with _every request_. Not only that, you have to be much more cautious with what you store. You should be cautious anyway, but having it visible to the client using your app is a whole other ballgame. http://blog.astrumfutura.com/2012/01/storing-session-data-in-cookies-problems-and-security-concerns-to-be-aware-of/
And users can modify their own cookies. `admin=1`, anyone?
We're working on revising the design pattern book, anything you think it needs to discuss more? Disclaimer, I am part owner of php[architect]
Uh. Have you tried PHPStorm? It's excellent at this, both for remote debugging and while executing phpUnit tests. --- Edit: &gt; Whereas to set up the same in PHP is so environment and IDE specific. This is a fair point, but I think part of that is because PHP is an open-source and distributed ecosystem. Visual Studio, for quite some time, was a very expensive piece of software - it had to deliver on that price. That's why it's so slick compared to, say, Eclipse with a PHP plugin. Additionally, at least when it comes to most C# apps, you don't also have to deal with a 'server environment'; as soon as your build is done, you can run it. In PHP, at least until recently, you had to configure an environment to test your code - it was just the cost of entry. As they used to say, "Linux is only free if your time has no value"; the same goes for PHP. I offset the time cost by using phpStorm, which has a modest price tag that more than returns on the investment in time savings.
I'm certain he's talking about the passing the session ID, not the session data. Having read several of ivosaurus's past posts, I can't see him suggesting passing the actual session data inside a cookie.
It's a failure pile in a sadness bowl.
As I work on this, the more and more I dislike EE 1.2 and whoever made this
That sounds insecure.
I've been using php since 1997 and it has never once been an issue for me. Inconsistent? yeah, maybe... is it broken? Hell no... need to fix it? not really!
Hmm ... lets see. It would be really nice to see sections on subjects like **Repository** and **Unit of Work**. The part about **Data Mapper** would need a rewrite. In the original book for some reason the mappers were initializing domain/business objects (that seems like a really bad idea, especially since one can use several mappers on same object). And it glossed over over subject like "how to map collections of domain objects" and "how to persist complex object graphs". And I guess you would need to add something about **DI Containers** too, since everyone like to talk about them, but 99.95% of people do not know where to uses them, what the limitations are and how not to devolve it into glorified Registry. My personal pet peeve is the **MVC** and MVC-inspired patterns. How they work, how to apply them to web. That sort of things. The guide-book is basically only PHP book that doesn't push the *"Rails = MVC"* crap like everyone else. There were some issues (like the mess regarding controllers), but nothing major. Oh .. and book better explained difference between concept of "domain model" (as used by Eric Evans), model as a layer in MVC and implementation of domain/business objects. Every time when someone says phrase "active record models", I get this urge to throw things. 
here are few subject/titles: - "PHP 5.5 for newbies" - 5.3 reached end-of-life several month ago. There is a need for book that aside from hello-world stuff also covers correct use of PDO/mysqli, the new password API, yields, anonymous function. The basics. - "OOP principles in PHP", covering thing like SOLID, LoD, SoP, CQS - "SQL for PHP developers", because aside from *"SQL Antipatterns"* book, there hasn't been any intermediate-level books that cover interaction with different SQL database via PHP. All we have is "learn php and mysql in 22 days" type of crap. Pick one =P
Most of major IDEs and even some "developer editors" provide such functionality with XDebug. Then again, a lot of PHP developers do not see the point for it. Those fancy debuggers are critical for languages where you have to compile your application before you can deploy it. In php you simple save it, refresh it, and see what comes out.
This is a pretty good attempt, but overall I found the entire thing really confusing. I think you've made it too complicated. At the core you've built, more or less, a dynamic query builder that lets you query the database and get JSON back. It's not that bad but I'd rather stick to a more basic CRUD layer and keep the API backbone simple. There are a lot of other addons like rate limiting and stuff, but the implementation of those features feels disorganized and random. Nice work on building this, though, and sinking in the time to write all of the documentation. If you haven't, my advice would be to use it in a real project. You'll quickly find out what things are good and what things are bad and if you want any more features...and then you'll either make the changes or start over and your next revision will be that much better. Thanks for sharing! Edit: //set page to output JSON header("Content-Type: text/javascript; charset=utf-8"); You should actually use application/json instead of text/javascript. 
It's definitely possible. You could use something like Guzzle (or Goutte, if you need some of the extra niceties it affords), to grab the content, then use the DomCrawler to insert your content. You would store your stylesheets somewhere web accessible, then inject `&lt;link&gt;` tags (or `&lt;style&gt;` with the content of your stylesheets) with links to your stylesheets in the `&lt;head&gt;` tag of the content you got from the other server. You would then display this post-injected content. DomCrawler: http://symfony.com/doc/current/components/dom_crawler.html Goutte: https://github.com/fabpot/Goutte Guzzle: http://guzzlephp.org/
Yes and no. Generics offer a language the ability define a strong typed system in a loose way. For example in Java the java.util.ArrayList class uses generics to define the specific type which can be stored in the array, for example strings when initiated with `new ArrayList&lt;String&gt;()`, but the use of generics gives the ArrayList authors the freedom to create that specification in an easy way. PHP does exhibit some strong typing qualities such as parameter type hinting. At least once every few months I run into a problem with PHP that could be solved with generics. Here's an example of what I mean: I start off by defining an abstract base class. abstract class AbstractValue { /** * The value * @var mixed */ protected $value = null; /** * Sets the value * * @param mixed $value The value */ public function set($value) { $this-&gt;value = $value; } /** * Returns the value * * @return mixed */ public function get() { return $this-&gt;value; } } Finally I create a concrete implementation of the base class. A value container for Widget instances. class WidgetValue extends AbstractValue { public function set(Widget $value) { $this-&gt;value = $value; } } I override the `set()` method because I only want types of Widget added to the container. However the way I've overridden the `set()` method would lead to a PHP strict standards error, because the signature is different from the base class method signature. I would actually have to override the method like this. public function set($value) { if (!($value instanceof Widget)) { throw new InvalidArgumentException( "The value must be an instance of Widget." ); } $this-&gt;value = $value; } That's kind of a pain the butt. Especially when you've written similar code a hundred times before. While there are ways to solve that problem in PHP, generics offer an easy and graceful way of dealing with the problem. First I write the base class. abstract class AbstractValue&lt;E&gt; { protected $value = null; public function set(E $value) { $this-&gt;value = $value; } public function get() { return $this-&gt;value; } } And then finally the container for widgets. class WidgetValue extends AbstractValue&lt;Widget&gt; {} That's it! There's nothing more to write to achieve a strong typed value container.
Well , you shouldn't be expecting a specific implementation to be passed in. Instead you should be hinting an interface. It's in the list of SOLID principles =] But yeah, this explained to me how it actually would work. Tnx.
I do use php storm and love it, and I use xdebug with it as well. I had to switch my main Dev machine to Linux in order to finally figure out how to get everything integrated. I'm ok with that but the fact that I felt the need to is what brought it up for me. And if I wasn't using php storm god help me .
I'm quite surprised so many people recommend PHPStorm given that it's not free. What are its advantages over Netbeans? NB still supports Xdebug &amp; phpunit
As stated by nonethewiser, use memcache as your session handler so you can have your sessions stored on a separate box, shared by different front-ends. Edit: Turns out redis can be used for this as well. You can also just write a custom session handler that serializes/restores your sessions into/from a database. Related function: http://php.net/manual/en/function.session-set-save-handler.php Either solution will let you continue using the $_SESSION superglobal. Might also want to check packagist for something that does this. Probably a lot of them out there.
I'm not sure what's worse... * The template file having this code * The warnings thrown when $_GET[DELETE] isn't set, the constant that is (probably) not set DELETE ... not to mention $_GET[id] * The obvious SQL injection that can happen /me smacks face on desk repeatedly.
I actually wrote my reply twice. The original included an interface but I decided to leave it out. The problem is still the same. The interface. interface IValue { public function set($value); public function get(); public function equals(IValue $value); } The abstract base class. abstract class AbstractValue implements IValue { protected $value = null; public function set($value) { $this-&gt;value = $value; } public function get() { return $this-&gt;value; } public function equals(IValue $value) { return $value-&gt;get() === $this-&gt;value; } } And then the concrete class. class WidgetValue extends AbstractValue { public function equals(IValue $value) { if (!($value instanceof Widget)) { throw new InvalidArgumentException( "The value must be an instance of Widget." ); } return $value-&gt;get() === $this-&gt;value; } } Once again I'm stuck doing type checking myself in the `eqauals()` method, and I wouldn't want to compare an instance of WidgetValue and FooValue even though they both implement IValue. I would love to simply change the method signature to `public function equals(WidgetValue $value)` but that is also a strict standards error. Once again generics save the day. The interface. interface IValue&lt;E&gt; { public function set(E $value); public function get(); public function equals(IValue&lt;E&gt; $value); } The base class. abstract class AbstractValue&lt;E&gt; implements IValue&lt;E&gt; { protected $value = null; public function set(E $value) { $this-&gt;value = $value; } public function get() { return $this-&gt;value; } public function equals(IValue&lt;E&gt; $value) { return $value-&gt;get() === $this-&gt;value; } } And the concrete class. class WidgetValue extends AbstractValue&lt;Widget&gt; {} Now only an instance of IValue&lt;Widget&gt; can be passed to `equals()`. Granted, generics can be a big of a wtf to beginners, but obviously we shouldn't hold back the language to appeal to the lowest common denominator.
[Here's a simple pastebin I just typed up for an example of how to accomplish what you're trying to do.](http://pastebin.com/AeFKD5MY)
Bah, you haven't lived until you've got Xdebug remote debugging (including step-by-step execution) working in vim. I've done that. Never again. LOL
It's just faster, mostly.
PHPStorm's auto-complete and code navigation features beat everything else.
I used netbeans for about a year on a large "in-house" codebase. It was slow, but otherwise fine. PHPStorm just has a certain speed to it, and a slightly smoother implementation of certain features (at least comparing to my memory of NetBeans, I haven't done a side-by-side comparison), that make it more appealing to me.
Thanks, I appreciate this so much. Its for an experimental project just so I can learn, so it works well. Only thing is while it appends the submitted URL, it doesn't actually load that page. Am I missing something? http://www.hiredanielle.com/ -&gt; I pasted it there to test.
Change $_POST to $_GET. Try putting var_dump($_POST); var_dump($_GET); at the top of the page. $_GET is the array of ?var=val&amp;var2=val2 and maps to $_GET['var'] and $_GET['var2'] if you don't want the URL appended with the formdata, use: &lt;form method="POST" action="" ... &gt;
Thank you so much! I'm getting the page to load. All the CSS is striped though, but I'm working through it. You're awesome!!
Websockets support is a must! Every day I just wish I could push updates to the client as soon as the data changes
Also, work Composer and PHPUnit testing as well into that list. I've noticed a lack of Object Oriented PHP development practices when interviewing people recently. It would be nice to have a book that actually issued a recommended best practice for OOP in PHP that is remotely related to the practices that are employed in Java and C#, in other words other OOP languages.
Faster in what way? I hear people mention this and I truly don't know what 'speed' they are referencing. I notice on my laptop that things like code completion and tooltips etc are sluggish, but on my desktop it's all quite snappy. Is that what people mean about PHPStorm etc being faster than Netbeans?
Named Parameters
Okay, this is NOT an 'API'. This is a JSON Interface for your RDBMS, stop calling everything that returns JSON an API please.
Neither java, c, c++, vala, perl, pear, lua, js comes with a unit test framework
Ratchet: http://socketo.me
Anytime I see a post title like this I start thinking, "Oh, please don't let it be my code. Please, please, please."
It's free or discounted if you are student. Also there is a free trial. Use it for a month instead of your regular IDE. Hell, just try for a week or even a weekend. It only took a day for most of my friends anyways.
It would be nice if there was a constantly evolving resource like a Wiki (free or subscription based) for PHP that helped people go from beginner to a competent developer and taught them everything from tools like frameworks, PHPUnit, etc, to design patterns.
What? No, just the session ID, the same thing the default php implementation does.
Thank you very much! I have been following a guide.. I wonder why it didn't include that.
Yeah, register_globals was removed in PHP 5.4. And why the caps? How old was the tutorial they used?! Anyway, you should use htmlspecialchars() to escape the GET values to prevent XSS attacks.
Thanks! This helped a lot.
Not really any less secure than php's default sessions. There's nothing stopping you storing the id in a cookie in this scheme, either.
I could be wrong, as I've only heard about it through myths and legends, but it looks like you're assuming register_globals is on (à very, very outdated concept) If you're using a tutorial, I sincerely recommend finding another, more up to date, one. I would suggest one, but I'm on my phone right now. Good luck with the PHPing :D
I've recently inherited a project littered with mysql_close; throughout the template, do these people turn errors off to make their live easier?
ALWAYS SANITIZE YOUR INPUTS This should be tattooed on young programmer's arms when they begin learning programming. I'm not sure there is anything more important. Hell, even memory leaks in C/C++ are more acceptable than not sanitizing inputs.
Thought MySQL might be a reliable guide http://dev.mysql.com/tech-resources/articles/ddws/17.html 
Nope. Keep away from user-submitted articles. Go to the official source for each of the tools you are using and read that. Here you go: http://www.php.net/manual/en/tutorial.php
You should check out PHPPHP: https://github.com/ircmaxell/PHPPHP Having an AST also gives the opportunity to do lisp-style macros: https://igor.io/2013/07/26/evolving-syntax.html That would be awesome.
Yeah, this is more what I meant, store it in the database simply for long enough for the user to transition from domain1.com to domain2.com, then remove it from the database. 
Great read. I learned at least 4 new things today
I am fascinated with the culture of "I don't understand auto-typecasting so I will always force a non-typecasting comparison". Suppose DELETE were a properly defined constant specifying the name of the parameter, that this code is only reachable if that parameter is set, and when $_GET['id'] matches a regular expression along the lines of '/\^\d+$/'. (In other words, ignore every other possible concern). What could you imagine going wrong? $_GET contains strings parsed from the querystring. Its values, unless you are being incredibly edgy and modifying $_GET, will always be strings. So you will get a string comparison, which will yield the correct result. Let's relax those assumptions. Maybe $_GET[DELETE] is not defined in which case it results to null. null == "yes" evaluates to false. That is a correct result. No? 
When I was starting out (and I mean starting out) I wrote shit like this. I simply didn't know any better! The company I was working for expected me to build stuff, ("you can do websites, can't you?") and I did what I could. Due to my guilty conscience, I've since revisited those early projects and re-written some of the worst PHP and JS I've ever seen. I learned through mistakes. Today, all my inputs are sanitised, my passwords salted, and my sensitive data encrypted. 
Consistency of design.
Although that article was by Kevin Yank, not a bad guy at all who's written numerous books about PHP, it was likely sourced from his first edition book "Building a Database-Driven Web Site Using PHP and MySQL" which was written way back in 2001. The latest edition, the 4th published in 2009, certainly doesn't have that code in it. That page should probably be pulled or updated.
Absolutely. SugarCRM does thus for many of its APIs and you should see the number of SQL errors that mount up in the log files as mail client plugins and other external apps generally get things wrong, and this feeds right down to the SQL statements. It is a security disaster waiting to explode IMO. 
I agree, better, native debugging tools would be something. XDebug remote debugging *kind of* works but from my experience it's slow, sluggish and not very stable on large projects, and there aren't other options expect for PHPStorm which is windows only.
I gues ===
Hmm. Not because it's working that it's the right thing to do... Unless you really do need to auto-typecast (even then, I think you should never do that), you should use ===. 1) It's faster http://micro-optimization.com/equal-vs-identical-comparison-operator 2) Good habit. 
Fucking homegrown devs thinking they're make code faster by removing characters.. Christ almighty.
Maybe you shouldn't be selling your code yet then. ;)
since no one pointed out this , I have a feeling I could be wrong) But shouldn't FORM ACTION="/php/welcome.php" be FORM ACTION="php/welcome.php"
This method isn't very good if you want to utilise PHP's use keyword. You'll end up having to rename the classes, traits and interfaces. 
Many array functions should have associative array support. We all deal all day with database data. I'm sick of doing foreach that would be more efficiently done with built-in functions.
I always Google search filter by 'past 12 months'
I think most people know that this works, but it causes a notice level error. PHP throws an error and then tries to figure out what you meant to do. This is really ridiculous behavior as its fairly common to use a constant as a key. Unquoted constants as keys are ambiguous, error prone, and less efficient, and should never be used. 
[yerp](http://www.reactiongifs.com/wp-content/uploads/2013/06/exactly.gif)
=== should be used in the majority of cases. You should know what type the variable is and make sure it is that type and value. There are of course some valid cases where truthy and falsey values make sense, but I'll sometimes even explicitly use triple equals with acceptable variations in order to make it obvious what you're expecting and not allow the program to continue normally due to a wanky type conversion. For instance, I sometimes do this just for clarity: if($someVar === 1 || $someVar === "1") { //do your stuff } else { //throw an error since the input is unexpected }
Session storage is configurable in PHP. I've used what you mention but I'm pretty sure you can set it up to store the $_SESSION super global directly in memcache as well. Also, phpredis session storage does not lock and rewrites the entire session data at the end of each request. That means race conditions happen. Caution is avised if you use $_SESSION extensively.
I see no harm in using == here. What else could possibly be typecast into the letters "yes" incorrectly?
Here's an example of what I mean because I feel this should be documented. This is something I've *seen* happening, not a hypothetical case: Request A and Request B hit the server at nearly the same time. Request A code: $_SESSION['x'] = 34; $_SESSION['y'] = "foobar"; Request B code: $_SESSION['car'] = "vroom"; The result? $_SESSION will either have 'car' set and 'x' and 'y' empty, or viceversa, depending on which of the requests won the race condition. This doesn't happen with the standard session file storage in PHP because the files lock; Request B would have waited until A released the lock. Without a built-in lock you have to keep these kind of race conditions in mind and work around them, for instance by implementing your own lock by other means.
&gt; Stop reading random guides found on the internet. This is a difficult problem for newbies in any area. I mean, you could say that following your advice would in itself be not following your advice. It's hard for people to know what to trust.
EE is so fucking bad. Had to work with it for some projects. 
We're seeing this issue right now on memcache. Do you have any documentation for this? It has been keeping us from upgrading from 5.3.
&gt; not to mention $_GET[id] That part is actually correct (aside from the injection bit). When within a string, array indexes are autoquoted, so the id part is treated as a string literal, not a constant name like in $_GET[DELETE].
Most developers will just typehint the class's interface for their method(s), instead of writing checks like that. I agree that generics could be mildly useful, but it's not even on the radar for a "top things PHP is missing" type of list, IMHO.
It surprises me that this works. Would `$result = mysql_close;` work, or would it fail (as it should) as it should think it was a constant?
`===` should only be used when you want to check value *and* type. In this example, you obviously don't care about type, so it would be better to use `==` and get rid of the duplicate comparison.
NONE of the get or post variables had quotes, they are just suppressing countless assumed constant errors
They thought they made me am account on the EE sure just to modify templates, but they definitely made me a global admin. I stumbled onto their orders table from their DB, and if I was an evil person, I have hundreds of UNENCRYPTED names, full addresses, credit cards.... 
If you do this - for the love of god - no "hello world" examples, no "let's do a checklist" example, no large example which uses non-persistent data. I'm hating all those online tutorials that go "Yeah, we can enter a new something and then somewhere some magic happens and the stuff will be saved, probably, somewhere..."
Try starting again here: [phptherightway.com](http://www.phptherightway.com/)
Makes sense. But also makes assumptions. In my experience this would lead to any number of unknown edge cases depending on how you try to use the data.
When the types are different, sometimes you can not quite be sure which side has its type converted to make the comparison. Better to be absolutely explicit.
It is possible that the entire $GET[] array is sanitized before this code is even run.
Righto... whatever you say.
Nope, I use an IDE
yea, i think it is a backwards compatibility thing, but its very wrong. A constant should always be a constant and if it isn't defined it should be an execution halting error. 
Being able to properly use and() or or() method names on query builder classes would be very nice. EDIT: How are people confusing this for a global namespace issue? It has nothing to do with namespacing, just the parser not differentiating between perfectly reasonable distinctions between keywords and method/constant names.
cries :(
This would bring PHP in line with other truly OO languages, which is either really good or really bad depending on how you code and/or feel about PHP becoming more Java-ish. Maybe I'm wrong, but does this represent a major (breaking) change in the internals? I was always under the impression that all of PHPs "global" functions were not in a namespace, and that PHP couldnt understand the difference between list() and MyNS\MyClass::list(). If this is the case, how much of the codebase is affected? For me, this is a welcome change, although it feels more like a bug fix than a feature addition.
There isn't that kind of book. What you need is practical experience. And that's not something you will find neatly packaged in a book. Also, you have to understand this: patterns are not magical canned solutions. They are just names to describe the solution. 
Afaik, but I'm not currently using memcache in production, the standard extension for memcache had a setting for locks (unlike phpredis which doesn't support session locking at the moment), so it should work when memcache is configured for it. I'd look into the github repo of the extension, IIRC there was info about this there.
Whoah, hold up, I'm maintaining a 12 year old codebase on an old toaster and don't want to have to do any work! Why do you have to be such an elitist!?
Exactly. They both have their place. PHP is a duck-typed language. There's no reason to fight that if there's... well... no reason to fight that. If there's a reason that it MUST be an integer, for example, then by all means run that strict comparison. But this notion of "always check strict unless you have a damn good reason" sort of misses the point of the language imo.
It would treat mysql_close as some sort of constant, give a notice level error, and get on with its life.
you ruined the joke
I would recommend Codeception. It contains PHPUnit, but it also adds acceptance testing from behat. Also, it's really easy to use.
phptherightway.com If it's not on there, let us know, and we can point you to the right resource. By "we" I mean us PHP oldheads in this subreddit.
404. Page not found. Sorry, but you are looking for something that isn’t here. wat
Massive, massive understatement.
Perfect analogy.
check us out at phparch.com - I think you'd find our monthly magazine useful, but besides books, we offer online seminars, training, and put on php[tek] in Chicag every May.
A while ago, someone put out an XDebug plugin for Sublime Text: https://github.com/Kindari/SublimeXdebug I never used it, but I'm curious about how it performs.
Have you done any technical writing?
Stop using the word "should". It means you can't convince someone so you just appeal to nothing. You sound like a goddamn idiot saying you know what "the right thing to do" is in the same breath. If you have no tests or documentation, you can't know what's the correct fix or best practice on ancient code. Period. Start from there. It may be the casting is required by another ignorant component that may not even be known! Took me 1 second to come up with that. Do you know the context? I can answer that riddle too. Nope. This is maintenance as he said. DERP. The bandwagon is foaming rather than admitting what every sane developer would do (given the described situation) and you aren't helping by suggesting acts that will destabilize the code. Fucking redditors spend some time with codebases they have complete control over and then they lose their fucking mind trying to tell others how to sabotage their jobs based on this utopian nonsense about standards and practices that didn't exist for over a decade. Why didn't we need it? Because, like your ego, it's not the important part of development. Use the important bit, your brain.
I can't tell you how many times I wanted to make a method name and, or, list, etc. 
If you are going to do this, why not just skip PHP completely? http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs
Well lets not confuse it and call the person who wrote that a "professional". Lets remember how low the barrier to entry is.
Not really. Unless you count [posts](http://stackoverflow.com/users/727208/teresko) on StackOverflow as "technical writing".
Nothing. sayHello() will call the PHP internal echo(), because to call the object method echo() it would have to specifically call it from the object context, e.g. public function sayHello() { $this-&gt;echo("hello world!"); }
This raises the question: *Is it still a SQL injection if I'm just feeding parameters on a query string?* No bobby tables is required here: just go http://this/url.php?DELETE=yes&amp;id=1 
It has nothing to do with namespacing, it's just that the parser hasn't been updated to differentiate between the use of list, and, or, etc. as a keyword vs. a method name or constant name. They're not ambiguous at all in their proper context.
There is an RFC for that already: https://wiki.php.net/rfc/named_params
You've just called the native echo. Should you have used: $this-&gt;echo('blah'); then this would be fine. I am inclined to agree with the request in OP's post. Provided I'm not strictly clashing with keywords in the global scope, it should be allowed.
I've got a side project going on now, but this is my first true foray into OOP, so it's a bit of a brain-stretcher at times. I'm just trying not to ingrain bad habits that I'll need to correct later, so I'm trying to saturate my studying with a lot of front-loaded design theory.
* Methods/properties for native strings, arrays, etc. Even if it's just syntactic sugar. This would also give an opportunity to create more consistent names and parameter orders without breaking any backwards compatibility. * Native regex literals. They're important enough to be first-class citizens in the language. * Reliable cross-platform arbitrary precision math available by default, preferably with more efficiency than bcmath. * A very simple built-in no-setup key/value cache like APC provided. * [x:y] slice syntax for strings and arrays.
wait, n/m i think I misread this and put more into it than it did.
LOL. Damn you sound frustrated, son. I use the word should because I'm not here to tell anyone what to do. Just giving advice. If you don't have tests or documentation, maybe you should start there, but we weren't even talking about that, so I'm not sure why I should say that. If you read MattieF's comment, he's a little bit right: &gt; $_GET contains strings parsed from the querystring. Its values, unless you are being incredibly edgy and modifying $_GET, will always be strings. So you will get a string comparison, which will yield the correct result. So, in this case here, == or === will work. MattieF's point was that it's okay to use ==. My point is that === is faster and better. MattieF answered with (int) $a == (int) $b is the same as $a === $b speed wise. I answered with a simple benchmark proving he is incorrect. A lot of people come to these subreddit to learn. There's enough bad PHP dev and bad PHP guides already, I don't want to create more. If a bad info circulate, I'd prefer to correct it in the most polite way, backed with proof and sources. Good practices are not necessary, but if you think we don't "need" it, there is no way to convince you for this argument. Sorry if you got offended (but looking at your comment history, I think you're just a natural internet asshole). 
The right-way-page is more like a collection of *latest hyped subjects* with some php.net links thrown in. No matter how you look at this, it is NOT a page for learning. 
&gt; so to debug between two break points means stepping a massive amount of boilerplate. Wat. If you've got the two breakpoints where you want them, and the program has hit one of the breakpoints, just hit run and the program will run until it hits another breakpoint. Unless you meant something completely different. 
But that is worthless. So you've deleted a user....big deal, you've gained nothing. Now, replace `id` with an injection that will dump out the user DB (with emails, pw's, and possibly, CC info), and now you've got something valuable.
\#3 is the worst. #2 is a possible source of weird bugs, and #1 makes the site hard to modify, but #3 is a clear and present danger to their business.
What about [PHP Objects, Patterns and Practice](http://www.apress.com/9781430229254) (2004/2010)?
Zend tried, with Zend Studio, but they gave up a long time ago and resorted to just taking PDT, adding a few near-worthless features, and then charging 100's of dollars for it (and then deferring most/all bugs to the Eclipse project). Having the lead of the Zend Studio team also on the PDT team just seems wrong to me...
Example(s)? I can't tell if that's a single suggestion or multiple. You can replace a lot of `foreach` uses with things like `array_walk()` or `array_map()`. 
Yop
me too :'(
It **was** on my recommendation list some time ago, but lately I have been noticing way too many problems with it. Especially when it comes to the examples: complicated computation in constructors, use of global state, leaking encapsulation, unnecessary error suppression.
Worthless!? for ($i = 1; $i &lt;= 1000000; $i++) { // curl-get our magic delete URL } Instant (well okay, gradual, but probably faster than you'd think) database table truncation, and I didn't have to reach through any keyholes or try to suss out any database table names.
Thanks for getting back to me. Sorry for the delayed response. What I'm after is for the data-filter to be set on page load, depending on what page I clicked through from. I've been trying to accomplish this with session storage, to no success.
&gt; An application programming interface (API) specifies how some software components should interact with each other. Yes it is. It specifies how one piece of software will communicate with another.
This was meant to be a positive spin, based on the recent negativity. Step 1 in a solution, and a call to action for interested internals folks - all in one. Several people in internals would like to see a team of interested people tackle an RFC at a time, (spreading the load and responsibility) with a hardened C programmer around to actually implement it. This team would take care of a lot of the preparation offline, and when it goes to internals it is to ask specific questions in a specific thread, not the shit-show free-for-all that we saw with function autoloading. As I said this has done wonders for the FIG and I'd like to see if internals would be interested too. I'm not just saying that users should be allowed to run around dreaming up features and demanding the core team implement everything for them. It's about bringing the two sides together, and giving internals control and **structure** through a documented workflow that everyone can follow.
Also if you want to use array data in double quoted strings you can use the array without the quotes around the key.
Especially since this increases the run time. PHP has to look for the constant and then try it as an array key.
Now now, it's ok, I cried a little too
Very true, there are many other problems, such as, expression engine uses eval on the templates
Try again.
Basically you want PHP to be different language.
PHP is largely a mix of borrowed ideas from other languages, and most of the recent additions to PHP have been features borrowed from other languages. This thread is about what features exist in other languages that PHP is missing. My list is just a few things that exist in other languages that could be added on top of what PHP currently has. What exactly are you criticizing?
Sure, you can do a lot of damage, but you've gained nothing from it. That's what I meant by worthless. Only a disgruntled ex-employee or a petty competitor would see any value here, or a bored teenager. OTOH, extracted user data can be sold, or used for your own phishing (or otherwise scummy) purposes.
What sort of assumptions? that they actually hit domain2.com within the time frame, and if not, what do you do with the data? The data would still be in the session for domain1.com, so if they then want to go to domain2.com just re-run the database process?
1) Editing… You misunderstood my example: If $a and $b can be either "int or string" you must always cast before doing the triple equal, though it is unnecessary for the double-equal. I increased the number of iterations to 100000000 to reduce uncontrolled variation. With $a = 4 and $b = 5: &gt; $a == $b : 7.027 &gt; &gt; ((int)$a) === ((int)$b) : 10.670 With $a = 4 and $b = 5: &gt; $a == $b : 11.978 &gt; &gt; ((int)$a) === ((int)$b) : 16.072 With $a = 4 and $b = 5: &gt; $a == $b : 15.994 &gt; &gt; ((int) $a) === ((int) $b) : 26.008 But the day I base my coding style on microoptimizations is the day I abandon PHP altogether. 2) I actually do agree with the concept that variable types should be well defined. But if the type of your operands are well defined, that actually reduces the danger of the == operator. I hope PHP expands type hinting from function calls to class variables. In the above example, with good data validation (which you should be doing anyway), you cannot get an unexpected result. 
I'll definitely be checking that out, thank you. I actually took an introductory PHP/MySQL class, but for the money that I paid for it, it was very basic and very very short (only 4 hours spent with MySQL), which left a sour taste in my mouth. 
I too can look at Wikipedia articles from 1991.
Proper DOM parser 
Oh it opens the door to more dastardly things, for sure. But the ease with which I could put your database out of business might be of interest to your competitors. Incidentally, I'd be willing to bet that other views have this same hole in them for other data types... My question from above remains: is THAT use of this hole a SQL injection? Or just uncontrolled access of a "site function"?
interactive shell or sandbox.. its really annoyying how i need to create a script just to test simple code snippet
No, it's not SQLi -- it's pretty much just [Parameter Tampering](https://www.owasp.org/index.php/Web_Parameter_Tampering) aka. URL manipulation.
&gt; How do you deal with it for session management then? Normally you would have implement your own lock, or just rely on an in-memory data storage like redis or memcache where the writes happen in real time and not at the end of the request. I opt for the latter and keep the data in the session storage to the bare minimum. &gt; When you say it rewrites the entire session at the end of the request what is it rewriting. Would it be completely empty if nothing is set in that request and prior session data emptied? Here's what happens with every request in a simplified form in regards of session data storage: 1. Request starts 2. Session data is loaded into memory 3. Code runs, session data changes are kept in memory 4. Session data changes are written back to the storage (be it a file, redis, etc) The default session storage implementation of PHP opens and locks a session file in step 2, and releases the lock in step 4. This means that, given two requests, if the second request happens during the step 3 of the first request, it will have to wait until step 4 is done, that is after the changes are written, before loading the data. Now, with an session storage implementation that lacks a lock, like phpredis, if the second request arrives while the first one is in step 3, the second request will happily load the session data without waiting to the first request to finish, and since the changes by the first request are not written at this point, the second request loads an "older" copy of the session data. Not only that, but since both requests will try to write the session data once they both reach step 4, one will inevitably overwrite the other depending on which of the requests is done first, resulting in data lost since each request is not aware of the changes done by each other. Note that this only applies to requests done with the *same* session. Two users with different session ids hitting the server at the same time will never result in a race condition because PHP handles each particular session separately. Still, if you have an app that does ajax requests often it is not that hard to have two requests by the same user coincide in time. Hope that clears it up a bit. Race conditions are major PITA, but the sooner one gets acquainted to them the better. 
I gotta admit... it looks similar to some garbage I wrote a couple years ago before I knew any better. Last I checked, that garbage was still in use too. Now, I sanitize and parameterize everything. 
I don't understand why you're not typecasting with ==. You actually should typecast when it's == instead of ===. The goal is to determine if $a is the same as $b. Using == might give you false result, especially if you compare int and strings. As I said earlier, $a = "1e3" and $b = 1000. $a == $b will give true, while $a === $b will give false, the expected result. If you type cast, (int) $a == (int) $b, it will actually give you the correct result, which is false. There's a lot of bad cases like this, hence why using == is really discouraged. If you can code to always use ===, you should do so, and we haven't even talked about booleans type here... I mean, (0 == false) gives true... this is a bad habit. $string = 'hello'; $needle = 'h'; $pos = strpos($string, $needle); if ($pos == false) { echo 'not found using =='; } if ($pos === false) { echo 'not found using ==='; } if ((bool) $pos === false) { echo 'not found using typecasting and ==='; } In this case, the position is 0. If we're using ==, it's gonna fire. Typecasting === would actually give a bad result: if ((bool) $pos === false) So.. yes, if you get in the good habit of always using ===, you can prevent cases like this. and that's jsut an example that happens quite often... It's not just a micro-optimization thing, it's a logic thing. plus, it's adding 1 equal, it's not like I'm proposing a whole new design pattern. edit: --- Also.. while we're talking about typecasting and booleans... PHP is weird and typecasting should be done properly.. this is not really part of our argument, it's just a note for people reading this. $a = (bool) 1; $b = (bool) "true"; $c = (bool) "1"; var_dump($a); //true var_dump($b); //true var_dump($c); //true $a1 = (bool) 0; $b1 = (bool) "false"; $c1 = (bool) "0"; var_dump($a1); //false var_dump($b1); //true var_dump($c1); //false
In the naming of being difficult: if ($fooBar and($foo || $bar)) Is that a logical and or a function and? Edit: Just saw the method name portion of your comment, so you can disregard this comment.
Nothing. However, it's generally a good habit to use === unless you're trying to compare, say, a string and an integer, and even then converting properly is less likely to go wrong.
http://twitter.com/nikita_ppv (Nikita Popov, aka nikic)
When you don't care about type, it doesn't matter which side is cast. What you're saying when you use `==` is "are these two values semantically the same?" Whether the left or right operand is cast doesn't alter the meaning of the expression. Besides, I'm pretty sure PHP is consistent with its casting. Do you have an example otherwise?
Noticed the "relevant XKCD" link was missing. That won't do. So, for those that need/want it: Relevant XKCD: http://xkcd.com/327/
What is in $test? Also I don't understand how this is working for you. ctype_alpha($warranty) will always return false because $warranty is suffixed with a string that contains 0's.
Right. So my response was about why `include` is bad in theory, not because of whether it's safe or not but more because of what it implies for the code design that employs it. Turns out you already know what happens if you prefix &amp; postfix :)
the final else is useless as you are just assigning the same value across. If you want to keep it in for ease of understanding based on conditions, I would move the first line into there. As mentioned you will have the issue the first **if** will fire due to the first line assigning non numeric data to **$warranty**. Other than that, there i not a problem assigning to $warranty multiple times, as only one can actually get used at a time (within that block) based on your substr(), and how it is being used, I'm guessing that you are trying to pull something off the end of $test **(something) 50k** If that is the case, you could do: if (preg_match('/([0-9]+)k$/i',$test,$parts) { $miles = $parts[1]; if ($miles == 0) { $warranty = "No Mileage Warranty"; } else { $warranty = $miles.",000 mile warranty"; } } else { $warranty = "Please contact for more information"; } 
Don't use PHP sessions. Create your own! Make a $_COOKIE['s'] variable that is set to domain: &gt; .website.com This way that cookie will be set for all subdomains of that site. Make the value of the variable be a randomly generated string: a0f5b543a0b540bde8ae333a511ca227 for example At that point simply store variables locally either in something like Memcache or MySQL tied to that randomly generated string.
It's not as bad as it sounds. I did a couple presentations on WebSockets in PHP and my demos run continuously as I have them being monitored and restarted automatically via supervisord: http://websockets.coreyballou.co/ The three demos have been up for months at a time now. I haven't spent any time determining a load threshold, however. I recommend opening the demos in two separate tabs so you can play along.
don't forget array_filter and the *sort family of functions too.
I think some of those count. If you want to explore it more see http://www.phparch.com/editorial/write-for-us/
I'm invoicing you for my vomit filled keyboard.
I could spend all day refactoring `Foo::getAll()`s to `Foo::list()`s.
I agree with you that a feature should able to be discussed without a patch. In other words, someone that doesn't know C should be able to participate. How many features where dismissed not because of the implementation, but because there are syntax conflicts/it causes BC breaks/the syntax is not appropriate/the feature is not well understood/some thinks that the feature will benefit only a few/some think the feature could lead to bad practice, … Having a first step debate, separate of those fcking annoying remarks on how "the patch will affect performances" (even though it has been proven wrong 10 times already), would be positive. It's like **a first step, to decide, yes or no, the feature could be part of PHP**. Then, if someone wants to implement it, then fine. Else, it's in the "accepted but not implemented" pool, so if someone really want it, either they try to contribute, either they pay someone else to do it (maybe some companies would be interested…). Heck, I would even give 100 bucks to a fundraising project to pay a C dev to implement some awesome features into PHP. If others follow (like a kickstarter or something), we could go far. And as it has been said already that there are other ways to contribute than to code. Just thinking about a feature, scratching your head, thinking about the edge cases, choosing the best syntax, thinking how it could be the most useful, etc... That's contributing too. People using PHP everyday have ideas. Let's hear them out. Maybe this welcoming climate will be very motivating for new devs to learn C and dive in the internals. ---- Also, please make this happen! And thanks!
This is basically what I started doing, just putting an application together as best I can, with sometimes some really really ugly code and later I plan on slowly redoing it.
&gt; Each certification level consists of approximately 15 modules ($500 per module). $7500 for "complete" certification for something not typically accepted by the industry? No thanks.
This is not a sponsorship of this program, but thephp.cc is a group of 3 consultants that includes Sebastian Bergmann, the author of PHPUnit and Arne Blankerts, the author of phpdox. I can't say I know who Stefan Priebsch is, but those two know their stuff. If not for the certifications, the training they would provide may interest you. 
 if ( isset($_REQUEST['option']) &amp;&amp; $_REQUEST['option'] === 'com_users' &amp;&amp; JFactory::getApplication()-&gt;isSite() &amp;&amp; ( ( !isset($_REQUEST['task']) &amp;&amp; !isset($_REQUEST['view']) ) || ( !isset($_REQUEST['task']) &amp;&amp; isset($_REQUEST['view']) &amp;&amp; $_REQUEST['view'] !== 'login' ) || ( isset($_REQUEST['task']) &amp;&amp; !in_array( $_REQUEST['task'], array( 'user.login', 'user.logout' ) ) ) ) ) {} Holy shit!
PDO takes care of that mostly.
Can you explain how the voting process works? Can anyone who maintains a project/package vote?
oh yes. built-in websockets would be SO good. yes, you could use ratchet or reactphp, but built-in would be nice.
Man, I am behind the times. I thought this was a standard already. Honestly I think PHP should have a standardized class path similar to Java that's dealt with internally, and we can be done with this auto loading nonsense all together. I'm getting tired of writing or importing the same boilerplate code into my projects. I've got to write my own auto loader, write my own error handler, get my own cup of coffee. It's annoying.
I demand a better logo. Seriously, they have not updated the thing since PHP 3.
&gt; I've got to write my own auto loader http://getcomposer.org/ 
Wow, it's like you didn't understand my original comment or something...
Read the sample and bought the book. Looks like a neat with useful examples, not only words :). Leanpub is great in what it offers various formats. I go for PDF on my computer and epub on the iPad. Don't use Kindle - it will screw your code with its two columns layout
&gt; I'm getting tired of writing or **importing** the same boilerplate code into my projects It's a sad state of affairs when something as banal as auto loading creates project dependencies.
&gt; object literals [There's an rfc for that](https://wiki.php.net/rfc/objectarrayliterals). Hasn't been updated in a while even though array literals are a part of 5.4 now.
PSR-0 was an autoloader standard written in 2009. PSR-4 is an autoload standard written in 2013.
Proper meaning what? [DOMDocument](http://php.net/manual/en/class.domdocument.php) has always met my DOM parsing needs.
One of the solutions, that I have seen is this: you use one specific application as an example throughout the book/tutorial/lecture. This way you can focus on specific aspects of it, while providing the reader with solid grasp on the context, problems and benefits. It also provides you with something like roadmap, because it makes clear that *"reader needs to understand C, A and B before you start explaining X"*
Composer is a dependency manager that will also autoload those dependencies. If you don't want dependencies, don't use a dependency manager. Autoloading is baked into every framework, and PHP itself. There is an "old" autoloading standard you can already use (with a sample autoloader which saves you that boilerplate) and there is a new one on the way. Your complaints currently seem to be based on nothing but confusion.
 $headers = "From: email@example.com\r\n" . "Reply-To: email@example.com\r\n"; mail($recipient, $subject, $body, $headers);
or you could .. you know .. [read the manual](http://php.net/operators). Trust me, all the operators are in there.
&gt;get my own cup of coffee man, you need interns!
There is probably a git plugin for Jenkins that needs to be installed. This will allow you to do a git checkout as one of the steps of your build.
Oh Phil, just stop. I'm not confused over anything. I was using PHP long before __autoload hit the scene, and I'm more than knowledgeable of Composer. PHP does not, and has never had built in auto loading. I think you are confusing our ability to write an auto loader with auto loading being "built in". If you had read and understood my reply you wouldn't be pointing out frameworks, as I'm making it clear I wish to have true auto loading sans-framework and without the need for special libraries. Auto loading has become an indispensable feature over the past five years, and I think it's high time auto loading is baked into the language in the same way it's baked into Java. There is no standards committee deciding on directory structures for Java auto loading, because there is only one way to structure directories in Java, and the auto loading is handled auto-magically by the runtime. I don't want your sample auto loader. I don't want PHP-land code at all. I want C code baked into the runtime that auto loads. Understand now?
I was really just opening my statement with some self depreciating humor, but thanks.
Sure, that's a great way to do it — and to be clear, you don't really care if that specific example is cliché? Another blog, or forum, or a facebook clone...
[Part 2](http://www.youtube.com/watch?v=Rn-MiHstYho&amp;list=PLp6xQ3fl72zK3aSXWWXcQkZaQJBi90p3c) - Video [Part 3](http://www.youtube.com/watch?v=i1-gd-Ph9iY&amp;list=PLp6xQ3fl72zK3aSXWWXcQkZaQJBi90p3c) - Video [Part 4](http://www.youtube.com/watch?v=Kc7wqIBj7sQ&amp;list=PLp6xQ3fl72zK3aSXWWXcQkZaQJBi90p3c) - Video
I would be interested, if this where to be a certification that is treated equal to say a university degree by industry.
I won't agree to it being correct, but I will agree that it is "correct". http://us2.php.net/manual/en/language.types.array.php#language.types.array.donts
Legacy code will always present this type of problem. Also, logically, there is nothing wrong with double equals in practice as long as you understand your comparisons.
I've seen it before but it's been mostly ignored so far, sadly. Arrays literals were implemented and php devs called it a day.
Okay, my post up there was in fact not very php specific. Just recently I started getting acquainted with angularjs. And every fucking tutorial out there does the "Let's to a todo list" demonstration. Which is great for showing how angular uses two way binding and controller and models but lets you hanging high and dry as soon as you try to do something real. because none of those tutorials tell you anything about data persistence, how communication with a server might be handled etc. So ... I don't really care if you do a "blog" example, or a "forum" example, as long as you do it COMPLETELY and with ALL the aspects relevant. And those include authentication, data persistence, communication between frontend and backend and everything else I can't think of right now. When at the end of the day I can take your complete example, add some bells and whistles and can take it online and use it without someone saying "Hey, there are some glaring omissions", then I'd say it is an okay example.
I've played around with CodeIgniter a bit. The thing is i'm "joining" a project that's already being developed on the Yii Framework. I have an idea of how the MVC model works but my skills in OOP aren't that good. Do you know any good stuff on OOP?
How's something like this? function get_warranty($tire_description) { $warranty_miles = substr($tire_description,-3,2); if (! is_numeric($warranty_miles) ) return 'Please contact for more information'; if ($warranty_miles == 0 ) return 'No Mileage Warranty'; return $warranty_miles . ',000 mile warranty'; } $warranty = get_warranty($tire-&gt;description); 
Also in /r/programming http://www.reddit.com/r/programming/comments/1mo7o4/cover_your_php_legacy_code_with_thousands_of/
I was joking. Well sure in so many years you'll go look at the docs. But something I realize (that maybe others havent) is how you can just go to php.net/function_name_here It's not a big deal. In all seriousness I do look up function signatures often. In fact I'm more interested in return values (null vs false most of the time)
The single biggest issue I've run into with Nginx is antiquated Russian forums being the top google search result for various issues. Be ready to do a lot more digging to answer your questions than you would with Apache. Other than that, in addition to being less of a resource hog, I find it to be better thought out than Apache. 
[maybe this](http://net.tutsplus.com/tutorials/php/object-oriented-php-for-beginners/)
ooooohhhh. I wasn't giving Jenkins enough credit. I thought you had to do the cloning yourself in the build. Having Jenkins do it makes so much more sense. Thanks
&gt; Do you want to cover your legacy code with thousands of automated unit tests in just few lines of code?!.. No, not really...
This is what it looks like when someone thinks all PHP-land code can be standardized into a generic run-time auto loader. The real world is inherently more complex. The rigidity of Java is why I don't use it.
What's the point of even telling us before the fact? None of us can vote or have any hope of over being able to vote. This is why we have such controversial decisions as PSR-2's: &gt; * Code MUST use 4 spaces for indenting, not tabs. Because programmers love inefficiencies like using 4 bytes where one should suffice. 
Posting to read later
meh . 3 bytes here, 3 bytes there .. I bet you put curly braces on the same line as your returns too
You'd have a point if this had anything to do with how the syntax looks to a reader. A single tab character doesn't actually change the way the code looks at all. Only how it's encoded.
Your complaint was about having to write boilerplate, but you don't as somebody else has in all cases written it for you. How would you go about baking it into the core? Shove PSR-0 or PSR-4 in there somewhere? There was an RFC for that, it didn't get voted in.
Nobody cares about tabs v spaces. The Python community isn't crying about it.
SEO 101: Post an article comparing programming languages with a link-bait title.
So obviously your first statement makes no sense. If no one cared it wouldn't be in the spec at all. It also wouldn't be the [top comment](http://www.reddit.com/r/PHP/comments/tyzcq/psr1_and_psr2_to_be_approved_as_standards/c4qx6l6) in introductory PSR-2 post to this subreddit. Finally, PHP is not Python. &gt;No one cares about ... This is an example of a logical fallacy used to avoid the merits of an argument.
Sorry dude, It didn't come across. I thought you were just being an ignorant fuck like [this guy](http://techblog.stickyworld.com/abandoning-php-for-python.html). Sarcasm on the internet is hard.
I am not sure if you can call the generated tests 'Unit tests'. Apart from that, here are some questions for you Doesn't refactoring involves changes in the input output of lot of intermediate functions used in deriving the final result. How does this deal with that? What if I rename a function? What if I remove a function altogether? How do you manage dependencies when running tests? I don't know, but legacy code may not depend on classes for their functionality and I am surprised that you expect legacy code to contain an auto loader. EDIT: and what about the database dependency. getNameForUserWithId(5) returns "Jack" yesterday. Today It returns "Jill" because someone edited the username for that user. So error??? 
Yii is a decent framework. You will learn a lot of good principles. Don't be afraid to dig into the source code and see what is going on under the covers. 
&gt; My first statement makes absolute sense. This is an example of what turns most people off from contributing to FIG and Internals. Person A brings evidence in the form of ... well [evidence](http://www.reddit.com/r/PHP/comments/tyzcq/psr1_and_psr2_to_be_approved_as_standards/c4qx6l6). Person B says evidence doesn't exist and down votes Person A. No logic. Just arrogant dismissal of the argument. [Obviously](http://www.jwz.org/doc/tabs-vs-spaces.html) [no](http://www.codinghorror.com/blog/2009/04/death-to-the-space-infidels.html) [one](http://programmers.stackexchange.com/questions/57/tabs-versus-spaceswhat-is-the-proper-indentation-character-for-everything-in-e) [cares](http://c2.com/cgi/wiki?TabsVersusSpaces) [about](http://jarrodoverson.com/blog/spaces-vs-tabs/) [spaces](http://lea.verou.me/2012/01/why-tabs-are-clearly-superior/) [versus](http://stackoverflow.com/questions/14281270/indenting-with-spaces-vs-tabs) [tabs](http://forums.xkcd.com/viewtopic.php?f=40&amp;t=15328). Also with the whole Python thing. A) It's a whitespace sensitive language down to it's core. B) It's not a C-like language so why bring it up? Spaces versus tabs is a topic specific to non-whitespace sensitive languages. Bring up Python is just punting the discussion.
I've never heard any complaints regarding the Java class path, short of inexperienced Java developers not understanding it at first.
Well, you kinda-sorta can... class foo { function __construct() { $this-&gt;{'and'} = function($x) { echo $x; }; } } $foo = new foo; $and = $foo-&gt;and; $and(1); (Please don't ever really do this.)
Resource hog? I had thought one of its selling points was that it was more efficient than Apache. Guess I was wrong...
An easier (and less spammy) way would be to hit "save" underneath the post. Then later, click on your name to go to your user page (/u/Headchopperz) and then click on ["saved links"](/u/Headchopperz/saved/).
he said "less of a resource hog". As in, less than Apache. So you were correct, it IS more efficient than Apache.
I think they're jumping the shark here, isn't SO a Q&amp;A site? I know I've seen many, many 'questions' closed because _"not a question"_ etc. So it's funny that it seems to be more of a _'do as I say, not as I do'_ mentality... it's ok if they post a non-question, just don't try it yourself. SO has some very strong strengths, but acting as a manual or wiki isn't one of them.
Oh, I'm dumb. Thanks :)
They specifically moved this post into a "wiki" status, so they have created functionality for it. I've also seen some very good wiki posts on SO. It seems the best are the ones that are informative yet concise. Here's an example http://stackoverflow.com/questions/2794016/what-should-every-programmer-know-about-security/2794089#2794089 Here are a few others from my favorites http://stackoverflow.com/questions/194812/list-of-freely-available-programming-books/ http://stackoverflow.com/questions/1396191/what-should-every-developer-know-about-legal-matters/1463552#1463552
&gt; In fact I'm more interested in return values (null vs false most of the time) Another inconsistency... And even if looking up functions is not a big deal (it doesn't bother me too much), it's still broken and could be improved a huge amount. But like I said, the devs don't care.
Both Java and Python support multiple class paths. I mean, they wouldn't even work without that, as classes may be installed in your application directory, and a system directory somewhere, and so on.
Yeah I know, but it's still hypocritical IMO, and sends a mixed message.
Isn't that more akin to include paths? Another issue is inconstant filenames. One script might use $ClassName.class.php and another might use $ClassName.php One valid thing that needs to be resolved in PHP is traits being treated as classes with the autoloader. PHP allows a trait to have the exact same name as a class but the autoloader method has no idea if it's trying to load a class or a trait.
&gt; Isn't that more akin to include paths? Yup. &gt; One script might use $ClassName.class.php and another might use $ClassName.php Valid point. &gt; the autoloader method has no idea if it's trying to load a class or a trait. Does it need to know the difference?
You want to just link to a few people who complained about using spaces as argument. That is not supporting evidence, that is just proof that people ague on the internet. As with the whole Python thing, you said this: &gt; Because programmers love inefficiencies like using 4 bytes where one should suffice. A) spaces or tabs have nothing to do with the language down to the core. It was implemented as part of PEP-8, a style guide, like PSR-2. It's the same thing. That style guide was agreed with by so many "programmers" it was ratified and made official. Many in the PHP community however would rather complain. I thought the contrast was interesting, and relevant. B) You said "Programmers", not "Programmers of C-like languages". I see absolutely no reason to differentiate here, but I'm sure you'll enlighten me. You are not the first person to argue about tabs v spaces. I used to use tabs. Now I am happily using spaces. The reason I dismiss this argument is because neither side is right, and neither side will ever be right. There is no _right_. It was A or B. B was picked. Everyone who used A complained. If we picked A, everyone who used B would complain. I used A. Now I use B. You know what? It never made a difference to my life. I still have all my fingers and I've not developed RSI. Tabs v Spaces is a religious debate, which is why I use phrases to shut the argument down. Somebody trying to say A is better than B is like trying to convince a devout Christian that Islam is "better", or vice versa. 
I think it should because if the name of the class and the trait is the same there's no way to to know which to include in the autoloader function. The two "solutions" at the moment: * Including the file containing the trait definition at the top of the class using the trait so that using the trait in the class won't trigger the autoloader. * Have the autoloader include both the trait file and the class file (if file exists on both) in the first instance of either triggering the autoloader so that the autoloader isn't triggered when the second of either are encountered. Not doing so could cause a fatal error. For example class Email gets loaded first and then a trait Email needs to be included at some point down the line to be used in another class. The trait load in the typical autoloader scenario could cause the PHP to run the class definition twice and therefore fatal error out on the second run. One other option is to check if the class has already been defined with class_exists().
Unfortunately no one chose the obvious with down the middle splits like this: * C - None of the above. Sometimes you shouldn't force a decision one way or the other.
Here are [Anthony Ferrera's](http://blog.ircmaxell.com/2011/11/on-psr-0-being-included-in-phps-core.html) opinions on it being baked into the core. I was not involved in the FIG when the decision was made to try and bake it in, but I am glad they didn't, for a few reasons. 1.) As Anthony points out it is inconsistent. There is this [oddity](https://github.com/philsturgeon/psr0-naming-oddity). 2.) It was modeled after existing usage, i.e PEAR, ZF1, Horde, etc. They're no longer really a thing. 3.) Baking in PSR-0 would make it MUCH harder to deprecate in the future. It would essentially have to last FOREVER. 4.) PSR-4 is now a thing. That would not be possible if PSR-0 was in the core. I have to wonder though, what is the real issue? Beginners these days are being ushered towards Composer or frameworks, which handles this for them. This as you say is a dependency, but (genuine question) how often does a total beginner to PHP build something entirely from scratch (no existing file structure at all) and then try to use pre-packaged code which is not available on Composer? I'd have to say that now compared to 2, 3 or 4 years ago that is REALLY unlikely. And if you're not starting from scratch, your dependency _probably_ handles autoloading for you. Right? It would be NICE if Composer-like packages were supported as well as Gems were, or Python packages were, but that would need a whole module system which IMO PHP just is not ready for. The FIG is trying to make the best of the eco-system _today_, not dream up solutions for making PHP better itself. That is a job for the internals team. :)
pretty much everything a functional programming language has. 
Maybe the advertisement gives too great expectations, but i think it's pretty cool that you can see the effect of your changes programatically now.
If you're writing a style guide then the entire purpose is force a decision one way or the other. We chose to ignore things like "this is how you do concatenation" and other trivial crap, but you cannot argue the fact that consistent whitespace is important. Any style guide will tell you to be consistent. As long as you pick A or B then you're going to have a joyous consistent experience, but if you let anyone do what they want with indentation then you have a truly f**ked up file. Every pull request screws things up, some IDEs automatically format things leading to 100% red/green pull requests, nothing is indented right and its a joke. I say this as a developer who has been involved in reviewing pull requests for things like CodeIgniter, PyroCMS, FuelPHP, etc, as well as using git and subversion for a decade. Inconsistent whitespace is a NIGHTMARE. PSR-2 says use spaces. The simple answer is if you don't want to follow PSR-2 then... you don't. Use PSR-1 and do whatever the crap you like in your files. Thats not a cop-out, that is exactly what you should do.
Yii is pretty great, but from experience, it takes a TON of effort to be able to use it effectively. Most other MVC frameworks like Slim, Laravel, CakePHP, Fuel, and Silex take little effort to get started right away. That's my take on it, anyways.
I don't do this often, but I'd like to take a moment to apologize about my tone in this thread. PSR-4 has been a long and troublesome road. It was nearly voted in 3 months ago and has since been through all sorts of attempted re-writes, alternatives, arguments and other madness. I posted a [heads-up on Reddit](http://www.reddit.com/r/PHP/comments/1kvr1f/the_new_autoloading_standard_psr4_passes_entrance/) to get feedback and to avoid the outrage of hundreds of developers for not having their opinions heard, so they could get feedback in during the Draft or Review stages. Still, there are complaints. Annoying. I then put it to a vote on the FIG ML and immediately people started giving feedback over there, after it had been in Review for a MONTH. Incredibly annoying. The whole thing has been hard work, and it's showing by me acting like a c**t in this thread. It's not ok, and I'll try and avoid any further attitude.
Just to be clear, because Anthony is talking about something slightly different, and I think you are too, I'm not suggesting we need a standard autoloader or extension. I'm saying auto loading should no longer exist in the same way Java and Python have no concept of an auto loader. I'm also not suggesting we follow any PSR standard. Any discussion on baked-in auto loading would begin, "Lets discuss a standard class path", and not, "Lets add PSR-x to the core". While we're on the subject.. I respect the work FIG is doing, and I'm happy to see standards being set, but they kind of fucked up with the PSR-0/4 issue. There's a reason standards created by other organizations (ISO for example) take *years* to hammer out. I read the Google groups post you submitted a couple days ago that basically started, "It's been the required two weeks. Lets vote." and my first thought was, "Wow! A ***whole*** two weeks." I understand you guys discussed the matter at greater length, but you seem to be moving way too fast. &gt; Beginners these days are being ushered towards Composer or frameworks, which handles this for them. Do you really believe that? New developers who are still trying to grasp the concept of classes, and even functions, are certainly not ready for Composer, nor do I think anyone is trying to push them towards Composer. When you say "beginner" what you really mean is "advanced beginner". The same goes for version control and unit testing. These are slightly advanced topics which are impossible to understand until you've grasped the basics. If anything having a standard class path could reduce the Composer learning curve. &gt; how often does a total beginner to PHP build something entirely from scratch I would say beginners build from scratch *everytime* because they don't know any better and they're not ready for frameworks. &gt; and then try to use pre-packaged code which is not available on Composer Beginners don't even know what pre-packed code is, so they certainly wouldn't be using Composer.
What framework would you recommend to a newbie?
&gt; Just to be clear, because Anthony is talking about something slightly different, and I think you are too, I'm not suggesting we need a standard autoloader or extension. I'm saying auto loading should no longer exist in the same way Java and Python have no concept of an auto loader. Understood. I feel like we were merging two conversations into one and I mostly just replied to the PSR related stuff - based on my description of what the FIG is trying to do. I guess regardless of what is "best for PHP as a language" the FIG still has to do its thing, and PHP are doing theirs. But yes, I agree that not even requiring autoloading, and some sort of Python-esque system would be **awesome**. &gt; "It's been the required two weeks. Lets vote." and my first thought was, "Wow! A whole two weeks." Absolutely not the case. PSR-4 has been in discussion for _months_. It was nearly voted in by a majority until some last minute change put the vote back, then everyone started arguing around in circles about other implementations. This is why the new workflow was created, to allow Draft, Review and Accepted to happen. So PSR-4 was _this time_ in Review for one month, but had been discussed for months and months before that. tl;dr: Not a rush job at all, it just looks that way if you're unfamiliar with the recent switch in the FIG workflow and the history of PSR-4. &gt; Do you really believe that? New developers who are still trying to grasp the concept of classes, and even functions, are certainly not ready for Composer, nor do I think anyone is trying to push them towards Composer. Your initial description makes it a little more clear what you mean. My assumption (which I still feel is fair) is that people are not really trying to autoload third party code without using Composer. Your point (also fair, which I hadnt really thought about) is that they need to autoload their own code too. Again, this is covered for you if you're using a framework as the structure and autoloading is already set up, and I genuinely believe the majority of new PHP users use a framework. I don't have numbers on that, but 10+ years of talking to people at user groups, conferences, forums, reddit, etc really lead me to feel that way. &gt; I would say beginners build from scratch everytime because they don't know any better and they're not ready for frameworks. Agree to disagree, based on the above :) &gt; Beginners don't even know what pre-packed code is, so they certainly wouldn't be using Composer. Anyone who looks at NetTuts, PHP The Right Way, or uses a framework is being pushed straight at Composer, so I'd assume they are most likely to use packaged code and tie into that autoloader at the same time. Your milage may vary, but this is what I see around me every day with the people I talk to.
didnt know about it, but not as good as what python have.. plus if i have dont readline support (obviously i dont cause im on windows machine), it would be cumbersome to make it run.. make it as easy as python interactive shell..come preinstall out of the box
That's part of the issue I have with how they are handled. You shouldn't be inserting the type of an object into it's variable name. You don't name variables StringName. Why should you name traits like that? For example lets say I wrote two controllers that both need a shopping cart. I can then write a single trait named "ShoppingCart" that would be called from both of them. It's silly to call it "TraitShoppingCart". The autoloader should know what type of object it's loading. It could be a function, a class, or a trait.
When did you try it? From what i've read it wasn't that good when it started but now they've improved it a lot.
The only slight problem I've run into is a type of "Apache blindness" from people who have only used Apache. And there are a lot of them. I may begin describing to a colleague a problem I'm having, "So I use nginx and I'm having a problem with x.", at which point they reply, "Oh, just put x into your .htaccess file." When I explain .htaccess is strictly an Apache thing, that doesn't exist in other http servers, they fall silent and look dumbfounded. Besides that small issue the switch from Apache to nginx is fairly painless.
The whole reason I'm even bothering to make a stand on this one is because I see spaces as being a pollution on the entire PHP codebase in two ways. * Quadruples the file size expenditure on formatting white spaces in all files. * Removes the ability for customizing white spaces. I just frankly don't understand the desire to use spaces. It makes the style rigid and doesn't allow for the option in most editors to choose how wide a tab is. That's pretty much the antithesis of PHP which has historically allowed for customization much more so than most languages.
I mostly host on apache. I never use htaccess files, that s*** goes in the vhost definition where it belongs. nginx gets that right. :-)
and the insert with no validation straight from $_POST `$insert = "INSERT INTO users (username, password) VALUES ('".$_POST['username']."', '".$_POST['pass']."')";`
&gt; tl;dr: Not a rush job at all, it just looks that way if you're unfamiliar with the recent switch in the FIG workflow and the history of PSR-4. Yeah, I was just busting your balls. Although there still may be a need to slow things down a bit more until this whole FIG thing catches on. You're not likely to receive many contracting view points on a proposed standard, even within a few months time, because only a fraction of the PHP community is following you work. Which is probably where PSR-0 went wrong. The standard was ratified when all view points were expressed, but at the time there were few view points. Fast forward a year and people started coming out of the woodwork, "Oh, that would never work for my framework." &gt; Again, this is covered for you if you're using a framework as the structure and autoloading is already set up, and I genuinely believe the majority of new PHP users use a framework. I can only speak from my personal experiences, and the experience from trying to teach noobs *how to program*. Keep in mind there's a huge undercurrent within the PHP community of inexperienced programmers who are still trying to figure out how to email themselves the data from a contact form. Package management and frameworks are way over their heads, not to mention a bit overkill. But explaining a class named \Vendor\Foo\Bar would be found in the "src/Vendor/Foo/Bar.php" file is very easy, and in fact they need to understand that concept before moving to more advanced topics like package management and frameworks. Now, slightly off topic, but Rasmus has repeatedly said he wants PHP to appeal to those types of users, which is likely why he's always dragging his feet when it comes to big feature changes that would push PHP in line with Java and Python. He wants PHP to appeal to secretaries with no programming experience, and he wants PHP used by accountants without formal training. I'm pointing that out because we want the scripts (I won't even call them "applications") created by noobs to have structure and organization, both of which are learned skills. Skills that need to be learned before moving to frameworks. &gt; I don't have numbers on that, but 10+ years of talking to people at user groups, conferences, forums, reddit, etc really lead me to feel that way. You have to consider the audience. How many beginners do you expect to find at a programming conference? I'm kind of old school when it comes to teaching. I, for example, believe someone should learn to use a compass before learning how to use a GPS, and I don't believe someone should use a framework until they understand the problems the framework solves, which means writing a lot of code from scratch. From my own experience I wrote all my code from scratch until discovering Pear, and then years later discovered CakePHP, and if I could turn back time I would do it the same way. A standard class path would ease beginners into the idea of application structure without throwing a lot of advanced topics at them, and it would make life slightly easier for advanced users because they don't need to write or import auto loaders, or deal with package management on small projects.
What are your top 5 PHP Frameworks?
emphasis on "if at all possible" since it will take a while for most hosting companies to upgrade. IMO 5.4 is at a point where most hosts have upgraded but still allow a choice between 5.3 and 5.4 so I would definitely go with 5.4. I guess by 2014 many of these hosts will abandon 5.3 and give users a choice of 5.4/5.5. Having said that, I wouldn't discredit a tutorial for using 5.3 but I would definitely take the opportunity to learn what new features and syntax could be upgraded to 5.4 
htaccess is for user specific configurations (ie, non-root users). It has a place in a virtual host environment. Does nginx have anything that non-root users can use to customize (clean urls) or does the root user have to specify that?
With all due respect, this is not constructive.
I actually don't see anything really wrong with PSR-4. Just found it slightly amusing that you'd ask for public feedback so late in the game. After all, as you say, once they are accepted they are set in stone. For the record when PSR-0 came out I didn't even know about FIG. It's almost like it was a self appointment among the top devs who all had the ability to self impose it since they could get enough publicity. I generally have to write a custom version of PSR-0 for myself anyway so I expect much of the same going forward. Whether optional or not is really besides the point since a lot of the voting members run major libraries like PEAR, phpDocumentor, and SabreDAV. Which means I have to deal with the bloated files that come with those libraries. Assuming of course they follow all the PSR standards. Obviously I don't use spaces on my own code. ;)
Nice. Not enough deployment tuts for laravel on the internet.
Thanks for the long and patient replies. I enjoyed the conversation :D
Even assuming we had a class path. There's still one reason to keep the autoloader. Purely as a function that runs when a class is loaded. if(method_exists($class, '__classLoaded')) { call_user_func(array($class, '__classLoaded')); } Personally I think that should have been a magic function long ago alas I must use this for now.
Yeah… And what do you do when the legacy code doesn't even have functions?
&gt; Although there still may be a need to slow things down a bit more until this whole FIG thing catches on. You're not likely to receive many contracting view points on a proposed standard, even within a few months time, because only a fraction of the PHP community is following you work. The issue of "Ask 1000 people and you'll get 1000 answers" kinda comes up here. There used to be 9ish people in the FIG. Ask 9 people and you'll get 9 answers. The fact they got 1 standard out was amazing. Several months ago we asked 27 people and managed to FIGHT it down to about 5 answers, mostly because multiple of the other answers didn't make any f**king sense. Again though, a magical feat. Asking more of the community would have increased the noise, but I personally do not believe the signal would have increased along with it. I think we'd just be repeating the same conversations for another year and everyone involved would just drop out through lack of interest. Drupal, Joomla and PyroCMS all want to use this, so the longer we wait the further back the implementations will be. That doesn't help anyone. &gt; You have to consider the audience. How many beginners do you expect to find at a programming conference? Lots. :) And talking to people about HOW they learned, and about how their friends are learning, and they all start with a framework. How many JavaScript developers do you know who have started in the last few years without starting off with jQuery? I'm not saying its right, but I am saying its happening a LOT. &gt; Now, slightly off topic, but Rasmus has repeatedly said he wants PHP to appeal to those types of users, which is likely why he's always dragging his feet when it comes to big feature changes that would push PHP in line with Java and Python. Right, which is probably why we'll have to stick to external solutions like PSR-0/4. &gt; A standard class path would ease beginners into the idea of application structure without throwing a lot of advanced topics at them, and it would make life slightly easier for advanced users because they don't need to write or import auto loaders, or deal with package management on small projects. Definitely. I'd love it, but I'm happy enough with how things are for now. :)
You're not listening. It was not announce late in the game: http://www.reddit.com/r/PHP/comments/1kvr1f/the_new_autoloading_standard_psr4_passes_entrance/ I was not part of the FIG when PSR-0 happened, but you're fundamentally confused on how it came about. The FIG is a group of developers who made some standards that most of them intended on using (when possible). As such they can do what they like and implement them if they like. If other people like them they can implement them, but we're not a bunch of egos bullying people into using standards. THIS is why I get frustrated when people complain about tabs or spaces, because NOBODY IS TELLING YOU TO USE IT. Said in caps for emphasis, not rage. Understand, if you like this stuff you can use it. If you don't then don't. If you'd like to get involved in the conversation then join the mailing list, otherwise you have two options: accept it, or complain in comment threads. As for issues with other peoples code, as I said, opcache means that difference is entirely irrelevant. Unless you're worried that the extra kb's are going to fill up your HDD.
&gt; The issue of "Ask 1000 people and you'll get 1000 answers" kinda comes up here. Ah, the pitfalls of being on a standards committee. I can only imagine what the core devs go through. That's why I generally support the C patch requirement on RFCs. They create a barrier to entry that keeps crackpots away, and if you really feel passionate about a feature request then you can take your own time to drum up support among C programmers. That being said a patch isn't the only way of creating a barrier. &gt; How many JavaScript developers do you know who have started in the last few years without starting off with jQuery Lots, because real beginners have no idea what a jQuery is. "Is that some kind of database thing, because I'm trying to learn Javascript." I don't know about you, but my CompSci 101 class was still teaching Basic, and stuff like frameworks, unit testing, and version control were not on the menu. I really think you're describing an advanced novice. Take [this guy for example](http://www.reddit.com/r/PHP/comments/kdzqr/why_should_you_use_a_framework/). He was using PHP for years before landing a full time programming job and ***then*** started to learn frameworks. His story is typical, and you'll find plenty more like it by [searching](http://www.reddit.com/r/PHP/search?q=framework&amp;restrict_sr=on) through /r/php: &gt;&gt; So, I've been coding with core PHP for ***about 5 years*** now. I would consider myself very proficient with PHP, but I haven't learned any frameworks at all. In which ones should I invest time learning? http://www.reddit.com/r/PHP/comments/cl3xw/what_frameworks_should_i_learn/ &gt;&gt; I know there's a lot of PHP frameworks out there but I'm looking for one to build my web app in. I have a limited amount of knowledge of frameworks but I have used PHP ***for years***. http://www.reddit.com/r/PHP/comments/ista4/good_php_framework_for_making_a_web_app/ &gt;&gt; I've got PHP somewhat down, and would like to start building a website, preferably through a framework (***i've built websites on php before so, this is not new to me***), however frameworks have proved to be somewhat confusing to me. http://www.reddit.com/r/PHP/comments/qlbyo/are_there_any_php_frameworks_out_there_that/ &gt;&gt; Hello Reddirors! I'm currently learning php and mysql. I have experience with other programming languages so i thought I'd try something web-related. Learning the basics wasn't hard and ***i have managed to build a couple of easy things***. As I was reading through this subreddit, I notice a lot of you talk about frameworks. I am ***used to do everything from scratch***, so here is my question, why should we use frameworks? http://www.reddit.com/r/PHP/comments/mysab/question_why_should_we_use_frameworks/ I could probably hit the 10,000 character limit quoting semi-experienced PHP users with no knowledge of frameworks. I think your supposition about the use of frameworks among beginners is just a bit off.
There's no way for non-root users to do rewrites, unfortunately. I had heard about a project to make .htaccess 100% compatible with nginx, but as far as I know, it was never implemented.
Well, type names and variable names aren't the same thing. I mean, "string" is a type name, and look. It has the word "string" right in the name. ;)
Thank for the info. 
Yeah, sometimes I think PHP should have forked a long time ago. The super-noob niche still needs to be filled, but experienced developers don't want to use a super-noob language. More than anything I'd like to see some application level logic built right into the language. I mean, even plain Java and Python have a default application structure.
doesnt the save require RES my phone cant do that
No, that is not the only reason for interfaces. Interfaces allow for polymorphism. What that means is if I have an interface, say Die, and I have several classes that implement that interface, say SixSidedDie, TwentySidedDie, TwelveSidedDie, etc, then those classes can be used interchangeably. Thus, if I have a game that takes a die, and that die is set something like this: function setDie(Die die) { $this-&gt;die = die; } Then because the function argument has type "Die" I can pass in any of my die classes and they will work. This is also useful when it comes to testing because, for instance, I could have a MockDie class that I could pass in instead for testing purposes. Also keep in mind that interfaces don't even have to specify methods that a class must implement. Serializable in Java does this. Having a class implement Serializable doesn't make you add any methods, but *does* allow anything that requires a Serializable class to use it. Generally, though, your interfaces will specify methods to be implemented. As far as interfaces being a Java thing, well, they're actually an OO thing in general: Java, C#, Objective-C, PHP, etc. 
I'll go with a more real world situation since Laravel 4 does something like this: interface DBConnectionInterface { public function connect(); } class MySQL impements DBConnectionInterface { public function connect() { } } class MsSQL impements DBConnectionInterface { public function connect() { } } class PostgreSQL impements DBConnectionInterface { public function connect() { } } First benefit is forcing them to have connect methods, and second benefit is: class Something { public function something(DBConnectionInterface $something) { } } So, that typehint would allow all of the above classes to be passed, since they're an instance of DBConnectionInterface? If I understood this one correct, is there any more benefits of using interfaces? This usage sounds very logical. Also, if you show me a real world usage, I'll easily understand it. :)
That question is 3 years old.
Just an interesting note, PHP is one of very few dynamically typed languages that have real interface support (Ruby and Python both don't.) the argument for this is that in a dynamically typed language, as long as the method you try to call is there, the receiver doesn't care what the underlying type is. Maybe it's just a holdover feeling from working with statically typed languages like Java and C#, but I really like having proper interfaces just as a source of documentation even though you don't truly need them in PHP. The way it's done in Ruby and Python makes me very uneasy.
Since you ask about other languages: one of the delightful things about Go is that you don't have to declare specifically that a type implements an interface with the 'implements' keyword or the like. Instead, if the type defines all of the interface methods, it's considered to satisfy that interface. So you can type hint via the interface easily, and there's no hard-coded dependency on the interface definition. One of the consequences is that you can define interfaces very freely even for source code that isn't your own. You specifiy that the `Printer` interface has a `Print` method, and any object anywhere that has that method with the right signature now satisfies that interface. This is quite liberating, as it makes you focus on what a type *does* rather than what it *is* in the context of your application. There's no inheritance either in Go, so behaviour is built through composition and many small interfaces that decribe it. It's a different approach, and very refreshing. 
On a more constructive note, unit testing legacy codebases usually is not the way to go. They would be better served with functional testing, with new or refactored code being done with unit tests. The reason for this is because legacy codebases do not normally lend themselves to being able to be properly unit tested due to class setup, large amounts of procedural code, globals, and other things like tight coupling of components. Functional testing like Selenium or something similar will produce better and more meaningful results. New code can be properly constructed, and refactored code can be evaluated add to whether or not functional or unit testing would be better. Unit tests are not a magic bullet, just a tiool at should be used at the appropriate times. 
Why not test your software in the same way as your targeted audience would use it? I've never understood this madness, it seems like a huge waste of time and honestly just a reason to jack up your invoice line items and costs. Someone who unit tests is going to get mad right now. Does unit testing improve your productivity? Lower costs? Increase code readability? Furthermore, what kind of software is being developed in such a broken state that it requires unit testing right out the gate? Progressively develop and test the software as you go, it's not that difficult. I would make a better argument if I had actually done some unit testing, but I refuse to waste my time on it and would rather finish up my current project so I can move on to the next one. I'd be just as inclined to "cover my code with thousands of automated unit tests" as I would be to "cover myself with thousands of blood sucking leeches". Yeah, zero chance.
First and foremost, you use unit-tests to make your software reliable. They are not about end-user-experience. Unit tests are there to let you be sure that your software works as expected in any possible state and can neither be broken by malicious input nor by introducing a code-change. You do unit testing to avoid having to test each part of your software all over every time you change something. Ever had the situation when you made just a minor change to a file which was intended to affect a very specific part of your software but after a while discovered, it had effects on a seemingly unrelated part? Well, unit tests would have had that covered. Ever had some seemingly random fuck-up occur with just one user's input data and couldn't recreate the issue because the user just complained about an error but did not provide you with sufficient data on the issue? Well, unit tests are intended to catch these kinds of unexpected quirks, if written correctly. It seems as if either you never write software more complex than what you can scribble on one piece of paper, or that you never have worked on mission-critical software, even less with a team. Please do not let your ignorance be an argument against educating yourself. Just because you don't understand it, doesn't mean it's bad. TL;DR: Unit Tests =/= User Acceptance Tests, also: Unit Tests are good.
Its actually not that bad, the keyboard shortcuts are a bit weird, but it does work. I've never used XDebug in any other IDE so I can't say how well it holds up to other implementations.
All errors aside, I suggest using guides that are not older than 10 years.
I did look before posting my comments, but I didn't immediately find a tutorial that I liked before I ran out of time. In response to your original problem: You have a space between the "&lt;" and "?". **A simpler solution is to omit the action attribute completely. The form will automatically post to the same page.** A few things to look for when finding tutorials: * Run from tutorials that use mysql_* functions. Today we use Mysqli or PDO * Tutorials that store md5 hashes or plain text passwords. In PHP &gt;5.5 we have password_hash() and &lt;5.5 we have crypt() * Run from tutorials that use $_GET[] and $_POST[] directly in SQL queries. This leads to SQL injections. Using Mysqli/PDO correctly will solve that problem anyway. I do recommend http://www.phptherightway.com/ once you get a handle on PHP.
I haven't looked at the guide, but from what you have given, I would suggest the following: - Ensure there are no spaces between &lt; and ?, as well as ? and &gt;. It should be &lt;?=$_SERVER['PHP_SELF']; ?&gt; - You may have short_open_tags disabled. This is a php.ini directive that basically says &lt;?= is the same as &lt;?php echo. Assuming you don't have access to php.ini, try changing the code to be &lt;?php echo $_SERVER['PHP_SELF']; ?&gt; I hope that solves your problem.
I came to PHP from C# / VB.NET. In .NET, where the languages are strongly typed, you HAVE to use interfaces to achieve polymorphism. You literally don't have a choice. In PHP, interfaces are more optional since you usually just pass whatever you want into methods unless there is type-hinting. Type-hinting is required in .NET.
Hmm, so can you explain to me the reason you would use an interface, and not just a base class with abstract methods? Wouldn't this be nearly similar: class Die { abstract getSides(); } class SixSidedDie extends Die { function getSides() { return 6; } } class TwleveSidedDie extends Die { function getSides() { return 12; } } I guess I don't see the difference.. do you have any insight?
Because you can implement multiple interfaces, but you can only inherit from one parent.
Okay, cool, that's what I thought. Otherwise, these are the same as SixSidedDie will match type Die in both instances. Thanks!
&gt; I know you should only throw exceptions when you have a fatal error Hmm, I'm not sure that is a safe generalization to make. There are many instances where you want to use exceptions that don't result from fatal errors. At my company, we just rolled out a custom ORM/DBAL, and we make use of exceptions for anything. For example: class Parent { public function addChild($child) { if (!$child instanceof Child) { throw new InvalidArgumentException('$child must be of type Child!'); } $this-&gt;Child = $child; } } This is a valid use scenario for exceptions, that otherwise would not have thrown a fatal error. Or at least, it wouldn't throw a fatal error in this function ($this-&gt;Child can be set to anything.. issues may arise when calling methods on $this-&gt;Child if not of type Child though). EDIT: ' not ", yep. that's what happens when you answer something in 3 seconds :P
Exceptions aren't necessarily for fatal errors. You can write some great, simple code using exceptions instead of if/else spaghetti.
Okay--your example is a great example of of when to throw an exception. I have a few instances similar to your code where I should probably implement this. Now, in the class or script where you initialize Child, do you have a try/catch block?
Let's point out the right way in addition to criticizing the wrong way. Use [PDO](http://php.net/manual/en/ref.pdo-mysql.php). $query = $db-&gt;prepare("DELETE FROM `$trusted_table_name` WHERE id = :id"); $query-&gt;execute([':id'=&gt;$_GET['id']]); This is better because user input like $_GET can't be trusted - PDO and prepared queries protect your database against a very common threat called [SQL injection](http://en.wikipedia.org/wiki/SQL_injection) attacks, by escaping untrusted input. And if you're going to use a variable for your table name, make sure it's not user supplied, and/or strictly check it against an array of allowed values.
When something exceptional happens. Happy to help. e: Imagine you write an API function that other people are going to use. They pass in a parameter that you didn't expect -it's null, or the wrong type, or whatever. You would throw an exception because your function can not be reasonably expected to complete successfully. You shouldn't die silently or hide the error because that's really awful programming practice. So you throw an exception as a way to say "Hey, whoever's calling me! You screwed up! I can't do anything meaningful at this point! You decide what to do!" Using exceptions as a flow control mechanism is a good way to not pass technical interviews.
This is really interesting, but what happens when in this scenario (using PHP to illustrate): Taking your `Printer` interface, and a class that implements it, and something that requires it: interface Printer { function print($msg); } class MyPrinter /* implied: implements Printer */ { function print($msg); } function printSomething(Printer $printer, $msg) { $printer-&gt;print($msg); } Then you go *back* and change the interface: interface Printer { function print($msg); function smashToPieces(); } The class no longer implicitly satisfies that interface and the call to `printSomething` now breaks when you pass in an instance of `MyPrinter`. Doesn't this cause issues?
That is the question my dear Watson. Exceptions _everywhere_ is not a good thing. For example, as appealing is it may seem, do not enclose your entire application in one big try...catch block (I'm reminded of you, former VB programmers, with your On Error Resume Next.) Basically, if a problem occurs within a given scope, and that scope cannot handle it, it should throw the exception upward a level and onward until it can be handled or the program terminates in error. 
I think in this instance it would be impractical to wrap every object initiation and method call with a try catch block, and most likely you would have an [uncaught exception handler](http://php.net/manual/en/function.set-exception-handler.php) for those situations. Think of it as a global try...catch that catches anything that slips past your other try...catch blocks. The kind of exception used in titomb345's example would most likely be caught during testing, and in fact I'm a proponent of the ol' fashioned [assert](http://us2.php.net/assert) function for catching those types of errors, because once the error is found during testing it's not likely to ever happen again, and asserts can be turned off in production, which gives you back a little performance.
Another way of saying exceptional errors would be unexpected errors. "I tried to connect to the database and the connection was refused. That was unexpected." "I tried to open a text file and it didn't exist. That was unexpected." "The value passed to `setGender()` supposed to be 'male' or 'female' but instead was 'giraffe'. That was unexpected." I think you get the gist though. You would use exceptions when your code encounters an issue that prevents continuing with execution, and you can use them to guard input such as passing the wrong gender to the `setGender()` method.
Since your example basically wraps a conditional, you should really be returning true or false in your example. However, if someone passes an object or something non-scalar, you should be throwing an InvalidArgumentException before the if-statement. The alternative here would be to just return false.. Ask yourself how many functions have you created where you're returning false instead of throwing an exception?
Nitpick - ("$child must ...") would end up dumping the contents of $child (or the string representation, like "Object") into the string - you probably meant to use single quotes! 
I'm on my phone so I don't have the code handy, but I used exceptions for a custom site search that was a wrapper of the stock WordPress search (using WP_Query) and an availability calendar. Using exceptions, was able to keep the code very clean/simple, and passed exceptions back to the user "sorry, dates out of range" etc. without having deep conditionals. Just because it isn't necessarily the Right Way (TM) to use exceptions in PHP, doesn't make it wrong. The rather complex logic and return handling is incredibly simple to understand the way I wrote it using exceptions, so to me I consider it a fine use of them.
An interface is a contract. If your class implements an interface, it's promising to provide some functionality. For example, think of electronics. Many electronics have a button labelled "power". You expect a button labelled "power" to turn the device on and off. You can sort of say that anything from televisions to cell phones are implementing a "power button" interface. I.e. they promise their button labeled "power" turns the device on and off, even though a TV isn't a cell phone. Interfaces also allow you to do things with any type, no matter what it is, that implements this interface. For example, you could write a generic sorting algorithm that would work with an array of any type that implements some sort of "Comparable" interface (e.g. you can say if an object is less than, equal to, or greater than another object of the same type). This sorting algorithm doesn't have to accept only one type, it can work in general *with an object of any type*! Basically, you can write your sorting algorithm once and use it on an array of anything that implements "Comparable". If we go back to the electronics analogy, it doesn't matter what the device is. Your finger can always turn it off with the "power" button.
Okay, this makes really good sense. I can honestly say I've never thought about it this way before. :) After reading this, I realize I have a lot of methods that expect 2-4 specific things in the argument and I simply just go through a switch statement to find the right one. Honestly, nothing happens if the input doesn't match anything in the switch. It's never been an issue before because I've been very careful about what I pass in my functions, but I think this would be a superior way to handle even simple typos. I think this would be a perfect place to start put an exception.
I do believe that is a little too simplistic -- it really depends on the "contract" of the method. The whole point of that method seems to be to determine whether or not that number is less than 5. My general rule (which, admittedly, is a little vague) is that if something happens that is outside the scope or contract of the routine, throw an Exception. The php [SPL Exceptions](http://php.net/manual/en/spl.exceptions.php) are sort of useful for understanding why one might call a function. An example: function getSource($url) { if (parse_url($url, PHP_URL_SCHEME) == 'https') { throw new RuntimeException("don't use https"); } return file_get_contents($url); } return getSource($argv[1]); Another trick that I use is to write out an API, but not the function definitions, just to help me get a overview of what I'm doing and why. Instead, just throw an exception in the body of each function, and that way, as I TDD I know which function needs to be written next (sequentially). They are definitely something that has been inherited from Java, but, as PHP seems to be transforming into an OOP-dominated language, they're sort of helpful. There are a lot of rough edges that I hate about PHP and Exceptions in conjunction with extensive unit testing helps mitigate these.
You throw an exception when you have a condition where your code can't reasonably continue. This is usually because your code receives insufficient information, wrong information, or a resource is unavailable. A lot of code "works around" bad information. For example, if you had a function called `Divide()` then what happens when the denominator is zero? You could just return zero as the answer (which would be wrong) or you throw an exception. From your example: if the database connection fails, if the query fails, if sending the email fails, if the from address isn't provided, if the query string is blank -- all those are exceptional conditions where there's no way for the code to continue what it is supposed to do. My code is absolutely littered with "throw" statements. But they are rarely executed. If they are, that indicates a fault in the program or a connection error. One should have lots of throw statements but have only a few (or one) catch statements. You only want to catch where recovery is truly possible, otherwise just log and report the error. 
Many a switch statement has an exception waiting as the default. "The value was supposed to be found in one of the case statements, and here I am at the default statement. That was unexpected."
awesome, I will definitely check it out
I suppose this gives you the flexibility to catch the exception instead of dying of a fatal error. Unless you plan to catch it, generally I think this would be better. public function addChild(Child $child) {
&gt; You specifiy that the Printer interface has a Print method, and any object anywhere that has that method with the right signature now satisfies that interface. I'm not really a fan of that concept in general. If my `HTMLTag` class has a `Print` method that renders itself that doesn't make it a `Printer` in the "printing a document" sense (if that's the purpose of the `Printer` interface). But now they are polymorphically interchangeable. 
this would be neat if I could actually get laravel to work...
Wow... how do I even respond to that? Oh right, don't feed the trolls. I hope your day improves!
But isn't this better handled by type hinting, because if addChild is passed something else than a child object, then there is probably something wrong with the code, a bug probably. 
I throw an exception any time the function being called is either not capable of continuing or it is not going to return the expected results. If I have a function called "is_active()" and it returns a bool, if for some reason it cannot figure out whether the thing is active or not, i throw an exception. If I have a function called "load_config_file()" that read the contents of a config file, if it cannot find the file, or the file contained bad info, instead of returning "false" or "null", I throw an exception. In your example of "send an email", there are two possibilities: a) your send_email() function returns true/false based on the success/failure of the email being sent, in which case an exception is not needed. b) your send_email() function returns the content of the email, or possibly the recipients of the email; in which case, throwing an exception on failure, would be a good idea. The key advantage of an exception is the ability for the code calling functions that throw exceptions to decide what to do when unexpected things happen. If I try to create a directory and it could not be created, I can then handle that problem and do something else, such as possibly retrying. If simply throw a PHP error, there is no possibility of salvaging the situation in such a way.
If you must write unit tests because otherwise you'd have to test each part of your software all over every time you change something, you're doing something horribly wrong. &gt;Ever had the situation when you made just a minor change to a file which was intended to affect a very specific part of your software but after a while discovered, it had effects on a seemingly unrelated part? Well, unit tests would have had that covered. Yes and the time it usually takes to fix one of these bugs is *minimal*. If not you re-factor that part of the code. Did you break something else while re-factoring? Well then, I'd say your code is starting to look like spaghetti at this point and you'll need to re-think some of the main components and/or architecture before it gets worse. Do you have any idea of what the architecture is in the first place? Maybe that's the problem. I'd like to think anyway that my code quality has improved from when I first started programming. &gt; Ever had some seemingly random fuck-up occur with just one user's input data and couldn't recreate the issue because the user just complained about an error but did not provide you with sufficient data on the issue? Well, unit tests are intended to catch these kinds of unexpected quirks, if written correctly. Yes it's because I forgot to correctly sanitize the user input, not because my unit test was missing. How vague are the problems in your software that the user cannot even describe them, at which point or on what screen it happened, a log cannot be retrieved, and you cannot ask the proper questions to have the issue described in enough detail? &gt; It seems as if either you never write software more complex than what you can scribble on one piece of paper, or that you never have worked on mission-critical software, even less with a team. You could have easily clicked on my nickname to find that out. What qualifies as mission-critical software? You mean all software, where the developers are trying to earn paychecks and raises to support their families and quality of living? The mission is you my friend. &gt; Please do not let your ignorance be an argument against educating yourself. Just because you don't understand it, doesn't mean it's bad. I don't think it's bad, I just think it's a waste of time.
The whole project is such an eye sore in the code. They used the "comments" textarea to as a poor-mans-VCS with lines of *'s denoting dates and different versions &gt;.&lt;
Yes, I'm using ORM :) I am working on something more complex, yet still analogous to this case and am finding myself going back to writing raw queries. Thought I might be approaching it wrong or that perhaps this is just awkwardness that everyone deals with. Inelegant solutions bug me.
even if you are using an orm you can query using the location object itself. The query will return a set of package objects(not an associative array) which you can use. If you are using doctrine, then the query will be something like.. $packages = $entity_manager-&gt;getRepository('\Entities\Package')-&gt;findBy(array('location'=&gt;$locationObject)); '\Entities\Package' is the name of the package entity class, $locationObject contiains the actual location object and the array index 'location' is the name of location attribute of the package object.
It's rm -rf --no-preserve-root /
yes, these exceptions are mostly used in development. in production, these exceptions should never be thrown. we like to use exceptions for the flexibility and control over what is displayed to the developer.
yeah, these exceptions should only show up in development. they allow us to display a nicer message to the developer, rather than just displaying the standard error message. if they show up on production, we have an exception handler that will take care of them (logging, mostly).
awesome example code
Your db interaction classes should be capable of $packageLocationIds = $packages-&gt;locationIds(); // or $model-&gt;getLocationIds($packages); $locations = $locationModel-&gt;getAll($packageLocationIds); And if not you can implement it. *:&lt; Extract N foreign ids from the first query and make a single second query, not one at a time?
[@codeguy](https://twitter.com/codeguy) is the creator of PHP The Right Way :)
In the underlying table, package should contain a location. It is a one to many relationship as a package cannot be in multiple locations. Your ORM should be able to handle the bidirectional relationship fine: (for example) $package-&gt;getLocation(); $location-&gt;getPackages(); Package::findBy(array("location" =&gt; $location)); Edit: actually, rereading it, I think it should be bidirectional, so, underlying table you would have: Package &lt;--&gt; Package_Location &lt;--&gt; Location Package_Location would contain package_id, location_id and a DateTime. So that you store your full history there. And then Get the latest one out of it to get the current package location. Querying for all packages at a current location will be difficult with this model, but it is possible, and you could denormalise to add a current_location on the package itself, as above. But it's better to get the underlying structure correct first
&gt; Yes and the time it usually takes to fix one of these bugs is minimal. The point is not the time it will take to fix the bug. The point is that you will have to manually test the 10 or 100 process(depending on the size of project) that the refactored function is a part of. 
In idiomatic Go, you'd just create another interface `Smasher` with the `Smash` method. Now some objects satisfy both interfaces, and some only one, and in the context of your application you'd understand the difference (or you should). If you really needed to hint for both, you'd combine the interfaces in a new `SmashingPrinter` interface. Then you could compose a new Smasher object with a Printer object to create something that satisfies that interface, without using inheritance. This is just really the 'I' in SOLID: by segregating your interfaces in this way, you can focus on only the behaviours that your application is actually interested in, and without resorting to implementation inheritance. In PHP, you can only do this by duck-typing everywhere, which is less fun :) 
They also authorized my comment, after a few days. They have also added my credits at the end of their post too. As well as acknowledge a few of the other authors who inspired my post.
Thanks for a great answer — maybe it's time I spent some time with Go!
Why, I [use them for everything](http://e-mats.org/resources/ExceptionBasedProgramming.phps). They're the greatest invention since sliced bread!
&gt; Should a location contain a package, or should a package reference its location? Think naturally: what are the functionalities of your application? - If at some point, a user gives you a tracking number of a package, then you wont certainly not load all locations and browse all packages of all the location to find the one with the correct tracking ID. You will rather find the package by its tracking ID, and then get its location. So it makes more sense IMO to have `$package-&gt;getCurrentLocation()`. - If however, you offer a functionality to shipping companies to list all packages they have in their warehouse, then you will need `$location-&gt;getPackages()`. If you need both, make the relation bidirectional. --- About performances and the number of queries, I don't think that's really that important. If you display too many packages, then make a pagination, and the number of queries will be acceptable. If you do 11 queries to display 10 packages, I don't find it absurd. Premature optimization is root of all evil: do not let your model be completely crippled because you were afraid of the queries. But just so you know, Doctrine for example allows you to do a "Fetched Join", i.e. it will load "all packages and their current location" in one query: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html
For one, there are built-in interfaces that react to built-in PHP functions and keywords. For instance, giving the interface `Serializable`to a class changes the way an instance of that class is (un)serialized with `(un)serialize()`. Implementing the interface `Traversable` allows for that object to for for-eachable. Now regarding custom made interfaces... you can kind of use them as to mark classes as "being able to do something". If you are familiar with MVC, Zend Framework 2 makes some neat uses of interfaces. If you want to grab a new instance of a class that does stuff with the database (let's call it DbManipulator), and it implements the interface `DbAwareInterface` (with the method `setDb()`), then when you call `$this-&gt;getModelInstance('DbManipulator')`. The bit of code in `-&gt;getModelInstance()` goes $instance = new $modelName; if ($instance instanceof DbAwareInterface) { $instance-&gt;setDb($this-&gt;getDb()); } return $instance; Okay this isn't exactly how ZF2 works, but a rough estimate. So basically you can use interfaces for making unrelated classes "aware" of the same thing so you can test for the objects with `instanceof` to see if they are of a specific interface and do something special with the help of the mandatory interface methods to those objects.
This is correct. This also means that if you make/use your own database type and want to use it with Laravel, you just have to hook up to the corresponding interfaces and make sure you meet their expectations - rather than going through X rounds of trial and error.
Oh boy, someone didn't answer what I have to say, possibly my time to shine!!! I came from C++ development to PHP. When I was coding in C++, I was doing heavy optimization for real-time programming where you don't have time to waste cycles since another event is , shit, already there, wait, another one, hey, let me, shit, yet another one. So, you optimize, and optimize, and optimize your real-time handling and try to balance your tasks in 2 piles: urgent one, and pending ones. The urgent core needs to be a lean, mean running machine while the pending one, meh, it's for when events finally stop and you can catch up on the non-urgent stuff. Your learn over the weeks of stress testing that some functions are faster and some combinations faster. And then, you test exceptions. You see, exceptions code is weird. Everything is C++ is lean and optimized, and yet, exception are SLOOOOW. Really Slow. I cannot emphasize enough how SLOOOW exceptions are (ok, I am exagerating, but compared to the rest, wow, an exception is much slower than an else, for example) **Why? Because they are optimized to NOT slow down your program if they are NOT thrown.** Exception are designed to be used in extreme cases, and as such, as optimized to NOT cause problems and not to be fast. Imaging your code as a well oiled car driving in the streets. Exceptions are dark alleys running between the buildings so that they don't cause detours on the normal flow. When you do an if/else, you are at an intersection and quickly turn left or right and continue full speed. When you trigger an exception, you press ALL the brakes and come to an emergency stop, and then, push your car to the nearest alley where you slowly drive to wherever the exception leads you. Now, PHP might have slightly optimized exceptions, and perhaps the CPU speeds are no longer making optimization relevant. But the day your site gets 10 million visitors per day because it's on the Reddit home page, are you really sure you want to use Exception for workflow when it wasn't designed for this? In my real time core, I did use exception, for out of memory errors, for database errors, etc... because that way, I was able to reduce the number of checks and tests and shave a few cycles.
What is the difference between a fatal and an exception? I would have thought a fatal *was* an exception that was passed, unhandled, right to the top.
http://steve-parker.org/articles/others/stephenson/holehawg.shtml
Well, as a newbie I started out with SlimPHP. It was pretty good, but I really only used it for routing. I moved to [limonade](http://limonade-php.github.io/), and eventually landed with [FlightPHP](http://flightphp.com/) which is my favorite php framework to date. So I'd recommend flight.
In exceptional circumstances.
My only concern is it is owned by the Russians so how can I recommend it to my American customers who might process financial transactions, password entry/submittal or whatever other sensitive data xfer through the web server and how do I know how safe the server is (what if it contains exploitive holes). Of course I'm paranoid and there IS a conspiracy :-) At least I know the US guys are spying on all my customers data - wheres the Russian transparency? 
i throw exception when i want to prevent code from beeing executed any further, because that's what's gonna happen. simple as that.
I think what you really need here is a third database table. Think of each class/table as a real thing. As I see it there are three things/objects in your problem: * Package - the thing being shipped and tracked * Location - a physical place that the package moves through while in transit * Record of package in a location - a record of the time and place that the two objects crossed This would be a many to many relationship and your ORM should be able to handle it. It'll let you query: $package-&gt;get_locations() // all locations that the package passed through $location-&gt;get_packages() // all packages to ever pass through this location $location-&gt;get_packages()-&gt;where('timestamp', '&gt;', time()-86400); // all packages to pass through a location in the last 24hrs Neither package nor location tables hold foreign keys for each other. You just query the table in the middle and join onto the package/location table as needed.
I throw an exception any time an error occurs that I can't handle on the spot that might affect the logical flow of my code. From a security stand point, this means that a hacker can not easily manipulate my code, because it'll simply crash with an exception. From a developer's standpoint, it is a lot easier to identify a bug when you have an exception and a stack trace in apache error log. From an end user's point of view, it can seem frustrating that the application isn't working, but it is better than corrupting the data, or sending incomplete emails to users. I use the PHP5 keyword extends to create multiple types of exceptions. I have about 50 different exceptions I can use depending on the case. For example, I have one called "SessionExpiredException" which I throw when the session expires. Higher up in the stack, I have code that catches SessionExpiredException and in another part of the code, I catch all Session Exceptions ( SessionExpiredException extends from SessionException in my code ). I consider "catch( exception $e )", to be bad coding practice because the code can catch anything and won't be able to handle any error that happens. My software is very stable because when I write new versions, it's faster and easier to debug the code because the code just doesn't work when something goes wrong. Here is a style of coding I see often in my code : try { // do some action that might throw an exception } catch( DatabaseGoneException $e ) { // do something here } catch( DatabaseDuplicateRowException $e ) { // something else here } catch( InvalidParameters $e ) { // something else here } catch( AccessDeniedException $e ) { // redirect user to a fun page that says they can't access the resource. } 
My advices: - Try to give your users a configuration file, instead of telling them to open the class and change parameters themself. This is bad practice. - Move "Field" class to another file, it shouldn't be inside swiftstorm.php - Don't rely on globals. Use class scopes. - Rewrite your global functions as class methods. As for the security (I'm not an expert, may be wrong) sanitizing everything with `htmlspecialchars` looks pretty secure to me and usually prevents XSS. Perhabs you may also want to add tokens to prevent CSRF, or add captcha to prevent bots from spamming. 
there are already some great answers here..i will be back a little later today to respond. thanks everyone
If you're working with a JSON API, you should return JSON all the time. So, in this case, you would return a JSON response that includes the caught exception message.
Could you show me some practical examples from your code on how you implement exceptions? Also, where do you try/catch exceptions? Inside the actual function doing the work, or whenever you attempt to call the function?
Oh come on now :) isn't nginx open source anway?
I use them in try/catch block when I need to check a Bunch of variables before running some operation, and I don't want a Bunch of nested if/else statements around it. Part of an API (simplified, obviously) might look like: $success = false; // returned status boolean $message = ''; // returned error/result message switch ($act) { case 'update': try { if (! $product_id) throw new Exception("Missing or invalid product_id", 0); if (! $product_data) throw new Exception("Missing or invalid product_data", 0); if (! $DB-&gt;select($product_id)) throw new Exception("Product not found", 0); if (! $DB-&gt;update($product_data)) throw new Exception("Database error, sorry!", 3); $message = "product updated"; $success = true; } catch (Exception $e) { $err_msg = $e-&gt;getMessage(); $err_code = $e-&gt;getCode(); $message = "Error: ".$err_msg; if ($err_code &gt; 0) { writeLog($err_msg, $err_code); // log "serious" errors } } break; case 'foo': .... default: $message = 'Error: Unknown $act value.'; break; } (ps: if this approach has flaws I'd *love* to hear them instead of a simple downvote..)
In that case you would just return false rather than throw an exception. Exceptions are for any time things aren't the way they *should* be. Their purpose is to tell you or anyone else working on the project when they've made a mistake in their code. You can never assume that you or anyone else will write code without making mistakes. Exceptions are there to let you know when you do so you can find and fix your bugs before your users have to deal with them.
While your first statement say it all, it's to vague to be applied in a principled manner. OP for more suggested reading material, start [here](http://c2.com/cgi/wiki?ExceptionPatterns).
&gt; Try to give your users a configuration file, instead of telling them to open the class and change parameters themself. This is bad practice. Depends entirely on his audience.
In your example, I see you throw an error when you query your database. Would that exception be better handled in your database class or is it better to handle it in function using it? In my application, I have a database class and my only real exception I have is when the result is false. But, I have that exception thrown inside the function itself: public function query($sql) { if(!result = $this-&gt;db-&gt;execute($sql)) { throw new Exception ("The query failed."); } catch(Exception $e) { error_log($e-&gt;getMessage()); } return $result; }
First, I wouldn't put all that stuff in a switch statement. Better to break out the 'actions' into separate, more maintainable and testable methods with lower complexity (fewer branches). Second, there's seems little benefit to using exceptions for flow control, as here, with all the unecessary overhead of creating then querying the exceptions immediately after. You could easily just set an $error variable in those conditions, and then log it if $error != '', otherwise set the success message. 
Thanks for your input! I thought globals might be something to avoid, but then again, with namespaces, they shouldn't collide with other names, right? What are the reasons for using a class, and would you suggest to keep everything static within the class, or should it be instantiated?
You could, and that has been the historical the counter-argument to exceptions. The difference is in how you deal with errors. With return type checking, if there's a problem the burden lies on the caller to figure it out. A lot of bugs have been created over the years of callers not checking for errors because they only did happy-path testing. With exceptions, you can assume your call was successful and don't need to check for errors. It turns out that there are a lot of quality implications to that - you detect errors faster (because they bubble up) and you can assume everything is going well. If something breaks, you can handle it but you have to explicitly choose to fixing it. So it's basically a choice of whether you want to force every caller to check for errors or if you want them to choose what errors they will handle. Edit: just looked at your username...
What error are you getting?
Thanks!
What is also interesting about interfaces is that they create new types. Interfaces also allow you to abstract above primitives and user defined concrete types. Perhaps you have an algorithm that you want to work on Integers, and Reals. Then perhaps you make the algorithm use an interface that implements product. class InterfaceExample { interface NumericOps&lt;T&gt; { public T product(T a, T b); } final private static NumericOps&lt;Integer&gt; IntegerOps = new NumericOps&lt;Integer&gt;() { public Integer product(Integer a, Integer b) { return new Integer(a.intValue() * b.intValue()); } }; final private static NumericOps&lt;Double&gt; DoubleOps = new NumericOps&lt;Double&gt;() { public Double product(Double a, Double b) { return new Double(a.doubleValue() * b.doubleValue()); } }; public static void main(String[] args) { System.out.println(thirdPower(IntegerOps, new Integer(3))); System.out.println(thirdPower(DoubleOps, new Double(3.2))); } public static &lt;T&gt; T thirdPower(NumericOps&lt;T&gt; ops, T value) { return ops.product(ops.product(value, value), value); } } Notice how my thirdPower algorithm can work with doubles and integers. This example is in Java. I could even extend it to work with strings by adding.. final private static NumericOps&lt;String&gt; StringOps = new NumericOps&lt;String&gt;() { public String product(String a, String b) { return new a + b; } }; public static void main(String[] args) { // ... System.out.println(thirdPower(StringOps, "3")); } Equivalent in Haskell class NumericOps a where fproduct :: a -&gt; a -&gt; a instance NumericOps Int where fproduct = (*) instance NumericOps Double where fproduct = (*) instance NumericOps [a] where fproduct = (++) thirdPower :: (NumericOps a) =&gt; a -&gt; a thirdPower a = fproduct (fproduct a a) a main :: IO () main = do putStrLn $ show $ thirdPower (3 :: Int) putStrLn $ show $ thirdPower (3.2 :: Double) putStrLn $ show $ thirdPower ("3" :: String) C++ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; template&lt;typename T&gt; class NumericOps { public: virtual T product(const T&amp; a, const T&amp; b) const = 0; }; class IntegerOps : public NumericOps&lt;int&gt; { int product(const int&amp; a, const int&amp; b) const { return a * b; } }; class DoubleOps : public NumericOps&lt;double&gt; { double product(const double&amp; a, const double&amp; b) const { return a * b; } }; class StringOps : public NumericOps&lt;std::string&gt; { std::string product(const std::string&amp; a, const std::string&amp; b) const { return a + b; } }; template&lt;typename T&gt; T thirdPower(const NumericOps&lt;T&gt;&amp; ops, const T&amp; t) { return ops.product(ops.product(t, t), t); } int main(int argc, char **argv) { std::cout &lt;&lt; thirdPower&lt;int&gt;(IntegerOps(), 3) &lt;&lt; std::endl; std::cout &lt;&lt; thirdPower&lt;double&gt;(DoubleOps(), 3.2) &lt;&lt; std::endl; std::cout &lt;&lt; thirdPower&lt;std::string&gt;(StringOps(), "3") &lt;&lt; std::endl; return EXIT_SUCCESS; }
Give this guy a cookie. At least one decent explanations that does not relay one crappy practices seen in frameworks.
A lot of the "answers" provided are wrong. Exceptions should be thrown when resources fail, client code has errors (malformed markup), or programming errors (such as illegal arguments). They are not to be used as handling flow control. Correct posts: * [Yare_Owns](http://www.reddit.com/r/PHP/comments/1mr1qa/when_do_you_throw_exceptions/ccbu3y8) * [Titomb345, though read the comments](http://www.reddit.com/r/PHP/comments/1mr1qa/when_do_you_throw_exceptions/ccbt8ki) And then these: * [wat](http://www.reddit.com/r/PHP/comments/1mr1qa/when_do_you_throw_exceptions/ccbyjeq) * [This is flow control](http://www.reddit.com/r/PHP/comments/1mr1qa/when_do_you_throw_exceptions/ccbtu3d) I don't want to read anymore of these. You get the idea. Take a read of this [article](http://www.onjava.com/pub/a/onjava/2003/11/19/exceptions.html) and look into exceptions in Java. PHP is modeled after exception models of other languages.
In my opinion, Exception should only be used as a defence against programmers or incorrect implementation of a library, where as error management should be used against errors inputted by users of the application. 
&gt;Edit: actually, rereading it, I think it should be bidirectional, so, underlying table you would have: Package &lt;--&gt; Package_Location &lt;--&gt; Location This has been exactly my approach so far. I am not going to denormalize and maintain a "current_location" on the package itself, unless it becomes a performance problem... Thanks man.
&gt; Think naturally: what are the functionalities of your application? I'm glad you replied as this provides some commentary on the other aspect of my question - the thought process for arriving at an acceptable solution for the relationships. I was kind of going down this route, with 'what-ifs' about how I would query the data, but wasn't sure if in practice this was the right approach to begin there. I will check out the fetched join. Honestly, I developed the ORM myself as I wanted it to be as minimal as possible.
Great. Concrete classes are not a problem for me, I just felt like I was getting a bit wishy-washy with the third class, but you've firmed up my understanding quite a bit there. My concrete classes, in this example, 'package' and 'location' will be instance objects and then my third class, maybe call it PackageLocation or some such, will be a static class. (I know there's no such thing as a truly static class in PHP, but all the methods will be static.) Each concrete instance object will then make calls to PackageLocation which will act as a service insofar as performing joins and returning an array which I'll process accordingly as with your last sentence. 
+1 for symfony2 Validator.
&gt; Better to break out the 'actions' into separate, more maintainable and testable methods Good point, I'll consider that. To your second point, I could log things based on an error var, fair enough, but I still want execution to skip all the other code before the `catch`, how would I do that without exceptions or a bunch of if-statements?
&gt; In your example, I see you throw an error when you query your database. Would that exception be better handled in your database class or is it better to handle it in function using it? The database class also does some exception stuff, but only for actual database errors (invalid queries and the like). But in this case if a product cannot be found, that is not a db error, the 3rd party might have messed up or typo'd the $porduct_id or something. So yeah, here I'm basically abusing the `throw()` for control flow I guess.. I prefer it over the alternatives because it's a lot more readable (to me), partly because you can pass the error *and* halt/skip further execution in a single statement, there's no need for the curly brackets after the `if (..)`.
Jesus, why does everyone want to do this shit? Just use PDO, FFS.
Why who RoR devs keep doing this? Comparing a *framework* to a language? Do they not know the difference? &gt; As requirements change, new pieces are bolted onto the project, resulting in spaghetti code, one-off pieces, and other development headaches. The best way to combat such a situation is to take a page from Rails and plan ahead. Programming in Rails does not automatically make you a better programmer. This is a universal tip that should be applied everywhere, not just in PHP. &gt; All developers reuse code. Whether they are just copying and pasting from other files, searching online for code snippets, or creating classes that can be shared between projects, we all do it. Ruby on Rails takes code reuse a step further with the gem system. Gems are packages of Ruby code specifically designed to be shared with any Ruby project. Even Rails itself is technically a gem. Gems are made to be shared, to work universally. They are versioned, so that you can be sure of exactly how a certain version of a gem will function. Symfony2 is its own library that pulls in multiple other libraries to work in a cohesive part. All Symfony2 bundles work well with Symfony2 and are meant to be added or swapped out when needed. You're comparing RoR to PHP because you're a bad writer. &gt; Testing is often overlooked as busy developers try to churn out features and fixes as quickly as possible. It takes dedication and commitment to follow Rails' lead and ensure that testing is made a priority instead of listed as something that will get done "when we have some extra time." You're off your rocker if you think testing is done 100% of the time by 100% of RoR devs. It takes commitment and an understanding that testing makes your code better, but not all developers do this. &gt; In PHP, namespaces seem appear to be pretty new. They were introduced in PHP 5.3, and the current version is only PHP 5.5. That said, PHP 5.3 was released more than four years ago! This is certainly a feature that PHP developers should be using at this point, especially when planning large projects or projects that will be using extensive third-party code. It's like you just learned to write! Who cares about version numbers? PHP doesn't jump major version numbers willy nilly. Namespaces *have been used* for several years. If you're seeing non-namespaced code you're looking at either legacy code, or simply apathetic developers. From the comments section: &gt; As a former Rails user I'm a big fan of CakePHP which is basically Rails for PHP. This is a problem with RoR transplants. You're a horrible writer. Go away.
**What Ruby on Rails Programmers Can Learn From PHP** That "who did it first" doesn't mean anything. What matters is what you are doing. And from this article, PHP developers **are** doing the same things. The difference is we PHP developers don't need to feel smug or better than everyone else about it. We just keep on building cool stuff while you continue to fight language wars and try to prove how much better you are. So enjoy!
It wasn't intended to be constructive. It wasn't intended to be destructive either. It was intended to be a joke... Sorry...
Every time something unexpected *could* happen. Think of exceptions as notes to developers who come along later and break your code. It's like you're saying, "hey dumbass, i already knew you would try this, so i wrote you a message explaining how you broke it!"
I would refactor the configuration variables into one array $config. Refactor the form functions into one Form class. Pass the $config variable through to the Form class and the Field class.
Well I'm not a big fan of configuration files myself, but I would say that asking people to change classes is a bad idea. Classes should not change, instead it should be possible to change configuration from the outside of the class.
nah. i meant stop on error...
according to tiobe, it's raising pupularity
To get the current location of a package, it's simply a matter of performing a query such that package_id = the package i want, and the id is the highest in the set. Now, to get a list of all packages joined with their current locations may be a little bit more involved, but my initial thought would probably be to employ a subquery that narrows the set to only the most recent entries for each package_id and then selecting from that. Not sure how efficient that will be, but such is life i guess. I'm still thinking through the implementation details of PackageLocation, but your point is well taken.
Perl does the same trick of interpreting undefined constants as strings.
In other words: If you call a function and don't check for an error code, execution continues with unpredictable results. If you call a function and don't check for an exception around it, the call stack will unwind until it hits a catch, or the program will abort. This is the preferred behavior. You should always try to make your programs fail loudly where the error happened, and not somewhere else as a side effect.
&gt;when you are receiving outside data that you have no control over This is pretty much it. If you have complete control over the data and state of your program, then nothing exceptional can happen, right?
As soon as possible
nginx is open-source, same as Apache. Apache also contains code written by Russian developers, as well as Chinese ones and probably some written by Iranians. Both nginx and Apache have security reviewers of all nationalities poring over their code. If your American customers are worried about using code developed by people of non-US nationalities, you'll have to give them closed-source code developed by a for-profit company based entirely in the US. Something along the lines of LiteSpeed, perhaps. Although... the company is run by people who at the very least are of Chinese descent and have Chinese education.
I've seen at least one chat system not let you put in the message '0' because apparently '0' == false. For your example: accepting either an integer, a float or a string is almost definitely not what you want to be doing. Cast your values to the relevant type explicitly when you retrieve them from an external system (whether $_GET or a database) and use them as said relevant type.
You could also trigger a build in a git post-receive hook: curl http://yourserver/jenkins/git/notifyCommit?url=&lt;URL of the Git repository&gt; This way jenkins only builds when a new commit occurs and doesn't poll unnecessarily. I believe it requires the Git Plugin...
I may be able to [help](http://www.reddit.com/r/PHP/comments/1m7r74/how_to_get_laravel_set_up_in_a_vm_using_puphpet/)
Both Symfony2 and Zend 2 have good validation components: Zend 2: http://zf2.readthedocs.org/en/latest/modules/zend.validator.html Symfony2: http://silex.sensiolabs.org/doc/providers/validator.html (I know this is the Silex documentation for the Symfony2 validator component which in my personal opinion is more readable than the Symfony2 docs). 
If you are telling me that some EE file contains this code I cannot believe you, and dare to say your description is misleading on purpose because you don't like EE. This is an example of how those guys code: $qry = $this-&gt;db-&gt;select('COUNT(*) as count') -&gt;where('site_id', $this-&gt;config-&gt;item('site_id')) -&gt;where('member_id', $this-&gt;session-&gt;userdata('member_id')) -&gt;get('ping_servers'); So, you saw some code written by a third person or team, but shittiness of that code is not EE's fault.
&gt; How vague are the problems in your software that the user cannot even describe them, at which point or on what screen it happened, a log cannot be retrieved, and you cannot ask the proper questions to have the issue described in enough detail? *"When too many rows of the spreadsheet are selected, the screen turns all curvy."* — http://thedailywtf.com/Articles/Theres-Something-About-Mary.aspx
In my example, accepting any type is definitely what I want to be doing. Your advice to cast explicitly produces the same perceived "problems" as relying on implicit type-casting: $_GET['foo'] = '1abc'; var_dump((int)$_GET['foo'] === 1); // true var_dump($_GET['foo'] == 1); // true PHP is a ~~dynamically~~ weakly typed language *on purpose*. Lots of people don't like this, and try to code around it because they come from a Java/C/C++ background. Neither way is "better", but I will say that if you're not embracing the ~~dynamic~~ weak typing *in a ~~dynamically~~ weakly typed language*, then you're essentially hammering a square peg into a round hole. **Edit:** s/dynamic/weak
&gt; PHP is a dynamically typed language on purpose. So's Python, Ruby, Lua, and several other languages which I program in on a regular basis. None of these allow you to compare a string to a number.
--&gt; /r/techoblanco might be interesting if you compete with our mod bot /u/tumba_burros
This is one valid mechanism for reporting errors. Formal exception handling is another. This it the thing about exceptions: they're an *implementation detail*. The requirement you're fulfilling here is, do something sensible when something weird happens. One approach is to use throw/catch. Another is field by field validation and manual error reporting.
You should let users inject their configuration directly into the construct. Editing class files means each revision they will need to re-edit their file.
Not a core file of EE, the previous developer put that code in one of the templates. The page was a dumbed down db table manager they made
Some of those fonts are way way too thin.
I was talking about weak typing (implicit type casting) and called it dynamic by mistake.
woops sorry :)
he "quit" internals (PHP internal mailing list and development), not PHP nor anything else.
Just for variety (since I'd normally just use the Symfony2 one), here are two other choices: [Laravel](http://laravel.com/docs/validation) [Aura.Filter](http://auraphp.com/packages/Aura.Filter/1.0.0/) I haven't used either of them, and I'm only assuming that the Laravel one can be used as a component.
Uh. wtf?
Oh, I fully agree with you... But we are talking specifically about exceptions... you don't have any control in your code over network latency. But you have control over your database and your code.
I think you missed my point. It's exactly because you can't control latency that things like exception performance don't matter. Whatever slowdown there is from throwing exceptions (not much) is completely undetectable by the user. The latency overshadows virtually everything, including total runtime in a good number of cases. So removing exceptions gives you a performance improvement of what... 10ms *maybe*? Average network latency around here is about 10 times that on a good day. It's the textbook definition of micro-optimization - even taking into account 10 million users. If the performance of exceptions is a concern, you should check out dynamically sized arrays, large string processing, and object instantiation. High-level programming is all about making *development* and *maintenance* faster, not runtime. We of course want to keep runtime to a minimum, but usually only if our changes are human discernable and/or it doesn't make our own lives worse (which removing exceptions definitely would IMHO).
Is it me or is this reviewing symfony 1.x?
Exceptions should be used when your unit of code cannot reasonably recover from an unexpected event. If you can recover from something unexpected and handle it correctly within that unit of code, then don't throw an exception.
Why is Slim referred as SlimMVC?
This gets asked a lot, and the answer is that you should find an open source project that you want to *use* and contribute to that. Put yourself in the shoes of the maintainer of a project. Would you really want contributions from people who are just trying to fulfill a course requirement, or would you rather have contributions from people who are genuinely interested in the project? Having said that, my two alternative recommendations are: 1. Start a project of your own if your instructor allows it. It takes literally a few minutes to start a project on github, and you can do pretty much anything you want. (Take common functions that you use a lot and group them into modules, for one example.) 2. Search for PHP projects that have security flaws and offer to fix them (if you know how). Example: [extension:php mysql_query $_GET](https://github.com/search?q=extension%3Aphp+mysql_query+%24_GET&amp;type=Code&amp;ref=searchresults) (Note: Some of those projects have security flaws because they're explicitly designed to illustrate them.)
I have an instagram API that might be missing some features of Instagram https://github.com/galen/PHP-Instagram-API
If you are interested in voice/VoIP the most popular asterisk GUI, freepbx, is written in php. There is a github org for casual devs at /POSSA that can get you started. 
Shameless plug: We can always use some extra help for Bolt. [website](http://bolt.cm), [github](http://github.com/bolt/bolt). Feel free to get in touch, if you have any questions. 
here's a playground: https://packagist.org/explore/
I've been looking to get involved with an opensource PHP project as well, but have no idea where to start. If I wanted to contribute to Bolt, where would I start?
Contribute to a project you use yourself, and add the stuff that's missing for you.
I agree with the other commenters, get a project that you use yourself. That said, you can go from easy all the way up to advanced with some of the bigger projects like WordPress, Drupal or Symfony. I'd also love help on [Requests](https://github.com/rmccue/Requests), but I can't really offer much in the way of projects that need doing. Maybe writing an OAuth authentication module; it would involve a fair bit of understanding specifications and becoming familiar with the project, so might fit your advanced but nicely.
Thanks! I'll browse the codebase and see if I could pitch in somewhere.
In PHP 5.4 you can even specify multiple traits :)
To my mind, packages have multiple locations. A source location, a delivery location (which may change) and a current location (which will definitely change - bearing in mind that warehouses and delivery vans are also locations). Packages will also need a location history/log so that you can track changes and so that sender and recipient can track location. To turn it on its head, a driver's delivery route will contain locations which reference packages. 
If this sort of thing is outside the bounds of reddiquette ... I'm sure you will let me know. :) Stef
The UserMapper in this example still implies a database for storage, as it has a dependency on a DatabaseAdapter (what if storage is XML?). And if you want support for more than one database type, there's little here that helps with the reality that all but basic CRUD operations usually require use of custom SQL. Generic PDO adapters just don't cut it. So there's a lot of abstraction here, but little to answer the two basic questions: What if I'm not using a database? What if I'm moving between database types? Wiring up the Repository in these cases is not as trivial as suggested in this example. 
If you're trying to refactor without any unit tests, you only have yourself to blame. Prototyping is no excuse :P 
Yeah, to get all packages w/ their current locations it would probably involve a subquery, something like: SELECT `packages`.*, `packages_locations`.* FROM `packages` JOIN `packages_locations` ON (`packages`.`id` = (SELECT `packages_locations`.* WHERE `packages_locations`.`package_id` = `packages`.`id` ORDER BY `packages_locations`.`time_out` DESC LIMIT 1)) 
Bitcoin can blow your mind when working with it. It's what got me interested in php.
Unit test can take time to implement. But point taken.
And now you're experiencing the technical debt of that decision. I guess it will give pause for thought at least in the future. Other pleasures to look forward to: code that you only expected to be used in the prototype persisting for years, like herpes. The horror when your manager won't let you refactor something you know is just held together by string and spit because "it works, so why change it?" and because he wants new features added instead. 
It's been a few weeks and I wonder how you are doing? Changing IDE is a pain in the butt so I hope it hasn't been TOO painful for you! I think if we find and use the useful features of new IDEs quickly (and avoid their inevitable pain-points) then it's possible to stick with it and change, but if you run into problems quickly then it can colour your opinion of an IDE quite badly. I'd recommend PHPStorm because it works really well for me. It's definitely "a contender" but if it doesn't work for you then no worries, keep using NetBeans because it's also "a contender!" :)
UserMapper is an implementation of UserMapperInterface. So if your storage was XML, you'd presumably create an XMLUserMapper (and hopefully, at that point, rename the UserMapper to something more descriptive, like DBUserMapper) and use it. As long as it implements UserMapperInterface, the rest of your codebase need not know or care about the details of the implementation. 
tl;dr: author discovers what left joins are, and fails to realize that with unsecure code like this, caching is the least of his problems: if(! get_cache($cache_item_name)) { add_cache($cache_item_name, mysql_query("SELECT * FROM `users` WHERE `username`='$username'")); } 
Then please do the responsible thing and post correct code so that less experienced users aren't led down the wrong path. There's no excuse at all for putting code out there with deprecated mysql_* functions and without showing use of prepared statements. Samples like this just feed the cut-and-paste culture that gives PHP such a bad name. At least use pseudo-code if you're too lazy to do it properly. 
I have to agree. Anytime I quickly put something together "just to see it work" that code morphs into production code, rather than being rewritten correctly, which is why I try to avoid the prototype mindset all together.
This x1000.
Right, I've got you! It's too late to modify it now but I just want you to know we're going to take your comments to heart and in future posts we will mimic our production code as closely as possible.
Awesome!
Don't be lazy and fix it. You are a setting terrible example.
Worked like a charm, very nice.
PuPHPet is awesome! 
Looks like your site is vulnerable to XSS attacks. If headers contain HTML it is not being escaped correctly, you should be able to see in your logs where it has happened :-)
I can say that a year of PHP only has made me "soft". All those ready made array functions, the ability to put anything in anything without much thought or repercussion, how easy it is to completely disregard types, etc... It will be a hard wakeup call when I attempt any personal project in a stricter language :P So, to answer the original question, a lot of people probably badmouth PHP because it is too forgiving and easy to get into without years of formal training.
O crap, never thought about the headers themselves :P I'll go check right now and and sanitize. Thanks :D I also should auto remove 'http://' and 'https://' from queries, I see a lot of these
Great thought and nice effort, but I think [Web-Sniffer](http://web-sniffer.net/) beat you to the punch.
Agreed * 100 - homebrew is OSX secret sauce
By 10 years, it seems. Guess I didn't do my homework properly when I only searched for applications of the 'get_headers()' function. O well, mine has a blue background and box-shadows :P
You beat me too it. That's pretty damn cool, imo. Never thought about such easter eggs laying in wait like this.
Hah! I think I'm going to like it here ^ _ ^
Tools like this are fun, but *please* don't put advertisements on the site. They cheapen the tool, they provide no value and they will not make you any money. You won't even cover the cost of the domain, but you will make people think ugh. If you want to make money or just cover costs, pay out of pocket to build up traffic and then talk to some companies that are interested in marketing to developers and have them "sponsor" the site -- this is exceptionally common when it comes to tools like this, it's pretty much expected at this point. Much friendlier for users and more lucrative for you. Also, focus on the goal not the method. Someone uses get_headers to get headers, they only care about the get_headers function if they're writing PHP, but your tool is built around HTTP, not PHP. Someone using Python, or Ruby or Node will still need to get headers sometimes. Also the people visiting your site are going to understand why they're there, it's much better to go with simple and then keep information beyond some form of option, eg: about. If you need help with inspiration when designing something like this check out [hurl](http://www.hurl.it/), note how simple it is!
I did
How would someone sponsor a simple tool like this? And they're just Google ads. They're pretty non-intrusive. I see an individual wanting to publish an actual tool that can be used, and having small ads to cover server/running costs. I don't care about the ads. More power to you :) EDIT: mobile a word
While some people might roll their eyes it's probably better that it's cliche then that it end up being too niche. The biggest part is probably keeping features fairly compartmentalized, so that someone can learn from or borrow the concept for how you built (say) a comments system without feeling like they necessarily need to take the rest of the framework. Maybe that's unrealistic, but that's what I think might help me in a book.
With your own code, you're probably fine, but you may encounter 3rd party PHP software that assumes, for example, that functions like apache_request_headers() or getallheaders() are always available, when they are not in a nginx/php-fpm environment.
From the class definition of `AbstractDataMapper` it seems that `PDOAdapter` implements `DatabaseAdapterInterface`. So creating a class that implements `DatabaseAdapterInterface` for XML storage would suffice I think.
Pretty much the same thing in MacPorts, except it's in the regular MacPorts tree so it's just: sudo port install php55 And before anyone says anything: MacPorts can use binary packages now and does so by default, so it's lightning fast to install PHP 5.5
Setting aside for a minute the confusion of XML with a database, have you ever tried to implement full text search with such a pattern? Since the semantics and SQL vary widely between database types, we're no longer talking about just `PDOAdapter` but also `MySQLPDOAdapter` and `SQLitePDOAdapter` at the very least, assuming that the full text search is implemented by the database and not some other service. And then the middle layers have to mediate between these. The abstractions grow very quickly in complexity. Even Doctrine has to resort to it's own DSL in the Repository to replace SQL - with its own heavy [lexer and parser](http://xlab.pl/en/full-text-searching/) to simulate SQL dialects - and code generation tricks to actually make this kind of thing work, and only with databases. Or you have to use Doctrine's own horrible reverse indexes via `Searchable`, with all the complexity that brings. The Repository pattern is an important one, and certainly far better than Active Record, but it isn't as easy to do well as this article suggests. 
I've no problem either, getting a couple extra bucks is a good incentive to keep working at the project. If someone is looking at this page they have the knowledge of how to remove them.
I think you may need to explain a bit more what this library is supposed to do. After reading the README examples, I'm still completely in the dark. 
Actually I think `DatabaseAdapterInterface` should be renamed as `DataSourceAdapterInterface` to avoid confusion between DB and XML sources. My understanding is that client code interacts with the repository (which is created up somewhere via DI or configuration) that hides underlying data persistance/fetching implementation from client. I see doctrine DQL/QueryBuilder as a language in which client code communicates with repository. The repository then fetches data converting the DQL into platform specific SQL(Same applies for MongoDB, Casandra etc). The final outcome is that client code is highly portable across different database implementation. To my experience it works 90% of cases. Complex aggregate queries are very small portion of my project.
It's not illegal, just frowned upon. (And dirty)
Fun Fact: unixtimestamp.com has ads and is one of the sites I frequent most.
Contribute documentation. The world needs more documentation! Find people complaining about missing, ambiguous or complex documentation, and fix it for them.
Well, querying has completely different semantics for MongoDB (ODM) vs MySQL (ORM) ... at what level of your code is this difference to be abstracted away? The documented Doctrine solution is to create [two different Repository classes](http://docs.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/cookbook/mapping-classes-to-orm-and-odm.html). This puts mapping into the repository layer rather than a separate mapping layer as the article suggests. 
Client code does not need to know about Repository implementation, client gets the repository from [ObjectManager](https://github.com/doctrine/common/blob/master/lib/Doctrine/Common/Persistence/ObjectManager.php#L30) which may be [EntityManager](https://github.com/doctrine/doctrine2/blob/master/lib/Doctrine/ORM/EntityManager.php#L65) or [DocumentManager](https://github.com/doctrine/mongodb-odm/blob/master/lib/Doctrine/ODM/MongoDB/DocumentManager.php#L44). The `ObjectManager` can be wired to the class via DI. The client just issues this code $blogPost = $this-&gt;objectManager-&gt;getRepository('BlogPost')-&gt;findOneByTitle('test'); Another way is to inject the repository only which is of [ObjectRepository](https://github.com/doctrine/common/blob/d9dea98243c733ff589aab10e321de4f14a63ab4/lib/Doctrine/Common/Persistence/ObjectRepository.php#L30). So the code would be, $blogPost = $this-&gt;blogPostRepository-&gt;findOneByTitle('test'); In both cases the client code does not need to know about the repository implementation and you can easily switch between MySQL or MongoDB behind the scene and does not impact on your main client code.
Agreed. I know how to use it, but NFI what it's actually for.
&gt;It is worry-some to me that professionals out there are selling code like this. Maybe some sort of job security for when they get hacked by little old bobby tables? Or maybe the developer(s) on this job was so junior he had no idea he was deploying lousy code. I've written code like this in my early days, and, at the time, I thought it did a great job. It is up to the client to perform due diligence. As for you, the worse the code you have to clean up is is, the more billable hours there are!
It's hard to give a good explanation without concrete examples, but a database error might provoke a "website offline" page whereas an invalid parameter exception my cause a redirect to the home page.
I don't think you're quite getting the point, I'm not talking about client code. First, with Doctrine if you need to create your own Repository you need two types of Repository class, one for ORM and one for ODM. It doesn't matter if your client code doesn't know about this. The point is your mapping abstraction now lives in two different Respository classes; and then you have to think about mapping different ODMs and different ORMs. Where does this happen? The article suggests in a mapping layer, Doctrine suggests in the Repository. Second, this does little to help anything more complex than the basic find* queries. At some point you have to be able dig down to the raw query language or SQL dialect to do anything meaningful - again, full text search is an instructive example. At what level of abstraction do you map a Repository query to e.g. `MATCH (col1, col2) AGAINST ('some -words' IN BOOLEAN MODE)`, just to take MySQL with MyISAM for starters? And then for SQLite with FTS on a virtual table: `WHERE docs MATCH 'some NOT words'`? This takes more careful thought and planning than is suggested here. I think part of the problem here is that most devs just aren't used to working across different storage mechanisms, so don't really understand the scope of their abstractions. 
We seem to be talking at cross-purposes and I'm not sure how often I can keep repeating myself. We already know that the Repository pattern decouples client from storage infrastructure. You're assuming that all the mapping between storage and domain model happens in the Repository; the article argues for more levels of abstraction beyond that - so just one Repository class only, with mappers and generic adapters injected. This is just deferring the core questions I asked above. And what you've described - multiple Repository classes re-implemented for different backends, native SQL or service queries in Repository methods - is already very different from what the article suggests. So we agree on that at least! There are many different scenarios where you might want to use different storage types depending on the platform that don't just involve straight migrations, so you still have to maintain both code-bases (I face this problem all the time, hence the frustration). But that's beside the point as well. Edit: And a `NotMatchingWord` method is doable, but doesn't help if there's more than one word not to match, or if we need to combine that with a phrase search, or a positional match, or a soundex, and any number of combinations of full text query semantics. It's just not that simple in the real world - you actually need to implement a whole full text query builder, for each platform. 
&gt; This is a rather bold statement that put me off right away I understand where you are coming from but I wouldn't say it's such a rare issue. The best example are SaaS platforms. Lets take the e-commerce industry. A single mid-size merchant can pay for hosting a Magento store from £1000 to £2000. You are right, he won't care that much about it. Higher traffic = higher profit (in most cases). The game change if you are an e-commerce platform like: Shopify or TicTail. You simply can't pay for every client that much money. Even outside of the SaaS, you can always aim to improve the quality of service. If your mission is to keep response time below 150ms it might be expensive to do it the traditional way. I'm convinced that SPA can save money (doesn't have to but certainly can). How much? That depends on the business and people nevertheless there is nothing inappropriate in saying so. 
5.3.3 is the default version of PHP on CentOS/RHEL. No need to upgrade since security patches are backported. :)
Well I haven't been into the situation you are in, so I can't comment on that. Just to clarify my comment about doctrine repository, I am stating Repository as an abstraction that returns domain object or a collection of domain object. Doctrine repository internally maps resultset to domain object internally as implemented[here](https://github.com/doctrine/doctrine2/blob/master/lib/Doctrine/ORM/Query.php#L265) and [here](https://github.com/doctrine/doctrine2/blob/master/lib/Doctrine/ORM/NativeQuery.php#L64).
.. and I have no idea if dates (as strings, not DateTime-objects?), ints, etc. work the same .. or what the purpose is .. at all.
Well... from the link you pasted I can see that data is in the Turtle format. The simple approach would be to find a Turtle parser for PHP. If you Google for "turtle parser PHP" you will find some resources. The first result was http://www.easyrdf.org/. 
I saw that one. But it involves using composer. I don't know how to / haven't used composer before. I'm looking for something ( a library ) or script I can include and then use.
Here is [how to use Composer](http://www.easyrdf.org/docs/getting-started). Does that look difficult to you ?
That's my point, he won't make even a couple of bucks, because adverts on these sorts of sites don't work. However, if he does want to make money, speaking with companies that would want to advertise directly to his users will pay. They won't make him rich, but they'll pay more than what advertisements would generate. Sponsorship is better for users *and* better for the finances of the site operator.
Composer is great and the only thing you have to do is "php composer.phar install". 
 $intervals = new IntervalCollection(); $intervals -&gt;add(new Interval(10, 20)) -&gt;sub(new Interval(11, 19)); $intervals-&gt;intervals() == [ new Interval(10, 11), new Interval(19, 20), ]; Is this saying that the relative complement of [10, 20] and [11, 19] is the union of [10, 11] and [19, 20] (e.g. {10, 11, 19, 20})? If so, that's definitely incorrect. It should be `[10, 10] U [20, 20]` or `{10, 20}`. I can't think of any set theory operation that would give `{10, 11, 19, 20}`, actually.
&gt; but it looks different. And that is why I am avoiding You could miss out on many things in life with that argument... 
&gt; I'm looking for something ( a library ) or script I can include and then use. Then just download it: http://www.easyrdf.org/downloads And then include [lib/EasyRdf.php](https://github.com/njh/easyrdf/blob/master/lib/EasyRdf.php) if you don't have an autoloader. Takes all of 30 seconds to get it running. 
Different from what ? Old school php ?
true, good point.
After downloading the files, right? The .phar is in the files, right?
yes. normal PHP
that's all I have to do? include /lib/EasyRDF.php ? How can I use easyRDF to parse freebase then?
Yes, you need the .phar which is one command to paste (from the quick start section) and you also need a .json file which describes what packages should be downloaded. Even if it looks confusing to you (at this moment) trust me, it's much easier than trying to download all dependencies manually. 
Sounds 'bout right. Step 3.5 is running composer install. Composer is a lovely way of managing dependencies in PHP.
In DDD, Repository should behave like in-memory collections, so I make them extend the `Collection` interface. Methods like `add`, `remove`, `get($id)`, `matching($criteria)` make a lot of sense on both Collection and Repository. With this, I can code against UserCollection and don't need to know if I'm using the UserRepository (database) or manipulation the UserCollection of `$group-&gt;getUsers()` (for example). In the end I find it weird that your repo has methods like `fetchById`, this implies fetching from database.
[@meramo](http://twitter.com/meramo) PHP/Drupal posts only
okay, cool thank you.
okay, thank you.
Yes, just include that file. Then load up your graph as per the examples, it should detect the Turtle format automatically. Otherwise add 'turtle' as the format parameter to the graph constructor if it's having trouble guessing. The rest depends on your knowledge of RDF.
You know, you're right about most of this, I don't think you deserved to get downvoted so much. I did kind of want a bit of coin, and was pretty much advertising my tool here. And when I think about it, yes, I might have misplaced my post, as it might be relevant to a less specific board (web developers or something) even if I made it in PHP. I'll keep most of what you said in mind. However, I'll probably leave all the text in for two reasons. Someone relatively new to web developing might happen on my site, and this person might not know about this specific shortcut to cURL, or heck, even the existence of php.net, so the text ads a slight chance of my site helping out someone. The other, less noble reason, is simply that more relevant text = better chances to be part of search results. I've also purposefully kept it below the more useful part, so it's not that much in the way. Keeps it all tight on one page, too. I'm upvoting you to try and restore the balance :D
Your post is fine in this subreddit, but I figured it'd be a much better tool if it was aimed at *every* web developer, vs. language specific developers, for the success of the tool. If you're looking to make money I *highly* recommend paying for the site of pocket for a while to build up a user base (people are in my experience much more likely to use a tool if they think that it exists only to help them and not make money) and then once you have a userbase leverage that to make money. This reddit post I guess got you roughly 700 page views and if your check your adsense you've probably made... $0.55? You'll need to make that another $99.45 to get a payout from adsense and at a rate of ~25 page views per day (what you're probably going to get after this post falls off the front page of r/php) it's going to take **years** to even make it to $50, let alone $100. Think of your website like a startup, focus on growth and not monetisation, monetisation is for when your product has a userbase. Making a few dollars now is just not worth it, you'd make more crawling around on the street, so if you focus on making this tool hyper attractive to anyone that comes across it (which means nothing distracting like adverts) you'll grow much faster and be in a position to make more money down the line. There's nothing wrong with looking to make money, but it's something you have to consider carefully and focus on the long term. Side note, a good way to increase traffic is to put up a tweet / like button, people *love* to show off cool things they've found and people *love* to talk about how great they are at technology, I have a simple website I wrote for developers to use with a tweet button and it has almost 1000 tweets, which brings in a good amount of traffic. I don't much care for the social sharing stuff but it is a very good way to turn one user into ten. Another good idea is to keep an eye out for relevant posts where you can mention your tool, for example if someone posts asking about headers you can mention your tool. 
Security fixes, yes, but not general bug fixes.
How does removing 11 to 19 leave you with 11 and 19 in the result? That violates [set theory math](http://en.wikipedia.org/wiki/Set_%28mathematics%29#Complements). `[10, 20] \ [11, 19] = {10, 20}`, not `{10, 11, 19, 20}` **Edit:** See [here](http://www.mathportal.org/calculators/misc-calculators/sets-calculator.php?val1=10%2C11%2C12%2C13%2C14%2C15%2C16%2C17%2C18%2C19%2C20&amp;val2=11%2C12%2C13%2C14%2C15%2C16%2C17%2C18%2C19&amp;rb1=diff).
Im not saying the guy's code is right at all, Im just trying to give my interpretation of what the author (who isn't me) meant. The author probably meant interval to be treated like a range, not a set, like you have in your first and second comments.
I hear ya. I guess let this be a lesson to people out there ... don't forget about documentation both internally (there isn't any aside from parameter types) and externally (only usage, no explanation).
You do not see the difference between "getheaders.org is brought to you by heroku, deploy your PHP websites for free today!" something users will want to click and ...[marquees for hire](http://i.imgur.com/TJUYXiY.png)?
This post bothers me a bit. I'd have made the mention on the site but the post has comments disabled. Essentially... I can't follow through with this being accurate if there is nothing at all even noting where the issue was in the code. However, if you're passing an array in where an object is expected, this kind of thing is bound to happen. It is Codeigniter though, and does not take advantage of type hinting, so this stuff is bound to not be caught right away. Also while I am a big fan of Laravel and have spent a lot of time in the IRC helping other fans, I don't like the nature of the last statement. It's very empty and promotes something I'd find with a band-wagon.
Even though MongoDB and Mysql both store data, they are not really interchangeable. I mean, when you replace your data store from Mysql to mongodb, you will have larger problems than rewriting your data access code. You probably will have to take into consideration all the possible queries and model your data accordingly. That is, of course, if you want to take the advantages that comes with things like mongodb. Apart from that, I don't think the ability to replace back ends is not the only purpose of this repository pattern. http://msdn.microsoft.com/en-us/library/ff649690.aspx
author here. new Interval($since, $until) represents all values from $since to $until, not including $until. so.. A={ 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 } B={ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 } A∖B={ 10 , 19 } and { 10 , 19 } == array(new Interval(10, 11), new Interval(19, 20)) Mainly I found this small lib useful working with dates. But noticed that it could be generalized to any type (you only need compare function). And of course, I will try to write some better documentation :)
yeah, I 100% agree :)
This article offers no real content other than the concept of sending a `Content-Type` header in an email. While it's important to understand the internals of email if you're going to work in depth with it, no one should be using `mail()`directly anyway when countless high quality mailing libraries exist (Zend\Mail, Swiftmailer, etc). The biggest issue in this article though is that `strip_tags` is absolutely the wrong thing to use in the context of email headers. It doesn't matter in this situation, but if the input were actually user provided (which it probably shouldn't be for the to/from addresses), strip_tags does nothing of actual value. For example, imagine if `$from = "blah@blah.com\nSome-Header: header value";` How does strip_tags help there? It doesn't.
Ahahaha, I totally missed the `strip_tags`. That's beautiful. Classic cargo-cult / magical thinking rookie crap.
Frankly, I'm just surprised that it wasn't `addslashes` or `mysql_real_escape_string` :/
Symfony2 has some of its issue tagged with "[Easy Pick](https://github.com/symfony/symfony/issues?labels=Easy+Pick&amp;state=open )". Its not particularly easy to contribute to this project, but it could be a good start though.
Good idea with IntervalBuilder. I'll try to implement something like this.
Have anyone actually tried to use that against the Freebase dataset yet? Freebase is immensely large (88GB uncompressed), and will most likely choke that by going way over the memory limit...
The idea seems nice, but you should consider a few things: - If/when scalar type hints get implemented, your String, Number and maybe Object classes will be broken as these words will likely become reserved. I would consider renaming them. - I agree that providing an OO interface around primitives is a worthy goal, but implementing this in userspace means a significant performance penalty, especially if you have a large scale application with thousands of objects per request. That's why this *has* to be implemented in the engine where the performance penalty will be much lower. Here's a quick benchmark to prove my point: $start = microtime(true); for ($i=0;$i&lt;10000;$i++) { $string = new String('hello world'); $string-&gt;uppercase() // HELLO WORLD -&gt;substring(0, 6) // HELLO -&gt;replace(' ', '?') // HELLO? -&gt;trim('?'); // HELLO } echo "Method 1 took ".(microtime(true)-$start)." seconds.\n"; $start = microtime(true); for ($i=0;$i&lt;10000;$i++) { $string = 'hello world'; $string = trim(str_replace(' ', '?', substr(strtoupper($string), 0, 6)), '?'); } echo "Method 2 took ".(microtime(true)-$start)." seconds.\n"; And here's the output: Method 1 took 8.1353628635406 seconds. Method 2 took 0.17836594581604 seconds. That's **45 times** slower!
Hi thanks for the reply! I'm not too worried about Scalar being implemented just yet, this is PHP we're talking about after all. Secondly, yes, there is a large performance hit, no two ways about it, but that's only to be expected. I guess its more of how I'd prefer PHP was, or rather, what PHP should aspire to be ;P
&gt; I guess its more of how I'd prefer PHP was, or rather, what PHP should aspire to be ;P Agreed, I wish this was already in core and we wouldn't need userspace libraries :) 
Are you asking us to do your homework for you? 
No, I just don't want to go the wrong way while starting a new project? This is more like validating my own way of organizing code.
That's why I would never use this library. 8 seconds to do a few simple operations on 10,000 strings is insane. It must be even worse for the numerical example.
What about: Entities: User (id, name, created_by (user_id)) Organization (id, name, created_by (user_id)) Role (id, name) Member (organization_id, user_id, role_id)
&gt; Please use pseudo code when possible, but please provide full list of attributes and function/method parameters . Are you sure?
I think what would be best is for you to begin, and then come back asking more specific information about why something doesn't work, is there a better way to do x, and so on. I'd also recommend reading up in more detail about some of the patterns you suggested and principles then consider how they fit in with your overall idea of what you want to achieve. At the moment it looks like you've asked for everything to be done for you, and looks as if you haven't taken the time to do any research or code yourself. Sometimes when am starting a new project it can take me a couple of goes if am doing it on my own to get the right project structure. This is only done with trial and error. Other advise I'll give your two user entities are actually the same, only difference being there user type. So in theory they shouldn't two separate entities, but one with an ability to check whether they are a user or administrator. 
yes. I just need to know how much responsibilities are you including in the entity objects, in your factory methods etc etc....
^ This is good if each organization can have different members and administrators but if an administrator is an administrator for the whole application then do this instead: User (id, name, created_by (user_id), role_id) Organization (id, name, created_by (user_id)) Role (id, name) Member (organization_id, user_id)
I don't think I'd separate users and administrators into separate entities like that. I'd likely create a user entity, then use an ACL to determine what it has access to. As for the rest, I'd use a basic onion architecture, i.e. entities, data mappers, repositories etc. 
&gt; I don't think I'd separate users and administrators into separate entities like that. I'd likely create a user entity, then use an ACL to determine what it has access to. the purpose of two separate entities for admins and users are not for Access control, but to create a type system, along with type hinting where errors can be detected early. &gt; As for the rest, I'd use a basic onion architecture, i.e. entities, data mappers, repositories etc. Ok. here is one problem I am facing. When I load the user object, I am using a factory class. The row read from database may be for a user or an administrator. If it is a User then I have to load the organization entity and populate the users Organization attribute. If it is an admin then this can be skipped. So I thought creatign a base user entitiey and then extend this class to create Administrator and User entities and implement different logic in the load attributes method. But then the issue is that the user entity object need to have access to factory objects to create the organization and parent user entities, which I don't like. So I once again put this code into service objects. So I now have UserServices and AdminsitratorService that extends from a base Service class that implements loadAttributes differently. But now I have to call the proper service class in the UserFactory's load user method to properly populate the attributes. I think I am going in circles.
Your stat estimates were pretty accurate :D I also know you are right about the feel of seeing an ad on a site like this from my own first impressions I've had a few times (rotatepdf.net comes to mind) I've put the ads away and replaced them with the left side of Smart Layers (I don't have a fb page to Like yet) Besides, even if I never get to the point where a sponsor would be interested in my tool, I think just knowing that I have a small constant flow of visits on one of my projects is worth it. Thank you for the advice, and also for your summary on how sponsorship works :D
&gt;the purpose of two separate entities for admins and users are not for Access control, but to create a type system, along with type hinting where errors can be detected early. It's for handling different roles of users, surely. What happens if a user gets promoted/demoted to/from admin? If you're thinking of doing what I think you're thinking of doing, your system is going to scream at you so bad. &gt;Ok. here is one problem I am facing. You should read up on entities, data mappers, repositories and service layers. If you're unsure on how to apply it, have a look at the existing applications at github or something. Also, I've mentioned several searchable keywords, so you should be able to get plenty of resources on google to read up on. I gotta get back to work now.
Yes and no. If you're doing the same operation 10,000 times that might be a factor, but if not, it's an artificial benchmark that doesn't really have any meaning. 8 seconds is a lot, but it's not 8 seconds. On, say, 10 string operations it's a milisecond. No, 10 milliseconds. Is that worth it for a solution that's more maintainable and readable? I would argue yes. We get too bogged down in benchmarks sometimes. Writing readable, clear, maintainable, extensible solutions is more important.
Perhaps a remember for the performance is this: https://github.com/phalcon/zephir I don't know if it will make a huge difference but it should in theory
I understand what you're saying. However, this isn't a case of "micro-optimization". This is plain optimization. Those string methods are neither more: * Maintainable * Extensible * Clear * Readable than the built-in methods. Sure, they may look prettier, in the same way using a static interface to immediately jump into fluid interface is "pretty", but the tradeoff in performance is far too much. Imagine if something like Symfony2 used this library exclusively? It wouldn't be a 10 millisecond performance hit - your application would slow to a crawl.
&gt; I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships. — Linus Torvalds
It doesn't have to be the same operation, it will behave just as badly with 10,000 different string operations. &gt; *On, say, 10 string operations it's a milisecond. No, 10 milliseconds.* Are you serious? 10 milliseconds for 10 string operations is absolutely insane, especially in web dev, when you want your whole page rendered and gzipped in under 100ms. And unless you're dealing with a trivial page, your code will do much more than 10 or even 100 string operations.
From the RFC: &gt; This patch opens the door for, or appears to go hand in hand with, nested classes Nested classes would be a ***huge*** improvement! If this gets implemented in 5.6, I will buy you a beer too /u/krakjoe! My [other beer promise](http://www.reddit.com/r/PHP/comments/1lv1dg/php_rfcnamed_params_php_wiki/cc31z29) goes to /u/nikic for the [named params](https://wiki.php.net/rfc/named_params) RFC :) **EDIT:** [Discussion](http://marc.info/?l=php-internals&amp;m=137991843212444&amp;w=2) on internals.
Did you read the RFC ***at all***? Or did you just comment after reading the post title?
I'd much rather have object literals, myself.
marc.info is not showing the thread properly for some reason ... http://news.php.net/php.internals
I really like this idea, especially when traits are used (assuming there will be no issue using traits here). This could potentially save lots of time and frustration when trying to refactor an entire namespace to satisfy just one edge case. On the other hand, I also see a potential for abuse here in that there are still plenty of people who dont understand DRY, so there's a high probability of spaghetti dinner. I think that something like an anonymous class should be the exception rather than the rule when organizing code. I wonder what kind of performance implications this would introduce. Say if there are N anonymous classes that are identical in every way (maybe generated in a loop or something, god forbid)...would the compiler be smart enough to know they are the same class?
Adding to what [calcifer](http://www.reddit.com/user/callcifer) said, technically stdClass is not a proper class. It is an object. But since an object in PHP MUST be a member of a class, it is assigned to the default stdClass. This RFC is about proper classes.
I like this from a use perspective, but it seems like it would be very difficult to implement in a way that doesn't undermine many sorts of optimization. Wouldn't this be very slow in practice?
Ah, finally. I've been wanting this feature for a while. Hopefully, it'll pass. 
It can't do any of the class analysis compilers normally do. It doesn't know the methods, class hierarchy, and other key info about the anonymous classes until well into runtime when it's presumably too late to optimize anything.
inb4: it's better to use OOP and mocks in your code, but legacy apps don't always use nice libraries and good design patterns.
What about this one? http://markmail.org/thread/sxqeqgc3fvs3nlpa
Thanks! It was a good read. What's funny is how nobody contacted her in the first place, yet so many hours were spent on an issue reported by a *single person*. What's even funnier is how Mary couldn't do a little process of elimination and try her spreadsheet in another cubicle (or the tech support lab) where the contrast was surely set lower.
&gt; until well into runtime when it's presumably too late to optimize anything. Well, yes, but this is true for any interpreted language.
_See also:_ /u/nikic's project [scalar_objects](https://github.com/nikic/scalar_objects), which does pretty much the same, but is provided as an extension. I don't think it's complete, though.
Can anyone give a real life example of a use case for this? Tks
Hmm? 
&gt;It can't do any of the class analysis compilers normally do. Well, PHP is interpreted, so.... 
You mean [like this](https://wiki.php.net/rfc/objectarrayliterals)?
It is also compiled. Most interpreted languages that are not toy languages are compiled on-the-fly.
Check the internals discussion [here](http://markmail.org/thread/sxqeqgc3fvs3nlpa).
PHP, even with an opcode cache, is an interpreter. PHP does "compile on-the-fly", however, depending on the setup, it might also put the bytecode into the opcode cache which it may then optimize using bytecode optimization patterns. Now, there are other languages which also do anonymous classes (Java for example). Now, correct me if I'm wrong, but Java does a lot of optimization to the bytecode, and I'm fairly certain that its anonymous classes aren't exempted from such optimizations. To flatly state that no optimizations are possible just because it takes place at runtime seems silly, especially when taking into consideration that we have accelerators and JITs that do just that. 
There is a [CallbackFilterIterator](http://md1.php.net/manual/en/class.callbackfilteriterator.php) (5.4+) class. But with 5.3 and anonymous classes it can be easily implemented like this: $iterator = new class extends FilterIterator { private $filter; public function __construct(Iterator $iterator, Closure $filter) { parent::__construct($iterator); $this-&gt;filter = $filter; } public function accept() { return $filter($this-&gt;current()); } } (new DirectoryIterator('some/path'), function () { return true; }); // Ran into exact same issue with FilterIterator and 5.3 few weeks ago, and thought of anonymous classes ps. Java FTW :D
&gt; Hopefully, it'll pass 95% that it won't =(
~~currently the compiler will wig out, cannot redeclare class if you try to create anonymous classes in a loop ... it shouldn't be that hard to work around ...~~ the patch to make the compiler smart enough to know that you want to re-use the same class is now included ... not that I am promoting the idea, but it's possible anyway ... however, as someone else said ... god forbid ...
I'LL BURN THEIR HOUSES DOWN.
+1
Right, you might have misunderstood me. Crackanape said that it couldn't be optimized because it wouldn't be able to do "the class analysis compilers normally do" implying static code analysis. However, to my knowledge, PHP doesn't do static code analysis and instead just compiles into bytecode and leaves optimizations up to PHP accelerators. 
That's probably true, though being able to use accelerators is quite nice.
You can still use accelerators.
Yeah. I want anonymous classes, object literals, property getters/setters, and anonymous function shorthands etc. For starters, anyway ;)
Looks good. I'd take it a step further and allow users to do getheaders.org/http://www.google.com and you should detect that and since you have radios for https or http break it down into the proper format and redirect to your page listing the data like getheaders.org/?https=0&amp;domain=google.com that way people can use it quicker by just typing your url before the url they want to check in their browsers. 
no you won't 
* String::trim is buggy. If I try to trim only spaces, it will actually trim a bunch of different whitespace chars and the NUL byte (see [trim](http://us1.php.net/trim)). Also, I'd rather you implemented ltrim and rtrim shortcuts instead of having to pass a verbose class constant as the second param. * String::is_regex is (as you say) crude. Reglar expression pattern delimiters don't have to be a forward slash, and what about pattern modifiers (after the ending delimiter)? (See [this](http://us1.php.net/manual/en/regexp.reference.delimiters.php)) * In Object::setFields you throw an exception if the param is not an array. Why not just use type hinting to require an array? * In String::html_encode, how do I access parameters 2, 3, and 4 of htmlspecialchars? (flags, encoding, etc) Also, how can I use htmlentities if I need to? Why is it called html_encode instead of htmlEncode? I could go on, but I've looked at enough of it for now.
Bring beer.
S/O http://stackoverflow.com/questions/18966065/having-issue-with-oop-and-pdo-in-php
Shared session storage if the websites were on two separate web servers. This is a sloppy implementation but it would work.
Nice and simple workaround.
I removed that stuff from the code because I wanted to get back to basics... and remove the extra stuff. The whole reason I'm doing the switch is to add this to it. I can't get a normal query working, so I threw out the rest until I can get that running. 
First of all, as public_method said, you're inserting values into the database without sanitizing them. This will enable SQL injection attacks and give attackers complete control over your database. Second, you're calling event::insertEvent() as a static method when it's really an object method. The proper way to call it would be $event-&gt;insertEvent(); Third, it's poor form to reference $_POST variables in your classes. Classes are meant to be portable and function in many different contexts. You should never make assumptions about those values being defined. All the data your classes needs should be passed to it as function parameters. What I like to do with data accessor classes like that is have a create() method that accepts an array of field values. Fourth, *even if* you were using $_POST, you should still check whether each array key is defined via array_key_exists() before referencing any of them. Check out a framework's database methods. They'll give you all the functionality you need while avoiding the pitfalls. Why reinvent the wheel?
That was not the correct choice. Apart from this being a massive security hole, you're doing no validation whatsoever. You're mixing PHP code with the template, not including your files properly, setting public properties in a constructor without reason, not naming your classses properly, there's no separation of model, view and controller logic, and on an on. There are just too many issues here. If you don't see these things, you're just not ready to do this by your own. Learn a framework, use it and learn by its example - that's my advice. 
Way over my head -- I hear that. Thanks. Codeigniter?
[Laravel](http://laravel.com/docs)
Your classes have no clue what `$db` is. you have you give it to them. $event = new event( $db ); $event-&gt;insertEvent(); In the constructor of your even class set an internal propert $db to the passed $db function __construct( PDO $db ) { $this-&gt;$db = $db; } Then in all the palces you use `$db`, change it to `$this-&gt;db`
Nevertheless there are many optimizations that are performed during the interpreter's initial pass.
Installed. Thanks. Just browsing through here I imagine this is mvc also. I guess I see myself working through this code and no longer will this website be a wordpress website. I inherited a mess... and I might as well do it the right way. 
What's the benefit of this over the normal HTTP detail view in the network tab?
I use mailcatcher for this http://mailcatcher.me/ 
Internals came with plenty. The most obvious to me is the ability to create mock and stub objects for unit testing. Finally goodbye to PHPUnit's mock API.
Wow awesome thanks!
no problem :)
I can't agree enough. I look forward to the day when I can write: $data = { firstName: "John", lastName: "Smith", age: 25, address: { streetAddress: "21 2nd Street", city: "New York", state: "NY", postalCode: 10021 }, phoneNumber: { home: { number: "212 555-1234" }, fax: { number: "646 555-4567" } } }; Rather than the awkward: $data = (object) [ "firstName" =&gt; "John", "lastName" =&gt; "Smith", "age" =&gt; 25, "address" =&gt; (object) [ "streetAddress" =&gt; "21 2nd Street", "city" =&gt; "New York", "state" =&gt; "NY", "postalCode" =&gt; 10021 ], "phoneNumber": (object) [ "home" =&gt; (object) [ "number" =&gt; "212 555-1234" ], "fax" =&gt; (object) [ "number" =&gt; "646 555-4567" ] ] ]; 
You can write it in JSON and convert it directly to an object...
Right in the read me it indicated that it could be used in other browsers as well, with a hoop or two to jump thru. 
Considering how they implemented goto in 5.3, I doubt this would be much of a concern to PHP devs.
Oh, thank God. Already love 5.6 (=
I have always used stdclass() for this type of thing.
Congrats PHP
Wow thanks for that, and sorry for my late reply - my head has been buried in reading code in frameworks. That's an interesting point you make about distributing code over servers, because I started planning for this in one of my earlier apps eg have admin user on a separate server from customer/users, but as yet I haven't researched how frameworks approach this. Do you know of any 'best practice' or real world app examples that show the best-ish way of doing this? Between posting my OP and this, I've settled for standard-ish MVC and am trying to use the composite pattern for partials (if I'm using the 'partials' term right), starting here: http://www.sitepoint.com/flexible-view-manipulation-1/ I was only really interested in HMVC, because the first framework I tried a few years ago forced me to use one view per controller with an inflexible templating system, which was horribly inefficient for view reuse eg no partials. Building my own micro-framework to refactor my old apps 'into', I don't want to code myself into such a dead-end. Any links to great tutorials or code examples for view patterns and classes would be immensely appreciated! Thanks again!
does this mean i can pass variable num of arguments to call_user_func_array? if so, juicy.
There is not better way to do **maximum possible harm** to a newbie, then recommend him/her to use framework, before grasping the basic principles of OOP.
Thanks so much, and my apologies for the late reply! I've bumped into SOLID via a few references here and there and have got my head around the easier parts - the S, the O, and I, so far, haha. I've been reading about the L and D, and think I may be on the cusp of understanding and even coding the D part now, but most examples of L still confuse me. I'm hoping as I improve as a coder and improve my micro-framwork, I'll understand it. I've also come across the GoF, and have been reading bits of PHP Objects, Patterns, and Practice, but at this time I can only hold about 5-6 patterns in my head, that is use them well-ish in my code, so hopefully there's little chance of me treating every 'problem' with the same pattern. I'm determined to keep re-reading the books I've read recently that got me coding better, and I'm now in love with gitbhub for reading the code of others frameworks, so hopefully I'll discover better patterns and practices as I go. And people like you and public_method really make this forum a great place to learn! Thanks again!
It's for people who can't figure out how to properly profile their code. I can't see any reason to use this, it's marginally more information than you'd normally get with a request, but far less than you'd get with a proper profiler.
Indeed, and it will be time well spent, methinks. Since you mention it, here's something else for your readling list: http://www.phptherightway.com/ 
Great more syntax inconsistent with almost every comparable language.
Why should your router care about anything but routing? Your router's job should be: * Get URL * Use either pre-defined routes or 'guess' what the route requested is * Parse any possible `$_GET` parameters * Return the Controller and Action name that corresponds to the route That's it. That's a router. Now, there's a bunch of other things you'll want for a functioning request/response execution: * Make `$_GET` or `$_POST` data available outside of those superglobals, * Call the actual controller/action * Figure out what template is wanted * Parse template * Parse response to browser * Return response Good luck!
Thanks for the quick and informative reply! Yes, I would like to adhere to SRP part of SOLID - thus just have the router do... routing. I guess I'm must a little confused about security? Other than session management etc, what stops someone entering a url that corresponds to a controller/action that they want to 'skip' to when they shouldn't have access to those methods? Is that the role of a central user management/session controller or can/should the router help in vetting urls in this regards? From your reply, it appears the router shouldn't know anything about this. I guess I'm thinking of something more akin to a firewall than a router in this regard? I am using nginx with php-fpm and as yet haven't worked out how to use $_GET for urls, so am using $_SERVER["REQUEST_URI"]. It is working. Is this what you mean by 'Make $_GET or $_POST data available outside of those superglobals'? I'm hoping I'm not going to have similar difficult with $_POST! I should make form to test this, but want to get my router working first. I'm still confused about how routers treat $_POST eg for forms - should I have code in the router for doing this or is this the responsibility of the controller that the router hands-off to? Can you elucidate or point to any good router code, please? Thanks again for your awesome reply!
It's really weird how PHP chose to copy languages that nobody has ever heard of. JavaScript and Go? Nobody knows what they are.
Using the unpacking syntax yes.
Hiya, yeah I haven't looked deep down at the options themselves, like I said, its a work-in-progress, and I'll start working out the kinks based on suggestions like yours :)
Nobody would ever do this if they value their genitals. 
Java has same syntax too
`$_GET` variables would be something like http://foo.com/controller/action/?userId=123&amp;name=jtreminio Inside your `$_GET` superglobal you would see both `userId` and `name`. However, you can also have pretty urls. Take a look at reddit, for example: http://www.reddit.com/r/PHP/comments/1mzxhu/questions_about_mvcs_router_and_controller/cce5v5t The information being passed is everything after the `.com/`. As far as security, yes that would be a firewall, using roles/acl.
In the context of *this* code and the obvious intent of the OP to continue developing it, the only responsible thing is to recommend a safe(r) environment within which to continue, and that means a subset of PHP and that means a framework with more focused docs than the whole of the PHP manual and a well-defined domain. This is at least something born out by experience. If you have better concrete suggestions to make for the OP in the short term, then do so, and be helpful and pragmatic rather than posturing and dogmatic. 
Not to diminish this, I think it'll be a useful feature. But it seems weird that something like this gets added, and yet [the Enums proposal](https://wiki.php.net/rfc/enum) has wallowed away for nearly 3+ years :/ *(Yes, I know about [spl_types](http://php.net/manual/en/book.spl-types.php) -- I recently had to can it because it was causing segfaults with 5.4 &lt;sadface&gt;. Plus using "classes" to make enums was weird -- and misleading to developers who then tried to add methods to them.)*
Ty I (hope) know what get and post are and the difference in how they are passed, but wasn't sure if I was missing something in how to handle them securely, eg protect them as vars but make them accessible to code. But I am now confused about pretty urls, which I thought I understood, haha. You are really testing my noob knowledge, which is awesome! Thank you! Are clean urls made by the controller passing the params following the controller/action 'internally' to the controller rather than in the url? I've seen a router that takes the params out to become an array, which I guess is for clean urls? Forms often use $_POST, but is it possible to use that for 'hiding' params, or would an array be best, and even still, I imagine any forms being passed by $_POST in my app should also be routed back to the relevant controller via the router? Ah, ty re the firewall clarification - I'm looking to build in rbac, but as yet haven't seen a 'firewall class' in a framework and roles/acl appear to often be an 'addon' of sorts, rather than a core framework class.
I went ahead and did a MVC in both code igniter and laravel.. the laravel one didn't work out to well. I installed the wamp stack from bit something or other so I could have quick access to more frameworks. I did a lot of py thon the right way and really liked it. Will check out php one for sure. I would like to setup to debug and that is the only problem I have with .net and php... I haven't ever taken the time to set up the enviro. Php I've always done from the browser... I just light up a sub domain. It really hurts for getting instant access to what is going on, but I learn the code inside and out I think. I ended up removing the classes from the site and getting the PDO working.... for the first 5 or 6 queries. I did some googling and didn't really know what I was looking for because I couldn't get an error message. I did try statements all over the place and couldn't catch an exception. All the code is the same as above so I am thinking hosting /server is an issue OR I don't know what I'm doing. I also do my php in visual studio so I know that isn't helping. Going to load up the laptop and see what php the hard way has to offer as a setup and work from there. Its hard for me to take time and mess with the work machine. Thanks for all your help I do appreciate it. I know I catch hell when I post in here because I don't know what I'm doing mostly, but I have thick skin and can handle it. 
Thanks, that's a great list(!), but I've tried to look at all of these, and so far found they have an abstract or interface class or higher level code hidden away that does some 'magic' (if I'm using the word right?) and they want me to use their router in specific way, which doesn't teach me much. For example, when I look at Laravel, I end up getting lost in the Illuminate(?) libs, which hide away a lot of methods. I was hoping the Slim router would be slim enough for me, but it also appeared to rely on too much code above it. If I'm wrong, please slap me in the brain, and I'll try to have another look. I'm trying to write a router from scratch, that does just enough of the basics to work for an app, and one that I can improve upon as my apps improve. I've found a few tut's and am trying to work through them, but the code isn't commented nor well described so it's slow work testing it and working out what does what. But yeah, out of frustration I keep returning to what popular frameworks do, as their docs often at least educate me about what a router should actually do, even if I can't understand how theirs actually does its 'magic'. I wish I could find a book that focused on building a framework or at the very least explain what a framework should have, and go into detail about core classes etc eg a router/dispatcher, as if describing an engine. I know each framework does this to some degree in their docs, but often at a very abstract level.
shiiiiiiiiiiiiiiiiiiiiiiiiiit. I've been trying to connect to phpthehardway.com. stupid stupid stupid. reset the router... hey.. let me log into reddit and hit the link. facepalm
&gt; I have thick skin and can handle it. Heh, good on you, there's a lesson for us all there.
http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1 Part IV deals with your exact question, but read the whole thing through. Then read the rest of his articles.
&gt; I wish I could find a book that focused on building a framework or at the very least explain what a framework should have Aha! I have the perfect things for you then: [Symfony 2 vs Flat PHP](http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html) [Create your own framework on top of Symfony2 components](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1) You don't have to like Symfony to appreciate the lucid, accessible descriptions of first principles of framework design in those articles. As for routing code, Kohana's is probably the easiest on that list to grok, but read it alongside [this helpful Request code](https://github.com/kohana/core/blob/3.3/master/classes/Kohana/Request.php#L216).
I will mess around with a framework and learn from it.. but moving over immediately isn't something I can do with this project.. 
Will continue doing the functional programming for this project because of how large it is. I will go ahead and learn some oop and mvc on a smaller scale. How is it that max possible harm will come out of it? I'm just curious.
I got what you are saying here. Thanks for this. I had tried making a class for the db.. but really struggled with it. I think I have to mess around with this stuff on the weekend..
I stripped a bunch of stuff out to simplify the code so I could work with it, then I would go back and improve it... but I completely understand what you are talking about. I appreciate your feedback.. I will be learning oop on a smaller scale and work with a framework in my off time so I can have more experience in it. Thank you!
That looks awesome, those benefits look great. Also exciting: [Argument unpacking](https://wiki.php.net/rfc/argument_unpacking) as referenced at the bottom of this RFC. That sort of flexibility would be very useful. 
Note: functional programming and procedural programming are two different things .. look it up some day. It might make you better at JS. If you start using PHP frameworks before you have good grasp on OOP principles and practices (SOLID, SoC, LoD, QCS .. look 'em up in google), then you will end up "learning OOP" from frameworks. Unfortunately PHP frameworks are infamous for the amount of bad code that they contain. Same goes for learning MVC. I'm not aware of any PHP framework that implements MVC or any MVC-like design pattern. Most of them simply follow the Rails example. Hell .. most of them call themselves "MVC frameworks", while reality is that frameworks do not implement MVC (or any other architectural design pattern). Your code does .. or at least tries to.
I had a lot of fun learning functional programming and made some very interesting programs with JS... after reading some eloquent javascript and also sitting in on some online classes a coworker was taking on Udacity. I believe it had to do with Clojure. He actually took me WAAAY back and we were both watching/listening to some really old videos. Some very interesting stuff. Anyways, I understand the difference between the three different types. My background in php is from years ago. I haven't really messed with it in years except the occasional wordpress work I've done, and everything before that was basic concepts, form work, basic database stuff. I missed out on all sorts of good stuff by ending up doing marketing for a few years with minimal web work, so I really lost touch with what was going on. MVC and OOP is something I would like to learn in everything I do, but there are such horrible places to find anything php related anywhere on the net. It seems most are written badly or contain bad practices. I subscribe to a website, pluralsight, which really helps me out with .net stuff, but it has nothing for php.. which makes me really sad. The manual for php is really all I have to go by... and then a tutorial that teaches me the wrong way to do something.
You might find [this list](http://stackoverflow.com/a/16356866/727208) useful. Thing is, when you start trying to learn anything beyond basic in PHP, you will quickly end up in language-agnostic territory. There are very few PHP books and lectures on the subject.
&gt; In particular, this RFC does not propose to deprecate or remove the func_get_args() family of functions, at least not any time soon. This is important. I can see use cases where you want to access some of the arguments via named variables, and you still want to access *all* arguments in an array (to call another implementation of the function, perhaps).
give a try to https://github.com/myclabs/php-enum ;) (it's still "classes" though, not perfect but maybe better)
Someone's grumpy
While the author of this article is correct, most current generation (and especially old) frameworks make controllers very hard to test. For example, if we were to take the current Symfony 2 Standard Edition, we see that the default BaseController is ContainerAware, meaning the whole DI Container gets injected into the controller. This practice provides a new user with a lot of added benefit (availability of core services via defined getters), but makes controllers harder to test because it's difficult to keep track of dependencies. 
Another way to look at it is: why would you want to test your controllers? They are supposed to be as slim as possible, and not contain any domain logic. Maybe if they need testing, some code they contain could be moved to a service, or helper? (I'm just opening the discussion and not bashing the article)
You have a good argument. I could be convinced.
It depends. Are they doing any sort of customization to it? Theming? Custom plugins? Because those things are all quite difficult for anything but the simplest cases.
Since when did JS have it? Unless ES harmony does?
You might consider following FIG standards (PSR-0 through PSR-3). Edit: Also consider commenting your functions, using an autoloader, and providing an example of using it, including adding a plugin, etc. Edit2: Try to avoid the 'private' keyword, as that just means no one can extend those functions. 'protected' should work for everything you're doing, from what I can see. Edit3: Use a namespace for your library, perhaps. Also, I'm not sure I like the generic class prefix of "Core\_Library\_".
installing wordpress takes about a half hour. doing new layout and custom design will take time. 6 to 12 hours for customization is reasonable. do the math.
Thanks for the review. This framework has been extracted from a production system and some of the things you mentioned are already in my todo list [0]. I will definitely look into your other suggestions too. I would also appreciate if you can send a PR or create issues. [0] : https://github.com/oguzbilgic/hivli/issues?state=open
What does "integrate" mean? What exactly is it that they have been tasked with doing?
I just now found your roadmap, and you already plan to address most of my suggestions. One question I have is concerning the decision to remove multiple application support. What are your reasons and thoughts behind this? What are the problems you run into by supporting multiple applications?
Installing wordpress takes about 20 minutes, but it depends what you mean by "integrating."
Agreed. Integrating Wordpress into a Magento site can take a lot more than 10 hours once you account for all the testing that needs to take place. I know from personal experience.
For 13 hours I'd be charging a hell of a lot more than $200. It all depends what "integrate" means. You need to be a lot more specific.
This isn't an ideal setup, but it's what I use (and what I like): - GitHub repos for all work - Windows 7 box with NetBeans 7.3 - VMWare Player with Ubuntu installation I use my Ubuntu VM to handle all my SSH, I use GitBASH to handle Git on the windows side, and I can run my own test server in the VM (which can pull from git directly). However, due to the scale of the application I work on, I actually have my own dedicated dev instance in our AWS account that I SSH to and pull code down onto with a local deploy script, and it connects to a dev database that is sandboxed but that mirrors the live db.
Class constants are also often used to replicate database ENUM data type without having to worry about pesky migrations. create table users( `id` INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, `username` VARCHAR(255), `status` TINYINT(1) ); // It's own separate class class UserStatus { const ACTIVE = 1; const DELETED = 2; const INACTIVE = 3; } // SELECT * from users where status = UserStatus::ACTIVE // Sometimes in the User Class class User { const ACTIVE_STATUS = 1; // ... imagine more code here } // SELECT * FROM users where status = User::ACTIVE_STATUS 
200$ ... 13+ hours ... way to destroy rates ... :(
&gt;It's for handling different roles of users, surely. What happens if a user gets promoted/demoted to/from admin? If you're thinking of doing what I think you're thinking of doing, your system is going to scream at you so bad. Yes. This has been a problem that has been bothering me for a while. Even with that special case, I think there is advantage in being able to use different types for different users as this will detect and avoid hard to detect bugs in code. Also if I use same object for all the user role, I will have to do a user role check in every method of the user object., right? like this.. public function getOrganization() { if($this-&gt;type == 'administrator') { ...code to get organization for administrator... .... } elseif($this-&gt;type == 'user') { ...code to get organization for user... } } 
I use stdClasses too, but they are far from convenient for complex structures.
I've read the RFC but I don't see the point. Is this really necessary? can't one just have an optional $params array argument and fill it as needed? E.g. following the sendQuery example: function sendQuery ($query, $params = array ()) And then: sendQuery("SELECT * FROM user WHERE userID = %1 and bla = %2", [24, 32]); This would work fine for all the use cases the RFC suggests. 
on the one hand, 200$ isn't that much. if it is a contractor he has to pay taxes, insurances and stuff. on the other hand... 13 hours and 15$/hour sounds fishy. 
Plus I take it profiles every single request? Normally one wouldn't want to profile constantly, it'd make the app significantly slower.
wtf is that post...
It's about making the syntax more readable and easy to understand. Your example: sendQuery("SELECT * FROM user WHERE userID = %1 and bla = %2", [24, 32]); Could be interpreted as passing the array `[24, 32]` as argument `%1` and a NULL value for `%2`. sendQuery("SELECT * FROM user WHERE userID = %1 and bla = %2", 24, 32); Clearly always means that 24 is passed as `%1` and 32 is passed as `%2`.
C++: `template&lt;class...Args&gt; void print(Args... args) { std::cout &lt;&lt; ...args &lt;&lt; std::endl; }` Practically the same as PHP.
I've always found that most languages are similar and each have their own little ways of doing things... and then php can really break that mold! Thanks for this list.
You can already do this today, and not as verbosely: $iterator = function() { $i = new DirectoryIterator(...); foreach($i as $item) if (/*test*/) yield $item; }; Of course you can capture the source iterator and predicate instead of hardcoding them if you want to.
I would say - price is correct. The question really is why spend 13+ hours to do it. I mean for 13+ hours an unexperienced person will install it, just by reading the documentation and some tutorials. The rest is like /u/kristianwilliams said: &gt; And another pet peeve from my clients, if its so simple, why not do it instead of paying someone else to do it? Your paying for their expertise, not just the labour.
This is a good year for PHP.
It would. I guess the line should have been something more like if (value === “” || value === null || value === false) A value of zero would not work in my code, but I dunno, you say...
Yeah, I though so. It just confused the hell out of me when I first saw it. Cheers.
After a brief look I saw lots of things I didn't like, for example: * [This](https://github.com/oguzbilgic/hivli/blob/master/lib/Loader.php#L7) tells me the author doesn't know how to use `call_user_func`, which is a big turn-off. * Pretty much everything seems to be a singleton. Singleton is bad, it makes testing the code a nightmare. Why not DI instead? * The DBAL is very restricted in functionality and the little that it does, it doesn't do well. Why cross joins everywhere instead of left joins? You might want to look into these.
&gt; Also if I use same object for all the user role, I will have to do a user role check in every method of the user object., right? Uh. Why? Just have a user table and a organization table and map it directly. Why would you need special code for different account types? 
Because, may be, the organizations are related to administrators and normal users differently..organizations have an administrator attribute. But users has to be associated via tags. So the code to retrieve and organization for a user and administrator are different. 
There is a potential major exploit here: class Core_Library_Loader { public static function get($moduleName){ require_once $moduleName . '.php'; eval("\$loadedClass = Core_Library_" . $moduleName . "::getInstance();"); return $loadedClass; } } There is no need to use eval() as you can run the method like so: $loadedClass = call_user_func("Core_Library_" . $moduleName . "::getInstance");
and the lesson is: if you write text for humans, !(use programming language).
I use XAMPP/Eclipse (PHP) locally. Then I use a bash script to rsync my remote (staging) directory. Then another script to rsync my other remote (production) directory. ^^^ This step could be replaced by a mixture of SVN/Git commands, but you know!
We don't mount and write directly to the server?
Few points of feedback. 1. Why create your own status codes? HTTP spec provides them, why would I create another thing that devs would need to go read, and more data to send over the wire? Have the spec do the work. 2. The ApiInterpreter seems like a half-HttpFoundation from Symfony, in that it's a pseudo-wrapper for request data. Why not use tested components for this? 3. Specifying prefixing private/protected methods with '_' is old-hat :) 4. Don't ever write your own JSON, never ever ever. Use `json_encode`/`json_decode`, or some other method. Some other good tips here: http://philsturgeon.co.uk/blog/2013/07/building-a-decent-api
[Correct](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Spread_operator).
Current setup at home: * Gentoo Linux with Awesome WM - (tiling WMs are convenient) * Sublime Text 2 * PHP Syntax Checker plugin * PHP unit testing * ZSH as shell for terminal - History and the up arrow are a luxury with aliasing... * Commit to subversion for work or git at home *** At work: * MAC OS X * Sublime Text 2 * Fish prompt * Subversion -&gt; Branch -&gt; Upload to production 
People seem to be commenting on the wrong things here. Yes, you're not sanitising your inputs. But you actually shouldn't need to, because you **should** be using prepared statements. You are *almost* using them. But just not quite. First some housekeeping. Don't name things like this. Your classes should be named BumpyCase. Events. Matches. There are conventions, and they're like that for a reason. Learn good habits now. While on the subject, your classes should be in a separate file. **Each.** Now we'll get onto what you're doing actually wrong. For a start, you're breaking down and then rebuilding the POST array. There's no reason to do that. More than half of your code is redundant. Not only that, but it's actually a negative. For example, if you want to add another field you have to add it in the database, the form, the constructor, and as a class attribute. Those last two just aren't necessary. The prepared statement is where most of your issue is. Prepared statements are golden. They're good for maintainability and security. Here's your event class written with prepared statements properly. class Event { private $database; public __construct($database, $id = false){ $this-&gt;database = $database; } public function insertEvent($eventData) { $prepare = $this-&gt;database-&gt;prepare("INSERT INTO event ( promouser, eventname, fightclass, no_of_matches, status, doe, venue, city, state, country, zip, sanc_body, doctor, refree, referee2, judge, judge2, judge3, boxcomm, descript ) VALUES ( :promouser, :eventname, :fightclass, :no_of_matches, :status, :doe, :venue, :city, :state, :country, :zip, :sanc_body, :doctor, :refree, :referee2, :judge, :judge2, :judge3, :boxcomm, :descript )"); $prepare-&gt;execute($eventData); return $this-&gt;database-&gt;lastInsertId(); } } The actual call should essentially be something like this. $event = new Event($database); $eventData = $_POST; $eventData['promouser'] = $_SESSION['username']; $eventId = $event-&gt;insertEvent($eventData); That for loop also gives off a strong whiff of "doing it wrong" as well, but I'll leave that for now.
To install WP on a subdomain with a default theme, yeah, 20 minutes. To install WP with a custom theme/layout matching the rest of the site? That's different.
Other than not being as weird, what actual gain would you get from adding real enums to the language. i.e. what would you be able to do that you can't do now with SplEnum? Also - the problem with that enums proposal is _it just isn't that good_. The problem with it is that it assumes enums ≅ integers. i.e. you wouldn't be able to do: enum Month { 'January', 'February', 'March', //etc } or be able to do the planets example from http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html
Like others have said, basic Wordpress setup/installation is easy. The big question is the level of integration.