&gt;Are you using that expression to convey a sense of positivity? Is it that you enjoy being blasted by a spray of pneumatic turds? To be fair, he is a PHP programmer...
Congratulations in your witty retort, only 50 days too late to be actually funny.
I use *.dev.local so that I can have a wildcard self-signed SSL certificate for all subdomains that I might want to use. This means that I can test HTML5 features that need SSL, e.g. webcam, geolocation, etc.
So do I, especially since we have different services on acmecorp.net and acmecorp.com (which is probably a bad idea but that's a different matter). Then I use acrylicDNS to route local.* to localhost.
`include_once 'classes/WhatsappCallService.php'` Seriously?
&gt; Maybe Hack is a compelling platform for new code Yes, let's bet the ship on an incompatible single-vendor fork of a language whose best asset is ubiquity. Very compelling. I become moist just at the thought of it.
Is there a particular reason you dislike destructors? What have they ever done to you?
He outlined it in the blogpost, but TL;DR is that they make it harder to write an efficient JIT. HHVM is *forced* to refcount everything and immediately call destructors on objects when they fall out of scope. That sounds reasonable enough, until you realize that for the most common form of class definition, immediate destruction isn't necessary at all and causes runtime to be slightly, but measurably slowed while it deals with dead memory. More than that, optimizations like tail recursion and inlining have to mimick this behavior which undercuts their ability to improve performance.
As a PHP Release Manager, I endorse the dropping of PHP 5 support. :)
Looking at how they're used, there's equally usable (and potentially less spooky-acting-at-a-distance) alternatives for the common patterns (e.g. 'with()' for scopeguards), and destructors introduce the requirement for refcounting; we don't want to use as much CPU time on --, ++ and jz.
Half hour using something that is already implemented not building it from scratch. I would be hard pressed to find someone who can write this from scratch in 30 minutes. And if they can i doubt its very well written code.
There's another feature heavily dependent on ref. counting: copy-on-write ZVALs (arrays, strings, resources, etc.) Trying to eliminate ref. counting is IMHO misguided. Apple tried to eliminate ref. counting from Objective-C years ago and they realized ref. counting has some strong benefits. Pure mark-and-sweep garbage collection is associated with much higher memory usage, longer and harder to avoid stop-the-world pauses, and non-deterministic destructors. This is why Swift is still ref. counted (and has such a strong focus on copy-on-write value types, by the way). There's nothing to dislike in deterministic destructors, i.e. I don't know what you deem "spooky" about them. They're a great language feature that allows an object to take care of itself and the resources it uses. I don't see how replacing them with *manual resource management* is a step up for a high-level script language. Are we trying to make PHP easier to use or easier to screw up in? 
His list of reasons for PHP being bad is simply an argument a purist would argue about. These are all things that experienced PHP developers already know and work around. Bottom line is that PHP does exactly what PHP is used for. The more experience you get with PHP and OO programming the more powerful the language becomes. 
I feel your pain my friend. The programming world has a big D complex and always looking for the latest and greatest headache. Then scream MUH NOT SMART ENOUGH when things come tumbling down a break. I will stick with my PHP and develop the same things they can without the headache.
copy-on-write doesn't need full refcounting - i.e. you just need to keep track of if the number of references === 1, or is &gt; 1, so you can use a single-bit, with no -- or ++ - just an assignment. While this can lead to some wasteful copies, it currently seems likely to be more efficient than full refcounting.
Exactly.
True, but Facebook is a pretty huge vendor. And I'm not sure proprietary is the right word. Sure, they're in control of merging commits, but that's different. In any case I would be wary of using hhvm/hack unless you actually want to work at Facebook. Edit: typo
RIP PHP 5. It brought PHP kicking and screaming into the early 1990s.
&gt; The HHVM team believes that we have a clear path toward making Hack a fantastic language for web development, untethered from its PHP origins. Good luck, and I mean that seriously. PHP is some really awful baggage for language design. May I make a few suggestions on things to change? - Unify symbol tables and allow referring to functions and classes by symbol. The fact that we have to use strings for these is a serious refactoring and code analysis pain. - Unify case sensitivity. I'd prefer case sensitive but entirely case-insensitive would be great too. - Unify behavior with regards to undefined constants, functions and class-likes. - Once the above points are done you can now do general symbol autoloading instead of autoloading for only classes, interfaces and traits. These things would make me significantly happier with PHP, anyway. That plus generics, which Hack already has.
I don't see why it'd be more efficient. You still need to check (and if needed - update) this flag at every step. And tripping a bit flag is not "just assignment" because to make it "just an assignment" you'd have allocate a full CPU word for that one bit, completely negating the supposed storage improvements. If you want that 1 bit to take 1 bit, it means it's in the middle of a packed bitfield, and you're explicitly or implicitly doing bitwise operations on it to both read it and to set it. It's hardly a win, especially as refcounting needs not take more than one byte in most cases, i.e. it can fit 0...127 (intepreted as 1...128) references in the low 7 bits of a bite, and then the last bit is used to extend the count for extreme (and very unlikely) scenarios. This is how Swift/Obj-C optimizes ref. counting storage. So bottom-line is if you implement the bit flag you'd still need most of the infrastructure and CPU busy-work of reference-counting, but you'd lose a lot of the benefits from it. I've implemented this workaround for copy-on-write in pure-GC languages like Java, as obviously I don't have much of a choice as to how the JVM works, but if you have access to *real* reference-counting in the PHP VM, moving to a bit flag seems like a really unbalanced trade-off.
PR spin aside, by "dropping PHP 5 support" they basically mean "dropping PHP support", as references and destructors are not PHP 5 legacy features. They're very much core PHP features. Cheering for HHVM to no longer align with PHP is cheering for a Zend Engine with no competition. We know what happens when Zend Engine has no competition. Stagnation, lack of *meaningful* innovation, and excessive bikeshedding.
Yes, my response was probably overly broad. If you are just working on your own private (home) network, then you're unlikely to have any problems. Microsoft used to advise against the use of `.local` for internal systems on networks that had Mac clients, due to conflicts with Bonjour.
There is this package that allows using the Cake ORM to perform async queries https://github.com/WyriHaximus/cakephp-async-orm
Looking forward to seeing a PHP-ish version of `in`/`out`!
The following codes will never be used as a TLD: - AA - QM to QZ - XA to XZ - ZZ This is because they are part of the user-assigned area of ISO 3166-1, and DNS follows that ISO standard with regards to 2 letter TLDs. The country code ZZ is technically already assigned, but for usage in a fictional country, making it the perfect candidate for development purposes. In the end, you just use the regular SLD's, with the .com or .org TLD's replaced with .zz 
I found this thread looking for PHP benchmarks. I was wondering how the latest versions stacked up, and trying to do comparisons of 7.1 and 7.2 was really worth an upgrade over 7.0, or adding a new repo. Then I found an apt description of PHP programming :)
Bot's dead, Jim 
I'm curious why you guys didn't use https://github.com/nikic/PHP-Parser which would've made the project significantly simpler.
nit; AIUI, that's part of the longer-term departure from PHP7 support. I could be wrong though.
&gt; The operational concept is quite simple, really: &gt; &gt; 2) We feed your PHP file to PHP-Parser 
I have a question. If Facebook could start over, wouldn't you say they'd have benefited much more by moving their code (gradually) to Node with Flow (where basically Flow:Hack = JS:PHP), instead of literally reinventing PHP with a custom runtime, type-system etc.?
Hmm, I kind of missed it in the "require" list. My bad, thanks.
By inference, you think Symfony and Laravel are shitty, so how is Spiral Framework any better? It's no good saying it deserves more attention if you don't explain why. From a quick skim of the documentation and code, nothing jumps out as providing any significant improvements over either of those, it's looks solid enough and reasonably well tested, but that isn't in itself a reason. The documentation is written in very broken English, which isn't a deal breaker by itself, but it's certainly very unclear in places and suggests there aren't many eyes looking at it, for example: &gt;Spiral does provide ViewModel implementation by default, but rather simply access to rendering functions of view templates.
We'll be dropping destructors *from Hack* soon - references have always been banned in Hack, we're just planning to create an alternative. Both will continue to work with PHP code on HHVM until we're at a point where "pure Hack" projects are practical
Pretty much my exact thoughts reading the article. The improvements in PHP7 are more than good enough for 99.99% of PHP users. I wonder what Wikipedia will do? They moved to HHVM a while back. I guess they'd prefer to stick with PHP instead of Hack so presumably they'll move back to the PHP runtime?
I'm going to ask you the same question I asked /u/SaraMG - if you could go back would you reinvent PHP at all if the end game would be just an incompatible fork that's mostly specific to Facebook? Why not use Flow + JS?
&gt; Unify symbol tables and allow referring to functions and classes by symbol. The fact that we have to use strings for these is a serious refactoring and code analysis pain. Array and string callables are banned in Hack; the fact that class_meth(), inst_meth(), fun() etc are backed by them is considered an unsupported implementation detail, and likely to change. &gt; Unify case sensitivity. I'd prefer case sensitive but entirely case-insensitive would be great too. Hack is fully case sensitive &gt; Unify behavior with regards to undefined constants, functions and class-likes. Banned in Hack. &gt; Once the above points are done you can now do general symbol autoloading instead of autoloading for only classes, interfaces and traits. https://docs.hhvm.com/hack/reference/function/HH.autoload_set_paths/ - made convenient with https://github.com/hhvm/hhvm-autoload (composer plugin) Some of these 'banned' behaviors are still implemented in the runtime, so they'll show up on 3v4l; however, they'll fail in the typechecker, and in the default HHVM configuration: HHVM usually won't execute Hack code that the typechecker says is bad, however 3v4l explicitly allows it.
Sorry, I missed a few things; we don't really have 'referring to functions by symbol', however the `fun()` construct returns an appropriately typed callable (with parameter/return types). Classes by symbol: Foo::class is a subtype of string, a classname&lt;Foo&gt;: https://docs.hhvm.com/hack/types/type-system#type-aliases__classname
Wikimedia's sites run on MediaWiki, which is a very popular PHP application, so I'm sure they could switch back to PHP 7 and be fine. There might be custom extensions and stuff they'd have to sort out but it's surely a surmountable hurdle. And HHVM's performance lead is much smaller since PHP 7.
To clarify, though: the tables aren't unified, correct? You can have `foo` as a constant, function and class all simultaneously?
Sorry, yes, that's correct - so our autoloader interface supports providing separate maps for each symbol table, and/or a failure handler that gets passed 'type', 'function', or 'constant' in addition to the name, allowing you to implement PSR0/PSR4 or similar.
&gt; From a quick skim of the documentation and code, nothing jumps out as providing any significant improvements over either of those When laravel came out, people were saying exactly this, yet it took laravel 4 to even enter the conversation and that was back in 2014. So yeah don't let your internet beef w/ this guy cloud your judgement.
Just pull your boss aside and be honest. As someone who has both been in this situation before and is now in a management position the reality is that unless you've been wasting time and not putting in the effort (which you obviously have been), then your boss probably won't care at all that you're struggling, and will be more concerned with getting you the help you need to get things done. If your boss comes down hard on you after all this, then I would tell you that you work in an unhealthy environment and your own health and wellbeing is not a price worth paying, and to start looking elsewhere for work. Is your boss a technical person? Non-technical bosses can fall prey to this idea that because it sounds easy to describe, then the whole thing is easy (I'm sure many people here have heard "well isn't it just as simple as adding X, Y and Z where all three are incredibly complex items with far-reaching implications). If your boss is non-technical, it could also help to prepare a layman's explanation of why the task is so difficult. Finally, some tasks can seem massive and overwhelming on their surface because the description given to you is something sweeping and large. From my experience, it can become especially draining if you spend large amounts of time working on these features without getting any kind of small victory. I've found the best way to tackle both is to break these larger tasks down into smaller tasks that encapsulate minor features of the overall job so that for each new feature you can turn around and show progress and get those runs on the board.
This sounds like a good way to wake up to a $10,000 bill one morning.
Cool why don't you publish it on your blog.
If only PHPStorm has first class Hack support 
Given that Facebook is older than Node, I'm going to presume you mean "If FB could start over *today*...". I doubt very much FB would jump straight into developing their own runtime *today* for a number of factors: 1. PHP 7's speed is roughly apace with HHVM, so the perf question (sort of) vanishes. 2. PHP 7's AST makes replacing the front-end compiler to gain HackLang features (relatively) simple (compared to a full rewrite). 3. LLVM is *far* more stable and mature than it was at the time, so there's also less need to write a custom JIT. As to the theory of moving a very large codebase from one language to another, that always sounds simple in theory, but that also means a helluva lotta decoupling and rearchitecting along the way.
I love the mic-dropping mood of this response very much.
You mistake me. I have no idea who this guy is and my question was entirely genuine. From a quick skim there *is* no obvious unique selling point, so I want to know particularly what it is they see in it so I can take a look at that.
In case you are looking for a tutorial, here's one https://github.com/teamtnt/tutorials/blob/master/text-classification-with-php.md
PHP has had no notable competition in terms of implementations for most of its existence, yet succsssive releases have made huge improvements (2 to 3, 3 to 4, 4 to 5, the 5.x series). HHVM probably helped but PHP shouldn't stagnate without it.
yeah some of us don't give estimates, we are given them. For example I'll say something will take 12 months, and the response is we need it done in 4. That turns the dev cycle into a 4 month hackathon and then doing tests post launch. Then switching to TDD for additional features and maintenance. Its not a good way to work, but the reality of business is there is generally a 3-4 month window between conceiving of a project and the market window closing. Cumbersome enterprise development has the benefits of large budgets, and only internal pressures. Startups just don't have the same luxury. We don't deliver, we find new jobs.
Yeah, I like that better :-)
With this, we deem Voyager Production-ready! We're sure there are still some minor issues that need resolutions, so please continue to open issues and pull requests. With this release, we have a ton of new features and bugfixes, here are just a couple of them: * Re-built auth/permissions system * Relationship manager built-in * Settings Groups * Bulk Delete functionality * Compass Reference Section * Hooks (functionality to build hooks/plugins in Voyager) * Smaller Footprint (the package is about 1/4 the size) * And so much more! Don't you hate using something that hasn't released a version 1.0 yet... Sometimes we do, but now it's all good because we are at version 1.0!
Congrats! Nice to see others using BREAD terminology. :-)
Nice.
All of MediaWiki and our custom PHP extensions are PHP 7 compatible already - we've never introduced any HHVM/Hack specific code since we still do use PHP 5 for some batch CLI jobs and special wikis. There's currently a [discussion](https://lists.wikimedia.org/pipermail/wikitech-l/2017-September/088784.html) about where to go from here, but it likely will be moving to PHP 7 and dropping HHVM.
I use Charles proxy and set up a generic CA using my Charles proxy root cert. When I need a new domain, I run a command, sign it with Charles certificate, and then Charles can read the data in the proxied URL automatically with out having to specifically enable it in the SSL proxying. 
Or unless someone just buys it. 
Why do you need the dev part for that?
I think you're confusing class interfaces with abstract classes. Secondly, in your example, you have setTotalCoins in your abstract class, but access the property directly in the implement call() methods, and then overwrite those values anyway in your "test". (which is not a test). Also, implementing classes must have the _same_ method signature as the abstract class or interface. Not similar - the same.
&gt; into the early 1990s. Uh, PHP was born in the mid-90s About the same time as you, I'll wager. ;)
[removed]
They don't and for a good reason: https://blog.jetbrains.com/phpstorm/2015/06/hack-language-support-in-phpstorm-postponed/
Browsers don't accept wildcards for TLDs, so you can't use *.local
you are killing me! /s
I think having a competitor helps to counter balance the "we are a mature language, this new feature has no place in the language otherwise we would already have it", but having competent people and especially more people to review ZE specific changes matters a lot more.
And here I thought he left me hanging.
How does it compare to Reflection in terms of performances ?
Much, much, much, much, MUCH slower. I don't think it even compares: the difference is at least an order of magnitude, if not two. This is not a tool designed for runtime operation, but rather for code analysis, code generation, build logic. If you want to use it "live", then make sure you cache anything it does :-)
[removed]
[removed]
[removed]
PHP is about two years older than me, in fact. :D
[removed]
I would bet it has something to do with this announcement a couple of months ago tbh https://www.youtube.com/watch?v=AGkSHE15BSs
Ok, thanks for the clarification. This is a really nice project BTW :)
also if you have to consider this announcement https://www.youtube.com/watch?v=AGkSHE15BSs
They could've had Reflex be completely its own thing and still go for feature parity with Hack/PHP, turning HHVM into a JVM type of runtime with multiple languages. I can understand why they don't care - there's nothing in it for them to make it so. But it's a shame for the wasted effort. BTW, Reflex sounds like something with narrow appeal. I've seen such "reactive programming" efforts a lot and they never go anywhere. Whether we like it or not, nothing beats the raw flexibility and performance of imperative code...
wasted effort is subjective to a trillion dollar company, At the time PHP was too slow and they saved more than enough in server costs probably to offset the cost of developing HHVM/hack
They would've saved a lot more by using one of the PHP compilers targeting JVM, as one example. I think a lot of this was they wanted to dabble in NIH practices, and their money allowed them to. It's fair, I guess. I maybe also would write my own language in that situation, although it'd be absolutely pointless.
well you surely know how hack/hhvm came about? why target JVM when you can just Target C++?? and when you have a PHP to C++ compiler why allow the shittiness of php? so then you pretty up terrible practices in PHP to make them "better" and you just made HHVM and Hack
&gt; well you surely know how hack/hhvm came about? why target JVM when you can just Target C++?? Well to anyone with a bit more experience it was immediately obvious that trying to compile *statically* a heavily *dynamic* script would result in very modest boost compared to a C/C++ interpreter (which is what PHP is now). Which is why they quickly abandoned their "compiles to C++" solution and wrote HHVM, which is a more traditional language runtime. Unfortunately it takes a lot of time and a lot of smarts to make a *fast, optimizing* VM, so HHVM is actually a quite poor effort compared to something like the JVM or .NET (Mono) or what have you. So instead of reinventing a PHP compiler and then reinventing a script runtime, they really could've just compiled to an existing one, like JVM, with much better results. Going "raw" with C++ compilation (or similar) only makes sense if your language is already static - no gradual/optional typing. PHP is anything but, and Hack is also anything but.
Fat Free Framework
You cant buy 2 letter TLDs. Everyone wanted to buy `.js` when the new TLDs were announced - but ICANN is keeping 2 letter domains just for countries.
Missing extensions are always tricky :) Especially because someone might assume that a Bundled Extensions (like `mbstring`) are always shipped with PHP. This is not the case, the Core Extensions can be assumed installed along with PHP. For a list of each extension and its `membership` http://php.net/manual/en/extensions.membership.php To track down which extensions your project relies on and to see if all those are listed in your `composer.json` file I recommend; https://github.com/maglnet/ComposerRequireChecker There is no stable release and a bit rough around the UX and DX edges, but it is a very nice tool :)
First: /r/phphelp Second: This is resolved simply from left to right. // This true ? 1 : false ? 2 : 3 // is the same as (true ? 1 : false) ? 2 : 3 (1) ? 2 : 3 `1` becomes a truthy value, so it outputs `2`. If you enclose the second ternary logic, the backets will it be parsed first. According to http://php.net/manual/fa/language.operators.precedence.php. So as you mentioned you have to enclose everything to be parsed first. // This true ? 1 : (false ? 2 : 3) // becomes true ? 1 : (3) But to give you a little tip. Don't use this kind of behavior. Do not stack ternary this will confuse others reading the code. Simple you 2 ifs or something other than that, even its "longer" in terms of more line of code. But it will be easier readable.
http://phpsadness.com/sad/30
1. /r/phphelp 2. You should've been fiddling with the **documentation** first, which explicitly says [It is recommended that you **avoid "stacking" ternary expressions**. PHP's behaviour when using more than one ternary operator within a single statement is non-obvious](http://php.net/manual/en/language.operators.comparison.php)
BREAD?
Browse, Read, Edit, Add, &amp; Delete
&gt; Why not use Flow + JS? [My reaction when I read someone suggest using JS at the core of a codebase as large and complex as Facebook's.](https://media.giphy.com/media/SDxzM5LAVq5Tq/giphy.gif) Some of you have lost your damn minds.
I'm proposing it as a replacement for PHP/HHVM, which isn't the *entire Facebook*, genius. It's just some of the server-side front-end logic. A lot of the back-end services at Facebook are C, C++, Haskell, Erlang (well, used to be), Java and so on.
&gt; which isn't the entire Facebook Wow, I had no idea! /s &gt; A lot of the back-end services at Facebook are C, C++, Haskell, Erlang (well, used to be), Java and so on. I don't see JS in that list, and I'm sure there's a good reason for that.
Why not use this as an opportunity? Like you said it presents a lot of opportunity for code. The fact that it is for this CMS doesn't matter, code is code. Why not offer to keep it up to date, and use the opportunity to develop your own skills? Maybe it doesn't properly incorporate design patterns, maybe it doesn't comply with SOLID principle etc etc You could be the one that makes sure it does. Maybe there are some new features you could add that would provide even better value for your companies customers? Even if your company don't let you do this in work time, maybe you could branch off it on your own, and present it to them later? The alternative is becoming specialised in another closed system. Do you really want to be a Drupal or Wordpress developer instead, just because there would be a greater choice of other dead-end jobs you could take? 
I think it doesn't matter. The experience will allow you to grow as a developer. You will gain experience in CMSes in common, so that is a plus too. Outdated means, there is improvement to be made, and the person doing that could be you. (and if needed, you can borrow some ideas of any other CMS out there) A lot of bigger companies use some form of a CMS, some tailor made to their needs (and some of them used an out-of-the-box version to start with) If you are experienced enough, you can bend the CMS to your will. (so no worries...)
I was in the same boat, and I decided to give it a go. I'm in the company now for 2 years and I enjoyed the experience so far. Sure, there were ups and downs, roadblocks everywhere, quite a lot of manual digging - but just try to look at it from different perspective - you're actually learning how to handle situations you couldn't google your way out. It's been absolutely lovely experience so far and I don't regret my decision for taking the job and staying this long. Not that I'm gonna stay here forever, but as long as I have this good feel about myself and my career, it's good enough to keep me motivated.
&gt; Wow, I had no idea! /s I can't decide which is more pathetic: - That you didn't have an idea, and that's why interpreted that I propose JS for the *entire* Facebook (which I haven't), or... - That you *did* have an idea, and you came here to just spew bullshit. Hmm, maybe I can decide, actually. &gt; I don't see JS in that list, and I'm sure there's a good reason for that. The reason is they have 1M+ lines of Hack/PHP code laying around. They claim they also prefer a script language for front-end concerns as it's more flexible (hence JS would fit the bill, where C++/Java/etc, wouldn't). I appreciate your gargantuan efforts to appear smart and snarky, but you need to first inform yourself of the context of the conversation, before you can seem witty, and not just inept.
&gt; entire Facebook I didn't say the _entire_ Facebook. You did, and you're being pedantic. This is why I avoid getting involved in programming discussions on reddit, but sometimes someone says something so stupid that I have to chime in. &gt; hence JS would fit the bill You're moving the goalposts, since we're clearly not talking about the front-end. The "context of the conversation" as you put it, is about replacing PHP. &gt; inept Says the guy who doesn't understand the differences between front-end and back-end.
Are there plans or schedules to make it compatible with Laravel 5.5 please?
Voyager 1.0 already supports laravel 5.5
&gt; I didn't say the entire Facebook. You did, and you're being pedantic. You said "using JS at the core of a codebase as large and complex as Facebook's". HHVM is not at the "core" of Facebook, and isn't the most complex part of Facebook, which is in the backend services written in C++, Java, Haskell. So as a replacement for HHVM, JS also wouldn't be "at the core of a codebase as large and complex as Facebook's". &gt; You're moving the goalposts, since we're clearly not talking about the front-end. The "context of the conversation" as you put it, is about replacing PHP. Facebook calls PHP their "front-end" language: - ["front-end PHP development at Facebook"](https://www.facebook.com/notes/facebook-engineering/xhp-a-new-way-to-write-php/294003943919/) - ["PHP is typically used to write front-end code"](https://www.facebook.com/notes/facebook-engineering/xhp-a-new-way-to-write-php/294003943919/) - ["At the front end, their servers run a LAMP (Linux, Apache, MySQL and PHP) stack with Memcache."](https://www.quora.com/What-is-the-back-end-of-Facebook-written-in) - ["Facebook front end is primarily delivered via PHP"](https://www.forbes.com/sites/quora/2013/05/20/how-is-a-facebook-like-site-actually-created-from-scratch/) - ["PHP is used for the front-end"](http://royal.pingdom.com/2010/06/18/the-software-behind-facebook/) "Front-end" doesn't mean "client-side", unlike what you've read on a blog somewhere. &gt; Says the guy who doesn't understand the differences between front-end and back-end. Oh, the irony. So thick, I can cut it with a knife.
Is this bound to eloquent models, or are we free to use other things, like Doctrine, without compatibility concerns? This looks like a really slick tool, so I'm definitely going to check it out, either way. Great work!
Yeah, I don't see the point of posting this. One year old and it's definitely not the first time it's posted here.
ಠ_ಠ
&gt; unlike what you've read on a blog somewhere. I've been doing this for 12 years and built one of the top 100 sites in the world (according to Alexa) getting 20 million page views a day. So you can drop this snarky "newbie" attitude of yours. These are the kinds of dumb assumptions that make people like you come off as assholes, which leads to these types of stupid internet arguments. &gt; "Front-end" doesn't mean "client-side" If you drop the word "front end" in a conversation with web developers, they would all assume you mean client side. Again, you're being pedantic to win arguments on the internet.
It's still a list of limited utility because PCRE is actually core since 5.3 but doesn't show that way in any list. You'd still have to inspect every single "bundled" extension one by one to determine if it's actually mandatory or not.
is there something wrong with the statement? please clarify...
I tend to think that if the team when starting a new project decides to build their own CMS, that is likely a poor decision. They largely reinvent the wheel, and also put the company in a position where they can't utilize open source but have to build everything from scratch. New developers coming on the team have to start building their domain to knowledge from scratch. In-house systems are usually never documented as well since they only need documentation for a handful of developers, rather than the thousands that will use the Open Source Products. Chances are, using something open source and established and just writing custom plugins for it would be more valuable in my opinion.
We make use of eloquent models internally, but haven't tested mixing the two ORMs. I don't think it would work with the way the query builder works, but you're certainly welcome to try. I'd be interested in hearing how it goes (or if you have any suggestions on how to make it ORM-agnostic)!
&gt; access the property directly in the implement call() method Hi, I understand, Thank you for pointing out. Do I need to use setTotalCoins in call methods as well???
You're welcome.
&gt; built one of the top 100 sites Okay. Who cares. &gt; which leads to these types of stupid internet arguments But you started the entire thing with a throwaway post consisting of a meme and &gt; Some of you have lost your damn minds Then you get all pissed off that someone takes you to task over it. Maybe this isn't the place for you.
I've been in that situation, twice. I must say that those were the most eye opening experiences I've ever had. Yes, a lot of stuff has to be build from scratch again. Yes, you don't get as much support as if you were using a open source alternative. Those are valid complaints and need to be thoroughly explored. However it allows for so much more. It enables ways of implementations that are not possible or reasonable for given systems. You are building a product rather than using one to accomplish your goals. But that also means not being able to blame anyone else for poor decisions but you and your peers. And you are the only ones who can set it straight again.
You can use repositories and map eloquent object to plain php objects back and forth. Then you can let end users swap repository implementation using the container. It's probably a lot of refactoring though... better to have this design by the start
&gt; If you drop the word "front end" in a conversation with web developers, they would all assume you mean client side. Again, you're being pedantic to win arguments on the internet. If I drop the word without context, you may assume client-side. If I drop it in the context of looking for a HHVM replacement and I have used the phrase ***"server-side front-end logic"*** in the same conversation, you can change your assumptions and look up online what I mean, or you can decide you know everything, be arrogant and mock me, then it's kinda funny when it backfires on you. ¯\\\_(ツ)_/¯
I'd say this is one of those "if it makes sense for your project" things. I would choose one approach and stick with it. A way for your example to make more sense in my opinion would be to have Making/Maker.php Making/FastMaker.php Making/SlowMaker.php or maybe even Maker/AbstractMaker.php Maker/FastMaker.php Maker/SlowMaker.php if you're willing to make it more apparent that Maker is, in fact, an abstract class.
Zend 1 used the short style because it comes from the age before namespaces, where we used underscores for class names, i.e.: Zend_Foo_Maker Zend_Foo_Maker_Slow Zend_Foo_Maker_Fast This style made sense with underscores. With namespaces the names "Slow" and "Fast" are way too ambiguous and unclear without the namespace (and you usually see them without their namespace due to the `use` statements), so this resulted in some redundancy happening: Zend\Foo\Maker Zend\Foo\Maker\SlowMaker Zend\Foo\Maker\FastMaker Then when you start thinking of a namespace as a "package of related functionality", which is its purpose (one of them anyway), it doesn't make sense to have one of the items outside, and the rest in. So then you will see the namespace becoming a *plural* (when it makes grammatical sense) and the core interface/class moving in: Zend\Foo\Makers\Maker Zend\Foo\Makers\SlowMaker Zend\Foo\Makers\FastMaker This last style is by far most dominant right now in modern and new packages. *However* this doesn't mean that shorter styles are not applicable sometimes. I.e. while I go for the last style above most of the times, I sometimes do something slightly different...: Zend\Foo\Maker // Core interface Zend\Foo\Makers\* // Related sub-functionality, if any. Zend\Foo\Makers\Internal\* // Implementation classes (not public API) Zend\Foo\Makers::*() // Factory methods for creating Maker instances In practice this means that most people would only see and work with these two: Zend\Foo\Maker // Core interface Zend\Foo\Makers::*() // Factory methods for creating Maker instances For example: function foo(Maker $maker) { ... } foo(Makers::slow()); foo(Makers::fast()); Most people won't mess around with the "Makers" namespace, which contains advanced or rarely used aspects of the feature. This can make your core feature stand out and make it very clean, short, and easy for people to get started with your library. It's not for everything, though.
[removed]
Having that namespace is useful *because* internal classes are not enforced by the language. If we had internal/private classes I wouldn't need this namespace, would I? PHP lacks many things we need day to day. It means that they fall into the "convention and recommendation" category instead of the "enforced by language core" category. That's OK. It's better to have a "convention and recommendation" for a good practice or a useful technique, rather than to accept chaos. For example, Google's Go language enforces a very specific formatting of source code. You can't choose how code is formatted. Go forces you to do it a certain way, including how you indent and use white-space. PHP doesn't force you to use white-space a certain way. Yet we follow conventions. We have standards like PSR-1 and PSR-2. Is the convention useless? Should we just go about it randomly? The language doesn't enforce it...
That doesn't make it useless. The \Internal\ namespace indicates to developers using the package that they shouldn't be messing with the classes there. It's not ideal, but it's the best that can be done and conveys meaning. It's no more useless than the @internal docblock notation
This was confusing to me as well because the readme mentioned 5.3. Great news!
Haha sorry about that. Just overlooked it! All better now
I prefer "AbstractMaker", it's very clear it shouldn't be instantiated just by looking at the name. AbstractMaker.php MakerInterface.php SlowMaker.php FastMaker.php very clear about which files can and can't be instantiated.
&gt; It's not ideal, but it's the best that can be done and conveys meaning I guess you missed that part?
I think this was meant to be funny, but it just sounds like you're very upset about the world
I'm quite happy.. I was waiting for something to finish and I remembered my old [shit post](https://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/) 
Ah the concise points helps bring the point home
I was were you're at about a year ago. Writing the actual code will probably only take a few hours, especially if you've worked with Java before. But then you'll later realize that your code was absolute shit that anyone can hack in 2 mins, and you'll be disgusted by your own work when you look back on it a couple months from now.
Are you talking about using something like: function getFirst($array) { return $array[0]; } instead of: function getFirst(&amp;$array) { return $array[0]; } Personally I feel that pass-by-reference is premature optimization in most instances. Although, I'm sure there are plenty of cases where it makes sense to pass-by-reference. *Edit:* After looking into this a bit more there are plenty of good reasons not to use pass-by-reference. [Do not use PHP references](http://schlueters.de/blog/archives/125-Do-not-use-PHP-references.html).
That's what we currently have. We have ZF1 way, and I'm thinking if there is a really good reason to change it. But so far it doesn't seem to worth the effort.
Thank you for the response. Yes, underscores made perfect sense. A class, and its SUB-classes in a SUB-folder. Plural form sound interesting. But how about this? Parser Parser\Header Parser\Body Parser\Body\Paragraph Parser\Footer Where Header/Body/Footer inherit from Parser. Using Symfony style it'd be Vendor\Project\Parser\Parser.php Vendor\Project\Parser\Header.php Vendor\Project\Parser\Body\Body.php Vendor\Project\Parser\Body\Paragraph.php Vendor\Project\Parser\Footer.php This way Header, a sub-class is placed on the same level as Parser, and Body/Paragraph. Doesn't it look cumbersome?
I think if `Parser` clearly stands out as the entry-point of your package, and everything else in `Parser\*` is support code for it, then yes you can absolutely go for that, and it's fine. A parser like this seems like a suitable example for this layout. Symfony use a fairly standard naming convention etc. but they don't have an eye for "short and simple" to the point I sometimes wonder if they're messing with us. So Symfony is a nice reference point, but no need to copy what they do.
You are wrong though.
&gt; docblocks and conventions are useless, period https://www.youtube.com/watch?v=oAKG-kbKeIo
Some people worship Google as a God, so for them, it really feels like there isn't a choice. They are the Lost People. I'm just foolishly trying to save them.
Keep it simple. What are you gonna be doing with this data? What do the database tables look like?
Maker.php should be the interface.
Looks alright for what it is, but what may make more sense is using an abstract class for Tracker... i'll post something just as soon as I figure out how the hell to do multiline code comments on Reddit.
type it all in as regular text, highlight it all, click the code button
https://pastebin.com/PGN33TEF So what I've done here is split your interface and your base methods... getCoordinates and getBatteryLife are going to output the same format regardless of if they're a G1200 or a DMT, so they might as well go in the the parent. The parent class has a constructor which sets some members, but they're protected, rather than private, so you can still access / manipulate them however you want in your child classes. Then, depending on how you're creating them, maybe create a generator "factory" function that loads the right one, maybe based on a "devicetype" field. If you need something special, say to show battery life as uh, "3 bars" for a particular device that doesn't return a percentage, you can override your getBatteryLife() function in the child class, as it's not "final".
Database tables look like this. There's about 20 different configurations, and over a million rows. id|protocol|deviceid|latitude|longitude|attributes| :--|:--|:--|:--|:--|:--| 1|gl200|24|12.345678|123.456789|{"battery":"0.999","pdop":"1.5"}| 2|dmt|72|12.345678|123.456789|{"battery":"99%","hdop":"20"}| The class/object spits out a JSON for a front-end for Google Maps to display relevant info.
You should give strong consideration to modifying the database (if you can) to parse out the battery % and convert it to an integer number, and store that in your database at the point the data is INSERTED/UPDATED. As-is it's locked away inside some JSON and needlessly difficult to query. Depending on how many different protocols you had to deal with, I'd probably look at some kind of protocol definitions table that included the protocol name, what JSON attribute the battery was in, and any special manipulations it needed.... for example: protocol=dmt, battery_field="battery", conversion="int" protocol=gl200, battery_field="battery", conversion="multiply10" Then you can write code that only deals with 1. Finding the field and 2. Doing the conversion... which will often be similar across many different protocols, even if the attribute to find it in is different.
I would prefer to store the data the same way in the database, but if that's not possible, could this be done at output time instead? More or less: $bat = $tracker-&gt;getBatteryLife(); if (is_float($bat)) { $bat *= 100; } echo "$bat%"; That wouldn't scale well, but if this is the only odd case it's simple.
If it's in the same namespace as the class, you shouldn't need a use statement, so it would be the difference of: `use Maker;` or `// nothing` unless you're creating a class that's going to extend AbstractMaker outside of the namespace, you wouldn't need a use statement but otherwise, you could name it `AbstractMaker` so you would have `use Maker\AbstractMaker;` instead of `use Maker\Maker;`
I knew I was doing something pretty inefficient. I was thinking, "Damn this is a lot of copy and paste... as we grow with all these different possible types of GPS devices and their configurations." I have a table [above](https://www.reddit.com/r/PHP/comments/715ci2/need_some_oop_guidance/dn89ezz/) showing a rough idea what the database looks like. So the code now should look like this once those are in. &lt;?php $conn = new mysqli('host','user','pass','database'); // check for connection part $coordinates = array(); if ($result = $conn-&gt;query("SELECT tables FROM database etc.")) { while ($row = $result-&gt;fetch_assoc()) { switch ($row['type']) { case 'gl200': $point = new Gl200($row); break; case 'dmt': $point = new Dmt($row); break; default: $point = new Standard($row); break; } $coordinates[] = $point-&gt;getCoordinates(); } header('Content-Type: application/json; charset=utf-8'); header('Access-Control-Allow-Origin: *'); echo json_encode($coordinates, JSON_PRETTY_PRINT); ?&gt; 
Awful awfully rough example (no disclaimer it actually runs): $your_rows = []; /* your database rows would come in here */ $protocols = [ 'dmt' =&gt; ['battery_field' =&gt; 'battery', 'battery_conversion' =&gt; 'int'], 'gl200' =&gt; ['battery_field' =&gt; 'battery', 'battery_conversion' =&gt; 'multi100'], ]; foreach ($your_rows as $row) { $protocol = $protocols[$row['protocol']] ?? null; if (!$protocol) { /* error */ } $data = json_decode($row['attributes'], true); $battery_str = $data[$protocol['battery_field']]; $battery = 0; switch ($protocol['battery_conversion']) { case 'int': $battery = (int)$battery_str; break; case 'multi100': $battery = ((float)$battery_str) * 100; break; default: /* error */ } /* store your battery info back */ db()-&gt;execute('UPDATE phones SET battery=' . $battery . ' WHERE id=' . $row['id']); } 
The only problem is there's about 10-12 different attributes that may or may not be in each, and it all plays into how a "point" behaves. Like for example battery info may come in as a voltage and not a percentage, and then you have to look into a table to find out the actual % based on voltage. Precision of how accurate the GPS device is based on pdop or hdop and each has a little different data on it. etc.
If you name your classes to match what you have in the database, there's an easier way that makes use of the abomination which is PHPs stringly-types to load the class name that matches your type. class Protocol_gl200 { } class Protocol_dmt { } $inst_str = 'Protocol_' . $row['type']; if (class_exists($inst_str)) { $device = new $inst_str($row); } else { /* boom */ } 
I don't think the specific style matters so much as consistently applying it.
I'm afraid you're being screwed into doing everything the hard way then of manually parsing each type. The examples I gave of the interface / abstract classes are certainly one way around it, and probably the cleanest. The advice still stands to do it once on insert/update so you can actually query the data properly using SQL... Doing the conversion once and then storing it alongside the metadata beats trying to do it _every_single_time_.
I would create a Point class that loads all the columns in by default. Then I would make GL200Point/DMT extend Point which would then interpret the data differently. This should be safe to do as long as you can assume that the attributes will be the same for each protocol. So your design would really depend on how many different protocols there are and how much those attributes are gonna differ.
That seems way too good to be true... but that's amazing! You're a true guru. I was thinking about the easiest most scalable way of doing this -- mainly, the problem being that new devices are coming out monthly and weekly. They all adhere to different standards and produce slightly different outputs in some parts, but very similar in other parts (ie lat, lng, etc.). I wanted to nip this in the bud and kind of build it out more intelligently so as things get added it's not a chore. ---- Edit: Will I have to do that part at the top of the PHP file for each future protocol that is added? class Protocol_gl200 { }
Those were just so I didn't have to paste a large block of text I had already done... you'd have each Protocol_XXX class in its own file, and each one would deal with taking in an array of attributes, parsing them, and then setting the class members so they could be accessed.
And that's absolutely fine. It's just that until we get it conventions are the best alternative we have and they are objectively better than nothing. 
Probably the deep nesting and chaining that looks kinda wonky, but probably is not as bad at it looks like at first glance.
Agreed. \yournamespace\Maker.php at first. When you need a slow and fast one, you extract your interface and make it Maker.php =&gt; no need to change the signature of methods using the old Maker class. You can then add the code in - \yournamespace\Maker\Common.php - \yournamespace\Maker\Slow.php - \yournamespace\Maker\Fast.php
Not sure why this is getting downvoted. This is a common convention (often seen in the Java world - for example Spring) and enforces the idea of depending on interfaces, not implementations.
&gt; Not sure why this is getting downvoted. People thinking if they downvote low enough, they won't need to refactor. :)
Thanks for the response.
Keep it civil.
It would help if the downvoter posts his/her thoughts about the disagreement. I am neutral to this. I once discussed with a mate about how to name the interfaces and he was like naming it either "IClass" (like Microsoft likes to do) or "ClassInterface". Then I found an article where the poster was like don't choosing any of these both, but just plain "Class". In this example the interface would be just "Maker" so you can say `if ($maker instanceof Maker)` and say out like "The $maker is an instance of Maker" (or similiar.. I actualy forgot, but it sounded smart) and that noone would use ".. instance of MakerInterface" in a real sentence. I prefer the &gt;"if it makes sense for your project"&lt; way ojrask was writing about. In the end you need to stick to it and it should be something that brings you the most benefit. If you always getting confused with a way, it doesn't make sense to stick to it, except you are in a team where the majority prefers this way. 
Generators are for handling sets that are too large to put into memory all at once (like reading a giant CSV). They are entirely different tools.
&gt;Google's Go language enforces a very specific formatting of source code. You can't choose how code is formatted. Go forces you to do it a certain way, including how you indent and use white-space. A small correction, but Go formatting is still only convention based, it's just that not following the convention is *heavily* frowned upon. The language itself isn't generally sensitive to whitespace or indentation and will happily compile code that isn't formatted according to `gofmt`. As far as the compiler is concerned, formatting can be as free as PHP and similar C-style languages. Even with how heavily the Go community and official documentation push the use of `gofmt`, I still see libraries (and a lot of /r/golang posts) with janky formatting. Early on in the history of Go (I guess around 2012/13), it was only a slim majority of libraries that followed `gofmt`'s rules, though this has improved a lot with time and pretty much all libraries that have more than a handful of users now enforce `gofmt`. Otherwise I agree entirely with your post.
*Should* is a bit of a strong word. There are major frameworks that use the Interface suffix; ZF2 being one. I don't understand the argument that Maker.php is preferable to MakerInterface.php if they are both interfaces. One file name instantly tells you what it is the other requires me to open it and remind myself.
Why not both? https://github.com/phplang/generator/blob/master/src/iterable.php
Now that it looks like the RFC in it's current form won't pass, what's the future of UUIDs in PHP? Do you plan on doing a future RFC to address some of the issues that were brought up?
It doesn't cause inefficiency because PHP is "copy-on-write". If you want to know what this means, Google it up and do some research. If not, the short story is that PHP passes literally **everything** by reference internally, and copies only when two variables diverge in content. So the "&amp;" doesn't decide if PHP passes by reference. It just decides if you want the two variables with the same content to change together, or independently.
Can we please stop abusing this phrase "premature optimization" whenever we speak of optimization? In this case this would be a "bad attempt at optimization", not "a premature optimization". Using references wouldn't optimize anything here. As for this link you found, it's severely outdated, and has writing that seems to be targeted at toddlers, not engineers: &gt; References in PHP are bad. Do not use them. They hurt and will just mess with things While it's true references shouldn't be used lightly as they can easily introduce bugs, they do have their uses (optimization not being one usually). 
&gt; Do I need to use setTotalCoins in call methods as well??? You should, but it's only half way there. Really, what you want to do is encapsulate the logic around adding/removing currency (coins) into the abstract methods, so that you can call them as needed (probably only in your abstract class), without touching the other code. In the above example, it might seem like a lot of extra code for no purpose, but it means that you can add things like checks and other actions. You might want to check for negative totals, integer values, add tax, verify minimum additions, etc.
OOP IS bloat. Learn Functional.
PSR disagrees. But what do they know? http://www.php-fig.org/bylaws/psr-naming-conventions/
So let me get this straight: **1.** We can no longer pass arguments to functions (so piping things like substr(), preg_match(), preg_replace, and basically anything with more than one argument is out). I.e.: // This... |&gt; substr($$, 2, 3) // Becomes this... |&gt; function ($x) { return substr($x, 2, 3); } **2.** We need to pass function names as strings and methods as arrays with strings, i.e. // This... |&gt; strtoupper($$) // Becomes this... |&gt; 'strtoupper' // This... |&gt; StrUtils::normalize($$) // Becomes this... |&gt; [StrUtils::class, 'normalize'] Sorry to be blunt, but it kind of feels like PipeOp v2 is intentionally designed to fail. Not to mention we can build ourselves a pipe operator that functions like this in 5 seconds: function pipe($arg, callable ...$c) { foreach ($c as $d) $arg = $d($arg); return $arg; } Compare the RFC example: $x = "hello" |&gt; 'strtoupper' |&gt; function($x) { return $x . " world"; }; And our ad-hoc 5 second implementation: $x = pipe("hello" , 'strtoupper' , function($x) { return $x . " world"; }); What is gained? Nothing.
Static can also be used like 'Classname::method', but yes, the problem with this draft for me is not the pipe itself, but how awkward normal callables are in PHP, specially the array format. if $$ is so controversial, maybe something like $string |&gt; strtoupper(), without the original $$ placeholder would be possible, but based on other RFCs, when these dificulties start to pile up a RFC starts to lose traction
&gt; Static can also be used like 'Classname::method' I think this is on track to be deprecated and removed later from the spec of "callables". Also the problem is it becomes even worse in practice, because there's no namespace resolution in a string: // This... |&gt; [StrUtils::class, 'normalize'] // This... |&gt; 'Vendor\Library\StrUtils::normalize' &gt; if $$ is so controversial, maybe something like $string |&gt; strtoupper(), without the original $$ placeholder would be possible, but based on other RFCs, when these dificulties start to pile up a RFC starts to lose traction Thing is half the APIs in PHP won't accept the string (or whatever it is we're piping) as first argument, and this also makes the pipe operator less useful. The original RFC was best, but you can trust people to complain about things they don't understand.
Edit: I [take back](https://www.reddit.com/r/PHP/comments/7178o3/rfc_predraft_for_pipeop_v2/dn9tpp8/) most of this statement. Agreed. This implementation requires way more work on the developers end, makes static analysis massively more difficult, and the only “improvement” is that `$$` goes away. If higher order functions or even just “pass this actual function around” (as a literal token of some kind, not a string/array) was supported better, I could see this working moderately well although I’d still like it less than the original. I don’t think this would result in a push for fixing the “stringy functions” thing at a language level, and even if it did I don’t think it ends up as a net positive over the original proposal. But maybe this discussion will make it clear that the original is better overall (even if it comes with a different placeholder token, say `$|`). 
With all due respect to Sarah, please don't. This is the kind of thing which makes a language more convoluted, less intuitive, and more difficult to analyse. As for the examples given all of the string examples given could be MUCH better implemented by exposing class a methods of a string like every other modern language from C++ std::string to Javascript. php "MyString"-&gt;toUpperCase()-&gt;reverse()-&gt;append(' goes here'); Also, stringly types continue to make me sad inside.
As a resident of Florida that just had to deal with hurricane Irma, this post title confused me for 2 seconds longer than it should have. 
Or fossil by the sqlite author. Do yourself a favor and learn aside the *most used* stuff.
That means extra effort not everybody is willing to take because "I'm not the lead", or "I have enough workload already", but yeah, proposing is easy...
No mention of the bosses gender anywhere. It's important.
&gt; makes static analysis massively more difficult No it wouldn't – it'd be trivial for me, at least, to add support (once the parser supported it)
The reception here appears to misunderstand why `$$` was removed. It's not that the effort is dead it's that these features are needed *in isolation* of each other and can be combined with every bit as much of power. Consider wanting to create a closure for use in `array_filter` that uses a method on an object: array_filter($data, [$obj, "method"]) // can now do array_filter($data, $obj-&gt;method($$)) // equivalent to array_filter($data, function($arg1) use($obj) { return $obj-&gt;method($arg1); }) This use has no relation to `|&gt;` and would be useful. Then when you pair it with `|&gt;` you get the at least the same expressive power as the original RFC. Except each feature is simpler and useful without the other. *This is undoubtedly a better approach.* It turns out it is even slightly nicer. If you already have a callable in a variable you can reuse it without adding `($$)` unncessarily: $x |&gt; $y($$) // before $x |&gt; $y // after --- Also it will be easier to for the engine to optimize `|&gt;` paired with `$$` compared to `pipe($arg, ...)` (see [this comment](https://www.reddit.com/r/PHP/comments/7178o3/rfc_predraft_for_pipeop_v2/dn8om7w/) for `pipe`'s definition). The latter would require general inlining which is difficult, and type declarations make this worse. And if there are multiple args then we need closure inlining as well. To be a bit more clear: $x |&gt; array_filter($data, $$) // much easier optimize the above down to this: array_filter($data, $x) // compared to optimizing this: pipe($x, function($x) use($data) { return array_filter($data, $x); })
Actually, you are just missing the whole vision: https://www.reddit.com/r/PHP/comments/7178o3/rfc_predraft_for_pipeop_v2/dn8xxyb/ Please read that before continuing. If we had `$$` separately from `|&gt;` we can use it to create closures for other callback usages. Even in your example we could do this: $x = pipe("hello", strtoupper($$), // before was `'strtoupper'` function($x) { return $x . " world"; } ); Better left as independent features. As a side note I would include `...` in the same RFC as `$$` for if you want to create a variadic closure: array_map(combine(...), ...$arrays) Where `combine` is a variadic function.
This has nothing to do with stringly types; that is an existing issue that needs to be resolved separately from this RFC. Even if we have `|&gt;` there will usages of passing things to callbacks that don't use it and those need resolved too.
In what way is it not related to more use of stringy types? The very examples show the use of that mechanism being used to define which functions are called. Very much agree that it needs to be resolved. In desperate need of a function type.
Stringly-typed function names exist whether `|&gt;` exists or not adding `|&gt;` does not solve that problem in general. It's just using existing, regular language features. The issue is the deficiency of language features in this space, not `|&gt;` itself.
The first version used to be better then this. this one is terrible. is it soo hard to copy good features from other languages, than inventing your own crap.
Ah yes. My comment regarding stringly types was more of an amendment to my primary concern that the |&gt; mechanism is an overly convoluted mechanism, but I put it in as anything that encourages stringy use is something I am inherently concerned about, and I would much rather see a resolution to that problem, rather than encouraging more use of it.
Thanks for the heads up! I'm using .dev domains locally and this probably would have caused confusion at some point. sed -i -- 's/\.dev/\.local/g' /etc/nginx/sites-enabled/* /etc/hosts All fixed for me :)
Wouldn't this RFC be obsolete if we could use all types as objects?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Basically: XMB Forum, a long-since-inactive forum software that has not received any major updates since 2012, is being repaired for PHP7/MySQLi compatibility while still remaining a simple, old-school forum solution, as far as I know. 2.0 seems also work has started again for the first time in years due to the revived interest. Go check out the board and I hope you enjoy, contributors! I'm 'Scarlet' on their forums, by the way :)
Exactly. People treat interfaces like weird classes: they're types. When naming an interface, it should finish the sentence "This &lt;class&gt; is-a &lt;interface&gt;." Appending "Interface" to an interface is basically calling it "integerNumericType".
lolwut, you're using jQuery for this...
The meaning is clear. So why fuss about it. No one was freaking out about it ... but ok "man" ...
This. It's a familiar syntax, doesn't look out of place and it's clear what you do with it.
https://www.digitalocean.com/community/tutorials/how-to-upgrade-to-php-7-on-centos-7 My google skills increased +1
A lot of things are based on conventions, and, although, not strictly enforced, are useful. E.g. Python underscote notation to indicate a method is "private". Hell, even file extension is a convention. You don't have to name a file .txt or .jpg to be able to open it and read it. Would you still insist, that extensions are useless? Or do you think they need to be enforced?
Well yes, but using it outside of the scope requires you to write `Maker\Maker`. AbstractMaker is the easy case. I've added an example in one of the comments above. On of the problems is then visible, when you have class "subordinates", which end up on the same namespace level.
I'm using Caddy instead of nginx &amp; apache .. Would it work the same as the nginx guide? 
something happened
I recently used the ISO 3166-1 numeric country codes as the PK in my "country" table. Wondering what peoples' thoughts are on this? I'm not sure if it was a good or bad idea. Using the letter codes didn't seem to make sense, seeing they're political rather than geographic based, and in my case I'm tracking where users actually live. So it was either use the ISO numeric codes, or my own. I went with the ISO ones so that the country data can automatically update itself based on the PK.
&gt; and I would much rather see a resolution to that problem Do you have an RFC for solving that problem? If so, great! I look forward to seeing it. If not, please don't tell other people what they should be contributing their own free time towards. 
nelly the elephpant tripped over the power cord to rasmus's laptop again
So it boils down to the fact that you think the original RFC was adding two features, not one? I don't understand this mentality, are you able to elaborate? I see nothing wrong with an RFC adding two features at once if they're tightly related.
I follow a simple rule: * either the class is not meant to be substituted, then it gets "the name", eg. Maker, * the class provides an abstraction, and there is no class with "the name". Interface gets its suffix (MakerInterface), common base class gets its prefix (AbstractMaker), all concrete implementations are final classes with implementation prefixes (InMemoryMaker, FileMaker, etc.).
I recommend the PSR Naming Conventions: * Interfaces MUST be suffixed by Interface: e.g. `Psr\Foo\BarInterface`. * Abstract classes MUST be prefixed by Abstract: e.g. `Psr\Foo\AbstractBar`. * Traits MUST be suffixed by Trait: e.g. `Psr\Foo\BarTrait`. For example: Maker/MakerInterface.php Maker/AbstractMaker.php Maker/FastMaker.php Maker/SlowMaker.php
I was in the same boat. Was in a similar company for many years. Started as a junior and worked up to senior. I think at the time it was ok. PHP and the web was moving slower back then and a couple of developers could keep up with the likes of wordpress and drupal quite easily. We were much better than WP in my opinion and there was a time where I didn't know of a better CMS than ours. Around the time Composer became industry standard I started to notice the whole industry just go into warp speed. Suddenly we just couldn't keep up. Our codebase became obsolete over the space of a few years. Unfortunately for a relatively small company, an entire rebuild was too much of an investment. So we just got further and further behind until it was just a steaming pile of legacy shit. Pros: As as junior I learned a lot. Definitely fast tracked my PHP and general programming knowledge for a few years. Cons: After I reached intermediate-senior level It became obvious that I was missing out on the latest industry tech. This was amplified by the current turbo charged pace of the web dev industry. I would say that in this day and age you probably wouldn't get the same benefits I did. The industry moves too fast and you don't want to be left behind. If my situation feels familiar to you... stay there for a while just to see what they have to teach you, but keep an eye out for a really good job elsewhere too. One that gives you an opportunity to learn some cutting edge tech. 
Why shouldn't it? You must only change the fpm path to use new php 7 fpm process.
[removed]
The company where I work is using haphazard integer PKs for country code, and one of our customers is using haphazard integer PKs for country code too. Last year we need to make an integration with their back end and this haphazard PKs coused more work for me; I had to create a separete converter table and convert the integers accordingly when an end customer was created or updated. If both companies used ISO 3166-1 numeric country codes there would be less programming.
Can you change the DB schema? 12 fields isn't a lot, and it sounds like you need to write code for each of them anyway. I wouldn't use JSON unless you need to store externally generated incoming JSON with unknown field names. You're trading data integrity constraint features of a relational DBs in favor of churning out "easier" code more quickly. Bad idea long term, and worse for performance and data storage too. Especially since the kind of mathematical calculations you're probably doing with this data would be better done at the SQL level rather than PHP/app level anyway. A few well structured SQL views would probably replace a heap of more bug-prone and harder-to-debug PHP code. The fact that you're storing all this data in a single table implies that you probably don't need separate PHP classes to begin with. Even though your devices report battery as literal percentage string or decimal percentage, I wouldn't store/use them that way. Use a consistent format in your own database and code. Considering that it looks like some of your devices of your devices support more granularity than 1%, maybe a decimal column with as many decimal places as your most specific device can report. Or maybe an integer with the decimal percentage * 1000000. i.e. 99.9% = 999000. Also the fact that you've got data in different formats all under the same field name of "battery" is quite a mess. If you are going to store the source formats, at least give them specific names like battery_percent_string + battery_decimal_percentage or something. Then you can also quite easily populate both columns during import. But really unless there's a really good reason, you should be doing what I mentioned in the paragraph above (one consistent integer or decimal column for battery percentages). Strings like "99%" don't belong in database storage to begin with, aside from maybe in SQL views or functions used on output. That would be like storing formatted date strings instead of using DATE/DATETIME/TIMESTAMP columns (horrible). Likewise with specific field names, use specific method names so that in the future you can have a parent method that converts to difference formats without needing to write code for every device. i.e. a parent method called getBatteryPercentageString() &gt; Like for example battery info may come in as a voltage and not a percentage Eek... this should especially not be in this singular "battery" field (if that's the case currently?). That's not even the same type of data, even if you do have some way to convert it to a percentage. If these JSON strings are coming directly from the devices themselves and you want to store the raw data you get, you can still do that, but you should be normalizing the data into your own columns too for actually processing the data. Having the data stored consistently would replace most of the need to be writing custom PHP code for every device, except for a few customisations for the importing process. But even then, you could probably write a single import script that detects what fields exist, and the format used and then normalize it ***before*** storage. Even if you can't edit the schema of this table, you could likely just write an SQL view with some conditional statements (and maybe SQL functions if needed) that normalizes the data in SQL live as you SELECT it. To me this looks like it should mostly be solved in SQL rather than at the app level. If you're not that familiar with this type of SQL functionality, it seems like a great project to learn it for. Doing this stuff in SQL would be way simpler, even if it takes a bit of learning. I was coding PHP/mysql for about 10 years before I ever bothered making more use of doing things in SQL with views, conditional IF/ELSE/CASE and functions - now that I took a little time (only a few days probably) to get used to doing more processing in SQL, all my old PHP app code that was doing this type of stuff seems really scarily bad + dangerous, and was a huge waste of time writing to begin with. But maybe I'm missing something? Let me know, and I might have some suggestions.
Couldn't we just use the existing pipe operator? I realise that, at first wash, it would seem to be impossible because it's already assigned to the "binary or" functionality, but since we have an AST now, shouldn't it be possible for it to switch its behaviour depending on context? We could simply scan whether or not the function call has a corresponding `$$` placeholder to determine which meaning to apply.
So are you saying that this: array_filter($data, $obj-&gt;method($$)) Would now *not* execute `method` at that point but create a callable? That's really unintuitive and obtuse to me. 
I think objects and resources will be passed via identifier: https://3v4l.org/fFIj7 
YES
&gt;Using a constant to store your function name is totes legit &gt;totes legit Sara is totes down wit da kids 4realz.
1. This is not PHP. 2. To be devastatingly blunt, you are a poor developer and should not be writing PHP tutorials. Your MySQL tutorial is a security liability. Learn proper practices before trying to teach others. 
Wow, seems like no one else on this sub has a sense of humour. This was chuckle-worthy. 
[removed]
Yeah that seems like a great example for using a shared source of IDs (ISO). I guess you weren't able to just add an ISO numeric column to both of the databases to join on? Although you would have had access to modify the schema of one of the databases at least? Seeing it's a 1:1: relationship, why did you create a linking table instead of just adding new "country.id_in_their_database" and "country.iso_numeric" columns in the schema you could edit? (not implying you did something wrong, just curious about the situation you were in) 
Terrible tutorial.
Hello random person, welcome to Reddit, a wondrous technology platform based on sharing content and then DISCUSSING it :-)
&gt; like tail recursion Such am optimization in (similar) language like PHP would be a pretty big step. I wish we had these already. 
Just for the record: I like the pipe operator, I'm just afraid it will not be approved. 
[removed]
Makes me feel good about the code I write! 🤦🏼‍♂️
This is why we can't have nice things
Code like this is the reason for php's bad reputation. The more I look at it the more I'm amazed of how many "don'ts" the author has cramped in so little code.
Simply so you don't reinvent the wheel (perhaps even a bad wheel) with every new project. 
Not reinventing the wheel ?
I didn't have direct access to their database. They are very big company.
[Using SCL](https://www.softwarecollections.org/en/scls/rhscl/rh-php70/) is the 'proper' way to do this on CentOS/RHEL. This isn't just for PHP either. The alternative is using a third party repo of your choosing (Remi's for example). Great care must be taken to ensure the repo does not introduce conflicts if using them in production environments. 
I wouldn't agree that /r/php is mostly about frameworks, it's a channel to post about news, and or blog posts as well as discussions - including RFC, Libraries, Tools, Functions, etc. To answer your question, only if you feel the need for a tool should you use it. A regular "honey bee farm" website maybe only needs a simple front-controller that includes the right sub-page when the user navigates the website, serving static files - then i'd say you don't really need a framework at all. A framework is there to assist you with tools you need on a regular basis across multiple projects and websites. For instance, frameworks such as Symfony, Laravel or CakePHP offers a platform for you to use that has all the common features such as database utility, routing, templating etc. All you need to do is configure the tools and add logic to get going. But like I said, if you don't feel the need for a framework, you might just as well be better off with plain PHP, or using composer to utilize specific components - like a nice mail sending library or even a currency format library if that's what you need. Don't over complicate stuff because others have different needs than you.
&gt; why it's ok for a language to be so deficient I dunno, I guess the "ok" gods just created the universe that way. &gt; you have to rely on Nobody "has to" to anything. A more powerful tool is more powerful regardless of how good or bad the language is. Most people who have spent enough time learning to use both basic editors and IDEs, will prefer IDEs even if they're programming in some utopian perfect language. We all thought IDEs were overly complicated and "not needed" until we learnt to use them properly. I used to say that about OOP too. Yeah a few people revert to basic editors for whatever reasons, but they're the minority. But don't even basic editors tell you function arguments at least? Are you using notepad.exe or something? If you prefer to do things the hard way, and also invent your own solutions for minor and mostly OCD-centric problems that don't exist for most of us, go ahead if that seems enjoyable or a good use of time. The rest of us will get on with getting useful websites and applications done, and making money. &gt; personally, I've been crazy-busy with work Sounds like you've got better things to do too. If you've got spare time to do some programming outside of work - you could spend it on projects that have potential earning in the future, or even just writing libraries that actually save more work in other projects than this basic pedantic renaming stuff. I've written my own logging library to replace monolog for example. It's very very useful for me in debugging and logging all my other projects. If any of the PHP functions you're using get deprecated/removed in the future, then you're basically doubling your dependencies in any projects using your library. Sure your renaming/wrappers will be "nicer" generally - but sooner or later you'll find that your wrapper functions weren't as well thought out as you intended them to be. So nothings perfect really. There's a line somewhere of what is worth using natively vs writing wrapper functions for. The needle/haystack and underscore things are pretty OCD in my opinion though, and not worth risking bugs or future project-abandonment for. 
&gt; So sell them to me Let me sell you Google search. https://www.google.com/search?q=site:reddit.com%20inurl:/r/php%20framework%20benefits
I made this post to start a discussion with others about what frameworks do better than classic PHP, which is something I believe other people would be interested to read
You and /u/ZenPhpCoder have both said that using frameworks means you don't "reinvent the wheel". Do you mean that working from the more structured level that frameworks provide is more efficient than working "from scratch" with base PHP? What kind of things are in-built already with frameworks that you would need to rewrite over and over again if you stuck to PHP?
Routing, Secure Login, Template engine, to name a few...
&gt; What kind of things are in-built already with frameworks that you would need to rewrite over and over again if you stuck to PHP? Not trying to offend you, but it really seems as though you put zero effort into trying to answer your questions yourself. Take a look at the table of contents of the documentation of major frameworks. It's the easiest way to find out what kind of functionality they offer. It's stuff like: * Routing * Controllers * Views &amp; templating * Validation * Authentication * Authorization * DB related stuff * etc. etc. You _really_ don't want to build these things yourself.
I provided this link to hint you that there are already hundreds of "discussions" started by people who prefer to demand a personal assistance to doing a silly research themselves. So those who are interested to read, have plenty to read already. And you know, nobody gives a fuck whether you'll buy frameworks or not
If you don't want to use a full-stack framework, you can use a microframework like Slim and "glue" independent components to it. You can have some control of the parts, but you don't reivent it at all.
Symfony Flex seems pretty promising too.
To "buy" all this stuff one have to be at the certain level already. Show a Neanderthal a modern kitchen utensil - a toaster for instance - they'll find it pretty useless. So if someone is still taking PHP as tinkering with `while $row = mysql_fetch_array echo "&lt;td&gt;"...` they won't find Controllers very useful either.
Frameworks already have implemented things that basically every project needs these days and that will take you months or even years to get right. Second reason is most of them have though about security and security issue prevention. This is actually the part that almost every self-developed framework will have if there is only a single developer. You are never gonna find to develop it properly unless you have 0 private life. Things like tests, documentation (yes, you gonna forget a lot of stuff even you are the author). Basically, efficiency. There are frameworks out there for all kinds of project sizes and types. There are fully-fledged frameworks like Symfony, Laravel, Yii and others. There are micro-frameworks of different size - from absolutely minimalistic once to those that have most commonly used stuff. And so on.
How can you tell if PHP is running on your server? There are footprints in the butter
&gt; Show a Neanderthal a modern kitchen utensil - a toaster for instance - they'll find it pretty useless. If the Neanderthal learns how a toaster helps him, he _will_ find it useful. Learn how to code like an advanced human being, or keep coding like a Neanderthal.
Is your code fully test covered, stress tested, peer reviewed and fully documented? Is anyone that is going to start working with you instantly going to be familiar with the router, db abstraction, view rendering, dependency injection container, service registration, session integration and form handler? I'm guessing no, and that's reason enough to use a framework. When you start a new project do you have all those features completed by just pressing enter because you used a framework?
&gt; what frameworks do better than classic PHP Everything. Frameworks are built with classic PHP. There's no magic, it just makes it easier to build your product with since half the things you need are already there for you.
Well, yes, PSR is great. But it doesn't tell you where to put the classes. Maker/FastMaker.php Maker/MakerInterface.php SlowMaker.php AbstractMaker.php is still PSR compliant
Identifiers are also a type of reference. The point is nothing large is being copied for no reason.
I'm not missing the whole vision, because this RFC is being submitted on its own, and it has to make sense on its own. If there are other RFCs it's dependent on, they should come before it. Case in point if there's a RFC for "$$" and it *also works with my 5 second pipe() implementation*, then *still* it makes no sense to introduce a new operator to PHP, just to call a bunch of callables in a loop. Also if $$ will be a general feature for producing callables, it has a big weakness: why just one argument? If it's not just one, why can't we specify order? It makes sense for $$ to be one in the case of piping, it doesn't make sense as a general feature for producing callables. If it was a general feature for producing callables, I'd rather prefer it worked like this: $callable = $obj-&gt;foo($3, $2, 'testing', $1); $callable('a', 'b', 'c'); // Calls $obj-&gt;foo('c', 'b', 'testing', 'a'); Also if $$ (or whatever...) produces callables, then this means piping would, without special optimization produce callables, use them for one call, and then throw them away. That would be quite slow and wasteful. You say "it's easy to optimize this". So why isn't it in the RFC? I'm sorry but all this seems so sloppily thought out to me. It's like a crippled RFC is being driven into PHP, so then we can "fix" it with "the full vision" that's not documented anywhere. If a RFC would be proposed on its own, it should be good on its own.
You cant build a site/app without a framework. Once you start making decisions on handling typical problems you are building your own framework. So go write your own and *you* tell *us* why a developer would use an open source framework.
Whenever I try to write something my own (core stuff), I feel I'm writing some kind of framework all over again whereas my aim is just finish the project I started, not to write a framework.
Just because you don't see it does not mean it is sloppy. There is no reason it would be restricted to one parameter. It wasn't spelled out here but it's also not the RFC for that feature. Please stop criticizing people. It's rather rude. Focus on the products and omit phrases like "this seems so sloppily thought out " in the future. 
Assuming you are not trolling, take 10 minutes to read through [this](https://symfony.com/doc/current/create_framework/introduction.html#why-would-you-like-to-create-your-own-framework) and go from there.
Butter you say... I don't get it?
No this RFC is beautifully simplistic and you want to make it complex. There's nothing sloppy about it. Sarah proposed a previous edition, revised based on feedback which strongly criticized the use of $$, gave a new implementation, and left explicit room for future work inside of her email to the mailing list.
I hate these types of arguments. Person A submits a pull request Person b discusses the shortcomings and issues of a pull request. Person A: &gt; Well Person B, why don't you submit a pull request? I don't see why you have to criticize Person A's pull request when you don't have a better working solution ready! Fuck that. I can spend all day criticizing and discussing the current bullshit healthcare bills trying to be pushed in the U.S. Senate without having a bill drafted by myself.
I accidentally deleted this one, so here's it back: ---------------- &gt; Just because you don't see it does not mean it is sloppy. There is no reason it would be restricted to one parameter. It wasn't spelled out here but it's also not the RFC for that feature. We're being asked to comment on this specific RFC. This specific RFC seems sloppy and implements a pointless (on its own) feature. We can only comment on what we see. We can't comment on imaginary or invisible features. &gt; Please stop criticizing people. It's rather rude. Focus on the products and omit phrases like "this seems so sloppily thought out " in the future. OK, this is a **bad RFC**. It is apparently **dependent on some other yet-to-come RFC** and **provides no value** on its own. It shouldn't be in PHP in this form. As I said, I liked the previous version better. ----------------- Now, regarding your latest comment: &gt; No this RFC is beautifully simplistic and you want to make it complex. There's nothing sloppy about it. There's a lot of irony in choosing the word "simplistic" here. *Simplistic: treating complex issues and problems as if they were much simpler than they really are. Facile, superficial, oversimple.* Yes, it's rather simplistic. &gt; Sarah proposed a previous edition, revised based on feedback which strongly criticized the use of $$, gave an new implementation, and left explicit room for future work inside of her email to the mailing list. Look, I'm sorry but your narrative on this RFC no longer even connects logically together. You say people criticized $$, so she removed it, and you also said I don't see "the big vision" for this RFC, which is to introduce the $$ back in. So, which is it? Negative feedback was had. This doesn't mean we can mechanically chop off the unwanted features and implement a decapitated version of it in PHP, when it *makes no sense on its own*. Piping in this form is simply useless. Every RFC should justify the value of its own introduction without hypothetical and unspecified future work. If I can implement this RFC as a plain function in 5 seconds, this RFC is **noise** being added to PHP in its current form. Just more syntax to do the same things we already could. 
I'm guessing they meant server as in someone who serves you at a restaurant. It's still a big stretch.
It is clear you think you are more capable as a language designer. You seem to have plenty of time to criticize every RFC and then to debate it with people here on Reddit. So why have you not contributed to the language?
https://www.reddit.com/r/Jokes/comments/2bsz1i/how_can_you_tell_if_an_elephant_has_been_in_the/
Saying restricting return type-hints makes things "more flexible" didn't make sense to me, so I wanted to see what's the tl;dr on that statement. For those curious, the author never supports this in the article. In fact, they claim the exact opposite in the conclusion: &gt; A lot of that is due to the flexibility provided by dynamic typing. But this flexibility has limited PHP’s performance. PHP powers some of the most trafficked sites on the internet — WordPress.com, Facebook, Wikipedia, Etsy, and more. New language conventions that make PHP less flexible, but more performant are necessary to meet the challenges of using PHP at that scale. Also author's statement that adding more type-hints make PHP faster is false. Every type hint you add makes your code slower in the current engine. Yup, I know, it's kind of unfortunate, but it's true. In *theory*, if one day PHP has a specializing JIT with type guards, it can use static type information to make PHP faster. But today is not that day, and let me make a prediction that day is not coming anywhere in the next 5 or so years. Don't add type-hints in attempt to make "PHP scale". Doesn't make a lick of sense. Add type-hints when you want to assert the type (or cast it, as is the case with scalars) at specific boundaries to enforce API rules and avoid bugs.
Not quite. Rather it's the realization that we think they are valuable on their own and that one half was strongly criticized. By dropping 1/2 we can try and reap some of the benefits now and can refine and iterate on the problematic portion in the future.
I don't criticize "every RFC", I said I like the previous version of this one. BTW, as you can't defend the RFC, let's use this thread to fling personal attacks at each other, is this your plan? Well, it's not my plan. I reject your "request for comment" ;-).
/r/ComedyCemetery
I can defend the RFC just fine but you don't have to agree with me. I also didn't resort to personal attacks. I genuinely mean my last reply. Why don't you contribute? You have the capability and time and think you can do better.
The answer is I used to contribute to core, and then I found the process quite dysfunctional and I quit. I have no interest in contributing in this way any further. Also commenting on RFCs where RFC literally means "Request For Comment" *is contribution, too*. To call it not contribution is quite hypocritical. Why publish RFCs at all then? Just make a blessed council who can commit whatever they want to PHP without asking and be done with it, right? What are *you* doing here commenting with me anyway, if none of this contributes to PHP? Anyway, no need to answer. What's important in this thread is whether the RFC in this form has merit, or not. I explained why it doesn't. You refuse to provide further arguments why it does. So we're done here.
Frameworks provide a foundation with which to build upon... That said, every serious developer should definitely try writing their own framework at some point, you can learn an awful lot from it.... but unless you have years to spend on it, or have very specific requirements, don't use your home-rolled version in production.
Damn, I wish I saw this the other day. I just tried multiple sets of directions until I had something that worked correctly. It's just in a local virtual machine development environment though for me.
Yea, 3 years ago people reacted the same way ;) Were you just referencing it? Kind of hard to reference an obscure joke from 3 years ago IMO
I suggest that if you're not already locally using a virtual machine or something like Docker (Oracle has a lot of nice Docker stuff now by the way -- I mention that because I'm working in an Oracle shop and Oracle PHP stuff can be a PITA) that you practice on a virtual machine. I use VirtualBox and I have images that I call "base images" for certain stuff like PHP. One is a clean Centos 7, another has a basic LAMP setup for prototyping, etc... As you do each stage in the work that you have to do (for instance after a large "yum update" -- these can sometimes break your VirtualBox guest additions drivers and other things), and your image works successfully, take a snapshot. Then, when you do some step where you fail and hose up the environment, you can revert back to the previous snapshot rather than messing up your entire environment. The advantage to you doing it this way would be that you can set up your image to be just like your production environment. You'll get practice doing it before possibly messing up your production environment. And then you'll have a development environment locally as well if you wish. You can also practice with Docker images, that's a great way of practicing doing stuff through the shell and the images for 5.4.16 can just be downloaded for practicing with.
I've heard numerous people say they learned a lot from creating their own CMS (as an exercise). You'll increase your PHP programming skills even if your resume doesn't show a lot of experience with major frameworks. I use Codeigniter and I tend to use a lot of built-in stuff like Query Builder (Active Record), Codeigniter forms validation and third party libraries like Datatables (for building reports and even CRUD), so I may not be building up my PHP chops nearly as much as you. So you may be a better programmer overall but maybe a less experienced applications developer? That doesn't mean that you can't introduce improvements using stuff like jquery libraries and other third party modules to your existing application. That could still be a major improvement to your existing CMS and would still look good on your resume. You can also write libraries for your CMS that are open source and make those available to others.
3 years ago? Mate, this was an old joke 30 years ago.
That's fine, but the topic he linked was posted 3 years ago.
&gt; Also commenting on RFCs where RFC literally means "Request For Comment" is contribution, too. Sure. I meant "why don't you contribute directly" instead of here on Reddit. Which you answered just now; you found it dysfunctional. &gt; I explained why it doesn't. You refuse to provide further arguments why it does. It can be optimized where `pipe` is highly unlikely to be. Is that not valid?
But building this is fun!
&gt; It can be optimized where pipe is highly unlikely to be. Is that not valid? It's not valid because $$ is not in the RFC, and the optimization for $$ is not in the RFC. There's already strong indication people don't like $$, and as a general purpose it's even more awkward and confusing, not to mention as general-purpose feature $$ is not complete as it can't specify multiple parameters (why are you making me repeating myself?). This might cause that *next* RFC for $$ to change drastically or not be adopted at all. We'll still be stuck with a useless |&gt; pipe implementation for B.C. reasons. "[Trust me](https://1funny.com/wp-content/uploads/2011/10/stairs-to-nowhere.jpg) it [will make sense eventually](http://2.bp.blogspot.com/-lMEpYy4KvAo/VDl_M7N4AeI/AAAAAAAA12Q/Z-GQ6UFQvfA/s1600/stairs%2Bto%2Bnowhere%2B2.jpg)" is a poor process and reason to adopt a RFC.
To be clear the optimization would work with any immediate closure, not just ones created with `$$`. Also, I did address that `$$` can support multiple parameters further up the chain: https://www.reddit.com/r/PHP/comments/7178o3/rfc_predraft_for_pipeop_v2/dn9clm5/.
Frameworks are "classic PHP" as you put it, just that they have written a lot of the "classic PHP" base code for you. All frameworks solve different problems and some excel in certain circumstances than others so you will have to research based on your specific project. They do however usually always share some common traits such as: - Routing - Templating - Authentication/Authorization Of course, you can write all these things your self but why? Sure as a learning exercise it's well worth doing (and I have done) but not a smart way of working when there is already very well tried and tested code out there that will achieve the same thing. No offense, the code produced and used by so many people will be much better than you (or I) could probably do it on our own. Another advantage which is often overlooked is documentation. The popular frameworks (and some other not so popular) are very well documented, much more than your self-rolled solution will be. Sure if it's only you ever working on the project then this might not be an issue but if the project grows its much more manageable if the application uses a well-known and well-documented core.
All points are valid but that was a lot of effort for a rant. Github is the new cancer in the community where devs compete for a virtual currency known as stars, the more stars they have the better their code is. It's really sad that so many devs compete and boast about something like that.
I have nothing against people using Docker but it seems the vast majority of the PHP community is not using it for its original purpose and its one major benefit over any other virtualisation workflow. To have the exact same environment locally as in production ruling out the "it worked for me" excuse.
This. Using your favorite Laravel / React / Whatever stack is probably overkill for smaller projects that just need a little dynamic content
PDOStatement::fetchAll(PDO::FETCH_CLASS)
Do you find the existing code to be intuitive and acute? &gt; array_filter($data, [$obj, 'method']) The proposal at least *looks* like it somehow involves method calls. An improvement, is it not?
why don't you use an older version of doctrine that supports php 7.0?
Cool,I didn't know about that. Any limitations I should know about?
I suppose I could, I'd need to see about bugs and security issues first.
7.1 is required for doctrine 2.6 (new features basically) You can use 2.5 which is very stable, works with php 5.4+. Furthermore 2.6 was just released and almost everybody is still using 2.5 anyway
3.8 just killed my site, no admin access. Gone back to 3.7.5 until i figure it out 😔
You can get started here: https://phpdelusions.net/pdo/objects Calling the constructor after setting member field values is really useful.
You must support whatever you build. Many people turn to common frameworks so that what they must directly support is reduced by having the framework maintainers do the support instead which allows only the need to keep their own custom stuff up to date. Leveraging frameworks also speeds up initial development time so places that crank out multiple projects leverage as much as possible and write some glue for their application in order for a quick turn-around to be profitable. Even when leveraging frameworks and dependencies via composer, you still must support dependency compatibility for what you use. When writing large-scale applications that are intended to be heavily used for many years, it's common to write proofs of concept or initial versions of the applications with frameworks and various other dependencies. Over time and as the scale increases and requirements change, the limitations of those initial dependencies start to show and you need to extend the functionality yourself. You usually have two options at these junctures: effectively fork the dependency by adding in your modifications and keep it updated or drop reliance on the dependency and make the functionality exactly what you require. Either way, you now must support the entire featureset that you once had the dependency maintainers support for you when you used their dependency. What makes the most news are additions and updates to dependencies because many people use them since they're great at solving 90% of most people's problems. If you write something entirely custom to your needs, then nobody else can realistically use it so nobody wants to talk about it as it doesn't directly concern them. That is why frameworks and other dependencies dominate the news. When deciding on whether to use a framework or some other dependency, you must factor in the cost involved. Does it actually do what you need? Does it do too much or too little? Does it conflict with anything you already have? Would supporting keeping updated with the dependency cost more in time and resources than writing your own custom tailored component and supporting that? How quickly must this be completed? These are all items to consider. For large enterprise applications I'm involved with, the first or second iterations almost always include some kind of dependency until we either fork what we're using and drop the dependency or rewrite/refactor to fully customize and optimize what we need. Over time, we eventually will drop most php package dependencies. Dependencies we never drop are third-party applications that would be insane for use to try to reimplement like running libreoffice in headless mode to easily convert documents so we don't have to parse an old binary format ourselves. Whenever someone asks about frameworks and such openly like you have, you'll always get a response about not reinventing the wheel. Sometimes the wheels available aren't sturdy enough for your needs like a wheel off a common car would never be sturdy enough for F1 just like a wheel for a carriage would never be sturdy enough for public transportation. You might need a tire, but your wheels only support old metal bands and you need a synthetic rubber to drive in the rain. Sometimes you just need something so entirely custom, that your only option is to reinventing the wheel like in [this situation](https://i.imgur.com/kMeSNQE.gif). More often than not, something is available that does nearly everything you need so you don't have to spend your own resources on it. This is the major benefit of dependencies...frameworks especially.
You're using `include_once`, instead of `require_once`, which suggests that failing to find the class in question is an acceptable outcome, which is clearly not the case. You're also using old-school manual class loading instead of an autoloader, which has been the standard practice for over a decade.
I actually disagree. I think a framework would be better in this situation, especially if you are making multiple "honey bee farm" sites. If you're redoing where the routing or how you handle a form or the db connections in each of your projects, going back when you have to fix a bug or add content is going to take longer. Or if you hire another dev to help you with managing the sites, you are going to be constantly saying, "oh in this project, I put that stuff here". Especially considering the fact that each time I built my own sites from scratch years ago, I would always make changes to my "framework" each project, which would all be breaking to my previous codebases.
&gt; To be clear the optimization would work with any immediate closure, not just ones created with $$. It's not clear at all - it's not in the RFC, it's not what we're discussing. &gt; Also, I did address that $$ can support multiple parameters further up the chain "To address" a problem means to "solve it". Saying "I won't talk about it" doesn't address it, it leaves all the questions in. And as you said, it's not part of this RFC, so it's irrelevant. The current RFC remains problematic. 
So to be clear, you're claiming that if a convention arises to use in place of a shortcoming a language may have, that prevents the language from evolving in the future? And furthermore, even though a proper solution may not exist, adopting a convention that conveys the code's intent is completely "worthless" (i.e., has no value to anyone using the code that is conventionalized) and instead nothing (no convention) should be done. That way, with no convention in place, the language is now free to involve and, hopefully, address the shortcoming at $some_DateInthe_Future (Notice I mixed snake and camel cases in that variable; didn't want to adopt a naming convention there and throw you off) Is that it? Do I understand?
It's pretty hard to link to a 30 year old reddit thread. 
Thanks for your hard work on this! Looking forward to using it soon :)
You asked why I was making you repeat yourself. I responded directly to you. That's how conversation works. Denying clarification here as part of our conversation because it isn't in the RFC is not helpful.
We hope you enjoy it when you get the chance to use it!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I doubt very much kids today still use phrases like "totes legit", at best that idiom is a generation old. And yes, I'm old. Now get off my lawn.
No, because in some if not most cases, the method you want to pipe to isn't going to be a builtin method on that type. I would like to see methods on base types though...
That depends VERY much on how the union of PFAs and Pipes comes together. If they're tied together as a single feature, sure. But PFAs become way more powerful if they can function independently, and at that point ambiguities exist in the parser and you wind up with a mess, so sadly... no.
It would be executed, repeatedly for each element of $data, just as you should expect from array\_filter(). The fact that a closure is declared behind the scenes is an implementation detail.
The problem with this kind of syntax is if you want to include your custom method in a chain of internally defined methods. It then becomes something like this: `my_custom_function("MyString"-&gt;toUpperCase()-&gt;reverse())-&gt;append(' goes here');` which becomes quite messy in terms of visibility of call order. The good thing with pipes (operators or just pipe functions) is that you can mix function source (internal functions, custom functions, closures) and still keep an easy to read ordering.
I can't change the database schema without doing huge major changes to the server application; there's a server application that interfaces with these devices. The devices connect via TCP to the server, and each device type has their own set of data that the server inserts into the database. So things go into the last column called attributes as an object with a collection of key &amp; value pairs. This is where stuff like battery is put in, accuracy measured in pdop/hdop/gdop/tdop/etc., and a slew of unique information. Some may report instead of "battery" as "battery_life" etc. What does stay consistent is that they all report latitude and longitude. ---- Any hints on possibly making MySQL better with indexing?
my understanding of generators suggests that in situations where you're doing `array_map(function (){}, array_filter([...], function() {}))`, generators may be more efficient since you'd be conditionally yielding a remapped result inside a foreach loop.
Because it's being migrated to a new server.
Maybe if short closures were a thing, this would be useful. Especially if there was an extra short closure syntax life Swift has, where you don't have to (but can) use an argument list and a fat arrow, just braces and that has implicit return. Something like $myVar |&gt; { $0 / 100 } |&gt; { number_format($0, 2, ',', '.') } |&gt; { sprintf('%s&amp;nbsp;€', $0) }; // What is this "Intl"? That would replace $$ complete without being complete magic.
That is a highly subjective and opinionated response. Keep in mind that most "honey bee farm" sites contains a landing page with "this is our family" and then a link to a "look at the picture of these boxes in our yard" sub-page. If you feel the need to make a fully integrated and automated way of generating these two, basically flat html pages, go ahead, but as a developer you'd push equally as many websites either way. But this only applies if you happen to know that multiple clients want this type of site. I'd start off simple, and if I get referred to, i'd start thinking of a platform based tool for these sites later on, when I know I have clients to support the development costs, which goes up a lot. So instead of pretty much piecing together two-three pages in 3-6 hours, you spend 20-25 hours on building a platform - which isn't something one honey bee farmer want to pay for.
What you've just described is "Partial Function Application", and it's absolutely part of the intended future scope. Or pre-scope, depending on how this discussion goes.
I guess you're stuck with needing to leave the existing columns as-is then. And I guess your PHP scripts aren't even being executed when the TCP inserting happens? A few different options come to mind... Are you using a version of mysql that natively supporting the JSON type and accessing JSON fields in SQL? options A+B below would require that... a) You could still normalize the data during inserts into new additional columns using SQL insert/update triggers. Not sure what they're like in mysql, I switched over to postgres last year and only just started using triggers after switching to postgres. Once you've got your normalized columns, the indexing on them would be pretty standard. b) Write some output SQL views that seek the fields from different configs automatically using stuff mysql's COALESCE(attributes-&gt;battery_life, attributes-&gt;battery) function... and then run the founds values through a function that converts stuff like 99% to 0.99 or whatever consistent format you want to use. Just in PHP... c) Although separate to all my suggestions on doing more stuff in SQL... the stuff I mentioned about just writing one single PHP import script that auto-detects fields/formats... could you just auto-detect most of this stuff on output instead? i.e. instead of having a PHP class for every config/format, you just have one class for all these records where each method such as getBatteryPercentage() just detects the existing fields/formats from the JSON automatically? i.e. Check if the "battery_life" field exists first, then try "battery" and other aliases etc. Even if that doesn't work for all formats, you can just extend the base class where it really is impossible to auto-detect the config. Also looks like you deleted the original post text? Any reason? Makes it harder to help. 
Is that what it's called? { htmlspecialchars($0) }; in this example was just a shorter form of function($0) { return htmlspecialchars($0); }; Which could probably (Don't know PHP internals that well) not be inlined by PHP like a function name with $$ would, so wouldn't we lose the performance benefit of having pipe as an operator? 
You'll probably want to start off with a framework, such as symfony. There are plenty others also. Then you could configure LDAP, authorize sections of the site based on groups if needed. Documentation is here https://symfony.com/doc/current/security/ldap.html . You could choose another framework if you want it to be easier, or you don't like how symfony does forms, ORMs, etc.
If I'm reading this correctly, you're suggesting that (separately from this change) `$$` could be effectively a macro^1 that yields a callable with one argument and appropriately-bound variables for the other params? e.g. `foo($$)` expands to `function ($x) { return foo($x); }` and $my-&gt;foo($bar, $$) becomes function ($x) use ($my, $bar) { return $my-&gt;foo($bar, $x); } Am I following correctly? If so, I take back (almost all of) my previous statement, and think that these coexist very well and is actually a very clever approach, and could have some pretty wide-reaching positive implications in areas well outside of the proposed pipe operator (v2). The only caveat is that I don't think it makes sense to have the pipe operator *before* this macro-binding-thing just because we could end up with some very ugly situation in say 7.3 full of stringy callables that can't be remedied until 7.4. That is to say, I think the `$$` thing should block the linked proposal, even if they're technically orthogonal. ^1 macro may not be quite the right terminology here since they generally don't exist in PHP, but I think it's the closest analogous concept.
Well, at the moment, nothing is inlined, ever. If we did start digging into inlining, it would most likely start with identity functions like this, where there's just a proxy through to another function and lifecycles on temps are going to follow a clear up-down pattern. In that event, I expect both forms to see the same optimization applied equally. TL;DR - Performance always matters, but it's mostly a wash here.
Yes, you followed it correctly. It can potentially even bind things automatically by reference when appropriate - still investigating the feasibility of that.
You might also be interested in `use namespace Foo\Bar;` and `use type Foo\Bar;`, effectively splitting `use Foo\Bar;` in two. I've been meaning to write this up as an RFC at some point, but haven't had the time. - we went for `use type` instead of `use class` because we have additional forms of types: enums and type aliases; I would suggest the same for PHP for clarity in case additional types get added in the future - We added this because we added `vec`, `dict`, and `keyset` value types, and wanted the library to be in similarly named namespaces: `use namespace HH\Lib\{C, Dict, Str, Vec};` and `$foo = Vec\map($bar, $x ==&gt; do_stuff($x);)` for example. as the runtime is still case insensitive for PHP compatibility, this wasn't possible with the standard `use` construct - and we feel that being specific about exactly what you're importing is an improvement anyway, and more consistent with `use function` and `use const`
Well, then I'm in favor of this proposal. ... But it shouldn't be implemented before the features that make it useful are.
If it's a hypothetical future RFC, it's not a clarification about the purpose and value of this RFC. It's that simple.
Awesome. I really appreciate you coming into a fairly hostile thread and rationally explaining the thought process. You've sold me on this being a better idea.
&gt; Then you could configure LDAP, authorize sections of the site based on groups if needed. Documentation is here https://symfony.com/doc/current/security/ldap.html . I love me some Symfony, but I can't recommend this for someone new to PHP. In my experience Symfony's LDAP component is lacking and requires some heavy lifting in some cases. In my situation I wanted authentication over LDAP while storing user objects in a database using Doctrine. This ended up being a custom authenticator, user provider, and doing most of the LDAP stuff outside of the LDAP component with Zend\Ldap. Symfony's Security component is one of the more obtuse parts of the framework. 
Memory efficient or CPU efficient? Generators are not as fast as maps. Generators use less memory than maps. This is the basic trade off. Filter creates a new array and only those in that new array are passed to map. Either way you test the element. Either way only those that pass get passed to the map. Using a generator in place of map/filter is overly complicated and expensive when you don't need to conserve memory.
&gt; you spend 20-25 hours on building a platform php composer.phar create-project slim/slim-skeleton honey-bee-farm That takes 20-25 hours? Have you ever used a framework before?
we do.
So basically, I'm *so* out of touch with "kids today", that I'm back in touch again? Gnarly.
Fair critique. And that may be what the conversation pivots to. I'm quite keen on PFAs and Short Lambdas being a thing, regardless of the status of Pipe.
Yeah, that's a fair description, though I'm not sure I agree with the situation you described being "ugly". It's certainly suboptimal to have your 7.3 code read like: $x = blah() |&gt; function($v) { return thing('boo', $v); }; But once shortlambdas/pfas are available (even if that's 7.4 or 7.5), updating the callsites is an easy diff. $x = blah() |&gt; $v ==&gt; thing('boo', $v); Or: $x = blah() |&gt; thing('boo', $0); It may be that pfa/short-lambda *does* end up blocking pipe, and that's cool too. :emoji-shrug:
Seeing you're starting off a new project, and using PHP, are you sure you wanna use MSSQL with all it's costs and licensing limitations etc? Postgres is more advanced than mysql, so it could be an alternative. https://www.pg-versus-ms.com/
Totes 
operationally efficient, I suppose; assuming I'm reading the opcode info correctly; * [generators](https://3v4l.org/0XM1H/vld#output) * [assign, filter, map](https://3v4l.org/5Sc8D/vld#output)
That would make it so much more elegant, but there are a lot of other things that I'd like to see happen before the pipe operator. Imo there's not really much of a usecase for this, but typed properties, read-only properties, property initialization without constructors (like objects), generics, proper data structures such as dictionaries, tuples, lists etc. Typed arrays... Those are things PHP needs, not an alternative syntax for function chaining :(
I am more concerned with the stringy callables (`$x = blah() |&gt; 'strtoupper';` or `... |&gt; [ArrayHelper::class, 'upperCase']`) than explicitly building a closure. Is it a blocker? No, of course not. I think it's more a matter of finding the current string/array callable particularly grotesque compared to many other languages, and I'd strongly prefer to see a solution to that before another feature that builds on callables. It's one of the most confusing thing to seasoned developers using PHP for the first time, from what I've seen. Tangent: `$0`in your example could work really well for short lambdas, as there's an obvious way to support multiple arguments. Swift does exactly this, and it's really lovely to work with (`someList.sorted(by: { $0.key &lt; $1.key })`). You'd lose some type information in PHP specifically, but it's often borderline-redundant from the surrounding context anyway. It also has the nice benefit of not conflicting with any code since it's currently invalid.
&gt; Why don't you contribute? Wait what.. He will have better luck in teaching a cow, a symphony. Than to deal with stas, zeev, and lot of people in internals. Oh, and for the record, if there is anyone who is contributing to php. Its just nikita and dmitry (and some folks who do windows support). Rest of all are just *noise* in php-internals. https://philsturgeon.uk/php/2013/09/09/t-paamayim-nekudotayim-v-sanity/
That's pretty crazy that they didn't realize that it's a terrible idea to just take the user input that's completely unsanitized and stick it in a string and hope the user doesn't happen to use any of the special LDAP query stuff in the username data they enter. If anyone was aware of what they were doing when they wrote that, serious alarm bells should have been going off in their head. Maybe multiple developers were involved and the guy writing one part of it assumed the guy writing the other part would do the sanitizing. Or something like that.
Yeah, that's reasonable. IMO, your case wasn't a typical LDAP situation. Most of the time you just use LDAP to authenticate and maybe authorize based on groups. But yeah, symfony is pretty difficult to get started with, especially security, and especially for a beginner. Unfortunately, I don't have much experience with other modern php frameworks, but I heard laravel is easier. That might be worth checking out.
I have 7752 additions and deletions across 30 commits over four years. I have authored or coauthored 6 RFCs that have passed. I have 279 commits to web-php, 1 to phd, and 3 for web-wiki. This doesn't even include bug comments and triage. Nikita and Dmitry are valuable members, no doubt. My stats are not anything close to theirs but to say I'm *just noise* and imply I haven't brought any value to PHP? There are plenty of contributors at my level of contribution or more. Please keep your discussion civil, thank you.
So, you would consider using an older version of Doctrine, but not upgrade from PHP 7.0 to PHP 7.1? If you're so worried about bugs and security issues... 
I'm not nessecarily in charge of upgrading
You basically replicated my initial post by adding overhead. But yeah, nice job. Edit: Btw, thanks for the down vote which further proves my point on how ridiculous you are. You don't need composer, you don't need slim, you don't need configuration files in your project directory, for all I care you don't even have to have sub-directories. The point where you **need** a framework, is when a project is complex enough. A honey bee farm site just isn't, no matter the number of sites you run, and when you hit a critical mass of having too many - you might want a multi tenant platform which takes more than 2-3 hours to make, this is where frameworks would fit right in.
Ahaan.. https://github.com/php/php-src/graphs/contributors https://github.com/php/php-src/commits?author=morrisonlevi
It's not defined where to put the interfaces and classes. A common practice is to put them into the same folder. Here are very popular packages (just for orientation / inspiration): * https://github.com/php-fig/log/tree/master/Psr/Log * https://github.com/symfony/console/tree/master/Output
&gt; just as you should expect But that's not what I expect. I see a function call, not a callable. I have to read carefully to spot the `$$` hidden at the end to realise it's a callable.
My suggestion, read: http://www.phptherightway.com/ Pay special attention to the chapter about Composer: http://www.phptherightway.com/#composer_and_packagist Start a new project using Composer and this composer package: https://github.com/Adldap2/Adldap2/blob/master/docs/quick-start.md https://github.com/Adldap2/Adldap2/blob/master/docs/models/group.md Add other packages as needed (templates, etc.) Good luck.
Well for starters I don't really see a reason to use that syntax now given we have closures. But it is (slightly) more intuitive to me as you are passing something to `array_filter`, whereas the `$$` syntax looks like you're calling a function *before* passing the result into `array_filter`.
&gt;But once shortlambdas/pfas are available (even if that's 7.4 or 7.5), updating the callsites is an easy diff. The reality is that once code is written that works, it is rarely updated just to take advantage of new syntax. It is read far more times than it is updated.
Frameworks provided well-tested code to solve common problems so that you can focus on what matters to your application. As an easy example, using the ORM in a framework means you don't have to spend as much time worrying about managing SQL connections or how routing works and can instead focus on your business logic. 
&gt; That's pretty crazy that they didn't realize that it's a terrible idea to just take the user input that's completely unsanitized and stick it in a string He wasn't saying to himself "Let's take the user input that's completely unsanitized and stick it in a string."
Welcome to Joomla. The whole project is a mess like this. Worked on a site integratedfor a year or so that was 100% joomla and it's got a the worst APIs and Documentation I've ever seen.
Give [ProcessWire](https://processwire.com) a try, it doesn't have everything you're asking, but it's very flexible. I suggest you read the about page if you want to learn more about it. https://processwire.com/about/
What an inflammatory and clickbaity title, even if technically correct. Those issues are exploitable in a fraction of a fraction of a fraction of those sites. 
Yes, they're likely using a geoip database.
https://github.com/maxmind/GeoIP2-php
Wow this thread deteriorated rapidly. My opinion has not really changed after reading through it, I do think the real issue is the state of callables, and while they're in the state they are, it is probably counterproductive in the long run to introduce more language features which depend on them until we go through the pain of getting them fixed, and upgrading all of our respective codebases. Personally, if we were to have this feature, I think the original proposal of the $$ symbolic would be necessary to provide it with the power needed to do anything useful (that can't be done in the loop given as an example elsewhere). IMO The real power will come from functions, member methods etc being treated as their own function type. If we can use $obj-&gt;method or method_name (or even method_name::fn) to define a strict closure of relevant scope, then it would become much cleaner to introduce something along these lines. I threw together an example of what might be viable if functions could be represented as objects... code is a little less clean due to the lack of an "operator()". &lt;?php /** * Class LateBoundParameter * * In the absense of a syntax symbol to represent late bound params, * let's just use a class instead, as we can always consider it a unique * type thanks to instanceof */ class LateBoundParameter { private $index = 0; public function __construct(int $index) { $this-&gt;index = $index; } public function getIndex(): int { return $this-&gt;index; } } /** * Class Closure2 * * The meat and bones of this example, this class represents a closure * that has some bound arguments, with some which may be late bound. */ class Closure2 { private $_call = null; private $_args = []; public static function Create(callable $c, array $args): Closure2 { return new self($c, $args); } private function __construct(callable $c, array $args) { $this-&gt;_call = $c; $this-&gt;_args = $args; } /** * This is how you mark that a variable should be resolved at execution time * * @param int $index * @return LateBoundParameter */ public static function InParam(int $index): LateBoundParameter { return new LateBoundParameter($index); } /** * Eh, completely forgot about __invoke * * @param array ...$args_in * @return mixed */ public function __invoke(...$args_in) { $call_arguments = []; /* * To deal with the issue of late binding, we search through all the arguments * that were passed, and check to see if any of them represent a late bound value, * if they are, we extract that value from the passed args_in varadic. */ foreach ($this-&gt;_args as $arg) { if ($arg instanceof LateBoundParameter) { $call_arguments[] = $args_in[$arg-&gt;getIndex()]; } else { $call_arguments[] = $arg; } } return call_user_func_array($this-&gt;_call, $call_arguments); } } /** * Class HypotheticalFunction * * This class just represents what a function may look like as an object */ Class HypotheticalFunction { /** @var callable */ private $emulation; public function __construct($emulation) { if (is_callable($emulation)) { $this-&gt;emulation = $emulation; } else if (function_exists($emulation)) { $this-&gt;emulation = function (...$args) use ($emulation) { return call_user_func_array($emulation, $args); }; } else { throw new RuntimeException('You goofed.'); } } public function __invoke(...$args) { return call_user_func_array($this-&gt;emulation, $args); } public function closure(...$args): Closure2 { return Closure2::Create([$this, '__invoke'], $args); } } /** * This effectively replaces the * |&gt; chaining * |&gt; method * |&gt; proposal * * @param $start * @param array ...$chain * @return mixed */ function doMakePipeRedundant($start, ...$chain) { foreach ($chain as $link) { $start = $link($start); } return $start; } /* * As the language cannot currently reference functions by their symbols, let us * emulate that ability by creating objects to represent each one. */ $str_replace = new HypotheticalFunction('str_replace'); $str_reverse = new HypotheticalFunction( function ($x) { return strrev($x); } ); $result = doMakePipeRedundant( "aaaabbbb", /* the first two arguments are fixed, the latter uses late binding */ $str_replace-&gt;closure('a', 'A', Closure2::InParam(0)), $str_replace-&gt;closure('b', 'B', Closure2::InParam(0)), $str_reverse-&gt;closure(Closure2::InParam(0)) ); /* expected result: BBBAAA */ print_r($result); echo PHP_EOL; /* using it as an object, expected result: goodbye world */ echo $str_replace('hello', 'goodbye', 'hello world') . PHP_EOL;
Maxmind.
You expect the callable arg to array_filter() to be something other than a callable? Ok.
Edited because it's 3am and I completely forgot about __invoke.
4 months of working in Joomla was enough to make me swear on my life to never touch it again. 
You described Craft pretty well in your requirements
Drupal 8 is definitely worth a look. The API's are quite flexible and feel pretty modern although they don't follow PSR-2, Drupal has its own coding standard. It mainly builds on Symfony so if you're familiar with routing, DI and services from Symfony, you're already half way there. There is a large eco-system of modules that enhance Drupal, including [Drupal Commerce](http://drupal.org/project/commerce) that is very powerful and should meet most of your ecommerce requirements. If you have any specific questions about Drupal ask away.
When you work in the web-tier you will encounter a lot of aspects that actually require a good dose of knowledge. E.g. the whole request/response cycle, you will need configuration, permissions, security etc. A lot of these things are common to most web-tier projects, so, why not have a reusable set of components that are tried, trailed and maintained by a community? Yes, you can roll your own but you will end up building an application AND a framework at the same time. From experience I can tell you, not a good combo. You will drop the ball one one of them, if not both. Are you building an application that solves a problem? Then focus on that, not on building a framework. If you come from a plain PHP background, have a look through this tutorial, it will show how you can build your own framework from Symfony components. I'm not suggesting you do though, but it illustrates how a reusable set of components can solve many problems for you without reinventing the wheel: http://symfony.com/doc/current/create_framework/index.html Good luck! 
Have you ever touched ModX? I thought it was good until I realized how terrible it was. If you hate Joomla you'll really hate ModX.
He has a point though, it looks like a function call (that might return a callable ofc). I always wondered why we don't have the JavaScript way of defining references to functions, or perhaps take a look at how C# or java solved these things.
Have you ever tried proprietary hosting company builders from 2005?
Someone was paid a solid $0.50 for writing this article.
I have successfully used ProcessWire for about 3 years now. It allowed me to do what I tried to abuse WordPress for or try to bend any other CMS to. I was even able to build powerful modular front-ends for our customers on top of it: https://i.imgur.com/9n7Gce8.png If you are fine with the backend they offer, it is very clean and modular as well (to allow the above front-end editing experience in the first place) The PHP API and syntax and extensibility is what makes me choose ProcessWire for every website or app project. This allows to easily create pagination, filter, sortable pages or similar/ They have a very living and caring community, both in forum support and development. Almost all functionality I needed for my websites and apps were in ProcessWire. Best, Martin
Click bait
No, but I have tried "proprietary hosting company builders" from 2017.
All benefits apply to other frameworks too, useless article...
Let's pray for all those who "Hire Laravel India developer". They surely need help. I might set up a web site for those who fell in the trap.
I've just finished a site built using [Craft 3](https://craftcms.com/3). As a developer, it's been an absolute dream to work with: Composer install and migrations mean I can host this on something like Heroku for free, hook up the assets to AWS and have a system ready to scale without even breaking a sweat. It uses Twig for templating which is very powerful and as it's built on Yii (which I've never really used outside of Craft), you have quite a powerful system for developing plugins. Only downside is 3 is in beta and the documentation is a little sparse, but I'd definitely recommend it.
PW or Craft. Little old now but might help if your interested in Processwire https://benbyford.com/articles/why-i-choose-processwire/ 
Looks like LDAP authentication is off by default and used only on a small percentage of installs. Although I'm guessing passing a test payload would tell you instantly if a site was vulnerable or not, so bots will create carnage on unpatched sites in coming days.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
We had to make this decision over two years ago and we went with [Kunstmaan CMS](https://github.com/Kunstmaan/KunstmaanBundlesCMS). Here is how it relates to your needs: ✅ Pages and content editable by client — there is no limit to what you can edit on page, including custom CRUD modules, then including those various entities in both automated and manual way 🆗 A powerful admin interface — it’s fairly basic, but it has it’s toys to play with, and you can extend it quite easily 🆗 A simple and extendable internal API — the system is only starting to mature, I think it could be better in this regard, but there is a solid baseline. Basic things like CRUD controllers are generated for an entity, but you have the ability to tweak to your needs 🆗 Good for both large (…) as well as simpler sites — I haven’t done any e-commerce stuff using it, there is no support, you’d have to stitch something together by yourself. Other than that, I made both simple sites and large platforms with custom registration flows, powered by some marketing automation tools, extended user permissions, … ✅ Modern development practices — the project is basically a bunch of Symfony bundles wired together in a demo app you can extend in any way. The code quality is lacking in some places, but otherwise there is very little lock in, and very much Symfony mechanisms in use. More on that later ⛔️ An API — nope, nothing out of the box, but it would be fairly easy to write this layer yourself ✅ Actively developed — it’s subjective, but they are definitely not stagnant 🆗 Good community support — there is stuff going on on their github page, but no forums, not very much [community plugins](https://bundles.kunstmaan.be/documentation/master/contributing/community-bundles) ⛔️ Themes ✅ Commercial / paid CMS systems are fine — MIT ✅ PHP based with webpack for the frontend layer in the newest releases (you can use your own) ✅ Not WordPress ✅ Database backed — Yes, a regular doctrine in the backend. As far as I remember it can work both with relational databases and a document store, but I think the latter isn’t supported very well The main reason we chose this project is Symfony. There are some Symfony-based CMS out there ([bolt](https://bolt.cm/), [pagekit](https://pagekit.com/)), but they don’t let you use those Symfony features during development, and require you to be locked in their custom architecture. Kunstmaan is different in that way. It’s just a regular Symfony application you can extend: * You can override templates using standard mechanisms * There is a configuration for common settings * You can use your own implementations injecting your own class names into container (using parameters or Compiler Passes) * You can extend existing forms using form extensions or build your own basing off them * There is a way of changing form templates (twig/form_theme) * A lot of modules dispatch events for you to plug into * etc, etc It plays nice with the ecosystem? Need to cache a bunch of stuff? Use Doctrine Cache on the lower level, and FOSHttpCacheBundle to cache parts of (or whole) HTML pages. No in-house solutions here. User management is based on the FOSUserBundle, and so on. There are some downsides. The project isn’t mature yet and it is changing a lot. There are parts of code that seem to be coded by a drunk monkey. There are bugs, because the CMS isn’t that popular and battle-tested yet. Some features are lacking. My team is using it for over two years now and I feel that it’s getting better. We started with Symfony 2.6 and during the first two months of bootstrapping we submitted over a dozen of pull requests with bugfixes and small features. Now it supports modern frontend stacks, has more features, less bugs and runs on top of the latest Symfony version. It doesn’t mean that we didn’t have to [code a bunch of stuff ourselves](https://github.com/syzygypl?utf8=%E2%9C%93&amp;q=kunstmaan) (and this are only the parts that seemed worthy of open-sourcing). Given the alternatives, I’m happy using it.
Wouldn't it be easier to use http://php.net/manual/en/function.simplexml-load-file.php along with a node class of your making ? 
No idea, I read somewhere this is faster. I have a ton of files and a ton of entries and need to process the file as fast as possible. Are you saying your way would be faster?
I don't know about "faster" but using a single line to read the xml and sort all entries into one single SimpleXML object seems pretty handy. I don't know your use case, but using XMLReader AND SimpleXML to reinterpret the XML to another object seems overkill.
You mean https://ipinfo.io/ ? :)
Ok thanks, I'll do some tests. How would you diagnose the script stopping after X number of entries?
Have you tried to wrap it in a try/catch snd then dumping the error? Are you sure error reporting is set to report all errors?
I'd not diagnose, I'd first simplify and enclose it in a try/catch to see if something happened. I wouldn't use XMLReader as I'm not even sure it throws exceptions if something goes poof in its XML mechanics. If I understand your script, you're reading the file somewhere else, extracting objects through XMLReader, and then create single SimpleXML objects based on the parsing of the XMLReader rendering of the same objects. I'd do $items = simplexml_load_file($file) and iterate through the $items. 
&gt; I wouldn't use XMLReader as I'm not even sure it throws exceptions if something goes poof in its XML mechanics. Really? I didn't know that -.-
No I haven't, I'll need to use try/catch to see what's going on.
Huh? I literally said I expect a callable. When I see the above I don't expect that `$obj-&gt;method()` is the method that will be called during the 'loop', I expect that method to be called *before* `array_filter` is called and the result passed into it.
What happens when $r-&gt;name !== 'Entry'? libxml_use_internal_errors(true) will collect parsing errors, and libxml_get_errors() will get them for you. 
Without an actual RFC, which this thread falsely claimed to be, I can't say I understand the difference.
That's when the parsing stops. I advance between nodes with $r-&gt;next('Entry'); Where do I put the two functions you mentioned?
On the plus side, Joomla site ops are probably used to it by now.
Legit
Maybe http://php.net/manual/de/simplexmlelement.xpath.php is something for you
It's probably the Javascript geolocation API. https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation From php you can only get an inaccurate IP location lookup.
&gt; while ($r-&gt;name === 'Entry') Ah ok. Put libxml_use_internal_errors() before any Xml call of any kind. I can't remember if you need to pass true or false so try both. One will trigger php errors on an XML parse failure. Doing while(strcasecmp($r-&gt;name, "entry")===0) might be a better comparison too. Maybe also check that readOuterXML() isn't empty because the docs say if it errors, it will return an empty string, not false. (which is typical PHP consistency) 
https://github.com/defuse/php-encryption/blob/master/src/Crypto.php#L388
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [defuse/php-encryption/.../**Crypto.php#L388** (master → 4da32ab)](https://github.com/defuse/php-encryption/blob/4da32ab19b3211594fdde5fc856a24340ea85aef/src/Crypto.php#L388) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnaytta.)^.
Why would it be inaccurate from PHP? 
I'll prepare some for 2018 for you to swear on.
😂
I can see how aiming to attract stars could become a source of hyper-competitiveness, which our community probably doesn't need, but aren't they broadly a good thing? If there's a long-standing library with 10K stars, then it's a reasonably good bet it's safer to use that something uploaded last week, featuring three stars. 
There's only so much you can figure out from the IP. Generally just the location of the provider. The geolocation API can use GPS hardware if available.
They aren't much better than the ones from 2005
What do you use for integration testing? Do you actually use fuzz/random testing with some library like https://github.com/ksamborski/phpintegration ?
What is the difference between browse and read? Browse is more of a search while read is the display?
And I'm going to disagree again. You want a framework here. Are you just going to have index.php and family.php in the urls? What is this 2004? Do you want 404 pages to automatically redirect to a certain page? Do you want your pages to have the correct HTTP headers and response format? There's so many benefits a framework would have and if you just spent 5 seconds pulling it in, it's going to save you time in the long run. No configuring Apache/Nginx to have cleaner urls. No switch statement to say this page isn't a real one and throw a 404. But if you want to have just a sloppy site that you don't care about AND took you longer to build, go ahead and don't use one in this situation. -- Also just assume I downvoted you, not someone else that also upvoted my other posts.
It's not a bad lib to use, but if you're able to load in libsodium, [you can use halite instead](https://github.com/paragonie/halite). It depends on what your encryption use-case is, mind.
&gt; Joomla! is one of the most popular content management systems in the World Wide Web. It powers about 3.3% of all websites Well that "most popular" claim put's WordPress' usage stats into perspective; WordPress runs [28.7%](https://w3techs.com/technologies/details/cm-wordpress/all/all) to Joomla's [3.3%](https://w3techs.com/technologies/details/cm-joomla/all/all).
If you're looking for a similar arrangement, October CMS is built on Laravel. https://octobercms.com/
1) best practice made easy 2) common standard for multiple developers to work together. In short. when working with a developer for a project, it's easier to ask if he knows a public Framework, than to explain your custom standard php code to him. 
Server side, you can only get the IP of the client. You can trace it back to the nearest gateway of your local ISP, but depending on location, that gateway might serve a larger area. so you might only get the area or town, but nothing more. Client-side, you have a lot more options to figure out your own coordinates. Looking at the data in OP, there is a confidence value in the location, so it's quite likely that they use several different methods of geo-location, with varying degrees of trustworthyness, trying to get as close as possible. "100%" reliability suggests that they used local GPS data or geo-location through available WLAN networks. Both only possible client-side. 
I can give you a tl;dr on all those architectures: - Layered architecture: where your architecture is made of horizontal layers, like a cake. - N-tier architecture: like Layered architecture, but you draw the tiers kind of more vertically in the picture. - Onion architecture: like Layered architecture, but the layers are kind of bent around in circles in the picture. - Hexagonal architecture: like Onion architecture, but the layers have sharp edges (be careful!) in the picture. Next time I'll discuss how to draw MVC, MVP, EBI, PAC, ADR, MVVM, MMVC, HMVC, Flux and Redux so they look slightly different, as well.
I would rather use something sodium/nacl-based so I don't have to worry about making the wrong choices.
Remember viennetta architecture from back in the 90's?
Using Joomla in an enterprise setting in 2017 is bonkers. LDAP outside the enterprise is very rare.
It's the best option if you don't have libsodium available.
The idea is simple: PHP doesn't have everything you need out of the box, so frameworks aim for a better out-of-the-box experience for typical apps. The problem is that anything that calls itself a "framework" tends to suffer from rampant, uncontrolled scope-creep, and this affects both Laravel and Symfony. This leads to: - The framework intentionally or often accidentally restricting what you can do by being "opinionated". - The framework trying to wrap every native PHP API into objects and custom functions, while providing little additional value for the extra bloat. - The framework trying to make architectural choices for you in a way that's counter-productive for your specific needs. - The framework becoming a big monolithic dependency for your app you can't remove, so when it dies, your app dies too. Some parts of an app warrant a framework. Some don't, and are best resolved with choice selection of libraries and independent components. How to choose is a very long conversation and depends on your specific skills and needs.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
http://standards.iso.org/ittf/PubliclyAvailableStandards/index.html There are tons of Standards. Pick the ones relevant to your domain.
On the downside, Joomla site ops are probably no longer site ops, and the new site ops are in Russia or North Korea.
Very nice article, thank you.
This article perfectly illustrates my experience as well. Thanks!
&gt; by exposing class a methods of a string like every other modern language from C++ std::string to Javascript. Ok, let's say you need to add new method to work with array. What's your actions? Will you advice to introduce monkey-patching in PHP? Or we will came up with something like this: myCustomFunction("MyString"-&gt;toUpperCase()-&gt;reverse())-&gt;map($multiply)-&gt;reduce($sum); There is no real value in making primitives to have class. 
dipping into node/angular as well...what tools are comparable to xdebug for debugging? 
Node.js handles natively the debugging. With the flag "--inspect", you will be able to debug your application in Chrome or your favorite editor (works at least for WebStorm, Atom &amp; VsCode). Here are some useful links: * https://code.visualstudio.com/docs/nodejs/nodejs-debugging Debugging Node.js with VsCode * https://nodejs.org/en/docs/inspector/ Node.js debugging setup doc * https://blog.risingstack.com/how-to-debug-nodej-js-with-the-best-tools-available/ Nice blog article that covers this topic
The example you gave would be perfectly valid, and such mechanisms are already used extensively, just not with native types (at least in PHP). To do otherwise would suggest extending quasi "class String" which, due to being primitive, would be considered both final (and immutable).
I was surprised how far Sequelize is lagging behind Doctrine in some regards. In particular, essentially zero support for auto generating of migrations or even diffing the current state of the database with schema definitions. Does anyone have a solution for this?
Saved! Nice article. +1
I'll one up both of you: Moodle. Anyone who's tried to develop for/with that software probably just started crying when they read the name.
As far as I know, there isn't a feature to generate a migration from an existing database definition. Still, https://github.com/sequelize/cli provide some help to generate the migrations when you create your new models. Updates of existing models would still need to be done by hand. I rarely used the Doctrine migration auto-generation as it doesn't handles advanced proprietary features, like Postgresql Full Text Search definitions or exotic types of fields and indexes. Yet I understand the appeal when you want to go fast. Migrations in Sequelize don't have to be written in SQL. You can also write them in JavaScript, that's what we dit. It's pretty quick to do (See http://docs.sequelizejs.com/manual/tutorial/migrations.html). Anyway, you should suggest this feature on the Sequelize-cli repository, I would gladly upvote it!
Thank you! Don't hesitate to ask me anything related to it :) I'm the author of the article.
That's a great article! Thanks for sharing
I'll be sure to find the folks who wrote the plugin in 2008 and chastise them. In all seriousness though, there hasn't been an audit of the Joomla code base as long as I've been around the project, and with something as large as Joomla there are bound to be gems like this still in the code base. Doesn't make it right, but there aren't going to be many 12 year old &amp; 300,000 LOC projects which are "perfect" as it relates to security.
Great write-up. Has your team done any performance comparisons? Also, are you using Node to serve static content, or do you still run Nginx in front of it for that purpose?
well it depends, I made my own libraries and frameworks to save time… you can make your own or use someone else’s like laravel and stuff
We looked into doing a virtual home school for one of my kids and my wife mentioned something about Moodle. I had to confirm she said Moodle and then gave my vote against it. After additional research and looking into that home school program we eventually decided against it. 
Did you write it?
&gt; Maybe multiple developers were involved and the guy writing one part of it assumed the guy writing the other part would do the sanitizing. Or something like that. There's no such thing as "sanitizing" in the context of accepting user input. When the LDAP plugin is building an LDAP query it should have properly *interpolated* the value into the query as a *literal*. This is a process of *encoding literals* not *sanitizing* and the responsibility for LDAP encoding input is squarely on the shoulders of the code building the LDAP query. The general purpose login code outside the LDAP plugin can't possibly know what LDAP deems a "string literal" vs. "a command".
I helped develop the custom implementation of Moodle for one of those homeschool programs. It was the worst experience of my 12+ years in development.
Why are you asking for pain points? Shouldn't you rather ask what makes it awesome to use? Usually you select a specific framework or library because of why you want to use it. Ask yourself what you need and then find out which one can provide this the best way. Bottom line: Chose and use what works for you, not what not works for you. If you want rapid development, quick and fast development of your website with the possibility to always add-on to it easily, then it can sure be the top choice here. PS: I still think you are asking the wrong question(s).
I've been completely spoiled by Doctrine. Being able to quickly sync to the DB with `orm:schema-tool:update` during dev and then easily generate migrations later is a godsend. The more time I spend in the Node world, the more I think I'm just going to build my databases and migrations in PHP/Doctrine.
Yes.
I suspect within the next 2 years you will see the rise of Async Php Web servers... React-Http is very promising. At that point I don't see why I would ever want to use JS over say something like PHP 7.2.
The "sync" method from Sequelize is already able to transform a model to SQL commands (see http://sequelize.readthedocs.io/en/latest/api/sequelize/#sync), sadly it's only creating missing tables. Maybe we are not that far from an option to sync the fields if needed. A good idea for another side project :)
Thanks! What did you find cool in the article?
&gt;At that point I don't see why I would ever want to use JS over say something like PHP 7.2. Is there a general purpose library for PHP that's as nice as lodash? Lodash is the only thing I miss from JavaScript.
Putting aside the differences between the languages, I think there are at least two reasons for full stack developers to make the switch: You don't have to context switch all day and you can share knowledge between the frontend and the backend. For example: having to remember different date format or the endless methods to manipulate strings.
Really? I think most of the lodash functions are already core in PHP, I use lodash mostly for non-existing native JavaScript functions. The PHP syntax is a pain tho (order of parameters, variable scope, verbosity): array_filter($array, function ($x) { return array_map(function ($y) use ($somethingElse) { return $y * $somethingElse; }, $x)); }); Which lodash method do you miss? If it's collections, I use Laravel Collections, but there are framework agnostic libraries like Knapsack too: https://dusankasan.github.io/Knapsack/ $collection-&gt;filter($function)-&gt;map($function2); 
&gt; Has your team done any performance comparisons? Yes, we did. Here is one of our test: https://github.com/baptistemanson/node-php-bench. We measured that Node.js was faster for most our use-cases. You can find a wide variety of articles online that will give you a better overview. http://www.hostingadvice.com/blog/comparing-node-js-vs-php-performance/ for example. Since PHP7, I feel both languages performances are not hurting the day-to-day development. When your app starts to be slow, it's either bad code or an infrastructure problem. You need to either improve your database queries or start using load balancers, CDN, etc... &gt; Also, are you using Node to serve static content: Yes, we do not use Nginx anymore. It's not really useful outside of the local environment as we put a CDN in front of most our applications.
Thank you for reading it! Which was your favorite part?
With all the respect, I would not bet a lot on async taking over the PHP world. there are a few problems: * PHP is most used because it's easy to deploy, it's ubiquity, and most people are unlikely to install alternative servers and process managers * Most people who really needed this already moved on to other languages * Ecosystem - you don't have tons of async, non-blocking libraries and you can't search specifically for this * Native PHP async/await, just like Hacklang's, would change the game here but I don't see the PHP internals even proposing this, let alone implementing this in the next 2 years I hope I'm wrong
me too, but I'm excited for typeorm for node (and browser). I'm not sure if it will ever catch up to doctrine though.
I found great comfort in not having to context switch between front and back. I also see way more innovations these days in JS. It is just refreshing. When PHP will get async, Node will probably already somewhere else, with webassembly, reasonml or others.
Oh, wow! I had no idea (and hadn’t thought to look) Node had proper debugging. 
&gt; Native PHP async/await, just like Hacklang's, would change the game here but I don't see the PHP internals even proposing this, let alone implementing this in the next 2 years The thing is, PHP and JavaScript are evolving pretty fast. PHP7 would have been released earlier if they did not try to include Unicode with PHP6. Let's hope for the best!
Nice one! I will check it asap. Thanks!
You have memory inspection, CPU profiling. Everything you have in the Chrome inspector basically (it launches an instance of chrome inspector). You also have integrations with IDE to drop breakpoints...
I made you some screenshots of what it looks like on one of my current project: https://imgur.com/gallery/kV6ai
[removed]
Does WebStorm just launch the browser, or have its own integrated debugger?
Who would have thought
It can do both.
I know right? He is the author AND he wrote it. Crazy. 
Take a look at https://github.com/tightenco/collect for using collections outside of Laravel!
Is it really a burden to know and work with multiple languages on a daily basis? I regularly work with PHP, Javascript, shell scripting and Python, and I dabble in Lua and Go in my personal time. I feel like maintaining an active understanding of multiple languages makes me a better developer in all of them.
Come on, suggesting express as alternative to symfony/zend? It's so, so barebones. Even Slim has bigger feature set.
Did you not find any help, knowledge online? Usually after X time, less than a day, I google and read. Then am able to get back going. If you're working with developers, ask them for ideas. You have the internet and colleagues to pick from. For now, you should break it down with your boss incase he needs to assign/offer help on this current task. For the future, communicate, and get out of that zone you're in now. It's not healthy to bottle things up.
Don't forget SQL.
 I guess I've never seen much 'sharing' between front-end and back-end people. The front-end folks who do JS that I know are all into browser stuff, CSS, dom manipulation, etc. The back-end folks who do JS I know are still largely around data manipulation. Maybe I'm just not seeing the right projects where this 'back and front sharing' thing makes a noticeable impact. &gt; For example: having to remember different date format or the endless methods to manipulate strings. Dare I say that's where IDEs come in handy? The time I'd save not having to look up date format syntax occasionally is lost whenever I need to 'npm install' something which ends up taking several minutes, in multiple environments. (or 'composer install', or 'maven install', etc).
Have you ever seen [laravel-debugbar](https://github.com/barryvdh/laravel-debugbar)? This will do what your package does + a whole lot more. 
[removed]
You make it sound so easy: "Just generate an Api and we're done". What about securing it? And do you really need just CRUD?
You're right on that part. I was utilizing php-fpm so the quide was the same! Thank you for the quick help!
We just need to get PHP in the browser, then we're good to go. 
Great article! Is there any reason you didn't go to typescript? 
Typescript is also a good choice. As we wanted to add type-hinting on a project already started it felt easier to use Flow. We also got a lot of good feedback on it in recent meetups.
We secured our endpoints using the hooks provided by Sequelize and Epilogue. &gt; And do you really need just CRUD? No, we also implemented custom RPC calls with Express. Those actions are mostly complex SQL/Elasticsearch queries. The JavaScript code is really similar to the PHP one with the help of async/await. 
He said it is not equivalent, but it was good enough for him. But your needs may be different. The Express galaxy is made of thousands of small stars.
But what about mutating data?
&gt; I know the have a study guide, it's fairly cheap too, but is it worth buying? No. And neither is the certification. &gt; Do you guys recommend any learning resources in particular? Besides the PHP Manual. I would recommend real-world experience over any reading material any day. But if you want some practical things to look over, I would recommend [PHP the Right Way](http://www.phptherightway.com/) and familiarizing yourself with [Design Patterns](http://designpatternsphp.readthedocs.io/en/latest/) and knowing when to use them. &gt; I know they cover A LOT of the material in the test, can I get away without intimately knowing every aspect of the language? Quite frankly, you can get away with NOT taking the test and still having a lucrative career in web / application development. At no point in my career have I ever heard a recruiter or employer ever ask a candidate if they're certified in anything PHP-related, let alone Zend Certified. Employers care more about the code you can produce and what it means for their bottom line. With that in mind, your certifications mean exactly jack shit. **tl; dr; Save your money and put it towards something with tangible benefits, or at the very least something tangible.**
As a prior Node/Angular developer, I actually didn't like js on the backend (although I really like Node) for the simple fact that backend js is different from frontend js, and I felt that I needed context switching, but found myself using Angular in Node and Node in Angular. I actually prefer two different languages.
As a prior Node/Angular developer, I actually didn't like js on the backend (although I really like Node) for the simple fact that backend js is different from frontend js, and I felt that I needed context switching, but found myself using Angular in Node and Node in Angular. I actually prefer two different languages.
To pay devil's advocate, that's a lot of cerebral baggage you have to carry around to get the job done. A single language stack is arguably easier and requires less overhead. 
ZCE here. The certification is worth it if for no other reason than the studying you'll do in order to pass. That said, it has had zero (meaningful) impact on job prospects. Having my name and email listed in the ZCE directory only resulted in numerous offers from braindead recruiters offering temporary 1099 work at shitty rates. Hiring managers for full-time jobs might take notice of the ZCE but it certainly won't make or break your resume. Showing skills and experience matter far more. IOW get the cert if you want it but don't put too much faith in it.
Came here to say this. Saying Express is like Zend is like saying a speed boat is like an oil tanker because they both travel on water. As yet there is no Node alternative to Zend/Symfony/Laravel. If a microframework is the best choice for a project then Node is ok. But there is a valid use case for large and full featured frameworks. 
In my experience almost all Node analogues to popular PHP libraries are lacking in features and maturity. 
I find having the context switch is a benefit. There is a context shift anyway between front end and back end development.If anything Nodejs development confuses things. There have been times I've had to remind myself "Oh shit this is server side isn't it". I don't think we should be afraid of polyglot projects. As a developer I tend to enjoy them more.
Sometimes you have to pick the best language for the job. We have a lot of PHP systems, but it's not the best for aggregation with Hive/Hadoop. It has longer response times for some critical frontend systems, so we had to use Go. It is also much slower for some ETL pipelines, so they needed to be written in Go/Java. There are places for PHP, but you should also pick the right language for the job and the scale. Learning another language is never a bad thing.
He still needs to learn how to bake bread and slice it. There are a lot of steps inbetween.
Why did you waste your time writing this when the OP says he wants to take the test? There is nothing wrong with getting experience and getting the certification because it shows that he was willing to put in the time to pass an exam. Just because YOU think its worthless doesn't mean everyone else does. I have been developing on PHP for almost 10 years and also planning on getting the cert at some point. Its another bullet point on your resume along with experience, a degree, and among other things.
There are a couple books on https://www.safaribooksonline.com that aim to pass the Zend PHP Certification but it all boils down to knowing PHP. https://www.safaribooksonline.com/library/view/zend-php-5/9781940111148/ this book I read through when I was going to take the test and it seem to be the most thorough. The study guide that you can buy from the Zend website is not terrible but is very condensed and more geared towards quick information and not a thorough understanding of the material. As far as study questions you are limited on that and will have to scour the internet for random PHP questions because there are no practice exams to my knowledge besides www.ucertify.com which is going to cost you to $200 for their course. I did actually purchase this course and it was very well written if you want to throw down the money. I didnt actually take the test because I stupidly thought it was 1 week later than it was so i was a no show. Then they wouldnt let me take it again without paying for it so I never did. I actually plan on taking it again sometime down though.
If it is good for you, just do it the way you like! Everybody has a different way to think, to build, a different experience. It's always good to share :). Thank you for that.
Oh, do tell me about these "other things". I'll wait. In the meantime, it won't change the fact that the certification does exactly jack shit for one's employment opportunities. The only thing the Zend Certification does is tell others that you're certified in taking the Zend Certification. It doesn't mean you can write maintainable code. It doesn't mean you can solve client needs in a timely fashion. And it doesn't mean you can architect the proper solution based on those needs. But yeah, go on and tell me more about how a certification is going to make prospective employers think twice. Meanwhile, some kid is out X number of dollars for.... what was it again? A bullet point in the resume? As opposed to.... you know....... a free Github account that shows practical real-world examples that senior developers can go through and verify? If you've been "developing in PHP for 10 years" and still think that the Zend Certification is something even remotely close to impressive, then I'm pretty sure you might want to reevaluate who's wasting their time.
Ah, of course. I was only thinking of IP geo-location.
Thanks, noted for full async applications. Yeah, I didn't think there would be a shot at using Doctrine in an asynchronous way but wanted to be on the look out if there was any literature of such a possibility I missed. We are looking for a solution that might not block a process while it's querying during a more intensive job, but Doctrine will definitely still be used for lighter processes that don't need async just because implementation is simple.
&gt; https://www.reddit.com/r/PHP/comments/70qere/any_good_reactphp_or_amphp_examples_with_doctrine/dn5qhzc/ Awesome example for mysql straight from amphp, and if my project was using mysql or postgresql, I would jump onto this immediately to trial as a possible solution
Yes, thanks for the clarification. I aiming to do the former: nonblocking, idle-waiting-avoiding network I/O, not parallelism. I'd figure a heavier job would be more efficient if it could query send more queries to the database while it's waiting for responses for past queries.
Loopback is pretty sweet if you want an all integrated solution! http://loopback.io/
&gt; it won't change the fact that the certification does exactly jack shit for one's employment opportunities I disagree. I know a handful of people that have received job offers directly from the Zend yellow pages. 
The good thing about only have one nerf is you don't need to herd it.
What about Adonis? (http://adonisjs.com/) It mirrors Laravel features.
Yes, the age old question everybody asks.. wow
Can you provide code examples as well?
It is better to set it to the minimal required instead of a 4x change, because you also reduce your serving capacity by this amount. So for example if I run a 1GB VPS and I set it to 256MB, with a nice infinite loop in the code one would only need 4 requests in parallel to crush the server - that is doable easily from a single browser even. If you hit a memory limit it is better to investigate the issue and solve the underlying problem. Specifically with PHP, if you are still using version 5, should change to a hosting provider that has version 7, as it reduces memory consumption significantly - not to mention it will be faster as well.
http://sailsjs.com is close to Laravel from what I've heard.
Don't use Wordpress is usually my go to solution. 
And HTML! Okay I'll go...
I guess it’s a matter of personal preference and job opportunities around them. Maybe they would like to work in a place where managers look at those kind of things — then it may be useful. But I guess if they can’t figure out this on their own, they are better left with your advice (to skip it entirely). In my 10+ experience on the job market, I don’t think I was ever even asked about my education… Maybe once, as a part of a small talk… ;)
OP is a bot
&gt; A rose by any other name would smell as sweet
Most likely, yes.
Middlewares will now be called Intermediate processing units.
Have you checked out nikic/php-parser? https://github.com/nikic/PHP-Parser/blob/master/doc/4_Code_generation.markdown
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [nikic/PHP-Parser/.../**4_Code_generation.markdown** (master → 4f8f773)](https://github.com/nikic/PHP-Parser/blob/4f8f773b9fa96b1b726d04a358d4a6748c1d54de/doc/4_Code_generation.markdown) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnck5t0.)^.
This ADR scheme was promoted by pmjones, and I've been using it for a year with Slim framework. It's very cool.
&gt; A request handler is basically a controller, but limited to one single action. So "goodbye controllers", yet it's "basically a controller"? Anyway, I understand we need to keep the hype going, but sometimes it's convenient to handle more than one action per request handler, so I propose the following new ***Hyper Cool*** Architectural Patterns: - Request handler: one action. - Request dichotomy: two actions. - Ternary request: three actions. - Request quarters: four actions. - Request quintuples: five actions. - Request confusion: six or more actions. Goodbye controllers, hello confusion!
It was doomed to happen sooner or later: humanity would invent every single thing that could be invented, and the only way people could claim fame for themselves is by taking something that exists, and renaming it.
I agree it's a bit of an overstatement, just trying to get the people's attention :)
A controller is actually the method of the class we call "controller", the "controller class" is actually simply a misuse of the word. But honestly that's a detail IMO. So TL/DR: you can write single-method controllers (or "controllers as callables"), sometimes it's better. But I disagree that it needs a different name, and that it's always better. Sometimes grouping very similar methods makes sense instead of having 5 separate but almost identical classes. In other words, be pragmatic.
The word you're looking for is "clickbait".
I agree. Updated the conclusion a bit. Thanks for the feedback!
Your problem [is here between lines 90 and 111](https://github.com/drupol/memoize/blob/master/src/MemoizeTrait.php#L90-L111). You have deep recursion (possibly endless recursion, BTW), you have serialization, you have SHA1 hashing, and this is happening not only when you memoize a value the first time, but also every single time a value is to be fetched from the memoization cache. In many cases your hashing function is going to waste more CPU and RAM than not memoizing at all. This is why memoizing for arbitrary arguments is often not pragmatic, compared to a specialized solution. Also parts of your hashing functions are outright incorrect, i.e. you assume spl_object_hash() hashes the object contents it seems. It doesn't. It's basically the object identifier, which doesn't change even as an object changes, which means you'll be returning the wrong memoized results when an object changes.
Or simply "premature excitement" for something actually not that exciting? We don't need to bash them too much, this is not a company trying to sell anything, just some developer that wanted to share an idea they just had.
&gt; This is why memoizing for arbitrary arguments is often not pragmatic, compared to a specialized solution. Totally agree with this (and other points of the reply above). I recently had to do something similar, and I simply exposed an option for the caller to give a unique key to cache the values for. This unique key can easily be the entity type and the entity ID/UUID. 
I would change the interface to: protected function memoize(\Closure $func, $key) 1. Not exposing it in the public interface 2. Shifting the responsibility of your `hash` method to the caller I would also remove the cache backend entirely, and only use in-memory storage. Cache is cache, I think you can always do it explicitly. YMMV. Your implementation cannot memoize `null` values (for example after looking something up in the DB)
The company I work for pays for it, so it's no loss on my part. As for the certification itself, worst case scenario I add another something to my CV, it doesn't hurt.
Basically the problem you also had....which frameworks to use? There are so many to choose from. Sounds fun to use node instead of php/symfony.
Thanks for your comment, I will look into the issue with spl_object_hash() and see how I could generate a proper hash is one is not provided. Do you know a better solution ? use an external package to do it ? Thanks!
I will implement this very soon, as soon as I found the solution to provide a valid hash :-)
Hello, 1) Could you let me know why you would not expose it ? I do not see what could be the reason for that yet. 2) I will implement an update that will fix this very soon, as soon as I found how to generate a proper hash. Thanks for your feedback! 
As I'm involved in recruitment myself (reviewed at least 500 CVs), I can tell you that ZC won't do you much. The reason for that is it only proves that you have read the php.net docs. That's a good thing although, but won't get you a job. If you want a job, you really need experience with: * PHP5 and 7 as well - obvious I guess, I'm not sure if ZC is covering this, like differences, new features in every version etc. * composer usage - so we know that you are familiar with libraries, know what they are, why it is good to have a modular system * multiple frameworks - so we know that you are probably familiar with design patterns and have seen different systems, multiple solutions for the same thing * multiple databases: relational (MySQL, MSSQL, Postgres) and key-value stores/nosql (memcached, Redis, mongo, Cassandra) - so we know you probably know the differences and can decide which one to use by pros/cons * testing: unit, integration, acceptance with phpunit, codeception, behat - so we know you probably able to produce high quality code * continuous integration - so we know you are used to pay attention to quality and catch errors before it gets out * deployment - so we know you are probably familiar with how to deal with configuration in different environment, in better case how to do zero-downtime deployment * web servers, docker, networking etc. I'm usually recruiting for senior, there is no way you will pass without the first 5; for specialist/middle level first 4 with single database and framework, and at least phpunit; anything less than that is junior level. I don't say you shouldn't take the exam, if it makes you feel better and are capable of memorizing function signatures, then it will be useful while working, but won't get you a job - other then from the already mentioned brainless or laic people.
I'll take a look, thanks!
&gt; For me, if the code is out of the current ‘style guide’ (I like to use PSR-2, or at least have a company-wide documented style-guide), I’ll re-style the code [...] &gt; Once re-styled, you generally have a better understanding of the logic [...] What?
How do you load balance your multiple pm2 processes? You do use multi-core processors, right?
Because it’s an implementation detail. You want your objects to have their business logic exposed. For example, given a `UserFetcher`: public function fetchUser($id); So you use it in a normal way: $userFetcher-&gt;fetchUser(10); There is no need for you calling this internal method: $userFetcher-&gt;memoize(function() { …??? }, …);
&gt;It's released under the GPLv3 license. Commercial licenses are available from Paragon Initiative Enterprises if you wish to implement Halite in an application without making your source code available under a GPL-compatible license. Well, that disqualifies it from pretty much all the projects I've been working on.
And CSS!
would `hash` + [implementing JsonSerializable](https://secure.php.net/manual/en/class.jsonserializable.php) be better here instead of serialize + sha1 ? i.e. `return hash($algo, json_encode($this));` ?
If I have to be honest about what's better here, it's not to try and hash random arguments at all.
Objects can be directly serialized, and they can control the process via the __wakeup and __sleep methods (or the Serializable interface if they implement it). You don't need any package for it. But the bigger problems remain: 1. Potential circular references cause endless recursion. 2. All of this is too slow and resource intensive and defeats the purpose of memoization, which is to save resources.
That's fine. Just use libsodium (or PHP 7.2), and use the [cheat sheet](https://dev.to/paragonie/libsodium-quick-reference) for the right function(s) to call for the right usage.
Have been following this project since a seeing a talk at Symfony Live like 3 years ago. So far it's really good. My only core issue is with there could be more docs on the contexts created for behat so it's easier to implement your own tests when developing modules. When working with the beta i found the majority of JavaScript tests broken.
Does this look like it'll do the trick, for you? https://preprocess.io/#class-accessors
I can see where you're coming from here; I should have given more context. For me, when I restyle code to conform to a styling guide, I like to read the code, as often it's broken out into logical chunks. In doing that, I'll naturally pick up the concepts and thought process(es) that went into the initial build. Since I've now got a deeper understanding of the code, and it fits the style guide - a refactor might be more a more appropriate. I'll be sure to be more informative in the future; thanks.
Use this: http://symfony.com/doc/current/bundles/SensioGeneratorBundle/commands/generate_doctrine_crud.html
Clockwork too. I always feel compelled to mention it since I've had a better overall experience with it and I'm not sure if people are aware of it.
It has some extras in there but you could just include `illuminate/support` instead of using a fork.
Fair enough. If the company is paying for it, then I would probably say to go for it. Like you said, as a worst case, it's just an item that sits on your resume. I just wouldn't put any of my own money into something like this. A quick search for some free study guides yields [this result](http://index-of.es/PHP/Zend%20PHP%20Certification%20Practice%20Test%20Book.pdf). Seems pretty dated, though. Outside of that, I would probably just brush up on a lot of the basics on [CodeCademy](https://www.codecademy.com/) and [Codefights](https://codefights.com/). Best of luck to you.
Are you excited to need a full rewrite when flow script inevitably goes the way of coffeescript?
I have been switching in and out of PHP and JS applications and have to agree Express is not comparable. For anyone who is looking give adonisjs a try. Anyone who has experience with Laravel will be right at home with this framework. It makes using JS bearable. http://adonisjs.com 
&gt; you can share knowledge between the frontend and the backend Say you're using the same language for front- and backend development. Communication between browser and server would still run over HTTP or sockets, meaning data has to be serialised and deserialised. Can you give a concrete example of sharing the same language front- and backend would be beneficial in this area? 
This is a very good book going in-depth on API architectures. It's not that simple :). https://apisyouwonthate.com/
I'm not familiar with filters, but given their name it sounds like they're one way. Filters data on the way in and filters data on the way out. Middleware can manipulate data on the way in and out. Maybe that's what' filters do, maybe it's not. But given the name, filter, it sounds like it's either on one end but not both.
I'm not sure why you are so pissed I was merely asking why would you discourage someone from taking a certification they said they wanted to take. How about just not putting your two cents in because it wasn't helpful to the discussion. A certification is simply something that if the OP wanted to get he would be forced to learn the fundamentals of PHP, the quirks, and many other things that at the end of the day will help him. Did he ask whether or not the certification was worth it? Did he ask if he would get a job by getting the certification? How do you assume he's a kid? For all we know he has years of experience in PHP and wants the cert for his own benefit. I want to get the certification which is not expensive at all for my own gratification, not for employment, and if you are worried about it breaking the bank then you must not being doing much right in life. At this point you are not even making any sense and on a war path against a cert. Go take a deep breath and troll somewhere else.
&gt; Is it really a burden to know and work with multiple languages on a daily basis? Yes. At work I have things written in Perl, Python, Bash, PHP, JavaScript, C#, SKILL(Lisp dialect), and some other random things. When jumping between languages I'll sometimes have to pause and think about how to do a specific task in a language(e.g. find a sub string. `substr()`?, `myString.find()`?, `myString.indexOf()`?, `[[ "$MYSTR" == *"SUBSTR"* ]]`?, `some lisp stuff that I don't remember`?). It may only take me a second or two to remember, or my IDE might assist me pretty quickly, but in the end it's mental overhead.
I think we are missing the point here is that he never asked whether or not its going to get him a job. He wants to take it. Why is everyone assuming that he wants to take a certification strictly for employment? If you had someone with the exact same experience you as a mid or entry level developer, you don't think they would take into account he had a certification?
Hey! - First we have to remember that node natively put any IOs in threads, giving you multithread capability from the get go. so if your app is usually IO-bound, meaning the db for instance is what takes time, there is pretty decent chances you won't need several node processes. - Now if your system has HEAVY node CPU processing, the command "pm2 start app.js -i 4" will launch a load balancer and 4 processes behind.
There is only one command to type to remove flowtype from your project. It is presented in the quickstart of flow with babel. Just put the same output file as the input file. Google is your friend. You probably didn't onboard jsx either for the same reason. We rewrite software every 6-7 years, and we know flowtype will be supported by then. We are just more productive and have a clear adoption and ejection paths. Being sarcastic requires skill and knowledge my dear.
No no no. PHP 7 came out because HackLang existed and was eating their lunch.
Thanks for the bullets. I've been using PHP for over a year and am now learning frameworks but I hate learning how to use stuff like that (and, for example, jQuery) without knowing what it's doing and how to do it myself. Your list gives me a list of things to dig into. 
In defense of coming here before or after using Google: First, for this specific question, I know OP could find answers using Google but, personally, I don't know any other programmers so I like coming here (any programming subreddit) and getting practical, up-to-date, advice from people who use this daily -- not the numbskull that wrote a terrible tute or a salesman. Seriously, ease up on people who aren't as experienced and knowledgeable as you. Second, OP did say "ELI5." I think we should reward humility and hunger, not crap on it.
Thanks for those sites. PHP the Right Way is one of the most beautiful sites I've ever seen. My heart fills with hope for humanity when sites are organized and easy to navigate. 
Why do you pull the signing key over http?
If you just want to generate getters and setters, Phpstorm will do that for you. 
&gt; Onion architecture: like Layered architecture, but the layers are kind of bent around in circles in the picture We've come full circle
index and show / all and one 
Was hoping you'd go into more detail regarding performance, etc ... Interesting none the less.
Off topic, but curious... I noticed it looks like you're using some stock photos here. Do you reckon its worth paying for them for these types of blogs/articles? Any other tips related to images/blogs etc? My Dad is looking to getting into some blogging for his business (not tech) - and we were talking about putting images in - so just got me wondering.
I copied the URL from the documentation https://unit.nginx.org/docs-installation.html
there are a lot of places to get free stock images. https://www.reddit.com/r/web_design/search?q=free+stock+images&amp;restrict_sr=on&amp;sort=relevance&amp;t=all
It's a great way to get your hands dirty with the code before making substantive changes to it. Legacy code also tends to be spaghetti, so any improvement in readability is a big win. During this initial style pass, I've discovered so many blocks of code that simply did nothing and could be removed.
Indeed, totally up to you! I usually go that route but some may simply want _just_ the Collection. Tightenco works closely with Taylor/Laravel so I trust the fork to stay maintained :)
Haha, that's the first thing I noticed too.
It was a light hearted poke at the JavaScript ecosystem, not an attack on your choice to adopt it. Get over yourself.
You may be receiving an Error object and not an Exception. https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/ catching Throwable would catch both Exceptions and Errors. 
I didn't have much time to check performance stuff, and honestly, that's not my strong suit (without using NewRelic or Blackfire). I ran a quick ab test with opcache, cache config, and an optimized composer autoloader: ab -t 10 -c 10 http://127.0.0.1:8300/ This is ApacheBench, Version 2.3 &lt;$Revision: 1757674 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking 127.0.0.1 (be patient) Finished 1959 requests Server Software: unit/0.1 Server Hostname: 127.0.0.1 Server Port: 8300 Document Path: / Document Length: 2321 bytes Concurrency Level: 10 Time taken for tests: 10.051 seconds Complete requests: 1959 Failed requests: 0 Total transferred: 6408027 bytes HTML transferred: 4546839 bytes Requests per second: 194.91 [#/sec] (mean) Time per request: 51.306 [ms] (mean) Time per request: 5.131 [ms] (mean, across all concurrent requests) Transfer rate: 622.62 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 6 51 22.1 41 148 Waiting: 5 50 22.1 41 148 Total: 6 51 22.1 41 148 Percentage of the requests served within a certain time (ms) 50% 41 66% 44 75% 48 80% 72 90% 89 95% 98 98% 108 99% 117 100% 148 (longest request)
I can't say why without digging into it.. but I suppose it depends on the context in which each is used. I have never had an issue with this personally.. but catching Throwable seems to be the better option than catching Exception. 
Debug component is much more sophisticated to log and report all kinds of errors but take look at this simple example (php 7.1.x): &lt;?php class MyUncatchableError extends Exception {} function myExceptionHandler($e) { throw new MyUncatchableError('BANG: '.$e-&gt;getMessage()); } set_exception_handler('myExceptionHandler'); $foo = true; try { $foo-&gt;modify(); } catch (Exception $e) { echo 'bleh'; } catch (MyUncatchableError $e) { echo 'bleh2'; } What will be the outcome? Well: &gt; Fatal error: Uncaught MyUncatchableError: BANG: Call to a member function modify() on boolean in /in/WJErU:6 &gt; &gt; Stack trace: &gt; &gt; * 0 [internal function]: myExceptionHandler(Object(Error)) &gt; * 1 {main} &gt; &gt; thrown in /in/WJErU on line 6 and you can't catch that exception because you should catch the original.. throwable here, which is [Error](http://php.net/manual/en/class.error.php) for this kind of "error". You can catch it by catching "Error" class. And with PHP7 hierarchy it implements Throwable, that's why you can't catch it using Exception. And this is true for PHP7+ because with 5.* there was no Throwable nor Error, and doing `$foo-&gt;modify();` would just return a Fatal Error.. You can make your own error handler (set_error_handler) and throw an exception there but.. this method does not work for Fatal Errors. :) Instead Debug component hooks into [script shutdown](https://github.com/symfony/symfony/blob/7974cd74e0410143e1ad8ace605b00869d5f88ca/src/Symfony/Component/Debug/ErrorHandler.php#L116) and reads last error and [throws FatalErrorException](https://github.com/symfony/symfony/blob/7974cd74e0410143e1ad8ace605b00869d5f88ca/src/Symfony/Component/Debug/ErrorHandler.php#L579) This description may not be completely accurate as I have't dug deeply into symfony but you can get the idea here.
Its definitely (TypeORM)[https://github.com/typeorm/typeorm]. Its have near same functionality as doctrine and definitely much more then Sequelize
I've implemented the changes. The cacheId is not customizable, but if it's null, then it will be automatically computed using the hash method.
Setting the memoize method in protected prevent the tests to be working. I've allowed a new parameter cacheId that can be set, and if it's null, it will be automatically computed. Let me know if it's better now. Thanks! 
Pixabay has cc0 license images, that's my go-to
Sorry if I misinterpreted what you wanted to say :). Do you then agree that there is no need to "rewrite" anything if you want to remove flowtype for any reason? 
I recommend reading the official documentation instead of this. This should be a Gist. The snippet A) assumes that you never installed Nginx directly from their repository and B) forces a global system update with the -y flag. Be advised. 
I assumed because it costs money, not a cheap exam, and we pointed out that the knowledge is the key and not the certificate. Personally I wouldn't take it into account, we have a small programming task and a technical interview to pass. If you have 1000 certifications, but you can't pass them, you won't be hired - also we would give chance to both similar candidates as ZC doesn't prove/guarantee anything, same goes for any kind of University diploma (seen people passing IT courses without the capability to write the most basic hello world). In summary: practice over theory, real work experience over papers.
Bad nginx. 
Just the slides without the presentation seem kind of useless for this talk. But I spotted the framework selling JSON-LD for APIs as something "backed by Google" etc. I don't know why people keep confusing JSON-LD APIs with JSON-LD page snippets. Google won't show snippets in search results for your *APIs*. It's for JSON-LD snippets embedded in web pages, I don't think API Platform is about that, is it? The value of adding "more standards" to your APIs is quite questionable in my eyes, what it adds up to is less control: you're exposing some API, you have no idea what you're exposing, it's all automated. This can lead to unintentional information leaks and hard to change APIs as if you enable support for X, Y, Z, you have a vastly increased support and testing surface and opportunity for B.C. breaks as your API evolves.
Interesting. I don't have a solution for you (I see others have already supplied elaborate answers), however, can I ask you "why" you want to catch this exception? It seems you have a syntax problem in your code that needs to be fixed instead.
What's the use-case for your library at all? Have you benchmarked if it improves performance at all, compared to not memoizing?
Rapid development.
r/php is mostly about r/laravel.
&gt; But I spotted the framework selling JSON-LD for APIs as something "backed by Google" etc. I don't know why people keep confusing JSON-LD APIs with JSON-LD page snippets. Google won't show snippets in search results for your APIs. It's for JSON-LD snippets embedded in web pages, I don't think API Platform is about that, is it? An interesting side-effect of using JSON-LD (and Schema.org) API-side is that you can just copy the API output in JS in a &lt;script&gt; tag and Google will be able to extract structured data (slide 54). API Platform clients will soon do that automatically. But JSON-LD at Google is more than just rich snippets, for instance the Google Knowledge Graph API public endpoint is in JSON-LD: https://developers.google.com/knowledge-graph/ &gt; This can lead to unintentional information leaks and hard to change APIs as if you enable support for X, Y, Z, you have a vastly increased support and testing surface and opportunity for B.C. I agree. It's maybe not clear in the slides, but you should not enable all formats just to support "more standards". By default, only JSON-LD is enabled. If you prefer to use GraphQL, JSONAPI, HAL or anything else, the point is that you can do it easily with API Platform. But choose a format, and enable only this one. &gt; Just the slides without the presentation seem kind of useless for this talk. The talk has been recorded, the video should be available soon on YouTube.
&gt; An interesting side-effect of using JSON-LD (and Schema.org) API-side is that you can just copy the API output in JS in a &lt;script&gt; tag and Google will be able to extract structured data (slide 54). API Platform clients will soon do that automatically. Designing your APIs around a few incidental snippets you need in your web pages is a very unfortunate ratio of pros/cons. Instead "copying API output" I might as well have just spend 2 minutes and format the output accordingly for the web site without compromising my API with standards that don't bring value in the API on their own. &gt; But JSON-LD at Google is more than just rich snippets, for instance the Google Knowledge Graph API public endpoint is in JSON-LD: https://developers.google.com/knowledge-graph Sure but this is about Google's APIs using JSON-LD in a few places, not about our JSON-LD APIs being read by Google. There's no connecting use-case to those two situations that I'm aware of. 
Please don't infect your sites with this garbage. Cloudflare should definitely be avoided.
Wait so a test that goes over the fundamentals of PHP and has to be taken in a proctored setting doesn't prove anything? But sending a programming task that someone could find the answer or logic online is so much better? No offense but it doesn't sound like you have taken the exam or any practice exams. To say it doesn't prove anything seems a bit of a stretch considering you have to know php fairly well to pass the exam. That in itself has some credibility behind it. I'm not saying its the end all be all but yes it most certainly has some weight behind it. You are acting as if someone with 0 experience in programming could wonder in and pass the exam. Thats not the case at all.
Why?
They did a great job with this implementation. I'm looking forward to messing around with it.
"Some times" WordPress is overkill and underkill at the same time. Also it's been a while since I looked at Drupal, but it was a pain to things out side of just a CMS. 
the one guide you need to pass ZCE is "Zend PHP 5 Certification Study Guide: A Php[architect] Guide" not only you will pass the exam, you will also know a lot more about PHP after reading this book. "I know they cover A LOT of the material in the test, can I get away without intimately knowing every aspect of the language?" No
This is literally the worst blog post I've ever read 
Looks like it's just someone who gets irrationally wound up when people do things differently to how they do them. Never appears to explain the hate, just goes on hatin'
&gt; I might as well have just spend 2 minutes and format the output accordingly for the web site without compromising my API with standards that don't bring value in the API on their own. No offense here, but it looks like you've no idea of the philosophical, theoretical and technical considerations behind the Linked Data movement and the semantic web. RDF, JSON-LD, Schema.org as well as other open vocabularies are all about interoperability at web scale, global cooperation, knowledge sharing and transparency (see https://okfn.org/opendata/ for a good introduction). They are a the key point to build an open web. If you think that open vocabularies and hypermedia technologies are just a trick for SEO, you definitely miss the point. If you (or your customers) care about those values, you should definitely design your public APIs with that in mind. Even for private APIs (for medium to large companies), it can be really interesting to define common internal vocabularies as OWL or - better - to extend a public one to use it as a common data format for your (micro-)service. It makes data consolidation, interoperability between different languages/stacks/technologies and hot service replacement easier. If it's just about SEO, you don't have to bother with JSON-LD, just add some random microdata to your HTML and your done. You may don't care, but in this case you miss the main reason of using such technologies, and GraphQL is probably a good alternative. If you're in France in November, don't miss the SemWeb.pro conference. It's all about that, and I'll give a talk ("API Platform: semantic web for masses") about how API Platform makes it easy to bring such advanced web technologies to the average web developer by using popular techs such as PHP and JS. &gt; Sure but this is about Google's APIs using JSON-LD in a few places, not about our JSON-LD APIs being read by Google. There's no connecting use-case to those two situations that I'm aware of. You are right than Google doesn't read directly your API (and I never said that). But see my previous paragraph, it's definitely connected ; JSON-LD and Schema.org is the foundation to be able to consolidate data. See what you can do with JSON-LD (and so any API-Platform based API) and Apache Jena (https://jena.apache.org/), it's amazing. 
&gt; No offense here, but it looks like you've no idea of the philosophical, theoretical and technical considerations behind the Linked Data movement and the semantic web. In a discussion about APIs, I'm not a theoretician, I'm not a philosopher, I'm an engineer and I write software. The only thing that matters is means and goals. And a lot of those standards are not a means to any goals, aside from scratching an itch for those feeling romantic about the semantic web. I *am* aware of the *technical considerations*. And they apply *in select cases*, for purposes of interoperability, but often they don't apply. Let me be specific. You need an interoperability standard if two parties must interact without specifically targeting (or knowing about) each other. This is why JSON-LD finds use in Google SERP snippets. I don't want to target just one search engine, and Google doesn't want to target me specifically. So a standard is used. Of course, a lot of it is just smokes and mirrors, because there are *a lot of specifics* in the use of JSON-LD that Google gets to decide, and everyone follows. But you can at least see the use-case for JSON-LD and entities from schema.org being used in this case. And because this specific situation of "I don't target you, you don't target me, but we implicitly interact" often doesn't make sense in a general-purpose API, JSON-LD often doesn't make sense in such an API either. All the clients connecting to you *specifically target you*, and not *some site they don't know about*. All the clients require to perform actions and queries, where at *best* small bits and pieces of the responses can map to schema.org standards for real-world business requirements. So you might as well not. &gt; They are a the key point to build an open web. The web *is* open right now, standards are for interoperability where it makes sense, and in many places it makes no sense. Don't mix up "open" and "interoperable" in the same pot, those are entirely different goals, with entirely different solutions. I can publish an API that doesn't follow any existing standard and still make it open. &gt; If you think that open vocabularies and hypermedia technologies are just a trick for SEO, you definitely miss the point. If you (or your customers) care about those values, you should definitely design your public APIs with that in mind. It's not a "trick", it's interoperability with search engines, and indeed that's so far the most compelling use-case in general. You think I'm missing a compelling use-case that most people will care about? Name it then, I'm curious. Keep in mind that trying to communicate "philosophical values" through APIs is not a meaningful use-case here. What's the goal? Technically there's no purpose to it, unless proven otherwise. Is the goal fitting among peers? Being liked?There are better ways to go about this, than superficially ornamenting your APIs with ill-fitting RFCs and specs for no tangible technical benefit.
So they caved after public pressure. They trust me. Dumb fucks. - Zuck Glad i'm using Vue.js.
What aspects of it? The WAF is fine, and so is the DNS.
Same here. Vue is superior in every way. I guess they felt people were heading towards vue. 
*Same here. Vue is superior* *in every way. I guess they felt* *people were heading towards vue.* ______________________________________________________________________________ ^^^-english_haiku_bot
I want to clarify my use case, as some people commenting seemed a bit misled. I'm working on a library, which allows to generate some classes based on API results. Classes can Ben regenerated at any time, if something in the API changes. Therefore I can't use PHPStorm, SensioGeneratorBundle (it's not a Symfony project), and Pre (I would still need to generate the stub class somehow). I built something using PHP-Parser, and it works, but the only problem is that the output is formatted rather poorly, and there's no way to improve that...
[removed]
Why are you so glad you're using Vue.js? I mean, besides from it being a great lib. Like React. The Vue.js Strike Force is really strong in /r/PHP and I don't quite understand what the problem is, except "omg facebook!".
Please don't infect our threads with this garbage. WhatAboutBergzoid's comments should definitely be avoided.
you should compare it (speed, memory, other?) with an always immutable class to see how much it improves (if it does) and then decide if it's worth it 
I really want to start using their API on a bunch of my sites. But it's insane that there's just a single API key for all features in a whole account. Most of us really just want to do non-dangerous operational stuff like deleting caches via API. Not administrator actions. We shouldn't need to stick API keys on our web servers that can do dangerous stuff like change DNS records. Especially when you have multiple sites in one account. It seems they already did put some separate API key stuff in related to CA certs or something, but it would be much more useful to most people to separate stuff like cache expiry vs admin stuff like changing DNS records. Especially given that most users are using Cloudflare certs... an attacker who finds your one-and-only API key can set their own server as the origin and continue to serve pages with valid SSL to users. It's a huge security risk. If you agree with me, please contact Cloudflare about this, and maybe write a blog something if you're into that. I've tried a couple of times, by I'm only one voice. 
Thing is it gnaws at my mind regardless of technically worth it . :)
Hi r0ck0, I use [https://www.pexels.com/](https://www.pexels.com/) for my images. They have free stuff on there, with a variety of sizes. If they don't have what you're after, Shutterstock is always an option.
That's a big claim to make with no proof 
I haven't heard of a "build pattern". There's a *Builder* pattern, which coincidentally is the exact solution you're describing: it's a mutable write-only set of methods, until you terminate it with a call (typically called build()). So this: $url = (new URL('')) -&gt;withScheme('http') -&gt;withUser('John') -&gt;withPassword('123456') -&gt;withHost('example.com') -&gt;withPort('80') -&gt;withPath('/foo/bar') -&gt;withQuery('baz=qux') -&gt;withFragment('heyooo'); Becomes: $url = Url::builder() -&gt;scheme('http') -&gt;user('John') -&gt;password('123456') -&gt;host('example.com') -&gt;port('80') -&gt;path('/foo/bar') -&gt;query('baz=qux') -&gt;fragment('heyooo') -&gt;build(); Choosing between a builder and "withFoo()" methods should be based on use cases. How often would you need to "tweak" the object long after it's created? If the use cases dictated tweaking long after creation, then "withFoo()" is suitable. But if you just need to build it once and then keep it locked mostly, the builder is excellent. Note that the builder still allows tweaking, but it's slightly more verbose, lets make the above $url secure: $urlSecure = Url::builder($url) -&gt;scheme('https') -&gt;build();
[removed]
Like with games, where developers used to do everything but now specialise, webdesign is no longer the "1 person does everything"-field it used to be. People specialise now. I would not go and tell Crytek that they should not make their own engine but use an existing one. But I also would not go and tell a small, young developer to write his own engine, before he has finished his first game. I think the same goes for CMSs and all other systems. If you have implemented hundreds of CMSs and you know all the ups and downs of all of them, it's a good time to start your own. If you just feel like learning the ones that are out there is a hassle, so you just write your own, it's a really really bad idea. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Worry about something important. Like what you're building! 😎
What frontend framework doesn’t „work well” with any backend technology?
It’s an opinion
Hi; thanks for highlighting this. We are working on adding support for permissions-based multi-user alongside better access controls for the API itself. I'll be sure to raise your feedback internally with the relevant teams.
[cue yakety sax](http://thenewswheel.com/wp-content/uploads/2016/11/Simpsons-Clown-car-joke.gif)
Awesome thanks! I did notice that there's some new multiuser stuff that looks like it would basically cover this issue, but seems it's only on the enterprise plan. Any chance that anything related to this will come through to the free plan? At least for deleting caches?
This is actually a worse license. From Facebook's bad patent grant to none at all.
It's perfectly ok to not want to use Cloudflare and your reasoning is valid. In this situation I was more saying the original person is just laying down their dislike with no supporting reasoning. "this is garbage, avoid" helps nobody at all - even if the thing they're talking about is actually bad. Pointing out your dislike in the form of "I don't like this because .." and putting down some reasoning is not a bad thing :)
Having only really used jquery for javascript stuff before, in the next few months I'm going to start looking into these types of frontend frameworks. I barely know anything about them currently. What is there about vue.js specifically that makes it good with PHP?
Hi, here is a small collection: * http://www.phptherightway.com/ * https://laracasts.com/skills/php * http://knpuniversity.com/tracks/php * https://www.codecademy.com/learn/php * https://teamtreehouse.com/learn-to-code/php * https://www.reddit.com/r/PHPhelp/ * https://github.com/odan/learn-php
&gt; What is there about vue.js specifically that makes it good with PHP? Nothing. It's a totally different language and does not interact with PHP at all. But that's not saying much because the same could be said with React and Angular. I would say go with React. There are move jobs/opportunities. It has a ton of resources and a lot of big names using it (Facebook, Wix, AirBnb, Discord, Disqus, NFL, Netflix). Also, once you know React, you know 90% of React Native (mobile version for making native iOS and Android apps). RN is too maturing and being use in production on a lot of apps you use everyday.
&gt; Vue is superior in every way That's not an opinion and it's definitely not true. Adoption: React has way more market and jobs Large companies using it: https://github.com/facebook/react/wiki/sites-using-react vs https://wappalyzer.com/applications/vue-js. Lol. Resources: A lot more libraries for react on npm and articles/tutorials. Mobile: React Native has such a better native feel and more major companies are using it. And that's before we get started on the syntax/library itself.
My five cents: immutability causes performance degradation, but the benefit is less error-prone application. And since immutability is, in fact, a *guarantee* that the object will never change its state, you suggested "optional" immutability depends on the developer, thus it's not 100% guarantee, thus is not very practical.
Great, thanks for the advice! Personally I'm not worried about jobs, I mostly work on my own projects these days, and on paid contract work I'm usually the solo dev and get to make all the technical decisions. But I do want to learn whatever is a good choice for the future, and the fact that it can help me learn React Native is a huge advantage, because I currently know zero about mobile app dev, and might want to do some in the future, which would be directly integrated with these same web projects. A couple of questions (anyone else please feel free to give feedback too)... 1. If I'm building websites where multiple users can edit stuff at the same time, and see each others' changes in real-time (e.g. Trello, Google Docs) - is React also the best choice there in your opinion? 2. When looking into react a while back, I read some stuff saying that react and jquery sometimes don't play well with each other. I use a lot of various widget libraries that depend on jquery, so I really don't want to dump jquery altogether. Have you found there's any issues using jquery + react on the same site?
we've used countless CMSs and the conclusion I've come to is that all CMSs are awful. Our current platform of choice for brochure websites is Silverstripe which at the moment is the least awful of the bunch. It's not that all CMSs are badly built or badly featured, its a problem with the fundamental concept of trying to build a piece of software to allow unskilled users to do something they are completely unqualified to do without allowing them to fuck it up. Then there's the impassible problem of trying to model content. The content that the client wants to manage and how they expect to manage it is rarely what is on offer from the CMS out the box so you have to craft bespoke content management functionality around a bespoke model and the client will be constrained by those decisions and won't understand why. **If we took all the effort that we as an industry put into developing content management functionality and put it into just updating the clients' sites for them each time then the industry as a whole would get much better value for money** not just because it's easier but because their content is then being crafted by an expert who is not going do the usual dumb stuff like writing an essay into a content block designed for a short headline message or upload imagery in a totally unsuitable resolution or going nuts with all the content features so that it looks like a "my first powerpoint presentation".
And even more major companies are using jQuery. /u/defunctAI was either stating an „obviously untrue fact” or their opinion. There is no need to start the framework comparison topic again, you’re not convincing anyone either way
If you've just finished building your own platform, it's no surprise that you don't regret it at this stage. The real test will be in 5 years time when the likes of Drupal and Silverstripe (and dare I say it: Wordpress), have been maintained consistently by the open source community where as your product has had 5 years of competing for resource with chargeable work. We ditched our CMS/Framework about three years ago. When it was first built it was the best thing since sliced bread, the day we ditched it we couldn't wait to see the back of it.
Nah. It is Saturday. On the weekends I work on my mental health and when my mind is torment I got to acquiesce. 
Yeah. That is fair. Bug caused by forgetting to X is not fun. 
with no facts, no evidence, no benchmarks, no research ... We all have opinions, like we all have farts - guess what - yours stinks.
I understand that this "immutability by proliferation" feels wrong, but your proposal is even worse. You've escaped engine ability to assure the contract by encapsulating mutable behavior. If you want to depend on the objects of this class you have to check if it's locked already or not (unless you don't care for sppoky actgion at a distance) - that's similar to Sqare vs Rectangle (LSP) but within single class. Ps. I don't like this repeated cloning stuff myself, and my take on such "prototypal immutability" is giving the object ability to return builder (in case of telescopic constructors) of its own type - [example](https://pastebin.com/i2KFMwBt). This simplified example looks pointless because of mutual source code dependency, but even this may be powerful in encapsulated contexts when you have controll over behavior you want to expose (something fun to play with for sure).
I'm not sure about the support part. When there is a bug or two in a framework I've chosen to adopt I can't just tell the client they have to wait for the maintainers to get around to fixing it. I could report the bug but they would ear-mark in for fixing somewhere between next year and never, or commit a fix and have it reviewed in a similar timeframe. So I have to learn the internals, generate some interest in their chat and tell one of the maintainers exactly what needs to change. As a reward I avoid looking incompetent. 
Yes, but the bandwagon has decided that’s not important. There’s basically been no accurate, intelligent discussion on the matter. For example, “Just drop in preact instead” doesn’t solve the patent issue at all, and arguably makes it worse if react actually ends up being covered by some patent. Most of the “solutions” that had been proposed may have solved copyright issues but would have done nothing for patents except upgrade you to willful infringement. 
Your interest should be how to use Internet first. Lesson one: read the page you are posting your question to. It says help questions should be asked in /r/phphelp. Lesson two: read the page you are posting your question to. in case of /r/phphelp there is a sidebar with the answer already waiting for you. 
And this is a message board where I'm allowed to discuss and debate subjects. If I'm not allowed to have an opinion, why is he allowed to have an have one about Vue on a topic about React?
This isn't a bad suggestion. Sometimes code is so poorly put together that its difficult to read. Be it the code is far too wide to fit on my screen or a variety of other garbage. In any case, its a start, and you should be able to automate it across the code base or at least do it file-by-file with your editors autoformatter.
Sorry you're getting downvoted, not sure why were are punishing people for asking questions. &gt; If I'm building websites where multiple users can edit stuff at the same time, and see each others' changes in real-time (e.g. Trello, Google Docs) - is React also the best choice there in your opinion? Either would be fine, but you would probably want to look more into websockets to accomplish this. Either use a 3rd party (pusher.com, pubnub.com etc) or write your own. There are a few PHP libraries to do this, but they aren't as mature as node or other concurrent languages. &gt; When looking into react a while back, I read some stuff saying that react and jquery sometimes don't play well with each other. I use a lot of various widget libraries that depend on jquery, so I really don't want to dump jquery altogether. Have you found there's any issues using jquery + react on the same site? I'm not too sure about this, but there are probably plugins and libraries you can download to make this easier. But isn't hard to have a class or id for an element in React and then a listener or something that calls that in jQuery. In the end, React is just creating HTML.
Did you know that when you leave composer.json without version key composer then will use git tags as versions? 
Thanx :)
TIL - That's awesome
Thank you, my bad was a little bit lost there
You could build a plugin that includes Laravel, [like this one.](http://getherbert.com/) I have no idea how well it performs though...running Laravel on top of Wordpress seems heavy. It is something I've been meaning to try just haven't gotten around to it though.
I would just use Wordpress. Finding the right tool for the job is also a very important skill. 
You stated what he said "wasn't" an opinion, yet yours is? Both are opinions sir.
I mean mine was more facts. It's a fact that there are more jobs for React. It's a fact that larger, better and more companies are using it. It's a fact that there are more libraries and tutorials for it. It's a fact that major companies are using it for their mobile solutions.
Absolutely nothing. It's just the fact that laravel endorses it and bundles it by default. But there's absolutely no reason why it would be any different to using angular or react or preact or any other front end framework. All the frameworks communicate with the back end using json api calls. 
1. Maybe php is not suitable for this purpose. To keep the updates in real time you'll probably need a websocket connection and php is not the best for thus even though it can be done with reactphp. 2. I use react and jquery. You can mix the too but you can't do dom updates on components that are being rendered with react. You can wrap jquery based components into a react component but it might take more effort than rebuilding them in react from scratch. Generally though if you keep them separate they work fine on the same page without interference. 
Even if say that was true, react still has a vastly larger ecosystem and industry backing which make it a safer technology to invest your time into. 
So now waiting for a reaction by wordpress. Will they stick to their decision or go back to react? Considering they already invested time in react and the only reason for switching was the license I assume they'll go back. What do you think? 
Also google is an excellent resource when you run into problems, there is almost always an answer to point you in the right direction.
Do you want to enhance your resume? Build a blog. Do you want to blog with relatively little maintenance? Install Wordpress. 
According to the README it takes the version number as a parameter so it wouldn't be blindly.
Has nothing todo with maintenance :D there is no maintenance once you are done building with Laravel. No need to worry about vulnerable wp plugins etc edit: Keep downvoting lads... keep downvoting
The keyword here is *sometimes*. If you're looking to create something clean and simple with only the core features of a blog (posts, comments, maybe media), then Laravel is a good option. You gain a cleaner code, as well as something to put on your résumé, more freedom to make things work exactly the way you want them to. Laravel is also a valid option if you want to break default patterns in how Wordpress does things, especially on the backend side. What you give up on freedom by using Wordpress, you gain in plugin support. As you already mentioned yourself, Wordpress is easy in that sense, and knowing how to make your own Wordpress plugins is valuable (if you're into that sort of thing). What's also worth taking into account is the reach you gain by integrating into an existing blog network, as Wordpress comes with additional benefits like an RSS feed, follow buttons (for Wordpress users), and having your blog listed in search results and recommendations directly on Wordpress.com. You also gain in not having to do most of your SEO optimization yourself, as there are plugins for that. Same goes for making sure the site works on all browsers, including mobile devices. It's also worth taking into account that while Wordpress is easier to install, it's also potentially more vulnerable to exploits. You have to make sure to update it regularly, or otherwise protect yourself against bots that specialise in breaking into Wordpress installations. This isn't to say your own code is 100% secure, you still have to keep updating it and fix some bugs, but if you're looking at a personal blog, you should be able to sleep more soundly at night. Of course if all you're looking for is a basic blog, plugging a custom domain into Wordpress.com might just be your best option instead of hosting the open-source version yourself. It really depends on what you're actually looking for in the blog, how much time and effort you're prepared to put into it, and honestly which one you think is more fun. So, if you want to build your own, build your own. Don't let anyone talk you out of it. It's still valuable learning even if you don't end up using it. 
Lesson three: don’t ever become an arrogant prick like colshrapnel here.
As a person occasionally involved in hiring people (not many times, to be fair), I would not be impressed that you built a CMS/blog engine in PHP unless you can explain the use case that made a custom solution better than WordPress. (And I can hardly stand WordPress myself.)
Why you're being downvoted: Laravel uses many packages in core alone, and on top of that, many apps would add new Composer or NPM packages to solve the same issues as WordPress plugins (think SEO plugins, some people use sliders, etc.) So "vulnerable X plugins" affects most platforms, Laravel and WordPress included. WordPress is "low maintenance" because it's generally built on more plugins than Laravel is, and comes geared towards CMS by default. Therefore most maintenance is typically handled by core or plugin developers and can be updated through GUI. 
Except for when you, as a beginner, find that w3schools is on the top.
Is your goal to build a blog, or your portfolio? If the former, use WordPress, if the latter, address some deficiencies that WordPress doesn't - be creative. Otherwise, you're making a shitty wheel out of mud and rocks, with feathers and non-precious gemstones, when you have a perfectly functional ready-made iron one that you can easily grab. tldr; I've never seen a commercial situation in the last 12 years of my professional career where the question was "blog" and the answer was "build it from scratch on a framework"
how many of those packages are directly exposed tho? there are tons of vulnerability scanners for buggy wp-plugins I haven't seen anything comparable to laravel.
Fair question. With or without a vulnerability scanner, the app will still be exposed on some level. At the end of the day, I'd recommend minimizing your attack vector by installing only those plugins or packages you trust and need. Many plugins are community vetted, and others could be solved easily by using framework methods as opposed to installing single-purpose plugins. 
I agree with your comment regarding the minimization of the attack vector. I am very new to laravel but I feel less exposed at the moment compared to when I was using wp-plugins. I still remember the timthumb issue that was a plague on hundreds of wp themes that happened to use it.
[removed]
You should look into Drupal 8, it's built on symfony components like Laravel and has more out of box functionality. Speaking from experience, Wordpress is a pain in ass overall. 
You want to run a blog? Okay use either WordPress, Drupal, Medium or Ghost. Don't re-invent the wheel; especially when that wheel is a prime target for injections and hijacks.
These are the facts
I learned PHP from [Eli The Computer Guy's PHP lessons on Youtube](https://www.youtube.com/watch?v=27dR_sLaM74) and Larry Ullman's book, "[PHP for the Web](https://www.amazon.com/PHP-Web-Visual-QuickStart-Guide/dp/0134291255/ref=sr_1_1?ie=UTF8&amp;qid=1506202132&amp;sr=8-1&amp;keywords=php+for+the+web)."
if you use phpstorm https://confluence.jetbrains.com/display/PhpStorm/Live+Templates+%28Snippets%29+in+PhpStorm
Porque no los dos? How about laravel, on top of a cms that you don't have to write from scratch? https://octobercms.com/
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Wordpress is garbage, build it in laravel and learn how to code rather than how to install plugins.
Yes, but we still use versions for our internal projects/packages. It has a few benefits like being able to access the release version without git, and adding the version as a standalone commit in the history.
There currently isn't anything comparable for Laravel or the packages it uses (at least, to the best of my knowledge), but that doesn't mean you shouldn't be concerned about keeping the packages and framework you use up to date. It may be that tomorrow a vulnerability is found in a Laravel package, or one of the Symfony libraries, or one any one of the myriad packages they depend upon, that broadcasts it's existence or is easily searched for in the manner that some WordPress vulnerabilities have been. It's certainly unlikely, for the more mature of those packages at least, but it's *always* a possibility and perhaps even an inevitability. In fact Laravel released a fix for very minor vulnerability only a few days ago. The fact you feel less exposed using Laravel (or any other framework), is not a good reason not to keep them properly maintained.
As a non-beginner, w3schools is often still on top. I don’t know how they manage to do it. At least with front end stuff you can add “mdn” to the search to get the Mozilla docs. 
Along with what others have said, you can still write PHP and MySQL within WordPress either via custom plugin, theme or something sideloaded, like a simple REST api for an ajax feature. And despite what you may think knowing WordPress is a marketable akill.
Just use Wordpress. Yes the core can sometimes be a pain, but unless you're doing dramatic alterations to core stuff, using it as a foundation for a lot of uses isn't a bad thing.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Also think about your client. It'll be a heck of a lot easier (and cheaper) if you get hit by a bus to find an experienced WP developer to pick up where you left off than to find a Laravel developer to review your custom site and get going. If that's a concern. 
Add `-w3schools` to the end of Google searches. This should be told to every beginner to avoid that shitty site. 
Cool thanks for the advice! &gt; There are a few PHP libraries to do this, but they aren't as mature as node or other concurrent languages. Yeah a few things I just read mentioned some stuff about php not being multithreaded or something along those lines. Definitely something I'll need to do a bit of research on. And maybe even learn a bit of node or something for the websocket stuff if that's the way to go.
Thanks! Yeah looks like PHP isn't the best, even though it can be done. Lots of stuff to look into. &gt; I use react and jquery. You can mix the too but you can't do dom updates on components that are being rendered with react. Generally though if you keep them separate they work fine on the same page without interference. Ah cool, thanks. Yeah I wouldn't really be using them to interacte on the same stuff. Just wanted to be able to keep using various widget libs, so should be cool.
It's because of the age of the domain I guess. Lots of people have been linking to the resource over the years, and the google spiders enjoy linkbacks (at least from what I can recall).
It's a little more complex than that. Licenses such as the MIT license are typically interpreted as containing an implicit patent grant, and it's generally assumed that the presence of an explicit grant would replace/override the implicit grant. So in many ways, the bare MIT license (may!) contain a stronger patent grant than the BSD+patents setup it replaced. However: 1. Although it's well established that *selling* a product included an implicit patent grant, there's some debate over how settled it is that giving it away triggers the same grant. (Although the sweeping language of the MIT grant seems to clearly imply such a grant; note in particular the grant of the right to *use* the software.) 2. Explicit is better than implicit 3. There's some open questions about the sublicensability of implied patent grants. If *I* give you some software and say "feel free to use it!", that implies that I'm letting you use my patents. If *you* then give it to a third party, it's not clear you can legally give them the same grant to my patents that I gave to you. There's some good discussion about it on [this old hacker news thread](https://news.ycombinator.com/item?id=9111849); pay particular attention to the comments by DannyBee, who is actually a lawyer for Google and an expert on open source law. I think I'd prefer an Apache v2 license on balance, but there's a decent argument to be made that MIT is still better for developers than the old status quo.
If the end goal is to blog, and be able to put WordPress on your resume, then go with WordPress. It's good to know how it works. Many companies use it. Leaning Laravel is also a great skill, but not as commonly used as WordPress. If you want a fun CMS to use, but isn't will known, [Bolt CMS](https://bolt.cm) is pretty slick.
WordPress is fine if you're not doing a lot other than blog. When you start expanding past a small scale blog, prepare for a compromise though. Even so, I'd use a better cms like Drupal. Sites that are purely for spitting out content don't really require something like laravel. Laravel is for applications. 
Teamtreehouse.com
You're a piece of shit for saying that. You should probably quit your career as a developer as you've clearly demonstrated you're incapable of being a decent human being. Who the hell would want to work with you?
PHP the right way and Modern PHP book. 
PHP the right way and Modern PHP book. 
Not only that, he totally misunderstood what the comment was about ... as all the downvotes did.
battle between something super mature vs mature; take your decision accordingly
It says built with symfony and zend.... It could be called inception
If you really want to impress, build a headless WordPress installation and a frontend SPA that uses WP REST API as a view. Shows your proficiency and understanding of the underlying structure and gives you options to optimize the slow php page build times in WP. Cache database calls with Redis and serve optimized flat files to the front end with some framework like React or Vue. I'd be impressed. You get your custom code and a slick super fast blog with easy to edit content. Win, win, win. 
Isn't it somewhat ironic to call this "clean architecture" when most of it is just zero-value noise? - What the point of writing [these getter/setter DTOs](https://github.com/krzysztofengineer/acme-market/blob/master/src/Orders/Order.php), let alone [unit testing](https://github.com/krzysztofengineer/acme-market/blob/master/tests/Products/ProductTest.php) them, if they don't validate, don't behave in any way differently from a plain object with public properties? - What's the point of writing [unit-tests made up of mocks](https://github.com/krzysztofengineer/acme-market/blob/master/tests/Products/ShowProduct/ShowProductTest.php), that basically test if the mocks behave as they were configured in the same test? As far as an example goes, the article is OK. But if this actually gets implemented in an app it'd be a criminal waste of the developer's time and a pointless maintenance burden for those to come after them. I probably wouldn't write mutable non-validating DTOs in the first place, but if this is the way we'll go, this is all that needs to be written: namespace Acme\Market\Products; class Product { public $id; public $stock; } As opposed to this: namespace Acme\Market\Products; class Product { protected $id; protected $stock; public function id() { return $this-&gt;id; } public function setId($id) { $this-&gt;id = $id; } public function stock() { return $this-&gt;stock; } public function setStock($stock) { $this-&gt;stock = $stock; } } namespace Tests\Products; use Acme\Market\Products\Product; use Tests\TestCase; class ProductTest extends TestCase { function testFields() { $product = new Product(); $product-&gt;setId($id = uniqid()); $product-&gt;setStock($stock = rand(0, 1000)); $this-&gt;assertEquals($id, $product-&gt;id()); $this-&gt;assertEquals($stock, $product-&gt;stock()); } } Aside from these more superficial concerns, the requirement to abstract Gateways doesn't exist for most PHP apps, so I wouldn't call starting to write Gateway interfaces right from the bat a "practical clean architecture". It's practical to abstract if you need it, not just blindly follow the most complex layout a given architecture offers. And a remark on your word on validation: &gt; If the validation rules are a part of business requirements - it is a good idea to place it inside the application core. What you could do is to use self-validating value objects which would throw an exception. Then you could catch them in your use case and respond properly (e.g. put fields in the response indicating that a field is not valid). In our case, however, we won’t worry about it and validate the incoming request inside the http layer. Why wouldn't validation be a part of the business requirements? Why wouldn't we worry about it? Why would validation in the *presentation layer* (i.e. the HTTP layer) reflect in any way the goals of the Clean Architecture? If the domain can't enforce its own business logic, then it's not the domain. It's not isolated and encapsulated as a concern, instead its guts are spread all around, ensuring we'd have duplicated and inconsistent validation from client to client. Unlike the hypothetical need for multiple Gateway implementations, a PHP app will often service at least 2-3 different clients: - Web API (JSON, XML, etc.) - Web site (HTML pages, JS apps like Angular etc.). - Internal requests (cron jobs for producing reports etc.) So to move critical logic like validation to the HTTP processing layer would be asinine.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [krzysztofengineer/acme-market/.../**ProductTest.php** (master → 8aadb66)](https://github.com/krzysztofengineer/acme-market/blob/8aadb66a6335539edcbb7d91d6d01ad7eb495d83/tests/Products/ProductTest.php) * [krzysztofengineer/acme-market/.../**Order.php** (master → 8aadb66)](https://github.com/krzysztofengineer/acme-market/blob/8aadb66a6335539edcbb7d91d6d01ad7eb495d83/src/Orders/Order.php) * [krzysztofengineer/acme-market/.../**ShowProductTest.php** (master → 8aadb66)](https://github.com/krzysztofengineer/acme-market/blob/8aadb66a6335539edcbb7d91d6d01ad7eb495d83/tests/Products/ShowProduct/ShowProductTest.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnfe1ny.)^.
Spiral seems to offer the same features and seems to do the same mistakes as any other mainstream framework. What's special about it?
I posted some Nginx Unit PHP benchmarks at https://community.centminmod.com/posts/54905/ as did one of my users 3 posts above mine. Testing Nginx Unit's PHP directly was faster than Nginx + PHP-FPM, but once you put Nginx in front proxying to Nginx Unit PHP, the performance was slower and on par with Nginx + PHP-FPM. Still early days as I figure out how to load multiple config json files https://github.com/nginx/unit/issues/48
Are you saying we should wait for Spiral 4? Not sure what point you're driving :)
&gt; All developers need to be trained in security best practices Damn straight about this...preach it.
They are saying if you want to impress someone male your own with Laravel and dont use WP.
My original point was something like that, but at the end of the day there's nothing that can really sell a framework with today's tooling. I guess the selling point with any new framework is that it isn't X or Y and I'm open for more friendly competition in the framework space. Like for me I personally don't enjoy laravel or symfony for different reasons so I'm always open to a new approaches to the same problems that I've had with those frameworks. Those solutions could be simple and tailored specifically for me, but others won't care or notice if said solution doesn't pertain to them. It's kind of like programming languages, everyone looks for something different and they find one that fits their needs to solve the same problems.
I agree we need more varied solutions (say my in-house solution is nothing like what you see around these days), but this particular effort, Spiral, feels quite traditional. The DI container, how it's setup, how you register "singletons" how you use it as a "Service Locator" how you have multi-action controllers, etc. etc. Like I said elsewhere, seems to have the same features, and to make the same mistakes.
Immutability causes performance costs *in PHP*. In a language with an optimizing compiler, immutability unlocks tons of optimizations. Maybe we will get there one day with PHP, now that we use a formal AST and there is a JIT optimizer on the horizon.
You can write your own theme, widgets, and plugins for WordPress and put them in your resume. I think that this is more valuable as it shows you can work with wp. You can still build other things that might be more interesting to a potential employer than a blog. 
Thanks man, autoloader is a great suggestion (Y)
There surely are some good Laravel CMS plugins that will spare you from writing everything but still offer a good alternative to WordPress.
I got a flashback of the 90's from watching this
Yeah I know that the set ruins the guaranty. Also want to avoid a constructor that takes in a ton of args and if you use an array you loose typehinting. Will have to play around with the separate builder class to se if I can make that feel ok (i.e. Not verbose factory factory java style).
Yea you are right. But they could be combined right? Builder class has the scheme method and Url class has withScheme?
They can be, but if you have every setter method twice it can be a lot of noise for users to see and extra boilerplate for developers to maintain. I sometimes choose to have *some* operations only on the final object, and *some* operations only in the builder. So let's say I allow you to resolve a relative URL like "../foo/" against a base URL like "http://example.com/a/b/c/" to result in a new absolute URL: "http://example.com/a/b/foo/", this is best done on the URL object itself: $absoluteUrl = $relativeUrl-&gt;withBase($baseUrl); But the rest can still be on the builder.
https://wappalyzer.com/applications/vue-js https://wappalyzer.com/applications/react
You're having this problem because you're using a data type that is change by reference by default Use arrays and change them by copy with a series of functions and you won't have to worry about coming up with some non standard abstraction to stop your data structure having hidden reference edits There's no user land PHP object I'm aware of that is "Immutable": https://3v4l.org/smE9M
That's... Actually brilliant. I'm gonna build something similar. Thanks for the idea.
Great book, will check it out, thanx
This is actually a really good point. As someone involved in hiring people (a lot for the last 15 years), the skill set is one thing. But knowing and understanding tradeoffs and business solutions is a much harder skill to come by in a developer.
No problem! Another benefit of this is that you end with a front end framework that can interface nicely with any back-end API. You could introduce laravel spark as another simple application back-end that works seamlessly in your app. You could also introduce a socket.io backed node.js chat application too. Sky's the limit. And you're not limited by WordPress' clunkiness. Great setup for a portfolio.
I have a commercial Laravel backend app already up and running with a Vue-augmented front-end, so this one I want to do with something entirely different. The apparent clunkiness of WordPress seems like a good victim of this experiment. Any advice how to set up the WordPress side of things? I've done some stuff in it, but it was mostly simple templating.
Some of the most valuable experience is in wrapping your head around massive legacy systems and figuring out stable ways to incrementally move them forward tech-wise with minimal disruption to business. Few care which frameworks and libraries you've worked with already, if you're worried about which ones you "know" you're operating at a junior level. The real world isn't made of the latest libraries cleanly stitched together.
Maybe? http://kizu514.com/blog/wordpress-rest-api-quickstart/ 
If you haven't done it before, and want some resume cred, try building your blog. Even better, open source it, put it on composer (packagist), add unit tests, and dockerize it for easy deployment. That would blow the socks off most interviewers
I did something like that long ago but with vanilla js and when I asked about redoing it with Vue on Reddit people told me it was overkill. No matter how much I explained that my original code is the shittiest of shits people kept telling me it was overkill. I just don't get Reddit sometimes. Any chance you could have a look and give me some pointers on how to go about converting it to Vue? The worst part is the code for routing.
We are actually doing this for Spryker module releases, just on a way larger scale :) 170 modules and their dependencies, releasing patches minors and majors with correct constraints between them requires such tooling.
Well the thing is that you also need to understand what tool should be used for what job. If on a resume I saw that you have Wordpress experience and decided to go overkill and develop a blog using Laravel, I would assume one of two things: 1. You were doing as you said and using this as a learning experience. 2. You don't understand what technologies to use and when. I think the better situation would be to develop the blog in vanilla PHP. This way you get a better understanding on the language and can practice OOP patterns, while not going totally overkill by adding an entire MVC framework for a blog. It is like renting a backhoe to dig a hole for tulips. It gets the job done, but is more costly, will require more work and will be messy.
&gt; What's the point of writing unit-tests made up of mocks, that basically test if the mocks behave as they were configured in the same test? How would you test this particular method or any method with a dependency? Or is this specifically about time savings, i.e. this method is not important enough to be tested? In case it's about wasted time, what would you do in a TDD environment?
What did the comment say? They have deleted it now
Been awhile since I have touched wordpress and had no idea you could do this, but it seems like a pretty solid idea. I always get clients telling me they do not want to use Wordpress and they never want to budget a custom or library CMS. So I do monthly maintenance for them. When they realize the cost for this, they suddenly want a CMS. So with this, can install a Wordpress instance in my server and use it as an API for certain content I want to be editable by the clients? Would save me so much time.
+1 my first question would be why you felt the need to build it yourself and why you felt it was the better option. 
Thanks.
&gt; How would you test this particular method or any method with a dependency? Or is this specifically about time savings, i.e. this method is not important enough to be tested? The trouble with your question is that I have a very specific image in my mind for the answer, but in the very next moment I realize it'd take a really long answer to explain it... And while the actual solution to a specific problem is simple, I can barely *scratch the surface* as to a general answer in here. Basically, there aren't just mocks. There are mocks, but also dummies, stubs, doubles, fixtures, fakes etc. When you're trying to substitute a dependency with something you can use in a unit test, the less specific it is to the *internal* behavior of the component you're testing, the higher quality of the test. From that point of view, the mocks here are the lowest quality replacement there is, as they directly dictate to the tested component what to call and in what order "expect... one call to... find... with $id... throw NotFound". What happens if the component we're testing has a cache? It knows $id is not found, so it doesn't ask the gateway, but it behaves correctly. The test will fail regardless, because it doesn't test external behavior, it tests *internal implementation details*. What's the alternative? You could instead implement an in-memory "TestProductGateway" which just stores products in a simple PHP array. And now you can initialize it with an array, and it *knows* if a given $id exists or not, by checking in the array, so it doesn't have to be set-up with overly specific rules to expect certain calls with certain input and respond in a certain way. This in-memory gateway is not only a much more faithful implementation of the dependency, but it's much more reusable. If you write *one* test, using a mock will be less code, but if you write five, ten, twenty tests, then using an in-memory gateway would be much shorter and more readable, just... new TestProductGateway([... array...]) and you're done. Much more importantly than the amount of code, your *tests will be better*, as you're testing external behavior, not internal implementation details, as I said. Another problem with OP's components is that they do very little on their own, to the point the thing you're testing does almost nothing except connect its dependencies with one-liners. When you start writing tests, using mocks, that are basically re-verifying the behavior of the dependencies themselves, you should stop and think if there's any substantial unique behavior that's added from the tested component, or the thing you're implementing simply has no reason to exist and you're over-abstracting for the purpose of over-abstracting. There should be value in every component you write. At the scale of Amazon or Google, a back-end service may be doing something as simple as "I'm a giant hash map, I have set/unset($keyOfBytes, $valueOfBytes) and nothing else". And this is fine at the scale Amazon and Google work at. But when you're writing a PHP application there's no need to dedicate components to implementing a hash map - that's built-in, tested, known and available. If you write small PHP applications the way Amazon and Google manage entire data centers, something is certainly off in that approach - architecture is *never* "one size fits all", and "one size fits all" is the approach the author is demonstrating, unfortunately. He's blindly taking an architecture and then writing some minimal code for every component so to appease the architectural guide. There's no thought, seemingly, as to why he's implementing a specific component and what is its purpose in the app. Sometimes you have points of extension where the default handler of this or that does nothing, but over time and as needs evolve you can plug-in handlers that implement quite a lot of functionality. But this isn't truly the case here. What's being tested is not just a "stand-in" for the real-world implementations to come, it's the actual thing. And it has no reason to exist. Also, as I mentioned, in a typical app you have no good reason to abstract the "gateways" in this way. So if you don't abstract them away, you don't need to mock them when testing the component using them.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; In a discussion about APIs, I'm not a theoretician, I'm not a philosopher, I'm an engineer and I write software. Technology is not neutral. It conveys values, and the value of openness and knowledge sharing behind the WWW are not granted (last example in date: https://boingboing.net/2017/09/18/antifeatures-for-all.html). But Reddit isn't the place to discuss this. &gt; for no tangible technical benefit Isn't the ability to get dynamic backoffices and to scaffold React/Vue.js/Angular/React Native apps for any API just by implementing an open web standard a big technical benefit? Isn't the possibility to aggregate data and create mashups using tools like Apache Jena without having to write adapters a technical benefit? It's just two examples among a lot of other use cases. &gt; And because this specific situation of "I don't target you, you don't target me, but we implicitly interact" often doesn't make sense in a general-purpose API I agree with most of the statement except the "often" part, but maybe don't we work on the same topics. Anyway using standards like JSON-LD (or GraphQL if you don't need interoperability) have another advantage: they allow to reuse code and infrastructure across projects, both server-side and client-side.
[removed]
I see. Thank you.
&gt; Technology is not neutral. It conveys values, and the value of openness and knowledge sharing behind the WWW are not granted JSON-LD stands for "openness and knowledge sharing" like how drinking Coca-Cola stands for "spending Christmas with your family during the winter, and being cool and hip with young friends during the summer". It's an arbitrary association that has been fed to you, and you're riding on it to market your own wares. If any of this directly contributed to the goals you're talking about you'd be able to explain why JSON-LD helps in any further scenarios that I explicitly listed (the rare scenarios where indirect interoperability of such data is required). You have so far not done that. &gt; Isn't the ability to get dynamic backoffices and to scaffold React/Vue.js/Angular/React Native apps for any API just by implementing an open web standard a big technical benefit? I don't see how. You seem to be under the impression that most APIs are basically CRUD for cookie-cutter standard entities. That's not what most APIs of value do. There's no `schema.org` for most of what AWS/Google/Azure etc. offer. Or Watson and Wolfram Alpha. Even the more mundane: Facebook, Twitter, YouTube, AccuWeather, LinkedIn, Pinterest, Flickr. Any uses of JSON-LD are specific and niche. So are apps that would be built by starting with scaffolding that does `var_dump()` of such entities. It doesn't seem like any of this is useful *in general*. You can find specific uses for anything, but as a general approach? No. So, no I don't see any significant value here. Care to link me to some mind-blowing examples that go beyond flashy demo and demonstrate true value? &gt; Isn't the possibility to aggregate data and create mashups using tools like Apache Jena without having to write adapters a technical benefit? Apparently not as if you check out the popularity of Apache Jena it's at best a niche product. Doesn't exactly jive with bold phrases like "the semantic web" and "a world of openness and knowledge". There will always be adapters, because you can't wait for some slow inefficient bureaucracy somewhere to come up with a universal cookie cutter solution that fits the whole world. What kind of a dystopian vision of the world is this? You don't seem to understand the weight of standardization and the value of simplicity and flexibility. Adapters are trivial. Adapters are small. Adapters are easy. Adapters are the freedom to have the entire world at your fingertips *without* waiting for standards to be invented and adopted, and to mold the data the way *you* choose. The control is not centralized at some out-of-touch ivory tower coming up with inept standards, the control is with you. That's a pragmatic approach. Only a small subset of things will ever be a "standard". That's always how it was meant to be. You will be dying of old age and still looking forward to the bright future of the semantic web that will never arrive, because you are confused about why standards exist and when they are applicable and when they aren't. &gt; I agree with most of the statement except the "often" part, but maybe don't we work on the same topics. I have to wonder what kind of topics you work on where `schema.org` entities are dumped CRUD style from every orifice of the web and that constitutes a common and useful approach to the problem of API design. &gt; Anyway using standards like JSON-LD (or GraphQL if you don't need interoperability) have another advantage: they allow to reuse code and infrastructure across projects, both server-side and client-side. If you have JSON-LD deeply embedded into your *infrastructure* that's quite scary actually. Anyway. With the basics of good architecture, you can *already* reuse all code you want to reuse. Whether you want to use JSON-LD or not can be a choice you make at the endpoints through thin adapters, which don't represent a burden of any kind at all. Never did, never will.
One should only set expectations on side effects, not on outgoing query messages. In this example the component isn’t required to call it’s dependency if for some reason it decides not to (cache, invalid ID, instance pool). A different -- tested -- repository implementation would be better. The test should be limited to assertions about the result
This
Thank you!
Looks interesting. You should at least ensure all of the databases supported by Nette/PDO are supported instead of limiting it to a single platform.
You should commit the composer.lock file 
Alternatively you could use something like http://oboejs.com/ on the Node side.
Laravel doesn't have plugins, it has packages. Semantics? Sort of but no. The open source packages that make up laravel can not be compared to wordpress plugins. Laravel's packages are used by a multitude of programmers every day. They are open to review and criticism on a much more regular basis than a wordpress plugin ever could be. Also most of them are made by trusted and respected sources. The reason Wordpress plugins are more vulnerable is because they are not used by programmers, they are used by site builders, most of who can not code. So they are not subject to the same level of scrutiny as the composer packages that make up laravel. Not even close. Wordpress plugins are the main reason why wordpress is seen as insecure. Core WP is fine, its the plugins and themes that have always been the problem. The chances are a Laravel installation can sit for years without being updated and still be more secure than a WP site updated today.
Laravel = packages, WordPress = plugins, Drupal = modules, etc. It's all different language for 3rd party code. All platforms have high quality and low quality 3rd party code. The same developer who does not vet WordPress plugins would probably not vet Laravel's Composer packages. I believe you're right that WordPress as a community has less security standards, but as a single developer choosing a platform, WordPress is perfectly safe to use if done right, just like any other platform. Sometimes it really is a better tool for some jobs. 
How can I better understand predefined variables like $_GET, $_POST, etc 
If you know that sometimes you might get a "bundle" of jsons, why not handle it on the server side? Look for a boundary string before calling json.parse.
Nagle's algorithm. See TCP_NODELAY socket option for disabling it. Apart from that - the receiver still may concatenate the two packets together, if there has been no read operation between every single sent packet. - so yes, the way to go it introducing an artificial boundary like \n. (And splitting there if applicable in your node.js app. Also: yes, Redis has message separation built-in unlike raw TCP. TCP is a bare stream segmented into arbitrary sized chucks with an upper limit of 65535 bytes each. You ought not relying on the packet segmentation being preserved by the OS or Node on the receiver side (It may _mostly_ work though). So, yes, the way you are doing it, is a bad idea. Basically: either use a proper messaging library implementation (like redis for example) or handle boundary chunking yourself.
https://www.phpbb.com Enjoy
Can you create your own website from it?
There are a tonne of resources out there. This article (https://dev.to/jchiatt/headless-wordpress-with-react) has a great explanation of the setup you could look to using with WordPress. Vagrant boxes are a great option for local development. You could launch your WordPress application on something like blog.example.com or api.example.com so it's not taking up your naked or www domain space. Then it's just really hooking everything else up. This guy explains setting up custom posts and a react front-end.
That is definitely an option. Page builders and pre-built theme frameworks (BeTheme, Bridge, etc.) in WordPress aren't a horrible idea, but will definitely not be as customizable as a bespoke application. Though, they are very easy to manipulate quickly. Keep in mind they do cost a lot in overhead when WordPress goes to build the pages, so keen caching is important. I have clients that use WordPress as a CMS and still find it too difficult, or end up posting incorrectly, or just plain doing weird stuff. They're not the experts, so it's really not in their best interest to be wasting their professional time on something they aren't best suited to. I'm assuming these clients are business owners who are busy with their own business. At the agency I work at, we bill upwards of a few hundred a month to maintain even the most basic WordPress installations for clients.
Google "PHP web hosting" You need a host for your site, and you need to know how to install the package. There are a million tutorials on the internet, just use some Google Fu and you'll learn how to use it. 
If you don't know how to work with PHP already I'm afraid you've come to the wrong place. However there are free forum hosting services out there such as https://www.proboards.com. That might be more up your alley until you learn how to do it yourself.
I don't think it's overkill at all. If you only want to create a front end for a wordpress site you may be better off just creating a theme. But when you spend the extra time creating a wonderful front-end application, you want to make sure you can reuse that code with other projects. A single front end with multiple REST back-end options gives you a tonne of flexibility. Not a waste of time in my books at all. Vue is a really great front end framework with some awesome documentation. I'd suggest reading vue-router and the basic Vue documentation (Vuex when event driven component communication starts to get heavy) front to back. This will give you more than enough information to create or convert any front end system you'd need to access the WP REST API. If you want to PM me a link to a repo with your code, I could take a quick peek. Can't guarantee it'll be immediately though...
I downloaded all of the packages in phpbb3. How do I run it to see what the base forum is? 
Any simpler ways you can create a public forum thay you can put ads on? 
So I freelance on the side for my projects (at one point was up to 6 clients, now 2 but just had a kid so I'm good), so I only have about 4-10 hours a week to work on this stuff. At my company we use an enterprise CMS. We also have over 20 portals and who knows how many API's. The enterprise CMS is used with content managers and developers. We are trying to remove devs from having to work in the CMS, but higher ups are unsure how to do that. Our team found out that the CMS has an API, and we are using that in order to Make it so content managers can actually be able to make changes using the CMS without worrying that they will break something. Simply because we only grant them the ability to make changes to certain parts. I was hoping this was the same thing. Keep a running instance of laravel with a wordpress shell to handle only the content that is editable via API requests. Have a feeling it wouldn't be lightweight, but I'm interested in running some benchmarking load tests. 
Thank ye, mate.
If you build it, they will come. 
How come you don't write articles? So stuff like this won't get lost in a comment chain. It's an interesting perspective.
What is a specific question you have about them?
&gt; JSON-LD stands for "openness and knowledge sharing" like how drinking Coca-Cola stands for "spending Christmas with your family during the winter, and being cool and hip with young friends during the summer". What a technical demonstration, congrats! &gt; You seem to be under the impression that most APIs are basically CRUD for cookie-cutter standard entities. JSON-LD isn't about CRUD. You can also design service-oriented APIs with Hydra and those tools will still work. But, even if JSON-LD (and API Platform btw) work well with non-CRUD, keep in mind that CRUD is the architecture behind the web itself and that it's OK for ~70% of use cases. Recommending to not create CRUD API when other approches don't bring any value but bring a lot of extra work for the dev team is total non-sense. It's just like recommending to go microservice early in the project. Most projects are not Google, Amazon or YouTube, and will never be. &gt; There's no schema.org for most of what AWS/Google/Azure etc. Creating a cloud platform is a very specific use case. Unlike most API, it's not about data, it's almost services. And interoperability wasn't a goal for most providers until recently. Now interop is handled at other levels (Kubernetes). &gt; Facebook, Twitter, YouTube, AccuWeather, LinkedIn, Pinterest, Flickr Every API you quote is older than JSON-LD itself. It's still a very new standard, and it's hard to create an API with a technology that wasn't even existing at that time. JSON-LD would be adapted for this kind of APIs. If such APIs was proposing a JSON-LD/Hydra endpoint, it will be easier for websites to provide integrations with them and to support without much work their alternative (but are the companies behind those services interested in interoperability? You remember the debate about openness...). It will also be more easier to search and do computations on all social posts/videos/photos available on the web, regardless of the platform used (just like with an HTML parser you can deal with any existing website). &gt; Any uses of JSON-LD are specific and niche. So are apps that would be built by starting with scaffolding that does var_dump() of such entities. Again, JSON-LD isn't about CRUD. But do you know this nice tool called Ruby on Rails (and all its alternative such as Symfony, Laravel, Django...). In the beginning, it was just a tool to scaffold and var_dump() some entities easily. Such a failure ^^. &gt; Adapters are trivial. Adapters are small. Adapters are easy. Adapters don't scale. But show us the code if it's that easy. &gt; With the basics of good architecture, you can already reuse all code you want to reuse. With your so high levels system, you use several languages don't you? How do you reuse your code in code bases of JavaScript, Go and PHP? With a standard API output (JSON-LD, but JSONAPI, GraphQL or any other is ok too), it's easier, you can use existing libraries. With your homemade format, you've a lot of work to do. It will be my last reply. I'll never convince you because you don't want to. Trolling anonymously on Reddit looks like your main occupation (https://chat.stackoverflow.com/transcript/11/2017/9/9/0-21 ^^) and I've some work to do. Have a nice day, and don't hesitate to publish open source code to ease API creation, I'll be glad to use it. 
&gt; But, even if JSON-LD (and API Platform btw) work well with non-CRUD, keep in mind that CRUD is the architecture behind the web itself and that it's OK for ~70% of use cases. Fielding would slap you in the face if he heard you say that. Quote: *"Search my dissertation and you won’t find any mention of CRUD"* (it's a real quote) &gt; Again, JSON-LD isn't about CRUD. But do you know this nice tool called Ruby on Rails (and all its alternative such as Symfony, Laravel, Django...). In the beginning, it was just a tool to scaffold and var_dump() some entities easily. You think scaffolding is the most valuable thing in RoR etc. That's hilarious... Ask any such "CRUD developer" and producing and customizing scaffolding for admins is easily the most annoying part of the job. And the irony is they don't even have to do it, but that's a long story, plus why should I feed you good ideas that you won't appreciate? &gt; Adapters don't scale. But show us the code if it's that easy. They "don't scale" how. Mapping structure X to Y is a stateless operation, this scales infinitely, it belongs in a class of problems called "embarrassingly parallel" (it's a term). You'd have to get a little more specific than buzzwords and slogans if you want this to make sense. &gt; With your so high levels system, you use several languages don't you? How do you reuse your code in code bases of JavaScript, Go and PHP? With a standard API output (JSON-LD, but JSONAPI, GraphQL or any other is ok too), it's easier, you can use existing libraries. With your homemade format, you've a lot of work to do. Google Protobuf, Thrift, Cap'n Proto for private services, and plain JSON for public services. Notice how JSON-LD and JSONAPI isn't in that list. GraphQL in itself is conceptually useful, but I've been doing what GraphQL does with plain JSON before GraphQL existed. So I'd pass. In the real world having to expect and resolve links to other API responses in arbitrary places in the data would destroy performance. So in real-world APIs, as far as high-performance is concerned, you want to deliver results that aggregate all information you need at once, where possible. And where not possible, you control the interface if it's a private service, so having a world-wide standard on global field names and links like JSON-LD doesn't make sense. JSON-LD makes sense for public APIs when you want to connect to a remote data source in a generic way, but the utility of this, although it's there, is limited. There are also serious implications about security when you start domain-hopping like this. Proposing JSON-LD and friends as a solution for "using several languages" is really, really, REALLY off-base. JSON-LD is an ultra high-level solution to what is a very low-level problem. If the issue is "I need Java and PHP to talk" and your first thought is "I know, JSON-LD!" then something is really wrong in this picture. By the way, a quote from the creator of JSON-LD: *"I hate the semantic web"* (it's a real quote) &gt; Trolling anonymously on Reddit looks like your main occupation (https://chat.stackoverflow.com/transcript/11/2017/9/9/0-21 ) Seriously, someone mentioned me once on IRC or whatever the heck this is = I'm "trolling"? Uh-huh.
[removed]
&gt; This also does not help me out a lot and still causes malformed messages. What's the issue with this approach exactly? As long as the node.js server waits until the buffer has a `\r\n` token, then everything before that should be a valid json chunk.
If you don't want to use redis, you might need need a custom communication protocol (aka message format) above TCP/IP. Some use netstrings: https://en.wikipedia.org/wiki/Netstring. I think redis itself does, too, but null-terminated, I'm not sure. Anyway, here's a PHP implementation of reading such a netstring message - maybe it'll give you some ideas: https://stackoverflow.com/questions/29177949/sending-and-receiving-multiple-json-literals-via-php-sockets/29178739#29178739. Check the comments on the question, too. Basically, you should send something like $json = json_encode($data); $dataOnWire = strlen($json) . $json; socket_write($socket, $dataOnWire, strlen($dataOnWire)); And then read it on the other side. Careful with socket reading: make sure you read the whole thing. TCP/IP guarantees the data, not _how_ it's sent. Also, careful with socket _writing_ in PHP: &gt; socket_write() does not necessarily write all bytes from the given buffer. It's valid that, depending on the network buffers etc., only a certain amount of data, even one byte, is written though your buffer is greater. You have to watch out so you don't unintentionally forget to transmit the rest of your data.
**Netstring** In computer programming, a netstring is a formatting method for byte strings that uses a declarative notation to indicate the size of the string. Netstrings store the byte length of the data that follows, making it easier to unambiguously pass text and byte data between programs that could be sensitive to values that could be interpreted as delimiters or terminators (such as a null character). The format consists of the string's length written using ASCII digits, followed by a colon, the byte data, and a comma. "Length" in this context means "number of 8-bit units", so if the string is, for example, encoded using UTF-8, this may or may not be identical to the number of textual characters that are present in the string. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Traits is like GOTO from OO perspective...
This is really bad practice... why encourage people to use such code? I would like to see a whole paragraph why not to use it, or when it really would be useful. For example when writing UnitTests for accessing private properties... (If really needed...)
No, it's not. Traits, it's like AOP, this promotes reuse and separation of business/technical code. Yes, ok, you can design some aggregation/inheritance/... but "traits" is an "another way".
Its not about the trait, its about "add methods to a class". Its even more sh*tty code than only a magic __call, because its harder to debug/maintain/read/find. No IDE autocomplete, no refactoring possible, ...
Or you could $instance = new class extends Foo { public function bar(...) {} }
I didn't see the two factors which I think are the most important ones: * Is this code actually being run in production? * How big is it, and is rebuilding gradually a possibility? Anything that's run in production is battle-tested, so I know from experience that a rebuild will likely start out with more bugs and less features (we always think the rebuild will be flawless and comprehensive, but it never is). The rebuild is however (hopefully) more maintainable, so if the maintenance cost will be dwarfed by the rebuild cost, I may still go ahead. Unless the project is big. Big projects shouldn't be rebuilt as a whole if they're actively used. Rebuilds should occur piece-meal as a part of regular feature development, which makes them essentially deep refactorings. Rebuilding as a whole makes the product stand still from a business perspective, which can be fatal. Many businesses have died while doing a grand rewrite, which is why it's known as one of the classic mistakes.
Glad I could help
Found the novice.
I've no problem with my IDE autocomplete. And traits are good candidates as migration step and refactoring.
&gt;Laracasts Stop right there.
More than 30 years of architecture, testing and experimentation. I don't think I'm a novice ;) (I started developing in 1983)
Did you even understand the article? When I'm adding a new method with this static macro helper, no IDE will autocomplete this new method, hence no refactoring possible and debugging is like hell with such things...
You never learned humility.
ho, wait, I totally screwed up. My apologies, I hadn't read the article correctly. Yes, I agree with you about this "dynamic"/sh**ty magic code :D I was focus on "traits" !!
no :)
No you didn't. Anybody maintaining a serious codebase should deny any PRs introducing this... 
At least two frameworks that stopped about 3 years ago...
I agree with you (if you talk about this article, not just "traits")
In what way?
I like it! Nice and simple, easy to use. Great job OP!
[removed]
https://www.phpbb.com/community/docs/INSTALL.html
It's click bait to show ads... /u/carolina_sar
If I'm not mistaken, PHP uses copy-on-write, which means that if you clone, you will waste memory only on the differences between the cloned and the original object. That was extensively benchmarked during the development of PSR-7, proving that chaining thousands of -&gt;with*() methods led to a minimal memory footprint, noticeable only after thousands and thousands of calls (which are not realistic in a normal app). I would link it but I cannot find it :(
Cool stuff! I did the same kind of lib but with a bit more features, available at https://github.com/drupol/DynamicObjects
Does js even has thing like Interface? No, then what's a point going from php to js? Js like 10 years behind php.
&gt; It’s more targeted at package and framework developers And in Laravel it is really annoying; searching through the codebase trying to dissect how something work to find out that it works through a "macro" As far as I'm concerned if your framework is not written in a way that it is easy to extend classes (and thus you have to use something Macroable) then you're doing it wrong. Eloquent model collections are a perfect example of this.
Composition over inheritance. If you have to extend classes, your framework is a no-go for me.
The main problem I have with this is that how do you know at runtime that a specific macro exists on your class? If you're creating this macro in a place that works at Dependency Injection time, you don't have a reliable order in which things are instantiated, if you're bootstrapping it, your code might fail during testing, or running from the command line... it's adding a lot more paths through your code which could fail and is then basically impossible to debug if in some situations this method doesn't exist. If your code isn't extensible enough, I agree with @flyingkiwi9 your framework needs work.
 /u/bwoebi is correct with his solution. As for php websocket clients... It can be done. Aside from Ratchet, there is [textalk](https://packagist.org/packages/textalk/websocket) but the reality is you really don't want to do this yourself. Implementing [6455](https://tools.ietf.org/html/rfc6455) is a ballache because you have deal with the packets on the *byte* level and do some handshakes and shit. Use a library.
Not sure you can advocate for Wordpress because blogs are a target for injections and hijacks. If security was the primary concern, he'd be far better building in Laravel.
Aside from Ratchet, there is also Aerys: https://amphp.org/aerys/websocket/ textalk does not look that bad, but it's fairly low-level and blocking, which is not what you want from a server - also looks unmaintained.
What use cases would make sense to you? I recently built a site for a customer who wanted to be able to edit their content and add posts. I done it in Laravel because a) he said he might want add a section to take payments from customers in future and b) because *I'm* the one who'll have to maintain it. I don't wanna have to rebuild/recover at the rate I would with a Wordpress site. I used [SimpleMDE](https://simplemde.com/) to add a markdown editor to the backend. Nice and usable.
Come on, there is no such drama at all. That's in the human nature, it's like football teams's fans. Yes, we should not engage in Holy wars, but heck we aren't expected to behave like aged noons either. And, you know... If someone is refusing a better job only due to their dogmatic views, then they are simply a fool, and community can do a little for them anyway. It's perfectly OK for you to reflect on these matters, but please, do not appeal to the community at whole. 
Debugging and patching the inevitable security vulnerabilities isn't, though.
I feel like they both serve a segment of the market. More choices are a good thing. 
Why do you need to? Plenty of spare time on your hands? :)
As long as it is indented with Allman I don't mind much ;)
I was also foreseeing this when I did my library and some methods has been added in it to cover this. See the API section in the README file: https://github.com/drupol/dynamicobjects
Because it feels like hotglueing instead of actually understanding the underlying problem. I would love to know how to implement this properly.
True I was hoping there was a solution on the PHP side though since I am able to for example check the amount of bytes sent and people are abusing socket_write with sleep functions. I guess breaking up the stream is not a problem if I identify the chunks with a delimiter. It feels like too much though, I think I will try and learn how to set this up with Redis because this feels like going down to bare metal TCP which is complicated. The implementation is not that hard but really understanding what happens with the buffer, why some messages get chunked together and others not, etc. is over my head.
I know that you had to read the PHP manual and have a deep knowledge of signatures, parameter ordering and the magic of the type handling in various cases, that's a good thing to know and it takes significant time to excel this exam, I don't doubt this. Our programming tasks are not of the kind that you will Google out. For example you get an existing code that does something and you have to refactor it with best practices and cover with tests, showing the full process with git commits. A ZC exam won't prove that you know the patterns, code structuring, testing, composer usage, have a consistent coding style, phpdocs etc. In most of the parts that ZC covers is what your IDE like PHPStorm will help you with, but it won't tell you where to put a class, how to name it, how to write good unit tests to cover etc.
&gt; The Vue.js Strike Force is really strong in /r/PHP Really? I haven't noticed that. For the most part I've seen people who speak highly of vue.js, many times with accompanying anecdotes, but not blind `hur dur use vue.js`
Symfony without yoda style
What do they do? I dont understand the logic behind them. I can post some example code from my project?
phptherightway is a great resource, but you should learn about the syntax and the basics of php before approaching it. It's very high-level. If you know other languages and just need to figure out the specifics of php, you should be fine, but if you don't have any coding experience, you might want to start with that and when you feel comfortable writing crappy code, go for industry-standards. 
Why do you say it is lax? What do you think is missing? I don't think I ever write vanilla PHP so I try to stick to whatever framework or CMS standard I'm using. Most have one.
Good spot, unmaintained is a big thing with websocket libraries too, because the handshake has changed a couple of times and makes the version of the library useless.
As far as standards go, I follow PSR2 and then do my best to observe the following: - keep method complexity to a minimum - use methods for complex `if` conditions - start method names with a verb (except entity getters) - start any method or variable that represents a boolean with `is` or `has` - organize classes passed to constructors alphabetically That's all I can think of right now. 
I'm clarifying : I'm **not** the author of the article. But I though it was worth sharing here.
Read through the rules for [php-cs-fixer](https://github.com/friendsofphp/php-cs-fixer), see which ones you like, then build your own ruleset.
They represent data that's coming into your app from various places. For example, $_GET is the query parameters on the URL so that if someone goes to index.php?foo=bar&amp;baz=quux then $_GET will contain keys 'foo' and 'baz' that have values 'bar' and 'quux' respectively. $_POST is populated similarly but from the data coming from an HTML form. $_SERVER is populated with information about your server configuration as well as information about the current request.
&gt; An important bit to remember is that you can’t use this trait on a class that implements __call itself. trait support lets you import methods by name, i.e. class foo { use Macroable { Macroable::__call as MacroableCall } public function __call(string $method, array $args) { if (thing) { // do your own stuff here } else { return $this-&gt;MacroableCall($method, $args); } } } 
As you know "goto considered harmful". Why? Because it allows you to build complex execution flow which will be very different from the way code written (the same problem with global state by the way). This creates huge mental overhead since our brains do not play well with processes which highly depend on time. This also increase probability of bugs. Traits creates similar effect in terms of "jumps" thought code to get whole picture. If you are overusing them then it increase mental complexity of code. The problem not with traits itself (just as goto) but how they used (and this article is good example of bad practices). Traits are just for copy-paste code. And if you are implementing logic in it and using it in multiple context, this could be signal that you done something wrong with decomposition.
&gt; use methods for complex if conditions You may like the idea of calisthenics then, check this out: https://www.youtube.com/watch?v=tiwSmIQn1AI
I use most of Symfony's spec, except a few variations: * I use underscores rather than camel case for variables because there's never any issue with case (especially when accessing non-autocompleted vars such as __gets on database fields, which are also underscores). * I split the class extension / interfaces up onto their own lines. * I use the C++ style of IInterfaceName rather than SomethingInterface * No yoda I have.
My application was outgrowing a single configuration file so I wanted something to help keep configuration files small and well organized. I couldn't find much out there that wasn't bundled into a framework, so I rolled my own. Take a look, feedback and pull requests welcome. 
Looks great! Nice simple library, looks well tested, and great name.
&gt; there is no such drama at all. I'm not going to link to it, but there has been non-trivial amounts of abuse directed at people on twitter when they've given advice on what they think is bad advice in some frameworks. Also, you aren't exactly a neutral observer when it comes to claims people abusing other people online. Correct me if I'm wrong, but I believe you were banned from Stackoverflow for a year, for behaviour very similar to that which this article is talking about.
Thank you for this. I've just been hired to build a project in Laravel that is supposed to be quite substantial with far reaching impact. As someone who knows that this is the framework they've chosen I read this thread and though, "uh oh." But this is reassuring information. Especially since my background is Java/Android and I only used PHP for a couple of projexts in school. The main focus of this project is to get it done rapidly and pull the resources back from AWS to free up capital and devote it to other things. So I understand why laravel was chosen, but the data intensive nature of the project is making me think I'm going to have to work around Eloquent quite frequently. We will see. Anyways, thank you for a thoughtful internet answer. They are rare.
Seems like an overreaction to some typical nerd-drama. This kind of tech flame war stuff is as old as programming. In fact, it's probably as old as the entire human endeavour of engineering. Techy nerds love to argue about tech and sometimes it gets overheated. I thought this article was going to go deeper into the ACTUAL toxification problem going on right now, of which the very sorry episode of Drupal's mishandling of the Larry Garfield situation is a recent example. But nope. It's just someone complaining about a good old fashioned nerd argument. 
You're welcome, glad it's still helpful months later! I wouldn't sweat Eloquent too much - I use it very heavily, and it's really only too slow when you need to deal with very large quantities of data, or when you need to build very complex queries. I would say I only work around it 5% of the time, at the most. If you're doing heavy data, then yeah, you may need the query builder or straight SQL a lot more.
If I use YAML files, doe this library load and parse the YAML every time, or does it create PHP cache files that can be used by the OPCache?
Done! Thanks.
My approach was to deliberately leave caching outside this library. I created a very minimal config file that contained only enough config to connect to cache. Check to see if the configuration is in cache, if so load all the config from cache. Otherwise read the config dir and store the resulting array in cache.
What is the file I run 
No thanks. Magic is bad, mmkay. Also... &gt; Have you written unit tests for your controllers recently? You probably ended up creating mocked dependencies that were not even related to your test. You shouldn't really need to write unit tests for your controllers. You're really just calling other stuff within your controller method, and that other stuff should be unit tested. In most cases you'll be able to use behavioral tests for your controllers.
Great points and I agree completely. Thanks for the discussion.
Wordpress on it's own is solid from hijacks and injections. Adding plugins without reviewing their code first is where you open it to exploits. Building a blog from scratch with an average to intermediate programming level? That person is pretty likely to write some poor code that's open to exploits.
Was posted just a few days ago.
&gt; we've used countless CMSs and the conclusion I've come to is that all CMSs are awful. Yup. Same for forums and eCommerce platforms. And the sad part is, all the most popular options in each category are the most awful of the bunch.
Might as well ask here since it's kind of related. Should I use request handlers even if they don't completely replace a controller action? For a specific example, my users can edit their profiles through the user dashboard, but admins can also edit their profiles through the admin dashboard, so I have two different controllers with essentially the same code (because authentication and authorization is done via middleware, the only thing that changes across these controllers is what specific variables are passed to the view). Should I move the business logic to a UpdateProfileHandler and call that in my two controllers?
I would argue that the business logic goes in a domain element (e.g. a Service) that each Request Handler would call. (Request Handlers replace Controllers in the OP's regime.) Doing so gets you one step closer to [Action-Domain-Responder](http://pmjones.io/adr).
[Previous discussion](https://www.reddit.com/r/PHP/comments/71pwxe/goodbye_controllers_hello_request_handlers/)
Yup, I agree. I tried writing unit tests for my controllers and it just seemed purely academic only to say I had unit tests. Behavioral/Functional/Integration tests are slower, but actually test what the controllers are doing.
what magic? using __invoke()? 
Maybe it would be more clean if explained how they are filled. So first of all there is the $_GET, this represent all the values passed in a GET request. These are the values that are appended to the URL. You usually see them in the form of ?id=42 or ?post=some-post. The format is always the same, there are pairs of values seperated by a &amp;. The ? is there to reconize that everything following in the URL are values. So for instance if you have the names id and amount with the values 42 and 12 you would have: ?id=42&amp;amount=12. What does this mean for the $_GET? Well, the values in the URL are translated as an array by PHP. So this: ?id=42&amp;amount=12 becomes the following and is assigned to the $_GET. ['id' =&gt; '42', 'amount' =&gt; '12'] The same goes for the $_POST variable. The data is passed as the body of a POST request and has the same format we saw with the get variables. So if you have a form with the fields initials and name, when filled in and submitted the request body will be: initials=JB&amp;name=John This again is translated to an array, which becomes the following but is assigned to the $_POST variable. ['initials' =&gt; 'JB', 'name' =&gt; 'John'] So in a nutshell, the $_GET and $_POST (and other global variables) allow for passing (outside) data to your PHP script which you can use as input. This data can be part of the request but also server information or session data. *ninja-edit: formatting*
Again?
Someone needs to get /u/ltaramaki a blog, I'd love to see them condense their opinions into actual articles. Seems like they seek out discussions they disagree with and give really interesting responses on why they disagree with a point, but I want them to take that passion and start pushing ideas that they agree with because right now I don't really understand this person's angle. Do they actually want to help move php in a better direction or do they just like to retort to things they don't like on reddit. I hope it's the former and we can convince them to start putting that energy towards something they truly believe in.
It *is* a magic method 
[Obligatory](https://github.com/mrkrstphr/array-config).
Okay that’s explained in a better way. But what about his code example. This is a snippet from a php site that stores information of books, movies and music. Why is “ address” in brackets. if ($_POST[“address”] != “”) { echo “Bad form input”; exit; } 
https://github.com/jtet/MiniConfig
Something along the lines of "you should quit your career as a developer".
I actually ignore that user through RES. I rarely care for their content and never care for their tone.
Only reads a single file, no ArrayAccess, no tests. Last update 2012.
Ha! good one. That's exactly what I was doing before I wrote this.
seems like a distinction but not much of a difference. If you organize your code as Route/handler instead of Controller/action what has really changed? The code doesn't even superficially look that different. You can use \_\_invoke() and have a callable class or you can call an instance method instead. what difference does that make? the fundamental design pattern here is registering a callback to a URL route with the design contract of HTTP Request in, HTTP Response out. Splitting hairs about the names and syntax of related but superficially different ways of implementing that contract seems like a waste of time to me. 
So the main difference looks to be that it's a hard enforcement on only having a single non static public function for a controller. Any app that isn't too CRUD heavy would most likely benefit from this enforcement. In fact, in Laravel you could reduce the 'Controller@action' usage significantly by using this and then making sure you use the resource method for any CRUD classes.
That's true, but "Controller@action" is also a magic string. One is simply more magical.
yeah well so is __construct(), so I think we need to go deeper than semantics here. 
&gt;No thanks. Magic is bad, mmkay. I'd argue that this is less magical than the "Controller@action" string. &gt; You shouldn't really need to write unit tests for your controllers. I agree with this. Either feature and/or integration tests should cover controllers.
&gt; I'd argue that this is less magical than the "Controller@action" string. How so? Controller@action is explicitly defined routes.
I used to feel the same way because they'd write globs of text circling around you to defend a point, but always never have time demonstrate their point in full and expects the reader to just know which is one thing I disliked about some of their arguments especially when they went against /u/pmjones in some threads. Even when say Anthony Ferrara disagreed with people, he'd write really in depth articles to demonstrate the point he was trying to make and that's one thing I loved about his content even if I didn't see eye to eye with everything they said. If we can get this person to do the same, it may or may not be really good for the php community.
It's a string that's magical and it's a unique magic string for every single route. The `__invoke` never has to or even can be renamed.
That, and in filter/map/reduce, "filter" filters items out and doesn't modify them in any way. Probably best not to overload the word too much.
I thought there would be an empty source file in there... but nope, not even that.
We use the "just don't be too weird" coding-style. Works pretty well for us. Minimal bickering, mostly legible code.
Really depends on how it is configured. There's nothing magical about saying "*this* controller and *this* method handles this route".
Thanks for your answer and providing me with some more pointers. Let's say I were to keep using socket_write and just split up the string from the stream myself are there any other big disadvantages to using something like socket_write? I am thinking about using Redis anyway but I would like to get this example working properly just for the heck of it.
It's magic by definition. I'm refering to this definition: https://en.wikipedia.org/wiki/Magic_number_(programming) &gt; Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants `::class` is our named constant from the article.
As I said, the values are converted to arrays. The brackets are for accessing values in arrays. See the manual for more information on that http://php.net/manual/en/language.types.array.php#language.types.array.syntax.accessing
But it's not magic in the fact that you know exactly what is happening just by looking at it.
It has been optimized beyond your wildest dreams.
No, no real other disadvantages. You'll just have to take care about properly handling the boundary splitting.
I agree. If you need provide VALUE for the business, WP is the right way to go. Tons of plugins, good integration. Also, if it's a complex site, you will have to apply some PHP skills now and then.
No environment support? I think the biggest caveat to handling configs is environment independent settings. Anybody can create a php array[] configs. Your true magic should be handling environments, overloading, and locked values. I should also note: config management is mostly done through frameworks now. This could be useful for custom projects. But, admittedly, these days when I start a new project, I'm almost always starting with a Laravel, Lumen, Symfony, or Slim base.
Yeah, definitely a good idea with environment variable support. I don't use environment variables (or a .env) on the particular project I am using this on. You can override stuff easily. Just read from a second file or add config from some other source. Locking was something I considered but I didn't need it yet. Pull requests welcome like I said :)
It's cool, I submitted a PR so people with slightly older PHP7.0 can still use
Were those file readers inspired by https://github.com/samrap/gestalt by any chance? ;)
Mostly this as well but due to spending time in C#, something I've adopted from their standard into PHP is private variables are noted as `private $_var` and public is simply `public $var`; One thing I've started doing myself is `private function DoSomeAction() : bool` and `public function doSomeAction() : bool`.
Maybe? I did read the code for several php configuration libraries before deciding to go down the path of writing my own.
I was just curious. I'm the author and was like hey that looks familiar! Anyway, package looks good. 
That's not always the case. Also you could say the same thing about using something like `PostCreate::class` versus `'PostController@create'`. The amount of information that you know about them is the same. One is just a named constant.
I disagree with using `$_var` for private variables. Property access controls make it redundant. In PHP methods are not case controlled, so your second example would cause a runtime fatal error due to duplicate methods: https://3v4l.org/MIHho
Cool, there's a name for it! I've never read it called "calisthenics" before.
Seemed awfully handwavy. I was expecting a full-throated condemnation of the horrifying actions of the Drupal leadership in relation to Larry Garfield, but actually it was just a vague complaint that sometimes fans of [Laravel/Symfony] aren't very complimentary about [Symfony/Laravel]. That's true, but it's no worse (or different) than the vi/emacs debate, or the spaces/tabs debate, or any of the other silly things we devs like to argue about while waiting for something to compile, or deploy, or a test suite to run. &gt; The global PHP community continues to toxify itself Yes, but none of your examples show this. Maybe you should have talked about Drupal? &gt; I’m not a member of the sub-community this second issue revolves around, so I will not explore it in this article. That makes no sense. "I'm not totally biased by being caught up in the problem, so I better not say anything"?
Using invoke here is dumb, but a normal method defined on an interface the class implements will yield the same benefits. It’s a good pattern that works well. 
&gt; The amount of information that you know about them is the same. No it isn't. I wouldn't have the slightest clue what `PostCreate::class` is doing until I looked at it. But it doesn't take too much thinking to assume that with `PostController@create` would be a controller called `PostController`, and a method called `create`. As an aside, that's a weird syntax - does something actually use that?
You can call it PostControllerCreate if you want, that's besides the point. The information they give can be exactly equivalent. You could even specify `Controllers\Post\Create::class` if you wanted to. What weird syntax are you referring to?
Jesus, what's being being described is very exciting. I hope HBO buys the rights and turns it into drama series, I'd totally watch that one hour a week.
Magical runtime-resolved method calls are not "composition" either. It's more in the territory where things completely lose structure and it's impossible to tell what is what anymore.
Do you ever stop to think "...why", or do you just write libraries for the heck of it?
The form serves the purpose. What problem is solved by *THE* clean architecture? It is dogmatic to claim there is one clean architecture. Even if what you study is as limited as "server side rendered forms with a bunch o' business rules", there isn't one sole good way of doing it. If you have 10k queries a second, or the opposite, when the software will never get modified for the next 10 years. "The right way to build houses. ". Well luckily my wooden cabin is not built like 1960 Russian brutalist architecture.
&gt; Someone needs to get /u/ltaramaki a blog Oh shit, someone get them a blog, they're apparently unable to find the "Blog" button on their keyboard! I'm negotiating with Alex Jones for a slot on Infowars. I'll rant about PHP and sell fake survival goods.
I'm disappointed to see so many people shun the Facade Design Pattern with modular Singleton Instances. Modular objects and wrapper classes (from my experience) seem far more flexible than namespace incarceration, but it is really subjective to the size and purpose of the code within project, as well as developers involved. I'd rather use the most minimal amount of code as possible. Most frameworks seem to be pretty awesome for rapid deployment, but can be overkill for many basic web/cli applications. Sadly, pretty much every job ad I see these days expects you to be some framework-reliant junky and disregards people who have created their own personal frameworks and code libraries.
You joke, but I'm sure people want to see what's really shaking in that brain of yours. 
Or blank lines before return.
I don't use the same names. That's redundant. Using Laravel, my public functions are named for the URI they are linked to and private functions are for a specific task so `public function getUsers()` and `private function FetchAllUsernames()`.
Not all 3rd party code is equal. Laravel packages, and all composer packages for that matter, are curated by a community of programmers. Wordpress plugins are generally not curated by anyone because they are not built for programmers. They are rated based on their utility, not the quality of their code. WP plugins are not a trusted source. Surely you see that? &gt; Sometimes it really is a better tool for some jobs. Completely agree. I just think the only reason to use wordpress is that your client is used to it. Or there is a particular set of plugins that you need and trust. But for a blog? There are plenty of better options. Pyro, Bolt, October, Grav, Statamic, and the list goes on. All are better than wordpress for most use cases.
For those worried about __invoke being too magical, one could also implement an interface and call a particular method instead, like, say, doAction. If you're fancy about it you could also optionally have methods like doGet and doPost, answering to their respective HTTP verbs. Name the interface Servlet and the cycle is complete. On another aspect, we could also ask ourselves why the request handler would actually be a class. There is no state and no polymorphism. I suspect it's just to fill the lack of ::function for resolving function names statically and the lack of function autoloading. For the latter, in most cases we could just glue all functions in a single file anyway. But I digress.
Yes, Laravel core packages are curated. Safe to say core WordPress and core Laravel are carefully vetted by each core team. But nothing is stopping a developer from installing a random Laravel package the same way nothing is stopping a developer from installing a random WordPress plugin. I completely see your point (WordPress has a lot of crap), but it's ultimately up to the developer to vet contrib plugins for any platform. WordPress with the right plugins is a perfectly acceptable CMS with many use cases.
What is old is new again
This is not the right place to ask this question. &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required) Your question is also extremely vague. YOu'll need more details if you want to get help. 
None of the sample code actually does anything I would want a controller to do, so it is hard to see how this is useful. I'm also not sure what qualifies as a "bloated" controller, is that 20 lines of code, or 200, or 2000? Also, I see you are writing classes that have no properties. So this is really just a pursuit for a *functional* approach for the problem that just happens to use a lot of cumbersome class syntax. Next thing you know you'll be re-implementing the idea of instance variables using closures.
This isn't the right place for web dev help, however this issue has frustrated me several times before. The two main issues of restricted/denied access in a php file are as follows: 1. Misconfigured/Strict webserver config: If you're running Apache, for example, you won't be able to access a directory's contents if the directory's config contains `deny from all` without any special allowances. 2. Misconfigured file permissions: If you're trying to access index.php, make sure that the user that the webserver runs as can read and execute the file. For directories, I run `chmod 755 [directory]`, and for files, I run `chmod 644 [filename.php]` Depending on your experience, I'd do some combination of trying these two options and posting to a more appropriate webdev-related help subreddit, along with providing more details about the issue. 
Oh hell that shit ain't getting into any application I work on. It's cool that it's possible, but please work with JavaScript if you favour prototyping. 
The word "Toxic" is now being used in blogs to amplify drama for clickbait purposes. According to bloggers every programming community is toxic. That being said, to apply that word to the PHP community when I am reading articles like this about node: https://medium.com/@bgourlie/nodejs-leadership-is-a-toxic-mess-34e2b8faa003 Sure we have our drama's too. But so far they seem less serious than other examples and the bulk of the community gets shielded pretty well from most of the politics. Personally I think you are all great and I love the PHP community. I think PHP actually has the best community. I've had disagreements but rarely a truly bad experience.
Hey hi ! I wrote about this on my blog: http://not-a-number.io/2017/PHP-experimentations I explained where it came from. Right now I don't have a clear idea on how we could use it, but I think it can be used as a very simple plugin system.
Well, I don't know about Drupal 7, *maybe* \_\_get/\_\_set/\_\_call based objects make up a "simple plugin system there". But anywhere outside Drupal 7's legacy, adding methods at runtime is a very undesirable feature and not helpful for plugins at all. There are very few, outright exceptional situations where these magic methods are the right solution. They're not discoverable via autocompletion, not error-checkable, not refactorable, not inspectable. So the reason you don't see more things like DynamicObject is not because it didn't occur to people - it did occur, and they decided "nope, that's a bad idea".
Why are we calling this "macro". Is this another one of those Laravel-inspired neologisms, where Taylor Otwell takes a word and completely changes its meaning? Dynamic methods are not a macro. Macro is a preprocessing construct that is converted to valid source code (or other kind of final output) by a preprocessor.
&gt; Bug classes killed &gt; system injections - We’re kind of killing it by filtering the $, |, ;, ` and &amp; chars in our default configuration, making it a lot harder for an attacker to inject arbitrary commands. &gt; mail-related injections - We’re killing it by preventing any extra options in additional_parameters. &gt; Session-cookie stealing via XSS - The goto payload for XSS is often to steal cookies. Like Suhosin, we are encrypting the cookies with a secret key, the IP of the user and its user-agent. And so on. So basically this "security module" is like an elephant in a china store, walking around and clumsily breaking things with the best of intentions. What a nightmare...
What are you trying to accomplish by posting this here? :/
Nah I like that one
Ugh, I became dumber after reading that article.
You're not saying "*this* controller", you're saying "a controller with *this* name, within whatever namespace the router happens to be prefixing at the moment". And yes, there are applications where not all controllers are inside *App\Http\Controllers*. I'll take something I can *Go to Declaration* over that any day of the week.
The think the advantage with __invoke is that it exists on the language level rather than the library level. And although they're generally very good, Laravel may be subject to the developer's whims. At least the language goes through very public RFC etc.
Ok, it's a bit "dramatic" when people try attack personal lives, but you will have fools everywhere. To be "attacked" for the ideas you have, or the code you dare to publish, there is no need for a person to feel offended, or attacked. The beauty of it all, is that it widens your horizon. All comments can give you more insight in how others try to solve things. It doesn't matter if you are going to change the code, but give you insight in more possibilities than you knew before. I never feel offended of attacked. If a person is willing to give comments on my code (positive or negative), they must love me somehow to spend some of their valuable time just for me and my code. ;-)
&gt; implement an interface and call a particular method instead, like, say, doAction. This would break LSP since you will eventually have different signatures of this method which will increase pre-conditions in concrete implementations of this handlers. With `__invoke` you don't have such problem since it just treats objects as callable. They could have different types, different policies for argument resolution and still you don't have to know exact method name. This is not magic. &gt; have methods like doGet and doPost, answering to their respective HTTP verbs. What value you will get from such prefixes? Your handler's class name will be much more self-descriptive. class RegisterUserHandler { /** * @Route("/users", methods={"POST"}) */ public function __invoke(RegisterUserRequest $request) { } &gt; why the request handler would actually be a class. This is really good question. The only possible use cases for "handlers" to be a separate classes, is orchestrating logic (Application-level services if you wish). But in this case we need to decouple this services from HTTP and we also need clear command/query separation (write operations doesn't return anything except maybe identifiers of created entities/resources, and read operations doesn't cause any side effects and idempotent). In this case your "handlers" will be just "use cases". And this would be pretty nice. From this point of view I really don't understand goal of this request handlers. If this handlers still working with HTTP then it's more likely will break SRP than controllers which only responsibility is to map http requests into method calls and map results of this calls to http response (http adapter). Making each action thin (in order to not break SRP) and also as separate class is very verbose and doesn't bring any value. This is handy only in case if you are putting orchestration/business logic in controllers.
Drupal 7 nor Drupal 8 has nothing to do with that library and concepts. As I explained, this is something I had the idea to do when I saw how the peridot-php/leo library was done, 3 weeks ago. Thanks for your feedback, it's always good to have feedback.
Then the connection between this library and "plugins" is even more vague I'm afraid.
So I checked and... yeah... it is... So I guess "macro" joins the club of "facade", "realtime", "pivot table", "tap" and others, that have a "Laravel meaning" that's completely unrelated to their actual meaning.
Stopped reading after &gt;Did that just blow your mind?
Kills me they went with Yoda. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Have you tried using satis? It also allows you to access all versions in zip format. That is what we use and never felt that we need a standalone commit for versions, however tags with annotation/message/comment provides you a similar list with datetime, person, hash, comment etc. So how it works at us: 1. dev creates PR, 2. maintainer merges and tags, 3. Bamboo builds, tests, 4. on success Bamboo runs the satis build, 5. everyone can check the satis page for libraries and add the repo to composer.json to install from zip.
The import part of config is ability of checking in as much as possible if it to the repo. And have there be different values per environment. Without that this seem to ad very little. 
What the difference? You still have front controller, you still have actions which are now called "request handlers". Some frameworks in other languages (like this: http://hanamirb.org/guides/1.0/actions/overview/) do the same, but they do not call it "request handlers". 
&gt; why the request handler would actually be a class. Maybe because of dependency injection? How can I inject dependencies into a Handler?
Security is not something you can get with a plugin. It's a way of thinking that must pervade every function your write. Blacklisting will never truly work for security. There will always be other attacks. These types of extensions are a terrible idea - they give a false sense of security and will frequently break existing code for no good reason (for example this extension will break some command executions that are perfectly safe when all the values are coming from pre-checked known-safe data) while not actually solving the problem. In my opinion developers should steer clear and learn how to write better code. In my experience security often goes hand-in-hand with good error checking anyway. Developers should always be asking themselves: * What could go wrong with this code? * What happens if an unexpected value / file is encountered? * How can I check the value is what I expect before acting on it? Unexpected values aren't always malicious / intentional. I've seen browser extensions that will upload files unexpectedly or mangle values submitted in forms. Files generated by code can be broken by error messages being sent to the file instead of logged. It should also be noted that the [Github Readme] has a big "this is alpha software - do not use in production" notice: https://github.com/nbs-system/snuffleupagus/blob/master/README.md I would also like to see some benchmarks on the performance impact this extension has and the results of testing against common applications (eg. WordPress). I believe a better solution to many of the vectors this plugin tries to resolve is an IDE plugin such as [PHP Inspections (EA Extended) for PHPStorm](https://github.com/kalessil/phpinspectionsea) which points out potential issues at development time rather than trying to resolve them at run-time. It also allows the developer to ignore warnings when they know it is safe to do so and provides links to documentation explaining the problem to educate developers.
&gt; in fact, a guarantee that the object will never change its state Are you sure? $response = $response-&gt;withHeader('Content-Type', 'text/plain');
everyone and his mother is going to blog about ADR for the next 5 years. it kinda annoys me how everyone is rehashing the same content over and over again just to sound cool
I agree with tests for controllers are not that relevant but disagree single action controllers are "magic". I think it's a valid but opinionated approach and should be used if it's suitable.
Yes, quite sure: method `withHeader` returns new instance of `$response`, hence you overwrite the content of `$response` variable to get that new instance.
Wow, so this is basically a monkey patch, right?
I do see the utility in organizing everything in terms of folders (namespaces) and files (classes) instead of controllers (files and folders) and functions. Rather than being scrolling up and down like a maniac in a controller going to the file where all your code is contained seems pretty cool. 
&gt; PSR Naming Conventions I personally don't like this part of PSR. What the point in "Interface" suffix? Interface is a way to say, that you want an object which is a "Bread", but not a "BreadInterface".