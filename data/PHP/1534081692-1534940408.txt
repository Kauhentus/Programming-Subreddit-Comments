Do you think that mechanical engineers machine every part they use from fresh metal blocks? Do you think carpenters cut down their own trees and mill their own lumber every time? No, they use tried and tested solutions invented by someone else and fill in the blanks with their skills. If I'm writing a database-driven application, I'm going to use an already written, well-tested ORM and DBAL. Just as when I put together a fence for my backyard - I could have milled my own lumber and smelted my own nails, I could have bought individual planks and put it together over weeks - instead I bought already made sections and an already made gate and only resorted to one step down when I had to fill in smaller areas.
In the past I did a lot of contact work, and the model that worked best for me was to have three distinct hourly rates for work: normal, urgent, and emergency. When providing a work estimate I would show the cost and deadline associated with each. Obviously urgent was higher than normal, and emergency *much* higher. This helped to shape client expectations, and inform reasonable deadlines. 
Can't repositories and loggers be injected as function parameters just the same? As long as you don’t mind the amount of parameters.
Depends on where you draw the line, sure. It's the difference between the two scenarios: * router gets the handler instance from the container without knowing or caring about how it's wired up and passes incoming request information to it * router creates a new instance (admittedly not relevant in this case) of the handler and gets every single of its dependencies from the container to pass along with the incoming request information.
Depends what you mean, in regard to actual frameworks to an extent I agree, the modern trend in programming is away from frameworks (or at least monolithic ones like Laravel, Cake, etc), if you use Golang, Node, etc then it is much more toward the use of picking individual components / libraries (albeit in Node usually on top of a minimal framework like Express). If you mean not using libraries/packages either and writing everything from scratch that is not included in the core language, then well, I just echo what others have stated about not reinventing the wheel, peer review, etc.
How can I google help for this? I'm teaching myself php now.
The values of the `name` attributes in the form aren't the same as the indexes you're looking for in `$_POST`.
https://en.wikipedia.org/wiki/Not_invented_here#In_computing
This is an exagerration. 
Hi r/PHP, I understand the importance of prepared statements. But should one be used for every query? Even ones that the user has no control over (for example - before page load)?
It's good convention to pull out all variables anyway. It's very easy to think some data is safe while it's really coming from untrusted sources, ie a database value that previously came from a user or 3rd party system/api.
Security is not the only reason to use prepared statements. Prepared statements can also be cached on the DB side, saving a little bit of time that would otherwise be spent parsing the query text into something the DB can understand.
From a habit-forming perspective, it’s a good idea. It’s also typically more tedious to work with two different apis. But if it’s a completely hard-coded query with no variables present, it won’t impact security. 
I would say it isn't necessary for SELECTs without any WHERE clauses or any other uses of variables. But even then, it's probably worth it to stick to prepared statements. It's just good to make it a habit. Plus, if you or someone else later decides to change the SELECT statement to now include variables, there's no chance of forgetting to change it to a prepared statement.
My own guideline is: if it has parameters, a prepared statement is required. Otherwise, prepared statements are preferred but not required. If code uses a prepared statement in the first place, any developers that make follow-up changes will usually do the right thing if they have to add parameters. I've seen parameters added right in to direct queries... Even by seasoned developers that should know better. :-/ Specifically regarding the "before page load" thing, you never know who's gonna screw up data at some point. A prepared statement is probably still save you a bug at some point. (That said, there's an exception to every rule. If you understand the pro/con, go nuts.) 
If the query is constant and run only once, then no. Otherwise, yes prepare everything. You can read a thousand articles about different ways to write stable code, but they all boil down to "make sure you know what data this code is responsible for". As soon as you add reasoning into your code like "it's probably okay to not prepare this statement here", that's not a decision you need to make once, but for you and every member of your team for the entire life of the product. You've changed your code from a very simple abstraction (run a query, return some results), do one with an extremely complex dependency (this query will never be run by anything with inputs we don't trust 100%). If you repeat this approach throughout your code, instead of writing a program where you can read one file and understand what it does, you need to understand the entirety of an exponentially more complicated codebase to make sure your changes work. 
Just a few questions: - Do you know how to mitigate a session fixation attack? - When and why do you use constant-time string comparison? Also, did you know that was a thing before I asked? - Do you use CSRF tokens in your homegrown code? - If setting up an account recovery process, how do you securely implement that? Libraries and frameworks are the knowledge of their contributors, crystallized into text. When you use them, you use the knowledge of the communities that made them. When you build everything yourself, you sever yourself from the community.
It’s not just security. It’s also performance issue. MySQL for example caches prepared query and just adds parameters when it’s executed. It’s faster because you use String concatenation it caches each query separately.
Yes, really. This question makes me think OP is not practicing good separation of concerns, actually. 
Why not? You are future-proofing things and it really costs you nothing... so... why not?
I think most people have wrapper classes or frameworks that will generate the prepared statements, so you don't have to do much work yourself (e.g. doctrine)
How is this an exaggeration? This is quite literally how you set up both authentication and authorization in laravel? (given the added configuration for roles/users/permissions - but that's not exclusive to laravel but to any custom stuff, too, so that doesn't count). Personally I'm not a fan or Laravel either. Actually, I quite hate it - I'm pretty much a Zend Fanboy and I'll always prefer it over Laravel but noone can deny that the tooling options of Laravel are leagues ahead of EVERY other php framework out there. And Laravel as a whole highlights the best why frameworks are so much of an advantage over custom development when it comes to "default tasks". 
Nor can you do that with your own custom solution. Again, it's about the logic stuff for auth* The configuration - ideally - would be identical in both scenarios.
why wouldn't you? Some one has gone through the effort of making sure its secure, optimized, easy to use (laravel) so you can build the app in say 6 months instead of a year, where 6 of those months are used to architect the solution. While yes there is a level of achitecting with premade solutions, the complicated aspects of security from a form input down to the SQL level is done for you. why re-invent the wheel for every system?
&gt; in an application where timing is important, you might have to rely on these practices. provide an example of such an application and a measurable improvement gained by means of implementing such practices. Thank you in advance.
why would you share something so badly written and riddled with security issues?
You can inject them in constructor, same way. 
Not using "strange" syntaxes on the router and supporting refactoring controllers for example... 
That's a myth. Modern databases will cache everything that can be cached with a benefit, whether you prepare or not. The tokenization of the query is absolutely trivial itself, so whether you go parametric or interpolate values is irrelevant, unless you want to insert, say, a large BLOB into the database (which is a bad way to use a DB in general).
I prefer unique class names when possible, for me is positive, but I guess it's up2you totally. 
The specific values are not the only thing that changes in a query. Many queries are built conditionally, say, based on what criteria the user is including in their query etc. So this "it should never be manipulated" concept is nice, but it only works in very simple, basic apps. 
The question is, *why you're trying to bargain*? Is a prepared statement is THAT hard for you to use? Why not to ask how to make it easier then?
The general guideline I observe is that unless you are doing something uncommon and specific you should never be writing SQL queries and using as much as possible an ORM.
Sorry for my ignorance, but in which point is SingleResponsability violated in this case?? 😅 😅 😅 
yes, and make it a habit
Single action controllers in Laravel load all controllers unless you cache your routes. Be advised, on a shared dev environment, this means if you have some compile time / load time error your development process will be crap and will crash out every route for one bad controller. One way around this is to specify @__invoke on every entry (not just the class). They're second class citizens.
we're talking about stand-alone functions, there is no constructor.
let me guess you're writing a very large but very simple query and you find it tedious to put in all of those parts of the prepared statement. Just use a query builder for 99% of your apps needs. It Williams prepared statements for everything automatically. The only time you will need to manually do prepared statements is for a handful of occasions were the query-builder code is harder to understand than a manually written query for the query Builder is not able to fully Express the query that you need.
I disagree. I deal with a lot of stuff like `"SELECT id FROM users WHERE disabled=0 $subQuery"`, `"UPDATE articles SET (?, ?, ?) WHERE id=?" . ($parentId ? " AND parent=?" : "AND parent=null")`, general catenated queries and such at work, and I don't think there is a single situation where that is the correct move. If you need to add or remove parts from your query, that should be isolated to a function or isolated into entirely separate query variables.
Examples would be outside of the scope of what you should do in PHP. If you were do a VoIP application, you need to do some sort of analog to digital/digital to analog conversion, along with compression, this operation end to end take greater than 50 ms, this would cause for a noticeable audible delay. While 50 ms is a pretty long time in the sense of computing, but there's a lot of stuff that need to happen end to end in a VoIP application. Video gaming, you have a lot of things going on at once. If you have something that deals with sensors and you need to perform PID type correction, depending on the application, tiny amount of speed increase might be (hypothetical) "It works fine and we get 30 MPG", to "I works great and we get 40 MPG". Also some of the micro optimizations might not be about speed, but might be about memory usage. If you are developing something on an 8-bit microcontroller, the savings of a couple bytes of data might determine something that works or doesn't work, since you are very limited on RAM and ROM space. But typically you would want to say these types of optimizations for last and tackle the optimizations that actually give you the biggest gains with little effort first. Like I said before, these type of micro optimization are "last ditch" efforts, since most are little gains that take a lot of effort.
There is. Try it. The instance is constructed correctly 
More info here https://jenssegers.com/85/goodbye-controllers-hello-request-handlers
If the query takes user input, then yes. Otherwise, no, from a security standpoint, you don't. But there's really no reason not to, so just do it.
Seperate *variables or functions*, so no string manipulation on the actual query. I am cleaning up a lot of stuff like that at work, and I can't think of a case where you have no other option.
Hey, BayLeaf-, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
Okay, so say you have a `posts` table and you want to conditionally select some stuff based on user-selectable options. Let's say we have the following fields that the user can search by: - title - age - category The user can select all or none of these. How do you write the query in a way that is not conditional?
These are callable classes, not stand-alone functions.
Look at the root comment of the thread you're responding to and read it carefully.
You're right, sorry, of course single functions doesn't work for this. My fault. Regards 
Every statement that has parameters in it, yes. Anything else, maybe, but not necessarily.
Sorry - it looks like your post was removed, so I can't see it anymore. I'd be happy to analyze yours if you want to paste it again.
Yes, there's tons of PHP work available for junior developers to seniors, and even all the way up to people that get paid five times as much to clean up the messes they made.
This should be amended to say if the query uses anything that the user can manipulate. something.com/articles/article-slug-here doesn't take user input, but the user can manipulate the url/slug, and assume that the slug is in the DB somewhere.
Just learn whatever catches your interest. Anything. It does not matter what. There are jobs everywhere for everything and even if it’s not the language you know most jobs are fine with cross training you from Python to Ruby or Node or whatever. 
They're good for business. I make six figures working 20 hours a week fixing codebases they ruin.
Agreed. People generally want a quick fix for a fraction of the price you’d normally charge. Noticed this with other languages as well. I normally ignore them, not worth it. 
If it comes from a user, it's user input.
Usually, I will take an approach similar to this. Note: crusty code just for example sake. And I'd probably be using an ORM/DBAL so I could just chain methods in practice, but you get the idea. $query = 'select * from posts where '; if ($title) { $query .= 'title = :title '; } if ($age) { $query .= 'age = :age '; } if ($category) { $query .= 'category = :category '; } Now, this does look ugly, sure. There's a number of ways you could make this a little prettier. But, ultimately, for this kind of functionality implemented in code (so, not using stored procedures), this is where you'll end up. &gt; is something you should be trying to make a single line of SQL Were we only talking about a single line? I pretty much *never* have a single line of SQL.
I'd argue that it's the single biggest market for php devs
It doesn't matter. Many people do not want their work handled by foreigners.
I used to be a full-time freelancer. It can be very profitable. The only thing I didn't like was getting jobs to fix other people's work, which can be common with php. 
Most MySQL drivers I've seen do not actually use server-side prepared statements, they just emulate it on the client side. So you won't get any special caching. 
Where?!
This
You're not wrong
Agreed. Only mentioned that because some people may mistake user input for form input and disregard things like urls or ajax.
This. 30ish percent of the Internet is a good place to stake your flag. Also, with the emergence of Gutenburg, it’s going to be a great time to learn a JavaScript framework like React. There is also a lot to love about Laravel as well. 
Very
Assuming up-front that *every* query variable can or will be manipulated by a user will keep you out of trouble and will make everything easier to develop.
more information?
If you're using strict types and the user input is an integer, is it necessary to use a prepared statement.
I entered freelancing wanting to work with front-ends and JS. I do, but more and more of my work is naturally becoming PHP. I'm picking up custom WordPress, older web apps built in frameworks like codeigniter, and ecommerce sites using frameworks like Sage, underscores, etc. At the very least, you should be familiar with the language, even if you're not a backend dev like me. There is lots of work, from brochure ware WP sites, to custom web apps built with older and newer PHP frameworks(think Laravel and the likes). Some PHP devs make bank. 
No, no one has ever made any money with PHP...
This should be amended to say if the query uses any input. 
For the average PHP user it's hard as hell to tell what a user can amend. So you can tell that adding "user" to input is a call to disaster. It simply should be any input. As simple as that. 
Yes
Do clients tend to come to you or do you use a platform like Upwork?
React is great because it's such a large community and is well established, but if you're just getting started I'd recommend trying Vue out. It's a great framework as well and the documentation sets it apart. 
But, dumb question, where would you use it and can you get a job from knowing it? I am divorced and really need to step up my "get a good job" game! 
The only reason I mentioned React is because I think Gutenburg is built with React. But I personally love Vue too. Im starting to get into Laravel which has Vue baked in, so im loving it. I just wish there was as good of a Laravel/Vue CMS as Wordpress for client work. 
No, but it may be the beginning of a new one, haha! Just got a position doing Magento 2.
That's what I just did. They were storing passwords as plain text.
Something like half the internet runs on Wordpress alone, on top of all the other PHP frameworks and CMSs. As long as this is the case, PHP will be a safe choice.
Ya, I've seen that among other huge problems. The worst is when you fix work from someone who was using a ton of libraries and frameworks, but then strangely mixes in raw code and entangled them. My God. 
Go back a few years where the choice was mainly between raw queries and stored procedures. You'll see why prepared statements are a gift.
Correct. If it's got any sort of dynamic component to it, prepare that shit! And no, it doesn't have to come from a user as others say. If you get data from another system and use it in a query then you prepare it because otherwise that OTHER system becomes an attack vector. The only query you don't need to prepare is 100% static - and even then, what harm comes from preparing even that? Prepare ALL the things I say.
Why? Given this function: `function getPost(int $id): Post` What value does using a prepared statement provide? 
This guy refactors. 
If $field_first_name = $_POST('fname'); then isn't the first half assigning a php name to the information pulled from the html? I'm good at html and css but I switched to WordPress fully about a decade ago. My long-term client just had his college-age daughter make a website and none of it works, so he dropped it in my lap and now here I am learning php to fix his site.
If you look at the comment with the errors, it says that I have "Undefined Variables" in all but the drop-downs. So I googled that term and learned how to define those variables. The error stopped for the one line I tested it on, but the email I receive still doesn't have any submitted info in it.
The error lines are in a separate comment. Here is an image of the markup: https://imgur.com/psFygFJ
Ah - ok. Your problem is that your PHP script is requesting names that doesn't exist. Like this one, for instance: &gt; PHP Notice: Undefined index: fname in /send_form_email.php on line 2 In the image you posted, the input id "fname" has a name parameter of "firstname". The name parameter is what gets passed to the $_POST global. So $_POST['fname'] wouldn't exist, but $_POST['firstname'] would. You can fix this by either updating the names in HTML, or by updating the PHP code to look for the right indexes. As always, instead of assuming that content will exist, you should wrap everything in an if(isset($_POST['key'])) method so that you can avoid catastrophic failures. Also - one last thing concerning this error: &gt;PHP Notice: Undefined index: other_position in /send_form_email.php on line 7 The key you'd be looking for in this case is "position", and the value would be "other". So you'd want to do a switch statement on $_POST['position'].
can someone explain for dummies, the technicals of why facades are so bad?
Because it's the first major change to the way you edit content natively in WordPress since, well as long as I can remember. It's quite a different experience for users and devs alike. Plus there's TONS of plugins and themes out in the wild developed for a non-gutenberg interface. We can probably expect to see lots of broken themes / plugins once it's released. This could be a real good time for devs to get work fixing these problems too.
This. Also, don't forget the future, it may not take _user_ input now, but what if that changes down the line? If it starts using input from anywhere else then you'll be thankful for prepared statements. 
Yeah but there’ll be tons of Indians doing work for a few bucks 
That’s interesting. I would swear that PDO emulates server side prepared statements only when database doesn’t support them. I remember having in MySQL log queries with all these questions marks. But I might be missing how it is suppose to work.
No. But, you asked a broad question. If you don't trust your users-- parameterize. If you don't trust your co-workers-- parameterize. If you don't trust yourself-- parameterize. I always use a prepared statement to parameterize, but I use an ORM that does the monotonous boilerplate crap for me. It is cheating a little-- but, they are parameterized prepared statements, every one of them...
You completely fail to understand my argument for the sake of trying to screw over Laravel it appears ^^ My argument is that the time it takes for you to set up your "Y/N Questions" (read: writing the logic that makes the Y/N Questions happen in the first place) is way more than setting up the small config in laravels case. The time it takes to write the actual authentication and authorization logic in your custom solution did take time once. Surely it wasn't just magically there at some point. In Laravels case it takes about 3 seconds. And THATs the whole argument I've made. If - in later projects - you're re-using your own library it's no different than any other library anymore.
Laravel Forge is a convenience tool. If it shuts down, you can still manage your servers however you want. Not sure what you think you are locked into other than convenience tasks that save you time and money. Yes, I can provision boxes, set up virtual hosts, ssl certs, databases, etc. myself. I’d just rather pay a low fee to do all that and focus on things that pay me $$$. 
&gt; writing the logic that makes the Y/N Questions happen in the first place you do realize there is built in php stuff for that right? You do make a good point, though. For me it was a fun run...took a saturday to create the command line installer and all of that ... it was a fun challenge and I had never done command line stuff before.... and I did not know it was built into php until I attempted it... I still have yet to figure out how to add roles in laravel though
Oh I would never argue that it's bad or wrong to write your own stuff. Specifically in the context of learning something new or improving on something one has already learned, creating something is a great thing. I was merely giving one of the hardest examples where frameworks shine these days ;)
does it shine though? Laravel doesn't have a "php artisan install wizard" command..... 
LOL i guess that's true to an extent....but to get a project off the ground initially it could have something. but like I said that's not even my gripe with it. 
Laravel 5.7 adds this syntax: `action([ControllerName::class, 'method']);`
Uniformity.
What are you gaining yourself by adding the cognitive overhead of ensuring noone ever makes a change to: function getPost(int $id, string $data): Post And don't go and read every query in that function?
Pretty much, but any db abstraction will do this for you, like eloquent, illuminate
I made a list of the most common and most useful features that popular frameworks at the time had. I narrowed that list down to the ones I liked, agreed with, knew I would use constantly, could research and implement by myself (employer at the time has severe NIH syndrome), and could successfuly explain to my coworkers and get them to use it. 8 years later I was still refactoring the controller class and debugging the pagination class and had made almost no progress on the query builder.
&gt; forces using the best practices I would have thought that was a description of Laravel not Symfony. Symfony doesn't really enforce anything. Laravel is the opinionated one.
haha
That example *is* a single line of SQL. There are a million ways to filter like that, and I don't think building a query string conditionally is the way to go about it.
Your assertion is not true. Laravel is just as popular as Symfony here. And in general is probably more popular these days having much more activity on stackoverflow and github. They are both good frameworks. Its just a matter of preference. Laravel is more opinionated. Symfony leaves a lot of the architecture up to the developer. If you are a company like Pornhub and have a single massive application that is your main source of income then Symfony makes a lot of sense. You will want to customise your architecture to your needs anyway so any opinions expressed by the framework may just get in the way. However if you are an agency or freelancer that builds and supports many applications then Laravel makes a lot of sense. My company has a dozen laravel apps running and any of my developers can jump into any one and get up to speed really quickly. The opinionated nature of it means that we tend to code similarly for every application. But when our needs don't suit the frameworks opinions you can just ignore them. Laravel is very easy to extend and replace parts. There is no reason why you can't use Doctrine ORM with Laravel! Its all just composer packages anyway. 
I read OP's question as being about constant queries like `"SELECT * FROM sometable"` and queries that take no input from sources you consider unsafe, like `"SELECT * FROM sometable WHERE x=$constantValue"`, I was talking about the second one in my first comment. 
Once I saw a plain text database with hundreds of thousands records. Task was to move it to MySQL, without any documentation. Girl who had to do it, used reverse engineering on CMS code to solve what was what...
They offer fraction of quality job for a fraction of regular payment ;)
Got undefined index warning instead. However, use @ in front like this $var = @$_GET['var'] helps suppress warning, but get a bit slower though (not sure how slow) 
Yes, if you ask /r/PHP. PHP is not that profitable. You'll have a lot more gigs with React.
As someone who freelanced for 2 years using PHP your comment is so misguided. Plenty of work for all competent devs
Meaning you write shite code. Let me get this straight, you're writing Symfony code that doesn't depend on the framework, but conversely you are writing Laravel code that somehow depends on a specific version of Laravel? You wot mate? Laravel hasn't changed their public API since 5.1 even on the undocumented classes (basically most of Illuminate\\Support) they have only extended. Idk what sort of modules have you written that would stop you from straight up upgrading. I do have an old 5.1 project that I have to upgrade soon, but the more I look at it, starting new project and just copy/pasting the stuff from the older project and hooking them up through the autoloader seems like it would work. Even the libraries that I have, that depend on core laravel objects from back then will also work on the new framework. I know this because we have newer projects that use those old libraries. 
I spent more time fixing their code and dealing with unhappy clients. Clients realize quick you get what you pay for
PHP is very profitable. If you can do both it's even more profitable. Not sure where you get your info.
I've written at least 100 libraries and in exactly 0 of them I use Facades, because I don't like them. I use the so-called "service providers" to bind my libraries into the DI container and then get them through it, which is awesome because you can put some initialization logic that depends on the project itself and get that shit away from your library constructor. Makes the library simpler and makes it to do just one job. My biggest indiscretion is shoving the whole DI container as a dependency in one of our libraries, but you know, I figured I'd do that instead of shoving 10 classes in the constructor, seemed silly at the time. Sure this library in particular is up for refactor but so far it works well on multiple versions of Laravel. I also think people using rando facades in ... what tries to be a 3rd party lib ... to be assclowns, don't get me wrong, but you know, it's super easy to get away from it. Laravel also provides you a way of not using facades thanks to service providers and automated dependency resolving, basically, when you initialize a core class and you say you want an instance of contract/interface X the framework would find that X and inject it. And you get a nice encapsulated class with proper injection and no Facade crap. I absolutely love facades when I'm defining routes though. Makes the file super simple to see and read. 
It sounds like with modern MySQL drivers it will in fact default to server-prepared statements. Looks like it's changed since I last researched it! 
I would expect a lot more "bad" devs in the PHP space than elsewhere, simply because of the low entry requirements to getting started. They may not be genuinely bad, just very new / naive. Particularly if they never worked with another skilled developer - I didn't learn about SQL injection and similar until I was working full time, Security is sadly not something that comes as standard on the uni syllabus.
I'll try to give you some examples of what we gave to every php job applicant. It was mostly from junior to senior, but for senior role, we have some more additional questions. PHP: * Describe what you like and dislike on PHP. What would you change? * Do you know any design patters? Then ask to describe the first two in detail. * What's the difference between: ==/===, require/include, instance/static, private/protected, $name/$$name, .... * What are the differences between public, private, protected, static, transient, final and volatile? * What are the differences between Get and post methods * I am trying to assign a variable the value of 0123, but it keeps coming up with a different number, what’s the problem? * Would I use print "$a dollars" or "{$a} dollars" to print out the amount of dollars in this example? What is the difference. * How do you pass a variable by value? * Explain the ternary conditional operator in PHP? (with php 7 same question for null coalescing operator) * What do you think about ORM. Is it usefull or is it antipattern? * What kind of attack do you know, how to prevent them. * Where is session stored, how it works. * What type of inheritance that PHP supports? * What is differenc between mysql_connect and mysql_pconnect? * Check some knowledge about composer * What is api, what "types" do you know (rest, soap, graphql,...) * What is tdd, what testing frameworks do you know. * Every aplicant was given sample of the code (around 50 lines), the goal was to describe what is wrong with the code - performance, security, used global variables, sql injection,... * Do you know any memory storage (redis, memcache,...), queue (rabbitmq, beanstalkd,...),.... Just to know what else he knows, if he is trying to get to know other technologies and is reading some technical blogs where he can get in touch with these terms. Doesn't have to know how to work with them, but to know that something like that exists. * How do you debug when you are developing? How can we monitor performance of the application on production server? * What is coding style. Apache: * Describe how http protocol works (describe https for senior) * Maybe some question about mod_rewrite, but just basics, to see if candidate know that it exists. * What other web servers do you know. * Describe what is .htaccess MySQL: * What are the different table engines present in MySQL, what is the difference? (at least MyISAM and INNODB) * What are the advantages of stored procedures, triggers, indexes? * Explain Normalization concept? * What is the difference between char and varchar data types? * Short test where there were 5 tables and 3 question. For the first the answer was only about simple join and where. For second it was about joining 3 tables, using group. The third was about joining, group and to know that there is HAVING and how to use it. Others: * Some knowledge of docker or other virtualization/automation. * Do you know CI/CD, Jenkins, Travis,... For senior roles there were question about networking, like difference between TCP/UDP, know linux more (pipes, xargs,...). We didn't used apache so nothing there, but to know how to install it, setup new virtual. Know difference between mod_php, fastcgi, php-fpm. It's not important to have answer for every question. For me it was always more important that I can see that he want's to improve and is looking at new technologies and will not get stuck in LAMP only. So to have some wider knowledge and thinking is always a plus. You can always check how strpos works, but is harder to search for how to improve performance and how to cache, when you don't know that there is anything like "cache". If you don't know anything, say it. Do not try to say the answer after thinking about it for many minutes. Don't waste interviewers time, when you know it will not help you to come up with the answer. If you don't know exacly the technology (i.e. Redis) but know something similar (memcache), say that you don't know, but try to sell you knowledge of the alternative.
Another gripe people have with Laravel is Facades, and yet, like you said, there's is no reason why you can't just avoid them and use the actual DI container to inject them through constructors. But apparently Symfony devs find this too hard and rather complain about than just ... not using it?! 
Well, I'm not sure where you get your info either. I know we're on /r/PHP but if you go to any job website you'll see ads for React or Vue (depending on the country), not PHP. PHP is sometimes necessary but many new projects are implemented with serverless architectures and data gets saved using object storage services. I think OP just made the naive mistake of asking the question on /r/PHP, of course people will say how wonderful PHP is, but it's not an unbiased answser.
Yep. I'm pretty sure query planning happens after parameters are substituted as well, and query planning is far more expensive than parsing.
that I can agree with. Type juggling can be better
ooh look. Another broad statement from someone who has no understanding of the context. Such a fresh approach! 10/10
I am deadly intrigued, what do you call "before the page load"?
In OOP, one of the code concept is to split your code in classes interacting with each other. For instance, a common pattern is to use a database connection as an object in your other classes, without having to create and check the database connection itself (it's been created by another class for you). To rely on other classes in your own classes, there are many different ways, but in our case, there are two main ones: \- either you can use \*facades\*, which let you access the database connection directly using a static method (DB::connection()) in your code \- or use you can use \*encapsulation\*: you inject the database connection object into the class needing it, usually as a constructor parameter Now, using facades is easy and works out of the box in Laravel, which is probably why it exists. However, there is a huge issue with facades: you \*can't unit test code using facades easily\* (ie. without relying on something else than PHPUnit). Because you rely on facades directly in your code, you can't change the class used by your code during tests, which means it will always try to connect to a database, even if you don't want to test this connection but only your logic. Encapsulation is much better on this level: by using a constructor parameter, you allow the \*user\* of the class to give its dependencies to the class. This means you can use your class in production with a certain db connection and unit-test it with another (for instance, a fake connection), just by passing a different value in parameter. This is also why interface are so important in encapsulation: when you write your class, you need the user of your class to give you a dependency as parameter on which you can call certain methods you need in your class. If you don't put any typehint, you can't be sure this will be the case. If you put a specific class as a typehint, it means you are forcing users to provide a specific implementation, forbidding them to change the parameter value easily. If you put an interface as typehint, you only ensure what you need: that the methods you need exists. I'm not sure it's all clear, don't hesitate if you want more details :) .
No, don't suppress errors. Bad dev, bad! \*waves newspaper menacingly\* Seriously, don't get into that as a habit, it can make debugging things an absolute pain. Check that $\_POST is not empty, then check with isset for the individual indexes before attempting to use them.
Because Laravel is for people who want to look cool and Symfony is for people who want to get work done. Laravel is this decade's CodeIngiter. It looks pretty neat and does a lot for you, but when you hit a certain size it gets slow and complicated. Symfony has fewer features, but they're implemented better.
dafuq are you talking about. I've on airplanes for the past 24 hours without internet. Is your head so far up your ass that you can't even tell time anymore?
Also see [ContainerAware Considered Harmful](https://qafoo.com/blog/057_containeraware_considered_harmful.html) by [Tobias Schlitt](https://github.com/tobyS). 
I agree that service location is an anti-pattern, but I don't know if all the arguments put forth in this article are the best examples to illustrate it. &gt; Auth::user()-&gt;id This isn't really a problem with the service locator pattern. If you use dependency injection to obtain whatever the underlying service instance that `Auth` is bound to, and call `-&gt;user()-&gt;id` on that underlying instance, it's going to blow up if `user()` returns `null`. The service locator pattern didn't cause that problem, Laravel's failure to use the `Null object pattern` did. But even if the null object pattern were used, it still hides a fundamental condition of your application: that the requested path is only valid for a logged in user. There's really no avoiding having to put the conditional check *somewhere* in the application, ideally in a middleware. Whether that's done with dependency injection or via the facade, you still have to make sure `user()` is not null and to provide an exit condition if it is. There's nothing wrong with that. To be fair, if you've got `Auth::user()-&gt;id` everywhere in your application, then this is indeed going to be a problem. But either way, at some point you *do* have to trust that if you've made it to this part of the application, that you do indeed have a valid User, even if it's been provided by DI. &gt; Obfuscated classes / Increased cognitive load While I get the gist of this example, that seeing the user listed as a dependency is important, it's a bit hard to reconcile with Laravel's lifecycle. Where does that user object come from? Laravel (as far as I know) doesn't know *which* user to inject there during dependency injection. You have to obtain it via the `Request $request` that gets injected, which means calling `$request-&gt;user()` may still result in a null condition that has to be checked. From an example perspective, the below is nonsense (unless Laravel has changed) because Laravel will not just inject a user in that class when resolving this action of out of the container, as it just doesn't know *which* user to inject. class CreatePostAction { public function __invoke( string $title, string $body, User $author ): Post { /* ... */ } } If it's smart enough to auto-inject the logged in user, then what happens to this request if the user is not logged in? Does it just blow up? What happens if this method asks the `$user` object for information about its session? If some random dev comes along and goes "Oh, this action requires a user", it's not clear it requires a *logged in user*, so the problem can still manifest itself (which means it's not really a problem specific to the use of service location). I agree that this is one of the biggest issue with service locators since it's not at all clear what dependencies a class or method has, but the "extra things to think about" listed below is not at all because of service locators: &gt; Am I sure a user is logged in at this point? &gt; Should I add an extra check, to be sure? &gt; What context will this method be called from? &gt; Are there any future features in the project's scope I need to take into account? &gt; Should I add a test to be sure this never breaks in the future? "Am I sure a user is logged in at this point?" That's a business logic question to ask yourself, nothing to do with the service locator. "Should I add an extra check, to be sure?" If it can fail if yes, you should. An injected `User` can be null as well, at which point the call will blow up. So that's not a service locator specific issue. Calling context is something to be aware of even when doing dependency injection, because you still have to be sure the class /method is being resolved out of the container so that it will have its dependencies wired together for you. Future feature consideration is something you should *always* be wary of. Asking if you should add a test is again, something you should be doing regardless. But this is a good segue into the real issue: testability. It's simply *harder* to write *clear, obvious tests* for classes with service location (whether that's facade-based or by injecting the service locator directly). Yes, Laravel has test helpers for mocking out facade and service locator calls. The problem with that is that your test setups are now based on a sprinkling of magic, which can make them less obvious and more prone to having edge-case problems.
This is one thing in which you're going dead wrong. You do not, ever, for any circumstance, trust data that crosses the boundary into your application. Never. 
B.S. Unless you're building a site, product, or service for yourself, you are trading your time for money. At the end of the day, it's your fixed price divided by the hours you spent working. Since you operate on fixed pricing, do you charge for a separate and proper discovery before the project begins? Even with proper discovery, the value of the project could end up greater than the value of your work.
&gt; Your controllers are supposed to be nouns that relate to some sort of persistence layer or business entity within your application. The action is supposed to be a verb that relates to said noun. I don't think this is a universal rule. Rules like this tend to lead to names that follow a rule but aren't as useful.
You could inject the parameters by having a function take them and return a function which `use`s the parameters.
Good point. Although, does this approach have any real benefits over a callable class?
You can say that again. The web development course in my university did a hilariously good job of skipping over the basics and getting you in gear and writing the same classbook CRUD app that we wrote for other subjects, but this time in PHP, .NET and JSP. Security wasn't mentioned even _once_. When I started working as a web developer I realized how useless most of what I was taught in university was. And to give some insight (rant ahead): &lt;rant&gt; Universities in Romania discriminate so hard between subjects it's not even funny. Some subjects are trivial (databases was very useful but also had very relaxed requirements, web development was a joke as I mentioned above), but our computer architecture (assembly language) course was so demanding that about 75% of students failed the first exam. And this was the first semester of the first year, some people wrote their first 'hello world' that semester. Then you have the utterly useless subjects that should have clearly been optional, like most mathematics. I can understand statistics being obligatory, it can definitely be useful especially with work revolving data being more and more widespread. But I do NOT understand why mobile development was optional while advanced calculus was obligatory in a COMPUTER SCIENCE university profile. &lt;/rant&gt; 
Does a callable class have any real benefits? Normally objects should be used to encapsulate state and behaviour. You are not going to modify the object state of your controller (or at least shouldn't), and you don't really have any behaviour (except for one function). Functions seem to be better-suited in this case, don't they?
Yes, that moves the concern from "I need to protect this query from abusive users" towards "I need an interface where I can send in any input and expect it to be automatically wrapped for the target domain language". The security benefits are just a nice side-effect. Right now I am writing this comment in a box on the Reddit website. I expect the data to keep its semantic meaning across domains. The data is put into a black box that goes through all layers of the application without interpretation, and I expect it to come out exactly the same on the other end. Except that it *will* be interpreted as Markdown at some point; a concious decision made by the developers, not an unintended side-effect of the communication protocols between layers.
Good for you. The problem is when you receive a legacy code filled of facades. It's a huge task refactor it all... 😅 😅 😅 
I disagree highly with this. The more of the program you have sitting on the front end, the more security issues you're going to run into. Sanitation, calculation, storage, sessions - that all needs to be back end tech. Less risks.
Which part do you disagree with? PHP has been replaced with object storage and serverless architectures, which absolutely implement sanitation, storage, sessions, etc. about 100 times better than me or you (if anything, because Amazon has more resources than anyone on /r/PHP). Competitive advantage of apps is not in calculations but the idea, design, UX, ease of use etc. etc., and all of these things happen 100% on the front-end. Since object storage technologies work perfectly, people focus on what can make their app successful.
Beware that not every database driver supports real prepared statement; PHP emulates it then. That will take care of escaping, but will not help in terms of performance in any way. But that's just a good to know tip.
It's the _only_ way to go about it, save for repeating code by duplicating entire queries with minor differences (which itself falls victim to exponential explosion of parameters).
This artile is 💩
I dont think you understand what sarcasm is
Before shitting on it (I dared) just for the title, it's an ironic article, which is pro php in the end.
&gt; Every developer knows that the quickest and most efficient path to getting anything accomplished is to complain a lot and start from scratch. The market will always wait for your startup to finish building its framework first. Besides, why should we bother to offload work and rely on a language’s open source community when we can just do everything ourselves?
It's good to know and underestand certain internals of the language in order to avoid bottlenecks. So, saying that single quotes are better is stupid (because it really doesn't matter), but, for example, wrongly placed ternary operator can slow down a loop quite hard (not sure if it still does or if it was optimized somehow). So not all of those tips are bad. for (;;) { // This will always evalute to assign by value. $a = $expression ? $b : $c; // This will just set $a to reference to $b or $c internally (till $a changes). if ($expression) { $a = $b; } else { $a = $c; } }
*Be honest* - Did you actually **read** it?
If we could define our exported interfaces, we could do the same with functions. One can only dream... But in that case I'd heavily prefer not a callable class, but rather a class with a constructor and a handle method.
Yeah, I do often end up refactoring `__invoke()` to a more descriptive method name to get around this problem: https://stackoverflow.com/a/7067646/3784306
This was fantastic, i loved it!
I don't think you understand how incomplete and sometimes irrelevant your arguments are. You just picked a few numbers and interpreted them to your advantage. It doesn't work like that. &gt; However, if we compare programming jobs in PHP and programming jobs in React/JavaScript (notice, we're talking about jobs here, same thing), there will be more demand for React than not PHP, and therefore you'll get paid more. To start this off, this is straight up not true because you're talking about demand while completely ignoring supply. It just so happens that neither PHP nor Javascript has an imbalance of their supply/demand ratio, if you're trying to suggest that more jobs on the market means more demand than supply, once again it doesn't work that way. Having many jobs on the market doesn't automatically imply that they are hard to fill. Regardless of that, you haven't even touched on types of projects associated with each technology. Why do you think Java pays so well on average? There's no issue with its supply of developers, it pays well simply because the technologies associated with it are used in enterprise projects more often than other technologies. These projects simply pay better on average. Which brings me to the next point where you completely disregarded the full stack market. Like you said - much of the functionality has moved into the front end. Did you account for the impact this had on the full stack developer job openings? Do you understand that a very large amount of jobs which require Javascript also require back end technologies? Did you even consider how popular full stack became because of this? In fact a quick search on angel.co (nifty little startup recruitment platform that mainly focuses on web-related jobs) shows a disproportionate amount of full stack developers compared to front end developers and _especially_ towards back end developers. This means that full stack is becoming more and more popular. It also shows that there's a higher demand for full stack + javascript than front end + javascript. In comparison, less than half of the available PHP jobs are full stack. This means that Javascript has more full stack jobs than PHP does. Do you understand the implications of that? Do you understand that full stack is on another level of pay compared to pure front end or back end? Combined with the fact that proportionately JS has more full stack jobs than PHP heavily skews the average pay in its favor. By ignoring full stack developers you also ignored the background they're coming from. A .NET full stack developer will be paid more than a PHP full stack developer on average, again because of the projects. 
Programming jobs aren't the same as freelancing (which is what the OP asks).
I think you'd meant to say "WordPress", not "PHP". PHP certainly has drivers that support prepared statements. The `$wpdb-&gt;prepare`, on the other hand, is a simple escaping function.
I don't think you understand how incomplete and sometimes irrelevant your arguments are. You just picked a few numbers and interpreted them to your advantage. It doesn't work like that. &gt; However, if we compare programming jobs in PHP and programming jobs in React/JavaScript (notice, we're talking about jobs here, same thing), there will be more demand for React than not PHP, and therefore you'll get paid more. To start this off, this is straight up not true because you're talking about demand while completely ignoring supply. It just so happens that neither PHP nor Javascript has an imbalance in their supply/demand ratio, if you're trying to suggest that more jobs on the market means more demand than supply, once again it doesn't work that way. Having many jobs on the market doesn't automatically imply that they are hard to fill. Regardless of that, you haven't even touched on types of projects associated with each technology. For example why do you think Java pays so well on average? There's no issue with its supply of developers, it pays well simply because the technologies associated with it are used in enterprise projects more often than other technologies. These projects simply pay better on average. Which brings me to the next point where you completely disregarded the full stack market. Like you said - much of the functionality has moved into the front end. Did you account for the impact this had on the full stack developer job openings? Do you understand that a very large amount of jobs which require Javascript also require back end technologies? Did you even consider how popular full stack development recently became because of this? In fact a quick search on angel.co (nifty little startup recruitment platform that mainly focuses on web-related jobs) shows a disproportionate amount of full stack developers compared to front end developers and _especially_ towards back end developers. This means that full stack is becoming more and more popular. It also shows that there's a higher demand for full stack + javascript than front end + javascript. In comparison, less than half of the available PHP jobs are full stack. This means that Javascript has more full stack jobs than PHP does. So actually, that proves that most Javascript developers also work in the back end, where pay is better. By ignoring full stack developers you also ignored the background they're coming from. A .NET full stack developer will be paid more than a PHP full stack developer on average, again because of the projects. And you're severely underestimating how much the low barrier of entry of PHP is bringing its average salary down. 
I said exactly what I wanted to. Read more [here](http://php.net/manual/en/pdo.prepare.php).
I was about to Stop reading 10 times in a row, but this was so anti PHP that it MUST be pro PHP in the end.
Those tips are bad, because, &gt; you have to optimize a code that is actually slow in your particular case, not a code that has been slow long time ago in a galaxy far far away, or a code that someone just had a fancy to call slow based on some pointless measurements. 
Yes, what I do is this return function( Foo $foo, Bar $bar) { ... }; Router hit is matched against a php file, the php file is required and returns a function. Function can then in another layer be injected and called with correct arguments. Really nice, single responsibility, no bloat. 
Just use a big factory that you pass to your controllers. Fully typed if you want it, no, magics. PHP is interpreted, you don't need to use XML or YAML on top of it. 
I would say that in almost every case serializing an array like your example is always a bad idea. Create a qualification and a skills table and then wire up with a many-to-many relation. 
Okay, then you'd meant to say PDO. "PHP" doesn't emulate them.
&gt; The general guideline I observe is that unless you are doing something uncommon and specific you should never be writing SQL queries and using as much as possible an ORM. says who? you don't need a ORM. At most a query builder is convenient but you don't need layers of layers of indirection just to end up using DQL because query builders are more verbose than SQL statements. It's even more true when modern databases eliminate the N+1 problem with document types and aggregation functions.
You missed the point completely, didn't you ?
That's the design I'll be going with, thanks!
PDO stands for PHP Data Objects. Also, prepared statements can be done on database side, which is your only option without PDO (and you have to do some escaping manually), or driver side (than, if database supports that, escaping is actually done on database side, or by PDO otherwise). Emulated prepared statements handle escaping, but they aren't exactly the same.
There is sarcasm which has a point and there is this post.
Huh, that's good to know. Thanks.
Whats the point? 
I will always upvote this repost.
Haha good read :D
made my day :) please do this for every language :)
forget about mail() and use https://github.com/PHPMailer/PHPMailer
Great! it just said truths about PHP and Javascript.
I don't know if there's much of a difference.
Absolutely PHP is good for freelancing. Master the language, learn two or three of the frameworks (ex. Symfony or Laravel), a CMS (ex. WordPress or Drupal) and an E-commerce platform (ex. Magento) and there will always be a mass of jobs to bid on. Take a look at Upwork and Freelancer. Every once in a while, Craigslist offers a gem, but usually the clientele there is not worth the dollar.
it called satire
Ah, actually I edited right away with a more thoughtful reply. I'm fine losing the argument as well, for all I care.
Those aren't lines, those are gaping chasms! :)
Isn't counter snarking getting old now too?
This is great but should probably get to the punchline faster, Node developers have too short an attention span and might think this is serious.
LOL, if you have a permanent job then you aren't freelancing, you don't describe someone who has worked at a company for 5 years as a 'freelancer'. The entire point of freelancing is you are self employed and offer your services to clients, you aren't looking to become a full time employee of a company. Hence comparing jobs other than short term contracts is useless, because it is irrelevant to someone who wants to freelance.
npm remove php 
My biggest complaint about php is I don't have enough free time from work to bitch about how much it sucks.
Are you implying you can't receive a shite PHP code? That's why we exist mate, because somebody else fucked up majorly. And let's be honest here. If you need to rewrite a Facade and you are short on time you can create a static motherfucking class, implement the public "api" and pass it on to the next guy to deal with it. Just don't forget to write bunch of tests to make sure the working component you are rewriting is still working after that PHP magic bullshit. 
No, I was not implying that. My point is, that laravel seems to be helping to promote bad code or bad practices at least. It's my point of view though...
I think you just want [git-tag](https://git-scm.com/book/en/v2/Git-Basics-Tagging)
You are suffering from the not-invented-here-syndrome, which has the nasty habbit of: * thinking you can do better * don't trust others to do well But hey, call me lazy ;-)
Apparently the article author has never heard about helper functions and/or middlewares smh
Single vs. double quotes Single onces on a normal keyboard are faster to type, cost less human energy, so always a better choice.
Do I need to do a an app in a small timeframe? Do I need a battle tested architecture? Laravel. Do I need an more extensible framework? Do I need to define an architecture? Symfony. You can't have only one tool to fix everything.
$field_fname = isset($_POST['firstname']) ? $_POST['fname'] : ''; $field_fname = !empty($_POST['firstname']) ? $_POST['fname'] : ''; Am I doing this right?
We would do that as part of our build process. Jenkins checks out the code, stuffs the revision hash in your version.json and tarballs the everything up as a release. That tarball gets stored somewhere and is what gets pushed to servers.
I don't know man. Most Laravel libraries (that is, open sourced libs on github etc etc, not the laravel core itself) sport a top-notch fully testable code. As for laravel, they don't even accept issue reports unless you write a test about it. So idk, either I'm high on meth (unlikely) or people claiming that laravel promotes bad code are not actually looking into laravel. Thus their opinion is pretty much invalid on that point alone. Most Laravel contributions are stellar in terms of code quality. The Laravel community **does not stand** for bullshit code. If laravel was truly promoting bad code and bad code practices, how is this the case then? Riddle me this my friend. Because I'm quite honestly speechless at the "what-ifs" arguments with 0 factual backing.
Thank you. Does $value have to be the same as 'my-input' ?
Laravel code is pretty good, I have no problem with it, but how can you explain facades existance??? And they are all across the documentation... Instead of facilitating to inject the correct code on the constructor, as you are most probably doing... 
Hey, akas84, just a quick heads-up: **existance** is actually spelled **existence**. You can remember it by **ends with -ence**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
`$value` can be anything, it's just the PHP variable name you'll use to reference it.
&gt; Laravel's ORM suck. Terribly. Anything that is above the basic CRUD you have to use query builder, which kind of defeats the purpose of using an ORM in the first place. I kind of like this, because I've never found an ORM that could do some complex queries like CASE WHEN ISDATE([foo]) = 1 THEN CAST([foo] as date) ELSE CAST(NULL as date) END AS [date] I've always needed to mix raw SQL with the ORM so Eloquent being basically a glorified query builder suits this need quite well.
You should get a dev kit instead of the minimal ICs. With a dev kit, you get power through USB, which makes the whole thing much simpler. ESP01 are nice if you need to make a lot of copies of your project since they are really cheap.
Obviously it's done to ease-in rookie developers, who are going to learn about DI real soon. Hell, their validation documentation chapter is full of "Input" facade. It makes sense right? if you read it, it's going to be reeeeeally easy to follow. Honestly if you are using Laravel controllers I see nothing wrong in using Input, however the way I write controllers is really funny. In every public method that's going to respond to an HTTP request, I require the Request object to be injected thus I can use stuff like ```$request-&gt;get('param')```php or something, which is really nice. Laravel's Request object is an extension of Symfony's request btw.
You do it same way I do with Request being injected 😁😁😁
Wrong, the demand for technologies differs, because they have different use cases (or have at least have use cases that are more common to specific technologies). E.G the job market for Haskell is very different from say Ruby. So taking PHP has an example it has always been good for freelancers, because things like Wordpress, Drupal, Magneto, etc lend themselves to generating the sort of a freelancer can do and are much more commonly used by small business which don't have in house teams, so again lends itself to freelancing. Hence comparing overall demand that mainly consists of permanent jobs that are of no interest to freelancers, is about as much use as a chocolate teapot.
Got asked by another developer if any new startups actually use PHP anymore. Then again if there are actually any PHP jobs still. Last he asked if I use phpmyadmin to administer production databases. Answers in order. 1. Yes. 2. Yes. 3. No. Migrations handled via Phinx scripts and if I have to have direct access it's via an SSH tunnel doing port forwarding, but they is rare. 4. Any other questions? Tons of misinformation compounded by legacy code and practices.
Teach us your ways... I'd like to get into this field...
It is obvious from the first sentence that it is sarcastic.
So you say there is no difference when repetitively calling a prepared statement with multiple parameters?
PDO still emulates by default for mysql but every single manual just tells you to switch it off.
You are confused here a little. That's two different types of cache. For the literal query its the result (returned rows) which is cached while for the prepared query it's just the parsing result, which has so little use in PHP that there is nothing to talk about. 
While the first sentence is hogwash, It is something I've heard people say 100% seriously
&gt; Things you can't do as a PHP Developer &gt; &gt; Tell People you're a PHP Developer &lt;3
This is patently false. &gt; Because Laravel is for people who want to look cool and pump out shit fast. Most laravel libraries have full code coverage and no bullshit code within them whatsoever. You are blaming the tool instead of the programmer. You can write equally messed up code with Symfony, even more so especially since it's not opinionated and you have to build the architecture yourself. God forbid if you are a little bit inexperienced. Anyways, your first argument falls flat on its face, on the merits of open source supported libraries over at GitHub. The code there is fantastic. &gt; Laravel is this decade's CodeIngiter. It looks pretty neat and does a lot for you, but when you hit a certain size it gets slow and complicated. I think Taylor mentioned in this thread actually whom to contact about enterprise-grade Laravel built projects. What size are you talking about precisely? When does it get slow and complicated? Because you know, I operate an okay-ish large website with decent traffic and yeah I have some pages that have around 100-120ms generation time but outside of those, the generation times are 20ms per request on a loaded server (not a sleeper). I think this time is fine as PHP goes, I doubt I can do it better if I were to write plain PHP. The router is fast, the middlewares are fast, the laravel core is lazily loaded so it doesn't bloat the runtime and thanks to composer autolaod it hardly, if at all, hits the filesystem to check for file's existence. So yeah, I would really like to know what this "certain size" is, apparently I haven't reached it yet even though we serve thousands of users every day.
Spend 10+ years building up a reliable resume of work across multiple disciplines while honing your skills.
That's pretty good estimation. How did you find out? Let's say I have 10 placeholders and I use `mysqli_real_escape_string()`, which, afaik, communicates with database server. How is escaping 10 parameters and executing the query faster than just calling prepared statement with all parameters at once?
Sorry about that, there was some distraction around here. I guess we both mean the same anyway.
mysqli_real_escape_string() does not communicate with the server in the first place. it gets the encoding information during the set_charset() call. In case there is just a single query with 10 parameters, a prepared query won't be faster than a literal query. In case there are 10 queries with 1 parameter each, a prepare + 10 execute will be marginally faster than 10 query calls. 
If I remembered correctly, pre-php5, doing a `new Car()` will copy an object value, not reference. The coder usually will do `=&amp;` to ensure the new object is returned as reference and not a copy of the object. So we can say that, in PHP 5+, doing `$car = new Car()` is equally doing `$car =&amp; new Car()` in PHP 4. Cmiiw.
If they hand you a paper test and expect you to write code with a pen, just walk out immediately.
I would atill prefer Go over Node
Exactly. 
Ideally, something along the lines of ES or solr. If the task isn't big enough to warrant that and I for some reason have no access to a proper way of building a query, I would chunk it (if needed) and keep the actual logic and filtering in php. Doing it in raw SQL (with no sprocs) is far, far less maintainable in the long run, in my eyes. &gt;Okay, so show your preferred way. With code. There is no reason to start a dick-swinging contest just because we don't agree on a random aspect of a programming language, though. 
I mostly work in R/Node now, but if I ever want some quick cash I can always rely on finding some PHP/Wordpress work.
Hey, I'm also interesting about Symfony... What book are you reading?
&gt; Ideally, something along the lines of ES or solr That's massively over-complicated for my simple example. &gt; and I for some reason have no access to a proper way of building a query, What do you mean? Like an ORM? Is it the fact that you're manipulating the raw query that you don't like? So, would method chaining in an ORM be more favorable? &gt; There is no reason to start a dick-swinging contest I'm not, I'm just genuinely curious.
What's wrong with phpmyadmin?
Good idea, maybe they should skip a version number to emphasize the big difference between new and old.
Nothing in and of itself, but people have (ab)used it as a CRUD interface and database schema management tool, which is not good.
SRP
This is a great summary of all the silly criticisms lobbed at PHP (my favourite was "not being able to tell anyone you're a PHP dev"). The bazillion ecma frameworks being seen as a strength by so many is great too. One of the biggest problems I have in finding good ecma devs to hire, is the sheer number who have strangled themselves with abstractions, learning so much framework microlanguage, but barely even know the language they have such a sense of superiority for using. People going after PHP for async programming seems the craziest to me. Node's async is all event-loop based, which literally means it's simply a fucking loop. It loops, looks for events, and runs them. Pretty simple stuff that's been implemented in several composer libs. I've been using quite a lot of async code (via GuzzleHttp Promises), and I actually love PHP as a language for concurrency. The lack of first-class functions makes it not quite as nice for some things as ecma, but having a built-in typing system and a lot of nice standard types in the PSR makes DI from a promise very nice. Coroutines especially make it really clean. `async`/`await` is fine (and I use it like crazy), but so long as you have `yield` you can write async code really cleanly. public function somethingAsync( int $foo ): Generator { $id = yield someLookup( $foo ); list( $a, $b ) = yield P\all( [ fetchA( $id ), fetchB( $id ) ] ); return $a + $b; }
Thanks for your help! I've found my problem tough, the mail() function isnt working on localhost for some reason but it works on my production server. 
Thanks! I've found my problem tough, the mail() function isnt working on localhost for some reason but it works on my production server. 
Honestly i dont even know why the async argument even exists. PHP 7 doubled the execution speed, OPCache helps alot, 7.3 will add a more intelligent Dead Code Elimination system and your users will not commit suicide if your app takes 100 ms more to load.
Hey, FlevasGR, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Holy cow - a /u/CommonMisspellingBot that had a somewhat useful mnemonic!
Async is more about not stopping the request to wait on one call, then stopping for the next. In my contrivance above, it's running a couple concurrent processes at the same time. It's quicker to do two http GETs at the same time, than do do one, wait, then do the next. It's pretty common for me to start an external request at the start, then run all my DB queries/fs io/etc., then get the results at the end. For a more concrete example, I have an endpoint that takes data from postgres, and puts some data in the response from a 3rd-party service. The 3rd-party service forces pagination of 25-results per request, and I always want 100 results, so I'll run 4 fetches, then query my DB while those run in the background, then wait for the results afterwards. Turns what may have been a 1s+ request into a 200ms on.
Tags should be created by build system not by hands. If you everything doing by hands you doing it wrong. Learn more here [https://www.tutorialspoint.com/jenkins/](https://www.tutorialspoint.com/jenkins/)
Install mailhog on your server or use a docker image. Use mailhog as your server and the web interface to see what is going to the smtp server. 
Depends on which RDBMS you are using, and which extension. If postgres &amp; pgsql extension then have [pg_query_params()](http://php.net/manual/en/function.pg-query-params.php) Sends a parameterised query and it's parameters to postgres for execution without preparing. For MySQL only the [XDevAPI](https://pecl.php.net/package/mysql_xdevapi) provides the equivalent functionality. With [Session::sql](http://docs.php.net/manual/en/mysql-xdevapi-session.sql.php). But if the app is simple CRUD, then can avoid writing SQL altogether with this extension. 
Most mail servers reject messages from localhost to prevent spam. Sometimes if you open your terminal and type *mail*, you'll see all the undelivered messages... but I think you have to be logged in as the same user that your webserver is running as.
I suggest you consult your sysadmin or network engineer. I had this problem before because they block SMTP port
\&gt; Unless you're building a site, product, or service for yourself, you are trading your time for money. \*\*Most\*\* of the projects I take on have nothing to do with building a site, product or service. Product developers are a commodity and there are a ton of them out there willing to work 80 hours a week for peanuts. I don't compete for that kind of work because it's not worth it to me. \&gt; At the end of the day, it's your fixed price divided by the hours you spent working. I typically don't take on projects that have a "fixed price" unless the scope is well understood. I work in an underserved niche that does one of two things: Saves the client money or makes the client money over some time interval. Consideration is always negotiated with that in mind (and in good faith). As a result, I have multiple passive income streams that I've built up over the years that has afforded me the opportunity to pick and choose the projects I take on. 
&gt;This is a great summary of all the silly criticisms lobbed at PHP Did it actually address a single criticism lobbed at PHP? I read the article this morning, so maybe I forgot, but all I remember is snarky shit about "cool factor" and "JS devs write their own frameworks".
Partly because of how a lot of people choose to use it (serving remotely) and partly because it, like a lot of old PHP projects, has had a lot of security issues (239 CVE's, which is a lot for what it is).
How about PHP and real_PHP?
Haha the charts got me
If you're using it to modify a database then (in most cases) you're doing it wrong. Generally all your structure updates should be handled by migrations. Even then though, PHPMyAdmin is a bit of a legacy mess. SequelPro is a much nicer to use tool :)
lol. That was good for some chuckles.
We deploy multiple times per day as well, and tags (with date and time) is exactly what we do. It's a lot less excessive than making additional commits every time...
Nothing in particular, as long as its locked down. I believe he was alluding to a public login via phpmyadmin. I prefer DBeaver personally.
lol no generics
Or Adminer if you just need some locally-hosted web-browseable database frontend.
No, our migration steps don't have to be aware of the release version. Version.json is used for cache-busting (generating asset URLs) and to provide release information for sentry/rollbar or loggly for example. Ymd/Hi seems like an option, however we'd have to manually match git commits by timestamp :)
That seems like a good approach - we're planning on switching to TeamCity (Jetbrains), chances are there'll be a way to implement this. As we're already using codedeploy / S3, it should be straight forward, too.
For some people ya, It would be useful. but im primarily a backend PHP dev. For our front end react mobile app. They are in seperate repo's too, so if i do find my self needing to work on the react app, I do have 2 editors open.
Hey, DrWhatNoName, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
&gt; I don't know what you mean by magic here. This: https://laravel.com/docs/5.6/mocking The actual facades themselves have test helpers built into them, which is really not good design. You shouldn't have to include test helpers in actual source code, just to make them work, and it's strange that these APIs are available on these objects. 
Yes, I do that as well, depending on the project. It's two separate applications at that point, so it's fine. Maybe "two editors for one repo" would have been a better way to phrase it.
I more or less use it to inspect and modify some data records of hobby projects I was too lazy to code proper web interfaces for (because I hate frontend development).
Switch languages, bro. I have way more than enough time to complain about PHP since my day to day is Python, JS, and Go. The only time I run out of time is when I have to fix the security holes in legacy PHP 💩. 
&gt;With PHP you can't create your own memory leaks That's absolute bullshit, with PHP you can: - Write a SQL request to a file with a random name. - Call a C program that forks off to a FORTRAN program, return, and tell PHP to wait 1 minute. - Use the FORTRAN to read the file, interpret the SQL and then execute it on a csv repurposed as a noSQL DB with no simultaneous read/write protection. - Write the result to another file for PHP to read after the timeout and leave the FORTRAN program on a while loop and the file handlers open. - Quote the client a beefy 24-core, 128GB of RAM system to keep up with the bad code. - Use a cron job to reboot the server once a month in the busiest moment possible. - Make everything at least 10,000 lines worth of spaghetti code and ensure your employment forever. - When the disk is full you just delete 90% of the request/response files at random and hope none of them is a running batch job. - Also an accounts.php with a hardcoded array is required. And to maintain sessions you just pass along ?username=usr as part of the URL
&gt;He provided numerous examples that are very real world scenario, meanwhile you're just being an angry bellend 
You are just confusing the example with the assertion :) But thank you for your opinion anyway
I work with other languages I was just making a joke that PHP is so prevalent and the PHP jobs are so plentiful there's not enough time to stop working to b**** about it.
Besides, "he" didn't provide anything actually. He is just a random Redditor like you, who didn't read neither the article nor the discussion but had a whim to intervene. Reddit is a fun place :)
Preach brother.
XAMPP and MAMP users, here's a download preview of free standalone windows app to manage local domains. With a lot of small PHP scripts and projects, some prefer to create virtual hosts to separate the document roots. After initial short setup, to create a local domain you just need to enter the domain, select folder, click 'Create' and restart the server, and voalá, 'yourwebapp.local' local domain is working. Features: * Automatically detects common configuration file locations of XAMPP or MAMP for initial setup * Enables MAMP virtual hosts (if mamp directory detected on first start). XAMPP has them enabled by default. * Allows to create virtual host. You enter domain and create a new folder in htdocs, click create and local domain is set. No need to edit files manually unless you want to use virtual hosts config instead of .htaccess. * Allows to launch virtual hosts file, open htdocs directory, or project directory by selecting the local domain * Preserves virtual hosts configuration and comments while allowing to change the virtual hosts configuration. * Creates hosts file entry e.g. '127.0.0.1 my.domain.local' when creating a local domain * You can edit and disable virtual hosts from selection. On edit hosts entry and virtual host are modified. On deletion it removes hosts entry and comments out the virtual host. * Configurable shortcut to phpMyAdmin, just for convenience Will be great to have some feedback, also the only other windows app that manages virtual hosts that I know of is MAMP PRO which is $69. The app doesn't have an update feature yet, so will probably have to announce it here if you guys are interested in faster project setup. It's sort of in-house project to manage projects. Suggestions for features are welcome. Already have my mind set on MySQL DB management, one click CMS installations, CMD and Docker commands, as well as accessibility of localhost domain from the internet. Nginx domain setup is another story. [Download](https://cyberstunts.co.za/storage/app/media/software/local_domain_13_8_18.zip)
You're right. Branding is like a huge part of success.
You can write node scripts that compile to PHP using only 2MB of 300 dependencies, only 30% of which will break your Enterprise app with the next security update next week!!! I had a bad experience with node :(.
XAMPP and MAMP users, here's a download preview of free standalone windows app to manage local domains. With a lot of small PHP scripts and projects, some prefer to create virtual hosts to separate the document roots. After initial short setup, to create a local domain you just need to enter the domain, select folder, click 'Create' and restart the server, and voalá, 'yourwebapp.local' local domain is working. Features: * Allows to create virtual host. You enter domain and create a new folder in htdocs, click create and local domain is set. No need to edit files manually unless you want to use virtual hosts config instead of .htaccess. * Automatically detects common configuration file locations of XAMPP or MAMP for initial setup * Enables MAMP virtual hosts (if mamp directory detected on first start). XAMPP has them enabled by default. * Allows to launch virtual hosts file, open htdocs directory, or project directory by selecting the local domain * Preserves virtual hosts configuration and comments while allowing to change the virtual hosts configuration. * Creates hosts file entry e.g. '127.0.0.1 my.domain.local' when creating a local domain * You can edit and disable virtual hosts from selection. On edit hosts entry and virtual host are modified. On deletion it removes hosts entry and comments out the virtual host. * Configurable shortcut to phpMyAdmin, just for convenience Will be great to have some feedback, also the only other windows app that manages virtual hosts that I know of is MAMP PRO which is $69. The app doesn't have an update feature yet, so will probably have to announce it here if you guys are interested in faster project setup. It's sort of in-house project to manage projects. Suggestions for features are welcome. Already have my mind set on MySQL DB management, one click CMS installations, CMD and Docker commands, as well as accessibility of localhost domain from the internet. Nginx domain setup is another story. [Download](https://cyberstunts.co.za/storage/app/media/software/local_domain_13_8_18.zip)
Parent theme was learning something to expand your mind != easy to get a job. No, Clojure is a poor choice for getting a job though there are quite a lot of big companies (Daily Mail, Walmart, Deutsche Bank) using it.
And call it [the Mojave Experiment](https://en.wikipedia.org/wiki/Mojave_Experiment)
Received a POS built PHP 5 system. Basic bug work, changed everything to MYSQLi and moved to PHP 7, and they're happy to know the system will keep on going. 9/10 times my job is literally this.
the time has come... for counter counter snark
Indeed. Laravel and Symfony is like comparing Ubuntu to Debian.
thank you!
PHPdotNET?
That's the basics for me as well, though a lot more time is generally spent on HIPAA and PCI-DSS compliance, or logging standards.
Garbage article. Blatant SEO spam.
As for skills, I tend to agree with the other guy that it merits another table. With the qualifications I can see it your way, though I'm not aware that json is an option as a data field. I'm using PostgreSQL
Of course there is an exception to every rule, but it stands true 99% of the time.
&gt; patently I don't think you know what this word means. How can something opinion based "be without doubt"? I didn't bother reading the rest of your reply.
While you're writing your app-plumbing, we enjoy to rake-in piles of cash sipping cuba-libres on the beach answering questions on Reddit. That's why :)
I'm 0/4 for Indian outsourcing companies who deliver good quality output so far... I'm sure they must exist, I refuse to believe that an entire country can only produce low to middling quality of development, but there seems to be some sort of race to the bottom going on for pricing (and therefore quality) among the outsourcing agencies. That said, I've also worked with atrocious freelancers (but never for long) - freelancer populations tend to follow a Darwinian motif, particularly in larger cities or IT hubs where the competition is so high, the bad ones tend to end up out of work and taking a salaried job somewhere (installing plugins on WordPress sites would be my guess?), rather than being a successful freelancer. I have had good experiences with Eastern European developers - they cost more, particularly if you want to hire business analysts/PMs/Scrum masters to manage the team of devs, but they seem to be very well suited to best-practice development.
My brain hurts a bit after reading that, particularly the randomly emphasised SEO phrases :|
I haven't tried the json field yet, but definitely it's a good improvement, if you don't want to store everything in a separate table. Could you give me a rough comparison when you want to filter peoples with Team player qualification with json and with many-to-many relation?
And that is precisely why your opinion is blatantly false. You ignore facts, plain and simple and you just spew your own narrative. This is not how discussions work, and if you are really not into discussions, then how about you shut the fuck up and leave grown ups talk? 
I am sorry but I couldn't provide you with exact numbers, I used it a couple of times but never really did a performance comparison test since on the applications where I used it, performance was never a big issue. (mostly intranet stuff for smallish crowds)
quite...
&gt;$car = new Car() &gt; &gt; is equally doing &gt; &gt;$car = clone new Car() &gt; &gt; in modern PHP. No, on php5+ $car is still an object ref (you just throw away a fresh value with the clone operator). You cannot reproduce php4 behavior (object being implicitly passed/assigned by value), you have to deep clone everywhere.
Always set-up CRONS directly but now looking for a PHP based solution so the CRONs will also be in source control and our new staff don't have to be given direct access to production servers. There are loads of packages out there, what have you had the most success with?
Thanks. Didn't know that!
So ... you don't have a lead developer?
We do but the opinions of the seniors are taken into account. 
What's the difference between this and plain symfony/process?
Have you considered including the actual crontab in your source? Then move the file to the correct directory once you deploy your peoject. Just throwing it out there as a possible option
When you don't trust auto-correct because they're shady as fuck. :D
This is the best solution for most applications. You only need a managment arround crontabs it if your crontabs change quite often.
We've been using [Laravel's scheduler](https://laravel.com/docs/5.6/scheduling) for a while now, using it combination with a schedules table in our database. Using this combination allows us to easily set up cronjobs for a package (only one rule in the crontab is required) and the developers can add jobs themselves to the codebase.
It looks promising but how well does this work outside of Laravel? When I've used other Laravel packages its a nightmare and really hacky to get them running without everything else from Laravel
How would you compare this to a native solution with only Symfony\Console? https://www.tomasvotruba.cz/blog/2018/02/05/how-to-run-symfony-processes-asynchronously/
If you have systemd on your system you could use https://github.com/icanhazstring/systemctl-php. Version 1.0 coming soon where you can create units (timers for crons) using simple code implementation. This way you can checkin your source for a timer and deploy them if needed.
Too much fluff. Took about half the article for him to actually say anything significant instead of just using buzz words like SCALABLE, SECURE, FAST. 
Hey :) I understand the point of view, but I really feel like many people don't know/understand the reason why we use Docker/Kubernetes and I wanted to give an introduction to them before explaining why Symfony integrates well there. Don't hesitate if you have more precise feedbacks :) .
We also use semantic versioning, but we have an API which is consumed by a JS client so that causes a bump in major version. Many of our other sites don't and some just use an incrementing number for each build v1, v2, v3 etc.
Wrong. SELECT * FROM posts WHERE title = COALESCE(:title, title) AND age = COALESCE(:age, age) AND category = COALESCE(:category, category) 
I tend to write a bash script to deploy sites I make. That bash script does this at the end: `/bin/cat &lt;&lt;EOM &gt;"./deploy_version.php"` `&lt;?php` `# This file is written by deploy.sh. It provides the timestamp of last deploy to use as a cache buster.` `\$deploy_version = \`date +%s\`;` `EOM` Then deploy\_version.php gets included when the app is bootstrapped and the value passed into the app's container. It's then used as a param to assets to break the cache, or for anything else that needs a version number.
Its the old PHP 4 nonsense that a developer should no longer use in modern PHP. If it comes from a third party library, then this clearly is a warning sign that the library is outdated and you are using it at your own risk. If it comes from your company's own code, then its a good time to refactor their code. 
I would say that if your class has a constructor bloated with parameters, even if its the controller class, its a serious sign that you need to refactor it. Usually there is a clear violation of SRP, and you need to make sure the class knows only what it needs to know, not to become a god class. This article was from one of the previous comments, scroll down to 'Hidden Dependency' part and you will find such an example of big constructor, for which the author recommended refactoring: https://qafoo.com/blog/057_containeraware_considered_harmful.html
Even so, locators are lazy, which is feature you may find useful in different cases (like controllers).
Yeah I've been out of touch with webdev stuff for the past few years (doing mainframe now) but I try to keep an eye on it so I'm not too out of touch whenever (if) I come back to it. I noticed a job posting in my department recently and they mentioned Kubernetes and Docker so seeing this I post I decided to check it. It might be overkill for some to start with an explanation, but I thought it was useful to set the context. Thanks for the article.
At one company we had a cronjob that executed a .php that executed all .php in a especific directory in filename order. It had hourly and daily directories for that. It wasn´t brilliant, but get the job done.
you're an idiot
A true statically typed language, 💯% genius design decisions brought to you by Rob Pike™
What's the point in re-writing all of the common parts of an application every time you build one? (auth, sessions, requests, database abstraction). The frameworks many members of the community used are re-usable items which means you can spend your time more efficiently by developing features for your specific application, rather than the nuts &amp; bolts that hold every application together.
I do this sometimes. If you're running a Makefile upon deployment (or you're using Ansible deployment scripts) you can update the entire crontab in one go using `crontab /your/file/here`. Assuming `/your/file/here` is a valid crontab it will update your crontab for you.
You can update the entire crontab in one go on the command line using `crontab /your/file/here`. You could put your crontab in version control and then use a Makfile (or an Ansible playbook) to run that command upon deployment.
I do this: crontab.conf and when application gets deployed on server jenkins just runs: \`crontab -e crontab.conf
PHP docblock annotations are comments, do not try to fight the truth. Just because the comments are affecting code due to some black magic done behind the scene, doesn’t mean they are not comments. In Java and C#, annotations are language features, but these languages have native support for annotations. 
In all seriousness, I mostly see Go as a better-for-userspace version of C (`void*` anyone?). Like, if you were considering writing your super cool new music player in C (people do this on Linux all the time), you should probably just use Go. I'd still vastly prefer Go to PHP for web backend stuff as well, but it's certainly not a fantastic language.
It's like the toyota/lexus or honda/acura split. 7.2 on shall be known as Phether beacuse it's fast to spin up
Isn't sarcasm about counter-counter snarking getting old now?
Try [https://github.com/peppeocchi/php-cron-scheduler](https://github.com/peppeocchi/php-cron-scheduler) it's similar to Laravel's scheduler and isn't dependent on any framework.
This design pattern is getting more and more attention, thanks for this! I know it as [Collector Pattern](https://www.tomasvotruba.cz/clusters/#collector-pattern-the-shortcut-hack-to-solid-code). Have you tried it in Symfony/Laravel/CakePHP/Nette or any other framework? 
This horse is so beat to death it is not even funny. These articles feel like they are descendants of a single parent article processed through a "unique article tool". Here is a tip: if you have an idea to blog about, google it first. If it has already been discussed to death don't write about it.
That may be an option for local databases, but I wouldn't want to expose my remote databases to the Internet to connect with native tools.
The posting in this thread is way crazy. There is only a place to type the title, not the content, so you have to make a crazy long title that is too long, but it also doubles as the content, but it doesn't allow many words, so the content is very limited...
It looks like you can edit it at least, by I tried posting twice and could not find a place to enter the content.
So I was able to edit it and put the content in the content, since that is the only place it allows entering content, but now the information is duplicated because it is also in the title, and edit does not allow changing the title...
Reddit has 2 post types: "Link" (or "image" on some subreddits) and "Text". When composing a new post, select "Text" instead of "Link"
I'm glad You like it! The Signals project used here is framework independent. I'm using it with Yii 1 combined with some Symfony components and my own code. For example as Enum class, where it collects types defined by @SignalFor placed on interface. This can easy be used with Collector Pattern to automatically collect items.
Why ?
&gt; If you don't trust your users-- parameterize. I would argue you should never trust your users because users can end up being entities you don't even know, no matter how private you think your app is.
Not sure Apple’s aware of this. Their new OS in public beta is called Mojave so in essence, it’s Windows Vista disguised as a decent OS 😂
Given the recursive name, perhaps it should be PHPHP?
you'd typically use an ssh tunnel for this
Are they even directly competing markets? I think they are mostly disjoint...
They're competing when you're starting and you decide whether you should become a PHP or a JavaScript developer.
Of course not. That's why they all connect through SSH.
This seems like a straight anti pattern to me. You let this party code dictate the behavior of your application by doing this. Most frameworks solve this problem using service tags. The difference is that the relation is maintained the other way around. Maintained being the key word there, because it will be a conscious choice what parts of the application get wired. See https://symfony.com/doc/current/service_container/tags.html to read up on how Symfony solves this problem.
This is what I do. I even append the git hash to javascript and css files as a cache buster on public facing sites. 
That's the joke... Never trust your users.
Some people haven’t learned that lesson. So, I didn’t immediately recognize it as a joke. 
Agreed. Dynamic types programming languages can be strongly typed like Python, while Static typed programming languages can be weakly typed like C. PHP’s problem isn’t with dynamic typing, but weak typing. Weak typing is a terrible idea in modern programming languages, hope PHP will say goodbye to this old junk at some point. 
You may be conflating "being a programmer" with "having a job" or even just "being a human in a society". - Working really hard on something only to realize that you've overlooked something important and having to deal with the consequences. - Doing things to a standard below your own to achieve somebody else's objective. - A constant barrage of minor issues that you don't want to deal with that have to be addressed (or not) in a prioritized manner. You do the above things enough times in a repetitive cycle, and yeah, you become jaded. Office life has its own set issues, service jobs have theirs, dealing with being an independent adult yet another.
I'm confused. This is a pun right? But the jobs chart's cool factor and no. of jobs seem very real.
Thinking of all the ways that your code can fail isn’t a lean toward pessimism. It’s logic not mood. It’s what you’re supposed to do. Take pride in it if you do it well and feel good at preventing future work. Many other careers in engineering, finance, child care, etc have people thinking about the worst case scenario on a daily basis. I think you’d enjoy the book “The Phoenix Project”. Even if you take nothing from it, you’ll identify with it. 
I really loved the interactive part with a solid animated and colourfull teacher. Buy honestly at this point I just want to make sure I'm not learning outdated stuff. Also thanks for the ressources :-) 
I’ve watched a lot of videos and taken a few courses over the years and one that I feel taught me the best fundamentals was the “The Complete Web Developer Course 2.0” by Rob Percival on Udemy. It goes through all the basics and JavaScript/jquery etc but the php/MySQL section teaches you raw php/sql without a framework and includes some basic security which helps you understand how some things are working when you get started with a framework. If you find it on sale it will be around $10 so completely worth it. That’s my recommendation.
Seconding this, Jeffrey Way makes great videos. 
I actually will do this. As soon as I feel knowledgeable enough to do so. I just need a strong base, afterwards I really don't mind problem solving. As long as I am understanding what I'm trying to solve. Thanks for the input!
Will check this for sure. I also took A "Complete Web Dev Course" the one by Brad hussey. I loved it until the php mysql part. Does Rob percival takes his time explaining what you're doing while actually doing it? And is the lesson updated for today's reality? 
That's a novel hack for a very specific type of query, but it isn't applicable to most queries.
Thirded, hard to go wrong with Laracasts.
Making a connection to your db is the central thing here. To save yourself time and trouble use PDO. Most connection scripts you find will be kitchen sink kind of things. You need a very simple one, and once you get a successful connection it's pretty easy. And with PDO you can use the same connection script on pretty much any php/mysql/maria setup.
Yeah from what I read I gotta learn PHP/PDO. Do not hesitate to guide me towards usefull ressources / tutorials if you have that kind of info. Also I guess I gotta learn PHP/PDO then a framework like laravel?
&gt; I know it as Collector Pattern. I do something very similar to this, but I typically have a `supports($context): bool` method to determine which implementation to use 
I found [!this book](https://education.fsu.edu/wp-content/uploads/2015/04/Learning-PHP-MySQL-JavaScript-and-CSS-2nd-Edition-1.pdf) to be a decent primer. The content is enough to get you up and running with building a MySQL backed web-site.
I think having a nice little portfolio can help get you in the door. Have a project or 2 you are proud to show off. Make sure you wrote the code and can explain it well. Show you can use a framework. Be prepared to explain a few hurdles that you got over when working on your projects.
[How to connect to MySQL using PDO](https://phpdelusions.net/pdo_examples/connect_to_mysql)
Code something and pit on on public repositories like github. That proves it.b
Indeed there are some problems. The biggest one is a cargo cult error reporting on connect which does literally nothing. Persistent connections are useless most of time and could be harmful with PDO and - especially - with improper use of such a class, multiplying the number of connections. 
Hi, I can help you to learn php/mysql at a personal level one to one. Pm me if you like this. Thanks
so, years after laravel did it?
Please be aware that your database class is highly opinionated and only compatible with the MySQL driver because of the options used in the constructor. At this point, using a DSN gets questionable. The only reason to support that is to be able to support both TCP and Unix socket connections. Personally I would say that overloading the constructor is a bad idea in this case. Additionally, your prepex method seems a great candidate for a trait, since it's driver independent and you can promote it to be used on other classes. I would stick to prepareAndExecute to keep clear what is going on. A good IDE makes typing that no more effort than your prepex method name. 
I would not let my enterprise applications run without persistent connections. Why would you so strongly advice against using it? I can't recall having to deal with issues surrounding persistent connections that couldn't be solved easily over the last decade. Issues that won't even arise in a kitchen sink application, so why bother not learning to use persistent connections?
Is it time we tell you the story on the birds and the bees, little one?
I’m single and no one will ever love me
I am strongly against using this feature as a mindless habit and a default option. For the enterprise, a single transaction that hasn't been rolled back due to a fatal error could be quite fatal. For the the noob's home page that creates a new connection in the every function, it will lead to too many connections error. And the benefit is too questionable to be pursued with such a blindness. 
TROLLLLLLLLLLLl
think this is a joke huh ?
A persistent connection would not mean all your application instances catching on fire when one of them has a transaction error. That simply isn't how that works. If that were the case, a whole lot of sensitive systems would break down on a very regular basis. Preventing a junior developer from getting errors that actually show them their application is systematically built the wrong way by teaching them to do something different from what they would have to learn anew at a later moment in their career, seems to mark a lot of red flags to me.
Your question isn't, but my comment was supposed to be. For some actual advice, though: have a look at the user bundle from Friends of Symfony and I would definitely ask this question over at /r/symfony since there are a lot of experienced Symfony experts out there that are willing to help you out with this. Not sure what form of relationship you're looking for. Could you clarify that? I would assume having either relationships with user groups, ACL or perhaps you want to relate users directly to other users? The latter seems something you might want to solve using Doctrine.
Without a b.a. degree, but with a portfolio, and a pretty lame github account I was able to get a job as a jr. dev. Pay sucked because I had no experience but I quickly started to get paid more. Study technical interview questions on php, and OOP, learn git, and be personal, and you’ve got it. Promise what you can and be honest and you’ll find a company willing to hire you. Don’t think you’re not ready, you are!
i see thanks. 
To learn good practices: https://www.phptherightway.com
I still love you. Even if it's only for posting this comment. Let's get together and make some sweet sweet love.
 They are different technics. Both make sense. Just a few examples why my solution is better: The master process may exist, you should not wait. Scales better as you might have lots of consumers waiting for job on this or other servers. Jobs are in the queue, so could be delayed, expire, or repeated on failure. The con is that it is more complex solution. You need a consumer working a background a broker sitting in the middle.
I'm not sure why you needed to, but by making this thread toxic I abstain from further responses. Assumptions and toxic language are not helping this community grow and I urge you to think about that.
That's the good. I am glad we agree on that. 
this book is *fatally* outdated. Seeing a code like this, &lt;?php require_once 'login.php'; $db_server = mysql_connect($db_hostname, $db_username, $db_password); if (!$db_server) die("Unable to connect to MySQL: " . mysql_error()); ?&gt; which is wrong on too many levels, one can ditch such a book without any regret.
I would advise for the OP to use /r/phphelp instead, as there are much more people involved who can help - or, which is quite important - correct a wrong advise given out of the big heart but lesser knowledge. 
For general advice regarding symfony i can recommend the symfony slack channel. Those giys are really helpful if you are stuck on a certain part
Do not blindly trust any link or a book offered. Remember that whoever offers you it can be a noob as well and just have no expertise to tell a good one from a bad one. For example, mysqli is much harder to use than PDO, so you can tell that a course that is teaching you to use the former is not the best one.
You know, I'm pretty sure that's one of the tutorials in the Symfony documentation...
Not sure what it's like in the states, but over here, you'd put it in a covering letter, followed with something along the lines of "and I hope the role of JOB at COMPANY will help me learn more", rather than in the CV. Effectively, be honest about your level of ability, and be eager to learn.
Is better to take a raspberry pi, install the webserver, php and mysql taking some tutorial. The pi will cost you 5$ or so, really cheap and for learn and practise is much better than pay a hosting. If you dont want know anything about sysadmin, even if is that simple, maybe a hosting can do the thing, but i really think is so much money only for learning pourposes. And talking about you said at start, to learn well is more important your will to do it than the place you do it, everything in informatics science is about practice and more practice.
Regarding cheap hosting - sort yourself out an AWS account. The first 12 months you can have a single t2.Micro EC2 server running linux for free - check out the free tier information, you can use most of their services up to a certain level for nothing, some of it forever, and some of it just for the first 12 months - [https://aws.amazon.com/free/?awsf.Free%20Tier%20Types=categories%23featured](https://aws.amazon.com/free/?awsf.Free%20Tier%20Types=categories%23featured). And learning at least basic server administration (install apache/php/mysql/etc, configure and run the site) is really useful for a PHP developer.
Thanks! :)
Best comment I've seen all morning :)
That would be a very bad example. W3fools are infamously known for teaching you anything but the good practices. A [recent example](https://www.reddit.com/r/PHP/comments/906wnd/noob_question_here_sorry_regarding_passing_sql/e2o5we5/)
Make a website or two (or more) where you can show of your skills, put the code on gitlab, github or bitbucket and put the website online at a cheap hoster or on a subdomain of your portfolio site (see next step). Make a portfolio site where you put up a "preview" of these projects and mention the portfolio site when applying for a job. Need inspiration for a project? Google 'startup ideas' or go to a crowdsourced jobsite like freelancer or 99designs and pick something to make for yourself. On my resume I have an item 'Self study' where I list specific books I've read and courses I've taken (with month/year) to show that I keep learning and have a few skills without on-the-job experience.
The general rule is, only store data in JSON format in MySQL if you are not planning on using that data in a `WHERE` query. 
So what's the actual point of this? Sending out a notification when a class/interface etc is loaded? This seems terrible to rely on and definitely not robust, think long(er) running processes. Otherwise I have no idea what use this could possibly have and I'm missing this in the blog post. Can you provide some use-cases?
In my opinion, whether it is pattern or anti-pattern depends on use case. I'm using it to collect several types of classes in my application, especially plugins, for instance: * Template Types * Collection Types * Editor Plugins * Configuration Plugins The point here is to **only collect** instances, then application decide **whether to use** each instance. This totals in dozens of collected classes for which i would require some configs. And the point of maintainability is very important here. As adding all those classes to some configuration files is impractical and redundant. The component which uses collected objects decides **whether to use it or not**. The important thing is, that instance is created no matter if it will be used or not, so it should not do any extensive operations in constructor or any operations at all. P.S. Isn't adding *string* service tags the [Magic String](https://en.wikipedia.org/wiki/Magic_string) anti-pattern?
**[Magic string](https://en.wikipedia.org/wiki/Magic_string)** &gt;In computer programming, a magic string is an input that a programmer believes will never come externally and which activates otherwise hidden functionality. A user of this program would likely provide input that gives an expected response in most situations. However, if the user does in fact innocently provide the pre-defined input, invoking the internal functionality, the program response is often quite unexpected to the user. ***** ^[About](https://www.reddit.com/user/ultimatewikibot/comments/90r969/about) ^| ^[Leave](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[me](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[alone](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) 
But we are talking about a specific type of query, and you said that dynamic SQL code generation was the *only* way to do it. Which is wrong. I think dynamic SQL code generation is way more of a hack, which has led to all SQL injection vulnerabilities. 
The notifiers in blog are just example of application plugin. The point here is it to collect plugins automatically. More details are in my previous comment https://old.reddit.com/r/PHP/comments/97adna/collecting_interface_implementations_with_signals/e485ept/ 
I'm sorry but that comment still gives me no use-cases on where to use this, or when the notifier is triggered or even how.
I remember when someone in marketing made arsenic a childhood food.
🤘🏻
You're being completely disingenuous here in order to "win" or whatever, so I'm not going to argue with you about who was right or wrong on that silly technicality. I will, however, point out that your hack will most likely ruin any attempt by your SQL server at picking and using a relevant index for the query. You're also forced into only using equality, and only with constraints that don't use any mutating functions. I'm sure there are probably other restrictions that I'm just not thinking about at the moment, as well. Thus, even in the one or two spots in your application where this might actually work, it would be absurd. You're chopping off your leg in an attempt to prevent yourself from shooting yourself in the foot. At an application level, even this hack is untenable, so you're still going to be forced to use dynamic SQL or risk even worse consequences, as previously mentioned.
You still haven't answered the most important question though, when is this triggered and how is this triggered? "runtime" is the wrong answer, because everything in php is triggered runtime.
Working in customer service made me pessimistic about the ignorance of the general public.
I've paid already on Udemy, I don't mind investing as long as the return shows me the rope. is teamtreehouse up to date? Thanks for the input btw.
@colshrapnel What would be your ressource recommendation then? 
Confirmed. We've interviewed for interns and junior devs in the last few years, and we've *never* gone for the candidate with the most ability or knowledge. Always with the one with the right attitude, a willingness to learn, and that we saw could communicate effectively with the team. And what disqualified the most people wasn't the lack of technical know-how ; it was being shy or uncommunicative, or the opposite, excessive chattiness and apparent unwillingness to listen. We even rejected one or two very excellent candidates because they were *overqualified*. When you go to an interview, do your research and show that you understand the company, what they're doing, and have a few ideas of how you would improve something, anything, on their website or whatever. OR be honest that you really don't know, you need to learn more about the company's tools and processes first. Also keep in mind, lots of companies actually prefer inexperienced devs that they can mold to their way of doing things. Sometimes by being too experienced, they'll assume you're gonna try to impose your own habits on the team. You can play that card, alongside general willingness to learn. A portfolio will get you a hearing. The right attitude will get you listened to.
1. Calling `gather` method of `Signal` with `new NotifierSlot` as parameter creates array of Notifier instances 2. Then notifiers array is looped with `foreach`, and `notify` method is called for each item. The list of classes which should be returned by slot is generated via shell command, before actually running application. That's why I used *runtime* word to distinguish it:) I hope I've gave You some clues, as the Signals concept might be confusing at first:) The workflow with Signals is as following: 1. Create classes/interfaces with `@SignalsFor(SlotClass)` (or `@SlotFor` - this is not covered in blog post) annotations 2. Run command `vendor/bin/signals build` 3. Run application P.S. Have You tried to run example from GitHub?
Depends. They do use php 7 but there isnt a updated framework to learn. Still recommend you to start there to get a solid base
Look you didn't know enough about SQL to realise that non dynamically constructed version was even possible. You are the one trying to "win" by coming up with excuses for your lack of knowledge. The point is you don't know until it's actually been tested on real world data. And I'd suggest that the query above requires less code, therefore should be the first iteration, and benchmarked to determine it's suitability. 
In my personal opinion I had a good experience on [Udemy.com](https://Udemy.com), there is a lot of free courses on PHP, PHP/MYSQL and PHP-OOP. Download Ampps, Xamp or Mamp depending on your operating system. Theses apps will run Apache Server and Mysql Server for you. I use Ampps on mac and I'm able to create my own local domains and use PHPmyadmin and the command line. Lastly get yourself Sequel-pro (for mac) or Mysql Workbench so you can have a visual tool to work with your databases. 
This is one of the better resources for PDO I've seen: [https://phpdelusions.net/pdo](https://phpdelusions.net/pdo)
Okay so if I understand it correctly, instead of gathering "plugins", you signal a collector of sorts to collect "me" via the annotation, based on a script that you run before running your application. &gt; P.S. Have You tried to run example from GitHub? no
Same hare, (and same country) We had a "Optimization techniques" which sound good, but it's not actually good practices to optimize different algorithms and real life scenario problems. We "learned" some weird techniques to solve different math problems. Duuuh
`ghokin fmt`, why not just `ghokin format`? Or does it mean something else that's not documented yet?
Using this for cache-busting is not a good idea. If you're using Laravel already, why not use the asset-management that comes with it and automatically generates asset-URLs suitable for cache-busting? As for the git hash: I prefer the *git pull* type of deploment, meaning git has to be able to run on the deployment target. As part of that build process you can just get the latest commit hash with something like this: `git log --pretty="%h" -n1 HEAD` and save it somewhere. 
I think you really boiled this down nicely. As someone who's a developer secondary, but the one responsible for some of our agency's most important software (support, health, data accuracy, etc) - all of your bullets completely apply. Luckily our agency has about 500 people so I get to work some amazing people who ground me on days I start to feel like the OP.
No that's just getting older and saltier that's normal nothing to see here
Thanks for letting me know /u/colshrapnel . Having heard so many good words from Laracasts I'll give this guy a shot, really semt like a good course. I've bookmarked PhpDelusions and pĥptherightway for future reference. Thank you.
&gt; it's still a PHP MVC framework built with the same components. MVC is not possible in PHP.
If these attackers really wanted to obfuscate their code. They would make it look legitimate rather then trying to hide it like this. It sticks out like a sore thumb.
Lol, my marketing department SUCK. They want me to redesign everything for them every year, just because they don't know how to work a rich text editor. 
ikr! but i guess it is to fool those website scanner engines. sure it cannot fool our eyes but web scanners cannot. plain code can be picked up and marked by most AV search engines.
The key part is eval(rawurldecode()). This means they are executing pre-written obfuscated code in your context, with access to your $_SESSION, databases, etc. You could use a PHP interpreter or shell to execute just the rawurldecode part and dump out what the actual code is doing. It’s likely scooping data and phoning home. Should go without saying, but don’t let the eval run, especially not on a production system.
interesting, yeah i've actually cleaned and quarantined these files. was just curios how it work.
&gt; Visual debt So we're just throwing around trigger terms willy nilly now?
I highly recommend the above mentioned https://phpdelusions.net/pdo If that was written by you then thank you. Some of it is over my head, but I use it for reference quite a bit. I manage a couple of analytical databases for statistics and other stuff. Very niche things, but they've been around since the php3 days so I have sanitized tens of thousands of queries. I started working with web sites in 1999 and php in 2001 so things have changed a lot. I will admit I spend 95% of my time thinking about whatever it is I am trying to accomplish and 5% about coding style. 
I used to deobfuscate this stuff for a living. 9 times out of 10 it's an endpoint for them to execude random code on the server via a GET request containing a special key/password.
You will want to check all the files in the WordPress directory for similar obfuscated code. Search for words like eval or url_decode. It would be standard practice to hide multiple copies of malicious code in various files through the file system. Don't ask me how I know...
Neither or OpCache if you need it. Are there even any popular applications that use ZendGuard anymore?
What was the file's name? I'm decoding the code out of curiosity but it uses part of its own name and I need to know the file name. The code suggests there are parenthesis in the file name. 
Does anybody know if Laravel is at risk from these types of attacks?
Nope, don't even look, just restore from backups until you find one before it was exploited, update everything to the latest version, audit every plugin, and pray. No backups? Hahahaha! 
I don't think so for ZendGuard, especially WordPress specific (as we're only hosting a handful of WP sites on it) pieces. I hear OpCache has significant performance benefits, but I also see a handful of plugins with checkboxes specific to OpCache (something about update nags), so I guess I'll abstain from both.
it's for PHP. Laravel is in PHP. Hence... Yes.
What was the original name of this file? The first thing that it does is gets the basename of the file itself, which it uses to decode some obfuscated, urlencoded text it'll eval. If I switch the `eval` to `echo` I get nonsense, so I assume this filename needs to be used as a key for these data.
And probably without doing their actual job, you know, doing market research, a/b tests. Basically these people just pull shit out of their ass most of the time and hope it increases conversions. Cause hey, they don't have to actually do the hard work, the just throw it to a fucking grunt and hope it works.
Yes, it is not dependent on framework. It requires getting a file onto the server one way, or another. Validate your file uploads, always.
If you are interested in the topic I highly recommend to check out the whitepaper by Sam Thomas, the guy that found the vulnerability: https://github.com/s-n-t/presentations/blob/master/us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [s-n-t/presentations/.../**us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf** (master → 6b197aa)](https://github.com/s-n-t/presentations/blob/6b197aa570c751a0e967a953d6b72f5e8dbfaccd/us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf) ---- 
People used to spam references all over the place under some theory that it improved performance. Maybe a long time ago it did. Working with old code, I see a lot of places references are used where there's absolutely no possible reason for them to be used either now or even as far back as PHP 4. I see many bugs caused by this as well.
Original file name was ".f0a86fa6.ico" with that extension. 
Sadly no backup :/ but have done everything i can for now. everything is updated. continuously looking for malice code.
 Original file name was ".f0a86fa6.ico" with that extension. Okay. let us know what you find.!
I don't get it: the attacker still has to inject a file path that has to be evaluated by the PHP code right? This is already something we (should) protect against: we should not build file paths from unvalidated user input. So how is this different/more critical?
Not pessimistic, but I do generally expect things to fail first time (but then again I'm less bothered by that because I expect things can be 'debugged' and fixed)
I’m really interested to know what the other 1 in 10 is now. 
This is what the eval'd code contains: [https://www.unphp.net/decode/bd3294e75236248d454bd1f0b4320ed8/](https://www.unphp.net/decode/bd3294e75236248d454bd1f0b4320ed8/) Unfortunately I gotta leave and can't look into it further.
The main difference appears to be that before it was only when you loaded the file path that it caused an issue, whereas when using file_exists it can cause code to be executed directly. Again, no idea who (except probably Drupal) would give the user full control over file paths.
There are polyglots so the attacker can upload a harmless jpg and parse it as phar. 
A non-exhaustive list of obfuscated PHP I've found on websites (mostly wordpress and zencart): * Remote execution backdoors like this one * Credit card loggers * Spam emailers * Database tools * A javascript Snake game
Many ways. One obvious way is hijacking composer.phar downloads at the moment of provisioning your build environment with a dodgy copy that could mess with your app.
That's a dangerous assumption to make.
Wow, im surprised by how deep it goes. All that but cheaply found by the first look into WordPress directory.
Laravel does a good job of handling inputs but you really need to read the Illuminate source and understand what it does. 
I don't get it either. My understanding of the vulnerability is "If you use any file operations on a maliciously constructed .phar, using the phar:// stream wrapper, arbitrary code included in the phar can run". Thing is, I've never heard of the phar:// stream wrapper, nor seen code that uses it. [The docs](http://php.net/manual/en/phar.using.stream.php) do a terrible job of explaining what it's for. I'd be inclined to treat an uploaded .phar like I would an uploaded .php file anyway. (IE, don't let people upload it in the first place, and if you do find one, kill it with fire.) This feels a lot like scaremongering by Ripstech to sell their scanner service.
Yup , you're exactly right. 
This isn't an attack that lets people execute arbitrary code on anything running PHP. If it was it'd be massive news. Laravel's only vulnerable if it does the thing with accessing phar files over a phar:// stream wrapper that the article describes.
&gt; A javascript Snake game I was hoping there would be something ridiculous like this. Thanks!
polyglots are exploitable in the browser if the malicious file can be uploaded and if it is not blocked by CSP (like if it is served from the same domain) and if the site is also vulnerable to XSS. How can the polyglot jpg exploit be used in a PHP context if you are not also **including jpg files using `require` or `include`**?
1) "Exploitations" (sic) that require some flawed premise in the first place, like "be able to plant a crafted Phar file on the targeted web server" are NOT the language's fault. Grant me the abiliyy to upload a file to your webserver and I'll be able to screw it up like it's christmas, but I won't be unprofessional and call it a vulnerability on the part of the language your website is written in. 2) If a jpeg file is interpreted as a PHP file it's NOT the language's fault. 3) Notice how the paper's title doesn't mention either "exploitation" nor "vulnerability". Please be professional and responsible and change the sensationalist title of your post or just remove it altogether.
Echo $result[‘time_worked’] instead of sum(duration)...
hah! Right? Im not someone who posts this kind of stuff often and also who has no training in writing code. I appreciate the insight and suggestions! I have applied them and it worked, THANK YOU!
Oh yeesh, this was a dumb move on my part. Thank you for pointing it out and getting me on the right track!
I'm in complete agreeance with what you are saying. The title is complete clickbait, because it knows it can grab attention with "PHP INSECURE? MORE AT 11" I also noticed the introductory sentence beneath the header image says: "a new exploitation technique for **PHP applications**" which is a little more true to the point. It's an exploit that works on generic PHP applications that call user-supplied files over the `phar://` stream wrapper (which - if I understand it correctly - is already a huge WTF for the developer). Not at all a real issue that comes up frequently. "Luckily" this blog is written by a company which makes money by convincing you that there are dangers and securities around ever corner with our language of choice, so they are obviously unbiased! Not to say they are obviously lying or bending the truth (even though they probably are), but they certainly would benefit from convincing you that this is a PHP-level problem that is avoidable with better coding. That said, couldn't PHP developers actually take ownership of the problem and fix it in the core? Make it so it's a little harder to intentionally open a vulnerability? It may not be a problem with the language, but it could be solved by the language. That would be nifty.
&gt;This feels a lot like scaremongering by Ripstech to sell their scanner service. Obviously it has to be a sales move to an extent. They want to show you a danger, and show you how you would have never noticed it, but luckily you can pay them to keep you on the fore-front of every potential danger. But if it were a real danger, we would see a patch upstream in PHP source, which lessens their need for their service. So their bread and butter is: "dangerous programming mistakes that aren't so dangerous they need to be fixed but are scary enough to convince you that you need this scanner to stop them." But seriously, where in the hell has anyone used the \`phar://\` stream wrapper, especially on user-supplied content? *That* is a paper I would read, is any legitimate use of this setup that isn't either awful programming or a "manage your phar files" application.
Love this article. Keep sharing
Just use a decent ORM and stop living your life in pain.
The fact the jpeg file is interpreted as PHP? It's not a language problem. I do mean it. It's an issue of the webserver and, going a bit out of my depth, I believe it may be an OS or even more fundamental issue, since files aren't "judged" by their extension.
Oh, no, I don't think it is a language problem. Sorry if that wasn't clear enough. I'm actually just wondering if it's a problem PHP can find a solution for, too. Like not unserializing a `phar://` stream wrapper without explicitly flagging it as such or having more sanity checks before execution. Just some spitballing, not like I have the answer for it right now. Kind of like how PHP provides prepared statments, even if your DBMS doesn't do so. It doesn't have to, but it's nice it provides that protection if you want / need it.
I honestly don't work as much with phar (and even less with phar streams), but you may have a point there. Of course you can always open an issue and see how this goes =)
kullanıcı adından ismini, linkedin profilini falan çözdüm. benim kullanıcı adımı unutma, yıl sonuna doğru sana iş teklifiyle gelebilirim :)
Laravel still king. Faker, Monolog, phpUnit and PhpSpreadSheet also on the lead.
I agree man. Every time I write in php I have to code a new version of php in c and also rehash my own implementation of apache. /s
I'm not sure I get what you mean, fmt is a shorthand for format 
&lt;input type="hidden" value="whatever" name="hidden value"/&gt;
&lt;input type="hidden" value="whatever" name="hidden value"/&gt;
&lt;input type="hidden" value="whatever" name="hidden value"/&gt;
Looking good 👍
&lt;input type="hidden" value="whatever" name="hidden value"/&gt; 
yeah that's what I was thinking. So I guess my best bet is using Ajax then?
Been doing that for 9 months. Pay is great, but so frustrating. Finally getting to work on new stuff, and improve some of their automation processes.
Voow güzeldi bizden girini görmek. Güzel teklif düşünebilirim. 
Nice. It must be a refreshing change. I loved writing code from scratch for an entirely new project. 
that's just the same problem. once you send data to the browser, you have to rely on what it's sending you back. if it has to be static, keep it on the server - i.e. put it in a session-var or something like that. in short -start session -store static var to session -send form to user -on return of form join static var from session to dataset (not sure if this is useful for your exact problem though) 
https://github.com/trending/php?since=monthly This has some that are missing from your list. Carbon, Doctrine , Docker being a big ones. 
that is expected behaviour. diff the production php.ini and the development php.ini 
Well it's not completely static, I have multiple forms created dynamically with javascript innerhtml on the client side, and with each form I want to pass a separate specific value. So it's not completely static, just not inserted by the user 
I have an interesting "test machine vs. prod machine" issue. I am working on this wordpress web site that has a whole lot of custom fields, including repeater fields. As such I have been writing a lot of code to display those fields on the front end. One problem I noticed just today is that I get different HTML depending on where the PHP code is run. Given this sample of pseudo-data: acf\_heading: "list header 1" \- list item \- list item 2 acf\_heading: "list header 2" \- list item 3 \- list item 4 the production server tends to return 3 or more items instead of 1, and it usually looks like this &lt;h1&gt;"list header 1"&lt;/h1&gt; (no list) &lt;h1&gt;"list header 1"&lt;/h1&gt; (no list) &lt;h1&gt;"list header 1"&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;list item&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;h1&gt;"list header 2&lt;/h1&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; The error always occurs with the first header. My test machine, on the other hand, displays everything correctly. Which makes it difficult for me to debug it. Has anyone else come across this kind of situation? How did you deal with that?
Data coming from Github Archive ([https://www.gharchive.org/](https://www.gharchive.org/)) WatchEvent ([https://developer.github.com/v3/activity/events/types/#watchevent](https://developer.github.com/v3/activity/events/types/#watchevent)). Carbon is at rank 35 taking last 30 days data. Github trending ranking looks little bit tricky, as I am not sure if it uses current month data or last 30 days, and also when watching the stars for each repo, it doesn't follow a decreasing order always &gt;.&lt;
You can encrypt the value if you don't want to risk users editing the hidden field through the inspector. 
What's the name of this admin panel theme and where can I get it? 
Was there a specific reason you chose Symfony for this? Was it better to use this route rather than developer from scratch?
Bardak görseli süper. Ürün de güzel duruyor, ellerine sağlık. 
How do I know which form got activated on the server side though? They all go to submit.php (action="submit") and they all have the same input (input name="name") 
I developed it in my free time. It lasted about 7 months with the other packages.
Please use /r/phphelp for support. This is not a support subreddit.
Then you use a hidden field as suggested. That's perfectly fine for something like that. Another option is to use a parameter in the `action` field to tell the receiving code which form was used (i.e. `action="foo.php?form=register_user"`).
This still isn't working but it has been changed a lot. php here: [https://pastebin.com/8iiS4jzc](https://pastebin.com/8iiS4jzc) and the html here: [https://pastebin.com/iyPaxAdH](https://pastebin.com/iyPaxAdH)
My summary won't live up to the [original paper](https://github.com/s-n-t/presentations/blob/master/us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf), so if you want all the details please read that (in my opinion very good) paper instead. First, let's clarify some facts. A PHP Object Injection vulnerability in a modern PHP application that uses composer usually means arbitrary PHP code execution. There are quite a lot popular libraries that allow to do this (e.g. Monolog). To trigger the vulnerability all you have to do is to control the first part of a string that is passed to a file related function and somehow be able to drop a Phar file on the server (but it does not need to have a .phar ending). Yes, I agree, file paths have to be very, very carefully validated, especially if user input is involved. Though, there are quite a lot of functions involved in this issue where you would not expect that they have any side effect and this makes it dangerous. How certain can you be that none of the libraries that you are using does a file_exist on a string before validating the input further? Or the other dozens of functions that were not named? The second requirement, having a Phar on the server. If you allow to upload images to your server you are probably affected. If you read the paper you can see that at least Typo3, Wordpress, and TCPDF were or are affected. We have also started to analyze many projects but disclosure takes its time. In a nutshell, I think this is a serious problem that has to be addressed.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [s-n-t/presentations/.../**us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf** (master → 6b197aa)](https://github.com/s-n-t/presentations/blob/6b197aa570c751a0e967a953d6b72f5e8dbfaccd/us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf) ---- 
Looks great dude!! - To be honest, wish I had found this before I started one from scratch a few weeks ago \*whoops\*
 _________________________________ THIS IS FIXED! I FIGURED IT OUT TODAY! I THINK IT WAS LITERALLY JUST A MISSING PERIOD BETWEEN STATEMENTS.
Seconded! What sort of customisation/flexibility did you lose depending upon Symfony??
1) If you are not using a cloud service like AWS you do not have many choices to store files but on the hard disk. That is, if you want to allow your users to upload files like avatar images in a forum. It is not necessary that the file is in the www directory, it could be in /mnt/storage/ or anywhere else as well. Not too unrealistic if you ask me. 2) The jpeg file is not interpreted as a PHP file. 3) This is the terminology, it is not like we made it up. Finding and fixing vulnerabilities in PHP applications before they can be exploited is what we do at our company, that's the reason why we use them. The name of the paper is us-18-Thomas-It's-A-PHP-Unserialization-**Vulnerability**-Jim-But-Not-As-We-Know-It-wp.pdf by the way ¯\\\_(ツ)_/¯
Good stuff. Then yeah all it's going to take for OpCache to speed things up is for you to configure it appropriately for your app/site. I used to be a System Administrator and would always enable and config OpCache for customers complaining about slow sites. Well at least if their server had 2Gb of ram or more. These are some default configs I'd start with and tweak from there. opcache.memory_consumption=64 opcache.interned_strings_buffer=4 opcache.max_accelerated_files=7963 opcache.revalidate_freq=120 opcache.fast_shutdown=1 opcache.enable_cli=1 opcache.enable=1 Even [WP Rocket is compatible with it](https://docs.wp-rocket.me/article/673-what-is-opcache) and if enabled will give you an option to clear out OPcache. If the majority of your site can use the WP Rocket's Page Cache then you'll see the most improvement in the Admin's speed and in operations that cannot be cached.
Personally I just use static and set it to the number of processor cores * 1.5. On PHP 7+, RAM, with some rare exceptions, such as building ZIP files, never comes into it. This assumes external resources such as database servers are sitting on the same network with a few microseconds ping. If you're running a slightly higher ping then yes you can up the multiplier, but in general under any serious traffic you're likely to be CPU bound. More threads gives more connections to external resources. Even if you have 32GB of RAM on your PHP nodes, why force your database server to deal with 20x the number of connections when they don't have enough processor time available to actually run with true simultaneity. 
Honestly, that comes off as remarkably salty. 
Working from your second decode, it's a plugin manager. Plugins can be added and removed by post requests. The large comment in the original file is where the plugins are stored. 3rd layer! https://www.unphp.net/decode/7403f6702101cc7a02e3a092c573cedf/
Change the form name or button name. Can't remember which one. You can then check if the name of the submited form.
That's what I'm saying. It's as reasonable to expect someone to do that as it is to expect them to eval a `$_GET` variable. Nobody uses the Phar stream wrapper to work with jpg files. That has never been common practise. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
!RemindMe 1 day
I will be messaging you on [**2018-08-17 06:48:46 UTC**](http://www.wolframalpha.com/input/?i=2018-08-17 06:48:46 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/93e5f9/what_is_the_natural_progression_from_basic_php_to/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/93e5f9/what_is_the_natural_progression_from_basic_php_to/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I think my mantra more or less today is: "Expect things to work, but don't be surprised if they don't. Just always be ready to get your hands dirty."
What special kind of "customisation/flexibility" do *you* need that is not offered by a major framework?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bolt/bolt/.../**LICENSE.md** (3.5 → ac93fcb)](https://github.com/bolt/bolt/blob/ac93fcb5ca20a95a59fb4a37c486b39ff5d3f279/LICENSE.md) ---- 
What about the saving up the 90% of the work? 
Is that enough? Since an application working with database is mostly IO, so PHP processes are idle in the meantime. I achieved highest performance using core \* 4 - that's of course too much for CPU intensive code, but for a CRUD API this was fine.
They'll want to 1. update WordPress from a downloaded Zip, not the auto-update functions, because there's a reason that WordPress security updates happen thick and fast, and if it was me, the first thing I would poison in a wordpress is the auto-update capability, so it installed a compromised version for me from my own servers, or just stopped updating full stop (but, I'm a mean little bugger who thinks about these things and never does . 2. Make sure the web server user (likely www-data) doesn't have write access to anything on the server - grant it temporarily when adding new plugins etc, and has no read access to any files except the ones its meant to be serving up to end users. You'll also want to update the database credentials, and ensure there's no direct access from anywhere but the server, because they've almost certainly had some sort of terminal access if they've uploaded any scripts (the first thing people do once they get in at this level would be a simple reverse ssh handler), which means they've got the database. If the site handles user registration of **ANY** kind (be it logging in, or even just mailing lists), they have a moral responsibility to notify their users that their names, emails, hashed (I hope for their sake they were hashed) passwords and usernames have been exposed. If they are in a country affected by GDPR legislation, they also have a LEGAL responsibility to notify users of any information leakage. Failure to do so carries a reasonably large fine. Search the code for anything eval, exec, passthru type functions, as well as anything looking for remote URL's (stream wrappers and the like). Hopefully the site was in source control, so you'll have a clean copy to compare it against in the case of any modified core files?
Do you know why there was a delay getting to PHP7.2 where they having issues with it?
To the system commands, you should also add to the list of things to search for to unexpected file\_put\_contents, fwrites, etc. Because you don't need an exec if you've already uploaded a file that uses get and write calls to stick random files on your server, wherever you want to. In its simplest form: `&lt;?php` `file_put_contents($_GET['path'], base64_decode($_GET['filecontent']));`
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Yes I should do this, thanks.
We are not trading time for money. We are trading value for money. Even if you are billing hourly the client doesn't value your time. They only value the worth of the product you give them. An hour of my time has a different value depending on what the task is. Sometimes you can provide massive value in a very small amount of time, and sometimes its the complete opposite. To place a value on the time itself communicates the wrong message to the client. Its impossible for non technical person to understand why adding an extra column to a data display might takes 10 times longer than creating animated charts of that same data. In this industry we are worth a lot more than our time. And if we aren't then the project isn't worth doing. \&gt; the value of the project could end up less than the value of your work Then the project isn't worth doing is it. Why the hell would you do a project that isn't worth the time you spent on it?! Would you do a project like that for yourself?! Why would you expect a client to pay for that?!
It's more flexible than the other, and Symfony 4 is really fast. I love Symfony :) [http://www.phpbenchmarks.com/en/comparator/frameworks.html](http://www.phpbenchmarks.com/en/comparator/frameworks.html)
1) Nobody expects that, nobody said that, and the file upload is only relevant because we have to have a file on the server were we control the first 100 bytes. The [original paper](https://github.com/s-n-t/presentations/blob/master/us-18-Thomas-It's-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf) also mentions that sessions can be used in some circumstances as well. 3.1) Yes, and the vulnerabilities of this problem are in applications obviously. The same as for SQL Injections, Command Injections, Code Injections, or similar vulnerabilities. It is still a problem of PHP because it is very easy to do it wrong and many people are doing it wrong. No programmer would expect this to happen. 3.2) No, it isn't. It is the **file name** (i.e. name) of the paper, it is neither the title of the paper nor the URL of the paper.
I know, I know. Sometimes the difference between magic string or not magic is slight;) Like even in the link with Symfony tags. The are some properties `public`, `tags`, huh? Just for the first sight these said nothing, IDE does not understand those in any way, and basically You can write there anything and app will or will not just fail:) Annotations at least in Netbeans are possible to configure to autocomplete, so it's not that bad.
AWS is always slow to rollout changes to EB
&gt; We are not trading time for money. Keep telling yourself that. Unless your work is going to pay you residually, you are trading time for money. Maybe it's not hourly, maybe a quote is for an entire delivery, but it's still giving someone else time your time, for money. ... and Bingo on re-iterating the point I made. The value you put on your services doesn't necessarily mean the project warrants it.
https://www.nightlionsecurity.com/blog/news/2014/phpstress-dos-attack-php-nginx-apache/
You might like it or hate it. Doing things opposite is not necessarily bad (Inversion of Control?). This technique is used in real application, maintaining around 500 associations between components. Can't imagine keeping all of this in configs and to maintain manually:)
&gt; It's an exploit that works on generic PHP applications that call user-supplied files over the phar:// stream wrapper (which - if I understand it correctly - is already a huge WTF for the developer). Not at all a real issue that comes up frequently. As I wrote in my previous posts, this is not true. You only have to control the beginning of a string that is passed to an affected function and this happens a lot. So it is a real issue that comes up frequently. &gt; "Luckily" this blog is written by a company which makes money by convincing you that there are dangers and securities around ever corner with our language of choice, so they are obviously unbiased! It is our language of choice as well. RIPS is to a big part written in PHP, so problems with PHP affect us as well. I am not saying we are unbiased but our goal certainly is not to badmouth PHP. &gt; Not to say they are obviously lying or bending the truth (even though they probably are) We are not. &gt; but they certainly would benefit from convincing you that this is a PHP-level problem that is avoidable with better coding. It is a PHP-level problem because it is so easy to do wrong and you would never expect it to have this effects. The actual vulnerabilities are obviously in PHP applications though. &gt; That said, couldn't PHP developers actually take ownership of the problem and fix it in the core? Make it so it's a little harder to intentionally open a vulnerability? They could, they should, and we hope that they will do it. It is still not an easy thing to do because of compatibility.
Well, interpreting data (especially running unserialize) on a simple file\_exists call IS a language problem.
regarding: volatile and transient the only thing I could find about this is pthreads with regard to volitile, how rare do you think it would be that someone actually uses pthreads extension? and transient I believe are the __sleep/__call / etc methods.. which I thought were known by the term "Magic Methods" which basically are reflection-based calls in php that can listen to __get/__set/__sleep etc I think they also have __static? I forget, have to look it up, but they're highly dynamic and called on special workflows when existing methods don't match declarations, or some special workflow happens that you're accounting for. All these darn "Magic" ORM's use them.
what kind of things are you doing in terms of caching/speeding it up? I built an API with laravel but the server wouldnt cope if there was huge demand so we had to keep adding in servers when we were launching someone.. 
Yes, PHP is good for freelancing when it is full time..
So we are using AWS for most things, sessions are stored in redis, memcached for cache, also using AWS DynamoDB for our nosql needs. We are using laravel on the back end with react on the front end. Is laravel a little overkill yea but our team had the most experience with it and allowed us to rapidly build so it stuck and we haven't had any issues scaling it on AWS. 
&gt; They already put in an undetectable kernel-level rootkit and your server has joined the botnet. They can't do that if your server is correctly configured. If your web server has root access, wtf are you doing ?
This is probably nothing, but stuff like this always makes me think that they see EB as some kind of gimmicky bastard in otherwise glorious family of services.
It's documented here : https://github.com/antham/ghokin#fmt-stdout and when you do ghokin --help so...
I have a generic multi container setup with a bastardized version of laradock and I always have the latest PHP version (of the php7.2 branch) without any issues
Yup, our ratio was different - about 5 - 25 ms execution, 10 - 80 ms querytime and yet more ms for ES/Redis. So, in our case, execution was minimal compared to IO.
That looks very nice! Haven't download/tested the demo, but it looks pretty damn solid! Good job man!
Are you executing hundreds of queries per request? Personally I find with a properly indexed DB sitting on a server with plenty of RAM my queries and redis calls are measured more in microseconds rather than milliseconds. 
I actually copied my test database into the prod mysql server, so the data is the same.
works here on good range of browsers, including chrome. Network problem ? 
Your databases probably aren't remote and they're optimized, because you can optimize them. :) This was setting used for an API, which was used as a wrapper for MSSQL database of a procedure driven ERP (that's why we can't optimize - it wasn't our system), so that mobile devices could access its data.
As I said &gt; Root escalation is pretty trivial once you have access to execute any commands on the system. 
&gt; It occurs to me that I could simply use variables/constants to hold common joins. This is what a query builder for. &gt; I google MySQL views and find the advice that they're generally a performance suck And it was probably an [article](https://www.percona.com/blog/2007/08/12/mysql-view-as-performance-troublemaker/) written a **decade** ago. And you never even tried to see whether **your** views are slow or not. So you just took some outdated info for granted and made an architectural decision without any real life data. That's the way all decisions have to be made for sure. 
Can we upgrade from 7.1 to 7.2? I don't see that option.
Using a view is a good choice if you are calling again and again the same query in different strings. The storage of repeated content in a var is common, and is useful, remember not to expose your query to sqlinjection and all will be fine. As a personal preference, if your examples are php, i like using the double quotes to insert vars in my queries, the result is cleaner and easier to mantain as you can see wich quotes are for the string concatenation and wich ones are for query string values. Example: const myvar = 'tbl1 JOIN tbl2 ON tbl2.id = tbl1.id JOIN tbl3 ON tbl3.id = tbl2.id JOIN tbl4 ON tbl4.id = tbl3.id'; $sql = "SELECT id FROM {$tbls1to4} WHERE value = 'myvalue'";
The one view I've created is fine, but it's two relatively small tables. I ran some tests and it performed identically to the original query. I worry about bigger tables and using aggregate functions though, which I understand force a view into temp-table territory rather than merging?
constant string values are too seldom to talk about
Then go on run your own tests in your own environment and your own data. Another way would be to use an ORM that will build all SQL for you. 
I've only switched to prepared statements a few months ago and I found searching for "SELECT (etc) in my code (with the leading quotemark) a simple way to find queries I hadn't yet parameterised. As such when I fixed a query I'd write it with single quotes so it didn't show up in my next grep. Now that I've converted them all I still intentionally use single quotes for my SQL - I find it helps discourage me from being lazy, slipping into my old ways and embedding a variable. 
I didn't even understand his comment, fwiw :P
Search about index in mysql, if you are joining tables crossing id it shouldnt be a problem, if you are crossing them using columns not indexed, you should, or your performance will drop dramatically-
Okay then, i was only posting my way of doing that :) every tool has its use.
The only case when you find a single quote in SQL query is a constant string value written as is, like in his example: `WHERE value = 'myvalue'";` Such a case can be found too seldom to make it affect the code style for the whole project. Is it clearer for you now? 
It wasn't really good in 5.7 . However, thanks to imprivements for JSON field in 8.0, it is possible to assign an index on a key in json. You may give it a try.
Yes. Although FWIW in my codebase I often check for empty strings, and do end up having to type \'\' due to my code style. I'm ok with it though. Regexps, too.
My queries are as well-indexed as I know how to - I regularly check slow_log etc and improve where necessary. 
The visual debt part isn't even a belief the author (Taylor Otwell) has spoken up about. That was purely the community "coming up" with it and spreading it. 
Teşekkürler, aslında o girişimimin logosuydu ama değiştirdim tabi bu şekilde kaldı.
I try to see problems within problems when it comes to sql queries. It helps me to narrow the focus of queries and to build up queries that are fast because the subqueries are fast. Knowing how to read an explain really helps. Knowing what types of indexes to maintain really helps. 
It all depends on the end goal. You don't win much from views in terms of raw performance. You win in simplicity. Especially when you have to replace tables. First thing I do is concentrate all the database queries inside objects. Not just for MVC, or OOP principles. It reduces the surface area you need to modify when making changes. Next thing I go for are indexes, and create the queries around them. As a last resort, denormalizing could be an option, especially for tables that are very coupled. I've rarely used it in recent years, it's an anti pattern, but desperate times call for desperate measures. 
Query Builder. You want to be at a point where most of your DB queries are generated by a builder, not written by hand. 
Yes, There was no option for upgrading 7.1 to 7.2. I don't will they provide or not.
I don't like to use views or stored procedures because they become hard to keep it in a vcs (git, svn, etc). I prefer to use query builders and ORM most of the time. For big queries I use a string with the [heredoc](http://php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc) syntax. $sql = &lt;&lt;&lt;EOSQL: SELECT id FROM tbl1 JOIN tbl2 ON tbl2.id = tbl1.id JOIN tbl3 ON tbl3.id = tbl2.id JOIN tbl4 ON tbl4.id = tbl3.id WHERE value = ? EOSQL; 
Maybe you should look at your general code structure rather than the SQL. Repeated similar queries might be an indication of the code that is not well organised. Personally I have SELECT queries almost exclusively in class-&gt;collection() and update queries in class-&gt;update(). 
&gt;I am sorry but I couldn't provide you with exact numbers, I used it a couple of times but never really did a performance comparison test since on the applications where I used it, performance was never a big issue. (mostly intranet stuff for smallish crowds) Wow, thanks! I didn't know that. I definitely have have to try it out 
I'm not a big fan of automagic &amp; wrapping techniques / scripts using laravel (e.g. mix instead of webpack). We used to use laravel asset helpers, but decided to go without it. Can't really remember why, tbh. As we're running on quite a number of production application servers, git-pull deployments aren't really an option + it doesn't really fit into a CI pipeline with multiple staging areas (at least in my opinion). I've setup an AWS Codepipeline / JetBrains TeamCity / AWS CodeDeploy Pipeline in the last 2 days - it was quite a task, but eventually it worked out as expected. Just as hinted by /u/davedevelopment :-)
Thanks again, /u/davedevelopment, We're now using TeamCity to build, test, deploy to CDN &amp; update version.json. It then .zips the source to S3 and triggers AWS CodeDeploy using AWS CodePipeline. Was quite tricky to set up, but well worth the effort, it seems.
Maybe not ideal, but I would try to: 1. Move all queries to separate class or classes (if you can draw a line between separate contexts), each distinct query to separate method. Pass input parameters as method arguments. 2. Inject these classes as constructor parameters where needed or make them static if you're not into dependency injection. 3. Try to find common SQL patterns in these classes and move them to separate private methods. 4. If your queries are not too complicated, you can try to replace building them out of strings with some query builders. Make sure it doesn't hurt application performance too much. Personally I would stick to old plain strings.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I use EB for many large projects and it works exceedingly well. Although it is essentially just a UI for CloudFormation. 
You dont get it. The attacker injects phar:// in a file operation that you think is harmless,like is_file or md5_file
I just weep softly into my terminal
Maybe. They’re not exactly quick at deploying new versions of stuff to other popular services like Lambda, either. It took a long ass time to get Node 8 support. 
In add-user.php, when validation fails (username already in use) store the error message and submitted form data in the session, then redirect to the form. Now the form can show what was wrong with the submitted data by showing the error message in the session, you can also prefill the form fields with the incorrect data so the user can correct it instead of having to enter it all again. Don't forget to remove that information from the session after showing it.
You can perform the submission as an ajax post. No page reload when post fail and show error message. Or the ghetto version, your form page and adduser post page should use the same template for the html form. On error your post page just return the form again.
I stored the error message in a session if the username is taken. In my controller for index.php i made $error = $_SESSION['errormsg']; and then I unset($_SESSION["errormsg"]); and in my index view file I made a if statement to echo $error if its set : https://pastebin.com/iV0x8PrJ , but I'm still seeing nothing in my html so it must not be setting. Am I doing this wrong? All of my issues here are because the add-user.php file can only be accessed throught a post request. In other peoples code I see online in a form post form request, you can still access the file without a post request, so should I just make it so that I can access add-user.php without a post request? I thought this was bad practice but I can't find a way to display my error message otherwise. 
Ajax is the best answer. There’s some decent plugins, I’ve had good luck with this: https://formvalidation.io/features/... maybe a slight learning curve depending on your JavaScript competency. They switched to full ES6 I believe, so different than when I last used it. But once you’re familiar, it does a lot and simplified different validation types. Basic type checking is simple, tho you’ll want to do this via Ajax and Post. You can also do simple Ajax checks while returning response from the PHP file with straight JavaScript. 
What does your sexual orientation have to do with anything?
What will your role be on the new team? That'll determine in large part how things ought to be slanted. But in general, if you express a commitment to learning and to clean code, you should be quite hireable.
They have some scripts used to transfer data between Oracle and SQL Server. I will be recreating those with SSIS, and I guess making some changes to the PHP along the way
One thing I like to do is put it in heredoc notation so it highlights correctly in your editor.
^ this @OP on the app level, views are not ideal because they are database specific and hard to document. Views are more ideal for database admins or for generating reports, for applications you really want something like Eloquent or Doctrine to manage repetitive database work and represent your data better. 
The point is: does the following code look bad? is_file($_GET['file'] . '.jpg') Yes. Does it look like a code execution vulnerability? So far: no. Now it is. ?file=phar://... The attacker abuses the phar wrapper, it doesnt matter how uncommon phar is used by developers.
Just in case anyone is honestly considering this. It's a scam. No competent hiring manager would ever consider these certifications as worth anything at all.
The question is not how to write a big query. 
Sweet, sounds like a pretty quick turnaround time, glad it's working out for you. We were tempted by CodeDeploy and CodePipeline, but they were not available in EU-WEST-1 at the time, so we made do with jenkins and ansible. 
Yeah but if I want to know what "fmt" is, I first have to do --help, or open the external documentation. The whole point of UX is to make it feel intuitive and easy to use, which "fmt" is not. Just call it "format", it's an easy change, quick win and saves people from looking up the documentation. 
Well, maybe the scary outsourcing companies?
Seems good. You can also try www.ZetExcel.com
I don't know how you use a cli, but I read the README before using a cli, you must read some example to understand the way it works. fmt is a common idiom for format look : * https://github.com/rust-lang-nursery/rustfmt * https://github.com/dart-lang/dart_style#using-dartfmt * https://golang.org/cmd/gofmt/ * https://github.com/scalameta/scalafmt
Hi, Im fairly new to reddit, PHP &amp; wordpress so go easy on explaining things but help would be greatly appreciated. So I've set up a menu that uses custom fields to get the thumbnails, assigns them to a variable $thumb and then creates a bit of HTML that covers multiple menu objects with their respective thumbnails, text and a button. This works perfectly, however I've tried to set up an else statement that checks if no thumbnail is set and instead puts a placeholder image in place. Ive put an arrow to the line thats giving me trouble, but for some reason its just not getting the image and totally breaking everything. everything works to do with setting the custom fields but once I put the else statement there it just goes kaput. add_filter('wp_nav_menu_objects', 'my_wp_nav_menu_objects', 10, 2); function my_wp_nav_menu_objects( $items, $args ) { // loop foreach( $items as &amp;$item ) { // checks if thumbnail is set $thumbtest = get_field('menu_thumbnail', $item); if ($thumbtest):?&gt; &lt;script&gt;console.log('true')&lt;/script&gt;&lt;?php $thumb = get_field('menu_thumbnail', $item); $menu_title = get_field('menu_title', $item); //sets placeholder img if no thumbnail is set else:?&gt; &lt;script&gt;console.log('false')&lt;/script&gt;&lt;?php -----&gt; $thumb = get_template_directory_uri().'assets/images/placeholder.png'; $menu_title = get_field('menu_title', $item);?&gt; &lt;?php endif; // creates thumbnail and respective text if( $thumb ) { $item-&gt;title .= ' &lt;img class="thumb-imge" src='.$thumb.'"&gt; &lt;div class="thumb-cover"&gt; &lt;div class="thumb-container"&gt; &lt;h5 class="thumb-text"&gt;'.$menu_title.'&lt;div class="underline-thumb"&lt;/div&gt;&lt;/h5&gt; &lt;span class="thumb-button"&gt;View&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/img&gt;'; } } // return return $items; }
Good tips. I'd add running CI tools (especially tests!) against a supported PHP versions. You should always try to update PHP versions, if it is that painful to update something might be wrong in your design (unless it's a major release).
I'd suggest just reading the symfony docs/book from the official website
You misunderstood the article, this is not a requirement. I think this guy explained it pretty good: &gt; The point is: does the following code look bad? is_file($_GET['file'] . '.jpg') Yes. Does it look like a code execution vulnerability? So far: no. Now it is. ?file=phar://... &gt; &gt; The attacker abuses the phar wrapper, it doesnt matter how uncommon phar is used by developers. 
Hands down the most helpful answer given, thankyou so much. Answered my question perfectly.
Ah, okay. Then I agree, they are usually only dangerous in combination with an already existing vulnerability (like user input in is_file).
https://www.reddit.com/r/PHP/comments/97j4bv/new_php_exploitation_technique/
ITT: The dogma that PHP is as secure as anything else \*is more important\* than understanding the ways its insecure. 
To my understanding, it is not a *remote* code execution as a file must be present locally. I am not that good with the terminology though.
You are welcome, I thought it was a valid question. The down votes were totally unnecessary but that's Reddit.
Guess so. I'm no dbadmin so I didn't know about that. Although, having read about it now, I'd probably still have done it my way, because I prefer to log to a database table than a text file. Which it seems the slow log doesn't do.
See the last few slides on how to upload a temporary file / image containing a PHAR archive.
&gt; To trigger the vulnerability all you have to do is to control the first part of a string You make it sound easy, yet in the paper every example attach they describe requires admin access to the CMS that is being used. Note: The TCPDF example is an issue is actually an issue with Contao in my opinion. You mention Monolog. Do you mean to suggest people might allow a user to configure their log file location?
A vulnerability in which you upload a file not meant to be executed and cause code within it to be executed is considered remote code execution.
It's a bit more involved though, as the attacker also needs total control over the full string passed into file_exists. Doing a file_exists without a protocol on a file is safe, it's only if it's done with phar:// on a phar file does it become problematic. Since you shouldn't ever trust user-input, you shouldn't ever be calling file_exists with user input anyway, so most people will not be affected by this.
While that's true, it has nothing to do with what I said or the comment I'm replying to.
I think 8===&gt;
It's not about file\_exists but a stream wrapper, so any file related function is affected. If you, for example, pass unsanitized user input to any of the file functions (like file\_exists, or file\_get\_contents), you're affected. It has nothing to do with include and the file does not have to be present on server. You should sanitize your input (now with special care about used wrapper) and PHP devs should prevent loading serialized code in phar metadata.
I avoid making abstractions of SQL as much as possible. It makes your SQL unreadable, means the IDE can't help you and if you need to do something that your abstraction can't handle like joining a table or grouping records then you have to evolve your abstraction instead of just adding another line of SQL. Don't worry about repeating things like SQL syntax and table names. SQL syntax is as abstract as it needs to be, if there was a more abstract way of expressing it then we would use that instead of SQL. I've heard people argue that it's good to stick table names and column names into constants "in case they change" but if you think about it, the table name is no more likely to change than the name of the constant. In effect, the table name is itself a constant. There are exceptions of course when you are building a filter query you might need to add or remove conditions depending on user input but at that point it might be worth using an ORM.
Oh, forgive me, I wasn't trying to say you were incorrect in what you were saying, but the technicalities are slightly more nuanced. Chained together it's RCE. In some systems, SQL injection can be chained together to end up with RCE. I've published exploits in the past where you go from fragmented limited-input persistent XSS into RCE (via CSRF) because the admin panel of the system allows you to throw PHP into the templates. The original attack remained an XSS. The original exploit is an unserialize exploit. Those tend to lead to RCE due to being able to unserialize an object that lets you do what you're looking for. In the absence of one, they're very limited. In this case since you're doing it to a phar, and if it's an attacker controlled phar, you gain RCE because you get to supply the code too. If I were giving the original exploit (phar:// wrapper unseralises data from the phar unexpectedly), I'd give it a low score on the remote because it can't be ad-hoc triggered (AV:L). The exploits found against the various products listed in the original talk are high scores on the remote (AV:N) because of the rest of the code around it let a user-controlled file be the phar in question, which _is_ RCE. TL;DR: My original reply wasn't saying you were wrong, but since you've prodded me to re-read your original reply I'll point out that the original exploit is an unserialize exploit. 
&gt;Try to find common SQL patterns in these classes and move them to separate private methods. \*sigh\* why??? just write your SQL queries in... SQL. If SQL could be any more abstract then it would be. All you do when you do this sort of thing is make the code harder to read, harder to evolve (you now have to evolve your abstraction to make a change that the abstraction doesn't support instead of just writing a new line of SQL) and break any SQL support provided by your development tools (IDE's etc.). This is a great answer of the DRY principle being badly applied. Don't Repeat Yourself means Don't Repeat **Complexity** it doesn't mean Don't Repea**t Cod**e.
&gt; Possible destinations for log entries are log files or the general_log and slow_log tables in the mysql database. Either or both destinations can be selected.
using file_exists on user input should be safe no matter how untrusted the input is. It's one of the functions used to verify input in the first place. E.g. user passed file name, call basename and check if the file exists in some directory before sending its contents. That might be safe in this case because of the call to basename but still you're passing user input to that...
not rce at all
why? I mean, I understand why you would use ORM, but SQL is already abstract, why would you use a query builder to build a query that is just going to be rebuilt anyway?
&gt; you really want something like Eloquent or Doctrine FWIW this is like saying "you really want to holiday somewhere like Syria or Hawaii". Eloquent should not exist.
This is really helpful. Thank you, I went without OP Cache, but once we finish our PCI Compliance I am adding this to my timeline to implement OP Cache.
&gt; You make it sound easy, yet in the paper every example attach they describe requires admin access to the CMS that is being used. It is easy to do it wrong and it is easy to exploit (in most cases). Though, file operations are involved and *usually* only higher privileged users (not necessarily admin users) are able to trigger file operations in a web application. If you are an unauthorized visitor of a WordPress blog there is not much you can do besides reading the blog posts and leaving comments. If you have something like a bulletin board software there is a much higher chance that normal users can trigger certain file operations in the code as well. It depends on the application. &gt; You mention Monolog. Do you mean to suggest people might allow a user to configure their log file location? No, there is a technique called (PHP Gadget Chaining)[https://www.syssec.rub.de/media/emma/veroeffentlichungen/2014/09/10/POPChainGeneration-CCS14.pdf]. This technique is usually used to exploit PHP Object Injection vulnerabilities by using existing classes to do bad stuff, for example executing system commands. This only works though if the classes fulfil certain properties and Monolog, amongst others, fulfils them. There are other ways to exploit unserialize. For example, a use-after-free vulnerability in the PHP-core was used to hack PornHub: https://www.evonide.com/how-we-broke-php-hacked-pornhub-and-earned-20000-dollar/
Are you implying a Tweet written by a juvenile is not good content for """Redditors""" to consume?
Free video series from Laracasts: https://laracasts.com/series/php-for-beginners
How about Udemy? Is it good?
This guide is pretty comprehensive and contains a good overview of what is useful to know about PHP and relevant/related technologies: https://github.com/odan/learn-php
Not really. There is no quality assurance, and a lot of the courses there are stolen from other places and reuploaded. Sometimes even free courses are stolen then sold for like $9.99. I'd really suggest paying for a subscription on Laracasts / CodeCourse or both. They both do really well thought out series that help actually "get" what you're doing, instead of copying and pasting code until it works.
Thank you will check it out.
So, you're going for composer/Laravel If you want to get better at PHP/Programming, it's not just "learning a framework", but, laravel is beautifully crafted, so, using it, you're going to see the pattern they have used. Try to learn about OOP, the usage of composition over class inheritance, SOLID Principles, try to learn TDD (TDD let you improve your design a lot)
Thank you. Been thinking about that SOLID thingy, I’ve listed it as one of my targets to learn.
If you want to get better at software development I would suggest not to use Laravel but rather Symfony. It follows widely adopted patterns across multiple languages and uses much less magic so you actually know what is going on. Don’t get me wrong, Laravel is great, easy to use with a massive boilerplate, it’s just things like Dependency Injection and advanced patterns that are not part of the documentation and you will never learn it properly if you’re just using Laravel. 
If you want my advice, go for composer first :), composer is kind of must today. SOLID can wait a week :)!
Wow, I always see this in every job listing. It’s either laravel or symphony. Is the job marker for symphony good?
[https://www.phptherightway.com/](https://www.phptherightway.com/)
I’m new to this community and wanted to learn first hand how you guys learn.
So I told you. We are using Google. 
I once watched the awesome Laracast [PHP Practitionner](https://laracasts.com/series/php-for-beginners) video tutorial serie, which will not only give you the main basis of PHP developpement, but also some of the insights on how is a router really doing by creating one from scratch, etc... And I like this serie because when you will complete it, it is an awesome introduction to the Laravel serie because you will have the weapons to understand what is an ORM, a router, an HttpRequest, ... Without having to buy the fancy $30.00 "all the design pattern in PHP" book and leaving with a fuzzy head and no practical application. I really recommend it, mostly with your background.
IMHO, you don't need a framework to work on PHP. Laravel is popular but it's not giving you anything extra that you could do by yourself in a couple of days. 
If your app is a single home page with HTML/SQL/JS spaghetti without any error reporting, debugging, logging, routing, templating - well, sort of yes, you could. 
Subscribe to laracast. That monthly payment is worth it.
How is that? You could create an MVC from scratch, it's not as hard, just a single index.php and a .htaccess (if you want a pretty url). For example, a fragment of code of MVC. $controller = new $op(); if (method_exists($controller,$action)) { $controller-&gt;{$action}($event, $id, $idparent); } else { CriticalError("incorrect action [$action] for [$operation]","Error critical"); } Then you could add a template library, for SRP and PHP supports OOP since 5.x. Spaghetti code happens because of developers, not because a framework, neither your code is free if you use x or y framework. Instead, if you don't use a framework, then you are free of dependencies. For example, Laravel adds +3000 php files. How is it not a mess or it's killing the performance? PHP 7.x+OOP is doing an amazing job, however, it's not magic. 
Very cool. The opcache is a must-have feature for modern PHP, but I rarely see its configuration talked about. 
&gt; Don’t get me wrong, Laravel is great You *are* wrong.
OOP is a good practice but sheesh, people are abusing it and they are created so many useless mumbo jumbo. In this case, it blows my mind why Laravel (amongst many other frameworks) uses injection and static calls... and containers!. Yuck. In comparison, Java EE looks like a breeze 
&gt; SQL is already abstract And different between different vendors.
Oh this is awesome.
being a programmer is about inventing, creating, failing, drinking and celebrating. Its about watching something start from a single line of code into a fullfledge application, regardless of size. Being a programmer is awesome. Working in an office, with deadlines, teammates, project managers, who in my case were not programmers, and office politics made me go work for smaller, home based (I worked from home as the only developer) companies where I feel I have more say. PHP and JavaScript, over the years have made me love and hate my job.
Thank you for this write up. One small question, how do you make those nice graphs from apache bench?
Allowing someone to read an arbitrary file is a lot different than allowing them to run arbitrary code. It's still a major bug either way because secrets can be stolen, but executed code could also be used to send spam or join a botnet or corrupt the server.
LE SUPER SMART AND TROLLEY """REDDITOR""" CAN’T ELABORATE ON VAGUE COMMENTS 😂😂😂😂😂👏👏👏👏🤠🤠👌👌👌
It seems no one suggested this one - find a company, where you can have your colleagues and team to learn from, where they are willing to help you grow as a developer, where failing is a way to learn and no one makes you feel bad about it. Learn from other people, because then you can ask questions straight away, which you can't do with laracasts or online courses (in some you can). Go to meetups if you're not a loner coder and like to interact with people. A lot of developers will be willing to help because they're growing themselves by helping you. If you encounter some that don't think this way - steer away from them because they're probably no good.
I feel like this only truly applies if you take no real initiative to try and improve. i started on laravel and eventually you get curious and start digging around the internals to try and understand why you’re getting a certain exception or why a method is behaving a certain way. I understand that laravel abstracts away a lot of the core symphony components that it uses and that symphony adheres more rigidly to psr standards. laravel made it easy for me to get going and is also structured well enough that i could look at the code and get a feel for how oop works and how design patterns work and DI works and then do my own research from there.
We do this at the company I work for, as well. Definitely recommend to anyone who sees this and likes it. 
Technically they are the same, all of them call a file called index.php (that it's in the root of laravel). apache -&gt; htaccess -&gt; index.php -&gt; web. nginx -&gt; nginx config -&gt; index.php -&gt; web. iis -&gt; web.config -&gt; index.php -&gt; web. However, nginx is not as flexible and it's only configured once per instance but other that, nginx rules. Then later, index.php calls Laravel's route.php 
&gt; What sort of customisation/flexibility did you lose depending upon Symfony?? Wat....
3edgy5me
Working 100% from home is pretty terrible. I think it's made me more bitchy towards co-workers. Before I could develop friendships with these people, now they are just some asshole calling me while I'm in the middle of work. I think a good mix is 1 or 2 days from home per week. Definitely get more done when home, but there is an intrinsic value in being around people. Source: Have worked from home for the past 4 years.
However, some people go to the extend to not to trust on other systems, for example, an integration service between servers. 
Well, FB and Slack are really poor in terms of code quality btw.
I prefer: $this-&gt;isAwesome(); //returns true
I’ve been doing this home full time for four years and I love my boss and my coworkers (at previous home based jobs) because they are NEVER around and never bugging me. 
The docs say "The *phar* stream wrapper does not operate on remote files", so the file would have to be present on the server for this attack to work.
That makes it less risky, thank you for clarification. Application with unsanitized input combined with possibility of uploading is vulnerable then.
Definitely use a query builder. I like `Illuminate/database`, usually part of Laravel but easy to use outside of it. One thing I found necessary was a helper function to dump the raw SQL with variables interpolated where placeholders would be, so I can copy/paste the resulting query into my database client during dump&amp;die debugging. Since prepared statements aren't always compiled to SQL before being sent to the db server (if it supports prepared statements then the SQL and params are sent separately), I had to parse the output of [PDOStatement::debugDumpParams](http://php.net/manual/en/pdostatement.debugdumpparams.php) to compile the SQL string with interpolated params, but it's been very helpful for debugging to be able to copy/paste right into [dbeaver](https://dbeaver.io/) to inspect the results.
Maybe I'm being dense, but I don't see why you need to involve the web server in this? The PHP router of choice should allow you to declare your arbitrary routes.
Well, as the data shows these tweaks don't really do anything.
Thanks. Useful to know for the future.
Thank you!
Update: https://symfony.com/doc/current/routing/service_container_parameters.html which seemingly allows defining substitutions for the URL itself, and symfony 4.1 can define defaults and requirements within the URL itself.
Depending on the level of traffic that 2 to 5 % might be welcomed.
how do I run tests? how do I install with composer?
These tests also don't say how it's being tested. Depending on the main server running these tests the results may vary; i.e. apache vs nginx vs php built-in server. So that's a factor to be aware of. Also testing WordPress is kinda not super great. It's not very 'deep' in its execution path for most front end areas. A good chunk of rendering most front end WP pages are the DB calls, not necessarily PHP execution.
Try [Symfony](https://symfony.com/) with [API-Platform](https://api-platform.com/) to implement a GraphQL or REST API. Node.js is a bit slower than PHP for sequential tasks. (Look up some benchmarks in this subreddit). The trick is to leverage multi-threading for background tasks like your PDF generation: No need to have a web server or even PHP running for that. You can separate little services out of your monolith and write them in Go. I can also recommend using PDFLaTeX for PDF generation if you know some TeX. No need to have PDF do that. Also, consider using "serverless" workers for this kind of CPU-intensive tasks. Active Record is ok for toy projects, but not for a project with 250 tables. Performance will be horrible. Get a copy of Fowler's "Patterns of Enterprise Application Architecture" for alternatives. You'll get much better performance when you know your database (can't recommend [https://masteringpostgresql.com/](this book) enough) and know how to use a low-level DB schema generator / wrapper like http://www.pomm-project.org/ (use [https://github.com/pomm-project/pomm-api-platform](this) to wire it to API-Platform), independent of your backend stack. Get rid of Apache, its performance can't compete with nginx and others unfortunately.
Thanks for your time and the information. Yii's implementation of AR isn't the normal one. It's far more perfomant that the default thanks to the lazy load feature. Our PDF generation is currently done through a third party, but we had wanted to bring it in house due to some recent outages with HTML2PDFAPI. Pomm is for postgresql right? We use MSSQL. Yeah, ditching Apache is high on my list of things to do. I've been looking at Caddy and Nginx. I feel a bit overwhelmed by it, to be honest. I've been using Apache for 20 odd years, and feel a that learning anew the lower levels of my stack would be difficult. I need to sack up and do it though... I'll put it on the Kanban I use as a to-do list. Thanks again, you've given me plenty of things to seek out and learn more about.
I don't think we have much need for shooping here.
We just use yaml configs. Less copy&amp;paste this way
&gt; Yii's implementation of AR isn't the normal one. It's far more perfomant that the default thanks to the lazy load feature. It doesn't matter, AR is a bad design pattern. The only reason you won't notice that is if your project is trivial or you aren't familiar with the mapper pattern. I'd say POMM would be risky, not v popular and seems to be tied to Postgres too. Why would you not consider Doctrine? &gt;I've been using Apache for 20 odd years, and feel a that learning anew the lower levels of my stack would be difficult. There is nothing wrong with Apache performance for PHP, you won't get nginx to run any faster. That said I'd still recommend nginx, it's a bit more versatile, and it just feels nice. There's no reason to consider a micro framework in PHP, specially with Symfony 4. Node doesn't have any significant performance benefits, and it doesn't let you leverage your front end developers because they still have to know how to backend properly. On the plus side you can be entertained for days at a time deciding which programming language you want to actually program javascript in.
Hahaha TypeScript, CoffeScript and JavaScript wars ensue... Pass! Thanks for your time and effort. You've opened my eyes to a lot of stuff to look at.
Not spam.
This is not the place for you to advertise your services.
 \assert($this-&gt;isAwesome);
Hate to be the bearer of bad news, but there's quite a bit of room for improvement here. First things that come to mind: \`\`\` global $template, $config; \`\`\` There really, really is no place for \`global\` in PHP in 2018. You should "inject" things you need through Dependency Injection. \`\`\` $status = $\_POST\['status'\] ?? $config\['leads\_default\_status'\]; \`\`\` You're using the \`S\_POST\` superglobal as-is. This is a security breach waiting to happen. You should use a component like Symfony's \`Request\` to handle these things. If I can give you one pointer: Read up on using Composer and using well-built existing libraries. A link you'll often see is PHP the right way: [https://www.phptherightway.com/](https://www.phptherightway.com/) A tutorial i can heartily recommend is Patrick Louys': [https://github.com/PatrickLouys/no-framework-tutorial](https://github.com/PatrickLouys/no-framework-tutorial) It really explains some of the concepts i've touched on above. 
I do not agree with the get parameters, and this is not critique, but is there an architectural reason against making the id's universally unique and querying against the topic endpoint? You can replace your long url with /topic/{id}/discussions if the id is unique.
Many of them are, however most of the underlying code is based on a downwards locator hierarchy that enforces various constraints, and everything tends to operate in the context of a parent. For example, a client may be a top-level instance which can then be interrogated to fetch a project, that project can then be interrogated to ask for a discussion. While it is possible (and sometimes necessary) to do it in reverse, doing so usually requires pulling the bottom level element (discussion) out of the DB, and then chaining up the hierarchy until finding the top level (client) and then doing the whole thing down again. Ultimately, I find it better to ask the parent to create the child, rather than the other way around. 
FYI since PHP 7.2 opcache.fast_shutdown is meaningless, since fast_shutdown is now part of the engine and always enabled (if possible). With that in mind, it would be good to write down which PHP version these benchmarks were performed with.
Well the question was could you, not should you. I agree blue/green is the safer option. 
Probably because the documentation on how to configure it is a bit meh. For example, if there's a fast\_shutdown option, why wouldn't you always want to do that? What's the possible consequence of doing this. It could use a bit more depth.
Thanks! :D
That looks absolutely horrible. It follows no common standards in any way, the installation routine is very outdated (no composer), the directory structure is all over the place, it would be a mess to update and extend, there are no tests, everything seems to be in the global namespace, database migrations are non-existent. During the administration panel demo alone I triggered several errors that got handled really weirdly. What is this even supposed to be? Please, first learn PHP and HTTP, understand modern OOP architectures, understand testing, understand composer and then, only then, attempt to write an own framework. This looks like it was made by the WordPress dev team. 
My understanding is the following: In a typical database structure where you can't access data you shouldn't access, based on your example, a Client has many Projects, a Project has many Topics. So basically, Topics has a "projectId" and Project has a "clientId" If you get the Topic ID, why do you also need the Project ID and the Client ID? You can get the Project from the Topic and the Client from the Project. Why make URLs longer and more complex than they need to? Your URL could just as well be just `/topic/{topic_id}` and it would contain the same amount of information. /** * @Route("/topic") */ class CustomerTopicController { /* * @Route("/{id}", requirements={"id": "\d+"}) */ public function details(Topic $topic) { $project = $topic-&gt;getProject(); //??? $client = $project-&gt;getClient(); //??? return $this-&gt;render('customer/topic/details.html.twig', ['topic' =&gt; $topic]); } } Apart from that, you can add route prefixes on controllers in Symfony /** * @Route("/client/{clientId}", requirements={"clientId": "\d+"}) */ class CustomerTopicController { /* * @Route("/topic/{id}", requirements={"id": "\d+"}) */ public function topicDetails($clientId, $id) { } } I guess it comes down to a problem in the overall structure of your application, that's why usually, it's not needed and that's why there's no existing solution for it.
You might get better feedback on the \[Symfony chat site\]([http://symfony.com/community](http://symfony.com/community)). I use similar urls but I don't worry about defining constraints. All of these sorts of urls are generated and thus will have the correct type. If someone messes with them and tries to use different types or whatever then the page fails which is okay with me.
[removed]
Check comment 
You're missing the most important part of your post
\- I don't get your code. \+ You have to open your mind.
[SuperSQL](https://github.com/ThreeLetters/SuperSQL) A light, efficient and powerful php sql database framework. Allows you to quickly and securely develop anything using SQL databases. 1. Very small - 27.4KB one file (Unminified, dist/SuperSQL.php. Minified version: 12.4KB) 2. Simple and easy - Very easy to learn. SuperSQL was designed to be easy and simple, to the point that a noob can use it. 3. Compatability - Supports all major SQL databases 4. Efficiency - This module was built with speed and efficiency in mind. 5. Complexity - This module allows you to make all kinds of complex queries. 6. Security - This module prevents SQL injections, so hackers bye bye! 7. Availability &amp; Integration - This module is FREE. Licensed under the MIT license. Also available on composer 
Think of it like you might dependency injection, each level down can consume dependencies from the element above. Depending on the configuration of a client, it may inject different dependencies into a project, which may then inject different dependencies into a topic. It's probably also worth mentioning the main driver for this project has at least 4 or 5 hundred controllers, many with similar names, so keeping the URLs to them short is less important than keeping them structured. 
&gt;https://anotepad.com/notes/rsq4xr Please, check here :) 
[removed]
[removed]
Where did the link for this go?
I use to see them all the time back when my company used symfony, a few years ago, but now with laravel and the popularity there of, are we starting to move away from annotations, accept for those still using doctrine? Were they ever a good thing? to me they made the code messier, comment sections, like doc blocks were meant to describe functionality to the user, which I guess annotations did, but why were they so popular? and are they still?
Unfortunately, yes.
I mean yeah, not surprising. Even just taking a 15 minute break from a problem and going on a walk can do wonders.
Never liked them, never used em.
I use them in Doctrine ORM entities, and as route annotations in single-action controllers. I understand the arguments against them both as a concept and in PHP’s implementation, however their convenience and fit in my development style take precedence. I also make sure there is little to no performance overhead by parsing/caching/etc. in production.
Doctrine Annotations are terrible not only because they are in comments, but also that they are persistent logic put into domain/business model. The model is not supposed to care that their data fields are columns in database, its not business logic at all. For me, this is an even bigger concern, even if PHP will support annotations natively one day this can still be a lingering issue in many PHP applications. 
Knpuniversity has an authentication course on symfony 3. Supposedly they will be updating it to symfony 4 at some point. I don’t really like how they put up a ton of courses and just saying “in the planning stages” etc. It feels like a cheap way to time-gate the content keeping the sub money rolling in.
 Thanks for taking the time to take a look. If you don't mind my rebuttal, let's go point by point here: Dependency injection -- Agreed, it would help make things a little more structured and centralized, as I could just create a session / registry class and object that contains everything (config variables, template object, user / auth info, language, timezone, etc.), and it would help a bit. However, the cost to o that is a slightly increased learning curve, plus more importantly, while developing you basically end up writing more code for the same result. Am I missing something, other than simply "it's how things are done in 2018"? Maybe I'm missing something, but I don't see the practical benefit especially considering it'd basically require me to restructure things so functional code for the pages / templates is moved to a controller class, then you have to define routes to tie views / templates to the code, etc. As for using the $_POST, all variables are properly sanitized (or will be, I guess haven't added that in yet), plus natrually the database layer protects against SQL injection. Once done, this will be going through a vulnerability scan be a reputable firm, and I'm sure it will pass as I've been through multiple vulnerability scans / pen tests before. Assuming it passes, any other issues I'm missing? I don't see an issue with just doing a blanket sanitization of all POST / GET / REQUEST variables, but maybe I'm missing something. I like Composer and no issues with it, but it's not really suited for this. For example, say you start a new project and grab 8 packages / libraries off Composer to start with. Now you have basically 8 seperate and stand-alone libraries / systems that you need to tie together. Granted, some libraries work together better than others, but it's still a bit of a mix-and-match scenario, and I don't want to be in a position where I'm trying to fit a sqaure peg in a round hole, type of thing. I want things standardized, streamlined, everything in its proper place, and it just works without having to fumble around trying to tie two different things together. Again, am I missing something? Database migrations -- I know there will be blowback on that, but I'm a staunch believer that SQL database schemas should be written in SQL. I don't believe writing database schemas via a PHP OOP library is a good idea, because it's not. It makes it way too easy for people to write sloppy and inefficient database schemas. 
But still not using PHP_EOL :trollface:
I think the big thing this one's missing, is that progress happens incrementally. Laravel was well written and met a demand, certainly, but it was also a natural, understandable next step for a lot of devs. While it often gets compared to Rails, on account of a similar purpose, I think its adoption is closer to what we saw with angular. Angular is little over a year older than React, and follows on a lot of popular client frameworks (ember, backbone, etc.). A big part of why React took so much longer to really gain traction, was that virtual doms, pure componentization instead of "pages", and a full re-render on updates was a big departure from people's current habits. Angular, on the other hand, was still building the Dom from html, still late-binding events to it like jQuery, came with its own system for managing dependencies (so you didn't need to also learn grunt, gulp, webpack, etc to use it effectively). I think we see similar things with angular. Having another hard dependency on a very large framework, even a good, well documented, well written one, is not great. But it's a much easier step for PHP devs to take. Easier than learning how to use standard interfaces (eg from the PSR), manage your deps via composer, etc. Now that everyone's gotten used to laravel, this becomes a more accessible concept for people. Thankfully its authors seem well aware of this, and have pushed DI and standard interfaces into the product. 
Its looks to complicated, i want something simple like the laravel auth. Its so simple. 
OP, have you read [this](http://symfony.com/doc/current/create_framework/index.html)? Check it out, it was really helpful for me back when I was learning
Are those socrata 4x4s?
good point. Maybe more rest is required.
How are the GET/POST super globals related to security?
Whenever somebody / something is self proclaimed "secure" all alarm bells instantly go off here. By glancing through the project I found several pieces of code where queries are not prepared and/or manually "prepared". I also suspect there are several xss issues in there.And there are some xss issues of which I am 99% sure they are there. That was just a 5 minute glance which kinda scares me. Are the issues I just raised actually valid? If not can you counter it?
When working with JSON, one needs lots of REST. #CoderDadJokes
Happens to the best of us. Especially when you have a few languages and frameworks in your tool belt, forgetting helper functions like implode and just dumbly writing one on your own seems faster than googling for one. Get some sleep.
Hmm, we recently switched from anarchy to sprints. But I'd love to hear a synopsis of kanban if you don't mind.
4 weeks. Congrats n keep going
Doctrine entities are data transfer objects. They are not domain/business models. Easy to confuse because of the name.
The big change for us was limiting work in progress. No more constant sprint after sprint, which change halfway through and we inevitably end up dumping or deferring a bunch of cards. Your to-do list can keep growing, but you pick points where work in progress is limited. We limit all devs to having only 2 (or if you can explain why, 3) cards in "doing" at any time. If your priorities are replaced, you merge in what you can on a branched off card, and move the remaining work back to Todo. Keeps the actual cost of scope creep and quick priority changes at the front of your mind. It's a very natural way to have the whole "I can do this, but then I won't be working on this" conversation that teams _should_ be having, instead of using numeric abstractions that frequently devolve into issues being labelled "priority 1 severity 1 urgent top issue deadline yesterday" so that it can go in ahead of the five "priority 1 severity 1 urgent issue deadline yesterday" issues you have already. The focus is meant to be on the work your delivering, not on the individual devs coding the work. No reassigning queues because one dev is taking "too long" on something. 
Bit off topic here, but I discovered the other day that if you copy a SQL statement into dbeaver which contains parameters, and then execute that query, it will ask you what values to use for each parameter. Really makes debugging queries much less painful - you can fix the query in dbeaver and just copy and paste it back into your code without worrying about swapping the parameters back.
Adderall makes me stair at code for entirely too long trying to perfect it when many times the answer is 10x easier than I had thought. lol. mainly when on lack of sleep (see: adderall)
&gt; your 
Wow i did not know that, thanks!
And it probably took you two to three hours to write while feeling like 15 minutes. 
100%. And the above section was the least shameful of many from that session. There was some truly horrific code in there. Humans need sleep!
One reason why I have a rule that I don't code after 11pm. I used to code until I'd fix issues, which would sometimes lead to coding till sunup. But would always regret it when you get up the next morning and wondering why your unit tests are busted, or your code is acting really really weird. Sleep deprivation is deadly for anything you need your full brain for like coding.
Both of you smokey bastards can do it I believe in you! 
Relax, friend. Typed it out on my phone.
Yeah our commit count is very high. Each dev creating 3-4 PRs a day is pretty normal. The biggest thing that went down were merge conflicts, and it's been amazing for morale. Devs don't resent one another for making it harder to check their 500-line commit in behind someone else's 500 line commit. We have the opposite now: the low in-progress work leads to fewer long-lived branches and makes frequent small commits easier, so PRs are an opportunity to see how your co-workers' code could actually help you.
Your first code will perform better with large amounts of codes, so... Honestly this is not the kind of "bad" code I worry about these days. This is implementation. Making it a bit more verbose can be unfortunate, or most often it simply doesn't matter. The primary opportunity where you can fuck up or shine is the APIs and (depending on the app) UI, i.e. the key interfaces within and outside your app, that determine how this app behaves and how it's used.
Good answer but I take exception with this bit: &gt; Similarly, doctrine's annotations are terrible since you now have domain/business models aware of persistence layer/logic. Domain logic shouldn't be in ORM entities. Doctrine is basically a port of Hibernate, including annotations. One can argue that ORM is an anti-pattern but I've never heard an argument that annotations are the problem. &gt; A good use case for annotations is data validation, which do not suffer from the SRP violation problem. I'd include serialization for DTO's. 
I just wish you weren't THIS gay ya know
Zend expressive user auth and Zend expressive user auth session... Very easy.
Sorry, was only giving something to compare against, no harm intended
A good number of components for your Symfony application will require a bit more thought and effort to set up than the solutions provided by Laravel. Symfony caters more towards freedom of choice in that respect, which sometimes requires developers to be more knowledgeable on certain subjects. I hope you can see this as a wonderful learning opportunity. There are a million and one ways to do Symfony authentication and it's up to you to decide what works best for your application. I hope you'll understand that Symfony doesn't try to solve every problem out of the gate, but still has a wide variety of options to go about solving them with you.
&gt;A good use case for annotations is data validation, which do not suffer from the SRP violation problem. It sounds like folk thuth to me. Do you have or can produce code example where moving validation into annotations removes SRP violation?
on the first sight, yes, symfony security component is complicated, me too, have the same experience on the first time I tried to implement it outside the symfony framework. but, once you get the big picture, it is the most flexible security component. maybe this gist will help you understand the concept of security component [https://gist.github.com/jaytaph/cb7fb4392e5d6aa07d8f](https://gist.github.com/jaytaph/cb7fb4392e5d6aa07d8f)
&gt; "it's how things are done in 2018"? Maybe I'm missing something I think the point others are trying to make and which is my feedback too: it seems you're simply ignoring the evolution of best practices when led the PHP ecosystem to where it is now (which the majority is glad and happy to have and don't want to miss). And yes, it happens to be 2018 for that matter ;-) I would go so far to be bold and say: unless you've a composer package no one will try your software, it's too much hassle and it's already a signal it's missing one of the key points. I also don't see any kind of tests at all. No PSR-compatible autoloader. Greeted with spaghetti code when opening a file. The list goes on and goes and are red flags for many. I'd also say: it's a base line for the majority of people to have when even looking at projects. Because all these things are sending a certain signal and I would say your projects doens't send any of them. Please understand that no one wants offensively diss your projects. This is supposed to be constructive criticism to make you and your future projects better and thrive in the PHP ecosystem.
It may look complicated because it's a complete walkthrough of the Security Component which is quite more advanced than the Laravel Security one so yes there is more... You should otherwise already have pretty much everything you need except for the User model itself. There is a long standing debate regarding this subject but TL:DR; you can either roll with your own, use https://github.com/FriendsOfSymfony/FOSUserBundle or https://github.com/msgphp/user-bundle.
Find something you want to build, like a twitter clone, a forum system, a blog... then look for tutorials on building it. Follow them, then make changes where you want to change things. Look up best practices and change things to follow those as well. In my opinion the best way to learn is by creating something you want to be proud of and improving it.
I’m at my 5th project where i need to create a blog with comments validation, i’m trying to adapt the code from the lessons with Psr7 and Twig but it doesn’t seem to work out.
Maybe you should just start a project or join a beginner friendly project and code. I don't think there's a better way of learning and memorizing things. 
My HTTPResponse / HTTPRequest and my Page.php are used in a way that i have some trouble to adapt it with psr7/twig Here my project i’m working on : https://github.com/SilencyDev/Openclassrooms
Well I don't know exactly what the project is, but from what I can see I think you would benefit from reading the PSR-7 specification: https://www.php-fig.org/psr/psr-7/. There's some very important basic things I think you've missed! It sounds like maybe the lessons you're following aren't the best fit for what you want to do. If you check out /r/PHPhelp there are some learning resources in the sidebar that might interest you more.
They allow a malversant to pass any data into your application. You're right that it's not the purpose of the request library to sanitize it, but using a library like that _will_ help in ensuring that the data comes from the correct source. Of course, all of this _can_ be done by hand in your own code, but IMHO it's easier to follow 'best prectices' as defined by a library. 
Btw i just found this https://github.com/CedricF67/Simple-PHP-Blog it's another student that did the project i'm working on It doesn't include the library, why ?
Laracast and search for php bootcamp
I would recommend finding a Laravel tutorial, something that will get you from start to finish. Laravel has fairly clean coding standards and good structure, makes it easier to learn. Plus you can go from some absolute basics, which it seems you've got in your GitHub repo, to advanced setups. If you're brand new to coding PHP, try W3Schools, has the basics. Other best thing to do is find a mentor. Find someone who can walk with you and point you in the direction you need to go!
😎 just my day! 🤟
I understand those recommending frameworks like Laravel, but I think creating your first couple of projects from the ground up with no framework is a much more "healthy" way to learn a new language. You fundamentally need to be able to understand what/why these frameworks exist, and how they are saving you time before using them. As somebody else said, think of an idea (such as a Twitter clone) and try to recreate it. You'll run into many conundrums that you'll need to scour StackOverflow to understand and overcome, but I guarantee you'll get a great sense of achievement doing it with no framework and you'll learn *a lot*.
Check out Laracast and DevMarketeer yt chanel. Start building something. I first learned how to do crud, then schedule tasks, send email, notifications etc one by one
Try to break it up and narrow it down to specific problems/questios. /r/learnprogramming and /r/phphelp are both subs dedicated to helping people with specific problems and much less daunting/more welcoming than StackOverflow. For example try to ask questions like: * _How do I get PHP running on my Windows PC?_ * The answer would be to use XAMPP. And if you have no editor/IDE, try VS Code or Atom or if you're student you can get PhpStorm for free. You'll probably also want to install [Git](https://git-scm.com/download/win) and [Composer](https://getcomposer.org/download/) very, very soon after your first _Hello World_ program. * _How do I use this or that library?_ * Hopefully said library is made to be distributed via Composer. Composer is a dependency manager that may also provide an autoloader for all your dependencies and your own code (PSR-4). * _What is an autoloader?_ And so on... you get the idea. Progress is achieved by 1000 tiny steps.
I've had a quick look through it and here's my feedback: * The first thing that jumps out at me is the fact that the front controller (`index.php`) is in the application root. This is a bad idea because it's a security risk - if the server were misconfigured it could easily expose other PHP files, including configuration files. Most modern frameworks keep the front controller in a specified web root directory instead - if you move it to something like `public/index.php` you can prevent that happening and only expose that one file. It does mean you have to reconfigure the web server to serve from `public`, but you can provide an `.htaccess` for that with Apache, and it's not hard to configure for Nginx. * The configuration is stored in a file that's under version control, which is a recipe for problems. This is why DotEnv exists - use it * The use of the `data` directory for application code is confusing - it should be named something else that makes more sense, such as `src` or `app`. * The coding style is just awful. PSR-2 exists for a reason and is pretty much standard, and PHP CodeSniffer can sort out a lot of issues for you, so there's no excuse not to use it * You're using underscores in class names as a fake namespacing measure. PHP has had proper namespaces for a long time, and that was only ever done in old code bases because namespacing didn't exist in PHP at the time. Now we have proper namespaces, you should use them - your admin controller should be importable as something like `Apex\Controller\Core\HttpRequests\Admin`. * You're using globals. You can find any number of articles explaining why they are bad. * You aren't using Composer. Not only does this mean you're having to maintain your own autoloader, but you're actively making it harder for users to use third-party packages when building an application with your framework. With something like Laravel I can pull in any package I want and use it. I might need to write a service provider if that package requires a fair amount of setup, but that process is fairly straightforward. * Requests aren't encapsulated inside some sort of request object. This makes the whole application very difficult to test. If you replace them with a Request object of some kind, that will make it possible to test components by creating a request object manually and passing it through to them. Ideally that request object should also implement the PSR7 request interface. If you don't want to use an off-the-shelf request object, like the Symfony requests or Zend Diactoros, there's nothing stopping you writing your own class. It should have a shortcut method such as `Request::createFromGlobals()` that creates and populates a Request object from the defined globals, and should then pass it through to the rest of your application. * No tests. This is a killer for me. I would not trust any non-trivial package that lacks tests entirely. In addition, I'd reiterate the other points people have made about using Composer, dependency injection and so on. I'd also add that PSR standards exist for a reason - so if a particular component doesn't meet your requirements, you can swap it out and replace it. I don't want to discourage you, but this framework feels like a dated, amateurish sub-CodeIgniter mess. It needs a lot of work to be converted into a modern PHP framework. Other people have provided links to Patrick Louys's tutorial and the Symfony one for creating a framework and I would concur with that - both are excellent resources that will help a great deal, as is PHP the Right Way.
A quick Google would solve your problem https://loading.io/ Grab one and start the spinner when you fire the request and when you get a response back you hide it
start with simplest frameworks for example codeigniter (although that is kind of dated). you can slowly move to more modern and complex ones for example laravel. refer to official docs of the frameworks. and for core PHP, always look at php.net :) 
1. Create a static html page with very few resources which displays the loading icon. In that page make your Ajax request to your php page. When that completes redirect to the finished page 
I self-taught myself back in 2004 using SAMS Teach Yourself PHP in 24 Hours - its basically PHP broken in 24 one hour chunks. There may be a more recent edition or something similar, but would definitely recommend a book over anything online for this kind of “new language learning”
How is this related to PHP? It's a client-side thing.
thanks
If you live in Europe, make sure you post this on /r/europe as well.
The great thing about the internet is that there are so many possibilities. You could look on services like Fiverr to see what other people are doing to make some cash or just look around for inspiration, just some ideas off the top of my head: - Video game steaming - Make YouTube videos/tutorials - Proofreading or copywriting - Image editing/Photoshop - Programming (there's so much more than PHP)
What? How? And how on earth would a wrapper around the super globals have any different outcome?
&gt; As you will see, there is placeholders within the SQL statements (eg. %s, %i, %d, %ls, etc.), and the variables passed are all properly sanitized and checked for proper data type. I may have missed something though. Yes. What you missed is using prepared statements and instead manually try to do it yourself instead of doing the right thing and let the database handle it for you without the bugs you introduced and will introduce in the future. &gt; Then you're right, I haven't added in CRLF protection yet, but will do so shortly, and that should help prevent any potential XSS attacks. Wat? How is CRLF injection related in any way to XSS? Also now I will be looking whether there will be a mail functionality somewhere in your project, because I *know* that will be utterly vulnerable too. Also what you are saying basically means your project description is bullshit (at least on the topic of security). &gt; Of course, this will go through a professional security audit later, but we're not at that point yet. I've been through several security audits before though, so not overly worried about any vulnerabilities. Well I am worried and for good reason. All of the above shows an afterthought of security practices at best and more likely and utter lack of security practices in general at worst. &gt; But yes, those SQL statements you see are prepared. And yes, I use actual SQL queries, as I don't like those ORMs. No they are not. You have no idea what prepared statements are and how they should be used. It's about creating the (prepared) query separately to the database engine and sending the parameters in a second call to the database engine so you can never have sql injection because the database engine makes this impossible. &gt; as I don't like those ORMs. Same as database schemas, I believe SQL queries should be written in SQL, not some hodgepodge PHP OOP mess. I never used to words ORM, nor OOP. All my post is about perceived (at the time) security issues. Now that I have seen your reply and read more of the code I guessed would be bad from a security point I *know*what I feared is all true. &gt; Then PDO isn't much better I don't think, as you'd have: &gt; $group_id = 4; $stmt = $pdo-&gt;prepare("SELECT id,full_name,email FROM users WHERE group_id = :group_id ORDER BY full_name LIMIT 25,50"); $stnt-&gt;execute('group_id' =&gt; $group_id); $rows = $stmt-&gt;fetchall(); You have no idea how any of that works, what it does to prevent sql injection or why everybody in the security world and by now luckily most of the broader PHP community tells you to use prepared statements instead of dicking around like you do. And fyi this is in no way related to pdo nor mysqli.They are just apis to work with database engine and both support prepared statement with bound parameters just fine. So your point makes no sense whatsoever. &gt; Does the exact same job, and just as securely. Or if you have any examples of SQL injection vulnerabilities, please let me know, and I'll take a look. I know the $order_by variable within the get_rows() function of data tables needs to be sanitized properly still, but that's easy, and I'll ensure it's done later. That's already one and I am sure there are lots of other places. &gt; Password hashes just use Bcrypt via the password_hash() and password_verify() functions, as that seems like the current standard. Prior to this, I always used multiple iterations of SHA512 hashes with dynamic salts, but I guess that method is now obsolete garbage. Yes it's unsuited for password hashing. &gt; The two-way encryption isn't done yet, and obviously, ignore that /data/libstd/encrypt.php library as that's horrible. Still have to research more, but will probably settle on ECDH or EDDSA, and have some ideas in mind how to keep those encryption passwords and initialization vectors offline while still providing the necessary users / processes access to the needed encrypted data. There are libraries out there that do a better job than you will ever be able to do. So can we conclude based on above that the entire security bullet point in the project description is complete and utter bullshit after all of the above at least? Thank you
While looking for security holes and only trying to make OP aware of these this above is basically all the generic stuff I fully agree with.
Just so you know most efficient scrum/agile teams run their sprints as essentially immutable within the sprint and essentially a Kanban style internal to the sprint.
You should really use some sort of job queue.
If you breath oxygen, you could try your luck on [/r/oxygen/](https://www.reddit.com/r/oxygen/) , also.
I don't often use reddit but here's a template library I first release a few years ago. To quote Zack Wallace of sitepoint.com &gt;If there is one thing the world needs, it’s definitely another PHP template engine! But wait, this one is different! Zack did a very good job of covering the basics over at sitepoint.come when it was first released: [https://www.sitepoint.com/transphporm-a-different-kind-of-template-engine/](https://www.sitepoint.com/transphporm-a-different-kind-of-template-engine/) And here's a quote from someone who's been using it on commercial websites for the last few years: &gt;Transphporm has really made our web development so much easier to build and maintain. [https://github.com/Level-2/Transphporm/issues/192#issuecomment-386636435](source) The main selling point is that **you don't ever write any markup in your template. The template is pure HTML or XML**. The template is manipulated externally using a CSS like language call TSS (Transformation Style Sheets). As I know people won't follow links unless they're already interested, here's a very quick example: ```php $html = '&lt;h1&gt;Site heading&lt;/h1&gt;'; $tss = ' /* Find any H1 elements and update the contents */ h1 { content: "Hello World"; }'; $template = new \Transphporm\Builer($html, $tss); echo $template-&gt;output()-&gt;body; ``` Which will output: ```html &lt;h1&gt;Hello World&lt;/h1&gt; ``` Template XML/html and TSS can, and should, be provided as files rather than strings but demonstration here is easier using strings. You can also provide external data and look it up in the TSS using the `data()` function. You can think of `data()` in TSS like `url()` in CSS insofar as it references an external resource. ```php $html = '&lt;h1&gt;Site heading&lt;/h1&gt;'; $data = 'Welcome to my website'; $tss = ' /* Find any H1 elements and update the contents */ h1 { content: data(); }'; $template = new \Transphporm\Builer($html, $tss); //provide $data as an argument to output, making it available to the data() TSS function echo $template-&gt;output($data)-&gt;body; ``` Which will output: ``` &lt;h1&gt;Welcome to my website&lt;/h1&gt; ``` `$data` can be a simple object or an array: ```php $html = '&lt;h1&gt;Site heading&lt;/h1&gt; &lt;main&gt; Page content &lt;/main&gt; '; $data = ['title' =&gt; 'Welcome to my website', 'body' =&gt; 'I am a php developer' ]; $tss = ' /* Find any H1 elements and update the contents */ h1 { content: data(title); } main { content: data(body); } '; $template = new \Transphporm\Builer($html, $tss); //provide $data as an argument to output, making it available to the data() TSS function echo $template-&gt;output($data)-&gt;body; ``` Which will output: ```php &lt;h1&gt;Welcome to my website&lt;/h1&gt; &lt;main&gt; I am a php developer &lt;/main&gt; ``` It also supports loops: ```php $bandMembers = [ 'John', 'Paul', 'George', 'Ringo' ]; $html = '&lt;ul&gt; &lt;li&gt;List of band members...&lt;/li&gt; &lt;/ul&gt;'; $tss = ' li { /* Repeat this element for each of the items in data() */ repeat: data(); /* set the content of the repeated element to the current iteration's value */ content: iteration(); } '; $template = new \Transphporm\Builer($html, $tss); echo $template-&gt;output($bandMembers)-&gt;body; ``` I won't give any more examples here, you can find a good explanation of the basics here: https://www.sitepoint.com/transphporm-a-different-kind-of-template-engine/ and comprehensive documentation on the github page: https://github.com/Level-2/Transphporm This approach offers several advantages over conventional approaches: 1. The markup is totally separated, designers can work on pure HTML, include lorem ipsum text and other placeholders which will be replaced via TSS 2. You don't need the foresight to put a {{placeholder}} where you expect to need to write content, you can target any element using a CSS selector and write content to it, repeat it or even remove the element from the page 3. You can use the same TSS on multiple templates. Conventional template engines are equivalent to inline styles as the logic is contained in the template markup. With TSS you can apply the same logic to different templates 4. You can use different logic on the same template. Much like how you can use external CSS to style the same page in a completely different way, you can use TSS to replace all the logic in a page 5. Anything can be a partial. You can extract any element from any template and embed it in another tempalte. See: https://github.com/Level-2/Transphporm/wiki/Template-Partials Recently we also have a very unique caching approach where you can specify how frequently different parts of the page are refreshed. The page title/content can be updated daily, whereas the users shopping cart can be updated every page view. See https://r.je/transphporm-caching-guide.html 
I hope we've moved passed them: Complete list of advantages of annotations: - You can edit application configuration and application logic in the same file Incomplete list of reasons not to use them: - They are difficult to debug - They break encapsulation (You assume your code is running in an environment that is looking for that particular annotation. The class you are writing should not be concerned with the environment in which is running) - They make version control more difficult. Changing configuration requires a commit and probably a new branch - Breaks single responsibility principle, the class is in control of whatever it's supposed to be doing and how it's configured - Introduces coupling between the class with the annotations and the part of the application that reads it. `@Inject("security.context", required = false)` works on Symfony but won't work if you switch your DIC to PHP-DI. - They make it more difficult to instantiate an object with different configurations Is being able to edit the configuration and the logic in the same file really worth it? Here's my complete rant: https://r.je/php-annotations-are-an-abomination.html and here's one by a Java developer about a lanague where annotations are properly supported: https://www.yegor256.com/2016/04/12/java-annotations-are-evil.html As Java code increasingly looks like this http://annotatiomania.com/ I'm glad they haven't really taken off in PHP.
Nah, you probably missed [https://laracasts.com/series/php-bits/episodes/1](this) video creating a shitstorm by suggesting to eliminate return types and callbacks. See [https://www.reddit.com/r/PHP/comments/6e65sm/what_is_your_opinion_on_the_visual_debt_video_of/](this) thread and [https://ocramius.github.io/blog/eliminating-visual-debt/](this) brilliant reply from Ocramius.
Ah I see, I misuderstood. Makes sense now.
lol I got downvoted by doctrine fanboys, apparently they have consistently failed to understand that downvote button means 'this isn not related or contributes to discussion', not simply 'I disagree with you'. This is why its impossible to have a civil conversation with these fanboys. 
I have ton concur here. Its very unlikely I will use your library/framework if its not a composer package. If we're just talking a library and its good, but not in composer. I would simply fork you and put it in packagist myself. A framework without composer is a complete no-go.
Doctrines annotations are simply a method of configuration. If it seems to be an anti pattern then Just put it in a configuration file and never talk about it again.
Too bad :(
opcache.file\_update\_protection=0 (default “2”) Prevents caching files that are less than this number of seconds old. It protects from caching of incompletely updated files. In case all file updates on your site are atomic, you may increase performance setting it to “0”. opcache.fast\_shutdown=1 Fast shutdown attempts to use a faster mechanism for clearing memory. If enabled, a fast shutdown sequence is used that doesn’t free each allocated block, but instead relies on the Zend Engine memory manager to deallocate the entire set of request variables in mass. Use this with PHP7+, may experience segfaults with older versions of PHP. Here’s a copy of the config (opcache.ini) that was used…
Great idea and nice execution. I always wanted to play with the Model-View-Presenter pattern. For those cases I would usually create a Twig extension and inject dependencies there, but I will definitively examine the library in more details. Thank you for sharing.
Which category is more important? The first one, the last one, a random one?
I'm using the url as sorting criteria. When I find two identical urls I know I have more than one category.
FWIW annotations are recommended by Doctrine for entity configuration (XML for shareable bundles). 
&gt; Annotations are good but I would go nuts with it. I'll elaborate a little bit with *an* example. Like with Symfony, if you're doing a REST API app, you potentially could have annotations for Routing, Security, View (you can return an array in the method but the annotation will return that value as a FOS View), Serializer, and API Documentation.
 Ok, went through that tutorial, and thanks for linking to it. I need Apex for myself anyway, but I'd really like to make it work best I can, so let's go through that list. - Adding a /public/ sub-directory. Understand why, but won't implement it. Instead, just add "location /data/ { return 404; }" to Nginx, and done, as everything outside /data/ needs to be accessible to the public. That's probably easier than getting people to change the document root of their server every install. - Composer. Got it loud and clear. Will add in support for Composer later today or tomorrow. - Error handler. I like mine, and am keeping it. There's constants within the /data/config.php letting you set the level of both, error reporting and logging depending on if it's devel / production system. Plus things like it checks and if within an AJAX function will return a JSON error response, if a CLI command plain text response, if web browser a nice web page, etc. Log parsing and debug logging aren't there yet, but will be shortly, and will be nice and session based, allowing you to easily pin point any issues. - HTTP handlers -- I'm quite content with mine. Every HTTP request is routed to the correct PHP file in /data/controller/http_requests/ depending on the first segment of the URI (eg. /ajax/ to ajax.php, /2fa/ to 2fa.php, etc.). If a specific controller doesn't exist, it gets passed to default.php and trated as a page to the public site. I know you guys are used to standardized request/response objects, and I could easily do that. Keep routing the same, and pass a $request object, and referenced $response object to the specific HTTP request controllers, but would it really make that big of a difference? I'll happily do it if it makes people happy, but don't really see the benefit of it. - HTTP Routing -- This is one of my many pet peeves with other frameworks, hence why I'm developing Apex. I don't understand the need for a large routing table, where you're required to specify a route for every URI in the system. For example, take the URL http://localhost/admin/users/create. In Apex, it will get passed off to the admin.php HTTP controller, which will do the auth checks and then treat it as a template since it's the administration panel. From there, the template engine will automatically execute any PHP code found at /data/php/admin/users/create.php. Simple, clean, and straight forward. Why would I require you define a specific route for that URI? Maybe I'm missing something here, but what benefit is that? - Dependency Injection -- Been reading up on this more, and I do understand the benefits, but still not fully convinced. Will read more and mull it over in my mind. There's definite benefits to di, but also a cost involved in implementing it, and I need to know the benefits outweigh the costs. Not ruling it out yet though. - Templates, Layouts, Menus -- Happy with mine as is, although will admit, menus seem a bit messy to me. Uncertain how to clean that up more, and maybe someone can come along with a better idea, but for now it's fine. Allows interchangeable menus placed in proper position, setup so any theme can be overlayed onto them, etc. Any HTML / CSS theme available on the internet can be integrated within 30 - 60 mins, and simply work across all templates, supports multiple page layouts for any given theme, etc. - Version Control -- Just working on this now, and am quite happy with it. Basically, after initially publishing a package you can easily create an "upgrade point", at which time all files pertaining to the package will be hashed via SHA1. One command to publish the upgrade, it will go through all files again, check the SHA1 hash with the hashed one to see if the file was modified, and include necessary files in the upgrade. Obviously, ignore functionality will be there, and confirmation of files to include will be there. Once upgrade is published with one command, it's available to all systems via the Maintenance-&amp;gt;Package Manager menu. Simple, clean, and quality. - Security -- Again, this will be going through a professional security audit by a reputable firm before any production systems are put online, but I don't forsee any issues there. I've been working in the crypto-currency market for over 5 years now, so know full well how brutal, skilled, and relentless hackers can be. The security audit may come up with some vulnerabilities, hence why we're getting it done, but I definitely don't expect anything disasterous. I'll be happy to publish the results of the security audit once it's complete. - Testing -- Yes, I know there's currently no unit or functional tests, and obviously that's a critical component and will be added in shortly. I know many people prefer TDD, but I'm not one of them, and prefer development first, testing after. Both methodologies work, and there's no right or wrong on that one. But yes, testing will be there shortly, and most probably use phpUnit. I don't know, I still believe I'm on the right track. Add in composer, got it. Maybe restructure things to implement dependency injection, but I will play around with that more before I decide. Maybe I went about this wrong, but I went from the perspective of all the tech spec sheets that have come acorss my desk over the years. I know the development life cycle, know what clients requirements are, and know what's needed to develop, deply, and maintain professional online systems. There's many standards out there I don't agree with though, hence Apex. This is what I need. For example, my biggest pet peeve would probably be database migrations. I'm quite confident you would be hard pressed to find a single qualified DBA anywhere out there in the world who believes database migrations in Laravel are a good idea, because they're not. I don't know who or what started the trend that database schemas should be written in PHP, but that's simply a really bad idea for a multitude of reasons. Anyway, will leave it there. I'll continue on with Apex development, will add in Composer support shortly, and mull over dependency injection. We'll let the auditors decide on security, and aside from that, I think I'm on the right track. Once done, I plan to try and spark a developer competition, as I will have no problem putting this up against the big boys like Laravel, Symphony, CakePHP, Drupal, Django, and so on. Voluneer competitors, same project the organizers decide on, 24 hours to complete it, and let the results speak for themselves. 
I don't know for other framework/regular PHP app, but in my Symfony projects I used to write dedicated Controller in order to load only the right data for the partial. Then in parent twig template I include (with Symfony twig extensions) the controller action that output the rendered partial. Like that I'm not injecting this data on every page controller. But this is only with Symfony. This library is kind of cool though.
An example might be beneficial here.
 Ok, you're just being a dick for no reason. Plus considering statements like, "instead of doing the right thing and just let the database handle it for you", let's me know you don't really know what you're talking about. Do you think the database layer handles SQL injection, or something? It doesn't, at all. I think there's a configuration option in mySQL that allows you to prohibit multiple SQL statements in the same query, but that's about the best you're going to get when it comes to protecting against SQL injection attacks from the database engine. SQL injection prevention happens software-side, hence the likes of PDO and others. Yes, Apex uses prepared statements the same as PDO and others, hence the place holders. Actually, it may even do it better in ways as Apex checks the data types unlike PDO. For example, if you put %i into a SQL query as a placeholder, that variable must be an integer or else the database layer simply will not send it to the mySQL database engine, whereas PDO doesn't have any checks for data types, nor do many of the ORMs out there. Aside from that, will just leave it there. Again, this will be going through a professional security audit, and I'm sure it'll be find as I've been through several audits before. We'll let them decide if the software is secure or not though. I've been developing crypto-currency based software for over 5 years now though, so trust me, I know full well how brutal and relentless hackers can be. 
It's just a matter of time before The Astronauts land and PHP turns into the Java-lite wannabe it always dreamed of becoming.
It seems like they are pretty capable eg. make pins become inputs. I gotta put more time into it/learn more. Discipline split between hardware/software ehh...(more time).
Hi, when should I use nodejs over php? I heard node is better for scaling, especially apis, is that true?
I'm still looking for suggestions to improve it, of course it looks like reddit threads (I will probably take some idea from it) but I really want to focus on PHP world (RFC, vote, ...) It is open source : [https://github.com/Cryde/php-vote](https://github.com/Cryde/php-vote) (futur devs are in the issues)
Hey Im new to web development I have been doing php since past 8 months and i have covered all the basics and intermediate stuff Like file uploading Cookies Login systems Security PDO Objective oriented php Now i wana know what are some advance things that i can learn and where can i learn them ?
I think that you should take a look at view composers: https://laravel.com/docs/5.6/views#view-composers 
Like Reddit?
I didn't say that using globals was bad for security reasons. It's a bad programming practice - see http://wiki.c2.com/?GlobalVariablesAreBad for more details. Also, it makes testing more tricky. Regarding the document root, I would urge you to reconsider. Almost every modern framework uses this practice, and with damned good reason. The only exceptions are things like WordPress that are notoriously shit anyway.
&gt; Domain logic shouldn't be in ORM entities. So where should it be? In services? Or you should have yet another layer which maps "business entities" to "data model" (this approach was taken by Atlas.Orm for example)? I think that you are talking about limitations of persistence layer, like... you can't have unidirectional one-to-many relations. But I fix kind of problem by relying on JSON to store this kind of data. &gt; One can argue that ORM is an anti-pattern ORM itself is just about normalizing result set of the query, the anti-patterns starts when you use ORM in non OLTP operations.
&gt; doctrine's annotations are terrible since you now have domain/business models aware of persistence layer/logic. Actually they are not aware of persistence. Annotations is just a way of providing meta information, you entities are not coupled to them at all. They are "Terrible" only because they just move separate semantics and syntax, but this is not a big deal. Consistency is not something PHP devs aware of :( &gt; For instance, having route annotations in controllers is a horrible idea since the controllers aint supposed to be aware of routing Having metadata for some code right next to this code not makes your code coupled to this metadata. Metadata is coupled to code, not the other way. As for SRP - if you talking about "with annotations my module have additional reason to change - when I want to just slightly update metadata" then yes, this could be treated as SRP violation. But... Let's see what would happen if we will store metadata for code separatly. In order to bind metadata to context you must provide some links to this context. Imagina that you want to provide additional annotation for specific method. In that case your metadata file will contain link to both class and method which need to be annotated. And if you want to change method name you will need to change metadata. So again, by comparing efforts and risks, I would say that I don't see any problems with that. Annotations doesn't really have any effects on code by itself. There would be separate thing which will lay on top of your module and will use metadata to alter behaviour somehow (`@Transactional` is good example of such thing).
Make sure to profile you application. See point 3. in [this article](https://tideways.com/profiler/blog/5-ways-to-optimize-symfony-baseline-performance). &gt; Every sub-request will go through the HttpKernel event lifecycle and depending on your Listeners this can add several milliseconds for every subrequest.
As "fesor" already mentioned having annotations on class do not couple them together. Your "annotated" Controller is not aware of routing, the Controller class do not know anything about annotations, it's a responsibility of some another class to inspect annotations (metadata) and to do something (declare routes).
On project that need performance, I always use a caching strategy for such things indeed. Otherwise, for simple websites, the overhead is not that significant. Anyway, it's worth noticing this point, thanks.
"You assume your code is running in an environment that is looking for that particular annotation" - I'm assuming that the environment has all needed code dependencies declared in composer.json. Annotations are part of some library that is required for application to work. I'm not sure it breaks encapsulation. "Changing configuration requires a commit and probably a new branch" - changing configuration file also requires a commit (if we talk about configuration like routing, entity mapping, ...) "Breaks single responsibility principle, the class is in control of whatever it's supposed to be doing and how it's configured" - annotating a class do not provide any additional information to class itself. You do not have "getMyAnnotations" method on a class, so class is not in control of it's annotations.
&gt; Annotations are part of some library that is required for application to work. I'm not sure it breaks encapsulation. By including an annotation you are saying "Here is some configuration that's required for another part of the application and a completely different layer". For example, rules for a DIC or Router. Your class effectively *knows* it's running in an environment where the DIC is looking for an annotation using a specific format. Replace the DIC and either, the annotation is meaningless, or the new DIC is expecting the annotation in a different format and things break. Annotations are used to interact with parts of the application that are completely outside the scope of the class. If you change the implementation of the router to use a different annotation syntax, you also have to change every one of your controllers. Wikipedia defines encapsulation as "A language construct that facilitates the bundling of data with the methods (or other functions) operating on that data". With annotations, the data (in the annotations) is operated on by methods that exist at a completely differently layer of the application. &gt; annotating a class do not provide any additional information to class itself. You do not have "getMyAnnotations" method on a class, so class is not in control of it's annotations. To quote Robert C. Martin on SRP: "A class should have one, and only one, reason to change." if your configuration is in the class, your class has two reasons to change: To change the logic, or to change the configuration. &gt; changing configuration file also requires a commit (if we talk about configuration like routing, entity mapping, ...) It does, but we can add site-specific configuration to .gitignore (or even better, keep it in a different repo to our library files). Consider this: You have two websites, both sell products and both act in a very similar way. You copy the controller over from site1 to site2. The controller includes routes for `/products/`. The second site sells watches so you update the route to be `/watches` on the second website. You've just created a second branch, you can no longer (easily) fix a bug on site1 and push it to site2 (or any of the other sites using that controller). 
In all honesty? Program in either. The majority of sites won't encounter the sorts of traffic that make specific language features critical to its success. However, from a technical POV, NodeJS is a server-side runtime environment for Javascript, and is ideal for network-driven applications. So you'll have to program in Javascript, and will have access to a really good async. So if you want to (or have to) code in JS, eg if you'll be creating an SPA in React or whatever, using NodeJS allows you to have one language across the stack.
 Ummm... maybe I'm just missing something or having a blind moment again, but i don't believe that article has anything to do with PHP. It's means for other languages such as Perl and C/C++, and in those instances, I'm in full agreement with the author. PHP treats variable scope totally differently than other languages though, hence that article is a bit of a moot point. In PHP, if you create a variable within a function, it dies within that function. That's not the case with other languages such as Perl though, where you have to specifically define a variable as local to that function, otherwise it becomes global to the entire system. I could be wrong, but I'm guessing that's what the author was alluding to, and if so, full agreement from me here. Not allowing variables to get away from you and become globalized was a headache back in my Perl days. 
Seems similar to [https://externals.io/](https://externals.io/) ?
https://lemire.me/blog/2015/04/06/evil-abbreviations-in-programming-languages/ https://softwareengineering.stackexchange.com/questions/67310/should-you-use-internal-abbreviations-in-code-comments This ofc also applies to commands. Make your interface clear, don't abbreviate. I don't care if someone else uses "fmt" as well. For all I care it stands for "fake multi threading", I don't know until I look up the documentation and it's not UX friendly. Don't try to justify poor UX decision. 
&gt; You can edit application configuration and application logic in the same file Only if this is how your set up your application/framework. &gt; They are difficult to debug You shouldn't be debugging them, they are metadata, not code that's being executed. &gt; They break encapsulation Again, annotations are not executable code, it's metadata. Regardless of whether your put it in a yaml, ini, xml, php or annotation format, _it doesn't matter_. &gt; Introduces coupling between the class with the annotations and the part of the application that reads it. `@Inject("security.context", required = false)` works on Symfony but won't work if you switch your DIC to PHP-DI. And if you stop supporting yaml while using yaml configuration, you have exactly the same issue. Besides of that, You shouldn't be using that kind of configration for DI _either way_, because it's similar to using a service locator. This is not the fault of annotations, but bad usage thereof. &gt; They make it more difficult to instantiate an object with different configurations Configuration is static, so if you want to have different metadata per instance, annotations are not the right solution for that specific problem. I've not seen a single good argument _against_ annotations here, just poorly understood concepts and miss-use of annotations. 
&gt; Consider this: You have two websites, both sell products and both act in a very similar way. You copy the controller over from site1 to site2. The controller includes routes for &gt; /products/ &gt; . The second site sells watches so you update the route to be &gt; /watches &gt; on the second website. You've just created a second branch, you can no longer (easily) fix a bug on site1 and push it to site2 (or any of the other sites using that controller). This is a faulty setup in the first place. if you _really_ wish to solve it like that, don't use annotations. Annotations are not a silver bullet. 
Doctrine entities are _NOT_ DTOs! 
They downvote you because your comments don't make sense. Annotations don't add logic, they add metadata.
Annotations can't be dynamic, so if you're using the same controller for 2 different websites (arguably a bad solution anyway), use a different way of defining configuration, xml or yaml for example. This way you can load only what you need.
You’d have better answers probably asking in the Wordpress thread. But are you looking to learn Wordpress theme and plugin development, or just using the backend? -dk
&gt;But wait, this one is different! Well that is certainly true. 
Quick spelling issue in `slicing synthax sugar` - syntax does not have an "h" in it. 
&gt; Please explain what the advantages of annotations are, if they are not being able to edit configuration and logic in the same file? They provide mapping where you only have to define the config, rather than also a reference to a property/method/class. It's not just about editing, it's also about tracing back this mapping. Reading is a big part of being a developer, and having to find this mapping all over the place is _a lot_ of cognitive overhead. &gt; With yaml/ini/xml/php I can substitute the logic, run the code in multiple locations with different configurations or switch from YAML to INI without modifying any of my classes. If I use annotations I lose that flexibility entirely. I could switch from annotations to YAML, but then when a developer looks a my code and sees @Route, changes it and nothing happens, that's not confusing at all. I still need to go through and change every class. Going from YAML to INI I can delete the config.yaml entirely. Sure you can, but how often do you _actually_ do this? Having different configs all over the place will not make management any easier. Practically speaking, changing a configuration format happens once every 5 years? Maybe never? &gt; If I change my router from YAML to INI, I don't need to touch any of the classes. Call it bad usage but that example is straight from the symfony docs (though perhaps out of date, looking now as I can't find the page it was from) This probably from the JMS DI Extra Bundle, which hasn't been in the Symfony core for years if it ever was already. There have been several RFCs to re-introduce annotation based DI config but they have all been rejected so far. &gt; I've not seen a single good argument for their use but plenty of reasons not to use them. In the end it's a configuration format that provides some clear benefits over others, object mapping being one of them, and validation being a second, as it literally gets translated to PHP objects during reading). Other formats have other benefits. You might not have seen a good argument, but I've seen plenty.
I'm seeing reasons not to use annotations but I still haven't seen any reason to prefer them over alternatives. 
Date('Y')
[removed]
So, I have a very specific question about a problem I'm encountering. First, the error I'm getting: PHP Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 20480 bytes) in /opt/************/******/**********/dbase/PrimaryConnection.php on line 72 So, what happens is that for some reason, my code runs out of allocable memory. When that happens, the process freezes, and I have to manually go there, kill the process and start a new one (it's managed by a service, so all I do is `sudo service myservice restart`). I haven't yet figured out why my code would allocate all that memory without ever freeing it, it genuinely feels like a memory leak somewhere (which I didn't even know I could have with PHP), but I'm investigating. The file that you see in there is basically my wrapper around PDO (connection and the various PDO methods), literally just that and nothing else. And I should point out that I use `PDO::MYSQL_ATTR_USE_BUFFERED_QUERY`. Now, my question is: how do I avoid that my process freezes like that? Is there a way for me to free the memory? Are there widely used methods to investigate this kind of problem that I might not be aware of?
Why are people busting on OP for wanting to learn WP? It's a simple request, leaving that aside from a money making stand point WP is very lucrative. The fact that guys don't like WP doesn't it make any less lucrative. This sub downvotes anything that doesn't align with the general views of what's good or bad. It's basically an echo chamber of "I'm better than you because I code in X framework, btw Y is shit". Sure, October CMS or some other CMS may be better code and architecture wise than WP but OP didn't ask for October probably because whoever he's working with right now doesn't want October. Most of you act like a bunch of 12 year olds in the school yard fighting over who's toy is better. ---- WP is pretty well documented, I suggest you start there. Install a theme, build a plugin and you'll get going pretty fast.
I’ve been using it recently on a PHP 7+ project, refactoring some old code as I go. It’s great! Makes things so simple. 
Check out [Type Rocket](https://typerocket.com) - "It is like Advanced Custom Fields + Laravel + Magic in WordPress for FREE."
not too much, as there is strnatcmp() which does a better job
Hello, I'm fairly new to reddit, PHP and Wordpress so go easy on me. I'm trying to set up a default image for unset custom fields in wordpress. the function checks if the variable has a value, if it does it then sets the thumb variable to the the chosen image and outputs true to the console for testing purposes. if no image is set then it instead sets the thumbnail to a default image. This however does not work. I know that the this else statement is working correctly because false is getting outputted to the console for each item without a thumbnail. I have also made sure the custom field is set up correctly and I have even tried just grabbing the image straight from a directory but nothing works. I've put an arrow to the line that is giving me trouble I'd really appreciate the help if anyone can figure this one out for me. add_filter('wp_nav_menu_objects', 'my_wp_nav_menu_objects', 10, 2); function my_wp_nav_menu_objects( $items, $args ) { // loop foreach( $items as &amp;$item ) { // checks if thumbnail is set $thumbtest = get_field('menu_thumbnail', $item); if ($thumbtest):?&gt; &lt;script&gt;console.log('true')&lt;/script&gt;&lt;?php $thumb = get_field('menu_thumbnail', $item); $menu_title = get_field('menu_title', $item); //sets placeholder img if no thumbnail is set else:?&gt; &lt;script&gt;console.log('false')&lt;/script&gt;&lt;?php -----&gt; $thumb = get_field('default_image'); $menu_title = get_field('menu_title', $item);?&gt; &lt;?php endif; // creates thumbnail and respective text if( $thumb ) { $item-&gt;title .= ' &lt;img class="thumb-imge" src='.$thumb.'"&gt; &lt;div class="thumb-cover"&gt; &lt;div class="thumb-container"&gt; &lt;h5 class="thumb-text"&gt;'.$menu_title.'&lt;div class="underline-thumb"&gt;&lt;/div&gt;&lt;/h5&gt; &lt;p class="thumb-button"&gt;View&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/img&gt;'; } } // return return $items; }
[https://github.com/FreeDSx/SNMP](https://github.com/FreeDSx/SNMP) Just posting this here I guess. Recently created a pure PHP SNMP library (doesn't need the core SNMP extension). I've decided to start grouping these protocol implementations under the same org in GitHub, so the project name isn't very interesting. Oh well. It has a few things it supports which the SNMP extension does not, like getbulk requests and strong encryption mechs (aes192, aes256). Main features so far: \* SNMP version 1, 2, and 3 support. \* Supports all authentication mechanisms (md5, sha1, sha224, sha256, sha384, sha512). \* Supports all privacy encryption mechanisms (des, 3des, aes128, aes192, aes256). \* Supports all client request types (Get, GetNext, GetBulk, Set, Inform, TrapV1, TrapV2). \* Supports sending SNMPv1 and SNMPv2 traps (including inform requests). It also has a method for doing an SNMP walk. I'm currently working on a trap sink component and I'd like to add some sort of a general server component to it sometime in the future. Unfortunately it also doesn't have MIB support...another thing that needs to be added. Any feedback or bug reports would be appreciated. I haven't had a chance to test it against many different devices yet.
Good stuff, thanks Patrick 
I'll smack you if I see you using chaining/nested ternary.
I'm sorry, but I can not join the enthusiasm some people seem to have for this idea. lets pick this apart a bit &gt;After setting up Shoot, the only things you need to do to decouple a template from its surrounding and make it standalone, is adding a model to it using the {% model '...' %} tag, creating that model as a PHP class that extends Shoot\\Shoot\\PresentationModel, and optionally adding a presenter by making the model implement Shoot\\Shoot\\HasPresenterInterface and creating a presenter that implements Shoot\\Shoot\\PresenterInterface. You're now done. "decouple a template from its surrounding" sounds interesting, but is that really what you do? from my perspective what you do is rather than use injected values you hard couple your template to a specific model class - which is kind of the opposite of decoupling it. Then shoot dictates the model to inherit from shoot itself, from a class that adds rather generic methods that really shouldn't need to be part of the model, while it also adds a final constructor, as well as methods with names as generic as "getName" that reference the class name, rather than a name field, and if it has anything but static data, it needs to know what its presenter is. let that sink in for a moment, your model needs to know what loads and formats it? The model in shoot, is not the applications model, it is - as shoot calls itself - a PresentationModel, and in all honesty, its a dumb container for variables that is filled in the Presenter, which means if you use for example an ORM, or you have a model with its domain logic already, you end up with a presenter that first loads your actual model, and then translates it to the PresentationModel, adding a layer of abstraction with the above mentioned issues - to what actual benefit? You can achieve the ability to load data for partials by using an object in its context, and have the object load only when its method is called easily, without hard coupling a model to your template, having to inherit from its classes and using two models in general.
Quite often I want some shorthand notation for: $foo = $bar !== null ? $bar-&gt;getFoo() : null; so I can write: $foo = $bar &lt;operator&gt; $bar-&gt;getFoo();
Injecting values is not a universal solution for every problem. Views (templates) dictate what you need to be able to render the view. View models are a tactical pattern that allow you to separate your presentation layer from your domain layer (model). So, you are actually decoupling your presentation from your domain layer, by using the View model and it's presenter. This provides multiple benefits, like testing your views in isolation, having a "contract" on what your view demands and hiding how you are actually fetching all this data from the presentation layer. The negatives you mentioned regarding the implementation are, are far as I see them here for Rapid Application Development. You can always write a "cleaner" implementation if you wish so, but the idea is still worth considering if you application is complicated enough (or could become) to warrant something like this. I am in the processing of cleaning up/refactoring a relatively old application and having my domain model being used in the views is a real pain in the ass. If something like this was used I would have a place where I could switch the old domain models to the new implementations without grepping through code and trying to find if some getter is still used in one of the templates.
They're designed to be cached in production, obviously.
I've not said its a universal solution. and no Views do not necessarily dictate what you need to be able to render the view, you can build templates that use the data they get to determine what to display. As for decoupling the presentation layer (view) from the domain layer (model), could you explain how this decouples more than using the context array we usually hand to twig? I have the strong feeling that this depends a lot on how you provide the values to twig so far. My main criticism is that the templates hard-couple the model classes, and those have to know what presenter to use, which actually means there is no full separation, and no it doesn't "hide" how things are loaded, as you basically set in stone how things are loaded by using the class name in the template, and by having the class return the presenter to use. Especially clean mocks for testing get a lot harder with a setup like this, where you can not simply inject your mock for the model anymore. 
Any time you need to do stuff with arrays or stdclass (eg after json_decode) of an origin you don't control, the null coalesce operator makes it all better.
&gt; You're absolutely right. Why would you want the configuration for your router spread among two dozen controllers rather than a single routes.json then? Because it's tightly coupled. The Route configuration is literally a mapping of an URL to a piece of PHP code. If I look for a route name, I'm not interested in finding the configuration file, I'm interested in the piece of PHP that it executes. This saves me an additional search query. &gt; Again, as above, annotations put this "all over the place". If the configuration changes I can do it in one place using json/yaml/ini/whatever. As you say, annotations are a lot of cognitive overhead. I'm adding a new route, how can I check it's available? I need to look though 50 methods across two dozen files. Or automate that process somehow. You can also have a dozen of yaml/xml/ini files and have the same problem. Symfony solves this with debug commands where you can get all the routing details in the final state that you need. This also solves the problem of vendor routes being imported, which you can't find in your project either way. You'll also notice if a route already exists, because (A) test will break or (B) your new action won't ever be called. &gt; Definitely never if you lock yourself in with hardcoded configuration to start with. Configuration is static, not sure what you're referring to here ;) 
Just because my comments dont make sense to you, doesnt mean my comments dont make sense to others. I find it funny when we criticize the annotations are bad since they are comments, you annotation supporters try hard to defend against this, saying that they are not comments but code/logic. Now when it comes to breaking SRP/Encapsulation, you are saying exactly the opposite that annotations are mere metadata, not code/logic. Need to have at least a little bit consistency here, cant we? 
&gt; Because it's tightly coupled. The Route configuration is literally a mapping of an URL to a piece of PHP code. If I look for a route name, I'm not interested in finding the configuration file, I'm interested in the piece of PHP that it executes. This saves me an additional search query. If I want to see which PHP method is being executed by visiting `/news` I potentially need to look through all the controllers. How is that less searching than looking in a central configuration file? The argument is moot: It really depends which way you're looking do you want to know the method associated with a route or the route associated with a method. A single configuration file will tell you both in a central location. I'm struggling to think of occasions where I'm already looking at a controller action and then have to work out the corresponding route. Normally I'd get a ticket that says "There is a bug on this page" with the URL then have to find the corresponding code. A lot simpler with a central routing table. Perhaps your workflow is a lot different but I can't think of why you'd be looking at the controller and then need to work out the route. &gt; You can also have a dozen of yaml/xml/ini files and have the same problem. Symfony solves this with debug commands where you can get all the routing details in the final state that you need. "I caused a problem by spreading my configuration around multiple files so I had to create a tool to solve it. It's definitely not that doing so was a poor choice to being with". I don't know of any routers that split the routing table up into dozens of files. Normally you'd just have a single file where a simple ctrl+f will get you the information about the route. If you really wanted it would be trivial to create such a tool for a routing table, but because the configuration isn't spread across dozens of files, unnecessary so I doubt there is such a thing. This discussion being fixated on routing is somewhat of a tangent. The downsides of annotations exist regardless of how they are being used. At a more generic level, regardless of what you are using them for, annotations tightly couple the configuration to the implementation. Why would you sacrifice the flexibility of loose coupling for the sole benefit of being able to edit logic and configuration in the same file? 
Thanks but no magic one liners please. Less lines does not maketh better code. More lines with clear structure and comments are much better.
Yep. Great for object sorting. ``` &lt;?php usort($people, function (Person $a, Person $b) { return $a-&gt;getName() &lt;=&gt; $b-&gt;getName(); }); ```
Ditto. There comes a time when trying to compact your stupid code into the most unreadable shorthand ruins it and just makes you look like an asshole. Be verbose and comment liberally. 
This. Making your shit unreadable and unintuitive benefits nobody.
&lt;=['-']=&gt;
[https://www.phptherightway.com/](https://www.phptherightway.com/) can give you more insights to php (design patterns for example)
Reminds me of python.
The ?? Is my absolute dream function, I'm so glad I don't have to write isset() ever again. 
strcmp() is the old-school way to do this. I guess with strcmp() it's more obvious that the comparision is case-sensitive. To use the spaceship case-insensitively, you'd have to write: return strtolower($a-&gt;getName()) &lt;=&gt; strtolower($b-&gt;getName()); Or just use `strcasecmp($a-&gt;getName(), $b-&gt;getName())`
Well.. I'd argue that this is more readable: if ($bar) { $foo = $bar-&gt;getFoo(); } else { $foo = null; }
I would rather do: $foo = null; if ($bar) { $foo = $bar-&gt;getFoo(); } But with many of those it could become cumbersome, especially in HTML templates.
Those are not interchangeable though.
In my experience 95%+ of times I've run out of memory were either a long-running cli script (cron, daemon etc...) allocating more and more memory while never allowing garbage collector to free the memory (unset and/or throw away no longer used variables, use scopes effectively); or running some fucked-up query (possible caused by some strange bug) returning thousands or more rows which then caused ORM to try to create as many entity objects. The rest 5% were mostly some endless loops or do/whiles that had a problem in the break clause causing them to run forever. Unfortunately my own experience is the only thing I can provide on such a vague error. Hope it helps at least as little :)
One-liner if operator smells
The purpose of the &lt;operator&gt; is to return *null* when condition is not met.
Which features do you consider magic one-liners? The null coalescing and spaceship operator (three way comparison) have been available in many languages for a long time and are meant to express very fundamental concepts.
And who in this thread says that annotation is not a comment in PHP? It's a comment (that's how it's implemented for now) but it is still a metadata and it is still not a code/logic. Pretty simple idea, yeah? The package with 70 000 000 installs (doctrine/annotations) don't need to be defended, it's a real life, annotations are used a lot and will be used a lot in future (imho). 
You are actually describing my case accurately enough that it's kinda scary :P &gt; Q: is this error happening in a long-running script? Cli based daemon/service perchance? Yes it is. I have a service (which is started by my build script when the AWS instance is created) that launches a PHP process (`php MyScript.php --yadda -y`) that in turn instances a daemon class that runs an infinite loop which is basically the heart of my application. The infinite loop though was actually designed as such, and it's divided into 3 stages: * first, it prepares a set of "things" to execute, * second, executes those "things" * third, logs some information into text files, does some cleaning up, waits 1 second and then loops again. Between step 2 and 3 is where the whole of the backend of my application runs. Basically, this is the structure: Build script &gt; sudo service MyService start MyService &gt; php MyScript.php --args MyScript.php &gt; $daemon = new Daemon(); $result = $daemon-&gt;run(); // Here's where the infinite loop is As you've guessed, inside the infinite loop memory is of course allocated, and it keeps building up until it fills up all the memory allocated for the PHP process, and freezes once it tries to go over that quota. I've found a way to actually prevent the freezing of the process and actually terminate it after I posted my first comment, but the memory issue is still there. I do use a lot of `unset()` to get rid of the objects once they aren't needed anymore, and I should point out that I tried changing those `unset()`s to `$var = null` (since `unset()` doesn't free memory, but it just removes the reference to the object, for the GC to then clean up), but observed no apparent change in memory usage and build up. I had also thought about checking my queries to make sure there isn't some wrong one that returns huge data-sets, but that's a much slower process to verify all of them, and I can't think of any that would return thousands of records off the top of my mind.
I actually kinda like their idea mostly because I'm not sure reddit is always the best place for certain things. For instance, maybe someone has an idea for an RFC but it's so rough they don't even want it to be an RFC draft yet. There are certainly instance where you'd like to get feedback from the community, without being ready for the scrutiny and feedback an official RFC would get. I think that if OP (/u/Cryde_) refines the concept (a bit) and changes how they pitch the idea it could be great for the community.
Hi Peter, thanks for the elaborate feedback, I appreciate it. Maybe I should have phrased "decouple from surroundings" differently. What I meant to say here, is decouple the the template from it's parent, in a way that the parent doesn't need to know what data to provide, but can simply render the template. It is then indeed hard coupled to a model, which is hard coupled to a presenter. I think the extension is somewhat opinionated and I guess I can see why you might dislike it. It may not be a universal solution, but we've sure found it to be an extremely helpful tool in rendering large applications, with loads of nested templates and complicated data. The application we're mainly using it in is a webshop of considerable size, where the data needed to correctly render some templates may need to come from various sources and would be cumbersome to pass down 10+ levels of includes. Now, if you actually have a domain model that maps to whatever your template needs 1-on-1, the presenter might not add a lot of value (except for not having to pass that model down the template tree), but we've rarely found our templates to be that simple. The last paragraph of your replay sound interesting enough, but I feel like I'm missing some specifics there. How would you for instance make that object aware of context (let's say the PSR-7 request) and how would you prevent having to pass it down 10 layers of templates? Or would you make it globally available in all template contexts (not including templates with a specific context using \`only\`)?
Both shorthands, Elvis and null coalescing, are based on the operands value. Introducing one that doesn't would make a confusion
In modern entity framework, their preferred way is to write mapper classes using fluent api. If you are still using annotations for your entities, think about switching to this much better alternative: https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/fluent/types-and-properties
&gt; why does an entity need to care that There's simple test which could show does entity cares or not - simply move configuration from annotations to xml/yaml file. If there are no difference in behaviour and you don't need to edit actual code, then your entity doesn't care. &gt; This can be a huge amount of work, especially if there are different teams working with the database/storage and the business model. This is worst idea that someone can came up with. Teams separated by layers. This is just inefficient since you will have more communications between teams. &gt; Now you see, they are indeed tightly coupled to the persistence layer Please provide your definition of coupling. I think that you are missing something important here. &gt; you will have to take care of this mess when it happens. I use Doctrine for about 6 years and I never experienced any problems with annotations. Most of the mess was caused by bad decomposition of entities. &gt; as future routing changes(maybe for SEO reasons, etc) This isn't a big problem. 
This is indeed the better alternative. Where reasonable, \`else\`s should be avoided
I know where you're coming from but I don't think the two are equivalent at all. You're probably referring to list comprehension, which looks like a whole bucket of WTF to the uninitiated. Once you take the time to learn it, though, you can see how powerful it is. It can make you think about problems in different ways. Chained/nested ternary operators, on the other hand... no. It's not a powerful concept. You don't really get better at reading nested ternary the more you do it. With list comprehension, you can elegantly fit one or more loops or conditionals into a single line with little wasted space. With ternary, it's just the conditionals and it's never elegant no matter how much you study it.
I agree.
I concur.
Sorry - it wouldn't let me add text. I meant to ask: What's the best way to learn PHP if you're mostly learning it for legacy maintainance and to possibly migrate it to another language?
are you so ashamed of knowing PHP you made throaway?
what do you mean
Why would you want to migrate it to a whole other language? Wouldn't it be better to just upgrade it to the latest version?
No, these operators actually work. They’re language quirks. Here is more for your enjoyment. https://www.destroyallsoftware.com/talks/wat
Laravel is built on top of Symfony, things like Request/Response, Kernel, Router, Container are all extending Symfony classes. If you are familiar with this lifecycle from Symfony, you can apply that to Laravel as well. 
I never understand anti-framework guys. They always be saying frameworks are evil and this and that, but apparently they do not realize they always end up making little frameworks of their own. The only reason I see for this is to obviously have greater control over the app and understand everything, and maybe gain speed (depending on the app and your skills). But I'm more than happy to trade those offs for all the functionality already written (maybe much that I need), and probably much better written and tested that I could ever do.
How about those who maintain decade old legacy PHP?
Nice. I'll learn them by heart and win all those job interviews with these PHP black magic.
He thinks that the turd will shine after the migration.
Could it be [clearstatcache](http://php.net/manual/en/function.clearstatcache.php)?
This tool looks like it's directed towards new projects, so existing legacy projects are out of scope. If you're asking about actual legacy PHP versions, I'm not sure there's a good reason to limit yourself to an old PHP version, given the current state of virtualization and containerization.
&gt; Returns TRUE if the file or directory specified by filename exists; FALSE otherwise. If your filename as returned by the DB is empty, file_exists will check if /path exists. If /path is a directory, then file_exists will return TRUE. You probably want to use the is_file function instead. 
generating tests, docs still work for old projects too. in fact it can be updated to fill missing stuffs in existing project too (will do it asap) 👏
Thanks for catching this ! 
Hey Eric, let me give you a quick example on this. a few notes: * this is just an example, which I quickly hacked together for this discussion, this is by no means production ready code, but meant to showcase the suggestion I made. * Right now my ContextProvider will call the ContextModule each time you use it in the class, as the ContextModule most likely is doing the more heavy lifting for you, it seems a reasonable assumption that results should be cached here, which I've skipped for the purpose of the example. * Also, for the sake of the simplicity of the example, the ContextProvider takes instances of the ContextModule classes, in rl you might want to take a classname here, and instance when needed (for example through your container). So, lets start by defining a ContextProvider, a class that basically allows to register the context modules, and takes care of calling them when needed. &lt;?php namespace ModularTwigContext; use Psr\Http\Message\ServerRequestInterface; class ContextProvider { private $modules = []; private $request; /** * @param string $key * @param ContextModule $module */ public function registerModule(string $key, ContextModule $module) { $this-&gt;modules[$key] = $module; } /** * @param ServerRequestInterface $request * @return ContextProvider */ public function withRequest(ServerRequestInterface $request) { $newInstance = clone $this; $newInstance-&gt;request = $request; return $newInstance; } /** * @param string $name * @param array $args * @return null|mixed */ public function __call($name, $args) { if (isset($this-&gt;modules[$name])) { return $this-&gt;modules[$name]-&gt;getContent($this-&gt;request); } return null; } } As you can see this ContextProvider has 3 methods: * `registerModule` will take a key and a ContextModule instance. the key is later used in twig to access the module * `withRequest` this allows you to create an instance with a request. It will create a copy of the provider, to avoid side effects when running in an environment where multiple requests might be handled with the same instance, for most php applications you probably could use a setter instead * `__call`, one of phps magic functions, this is used to allow fetching the content from the module by using the key Now the ContextModule interface is a rather simple one, as it only defines a getContent method, which has the request as a parameter - this method will be called by the provider, if the module is accessed from twig. &lt;?php namespace ModularTwigContext; use Psr\Http\Message\ServerRequestInterface; interface ContextModule { public function getContent(ServerRequestInterface $request); } personally in my framework, I have specific files where I configure my services, which is where i would register all modules, and then slam it into the di-container however, i guess you have to figure out a place that fits your application. Registering a module is no witchcraft, but I'll include an example here, so we get to a "complete" example. In reality you probably don't want to use an anonymous object.. &lt;?php $contextProvider = new \ModularTwigContext\ContextProvider(); $contextProvider-&gt;registerModule("example", new class implements \ModularTwigContext\ModularContext\ContextModule { public function getContent(\Psr\Http\Message\ServerRequestInterface $request) { return [ "user" =&gt; "ppetermann", "avatar" =&gt; "http://www.gravatar.com/avatar/13a6ddb60faabf8f616febcbb9473d5c" ]; } }); As you can see I'm not doing anything with the request, and just return an array with a user and an avatar in this example. You probably can equate this ContextModule with a Presenter, and if you feel you need an additional model, you could also return your models classes here, rather than an array, but, well thats up to your implementation. So the majority of your questions was about how I'd use this, and to answer those questions, I need two twig templates, the main template, and one that is included - for the purpose of simplicity lets go with &lt;h1&gt;My Example&lt;/h1&gt; {% include "example.html" %} and &lt;img src="{{ modules.example.avatar}}" alt="{{ modules.example.user }}" /&gt; And to tie it all together the render call: &lt;?php $twig-&gt;render("index.html", [ "modules" =&gt; $contextProvider-&gt;withRequest($request), "..." =&gt; "..other fields.." ]); I probably should mention that in my framework I'd call the render method of my base controller, and have the modules injected into the context there (doing an array merge over the base controllers context and the actual controllers context), which spares me from adding the modules each single time manually but thats implementation details that aren't too relevant for the example. so to answer your questions: how i'd add the request should be clear, how do i prevent having to pass it down 10 layers of templates: well twig includes actually have access to the current context by default, so I don't really need to make it global, because it already is, and through the modules.key... syntax i keep each modules content cleanly separated from each other. If i haven't missed something this solution should solve the described problem without the hard coupling to the templates, and without the model having to know about who loads it - that is if you even need one.
right it can nonetheless be good groundwork for kickstart and since it will be supporting user supplied templates one can get around with the "opinionation" it carried. 😁 and obviously as being in early stage development it still can be improved to make more generic, more configurable. but if no one needs it, no one cares it or contributes (at least some issue) to it, i will really have to afford less time expanding it because the current "opinion" is just good enough for my case (and maybe free others) 😎
What about them? Not being funny but we all maintain old legacy code and are all well aware that in most cases new stuff wont be practical to use with them. It's not on the author of an opensource contribution to make your life easier.
Let's say I've used your tool a few times, I know how it works, but mistakenly I always type `format`, because `fmt` makes no sense. It would force me to look up the docs _again_ because it doesn't work out of the box, because it's not intuitive. I will repeat myself: Don't try to justify poor UX decisions. Just name it `format` and gain the free benefit of being intuitive rather than obscure.
&gt; If I want to see which PHP method is being executed by visiting &gt; `/news` &gt; I potentially need to look through all the controllers. How is that less searching than looking in a central configuration file? With everything 1 (or multiple) config files: 1. Search for "/news" 2. Open the match 3. Try to find the controller and method that belongs to it 4. Open the controller class 5. Find the method With annotations in your controller: 1. Search for "/news" 2. Open the match In terms of a CLI tool (such as Symfony), you can also do `php bin/console debug:router` or any of the arguments to make searching easier. This will also grab vendor routes in case of Symfony. &gt; I don't know of any routers that split the routing table up into dozens of files. Any router that allows loading configuration. It's not always a good idea, but conditional loading (multi tenant) or vendor provided routing files do this (I recommend to avoid annotations in vendor code!). Anyhow, there are positive sides and negative sides. If Annotations were bad, C# and Java wouldn't have made them popular. I'm a big fan of annotations when you use the right tool for the right job. There _are_ benefits and they are pretty well known, so please don't tell people there are _no_ benefits, just because you don't like them.
Thank you ! I'm open for any suggestion :) I will probably put an "idea template" to help user when submitting an idea 
[externals.io](https://externals.io) is a more "readeable" [http://news.php.net/php.internals/](http://news.php.net/php.internals/) I think 
https://i.imgur.com/DK1ckG8.png and there is noting contrary to common sense
Well, it *is* a Twig extension. 
PHP isn't a super hard language, it just has lots of gotchas that are hard to find out about without experience. So rather than attack the basics of the language, here's a high-level path of migration suggestion: Figure out what your target language or framework is. Laravel if you want to stay in PHP, Node if you think 2011 was the peak of technology, Go if you think Google can do no wrong, Elixir if you like the Ruby language but hate everything else about it. Then take a look at the strangler pattern. Figure out how your routes are segregated, and route-by-route, forward your requests to your brand new shiny application.
yes but I mean, if I wanted to load data into a parent template for a component that needed to appear on every page, I would just create a Twig extension so I could call "getTwitterUser" or whatever in my template without having to inject it into every single controller method (which if I'm understanding it correctly is the problem you are trying to solve). Am I missing something?
You did understand the example correct yes, but it was meant as just that, an example. The goal ultimately is to tie content and the provider of that content to the template more directly, instead of the topmost template having to determine all required data for all sub templates beforehand. There might be hundreds of tiny pieces of data that you might require to be passed down the template tree. Also a twig extension could help in getting data from your data store, but it wouldn’t typically have access to your request context.
As I said, the single benefit is editing configuration and logic in the same file. My argument isn't that there are "no benefits" it's that the downsides of tight coupling, inflexbility, difficulty with version control, broken SRP and broken encapsulation heavily outweigh that very minor convenience. 
&gt;docs (.md) generator from docblocks that doesn't sound like a good idea
Here is the official announcement from AWS: AWS Elastic Beanstalk adds support for PHP 7.2: [https://aws.amazon.com/about-aws/whats-new/2018/08/aws-elastic-beanstalk-adds-support-for-php-7-2/](https://aws.amazon.com/about-aws/whats-new/2018/08/aws-elastic-beanstalk-adds-support-for-php-7-2/)
Accept that legacy will be legacy. And - being PHP - a lot of corners have probably been cut with inexplicable or weird behavior that takes a lot of combing through to understand even partially. Definitely start with what is available, deprecated, discontinued, best practices, discouraged/frowned upon throughout the different versions. Functions, classes, language structures, etc. A concrete PHP version would've been nice information. Check out the PHP Standards Recommendations (PSRs) at https://www.php-fig.org/psr/. Don't try to "save the world" and change everything to be PSR compliant. Instead, slowly move towards a standard - perhaps not even PSR but your own variation - as you refactor code you meet, which is caused by a different task or bug report. Don't radically change functionality in legacy logic. Especially if you aren't certain of the outcome and possible corner cases. Instead, throw in a "HERE BE DRAGONS" comment/docblock. If needed, re-implement the functionality separately and implement regression tests to check the old and new implementations against each other over time. Eventually, when the regression tests have been unanimous over a certain amount of time, you'll be able to completely remove the old approach and exclusively use the new one.
Not going to get into a holy war here - the company wants to migrate what it can when it can. They hired me (a node-specialist dev) partially in order to ease that migration. 
Good luck with that... 😅 😅 😅 
Prepare a good exit strategy. The strategy for your new company is insane and will result in a failure. It is **not** possible to migrate a project from one language to another, especially to something some completely different as *proper* javascript. You have two options: - complete rewrite - refactoring the existing legacy codebase to something less shit For the former, I cannot give any suggestions. As for refactoring, there is the classical Fowler's book for that (which will be getting a 2nd edition bt the end of this year: https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599). TBH, I would actually call the company and tell them that you can't take that job.
??? I wasn't asking for help
Other than learning the basics of PHP, there's a lot more to doing any migration, even from legacy php to new PHP. Here's some general advice 1. Accept that it's going to take ten times longer than you budgeted for and that it'll involve rewriting most of the code. 2. I've worked as a developer for 15 years, in cases like this you're usually better off starting from scratch, gather the (updated) requirements and rebuild * The business requirements have almost certainly changed anyway * There are probably significantly better ways of achieving the goal than the way it was done in legacy code. Newer technologies, newer techniques, etc so don't just do a direct port from php to javascript * Parts of the site probably aren't used any more. If you do plan to do a direct migration, track all page views and function calls for a month, you'll be surprised how much of the code is never executed. * There will be parts of the code that are infuriatingly complex/long winded and only understood by the person who wrote the code. Don't try to understand the code, re-engineer the requirements and rebuild it.
I think it's a lot of code for something that could easily be done by some twigextension. Easy to maintain, approx. 20-40 lines of code and voila. 
N O T E V E N O N C E
Why not create a template, for example [`localheinz/repository](https://github.com/localheinz/repository), submit it to [packagist.org](https://packagist.org), and then run, for example ``` $ composer create-project localheinz/repository ~/Sites/foo/bar dev-php-library ``` ?
There's only one way: work through a bunch of legacy projects. There is no shortcut.
Does anyone know if sluggable works with translatable?
If you find a language independent testing framework, you could write tests for the existing code and try to implement the features in the new language.
I think that with the current community standards that you’re right. If you look at how some other languages, like rust, use this then it could be pretty useful. Maybe it wouldn’t be as useful for such a high level (loose) language but it’s something I’ve considered for a while now.
Playing the number game is the best way to show the reality. I didn't see much popular libraries that still use mysql\_\* functions, global variables, and do not filter user input. And what if I ask you to show me some proofs of these millions developers. Or this is just a random number from your head? Anyway I agree with your points in linked post. It really sucks that annotations are not supported natively and implemented as a part of DocBlock in PHP. I had some issues with them, just because they are not supported natively. More generally annotations are the same as configuration files for me. The difference is that you split the configuration per class. (I think we both can agree on this) Let me try to point out the pros of this kind of split: \- You see the contexts in which the class is used. I open the controller and by looking at annotations I do not need to find some configuration file in order to know the route path, security restrictions, arguments mapping. The same for proxies/decorators like [https://github.com/phpro/annotated-cache](https://github.com/phpro/annotated-cache) (first result that I googled). Old argument but still an argument. \- It's more easy for me to setup DI container. I like the Java Spring approach with "@Component" annotations to mark a class to be a member of DI container. Than I do not need to have a almost useless 1000+ lines config file like Drupal has [https://api.drupal.org/api/drupal/core%21core.services.yml/8.2.x](https://api.drupal.org/api/drupal/core%21core.services.yml/8.2.x) Finally I do not see the real difference between dependency on configuration file format and dependency on some annotation. It is still not flexible and the solution is to have some standard for all frameworks like Java has for persistance [http://www.datanucleus.org/products/accessplatform/jpa/annotations.html](http://www.datanucleus.org/products/accessplatform/jpa/annotations.html) Hope you have found something useful in my comment.
I quite like this, but it reminded me of a horrible idea I once had for minimizing TTFB using generators. It inspired me to finally get around to coding that, and the result is... painful. [LazyContext.php](https://gist.github.com/8159bd5ab9774dbbd7db151cb593feb6)
&gt; I'm quite confident you would be hard pressed to find a single qualified DBA anywhere out there in the world who believes database migrations in Laravel are a good idea, because they're not. I don't know who or what started the trend that database schemas should be written in PHP, but that's simply a really bad idea for a multitude of reasons. Most developers are not DBAs nor do they have the resources to hire a DBA to design, develop and maintain their schema. Migrations are a good approach to bridging the gap between DBA and developer, and while they're far from perfect, they are a huge step forward from developers editing the database schema in their client and committing a `.sql` file to their repository. &gt; Adding a /public/ sub-directory. [...] That's probably easier than getting people to change the document root of their server every install. A Key (Key with a capital K) focus when building software to be used by others is **safety by default**. You should, to the best of your ability, design your software so that a mistake by a developer does not create an attack vector. Designing a framework that depends upon your users **never** misconfiguring their web server is very problematic. The reason that all modern frameworks use the `public` webroot model is *because* it's a huge step towards insulating developers from that sort of mistake, because if they do misconfigure their web server their application is going to break so it's impossible for it to go undetected. Choosing not to use the `public` web root model is deeply irresponsible. Everybody has at least once in their life as a developer misconfigured a web server, even the smartest people in the room do it. &gt; This is one of my many pet peeves with other frameworks, hence why I'm developing Apex. I don't understand the need for a large routing table, where you're required to specify a route for every URI in the system. The reason is pretty simple: not only does explicit routing allow far greater flexibility (which is essential for most medium-complex applications) it also means that your application is not married to the filesystem. Your framework pigeonholes developers into one way of doing things that cannot evolve along with an application: I cannot break my Apex framework application out into modules, or use third-party packages, which means if my application is even a little complex, Apex is a no go. &gt; Security -- Again, this will be going through a professional security audit by a reputable firm before any production systems are put online, but I don't forsee any issues there. I've been working in the crypto-currency market for over 5 years now, so know full well how brutal, skilled, and relentless hackers can be. The security audit may come up with some vulnerabilities, hence why we're getting it done, but I definitely don't expect anything disasterous. I'll be happy to publish the results of the security audit once it's complete. Security is very complex, it's a moving target, and requires serious considerations and eyeballs. You've shown above that you're willing to take a pass on easy wins for security (e.g: refusing the `public` webroot model) which indicates that the other decisions you're making probably aren't particularly good either. A security audit is a fantastic step but your framework audit will surface a number of fundamental issues, you'll save yourself time and money if you take the advice of people who've experienced all these issues before. There's no shame in doing the same thing everybody else is doing if it's what is best. For anybody to have confidence in your framework you need to take security seriously, hand-waving away valid criticisms because you're *going to be audited* is not a valid strategy for building confidence. How often are you going to be audited? Every time you release new code? Security has to be at the forefront of all the decisions you make, otherwise nobody is going to be able to use your framework with confidence. I think it's great that you've taken something from an idea to a working product and I commend the hard work, but you're being severely betrayed by what is either arrogance or foolishness. Frameworks like Laravel and Symfony have evolved over the last ~decade to meet the needs of a huge number of developers, and you're throwing away everything they've learned from millions of hours of developer time and saying "I know better". A smart developer isn't a developer who writes the most code, or writes the best code, a smart developer is a developer who knows *when* to write code, *what* code to write and when to defer to the work done by others. Your framework has potential simply by virtue of you being someone who has ideas and is clearly willing to work hard to build something, but your framework has no potential to expand beyond whoever you hold at metaphorical gunpoint if you're unwilling to learn from others. I don't have enough time right now to do an informal security review of your code but giving it a quick scan I can see a number of places where there are opportunities to probe which is a bad sign. My recommendation would be to take some time to look at what other applications are doing, learn from them, determine what you do and don't like, determine what they're doing right and wrong, determine how you can improve upon their work and do all that while losing the foolish belief you're better than every other developer who has contributed and used these frameworks: because you're not. Nobody is. Open source software is so successful and effective *because* it has so many different people contributing, each providing a small slice of expertise that creates a huge surface area for covering everything from user experience to security. You need to understand your own limitations and your own expertise and go from there; if you think the way that Laravel handles migrations sucks, you don't need to throw the entire framework away.
I faced the issue that the serializer groups annotations don't work with traits, idk if this was fixed already, but be aware that it might be a problem using the trait approach for entities
Why?
I didn't know that. I think it should have been fixed because the underlying annotation parser is the same (Doctrine annotations) and it should be its role to handle that. I'm not sure though.
If you’re taking this specific example yeah. I was hoping for people to grasp that the scope is actually broader than just this example. We use it to populate pretty much all of our templates and we wouldn’t want to be writing Twig extensions for every piece of data. I don’t disagree with you for getting access to a Twitter handle, but I would disagree if that were your solution for all data.
Well, I do actually like that concept, if your application allows for streaming the contents of the page right away, it’s a nice idea 👌
I used serializer group annotations on entity traits in Symfony 3.2+ already and it worked. Maybe something else was wrong?
Then maybe I should just try again, has been a while since the last time. Thanks for clarifying 
Why wouldn't you use traits? They are the best thing for this exact job. Traits are DRY, they are the "copy-paste-construct" that doesn't need you to extend classes or decorate stuff, but still allows you to implement interfaces cleanly. You can even declare abstract methods and force users of the trait implement them correctly. There are ways to use them wrong (e.g. using anything outside of the trait itself, like assuming the class the trait used on is of a specific type or contains specific methods), but that's the case for most programming constructs, when used right, they are absolutely great. The only thing that is lacking is to let them implement interfaces directly.
Yeah, annotations in comments are horrible idea, comments are never meant to affect the code. There are many problems with how annotations are implemented and used in userland, though right now I am focusing on the aspect of SRP violation/broken encapsulation. If PHP will ever implement annotations as a language feature, the 'annotations being comment' issue will go away, but the other problems will remain and need to be addressed. 
Why couldn't you just create a proxy API that starts by passing through all requests as-is to the legacy PHP API,, and then build out the new services to replace the old as you gradually switch the system over? 
Should also note which ones provide [stampede protection](https://en.wikipedia.org/wiki/Cache_stampede). Cache-Aside doesn't provide protection against this, but Read-through does. Write-through does, and write-behind might (basically depends on if the cache is invalidated by the storage or by the code).
I believe they are good, not just because most languages have them. There needs to be a way to provide more meta-information to a class, property, method more than input-types and output-types, as serialization, ORM, route-mapping etc. are very common patterns that exist in all major applications, and you surely don't want to duplicate most files in your application just to provide metadata. Surely, them being in DocBlocks and the sad IDE support for them don't make them look like a final solution and they aren't, but with an own syntax and optimized caching they can provide a lot to an application. I worked with all kinds of ORMs in many languages, including those that are mapped with e.g. config files. One the very specifically sticked to me surely was the EntityFramework of ASP.NET. For me, it has never been simpler to define entities and clearer what they represent. When I want to change something ("My product needs to save an UPC, too!"), I know exactly where I have to look, since there is just one Product, one entity that defines it's behavior fully. Same for controllers, looking at Laravel, when I'm searching for a specific route I have to follow whatever route naming pattern the programmers before me used and I may find "/product/{id}" in "routes/common.php". With annotations, I at least always have the information: "What URL leads to this specific action?", since they are directly above them. I don't have to constantly switch between two files to synchronize my action parameters. Annotations are a war between convenience and principle. And this, people, is PHP. Convenience has always been major in PHP while principle...not so much. There are a million theoretical reasons of why annotations are bad. And a very practical, really good one: They are easy to understand. They work as expected. They do what they tell you they do. Why would PHP be the first language that actually asks itself this question. Where have the big Microsoft developers been when it was the question if C# will get annotations (or "Attributes" there)? Where were the big Java-developers when it was in question if Java will get annotations? Where are all the JS-developers crying about decorators being standardized in JavaScript? Will it lead to all languages having annotations, but PHP doesn't? What makes it special in that matter? That you have more work to do the same thing, two files instead of one, 10 lines of code instead of 1, just for "breaking encapsulation" (which is really hard with meta data that is _defined_ as meta data) In the end, convenience will win, like it always was and always will. That's why Laravel is more popular than Symfony. They don't care about most patterns or principles, they use what is easy to understand, what is easy to apply. And that very much applies to annotations, too. Most reasons against annotations come down to PHP not having native ones.
I like the SoftDelete and Timestamp traits but not a big fan of having Sluggable mixed in with the EntityNameTrait. Having a sluggable name only makes sense in some contexts while having a name is very generic. 
\&gt; I've worked as a developer for 15 years, in cases like this you're usually better off starting from scratch, gather the (updated) requirements and rebuild I think that's the plan. The way I think to best handle it is to create a "proxy API" - basically, instead of the front-end hitting the legacy system, it now hits an API which routes all requests to the legacy system, and then as features are added or converted (using the new system), the routes get re-routed on a case by case basis. So if there was a GET endpoint called "/latest" you would write it out as: `app.get('*', (req, res) =&gt; request.get(LEGACY_URL_ROOT + req.url, req)` `.then((legacyResponse) =&gt; res.send(legacyResponse))` `}))` or somesuch. (with a similar one for POST/PUT requests). You'd simply put that at the end of the proxy server, and as you move items off the legacy server, you assign a new endpoint that catches before the default '\*' route resolves. 
I wish it was more of a thing! Its the only presentation about programming that I have ever found so funny. 
It’s not like there weren’t any solutions available for symfony previously. They’ve just not been in the base framework, which is alright since they mostly find usage in bigger applications
Why not? Docblocks are supposed to have documentation in them, hence the name. I’ve done it plenty of times, and it works pretty well. The only argument I’d have against it is that it seems out of scope for the tool. Just be sure to prefer the actual function signature if there’s a conflict with any annotations (and, preferably, emit a warning so the developer can fix it). Or stop wasting time with annotations when you can use proper types. 
I am afraid thats not how you define whether the entity cares about persistence logic or not, you dont know what you are talking about. I already gave an example, if you want to switch from one persistence mechanism to another, ie. from SQL tables to NoSQL documents, you have to go to the entity/business layer to change the annotations there. This makes your models/entities dependent on the persistence layer, a horrible idea for architectural design. Actually teams separated by layers is commonly practiced in large companies, whether or not they follow DDD or other architectures. Like it or not, thats the reality you have to deal with, and hence a very important reason why its necessary to make sure that changes in persistence layer will result in heavy modifications in the business/model layer. With annotations mixed in entity classes, it becomes very difficult, if not impossible. You want an example of tight coupling of models/business layer with persistence logic, you have one now. Oh yeah, so you have not encountered issues using doctrine in 6 years, and you dont see future changes in routing can be a problem, awesome. You sound just like that infamous Tony Marston, when people criticize that his uses of global variables, singletons, god classes, SRP violations can lead to issues in future development, his response is always 'I dont have that problem'. Yeah you dont have those problems now, doesnt mean the other people dont, and you may as well run into such problems later anyway. Seems you have only worked for one company and written only one application so far, so your biggest issue is lack of knowledge and experience. 
You don't have to use it, I was just pointing the usefulness of traits :) !
For example Laravel, Laravel uses over 1000+ classes. How is it not bloated?. But the alternative is simple, 2, 3 or even 10 classes and you are ready to go. You could slim Laravel but you are still using 200 - 500 classes.
I managed to achieve what I needed. It wasn't more than around 200 records so two loops did it. Out of curiosity what algorithm where you thinking of?
No worries. I was just pointing out one of the pitfalls I see with traits: that their scope is getting too big and classes get functionality added it doesn't need in the first place
Yes - more or less. Ended up looping over the array and just marking the one that was in more than one listings.
You are right, but ended up solving it before I came back to reddit. 
I did this recently. We deploy two types of packages, web applications and stuff run via crontab. I created a skeleton package for each type based on the work done in [zendframework/zend-expressive-skeleton](https://github.com/zendframework/zend-expressive-skeleton). Added them to our local satis builder and now use ``composer create-package`` to kickstart new projects.
 Thanks very much for the feedback, and I honestly appreciate you taking the time, and am soaking up all this feedback. Quite obviously, I've done a poor job keeping up with modern standards. Just recently turned 37, so think I'm getting a little too old for this software thing, plus was a little busy the last couple years figuring out how to be blind. That was a bit of an unexpected life change. I've taken everyone's advice into account, and have been hard at work implementing everything. Give me 2 or 3 more days, and I'll give this whole thing another try. I still think the base concept of Apex is excellent, but I just screwed up on the implmentation in several areas, but that's ok, learn from your own mistakes and all that jazz. Give me a few days and I'll upload to Github again. Will fully meet PRS-2 specifications, have a proper autoloader, Composer support, etc. Yes, I moved the index.php file into a separate /public/ directory, and actually totally revamped the entire directory structure. It should be a little more standard / familiar now, especially if you're used to LINUX based machines. I also flipped everything over to proper namespaces, and unsure why I wasn't doing that before. Always used namespaces back in my Perl days, but think when I flipped over to PHP it didn't support namespaces yet, then once they were added I guess I just never bothered with them. That wasn't very smart of me. Will also have dependency injection as well, mainly because as mattde pointed out, that's going to be an absolute requirement anyway when it comes to adding unit and functional tests to emulate the HTTP requests. Sorry, but I'm still not adding in database migrations, as I simply can't agree with that. Then you end up with a database filled with VARCHAR(255) columns that allow nulls when they shouldn't, there's no proper foreign key constraints or cascading, there\s a bunch of myIsam tables when they should be InnoDB, and so on. If people are that opposed to using SQL, then simply don't use Apex. Plus just having a install.sql file allows developers to get fancy if they'd like with database triggers, views, stored procedures, etc. I personally love database triggers especially for statistic / reporting tables, but on the fence if I will use them or not. The one issue I've had in the past is if you transfer the system over to another server and the mySQL username is different, you have to drop the triggers and recreate them under the new username, or the database will break. No, I like the hard-coded routing rules, and will keep those, but it's still quite flexible. For example, you could just create a new http_requests controller, and have every request that hits the /myapp/ URI routed to it, then you can do whatever you'd like with it and totally avoid the templating system if desired. For example, both /ajax/ and /repo/ avoid the templating engine and just give JSON responses only. Or you could just create a template, and go ahead and include any libraries / files you want, and do whatever you'd like with it. You are right though, Apex isn't quite as flexible as others out there, but that was intentional. This is designed specifically for standard online operations that consist of an administration panel, public web site, and member's area. If you're doing something like a trading bot or financial analysis tool, then Apex would be a bad choice. However, if you're doing something like a sports betting site where users can register, then login to place nd manage their bets, then Apex is a perfect choice. It's basically like Wordpress, but for professionals, or at least that's what I'm aiming for. And yes, you're totally correct with everything you said regarding both, security and general mindset in moving forward. Don't worry, by no means am I arrogant and closed minded, and I do actually listen. Give me a few days to try and clean up all my mistakes, I'll publish to Github again, and we can give this whole thing another go. I know I made several critical mistakes, and should have been keeping up with modern standards better. Nonetheless, I'm still confident the core concept of Apex is a good one. We'll see what happens. Thanks again, Matt PS. While I'm here, any standards for documentation I'm missing? Should I just add a /docs/ directory to the Github repo, fill it with .md files, and link to them from the main readme.md file? Or is there something else I should be doing? 
What's your point?
I guess it's meant for simple valiidation that comes from detached view/input (like parameter format) not bussiness rules. Although abusing them is also the part of not having control on the input... whatever. What irritates me is being dv for asking the most basic question I could. I've heard that statement couple of times and want to see what I'm missing in its logic. Maybe this statement wasn't suppose point to advantage of validation in annotations as I thought it was, but to not being *additionally* harmful. Which means if there is no SRP breaking with php validation, it won't happen with annotation meta programming (on top of the class with no behaviour). Btw. Nice post below. I remember reading about MVC on your website when I was learning couple years ago.
I was fiddling for a use case to meet the following criteria: 1. Limit the number of iterations per process 2. Repeat the iterator if it reaches its end before the set limit is reached 3. Ensure the iterator cannot be reused within the same process To meet all criteria, I came up with the snippet in the [3v4l.org](https://3v4l.org) post I linked. While this is solved cleanly with SPL iterators, I'm also quite self-aware about the deep nesting of iterators I did to get there. I would like to see your thoughts on how to improve this or if this is simply near the most clean solution I could implement, using only SPL iterators. I would love to hear your thoughts.
terrible idea...
Is this an assignment, or do you have some sort of use-case for this? There are other ways to tackle this problem. You could create an a custom iterator to prevent the nested iterators, for example. I just don't see the business case here, and it sounds like homework to me.
I had no patience to wait for a VM for the app... Is there any other method besides the Cloud Shell?
https://3v4l.org/vaBS7 You are right and I didn't know that. Thank you! I couldn't find that in the documentation anywhere either, it seems really stupid. I might set up an RFC for this if I can't find any. Do you have an idea why it behaves like this? Is there a reason or was it simply _forgotten_?
Please explain, it's always more interesting than assertive statements :) 
Be verbose and comment ~~liberally~~ moderately.
Well, what I really mean is "Be verbose and only comment when necessary", which is ultimately when doing something weird/out of the oridinary, or to explain why. 
lol
Better then rolling your own install? I haven’t messed with GCP in a good long time, but on AWS I usually just do it myself.
### [XPM](https://github.com/liamdemafelix/xpm) XPM, or the XAMPP Project Manager, is a lightweight GUI tool to manage virtual hosts for local projects. Simply put your project name, and check the options you need (supports Laravel virtual host templates), then with the help of a DNS proxy (like Acrylic DNS) you can access your local project through http://&lt;yourproject&gt;.local/ The tool is open source and is written in .NET. Simply install XAMPP, activate the services, Acrylic DNS and then install this tool. It'll configure everything else automatically. I've moved on to a different setup now (Laragon), but if you have any suggestions just create an issue in the tracker I'll be glad to take a look into it.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/liamdemafelix/xpm) - Previous text "XPM" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I understand, but this is just a simple guide, and to be honest i don't see the value of doing a unit test for an app that is for the purpose of demonstration. 
you can do `cp -R` too ;) the point is things should be as dynamic as possible so you don't do find replace later. enter templates.
Use the right tool for the job. If you need to do something that a protocol or library doesn’t support then don’t try to shoehorn it in.
I actually love this idea even if I actively avoid using traits in the codebase! 
Sorry, I follow TDD, I don’t write tests after the fact. 
It's definitely not homework. I'm trying to get a fresh approach on consuming an existing message que on a really bare bones k8s node where I'm trying to cut out the need to install vendor packages. As such I want to keep the code very lightweight. Possibly even without the need for autoloading or including other files to load up required parts of a small custom code base. It's been a really long time I've done anything like this, where I don't fire up an entire application built on top of a framework. The limit is to ensure memory leaks don't slow down this process. Having the no rewind logic may be a bit superfluous, because I can guarantee it's only going to be iterated once. FYI: this is not meant to consume from AMQP. We use more mainstream solutions for consuming those. That's as much of the use case that is interesting to this challenge ;-)
I am under the impression I posted this on /r/PHP 
Why do you want to use it? It sounds like it's not the right fit for your project.
So then even though their entire api is rest, then for this call you Just out it outside the rest of your code? Doesnt that seem “broken” of jsonapi?
The idea of a consistent api format for all our projects sounds amazing because then you can automaten more and have less code to write over and over. And everyone knows the format so you have less “improv”. Jos app seems like the only format to fix this issue so far, however in the real world sadly you have most of the times some exceptions like mentioned above. 
You can use `meta` for non-resources. And different content types are outside of the spec, you’ll have to improvise!
Google Calendar?
Sounds like only issue I think then yeah :). Good one, Thanks!
What?
That's fine for most use cases. But it is hard to achieve what GAE has to offer.
You can transfer files with base64 encoding, or a download url.
Pen and paper?
If your overall goal is to have a consistent API format, maybe you just need to go with a less restrictive spec. It might be more work, but that's the trade off. There's always the method of rolling your own in-house format, though I'd consider that a last last last resort.
That's a bullshit excuse, learn to value constructive criticism.
You might want to search here: [https://custom.simplemachines.org/mods/](https://custom.simplemachines.org/mods/)
I was talking with my friend just 5 minutes ago and we agreed on some aspects but we couldn't agree if there is a one size fits all set of criteria: licensing, code quality, PSR compliance, contributors, tests, ...?
 - does package do what I want to do - tests - pulse/issues - commit history - stars
Not in any particular order -- Tests (that they are there, and they cover most of the code) Github stars/issues/forks (a high number = lots of others use this) Of course what the package does (does it do what I need?) The quality of the code (I'll almost always have an indepth look around *) And quality/ease of use of documentation, if this is not a simple to use package. * although I'll test it first without checking anything, seeing if it does the job I need. Then if it does and I will continue to use it i'll check its source and make sure it looks ok to use.
licensing should be compatible with one that your project has (and all other conditions required by license). This isn't something that you can really skip and this shouldn't be part of this question. &gt; code quality How do you measure that? In my experience most of php packages has bad code quality, and some of them are just don't have alternative (take a look at SimpleSAML for example, it's useful and this is just trash) &gt; PSR compliance As far as this package ships as composer package I don't care. &gt; contributors What it shows to you? 
My criteria depends a lot things First I see if the package is not deprecated. Isn't a smart decision you choose a PHP package that was deprecated and just abandoned, the only, and must reason to choose a deprecated is just for if this package has something very specific to you where you can't find any others packages in the internet (which a something I think is very hard to be true). Second, the package can't have many issues opened for a long time, a package with many issues could be a normal thing, but, if we have a package with a lot issue opened for long time, could be a problematic for you. And it's could be a signal it will became abandoned and deprecated very soon. There's a lot reasons to this happens: missing contributors, the creator doesn't have a lot time to maintain the package and others reasons. Third, and I believe the one the most important criteria is if the package compatibility with another frameworks, any package should be compatible to workaround with any php tools. If any package it's just for a single framework, tool or anything like that it could be a little problematic too, could make you hostage of the framework and package itself. Liberty to change without breaking out my application is a critical criteria to me. I believe I don't want to rewrite any class or anything that using a package because I'm changing my stack. I believe for now, that I could remember this is my criteria. 
&gt; just a simple guide There are already documentation for both symfony and doctrine (and it's not Symfony ORM). This kind of "guides" could lead to incompetent developers who just copy paste things. It doesn't show anything about how to write software. I don't even understand what goals this guide could have (apart from misleading newcomers)
The create a modification link links me to a vague topic about a SDK thats in development a few years ago.. maybe im missing something but I dont really see how this topic helps me getting started. But thanks for the link anyway!
&gt;I don't even understand what goals this guide could have (apart from misleading newcomers) It's all about self-promotion.
didn't work lol
Some recommendations? 
What others said plus the list of dependencies needs to be sane. I don't want libraries pulling in a whole bunch of other stuff I never wanted. 
Thanks for the detailed feedback :) ! Here are my answers, please note that even if I may seem a bit assertive without noticing, I like the discussion! 1/ when I said to compose, I am not talking about OOP composition. I'm using the English verb meaning "to arrange in an orderly form", ie. to rely on traits to declare code as "copy-paste", as you said. 2/ I would like it if you could elaborate how defining two properties and two getters in a trait is a symptom of bad decomposition. 3/ I don't do this to write less code, I do it to *read* less code. When I read EntityIdTrait, I know precisely what there is inside, mostly because it's used in most entities (otherwise, I don't create a trait). Having a single line of code for this let me focus much better on the rest of the entity: the important properties which are *actually* specific to this entity. It does make things much simpler to read, by limiting the amount of code to read while still having the same amount of information. 4/ you need to watch for unwanted side effect in every single link between classes, it's not specific to traits, I don't see why this would be a problem. 5/ I feel like you have a preconceived opinion about traits being bad, because they can be badly used (and in many cases, they are, you are right). However, I am almost certain the usage I shown in my article is basically what traits were made for: sharing bits of code between classes. 6/ traits does not have *anything* to do with how you write rich entities or not. If you want to have business logic methods inside your entities, that's fine, but using traits is not related to this. More generally speaking, I like the idea of entities describing your business domain. I usually tries to do it as much as possible, but there are huge limitations to this approach. If you want to discuss it, don't hesitate to continue the debate, I can detail my opinion :) .
Jason Fried Q&amp;A was awesome 
Why are the topics of the talks not part of the video title? Would be someone so nice and link my a list of the topics, so I can see what I want to watch in the first place?
Hell yeah. Uncle bob is great, as always 
I joined Google App Engine when it was for free. However, Google switch from free to uber-expensive. Also, I never liked its restrictions.
I'm wondering the same right now, I have to play the video to know what it is about, I'm going to watch almost all of them anyway but not everyone have the time for that. 