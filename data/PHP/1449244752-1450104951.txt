Im seriously worried about that normal productions, and worried for you if you really think like that :D
(if you're using the right contrived benchmark programs, anyway ;)
[PHP 7 Compatibility Checker](https://github.com/sstalle/php7cc) Please also note: &gt; Although php7cc tries to detect as much problems as accurately as possible, sometimes 100% reliable detection is very hard to achieve. That's why you should also run a comprehensive test suite for the code you are going to migrate.
I'm sorry I don't understand, can you elaborate? I'm not using phpmyadmin but something similar (0xDBE), but this has nothing to do with managing schema and/or migrations in code, automated, versioned, etc.?
Can you share the command you used to install php 7 alongside php 5 on CentOS? I assume you enabled the remi-php70-repo and then ran: yum install php70*
[**@spinx**](https://twitter.com/spinx/) &gt; [2015-12-04 11:58 UTC](https://twitter.com/spinx/status/672746861346856960) &gt; Celebrating @php\_net 7 release and @symfony 3 release at @dlabs\_si üôåüç∞üéâüéâ &gt;[[Attached pic]](http://pbs.twimg.com/media/CVYTsvIW4AEVKWe.jpg) [[Imgur rehost]](http://i.imgur.com/l68c98c.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
For managing schema, yes but for the rest perhaps not
I thought PHP 5 was faster than Python 3 and Ruby too, am I missing something here? Why comparing PHP 7 to Python 3 if the old PHP already outspeeds it? 
As others have said - static analysis will catch them, but a well designed test suite will as well. A well designed test suite will run through each possible interaction with the system, including any error paths, so if your test suite is comprehensive enough, every line of code will get exercised and perform as expected. No one test suite can do this, the total coverage is often split between unit tests and integration tests.
PHP's `/` is not integer division, no. It's coercing the operands to floats before evaluating, unless the left operand is integer 0 and the right operand is nonzero. In that case, the output is an integer. My point is that in PHP, dividing by zero is a special snowflake. Here's a table of the outputs of various divisions in other langs: | php5 | php7 | python 3 | ruby | c# | C | Excel | PostgreSQL ---|---|----|----|----|----|----|----|---- 2/3 | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0 (int) | 0 (int) | 0 | 0.666666667 | 0 (int) 2.0/3 | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666666667 | 0.666 rpt. 2/3.0 | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666666667 | 0.666 rpt. 2.0/3.0 | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666 rpt. | 0.666666667 | 0.666 rpt. 3/2 | 1.5 | 1.5 | 1.5 | 1 | 1 (int) | 1 | 1.5 | 1 3.0/2 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 3/2.0 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 3.0/2.0 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 | 1.5 1/0 | false | INF | (error) | (error) | (error) | (error) | #DIV/0! | (error) 1.0/0 | false | INF | (error) | Infinity | Infinity | inf | #DIV/0! | (error) 1/0.0 | false | INF | (error) | Infinity | Infinity | inf | #DIV/0! | (error) 1.0/0.0 | false | INF | (error) | Infinity | Infinity | inf | #DIV/0! | (error) 0/1 | 0 (int) | 0 (int) | 0.0 (float) | 0 | 0 (int) | 0 (int) | 0 | 0 0.0/1 | 0 (float) | 0 (float) | 0.0 (float) | 0.0 | 0 (double) | 0 (float) | 0 | 0 (numeric) 0/0 | false | NAN | (error) | (error) | (error) | (error) | #DIV/0! | (error) 0.0/0 | false | NAN | (error) | NaN | NaN | nan | #DIV/0! | (error) 0/0.0 | false | NAN | (error) | NaN | NaN | nan | #DIV/0! | (error) 
It was, but people are used to hear only bad things about php. So every post about new release will educate more people.
Sad enough that people tend to leave out tests. Because on these occasions it would save the most time. I am nowhere near perfect, yet I try to write my tests. I even estimate for them since the time doesn't get added here... And my colleagues stare at me once I have pushed a feature with a test, probably the same way I look at them when they don't...
Lots of cheapy hosts are upgrading too http://phpversions.info/php-7/ Just pointing out this isn't the 4 -&gt; 5 debacle, nor is it the 5.3 -&gt; 5.4 shit. Since then many hosts have got a _lot_ better at upgrading quickly. 
Good guess, Professor Guessington! =D
All of the PHP 6 non-unicode features were ported back to 5.3, the [decision to kill 6](http://news.php.net/php.internals/47120) however was made during the 5.4 ramp up; and this interview happened during the 5.4 RC phase.
You can't, unless you explicitly added tests in all possible places to cover all known changes. That works if you have maybe three classes or so. It's a great leading indicator, but almost certainly not 100%
Oh, so someone could fork them to 7fony and 7end and ... 7aravel :-)
Hi! Author here. Just as a heads up, php7ize is more of a conversion tool than one for analysis. And mostly for scalar type hints and return types at that. I probably should go back and add more though...
They should really just discover this "complex concept" called LTS. You know, it kinda works... kinda... Only few linux distros use it... Oh, and also major frameworks! 
docker
The remi-php70 repo will replace the system php. The remi-safe repo provides php 7 as an scl prefixed with php70. 
So what happens if another request comes in without the previous request finishing?
Wouldn't be the first time for a fork, but I've never heard of any forks actually going anywhere.
I do, and i love it. More experienced in PHP, so i might miss some things in the whole python 2.x vs 3.x discussion
First I installed remi's repo (note this is the RHEL/CentOS 6 one): `wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm` (Others available at http://rpms.famillecollet.com/) `rpm -Uvh remi-release-6.rpm` Then I got a list of all my currently installed php56 packages: `rpm -qa | grep php56` Mine were all in the format "php56u-blah", e.g. "php56u-pdo". I then changed "php56u" to "php70-php" in all of those and made a string of the result. (I used copy &amp; paste and a bit of excel manipulation, I'm not all that with bash!) Then ran this to install them all: `yum install php70 php70-php-pdo php70-php-mbstring`... etc etc. Set it to start automatically on reboot: `chkconfig php70 on` 
Really? Where can I find that repo? I have the "remi-release" repo and it installed it the SCL way. 
travis is your best option in my opinion. create unit testing and make sure they pass on php5, then execute php7
We all know that, but we don't say it loud out because /r/python can get their feelings hurts. php better than python 
thats first world problem to me. i have some projects stuck in php5.3 and yii1.1
I thought programmers were the cause of software vulnerabilities.
How different is it from fastcgi+php-fpm+apc/opcache? You've still got a long running process waiting for requests from the web server and scripts stay in memory.
On mobile so short answer here, but that's kind of just the nature of databases. Unlike source code, they don't really exist at a single point in time. When you migrate prod, you don't check out a new database and start over, you migrate the existing data. The starting point and patches approach is the procedure to make it happen. The tools to make it easy definitely vary wildly in quality though. What I've found to be a good balance of reliable and easy is a schema changes table and a small script to run any changes not listed in that table - just make sure it maintains the correct order. Some tools use more magic, but that's a lot scarier once you have real prod data and have customers and uptime requirements. 
Can you elaborate on what kind of information you want to display? Are you talking full-blown template HTML, or wrapping HTML like tables, lists, etc.? One example I can think of off the top of my head is [Laravel's Pagination](https://github.com/laravel/framework/tree/5.1/src/Illuminate/Pagination), which offers a Presenter layer and comes default with a Bootstrap compatible implementation. Easily replaced by your own if you need to, which can include anything from hardcoding your own HTML to tying in with a template library such as Twig.
Works just fine from everything I've heard and seen
I'm not entirely sure how some of these functions are especially helpful... //Returns true if value is true Funct\true(false); // =&gt; false //returns true if value is null Funct\null('fooBar'); // =&gt; false //returns true if value is true Funct\true(false); // =&gt; false //returns true if var is not empty Funct\notEmpty('fooBar'); // =&gt; true 
yeah i've been getting up to speed with the terminology i guess what i'm looking for at the top of the list is "Building a Content Management System (CMS)" thing is i'm not too sure to get a template or just build my own after i look at some lynda tutorials 
after looking around CMS is what i need but i'm not sure to get a template or build my own, (i'm not sure if it makes a difference if i already had the master "main" webpage that they gave me it's all styled and java scripted and all)
Have you any experience with working with mysql databases and php before? 
This was [posted just a couple days ago](https://www.reddit.com/r/PHP/comments/3v4zba/php_funct_the_first_stable_release_an/), FYI.
I'll rephrase that WordPress Core runs just fine, with default themes. 3rd party code has no guarantee.
I took the bait, but against all odds it seems that sanity has prevailed - the highest ranking comments are reasonable and in some cases, positive!
It would read a bit more nicely.
You might be joking but you're confusing sleep and usleep :P
If Scott's too sketchy for you, you can also get an equivalent to this file from the official PHP 7.0.0 tarball: pear/install-pear-nozlib.phar will also install a working PEAR environment. Here's a one liner that will get you the file: curl -L https://secure.php.net/get/php-7.0.0.tar.xz/from/this/mirror | tar -Jxv php-7.0.0/pear/install-pear-nozlib.phar --strip-components=2 Then, if you want to install into your default PHP's lib/php/pear and bin directories, you can just run it: php install-pear-nozlib.phar You can also control the directories it installs to with -d (to change where the local PEAR libraries will live) and -b (to change where the pear, peardev and pecl command line scripts get installed to).
&gt; Or maybe just stop trying to do the thing the warning says not to do.- Are you not understanding the issue or do you just not understand object oriented programming? The whole point of private members is that I can add/remove/change them without affecting anything outside of my own class. If I maintain a class that 50 people extend I should be able to change the private methods of my class to my heart's content without (assuming I don't change the interface or externally observable behaviour) affecting the code of the people who extend my class. Except with this warning I can't do that. If I **happen** to add a private method that shares a name but not signature with a method one of them has added to one of the classes that extends my class then their code will now output warnings. So what's the correct way to write/maintain code that will be extended? Don't use private methods? Don't add private methods? Somehow comb through all the code that extends a class before adding a **private** method to it? &gt;Then don't display errors to your screen? That's the sane thing to do anyway. Just have the errors write to a log file. Again, do you not understand the issue? Warnings are supposed to warn you about code that's highly suspect and that you probably don't want to (or didn't intend to) write. So what's the purpose of this warning? To discourage encapsulation? To encourage people to comb through the implementation of classes before they extend them (that kind of defeats the purpose of encapsulation, doesn't it?)? To encourage people who write non-final classes to comb through every single derived class before making a change to the base class? The only behaviour this warning encourages is anathema to object oriented programming. It's not designed to inform the programmer about unexpected or unintended behaviours, its only possible purpose is to ruin a core tenet of object oriented programming: Private implementation details don't affect consumers of your class. And as far as I can tell unlike with something like GCC there's no way to disable just this one warning, so you have to disable **all** warnings, which is questionable as well. Sure, don't display the warnings to the screen, send them somewhere else. But are you actually going to look through them if they're not in your face during development? How much development time does it add checking that log file? Are you really going to consistently see **real** warnings in among all these spurious warnings that get generated every page refresh/run through your test suite or is the entire thing going to become noise?
it's not unpaid , but i've been after them for a while and they don't want inexperienced programmers and so they offered me to try doing this website (and they said they will pay me ) but more importantly this is cement my position there and if i can't do it i need to tell them ahead of time so their deadline with the client is met but i didn't show any signs that i couldn't do this 
Probably worth remembering that a lot of people who work on PHP are guys/gals doing it in their spare time. Myself included!
If this is something that upsets you to this point, then email the PHP internals list and propose making private methods truly invisible to child classes so the code you posted will not generate a warning. For what it's worth, the reason this is E_WARNING in PHP 7 is because E_STRICT no longer exists, see https://wiki.php.net/rfc/reclassify_e_strict. 
Interesting... although I immediately have performance concerns about running a mongo client from interpreted PHP instead of a C extension. I'll give it a try and see how it fares, thanks.
I think this is a valid question, so I'm not sure why you're being downvoted. I worked at a shop that did some small projects in Python and one that was a pure Python shop. Both of them refused to upgrade to 3.3 (or are we on 3.4 now?) and we're perfectly content to remain in 2.7 seemingly forever. I've never personally migrated a project from 2 to 3, but some people make it out to be the most frightening thing ever. I don't get it.
That's essentially what the phalcon framwork does too (running as a php extension in memory). Pretty fast too.
I thought so. Python 3 created a lot of issues that broke a lot of apps that were already created in Python 2.x from my understanding.
usleep, isleep, we all sleep!
7 years bad, though? I have to imagine that the difficulties were probably a bit overstated. 
sure, looks good so far. here is another one http://www.linxiang.info/l5-cs/ 
I wonder what their speed on PHP7 will be. 
I'd highly recommend using [phpbrew](https://github.com/phpbrew/phpbrew).
I have to believe they'd change that if they honestly could, but can't because: Back compat.
Honestly, no. However, that doesn't mean others wouldn't find it beneficial. It just doesn't fall into how I find information when I need it. Always nice to see contributions to the community, though!
Ruby is dumb slow. I don't know why anyone would start a new project with Ruby.
Have a visit in /r/lolphp and re-read your post
 function play() { $player1 = 0; $player2 = 0; $round = 0; while ($player1 &lt; 2 &amp;&amp; $player2 &lt; 2) { // 1 = rock, 2 = paper, 3 = scissors $p1_turn = rand(1,3); $p2_turn = rand(1,3); if (($p1_turn === 1 &amp;&amp; $p2_turn === 3) || ($p1_turn === 2 &amp;&amp; $p2_turn === 1) || ($p1_turn === 3 &amp;&amp; $p2_turn === 2)) { echo 'Player 1 wins round ' . $round; $player1++; $round++; } else if (($p2_turn === 1 &amp;&amp; $p1_turn === 3) || ($p2_turn === 2 &amp;&amp; $p1_turn === 1) || ($p2_turn === 3 &amp;&amp; $p1_turn === 2)) { echo 'Player 2 wins round ' . $round; $player2++; $round++; } else { continue; } } if ($player1 === 2) { echo 'Player 1 wins the game!'; } else { echo 'Player 2 wins the game!'; } } play(); This is more than helping you, but if you already had something done you can compare it to this. I never tested this or anything, but I assume it works.
An untyped array is currently `array`, not `mixed[]` or something. Why change the syntax when it's a typed array? It's weird that an array of arrays would be `array[]`, too. Compare that to the angle bracket syntax: array | array int[] | array&lt;int&gt; array[] | array&lt;array&gt; int[][] | array&lt;array&lt;int&gt;&gt; Now that I think about it, there's also the problem that `[]` would conflict with the `?` nullable type syntax, if that ever got in. Is `?int[]` either null or array of integers, or an array of integers or nulls? Heck, this problem exists for union types too: `int|null[]`. But there's no ambiguity for the angle bracket syntax: `array&lt;?int&gt;` or `array&lt;int|null&gt;`, `?array&lt;int&gt;` or `array&lt;int&gt;|null`.
&gt; BC breaks require change in the code. (/me continues pondering) I suppose in a narrow sense, that's true. At the same time, it's a break in the continuity of the package being released; I think it's reasonable to expect to be able to use a minor release without having to upgrade one's PHP version. It strikes me as being worthy of a major version bump. EDIT: &gt; if they don't solve their dependency conflicts This is the part that eats at me. It's not *their* dependency conflict, it's a conflict that has been purposely introduced by the package maintainer. Still seems like it needs a major version bump.
&gt; I don't believe that anyone has previously suggested these toy programs were contrived to make PHP look fast ! :-) I'm not claiming they were created specifically to make PHP look fast. They're contrived because they don't measure real-world application performance.
Great, because Python3 uptake took no time at all...
WordPress runs on PHP 7, but some of the ecosystem stuff (themes, plugins) might not.
&gt; The focus on abstraction correctness and decoupling at the cost of bootstrapping a complex application structure on every request is out of control. Hey, I'm a little slow. Could you ELI5 what you mean by that. What could the frameworks do differently?
Mmm case insensitive sleeping.
If all you mean is that those [toy benchmark programs](http://benchmarksgame.alioth.debian.org/why-measure-toy-benchmark-programs.html) are not "real-world applications" (whatever that means to you) then "contrived" suggests lots of other things that you say you don't mean. (Incidentally, they don't measure anything at all -- they are the things that are measured.)
The general rule of programming is that if you need it to run faster, remove an abstraction layer; if you need to be able to build it faster, add one. It's certainly hard to find a good balance, especially if you don't know your exact needs ahead of time (and in the real world, nobody ever does)
Yes, but the opcache does take away a pretty significant amount of the cost. It's not on the same level, but you can push PHP applications *really* far before the process model or the language itself is your performance barrier. If it's sitting behind any sort of HTTP stack, the network will kill you no matter what (I've seen firsthand speedups ranging 10-500x by eliminating it)
Give it a week.
There is no such thing as learning fast. It takes time. If you're in, then be in it for the long haul. If not, find another interest.
Added notes: you'd have a hell of a time getting every single WP site (25% of the internet) out there to get a plugin installed for this "legacy" API and then also get every single plugin and theme to migrate away from the legacy API and learn a completely new one. 
&gt; So multiple requests only result in one instance in memory? Yep, pretty much every other modern non-PHP web language does it this way. Bootstrapping (eg. processing/optimizing the routing rules, loading core framework stuff, etc) is only done once at startup, not every single time a request comes in. You can have multiple instances and load balance between them if you need to scale out further.
&gt; Added notes: you'd have a hell of a time getting every single WP site (25% of the internet) out there to get a plugin installed for this "legacy" API and then also get every single plugin and theme to migrate away from the legacy API and learn a completely new one. That's not how change management is done. Here's how it's done: 1. You internally refactor the old API to call into the new API. No BC breaks. 2. Still in the 3.x series, you move the legacy API into a plugin, which comes with WordPress by default. Plugins don't have to change anything. No BC breaks. 3. Later in the 3.x series, you deprecate the legacy API plugin, plugins still work fine, but there's a small note in the admin when you use a legacy-dependent plugin. No BC breaks. 4. In 4.x series you make the legacy API plugin an optional plugin that legacy plugins will require. No BC breaks, but a legacy plugin will have to install the legacy shim. This process can be automated, where a plugin declares in a single call that it's a legacy plugin and WP automates the rest, so the user doesn't have to install the shim manually. 5. In 5.x series you stop supporting the legacy plugin, and if someone wants to unofficially maintain it, whatever. It's an open source project. There's no such situation where "every single plugin" has to "completely move" to something. It's a very gradual and natural process, where everyone can move at their own pace. There will likely be a period when plugins are using a mix of the new and old APIs too, that's fine. The important part is that to get rid of legacy you should *always* be moving forward in that process above, even if you're moving *slowly*. Is WordPress moving forward? Even slowly? No. They're just giving excuses and their fans support them out of ignorance. BTW, WordPress already does little BC breaks in every release, or it wouldn't be the case plugins have to be tested for a specific X.Y.Z version to know they'll work. If BC was truly maintained, they'd work without there being tests for such minor releases. Truth is you can't know they work because the API is a mess and plugins routinely bypass it, read and write to the database and so on. This wouldn't happen in any well encapsulated API.
&gt; Reading is like .00001 of what it really takes to be a good programmer in any language. You mean like a book, because reading through production code is quite edifying.
You're the one defending non-existent change management, so you're the one I'm reacting to. I don't work with WP, I took just one small project couple of weeks ago, as a favor (which I regret) and I guess the Stockholm syndrome hasn't kicked in yet. WP *can* be awesome, but cultural problems are much harder to solve than technical ones. 
I'm going to give this a shot: You know how in ms word, hitting file &gt;new is faster than reopening the whole program? Frameworks are kind of like that. Everything gets initialized during every request. There are some caching shortcuts taken, but the kitchen sink gets loaded from scratch on each page load.
&gt; check out the stack traces Doubt it's worse than Java. :&gt;
My bets are when the REST API is completely integrated, a good portion of the legacy cruft will be able to be avoided right away for those who want to. I'm also stating what I've seen said in the past from others who have proposed such changes already. As shitty as it can be to say, especially to those passionate about modern practices, they're not going to refactor for refactoring sake. 99% of the modern PHP features are "nice to haves" and not "need to haves"
*"Ask not what PHP can implement for you ‚Äì ask what you can implement in PHP."* ~John F. Kennedy Loop with first and last: loop([1, 2, 3], function($item, $first, $last) { if ($first) var_dump('First'); var_dump($item); if ($last) var_dump('Last'); }); Output: string(5) "First" int(1) int(2) int(3) string(4) "Last" Implementation: function loop($items, $handler) { reset($items); $kFirst = key($items); end($items); $kLast = key($items); foreach ($items as $k =&gt; $v) { $handler($v, $k === $kFirst, $k === $kLast); } }
&gt; My bets are when the REST API is completely integrated, a good portion of the legacy cruft will be able to be avoided right away for those who want to. Nope, because plugins. If you reduce WP just to its core, it'd lose about 90% of its audience and I'm being generous here. WP is used as a makeshift CMS for a lot of websites, and if you take away custom themes, posts, taxonomies, shortcodes, plugins etc., which can't work over REST, then it can't work as a CMS. Which... hmm. Well I guess I'd be fine with that, as I won't have to have another "why not just use WordPress" conversation with clients. &gt; I'm also stating what I've seen said in the past from others who have proposed such changes already. As shitty as it can be to say, especially to those passionate about modern practices, they're not going to refactor for refactoring sake. 99% of the modern PHP features are "nice to haves" and not "need to haves" A lot of what WP does was a bad practice in the PHP 4 days as well, so framing it as if a bunch of namespace enthusiasts are whining about more fancy PHP features in WP is to misunderstand the problem. Sure, some people frame it like "WP should be modern" as they simply associate a set of sane design practices with "modern code". But honestly you can take the PHP 4 featureset and do a much better job than WP is doing today.
Ugh yeah, simple requests easily pass 60+ function calls. It is kind of out of hand.
Wow they are really dedicated to hating php. Well, as long as they enjoy it I guess.
Since you're using a desktop OS I guess this is your development machine - in which case you should be using a development environment in Docker, Vagrant or similar.
Yes, true. For frameworks, I think the "build faster" bit comes if the framework has a good set of APIs. What happens under that API surface, should be of no concern to the users, and where all the dirty things associated with performance should happen. It's very tricky though especially for frameworks that have lots of contributors. Although it's possible if we confine the tests of correctness just to that API surface.
Most other web architectures work that way - Nodejs, Java, .Net etc. Pardon my PHP hate but it's the most ancient technology still kept alive by the people who don't wanna move on. I'd be amazed if PHP guys didn't already know this (lots of similar questions ITT), but I'm guessing you're a newbie. 
Lumen might be what you are looking for
I don't think WordPress has to do what Drupal did. I think they should release version 5 build from scratch build on Symfony and break all backwards compatibility. Now, when when I say from scratch I don't mean that release 5.0 should have every single feature that version 4 has in it. They should start with the simplest possible version and iterate fast. The version 4 and 5 branches can coexist for a certain amount of time and once the 5 branch has really taken of (I suspect a year or two, maybe 3) phase out the 4 branch. Maybe they shouldn't even call the 5 branch "WordPress".. 
Have you used Drupal 7? It had an insanely high number of function calls. IIRC, it was in or above the 5 digits range.
Too bad there is people around here that doesn't want to learn, they just want to take advantage of people around here.
I meant reading a book. I mean it's a good start, but you won't really learn anything until you start coding, even if it's a simple hello world project. This is not to mean you shouldn't read books or magazines or blogs, learning is important. But without practical experience you won't understand what are good coding practices and why, and what are bad coding practices.
I ran [my own benchmarks](http://www.syntheticminds.co.uk/blog/is-php-now-suitable-for-machine-learning.html) just before 7's release. PHP 5 was already faster than Python 3, which itself is slower than its predecessor.
If you use a intermediate variable, you may also type hint using a @var comment, it works in several IDEs : /* @var $object ClassName */ $object = app()-&gt;make(...); It works wonders in your templates if you use PHP as a template engine : you get completion for your injected vars
The mistake you are making is that you think that because your use case is useful to it MUST BE THE ONE TRUE WAY OF DOING THING!!!ONE!!! &gt; So what's the purpose of this warning? To discourage encapsulation? It's to encourage people to stop writing shitty code that depends on quirks in the language. Overloading the signature of a function is just bogus, as it makes thinking about how code is going to behave be really fucking confusing. Even without changing the parameters in the function, changing it from private to public is bad enough. Look at this code: &lt;?php class A { private function foo() {} } class B extends A { function test() { $reflMethod = new ReflectionMethod($this, 'foo'); echo "Method foo is private: ".var_export($reflMethod-&gt;isPrivate(), true); } } class C extends B { public function foo() {} } $b = new B(); $b-&gt;test(); $c = new C(); $c-&gt;test(); The output is: Method foo is private: true Method foo is private: false That's crazy. And any code that is written like that is crazy. &gt; Private implementation details don't affect consumers of your class. But a class extending another class isn't a consumer of the class, it's modifying it. Perhaps you should be using composition here? &gt; So what's the correct way to write/maintain code that will be extended? Don't use private methods? Don't abuse the language, and then especially don't whine when ten years later the warning message is increased from "that's not the best idea" to "please, stahp".
Yeah, my interview test for my current job was to write a console version of Rock Paper Sizors Lizard Spock with Unit Testing. We just hired someone. I feel suspicious...
PHP has had lambdas since 5.3. http://php.net/manual/en/functions.anonymous.php
Wordpress's biggest base is people who can't program or have limited skills. If you spend a huge effort to rebuild Wordpress and just end up back with the same or less functionality, then that base is not going to give a shit. They won't see any difference. 
&gt;it makes thinking about how code is going to behave be really fucking confusing How? To who? When you're writing a derived class you don't think about the implementation details of the base class unless you're doing object oriented programming wrong. When you're writing a base class you don't think about the details of the derived class unless you're doing object oriented programming wrong. This warning -- not the code I showed in my original post -- makes thinking about code "*really fucking confusing*" since each time you create a public method in a derived class you have to make sure it doesn't conflict with a **private** method in the base class, and every time you add/change a private method in a base class you have to check every derived class to make sure none of them have a conflicting public or protected method. This reaches even more extreme levels of insanity if you write/maintain a base class that's used outside your code base. Now you have to figure out which code bases use your class and check each and every one of them to make sure there's no conflict, and if you maintain an open source project this might not even be possible since you may not even know all the users of your class. The ability to hide implementation details so they're invisible to consumers of classes is one of the compelling arguments for object oriented programming. This warning completely negates that by making implementation details of base classes of concern to derived classes. &gt;It's to encourage people to stop writing shitty code that depends on quirks in the language. You rail against "*shitty code*" and then use **reflection** to support your argument. Come on... &gt;Don't abuse the language Don't make excuses for PHP.
I'm talking about [Aerys](https://github.com/amphp/aerys). ;-)
You can't compare a framework to Java. You'd have to compare it to Spring or similar framework.
I doubt anyone will be running that when it hasn't even had a beta release yet
&gt;Yep, pretty much every other modern non-PHP web language does it this way. Bootstrapping (eg. processing/optimizing the routing rules, loading core framework stuff, etc) is only done once at startup, not every single time a request comes in. I thought RoR worked the same way. The only time you wouldn't need to bootstrap everything was if you were using an application server like Tomcat or whatever Python uses instead of a web server like apache or nginx. 
There were probably a dramatic handful of changes that would affect most users. Most are relatively simple changes, but so common there might be a lot of them. Plus some of the latent issues you wouldn't discover unless you had a rigorous test suite. Probably more importantly is that a lot of libraries broke with the upgrade. However, as already mentioned: it's been a long time, those libraries have a been updated, and they even provide tools to help with the migration (the \_\_future\_\_ module and 2to3 for example). So it's certainly pretty serious, but not awful. And it only applies to projects started before Python 3 came out (or at least got support from libraries)
This also doesn't take python's natively supported threading into regard. I mean sure, a single process might be faster when doing pure computation but that's rarely the bottleneck in most production environments.
You can write insecure code in every language. With php it's easier. If ruby/python would be as popular as php, we'd see as many complains about them.
I meant hack lambda expressions ($x) ==&gt; $x + 1;
Yes of course. That doesn't solve the travis problem though.
Same, especially with LTS support.
I already fixed the problem, thanks anyway !
 $barney = "A big purple dinosaur."; session_register("barney"); =&gt; $_SESSION["barney"] = "A big purple dinosaur."; from http://php.net/manual/en/function.session-register.php
Reading the docs it says: &gt; [cache-files-maxsize](https://getcomposer.org/doc/06-config.md#cache-files-maxsize)# &gt;Defaults to 300MiB. Composer caches all dist (zip, tar, ..) packages that it downloads. When the garbage collection is periodically ran, this is the maximum size the cache will be able to use. Older (less used) files will be removed first until the cache fits. Maybe it's getting full some how?
My god your autism is hilarious. 10/10 would read again.
Sure, it's a new way and it will need some more time until it's totally stable, but it already runs on https://dev.kelunik.com for more than a year now.
so... you are saying that a JUNIOR php developer in ukraine earns more than one in france or italy, when the minimum salary in the ukraine is less than 200$ per month?
Use isset() instead. 
Mb is megabit, MiB is mebibyte. This is extremely well established, and to use other forms is just breaking an extension of the metric system. While well intentioned, your suggestion is based around misinformation. 
In particular, returning from yield was not possible, making it impossible to implement coroutines. For example '$foo = (yield)'
Hopefully you can get out of 5.4 and into 5.6. 
You should give 3.11 a try when it comes out next week, I think we fixed a few issues around this when we were doing generator returns and generator delegation for PHP7. (Along with the aforementioned generator priming, which was one of our major differences to PHP's generators.)
Holy cow that site has really changed since I last saw it.
ok run your phpunit loclly till your code pass all your tests. then create the travis.yml file and make a commit. if you fail travis will let you know and you can push again :) 
I think you don't know what autism is. Ignored.
It's spam, just look at the account's [submission history](https://www.reddit.com/user/bling1bling/submitted/).
Sorry for the late response but you solved my issue, thanks so much man!
It's both. Theoretically you can safely handle planks of wood with nails sticking out of it at random locations by applying appropriate care and wearing thick leather gloves and whatnot, but you'd generally expect there to be a better safety record if the nails always poke out the same way from the same place, yeah? And wood planks with no nails sticking out at all can be safely handled without any safety equipment and minimal care. You can argue it's always the handlers fault for getting hurt or hurting others, but that doesn't mean the product can't be more prone to accident and less forgiving to users.
In the first place, you should never do such a thing. 
hey sir, does it matter if they master page they gave me is made with bootstrap,,, yesterday i created the self contained "Contact us form" page i never worked with bootstrap before, took me a while to do some styling 
Looking at his profile activity, he's just spamming. Probably just trying to get traffic to his blog.
&gt; I wonder how that would even work in PHP. Well it sort of subverts the original way PHP was meant to be written (The Apache/mod_php way), but you'd have a server that takes in HTTP requests in the front, generates the right response in the process, sends back the response and returns to the initial state. This single process, on startup, runs all relevant setup needed and optimizes the routing tables or whatever else it can do to get the responses out faster. This process is generally called a worker, and generally you make more than one and get 'the workers'. All the workers are not facing the public internet, but rather sit behind some kind of manager and/or load balancer. In a simple example you might have website that doesn't rely on anything in a process to generate the right results (If you're only hitting the database to get the state needed to generate the right output for the request, for example, you're in this category) so it doesn't matter if a user gets the same worker from one request to the next, and you might have a web service that doesn't have any requests that are that heavy or that would take that long to service, so you can get away with not having intelligent load balancing. In that sort of case you can just have, say, 4 worker processes behind nginx, and nginx does round-robing load balancing just handing each request to the next worker on the list, and going to the front of the list when the last one on the list got a request. nginx is made to be really good at handling these proxying requests and it delivers; odds are good you can stick to just having nginx take in all public requests and it'll be able to keep up even with a huge number of requests. If the workers get overloaded you just add more worker processes and update the routing info in nginx. (nginx can reload that without downtime.) Now you can scale up and down seamlessly without clients knowing anything's happened. What if you want to update the code the workers are using? If there are no special concerns relating to a client getting a different version of the website from one request to the next in the same session just spawn a new worker with the new code, update the routing to replace one of the old workers, kill the old worker. Repeat until all workers are on the new version. Application servers generally handle all the admin I described there for you, or at least a lot of it. They can be configured to do the scaling for you and updating and whatnot. This setup doesn't work with mod_php style sites, but it has many massive benefits and I think the idea of code layout being the definitive routing information is very silly anyway so I'd certainly not be sad to see it go. &gt;I agree, PHP is an old language, but it is constantly improving and moving forward. Eh, basically just as old as Python or Ruby really. (In fact in terms of 1.0 release date Python is the oldest.)
7.0 * ;)
It's really coming up. The Python devs knew it'd be a painful change, but they did it anyway to fix some very ingrained issues in the language. Most big projects are coming to Python 3 if they aren't already on it now. Things like async and await are too delicious not to go for. I did a non-trivial project on Django with the REST framework stuff and some other libraries and it was just fine on Python 3, not one issue related to not being on 2. 
The fact Python has good FFI support for C means it could blow PHP out of the water in a huge number of areas pretty easily by 'cheating' and using C for the heavy lifting. How about transcoding video? Slow as balls in pure Python, but get ffmpeg or whatever in on it and suddenly Python is only trivially slower than the pure C. 
What the....eeeeh is it 2002 again?
Its not like that I am new to Reddit, By mistake I submitted in PHP insteadoff MySQL, I will takecare it never happen again. Thank you
I wouldn't say NEVER, but there should be a whole lot of caveats around it.
Fuck me sideways, that's useful. Never even considered doing that. But that's mostly because I'm absolutely terrible about documenting my code.
According to your profile, your account was just created and you've already posted 11 times back to your website. Many times with incorrect or off topic information. Please read the [Reddiquette](https://www.reddit.com/wiki/reddiquette), specifically this line: &gt; Feel free to post links to your own content (within reason). But if that's all you ever post, or it always seems to get voted down, take a good hard look in the mirror ‚Äî you just might be a spammer. A widely used rule of thumb is the 9:1 ratio, i.e. only 1 out of every 10 of your submissions should be your own content.
[removed]
Would be nice. ..
Nah, OP is just spamming the sub with crappy code. 
Stop spamming us all with your bad code.
Just because you can doesn't mean you should.
Any idea when cpanel/whm will support it?
I'm curious to know in which case you *would* recommend this?! If OP takes you hostage maybe?
Oh right. 
Good idea. Personally, anytime I test some unknown app from the intertubes, I run it inside a docker container.
I'm a Ruby developer, forced by client to do a PHP application, and I hate it so far. Ruby might be slower, but is a lot more intuitive, for example, why on earth array_map and array_filter take parameters in different places?, why do you have to pass the array as first argument in array_filter and as a second argument in array_map?, that doesn't make any sense to me.
PHP is lacking in design choices, I won't argue with that. But I would take PHP or JavaScript/Node any day of the week over Ruby.
Ok. Would you mind posting up the URL to where ondrej has given reasons for doing this? I searched before I even posted in here and came up trumps.
The php server is much closer to what you would have using php-fpm behind nginx or lighttp. So it doesn't have support for things like .htaccess 
If you have an idea of resetting an auto_increment value, then your idea on auto incremented fields is wrong.
Sorry, but every example you have on your site is absolute rubbing. Are you trying to take us back to the stone ages?
[removed]
Nope!
Not sure what that means.
I'm sorry? What am I missing? Op asked if it was like Apache with features like .htaccess. But really all it is is a thin http wrapper around a php process. Which is exactly what you would have with fpm in a scaled up multiprocess form. Mod_php is a different beast since it ties into a fully formed http server that has its own ecosystem of features and plugins. If the hate is directed at mentioning something outside the conventional LAMP stack, to each their own. All three have well defined use cases. Quick and dirty dev testing, highly concurrent simple requests without the overhead of build up/teardown, or complex long lived processes with the ability to modify flows based on arbitrary rules that don't require the server to restart. But that's just like my opinion man. 
K.
[removed]
[removed]
php-fpm is not an HTTP wrapper but a cgi manager. Both has nothing to do with configuration files the OP was after. Your answer is irrelevant *and* incorrect.
When cpanel adds it as an option we'll see a lot of smaller web hosts switching to PHP7.
Welcome to development in ANY language or system. Linus Torvalds is one example of a really brilliant developer, but is so crude and rude in the way he explains how things are 'wrong'. Most (not all) of the time, he is correct. Personally, I'm getting sick of Micro Frameworks and how much they make life easier, yet you have to do SO much f'ing work to make them do things. I'm getting sick of PSR's that seem like a militant thing of "Do it this way, or you suck" mentality. BTW - some of the PSR just seem to me as a band-aid to fix issues that don't need to be fixed. Fix crap like Needle-Hay stack and Naming conventions in the core first off (Just an example). Putting makeup on a pig only makes it pretty for a pig f'er. I've worked with PHP for 15 years and I've seen improvements, I've worked through the pain. Most of the pain isn't with the language itself, but with the projects created with it.
I think it's humans everywhere you go though isn't it, so why expect more in one place than another; although sometimes I know what you mean, at least there are core contributors on Reddit
[removed]
[removed]
Some of the PSR's have been OK. But, there are some or parts I think are trying too hard to please the people that complain too much (or more loudly), yet fail. PSR-1: The &lt;?= ... ?= what? I personally don't like short echo's. Yes, it does make for less typing, but just seems a bit less readable to me. PSR-1 &amp; PSR-2: Conflicting spacing and bracket placing. PSR-3: Is OK, since there are not many variances in what we log. PSR-1 &amp; PSR-4: Naming our name spaces, this really f'd me up for a while with composer and it took me a while to figure out. I won't say I'm the smartest person out there, but wasn't fully clear (got my dick stuck in a fan). PSR-5: Haven't read much into it. PSR-6: WTF. Caching is such variable laden beast, that you can't standardize it. Like I said, PSR isn't an evil in core ideas of trying to standardize somethings (Of course some of the thing I agree with that other don't), but is awful in a lot of respects.There are certain things that, if you want to force upon the coders, do it in the core of the language. Of course, I understand they are trying to do something to make PHP get rid of it's 'bad' rap, but try doing stuff like in the C/C++, ASM, What ever language outside of the core, I don't think it would fly. It's kind of a like a religious subset, if you don't follow it, then you are not them and are hated and are dismissed.
&gt; I can rest Hope you really mean it...
I'm not looking for the uber swiss army knife, I want CMS/Blog front end that is easy to use, but on the back end isn't a cluster f. I want people to develop in a system that isn't from 2003 and will allow them have skills to be out side of just one product and more to core of PHP. If I can develop more in the way I'm used to in a pure PHP development with separation of code and HTML, then it would make it awesome. I've done dev in WP, and it's usually just annoying.
If you follow a standard, which I try follow of modified Allmand coding standard, your public project my be ostracized by people that think that PSR is the end all, be all for coding standards in the PHP community. I've seen comments on here that tear apart someone for not following them.
Really? Using `technical debt` as a fear inducing actor... Everything you do, in life has debt. The seconds spent typing that, and this, have put us both in debt; we'll probably both regret what we wrote in 5 years. Accept debt, but try to sensibly limit it! &gt; I can barely understand ACF Actually you should be commended for that statement; and anyone that suggests the contrary, when the nature of the plugin is to create a deeper experience than is defined as standard is lying to themselves. You cannot comprehend what the effects of using the plugin will be if some crazed user rolls-in and starts hacking away; so IMHO that plugin leaves too much open for a client. Which is why you should never leave it active for a client, unless they have significant technical skills. It simply allows too much that a web-front-end should not be able to do; but if it were locked down a little more; (and it can be); then it can be an incredibly powerful RCC tool (Rapid Content Creation, as I hate the term application development coming close to WP, it's a content framework). Your customers then need not be concerned with it's use, or in-fact existence; and it can be incredibly useful. Don't ban people using knives because some people stab with them; it's ridiculous and ignores the valid use-cases. Also guess why not everyone implements `precisely what clients need`... Because life changes, and sometimes a significant TD has to be accepted for productivity. I Have to accept the rules of Rugby or American Football if I want to play a full contact ball game. It's for this reason WP and swiss-knife variants exist, and without this resting on TD and others work, we'd all likely be dying in a cave, whilst tripping ball on shrooms, wondering which child sky-daddy demanded be sacrificed next. WP has a purpose, it's just not restrictively specific any more; and that can be a good thing! &gt; And now you've got HTML markup in your database - congratulations! What the hell was that supposed to mean? Where would you store the content? I Hope not on paper, or in a word document; on a HDD on the PHP machine like the uploads; naively perched in a web-accessible folder, hoping nobody runs it solo, or worse still having &lt;?php if(!defined('IMADICK')) die("stop hacking me, my mum says I'm an awesome coder"); I hope not in a KV store, just because an article you read suggested all BLOB and TLOB's are `evil`. It has to be somewhere in source form, so that all instances of the app can get to it. It has to be retrievable and addressable to more than one computer. Even if you put it (the content) into an S3, I'd argue you were using a KV store, rather than use an RDBMS, and now your backup strategy is needlessly long-winded and convoluted and your TD is higher so your head explodes and you have to be replaced by someone else hell-bent on a complete rewrite. Surely the media API should come under more fire for it's use of same-server uploads, than the fact post_content is stored in the DB? &gt; Wordpress is just shit. It's shit for developers, it shit for clients. I hate pink, it's for the ___X___. It's the same kind of moronic baseless argument. It's like railing against the sky being blue! I Happen to work with a number of clients that love WP, despite me hating some parts of it, I grit my teeth and carry-on; and at the same time use apps built on a common core framework I developed. They are happy with both, as both have very different use-cases. As much as I'd hate to have some work I've done for a few weeks or months be dumped and re-factored; In WP nothing really takes a few months, so it embraces the fail-fast ideology and for that reason I think you should salute it for yourself and your clients.
[removed]
I think the commenter believes you mean have legacy API as a literal plugin, that is activated and de-activated). I would say /u/tw2113 is either naive or trolling suggesting you take every idea you have to the core... You have your own things to be working on, and if you did have a small amount of time to give to the core, my feeling is they would make you regret it. You cracked it in a nutshell with this &gt; cultural problems are much harder to solve than technical ones There is also a dogmatic, fanboy streak so I'd be careful around anyone expressing close to `WP until I die` mentality
&gt; of course the ' : bool' is weird to me, I think I would like more C like, maybe like this: PHP 7 is already in effect, nothing's changing now. &amp;nbsp; function foo(string $arg1, int $arg2) : bool { .... } &gt; is the way I would want to see it. That's [psr-2](http://www.php-fig.org/psr/psr-2/) :P Edit: &gt; PSR-1: The &lt;?= ... ?= what? I personally don't like short echo's. Yes, it does make for less typing, but just seems a bit less readable to me. ??????????????????? did you misread psr-1? &gt; Files MUST use only &lt;?php and &lt;?= tags. &gt; PHP code MUST use the long &lt;?php ?&gt; tags or the short-echo &lt;?= ?&gt; tags; it MUST NOT use the other tag variations. The other tags they are talking about are referring to this RFC https://wiki.php.net/rfc/remove_alternative_php_tags since those tags got removed from the language. Not sure what you're complaining about here. 
WP core should be fine as of today, that might change, and it will always depend upon if you have a pet WP, or a Zoo of code with WP as the main attraction.
If the user www-data doesn't work, then try the user 'nobody'. There's usually one of either of those on a Linux system.
It is from [dotdeb](https://www.dotdeb.org/2015/12/04/php-7-0-0-is-available-for-jessie/). &gt; This new naming convention and packaging method will help to produce future php7.x-* packages more easily. And you could even install several PHP 7+ versions on the same server without any conflict!
I think that might be the only case...
If you want a well written Wordpress (minus the huge ecosystem of course), have a look at Bolt https://bolt.cm/
Would not work with selinux but I see your point.
Your freedom to spout whatever you like is not free speech, as it could potentially infringe upon the freedoms of others. Sites need mods, but it would be nice if sites did not have power-tripping mods. In my current experience /r/PHP is not an area with power-trippy mods (in fact I've not been PM'd or warned by a mod to my knowledge on reddit)
Except Phalcon, of course, but it's expected.
dude, eat your snickers and chill 
I don't understand how ubench work. Yii2 active record looks fine at least, interesting because they are not using beans, they have massive assignment, and declaring relationships between entities looks okey. 
trying to be hibernate using php maybe
Even then it's hard to imagine. I have an internal ORM that could be considered relatively complex in terms of capabilities. It can map data structures that even Doctrine can't map. And it's 20% overhead over plain PDO. And Doctrine is 1600% overhead. The hell. I've played with the Doctrine code and the parts I've seen seem reasonable. Is there a sleep(1) in there I've missed or what. There's probably some specific feature or component where things go south fast.
This is just a script that downloads the tarball, extracts it, runs ./configure and make. There's already instructions for that on the PHP website. And that way you get a choice of extensions.
Using almost ten months old version of Eloquent. I'd like to see comparison with more recent version.
&gt; NotORM uses neither repetitive queries nor joins, because they can be slow. Not using repetitive queries OK... But not using joins? That just sounds like pure stupidity. Yes, joins can be slow. But using one properly optimized join is better than query-ing the database again to obtain the joined results.
I think calling it *stupidity* is a little too harsh. You can optimize joins by indexing the criteria properly, yes. In fact this same index is also needed to perform a separate query efficiently. One of the points of performing a separate query, the author says [1], is to avoid data to be transferred repeatedly. Another one might be that MySQL's query cache could last longer because its cached queries would be invalidated separately [2]. Of course you could disregard these and still get a great performance even out of Doctrine. But then again I don't think it sounds stupid at all. 1. http://www.notorm.com/#performance 2. https://dev.mysql.com/doc/refman/5.6/en/query-cache-operation.html
Also .htaccess is what makes apache slow
I don't think Eloquent has changed all that much in 10 months tbh. I'd like to see what Eloquent performance would be like with less magic. While being able to do things like `$user-&gt;posts` for the relation query, and `$user-&gt;posts()` for the query builder query is convenient and all, the internal magic it does is a performance penalty, since it has to check every property call to see if it's a property, or a relation. Also, if you have a property like `$user-&gt;name`, I believe Eloquent also checks for the existence of `$user-&gt;getNameAttribute()` method first, which is more magic stuff that really doesn't need to happen. Further, things like `$user-&gt;where('name', 'John');` can have a needless magic `$user-&gt;whereName('John')` helper. I don't know if that magic `where&lt;Property&gt;` creates a performance penalty for other operations or not, but if it does, then I don't see why it needs to exist.
https://www.reddit.com/r/PHP/comments/3vnizl/yii_20_is_the_fastest_orm_in_php_orm_benchmark/cxp6nqi should answer you
what about Propel?
Well, it could be really hard to cache non-tagged package versions, like `dev-master` (or any other `dev-`) as they are pulled from source (directly git commands). You can't create a cache cuz there is no version and there is no way to check **whether there is a new code without pulling from the source**. And as `dev-master` should always point to the newest commit in master branch you cannot cache it.
I agree with pretty much everything you said, save for the bit about contacting the library authors in private. The vulnerabilities sarciszewski discloses are more theoretical vulnerabilities. Exploiting them in the wild is a lot more difficult than exploiting an SQL injection or XSS vulnerability. So say some library doesn't authenticate ciphertext's. Oh boo hoo. Unless you have an active eavesdropper it doesn't really matter anyway. Sure, it might make it easier for the NSA to see what you're sending, but it ain't like it's gonna let some script kiddie deface your site. I mean, honestly, libraries like jcrypt don't really serve any practical purpose, from what I can tell. They're just there so people can say they use crypto. Like "hey my program is immune from any type of vulnerability ever because I sprinkled magic crypto dust on it!". Crypto is often just seen as a magic black box that automatically makes everything better and it shouldn't be. And I think sarciszewski's posts help to drive home that notion. But that said, I do agree with pretty much everything else you said. His posts do come off as saying "library x is terrible - use mine!". I've [thought that for a while](https://www.reddit.com/r/PHP/comments/3oeb4k/choosing_the_right_cryptography_library_for_your/cvwnp6o) lol.
yes. will update my post.
Yii 2 is ActiveRecord. Even says so on the link. FuelPHP, Phalcon and Eloquent are AR as well. Doctrine is the only DM ORM on the list.
 while ($stmt-&gt;fetch()) { echo '&lt;option value=" '. $id . ' "&gt; ' . $name . '&lt;/option&gt;'.PHP_EOL; } Remember strings with single quotes are LITERAL... (What You Write, is What you see) :P 
Even installing nginx, php-fpm, and MySQL through Homebrew is absurdly easy and takes all of five minutes.
Because it takes forever to start a ticket with your ideas. There is no trolling going on here. If you have valid ideas that would work, then they're the people to bring them to. Whether they accept or not, I can't say. They're still the ones to bring your ideas to if you want those ideas to actually be integrated. That said, if WordPress moves to primarily JavaScript for a good amount of development outside of core itself, then there's chance I'll gravitate away myself. I don't fancy myself as a JavaScript developer, and a lot of signs are pointing to I'd want to be, especially after WordCamp US this weekend.
hmm I changed the echo statement to: echo "&lt;option value=" . $id . "&gt;" . $name . "&lt;/option&gt;\n"; but it still only shows in the source. Thanks for your help 
**edit** Im a ding bat. It was the css framework I was using. 
You're right, sorry. Was thinking of Cake 3.
It's hard to say without knowing your full use case, but this seems like it would be best handled by one of two more appropriate pieces of functionality: * [Route variable conversion](http://silex.sensiolabs.org/doc/usage.html#route-variable-converters) * [Route requirements](http://silex.sensiolabs.org/doc/usage.html#requirements) You can build a `strotolower` converter if you want to accept any cased argument, or you can define regular expression requirement that forces the route parameters to be lower case, rejecting anything that isn't 100% lower case. So while you can use middleware here, it might be more "silex-y" to use converters or requirements.
All right, this is what I wanted to ask. What would be more semantically appropriate, thanks! I will take a look at variable conversions.
&gt; And it's 20% overhead over plain PDO. Well, it's not a big deal if you have immutable data structures on which data is mapped (for example on read), and you don't have something like unit-of-work to watch object state, compute diff and flush only what changed. In this particular benchmark the biggest overhead is generating proxy classes for entities in runtime, since it doesn't have any write operations.
 function get4chanImageUrls($start = 1400000000001) { $end = 100 + $start; for ($i = $start; $i &lt; $end; ++$i) { echo "&lt;img src=\"https://i.4cdn.org/b/".$i.".png\" /&gt;&lt;br /&gt;"; } } Yes.
&gt; Now, you can safely run your script or app as it cannot access anything on your home partition (/home/foo). All it can access is the directory it was started in. While that's not downright false it's certainly a terrible explanation of how stuff works and gives people unfamiliar with Linux a completely wrong impression. `www-data` or `nobody` are the default users for Apache on many Linux systems. What they can access is determined by how rights are set. And it can most *certainly* access stuff outside of the directory it was started in. If a dir/file is read/writable by `www-data`/`nobody`, then it doesn't really matter where it is ‚Äî your app can read/write there too. Of course, that's only if you're not running on an SELinux-enabled system ‚Äî because then your trick most likely won't work at all without setting the proper context on the directories first. &gt; Of course, the proper way is to do a full-fledged apache setup and all, but whoever has that time in today's world? People who has taken the teeny tiny amount of time it takes to become familiar enough with Docker that they can spawn an isolated instance of Apache + PHP + whatever else they need with a single command line or a few clicks in Kitematic? Seriously. Is `docker run --it --rm --name lamp -v /home/user/myproject/webroot:/var/www/html -p 80:80 l3iggs/lamp` really that much more difficult to type? (Note: I haven't tried l3iggs/lamp, it was just the top result for a search for "lamp" on Docker Hub. Make sure to search for yourself and not just use whatever some random dude on the internet says.)
A program--specifically a package manager for OS X: http://brew.sh/
Thanks, appreciated. Massively controversial call I'd suggest, but when haven't package maintainers done their own thing for the sake of doing their own thing.
TBH it isn't that controversial. Think about shared hosts. They want this kind of thing. It helps encourage them to offload maintenance work to repos. Which helps them keep customers more up to date. Then, those of us that manage our own, just keep updated period. No need for us splitting versions.
I sort of understand what you're saying, but I'm not sure what is your overall point. If there are proxy classes, which... I have no idea why you need proxy classes in an ORM, they can be cached if they're stable with stable source code, I'm fine with that. We see Doctrine people like Guilherme Blanco come in and say the test settings are wrong, and then not providing any examples of what performance is like when the settings are "right". As for unit-of-work etc. it's another discussion, but a lot of what some popular ORMs do these days is neither intrinsic to ORM, nor required, and it harms both ORM simplicity and performance *and* the ORM user, by complicating the API and creating opportunities for data integrity problems. It's packaged masochism in code form. Data mapper, which Doctrine claims to adhere to (but it doesn't), is brutally simple: http://martinfowler.com/eaaCatalog/dataMapper.html It doesn't require tracking state, or building units-of-work, you just put objects in a repository and you get them out of there. That's basically it in a nutshell, and from that point you can extend it with custom transform/update commands, but that's veering more into CQRS territory.
You complain that caching is disabled with doctrine. You conclude that the author is trying to fake performance degradation and "prove" that Yii2 is faster... But it turns out that Yii2 also does not have [caching enabled either](http://www.yiiframework.com/doc-2.0/guide-tutorial-performance-tuning.html#enable-schema-caching), and yet it still crush doctrine. Dev mode is disabled for doctrine in [the setup function](https://github.com/kenjis/php-orm-benchmark/blob/6d466b905f570d08a9c574e197eb54f04670c263/fuel/app/classes/controller/orm/doctrine.php#L15). Dev mode is also disabled for Yii2 in [the setup function](https://github.com/kenjis/php-orm-benchmark/blob/430d59510bdb18dd7a2659abe6197735947ad506/fuel/app/classes/controller/orm/yii2.php#L10). To me it seems like he's just trying a bunch of ORM (that he might unfamiliar with) to figure out which one is faster. It's not hard to see how that could lead to an 'unfair' benchmark. The end result is that Yii2 'wins' because Yii2 is able to perform without caching, as opposed to doctrine.
Nobody has been forced to upgrade because Python 2.7 is still actively supported until 2020. When we get closer to that mark I imagine we will see many more Python 2 apps upgrade. I just hope PHP does not make the same mistake and extend support of PHP 5.
Started using it in production a couple weeks ago on my Laravel 5.1 projects. I run them on Heroku so the upgrade process is as simple as updating your composer file. I upgraded my personal blog (WordPress 4.3) to php7 this weekend. No hiccups so far. Definitely getting a performance boost, but I haven't done any fair testing to see how much.
It's always worth to learn different kind of languages, essentially if they have a different kind of programming paradigm.
No, learning make stupid. Avoid always. '''/s'''
Personally, I wouldn't use Middleware for that. [Converters](http://silex.sensiolabs.org/doc/usage.html#route-variable-converters) seem to be what you're looking for in this case.
I should clarify, I mean trying to get better at BOTH languages at the same time. A good saying that comes to mind is "The man who tries to catch two rabbits catches none".
Well it's certainly worthwile for the case, when you have to do something in the frontend. Especially if you have to develop some kind of (REST?) API, which usually involves front- and backend. But if that's not going to happen, then there probably is no reason to do so, except for your own satisfaction.
&gt; So when resolving something out of Laravel‚Äôs IoC-container PhpStorm cannot help you. A dependency is fetched out of a container to be passed to a method/constructor as a typed argument, not to be used right there where it's fished out of the container. This feature is essentially supporting a common misunderstanding of the purpose &amp; use of a DI container. I realize I'm wasting my breath.
That easy to change versions on Heroku? I've never really used it, we're using AWS at my work. When it comes to change it'll take some server configuration but shouldn't be too bad.
i personally would chose other languages if you learn javascript ... you have to be really good at html/css too [and then photoshop of course], this is a huge area, and requires quite some dedication to be good at, theres a reason that on a "higher level" you will always see dev roles split between frontend and backend. So ask yourself - where do you want to go ... do you want to be able to "pull of a complete project by yourself" ? then js/html/Css certainly is a good choice. Do you want to be a really good back-end dev? then maybe learn C to be able to write PHP extensions and understand more of the underlying architecture ... or learn technologies orbiting around php like mysql/postgres, redis/memcache/casandra, sphinx/elastic, rabbitmq etc ... or the huge area ov devops ~ in my eyes those are better suited for php devs. but thats just my 2 cent, theres certainly nothing wrong with getting good at JS as a php dev, just think about where you see yourself in 5 years ... if you want to go the team/lead management road ... it might be even good to get "basic" in a lot of different things to know what you talk about.
Well, in my opinion, greatly depends on your needs and how good do you want to be at it. Here's a few clues of mine * How well do you want to know the language? It will take you 1-2 years to get it "senior level" and it will take you 5-to-10 years of heavy usage to get it to "guru" level. * Frameworks, libraries, tools - all that requires a lot of time and practice. Uninterupted practice. 1-2 years to seniour level provided you are good at the language itself, up to 4-5 to get it to the "high-level" where you had a change to work with multiple tools and now understand the application design, tools and all that crap. Still, 10+ years for a true "guru" level in total. * When you switch languages and tools for longer periods of time, you loose track, forget things and you need time to refresh it all. In the end, it really is up to your mental capacity. There are people who can multitask in 3-4 languages easilly, but that an exception than a norm rather. * Well, trying to catch two rabbits, catching none still applies here. JS these days is not the same it was 5-6 years ago, when you could really learn it easilly in paralel. These days frontend developer it's own profession, same as the backend developer. And it's much more punishing, hense pays quite a lot more. But the velocity of the frontend is so fast, that if you want to keep up, you need to dive into it and not look back on the backend (or do your backend on Node.js, at least that keeps you in the JS world, but that's also a whole 10 levels higher compared to Wordpress) So, what I would recomend, is actually understand what you need and what you want. I can say one thing - Wordpress is low level anyhow, so at this point you can go either way. Certanly learning JavaScript and knowing it at decent middle level is good. If you are still young, maybe you can push agressivelly into both. Me, myself, at my almost 30s, sticking to the backend world mostly. I can get it done with JS for the most part, but these days I just hire a frontend dev to do his part. Ends up cheaper and much better quality and time saved.
Goes without saying (unless you're stupid) - but research each host before you give them money. And by research I don't mean google "&lt;hosting company&gt; review" as you'll get the affiliate / paid reviews. Go over to somewhere like WebHostingTalk and get real peoples opinions. Oh and stay away from all EIG owned hosting companies (e.g GoDaddy, BlueHost, HostGator, etc) - they're 100% pure shit.
https://en.wikipedia.org/wiki/TrueSkill https://en.wikipedia.org/wiki/Elo_rating_system
But man who learns how to catch rabbit AND how to cook rabbit, he's the one that eats.
I actually created a sub-reddit to help with naming technical things about 8 month ago: https://www.reddit.com/r/NamingThings However I'm yet to actually post anything there to get the ball rolling. Every time I've had to come up with a tricky field name or whatever lately I've been in a rush to get on with the work. The initial idea was that it would be for discussion of variable/field/DB column/class names etc. Although technical RFC features is a great example of something else that could be helped with a bit of feedback. So if that type of sub interests anyone, please subscribe, and maybe we can help each other out in the future.
If your question is about how many things you should learn at once, then welcome to web development - learning new things never stops.
I'd focus your actual "learning/reading" time mostly on PHP. But of course JavaScript is useful to know as well. But these days, I've found that you can usually get by with JS libraries to make all your interactive widgets etc without needing to know a lot about JS. But it's still definitely worth learning the basics, although I'd focus more just on using jQuery.
I kept asking but it didn't seem to help.
Nice post!
Yep. Many companies specifically look for full stack developers. It'll also make you a preferred candidate for many PHP roles (provided your PHP is up to scratch with the requirements).
The thing is: Is being a full stack developer necessarily a good thing?. Personally I think it's important to understand the full stack, but I avoid full stack jobs like the plague. Full stack jobs usually expect too much from a single person. The responsibility list is so large that it is usually divided between 2-4 different positions in bigger shops. (UX/Design, Frontend, Backend, Devops).
&gt; is brutally simple: Yeah, and you don't take into account thousands of common use cases that covered by Doctrine. For example, you don't want to have two copy of a single entity (with the same identity), so you should have something like identity map. Then you need to worry about conflicts. For example if two users will change state of single entity, you'll need to compute change set and commit only changed data to prevent data losses and so on (here you go, unit of work). Doctrine handles most of common use cases, simplifies your code a lot. But you'll have to pay for it with performance. If you need performance then you'll probably need to use some light data mapper and handle all this use cases by yourself.
&gt; "6" and "7" are numbers, not names. Numbers can be names too, they are not mutually exclusive :) The name *is* PHP 7.
My method isn't suitable for teams (unless everyone is using the same dev DB server), but as a solo dev, all I want is for the dev DB schema to be synced to the live DB through auto-generated SQL ALTER commands... basically a diff like you're talking about. I don't want to fuck around with migrations manually, and the auto-generated ones I've tried were missing a bunch of features such a fully supporting foreign keys properly etc. And some don't even differentiate between SMALLINT/INT etc which seems fucking crazy to me. I had real trouble finding something nice and simple for my need, that also supported all the SQL features properly such as foreign keys etc. And I've spent a fuckload of time looking. The method I've been using for the last five years or so is this. The following happens when I run my "dev to live" deployment script... 1. The project on the dev server runs a "pre-deploy" script, which just does a mysqldump of the dev DB schema (without row data) to a .sql file (full of CREATE TABLE etc commands) in the code base (so these dumps get tracked by git) 1. All the project's code (including that .sql schema dump file) get rsynced to the live server 1. On the live server a "post-deploy" script is run, which does the following... 1. Create a new temporary database 1. Runs the .sql file on the temporary DB to create all the tables using the latest schema (no rows) 1. Then the command line Python program https://github.com/mmatuson/SchemaSync is run to compare the temporary latest schema with the real live schema. Schemasync generates two SQL files: patch.sql (the ALTER commands required to modify the live DB) and revert.sql (to undo them) 1. patch.sql is run on the live DB. 1. The temporary database is deleted. For me this solution is great. Fully automatic and simple. I don't even think about DB schema changes any more when deploying to live, it takes care of itself within the normal deployment script. As I mentioned at the start, if you're working in a team with their own dev DB servers, obviously you can't do this, but it's great for me otherwise. The only downside is that this method has no awareness of renaming a column. It would treat it as deleting a column and creating a new column... so you'd lose your data. I haven't had a need to rename a column so far, but if I did, I could easily just make that change manually before deploying (schemasync wouldn't need to do anything on that column in that case). I tried to find something PHP based rather than Schemasync (Python), but haven't found anything as simple and feature-complete. So I'll stick with this until I do. Schemasync hasn't been updated for years, and the website even disappeared. But it does everything I've needed so far. Although it would be nicer if I didn't have to create the temporary DB, i.e. if it could create a diff by comparing a .sql file to a running DB rather than only comparing two running DBs against each other. I've still got an old tarball of the final version (0.9.2) that I use rather than getting it from git, so let me know if anyone wants it. Although I think you should just be able to download it from git, then to install, run: python setup.py install ...and it'll install itself to /usr/local/bin All of the above only applies to MySQL. I'm hoping to start using PostgreSQL soon, and it looks like it might have more simple mainstream diffing tools like Schemasync (which only supports MySQL). I assume that most PHP migrations would be missing half of postgres's cool new features. So overall, from my experience "migrations" really don't fully do the job of replicating a schema properly. You need DB specific tools that are fully aware of all features of your flavor of SQL to do this.
Merci monsieur napoli &lt;3
Yeah, Heroku is very limited in what kind of server administration you can do, but if they support a version of something it's very easy to just instruct your app to use it.
&gt; you trust Doctrine to magically avoid race conditions No i don't, I usually use CQRS and event sourcing when it is needed. &gt; Can you rephrase this, it's unclear what's your point http://martinfowler.com/eaaCatalog/unitOfWork.html My point is that Doctrine is just a tool. And like with other tools there is no silver bullet. There is cases where Doctrine doesn't feet or brings additional complexity. And there is more simple systems where Doctrine makes life easier.
Ideally you want to have your core features in its own repo, so you can easily upgrade all of the client's cores easily. You work on the client repo and using composer include the main repo that way its easy to keep it updated.
That's what we're doing now. But many features in the core need to be modified in different ways by each client, so the Composer package has to be crazy complicated in order to accommodate all the possible bespoke modifications, which is what I want to avoid.
It'd be good to see Propel featured, though I can sort-of understand why it isn't. The 1.x branch is dead, but the 2.x branch seems stuck in a lengthy alpha - I think they don't have many people working on it. The official advice is to use 2, since it is more thoroughly unit-tested than 1, but the new code is still open to possible BC breaks. So, the only new projects that can use Propel 2 are ones where there's sufficient time to refactor if a Propel update demands it. (I have a Propel 1 project, but am wary about bumping up, especially given I am happy with my system as it is). 
Currently, the best-practice is to use php for backend-functionality. CSS for style, Html for page-frame and javascript for UI-automation and AJAX-Calls. Being able to use them together and for their intended purposes is one of the big skills a webdesigner/developer needs. Nothing worse than a developer who refuses to use the right language, just because he thinks he can do it all in one. If there was one language in webdevelopment that could do it all perfectly, there wouldn't be as many used together. 
If you wanna go for REST APIs with AJAX XHR-Calls, learning both is exactly the right way. They integrate into each other and understanding both sides is essential. But if your job is only to write the php API while other people do UI and frontend-calls, you can get away with only php (or only javascript, if you do the frontend stuff) I'd give a bit more attention to php in the beginning and a little bit more attention to javascript along the way, but over all, I'd say 50/50 is quite normal. 
In my experience you can get round this trivially if you use dependency injection and an IoC container - just override the core class bindings in your container with your client-specific implementations versions of those classes.
I'm in a not entirely dissimilar predicament, so am commenting here largely so I can follow the progress of this thread! I have a successful webapp, which there's some interest in franchising out to others. To do that I think I want to split the current one into two codebases; core and have my site ("site1") sit on top of that. Then down the line I can implement "site2" without touching core. I want to be in a position where I can make changes across all sites just by modifying core, but it's not a concept I've ever worked on before.
I was trying to learn them all but I got hooked on PHP and haven't really moved on. I use javascript for basic stuff but don't really know it well. I had the same worry that you did. I don't want to confuse the two. One thing I did at the start was to compare the two and make a mental note of the differences in syntax. I would read about php then javascript and get the two mixed up when programming. Noting the differences helped a lot. It is good to have a basic understanding of it because you will need it for certain things along the way but you don't have to master it. In the end you will learn whatever you use the most anyways. I use jquery now which is just a javascript library and it is simpler to figure out. 
The name is "PHP", the number for the version is 7, the identifier for that version is "PHP 7"
If you're learning PHP you're probably doing web development, in which case JavaScript is pretty much essential. Modern web-apps do a lot of things client-side, so unless you want to focus strictly on back-end programming you're going to need to learn it. I understand your worry of trying to learn too many things at once, but you'll find that a lot of what you learn can be applied in both languages.
I ran Homestead7 which has PHP7 installed on a Laravel 4.1 project. I didn't give it enough time to test speed, but it worked with no errors or warnings which is cool. :)
* +1 for Depency Injection as others have said, don't fork. * Sometimes you might need to change settings, like who will receive an email when I do X, API keys, and so on. You can use Config::get() like Laravel's. * Other idea is to make your app trigger events like "when i save a record run X" and then separate custom behavior on the client repo * You can also call REST APIs on the Client App when something happens, separating this way your core code completely from the client code, but this doesn't seem to be the way your app works now. I'm trying to find the best way to customize my apps as well and have not found the perfect architeture yet
If you run Debian Sid PHP 7 is also now available on [Unstable](https://packages.debian.org/sid/php7.0).
Don't forget sysadmin and netsec. 
We should really start naming releases. :)
&gt; It's just IMO much more convenient to have a framework chewing you at the deltas instead of having to do it manually and keep this delta files lying around. One challenge of doing this in PHP is you need to store some kind of schema definition somewhere. - Integers can be smallint, int, bigint. - Double/Float precision also needs to be specified. - String types usually have some kind of limit. - Indexes / unique contraints. The schema could be defined at the model layer and tools can parse the schema definition to generate the `create` and `alter` statements. You might also need to run some upgrade scripts on the existing data (let say you move from char to varchar, the string needs to be stripped).
I'm with you. Another reason is I don't think you can be as good at your job when you're spread around. 
But there's so many view modifications, business logic, entirely new features, huge overhauls of existing modules, custom menu items, etc it just becomes overwhelming to hide everything behind interfaces. Each client can even have completely different database structure, with entities with entirely different fields. Lets say you have a `Book` entity that implements `BookInterface`, both provided in the package (the package that is required by every client application), and `BookInterface` has a single method `public function getIsbn()`. One of my clients doesn't use ISBNs, and their books have only a name. So, the clients actually needs a different `BookInterface` that has a single `getName()` method. But I have to use the interface provided by the package, because the rest of the application type hints `BookInterface` and makes multiple calls to `$book-&gt;getIsbn()` - but of course this doesn't apply to the client, who wants to use `getName()` (pretty stupid example, but hopefully it demonstrates my point). I know there's ways around this - I'd probably have to extract everything related to book entities, and everything that interacts with book entities (multiple classes, related entities, views and controllers) to an interface in the shared package, provide a default implementation that internally uses `getIsbn()` everywhere, and then re-implement the whole thing in the client, making my custom implementation internally use my new interface and its `getName()` method. However, compared to how it would look if I had a client fork - I would just directly modify it in the code base, remove all calls to `getIsbn()` and add in calls to `getName()` where necessary - this seems like such a simpler option. Having experienced working with the way you're suggesting for a year (using a single, incredibly abstract dynamic Composer package used by all clients and utilising config settings and DI to inject custom implementations, hiding almost everything in the application behind interfaces for the sake of client modifications, no matter how big or small those modifications may be), I really feel like directly modifying the code base in a fork would make development faster, and the code easier to understand and maintain. I appreciate that in theory DI is almost certainly the most "correct" answer, but in practice its taking so much time to work that I'm not sure its worth it. Right now, forking and making changes directly in the code base is a lot more appealing.
Can you precompile those queries into a static table every morning, then query that/those tables instead?
This isn't really the place for these types of posts.
Isn't MariaDB prefered over MySQL? Also, I would consider adding NodeJS + npm for frontend automation (gulp/grunt, ...)
Yeah, I'm still in the habit of calling it MySQL (will fix). I wasn't planning on adding any front end tools, but come to think of it I may aswell throw in the kitchen sink :D Will get NodeJS on it too.
You use [scotch box](https://box.scotch.io/) as a base? If it's anything like scotch, I'd like to try it. SB won't be updated for a [few months](https://twitter.com/nickforthought/status/669657306213298180) it seems.
eta?
PHP 7 doesn't introduce any new caching methods, so your favorite approaches from 5.x are still equally valid. Memory usage is more efficient though, so any in-memory caching you're doing should be a little faster.
Test code is not production code, but you should still look after and refactor it.
&gt; so any in-memory caching you're doing should be a little faster. That's can only be true where Zend's representation of values (zval) is used in the storage itself. Lots of caching mechanisms use some other format, json, serial, or some other binary format, these can't benefit from memory optimizations. Any gains you might have gotten from more efficient zvals when copying out of a cache are destroyed by the fact you have to traverse and transform the data in the first instance. So ... it's not really true in the general case ... Except, when you request that APCu stores an array, it is not (by default) serialized, it is copied bitwise into shared memory ... here, you may be able to measure a meaningful difference.
they all remained the same: - Zend Optimizer+ for opcode cache - APC for configuration-like data that needs to be reset with PHP. - Memcached for non-critical persistent cache. - Conditional GET for HTTP caching 
So what is it? APCu, memcached, redis? Whats the best nowadays? 
I code all my backend websites in [asm](https://en.wikipedia.org/wiki/Assembly_language) because it is fast and web scale.
Thank you, I'll give these a try!
Oh neat, I'll have to give that a go. Thank you!
It's not the type of thing that needs to run on a schedule per-se, but when it runs it has to be accurate as the data is at that moment.
Your sql view is doing all the joining of tables and processing of the data to be returned, right?
This was a throwaway answer to a low-effort question (which has since been expanded upon). Now it's just stupid (thanks to learning, no doubt).
Even though I am not a PHP dev, I learned it because you will have to work with it at some point if you are in web dev for long enough. The same reasoning goes for JavaScript. Once you learn two programming languages well, learning the 3rd and beyond becomes much easier.
maybe it's because you're a webdeverper
i wish you gave me a productive answer.. just because you dont know doesn't mean that there is a good solution that is within such a tight margin of differences that it doesn't matter.. 
I am coding a CMS and framework for a personal project. I'm self-taught and doing everything by hand. Have the CMS portion down but I am getting to designing a user login, registration, profile,etc. system and I am wondering if OOP is necessary or the best route to go with this? I used OOP for the CMS portion, finding/adding/listing articles,etc so I am not unfamiliar with it. Also want to check my users via a session when they log in, what's the most secure way to create/manage sessions? Thank you.
Made it to 9 seconds when I realized this is yet another video of someone typing very slowly and awkwardly.
Well, while I would normally just ignore this thread and dislike the video, I see that your channel is rather small and new. So I may as well leave behind some feedback for you to grow. First, your typing is rather slow, and there is no speeding up of the video - from what I watched. If you really want to have a text-based video, you must type fast, or you must speed up the video. It was rather hard to watch until you got some PHP on the screen. There was so much typing before the actual code to make me want to find another video. Just use your video editing software and speed up typing a bit. Also, text only videos are rather 'cringy'. It's hard watching a video that has no volume to it at all. At the very least you could have put some music in the background - something soft and not distracting from the text-only style of the video. Orchestra will do fine here. Otherwise, you should truly use a microphone - and not live commentary either. Live commentary for new video makers is sometimes bad, leaves information out, and is filled with awkward 'uhh's. Use a microphone when you are reviewing the video that you just made; fill the audio with useful information while being quick to the point. The zooming can be nullified, if you are doing that intentionally. We can read the text without the zoom in all of the time. Also, when someone is learning, they like to see all of the script laid out. When you zoom in, it is difficult to actually see ALL of the code, even though it is on one page. Just code without the zooming in, and we will see what you are doing. Lastly, your formatting needs to be proper. If this were a larger channel and gathered views from someone that is learning PHP, you could teach bad habits. I definitely learned bad habits from video makers, and it took me a while to train myself to comply with PSR standards (not too long, but it was annoying). Use PSR standards yourself, so that anyone who learns when viewing your videos will do the same without thinking too much about it. Also, those who know more than you will take you a bit more seriously. Overall, I hope you or anyone else does not get mad at me for giving a little critique. It's better than just ignoring it and not trying to help out. I wish you and your channel luck in growing, and hope you have a nice day.
*WOW!* I just ran my phpunit test suite against PHP 7 and all I can say is **HOLY SHIT THAT IS QUICK!!**
Well, OP, I think he did provide [examples](https://www.reddit.com/r/PHP/comments/3vt6iq/what_is_the_favorite_caching_method_for_php_7/cxqilb8) of which caching is better for each case. You did not provide him information about what you want to cache.
Not to poop on your parade, but my FOSS https://puphpet.com has every single item you listed, and can be created via the online GUI. Nice video, however.
I immediately think that sounds like an issue with the data being generated and while it's generated the values aren't there so if somebody were to query it at that time there would be no data.
On top of this, there's a few implementation issue i ran into when following PSR-6 (at least the older versions). https://github.com/php-fig/fig-standards/issues/389
 An actual suggestion for how to improve the situation. Stop trying to have one PSR for a certain thing which is the ONE TRUE WAY OF DOING THAT THING and instead make the PSR organisation just be a central place for projects to work together on thing, but not force everyone to use them. And instead of having unique numbers allow those projects that want to work together to claim namespaces for the stuff they want to work on. e.g. if the Laravel and Doctrine guys want to get together and define better interface definitions then allow them to do that under the `PSR\LDCache\` namespace. If the Stash, PHPixie and other people want to continue pushing this design through, if it was under the namespace `PSR\AwsomeCache\` there would be no fighting over who would be the ONE TRUE CACHING PSR!!1! Yes, that would mean that there would be competing interfaces for similar things. This is a good thing. It allows for natural selection between the different implementations. Having everyone just use a single design is the end of innovation (and the biggest thing I dislike about the idea of the current PSR organisation). Oh, it would also allow for stuff to get done more quickly, as people designing standards wouldn't need to cater for every single use-case under the Sun. Having it under the umbrella of the PSR would still be useful, as it allows for a single place for people to discuss stuff, (for example organising BC breaks in a planned way, rather than them just being done haphazardly) as well as giving some back up in case the original developers get hit by a bus or lose interest in maintaining the standard.
How'd you get memcached working - did you build from source?
&gt; but not force everyone to use them. Oh stop it Dan. The FIG doesn't do that and it never has. &gt; e.g. if the Laravel and Doctrine guys want to get together and define better interface definitions then allow them to do that under the PSR\LDCache\ namespace. Hell no! We've have ended up with about 95 autoloading standards if that were the case. We'd have more of these ministandards than there were implementations in the wild. &gt; Oh, it would also allow for stuff to get done more quickly, as people designing standards wouldn't need to cater for every single use-case under the Sun. This PSR doesn't cater for everything. People keep saying that, and it's a vague annoying meta discussion. There were a _lot_ of features deferred to a later Cache Advanced PSR, or multiple potential PSRs, but if it went as simple as some were pushing for a singe interface with get/set and that's no use to man or beast. I did appreciate Anthony's feedback about trying to "keep it simple" through interface composition, but after 15 years of squabbling here I'm just glad there is some sort of agreement on the PSR. Those that want to use it can carry on and if Laravel+Doctrine want to make one then they might, but they'll realistically just bikeshed forever and stick to their own implementations, while the heaving masses adopt the PSR - as they always end up doing. 
Personally, I've had many issues getting PuPHPet working properly. I've attempted to use it multiple times over the last couple of years on a variety of hosts (multiple Linux flavors and Windows 7) trying several different guests (CentOS, Ubuntu, Debian). Out of about 8 attempts, I've only ever had the box come up working properly one time. One issue that happened a couple of times was that Apache was not installed and so the service was unavailable. There were other problems I had on various tries causing me to look elsewhere as I don't have time to troubleshoot a Vagrant box like PuPHPet when there are alternatives that I've had no issues with. Scotchbox and Homestead are my go to PHP development Vagrant boxes. Both are simple to use and are setup and ready to go out of the box. I've really wanted to use PhPHPet over the years because of the ability to customize the guest and dial in the box more closely to our production server stack. Scotchbox and Homestead are obviously pre-configures boxes with each having basically one configuration, so I realize that there's a difference in what PuPHPet is capable of. I only post this to let you know that even though PuPHPet is a great tool, it doesn't work for every developer and I'm happy to have options.
Replacing included X.A.M.P.P.'s P.H.P. from 5.6.14 to 5.6.15 was easy. When I tried to do the same with 7, apache server just didn't start. I found a monster called Ampps. It looks preeetty nice. Maybe there won't be much problem then.
&gt; Oh stop it Dan. The FIG doesn't do that and it never has. Look me in the eye and tell me that there isn't going to be a _massive_ amount of pressure for the Doctrine team to use this caching PSR instead of one that they like. &gt; while the heaving masses adopt the PSR - as they always end up doing. Which is another way of saying that once a PSR is passed it becomes the one true way of doing stuff, even if it's not as good as other ways.
I agree with you. If some other organization came up with a library API that became the defacto standard I wouldn't have a problem with it. But the fact that PSR is doing it is is a problem. Just how many API's do they get to dictate? At this point an API the FIG promotes isn't necessarily going to be adopted because it's the best API - it's going to be adopted because the FIG tells people to adopt it. Libraries and API's ought to be selected via survival of the fittest - not on the orders of the FIG oligarchy. What's next? Will the FIG come up with a standard for frameworks? I guess we should all stop using Laravel and Symfony and CodeIgniter and whatever else if the FIG tells us to.
&gt; My point here is that the most relevant projects in the group are against the proposal and everyone else appears to be voting '+1' without thinking why. That's a fair point (I actually agree with you), but I'd prefer the real issues to be discussed rather than looking at what others are doing and guessing. &gt; On number two [‚Ä¶] the problem is that the specification doesn't require exceptions implementing the 'InvalidArgumentException' interface to also extend the root 'InvalidArgumentException' class I don't see why it's a problem. The name might be implying a hierarchy here (because it's the same name) but I don't see why it has to be a subclass of `\InvalidArgumentException` (or rather I don't see a problem if it's not). &gt; Problem three is that you'll need to provide a public method that you only want to use for internal purposes (for the reason that it isn't a public method on the interface in the first place). It's not for internal purposes, it's for the purpose of an external component (of the item) which is the pool. We are exposing extra item information that is necessary to the pool, but not to consumers of the items or the "cache component" as a whole. It is however implementation details (when we look at it from the PSR-6 consumer POV). Here is an example: https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Routing/Router.php The router exposes many public methods that are not part of the `RouterInterface`. It's all a matter of use case. You may want to standardize how developers will store/read from cache, but that standard doesn't have to include how the item will communicate with its pool.
Have you looked at the sources for the benchmarks or have you just taken meth with a ketamine chaser? ### Clarification When do you run so many iterations of those specific functions in PHP or python? If I want to play with zip files, I won't even use PHP, I queue a series of synchronous tasks, the first of which will likely let a C program unzip. PHP is not the hammer to solve all problems. If you want to rail on python, do while loops, switch statements, ternaries, all missing, and more vital than speed. https://wiki.python.org/moin/PythonVsPhp has a more informed response for those considering Python or PHP, but I'd consider just using what tool you feel comfortable with per-task
Wait a second. If no cache drivers are configured, then Doctrine is really slow! Cache drivers are always configured in production. What kind of person benchmarks something with all optimizations turned off? That's like benchmarking a race car with the engine turned off and five guys pushing it. Sure, they are working hard, but it's not relevant.
&gt; isn't necessarily going to be adopted because it's the best API How do you define 'best'? Most features? Best docs? "Vote of confidence of X% of community projects" surely is a factor now, and FIG/PSR have play a role in that metric. Personally, I'm not a huge fan, although I've undoubtedly benefitted some from more community standards. It feels to me, however, that the incremental value in newer PSRs is rather nominal. Defining code standards for interop - PSRs 0,1,2 - laid a strong groundwork for a lot of interop. Newer efforts - having "security disclosure" standards for a PSR, for example ... they're good intentions, but don't really belong under the umbrella of "PHP" (that one in particular)
You'll get an error reading an undefined offset, so you can't use a function call. Also you named function "echoIfSet" which immediately limits your use cases to just echoing out values. Often times Null Coalescing is used in assignment.
No memcached is in the [Remi](http://blog.famillecollet.com/pages/Config-en) repos I used.
Good point! On your second point though, I actually suggested two different functions, though I wouldn't want to use either of them.
Be careful. You should try to facilitate as much cross-client benefit as possible, and probably will want to work with multiple repo's
&gt; That one seems obvious enough, and close enough to the current syntax. I'm surprised that wasn't proposed at some point. (And no, it doesn't work). It's something I myself have wanted after using the null coalescing operator for a while. I think I might have written `if (($_GET['foo'] ?? NULL) === 'bar') {`, where `if ($_GET['foo']?? === 'bar') {` would be nicer. Who knows, I might write an RFC for that someday. It's a little niche, though.
I'm not sure what the purpose of setting an expiration date is, if you can't get it later, when you need to use it. That really doesn't make sense.
missing a TTL, but something this simple would be pretty nice
If you want to suggest they were "contrived" to make PHP7 look faster than Python 3 -- show some evidence for that claim.
Hey Juan, just wanted to say thanks for building and maintaining this excellent tool! I've used it for almost two years now. It's super handy.
TTL is something most usages don't need to be concerned with. An implementation could set defaults or provide methods to handle that via decorators. But the thing actually getting/setting the cache item doesn't need to know about it. 
Then I would be participating in wasting everyone's time like I was complaining about the benchmarks doing, go away, or refute (The specific example I would like to see is openCV vs PHP's equivalent if one exists)
PuPHPet troubleshooting trick #0: try more RAM. I've had several failures and it usually ended up being some hiccup in the provisioning process where the box ran out of memory. The only other problem that I recall having had to do with the `config.yaml` file and `"Off"` not being equal to `false`, [as described here](https://github.com/puphpet/puphpet/issues/1882).
tax percentage - yes discount - discount amount or percentage 
While, ideally, everything is constructor injected, it's nice to have PHPStorm understand the alternative.
For the most part you shouldn't care about the expiration of an entry as a consumer. It's either there (and not expired), or it isn't. Some engines (Redis) handle this internally. 
I think you should save total, tax amounts, discount amounts etc in the DB. That way if you ever change how a calculation works all historic records are still the same. What if you decide to change from bankers rounding to round half up? It also allows for a level of auditing. If there was a bug in your code and you have been charging the wrong amount you can quickly see how much money you have lost/over charged.
I would argue that the current state of the bill should be stored so you can see what the total and details were at a certain point in time. If you need to make changes, then you generate a new bill with a new total. Then you have a paper trail showing the changes.
I agree that the state of the order at that point in time is important. But how it should be structured, and whether the individual components should be stored, and how, is simply not a technical question that we have any job giving an opinion about. It's not a problem of /r/php/ it's a problem of /r/business/ and /r/accounting/
I think you make good points, but the focus of an *interoperability group* should, first and foremost, be interoperability. If the implementations must be adapted to be useful in most scenarios, that's not very interoperable. Folks will just end up not implementing PSR-6 and/or only implement the bits they need (leaving the others throwing NotYetImplementedExceptions) rather than writing adapters - because we already write adapters. The point of these interfaces should be to eliminate that step for the majority of users. And that brings me to the only major/show-stopper problem with PSR-6 as I see it, which is that it egregiously violates the interface segregation principle.
&gt; I think you make good points, but the focus of an interoperability group should, first and foremost, be interoperability. If the implementations must be adapted to be useful in most scenarios, that's not very interoperable. That's a bad concept of what interoperability is about. Trying to have an interface which is *native* to *everything* is a false goal, that leads to bikeshedding like this thread. Think about it, even through there is an adapter, you don't adapt *an implementation* as you said, you adapt an interoperable interface. There's one of it, so instead of adapting N implementations for N libraries, you need one single adapter, and then all PSR implementations can be used with the system you're adapting to. That's quite "interoperable" in my book. Case in point: would you say x86 is a standard for CPU instructions sets? All Intel processors implement it, so does AMD and some other companies. What if I told you that no processor from either of these companies works with the x86 instruction set natively since 1995? They use a translation layer converting x86 instructions to an internal "micro-ops" instruction set which has nothing to do with x86, and this internal instruction set changes with every new chip. In other words, unlike earlier chips, modern processors support x86 through **an adapter**. But the resulting chip is still interoperable with x86 software, right? All our PC stuff runs just fine on it, as if nothing changed. So what's the lesson here. Should we spend an eternity nit-picking exception names and what not, or should we accept that no common standard will be everyone's cup of tea in terms of trivial issues like these? A better goal for interoperability is "instead of having to write N cache adapters, I need to just write 1 cache adapter, and all PSR caches will work with my library through that adapter". That's what the value of PSR is. Instead of 100 adapters to support 100 implementations, you need 1 adapter to support 100 implementations. If you frown at the idea of using an adapter, what is your plan of action when the inevitable "PSR Advanced Cache" proposal comes out one day? How'd you have a library which supports both "advanced" and "non-advanced" cache as its cache with no adapters? Would you just write everything twice? Or maybe you plan to pepper your cache-using code with stuff like this: if ($foo instanceof AdvancedCache) { $foo-&gt;advancedMultiSuperGet(); } else { $foo-&gt;crappyGet(); } ...all over your code? Nope, if you value your sanity, you'll use an adapter, and support *both PSR interfaces* through a single *internal* interface which *matches your needs*. Good software architecture is mostly about having interfaces and adapters in the right places. It's so simple, and yet so rarely understood. &gt; And that brings me to the only major/show-stopper problem with PSR-6 as I see it, which is that it egregiously violates the interface segregation principle. It may violate it, but the reason it does is a flaw in PHP: we have no intersection types. You can't request, say, an "sql connection with generators and transactions" in your method: function (PsrSqlConn &amp; PsrSqlGenerators &amp; PsrSqlTransactions $conn) {} The only way to approximate this is to pass three distinct objects, which internally point to the same connection, which I think you'll agree is very misleading, because they may point to the same connection, or they may not, this is not communicated in the signature, and can't be enforced, and you don't want hidden assumptions in your code: function (PsrSqlConn $conn, PsrSqlGenerators $gen, PsrSqlTransactions $trans) {} Until we can ask for an object which implements all interfaces we need, instead of just one interface, we won't be able to truly segregate them, because it's not realistic for an object to need just *one* of them at a time in many cases. It's also not realistic to have declared interfaces that combine all possible "simple" interface combinations that one may need (the more simple interfaces we have, the more combinations). Fix PHP, and the PSRs will become better.
You will *not* be able to write a single adapter for all possible PSR-6 implementations, because of what I just said. The only thing you'll accomplish by doing so is shutting up the parser. In practice, when you violate the ISP, you're going to find that people implement only the parts of the interfaces that satisfy their use cases. This is a huge red flag that you messed up in designing your interface.
Didn't npm 3 fix the long file name issues?
That might well be, I don't use npm a lot so I didn't check it out. Thanks for the tip.
You'll probably be safest if you just used [Gatekeeper](https://github.com/psecio/gatekeeper), but if you're trying to learn then a drop-in solution probably isn't very useful to the spirit of what you're trying to do. So instead, check out some blog posts that I've written on the subject: * [Secure PHP sessions](https://paragonie.com/blog/2015/04/fast-track-safe-and-secure-php-sessions) * [Basic cryptography concepts](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded) * [Designing a secure user authentication system, with "remember me" cookies](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence) At the very least, check out [LetsEncrypt](https://letsencrypt.org/).
&gt; TL;DR What would y'all like to see more of from me in 2016? I'd like to see if you can spend all of 2016 without saying anything about security. Just as a challenge.
Consumers of the interface can't get it. The pool can. And that's good because consumers don't need it, but the pool does.
Yeah but we have to consider how much time people have spent on this PSR. If I were these people I would go crazy, many PSRs have gone from draft to review to vote to review to draft so many times, and every time because of last minute things. That may not be a good response, but it's the least we owe people working on this project. &gt; Getting defensive right off the bat, and blaming me for Sorry. But in my defense, this is a bit what this article is towards authors of the PSR (that's what I feel at least). It could have been more constructive.
Very helpful, thanks for taking the time to respond.
[Greg Young - CQRS and Event Sourcing](https://www.youtube.com/watch?v=JHGkaShoyNs)
Considering that the $item is plain value, decorators might introduce complexity or having to rely on side-effects (global state). Adding a `$ttl = null` seems reasonably non-intrusive to me.
So I've been using RC1 for the past few months. What are the backwards incompatible breaks I need to be aware of? I saw some from RC1 -&gt; RC2 earlier but where are the ones for this?
Like this? https://github.com/php-cache/doctrine-bridge (shameless plug, but relevant to the post)
*Exactly* like this :) Thanks for making and sharing it!
I've recently come across this; http://programeveryday.com/post/message-queues-php-and-resque/ - although thats still a year old.
If its going to be required by the pool, why not put it on the interface
I don't see it in the sidebar and I don't see a moderator of this subreddit advertising it. What exactly makes it reddit-php/chat and not dracony's-shamelessly-advertised/chat?
Then perhaps, collectively, we (community) need to just ignore FIG from today onwards? 
Hurrah, great little framework. Glad it's released at last.
Or you know, just use something like a query builder.
https://github.com/slimphp/Slim/releases/tag/3.0.0
The name says "reddit-php", surely it's official... oh. I like the idea, but do we need *another* place to chat?
I actually wanted to put "official" in quotes, but somehow skipped that. Although I do feel it belongs in the sidebar
I'd say the most appealing feature to the enterprise world is the long-term support.
LTS, Symfony being partly is modeled after Spring, Dependency Injection Container, well defined application strucuture.
I've been on this subreddit for along time and you're the only recurring shitposter :3
I'm more in favor of posting helpful advice for whoever may need it. Difference of opinion. I choose to help others, you choose otherwise.
Are you?
I almost put something in like that, but I didn't want to overdo the example and potentially muddle the point. But yea, I know what you mean.
Disagree. Remember, this interface is for consumers, not implementers. Let's say you're building a library that needs to cache some data. Your library shouldn't care about TTLs. In fact, you don't want it to know about TTLs. Otherwise you'll have 700 different places that TTLs are managed. And they shouldn't need to know or care about it. So the backend would be a different interface, something like class MemcachedStore { public function set($key, $item, $ttl) { // ... } // ... } And then a decorator that controls the TTL but implements the cache system interface. class TTLAdapter implements Cache { public function __construct(BackendCache $cache, $ttl) { $this-&gt;ttl = $ttl; $this-&gt;cache = $cache; } public function set($key, $item) { return $this-&gt;cache-&gt;set($key, $item, $this-&gt;ttl); } //.. } So, when you create the library, you define the TTL by decorating the cache instance: $lib = new Lib(new TTLAdapter($cache, 60)); You can do the vast majority of what you could possibly need with these types of operations. The only thing you can't do is stampeed protection because there's no locking mechanism. But it's worth noting that you can't do that anyway with PSR-6 without implementing additional methods anyway. In short, your backend should know about TTLs. The frontend that actually does the details that requires caching shouldn't need to know or care. It's worth noting two things. First, the interface that /u/Rican7 posted here isn't the one that I made, he added another method (has) which I explicitly left off for a number of reasons. Second, I did a followup post talking about that design showing how you can solve all of the problems that PSR-6 tries to solve (and more) keeping things simple: [A follow up to an open letter to PHP-FIG](http://blog.ircmaxell.com/2014/10/a-followup-to-open-letter-to-php-fig.html)...
I did a followup that explained the common things people say about this sort of approach, with code demonstrations on how easy it is to work around. [A followup](http://blog.ircmaxell.com/2014/10/a-followup-to-open-letter-to-php-fig.html)...
Same here, even though I see great value in Behat (and I see it used more and more) it's lacking contributors a lot and it's worrying. The documentation with v3 is unfortunately still an issue.
Hi, I would store every computed value in database, this helps down the road when you need to report on those values or need to produce PDFs or just to have a piece in mind that the data is there and I do not need to worry to compute something. Size of the database is not the issue present days. Hope this helps.
So I can't call bullshit on unverified claims without subjecting my own views to your scrutiny?
PHP source code in PHP 7 undergoes three processes. 1. Tokenising (or *lexing*): source code text like `function foobar(int $a) { return 1 + $a; }` is broken up into pieces (*tokens*), e.g. `function`, `foobar`, `(`, `int`, `$a`, `)`, `{`, `return`, `1`, `+`, `$a`, `;` and `}` in this case. The lexer also attaches some metadata to each token, like the fact that `foobar` is an identifier, whereas `function` is a keyword, and it does things like replace escape sequences within string literals. 2. Parsing: PHP looks through the tokens one-by-one and matches patterns that form different structures in the language, and a "syntax tree" is built recursively. For example, a function declaration can be recognised by a `function` keyword, a name, an opening bracket, a list of parameters, a closing bracket, an opening curly brace, a list of statements, and a closing curly brace. Similarly, a list of parameters is an optional type declaration, a variable name, and optionally a comma followed by another list of parameters. And so on. So in our example, `1 + $a` is recognised to be a binary add operation with the operands `1` and `$a`. That operation is recognised to be the operand taken by the `return` statement. That return statement is recognised to be the single statement in the statement block that is the function body. `int $a` is recognised to be a parameter declaration of a variable with the name `$a` and type `int`, within the parameter list. The end result of this stage is something along the lines of this, an *abstract syntax tree* (this isn't a real PHP 7 one, those are a bit uglier): { type: 'function_decl', name: 'foobar', params: { type: 'function_param_list', children: [ { type: 'parameter', name: 'a', typehint: 'int' } ] } body: { type: 'statement_list', children: [ { type: 'return_statement', expression: { type: 'add', op1: { type: 'integer', value: 1 }, op2: { type: 'variable', name: 'a' } } } ] } } 3. Compilation: The abstract syntax tree is transformed into a linear list of *opcodes* which are what the VM actually runs. They're very simple instructions which can be executed in order. The opcodes making up the function [would look like this in PHP 5](https://3v4l.org/oHfBX/vld#tabs) (this is a text representation, not the actual C structures): line #* E I O op fetch ext return operands ------------------------------------------------------------------------------------- 3 0 E &gt; RECV !0 4 1 ADD ~0 1, !0 2 &gt; RETURN ~0 5 3* &gt; RETURN null The first opcode, `RECV`, receives the first argument passed to the function and stores it in `!0` (which represents `$a`). The second opcode, `ADD`, adds 1 to the contents of `$a` and stores it in `~0` (a temporary variable which holds results before they can go into actual variables). Then, `RETURN` makes the function return what's in `~0`. There's an extra `RETURN` because PHP always adds an implicit `return null;` at the end of the function. Okay, I hope that made sense. So what did PHP 7 change? Well, in PHP 5, there was no abstract syntax tree. Steps two and three were combined: PHP would immediately emit (add to the list) opcodes after recognising some feature in the list of tokens. That caused problems when we didn't have enough information, just from looking at the preceding tokens, to know what operations to emit, and lead to a lot of hacks in place just to get this to work. It meant, for instance, that we couldn't implement Python-style list comprehensions with `[$foo * 2 foreach($foos as $foo)]` syntax because, for that to work, we need to emit the opcodes for the beginning of a `foreach(...) {` loop before we emit the opcodes for `$foo * 2` (you can't use `$foo` if it's not been set yet), but this wasn't something possible in the old parser. Now, though, we can analyse and compile the result in whatever order we like, we're not bound by the order things come in.
I call bullshit on conclusions which differ from mine, regardless if /u/pmjones perceives them as positive or negative. What exactly prompted you to accuse me of a bias?
&gt; What exactly prompted you to accuse me of a bias? I'm not accusing you of it, I'm observing it. Specifically, the part where you didn't say "I liked the part where you provided examples for the claims you made" regarding the *positive* comments made before you replied to /u/beentrill90, to wit: - "I'd say the most appealing feature to the enterprise world is the long-term support." - "LTS, Symfony being partly is modeled after Spring, Dependency Injection Container, well defined application strucuture." They didn't provide examples for those claims; why not demand the same from them?
I don't know, why do you ask me?
Good summary, I'll add that Symfony has a great community. One that promotes good practices and design, and one that was the source of good things that happened the PHP ecosystem like composer.
The name and price of items, too, as those may change in future.
&gt;it shows a lot of common things that you would want to do But it doesn't... it's just a skeleton to quickly get a project started.
You've already wasted everyone's time.
&gt; I'm not accusing you of it I believe observing out loud is called accusing. I only need the arguments if I'm going to debate it and I was going to debate those claims, but without knowing why he feels that way I can't do much. I'm sure we can agree that the burden of proof is on him. I don't need anyone to elaborate on conclusions which I already agree with. I think it's up to those who disagree to request clarification or engage in debate. 
Isn't symfony more of a meta-component that also depends on external FOSS components like twig, doctrine and even its own symfony components? Instead of installing the full-fledged symfony, can I start my project by adding only few of these components to my `require` and build on as my needs expand?
Yeah, something like this $app-&gt;group('/users/', function() { include 'routes/users.php'; } But I was hoping for something more along the lines of $app-&gt;group('/users/', new Users\Routes()); 
Yeah, unless they're willing to exclude a good portion of the user base.
&gt; I recently learned that one of the very early iterations of PHP implemented loops by ftell'ing the start position and fseek'ing to it after the iteration. ... holy shit.
Of course you can. *Quod gratis asseritur, gratis negatur.*
You could do `$app-&gt;group('/users/', Users\defineRoutes());`
As soon as people start making the decision to write them.
They may have removed it from their PHP configs, but the language itself definitely supports it. 
They were not removed, It is just highly suggested by the PSR-1 that you do not use ```&lt;? ?&gt;``` and you only use ``` &lt;?php ?&gt; and &lt;?= ?&gt;``` but they were not removed. As someone else said your host manually disabled them, which does not deactivate ```&lt;?= ?&gt;```. So I could see how they could infer that the ```&lt;? ?&gt;``` tag has been unofficially "deprecated" though officially it has not.
&gt; But you'd have to either pass in the $app or create a new one in there and trick it into stripping off the group "prefix". Ah, hmm. You could get `Users\defineRoutes()` to return a closure, which Slim will then bind?
&gt; I don't see you having said anything that implies that. Your overall point is "implementations can be half-assed". No, my point is that the interfaces are poorly designed (by not being segregated), and as a result, adoption will suffer. It's a design problem, not a "people are lazy" problem. Poorly segregated interfaces result in half-assed implementations as a simple cause and effect. People aren't going to waste their time filling out functionality that they don't need, and asking them to is a sign that you don't understand your problem space very well and you've created a poor interface for it. &gt; Regarding the first, as I told you, you can't split one interface in 10 interfaces, because PHP lacks a mechanism for asking for a combination of those interfaces in a method signature. This is a problem with PHP, not with the proposed PSRs which have to match what PHP offers in terms of expressiveness. PHP supports multiple inheritance for interfaces, and it would be quite easy to properly segregate the interfaces along the well-defined functionality borders. As an example, using the glaringly obvious deferred save functionality that should be segregated: interface CacheItemPoolInterface { /* basic cache API */ } interface DeferredSaveInterface { /* deferred saving API */ } interface DeferredCacheItemPoolInterface extends CacheItemPoolInterface, DeferredSaveInterface {} EDIT: I should also note that it's my personal opinion that the latter two interfaces should ideally even be an entirely separate PSR. The FIG has this tendency *cough*PSR7*cough* to favor passing everything they can pass all in one go, rather than properly splitting out functionality. Many PHP RFCs died because of exactly this problem, and the FIG could learn a thing or three from that process.
&gt; Look me in the eye and tell me that there isn't going to be a massive amount of pressure for the Doctrine team to use this caching PSR instead of one that they like. I'll look you in the eye when I get back to Bristol in a few weeks (sounds romantic), but for now I'll just ask: From who is this pressure coming? The FIG? Nope. They do not have an enforcement agency, nor is there a requirement to do so in any bylaw. In fact them documents specifically say that you are not required. The PHP community at large? Maybe, but there is nothing the FIG can do about that. There is this constant conflation between "The FIG make you use it" and "The FIG makes standards that shitloads of people like so shitloads of people ask other projects to use it." &gt; Which is another way of saying that once a PSR is passed it becomes the one true way of doing stuff, even if it's not as good as other ways. Autoloading can be done in a bazillion different ways, but folks are pretty content with PSR-4 (other than the few squabbling fucks who want to use poor-mans namespaces forever like PHP 5.0 just came out). The masses regularly implement standards because it has advantages over every single implementation being a unique snowflake, even if that snowflake is really really pretty and awesome. 
I asked something like this: [Is any major framework (Symfony, ZF, Yii, Laravel, Phalcon) planning to use PHP7 type hints and return types?] (https://www.reddit.com/r/PHP/comments/3vbxk4/is_any_major_framework_symfony_zf_yii_laravel/) I got answers from Laravel and one member of ZF staff, and it seems only new frameworks will use it, since established frameworks can't take the risk of losing all the PHP 5 users they have due to BC break. Since PSRs are voted mostly by framework and library mantainers, i guess that even if they suggest it, it will be optional (all PSRs are optional anyway: "Projects have to consider backwards-compatibility issues when upgrading and make the changes at the right time", source: http://www.php-fig.org/faqs/#do-voting-members-have-to-comply-to-the-standards).
Actually, that is a very good point. Considering it's an interface, you could pass a `CacheItem` implementation from one lib to the pool implementation from another, which wouldn't work since the public API doesn't support getting the expiry date... // Edit: replied on list with this issue: https://groups.google.com/d/msg/php-fig/Qr4OxCf7J5Y/tYZoGsQ8CAAJ
I think this only works if your code base is already using Constructor or Setter Injection. As you can see in those other examples service-locating or using globals is likely a wide-spread practice in that code-base. What I wish paul went into a bit more detail is basic strategies to solve the problem rather than just pointing out what they are. The example is a perfect example, I have myself seen so many of those classes :)
I gave the answer to that further down in my last reply. There is a combination interface (multiple, actually). There is just not 1000, or whatever hyperbolic number you came up with, because you only divide on the major logical functionality boundaries, not every conceivable boundary.
Why would I want to see evidence in favor of a conclusion I happen to have already reached? I've used Symfony2 for 3 years. If you asked me what I feel about its design, I'd say it's pretty good. But somehow you expect me to scrutinize people who say that?
Laravel is based on Symfony. http://symfony.com/projects/laravel
Typo where it says "15" concurrent users, can be found throughout article ....must be missing zeros, I think.
Uhm it really was tested with 15 concurrent users... It was a siege so the point was to make sure all CPUs are occupied :)
It's not "hyperbolic", it's "combinatoric". It's math. It's objective. 10 interfaces, 1013 combinations.
I created a configuration container library a while ago that makes constructor configuration injection easier to manage. This goes against what Paul is advising though. If PHP had named parameters this wouldn't even be a thing. http://rtheunissen.github.io/config
Most people will have this mis-feature turned off nowadays. If you're sharing your code with the world, you should avoid using it.
haha, so true
That's pretty neat. Edit: `Configuration` could be type-hinted as a constructor parameter dependency. Or the constructor could accept an array which is then used to populate a `Configuration` object, if only for the validation and type-safety benefits.
Math is objective, but your use of it here is objectively hyperbolic. Not only are there not 10 interfaces, but most combinations of the ones there would be would make no sense. But you're smart, so I'm certain you knew this and were just going for added effect.
Did you bother testing it with higher loads?
I expect you to scrutinize *yourself*. You have admitted a bias; demanding evidence for claims that conflict with your priors is not "rational" or "logical", it is "cheerleading." Don't imagine yourself to be doing anything else.
Aura.Di 1.0 already incorporated injection of configuration values, so it's an old technique for me. ;-)
Freebie paul ;) give back to the community :D
I believe 20 months is adequate. I wouldn't oppose moving towards December (i.e. option 2), since PHP 7 wasn't available in August. I would be opposed to moving towards the end of 2018 for security-only patches. If the companies that *need* this extra year were paying everyone for their time to backport security fixes into PHP 5, that would be different. But so far, I haven't see anyone sign a check. So, instead, they should make supporting PHP 7 a priority and upgrade. The onus is on them.
I agree. Things are moving fast now and I think a year for active support and a year for security are sufficient. I oppose anything which will hold the language as a whole back for a few slow upgraders. (By hold back I am referring to the effort made to support the security releases for years to come).
On further reflection, if you watch [this free video](https://vimeo.com/47849625) (which led to me writing the book) and replace the word `global` with `getenv()`, `$_ENV`, `$_SERVER`, or `Config::get()`, the technique is exactly the same.
Given an admittedly brief inspection of the docs, I don't see the same kind of validation. I guess type-hinting scalar types in PHP 7 code would be a around-about sort of validation. Is there something in Aura.Di which lets me say what types a similar configuration object's parameters need to be? Seems like the uses for these libraries (Aura.Di and Config) are a little different...
ha, I love this.
And what to do when the number of configuration options exceeds what's reasonable to inject as separate parameters? Note that I fully support configuration injection, but parameterizing it can quickly become unwieldy and I haven't found a solution that doesn't make a concession one way or the other.
&gt; demanding evidence for claims that conflict with your priors It's called debating. If you make a claim that I don't agree with, I can either [tell you that you're wrong](https://www.reddit.com/r/PHP/comments/3vxdah/what_is_so_good_about_symfony_that_it_has_gained/cxrrcln) or I can ask you for evidence which I will either have to agree with or argue against. I'd say the latter is more constructive. Is that "logical" or "rational" enough for you? Why exactly are you quoting me words I haven't used once in the whole conversation? 
I installed 7 on the day it was released, along with imagick courtesy of the Remi repo. 5300 photos uploaded and processed since then, no problems at all.
Its really hard to see what 15 concurrent users actually looks like. Was it 15 in 1 second? 15 in 1 millisecond? Did all 15 requests respond in the same time? Or did the first one respond quicker, and the rest get longer? I find scatter plots better describe the effect of load on response times and errors: http://imgur.com/a/F0U7l (each dot is 1 http request, y axis is response time in seconds, red dots are connection failures)
It's called "debating" only when you present your own evidence. What you're doing is "cheerleading." And hey, that's fine! But don't think it's anything else.
Having worked with systems where I've had 8+ segregated interfaces for one type of object (my use of SQL examples is not incidental), I'd say I have the experience that proves that once you go this route, interfaces quickly pile up, and with that, all their combinations. And once again, there's no pragmatic reason whatsoever to split off deferred save, as it can be simply an alias to regular save for drivers that don't support it. You feel very strongly about this, but this is not about feelings but hard arguments, which you're sorely lacking. In any case, I've had enough of this pointless debate. If you don't like PSR-6, you can simply not use it. It's not mandatory.
Class that connects to a database is the perfect example of something which can have _a lot_ of parameters. Your example shows 5, but then there are also things like charset, port, socket (which is mutually exclusive with host + port), timeout, error mode... Many of these are part of the usual PDO DSN string, but some of them take the form of a parameter hash. And they are just to establish a connection to the database. Not something I would consider a divisible group of responsibilities... :)
They're called [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions), and according to Wikipedia both Wordpress and Symfony use them as part of their coding standards.
I love your focus on security, but some of the articles you have written aren't geared towards beginners, or those without a background in security. Maybe you could revisit some of your articles in a PHP 7 security essentials series?
It's up to you to define which of those things are necessary to compose your class. Do you *need* a charset, port, or socket in order to instantiate a connection object? If you do, do they *need* to always be defined by the user, or can you provide a common/suitable default and an API to change them?
I'll see if I can get a copy for work ;)
Is it always bad? What if you are using PHP as a template engine (√† la http://platesphp.com)? 
There is symfony as meta package that contains all of the components (symfony/symfony) and full-stack framework (symfony/symfony-standard) which uses only some of the components and also includes stuff like Doctrine by default.
Still trying to evade the fact that you're biased, and only demand evidence from people you disagree with, while allowing non-evidentiary claims from your own tribe to go unchallenged. Look, here's your pom-poms ... (/me picks up pom-poms and throws them to /u/Pardalean) ... there you go. You can even have the last word here. Have fun cheerleading!
I'd rather live with a big constructor, but I'll admit that I often fall back to an array or object. Unless it's a factory, you can get away with passing in preconfigured objects as well, which I greatly prefer to the other methods.
&gt; Cf. the last example, where you have a configuration object. Right; the article just read like you weren't in favor of this strategy. And when there's a reasonably small number of options to configure (and you're fairly certain it won't grow over time), I agree that they should ideally be split out and injected separately like standard dependencies. &gt; Further, I'll opine that if you need "too many" configuration options, perhaps it's time to split that class into separate concerns, and compose them. Sure, this can definitely be a red flag for SRP violations in some cases, but there are also just some things that are *very* configurable. Rather than a generic "Config" class, which I would agree is more or less similar to service location, what I usually prefer is a contextually-scoped DTOish class where the options are first-class parts of the interface: public function __construct(DbConfig $config) { $this-&gt;host = $config-&gt;getHost(); // ... } It's not perfect, but it seems marginally better than other options to me in the cases where the options can grow over time and would make for a cringe-worthy method signature, anyway.
It's a standard siege... "siege -b -t 1M"
So that's what you wanted, the last word? &gt; allowing claims from your own tribe to go unchallenged Claims which I think are true. If that guy said Symfony2 was the fastest then I'd want to see some benchmarks and I'd have some salt ready for when he provided them. Did I prevent you from challenging "my tribe", at any point? If you wanted that debate so baldy why didn't you ask me what makes Symfony2's design so good? &gt; Look, here's your pom-poms ... (/me picks up pom-poms and throws them to /u/Pardalean ) ... there you go. You can even have the last word here. Have fun cheerleading! You really lost it at this point. So Freudian of you to bring up emotions earlier. 
This is a misnomer. Symfony *components* are not Symfony the *framework*. Laravel is based on Symfony *components* only, and even then, it re-wraps them to expose its own API. Someone working in Laravel will rarely touch anything remotely Symfony related, directly. The question of "what's so good about Symfony" doesn't really apply when talking about the components that Laravel wraps. 
I didn't believe it either, that's why I re-created everything twice and got the same results. I even played around with the internal caching stuff, no change. I will try it with less posts (or maybe even no posts at all at first).
prepare for it not to see usage among key players and be largely ignored
What
I find the short opening tag quite nice. I fail to see what is so wrong with it. Especially when the &lt;?= will be enabled by default. In any case a quick sed command corrects it. 
We aren't, and I'm not sure where you're getting the impression otherwise.
Well you make an interetsing point, but dont think it is a big problem. Your configuration values are in general constants(and if they are not, you have probably designed it wrong in the first place), and constants do not suffer from the pitfalls of for globalness or dependency as variables do. We often say global state is bad, but by this we mean global 'mutable' state. In PHP a constant is effectively global, even class constants are simply namespaced global constants. This is not an issue though, as you are sure the state is immutable and you cannot make accidental assignment mistakes. If you look into the bigger picture, a class in PHP is also global, you just have to import it with the use statement, and then it's available everywhere. But since in PHP you cannot alter a class, no one has a problem with this globalness. I dont see the benefits of passing a configuration object into constructor of your database object, as compared to just use class constants such as DBConfig::Type, DBConfig::Host, DBConfig::User, etc. Unless your configuration object actually does a lot more than just exposing constant values, which Id say your configuration class itself is doing more than it should and breaking SRP. 
Yup! You can now even use the `MicroKernelTrait` which lets you build a stupid simple app, that can still use external bundles and what not. http://knpuniversity.com/screencast/new-in-symfony3/micro-kernel
It's not nearly as bad as a few people are claiming, and lets not forget the amount of blowback there was against the autoloading standard and the coding style standards which are now generally well accepted.
I honestly think you are a little too close to the PSR to have an un-biased opinion.
Having used both, I think the Symfony documentation is much better than ZF2. That goes for both the official docs ("The Book") and the quality of blog posts, eBooks etc.
They are stupid IMO. If you can remember to put the arguments round the other way, you can remember to write ==. It also doesn't protect against the `$var1 = $var2` scenario. I haven't accidentally used = for years. 
The problem with the short opening tag is that certain other formats e.g. `&lt;?xml` will be parsed by it. This is the primary reason the short open tag is discouraged. (For what it's worth, `&lt;?=` is *not* affected by the INI setting and is still considered safe to use.)
Ah, so this is when PSR starts it's decline. Happened sooner than I thought. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/thepopcornstand] [Pardalean comments on What is so good about Symfony that it has gained so much popularity in the enterprise world?](https://np.reddit.com/r/ThePopcornStand/comments/3w0tup/pardalean_comments_on_what_is_so_good_about/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
TTLs are often content specific and end up getting managed in the app. Usually with a few, maybe three or four, buckets like short, medium, long and "forever". The consumer must have the ability to know about, and tune, TTLs because they are tuned by data sensitivity to going stale and usability concerns about stale data and other consumer side factors.
It's kind of thrilling and terrifying at the same time. You have to wonder what most people would say if they knew how fragile all of this was. 
The info is strong with this question.
What do you mean? I havent really used other languages with web based applications, but it's so you can get variables from the url. For example, do you want to send a mass email to all of clients? And put an unsubscribe link at the bottom of the email? You can just link to www.yoursite.com/unsub.php?email=emailaddress .. and it will unsubscribe them. Instead of making the client go to the site, enter their email etc.
&gt; Some caches don't support native multiple-item commands, and emulating it in userland is a great example of a leaky abstraction with real world consequences (now I have to be aware that part of my interface is vulnerable to difficult to debug race conditions based on what driver I choose, and be mindful of it in how I design my software) *What* race conditions? &gt; Similar problems exist for emulated deferred saves, as the queue/flush pattern implies a certain behavior that isn't being respected under the covers and can produce bugs a la emulated commits in DBALs. The behavior, as documented, is "MAY delay". *What* bugs exactly are you talking about? There are no race conditions and bugs in saving items one by one on a multi-set, or not deferring a deferred save. A cache should be used to scale only reads, unless the data being cached is immutable (i.e. value for one key will never be set to another value). I'm starting to suspect you're using caching services as a database for persistent storage of canonical state... which is a major abuse of a cache service. Caching implies a certain (lack of) guarantees about stored data: 1. No transactions and conflict resolution. Last writer wins, where last writer may be defined arbitrarily in a concurrent environment. 2. Data may arbitrarily be deleted as memory goes full, least used, or oldest values are collected, and a number of other criteria causes them to be deleted (say once a day at 3AM, everything gets purged, why not...). 3. You shouldn't trust data in cache is fresh, because you're unable to invalidate it immediately as it goes stale, unless the data you store is immutable (one key is used to store one specific value and nothing else, for ex. keys with a version), which means it can't go stale by definition. This means that mutable cache values are only useful for scaling reads in an eventually consistent way, as you can't rely on them for anything else. And immutable ones automatically rules out state/writer conflicts, so there *can't be* race conditions.
POST is no more secure than GET, they are both client side values.
[removed]
&gt; other clients will be able to see some updated keys but not others. Any scenario in which those keys must exist separately but remain in sync requires atomic multi-writes. Quote to me where PSR-6 promises atomicity in multi-set. Or did you just pull that out of your behind. Multi-set is purely an optimization feature, and it's advertised as such. If you want atomicity for a set of values, write an associative array under a single key. Not only is atomicity across keys not ensured, but you should fully expect that after you "multi-set" a bunch of values, *some* of them may get evicted from memory and the rest may remain. Which means when you fetch back that set, you should expect only *some* of the keys to be there. That's part of the contract of a caching service. Every key-val pair in a cache must be disposable, otherwise it's not "cache", it's "state". Confusing both would lead to a lot of sadness in your projects, so don't do it. &gt; The overwhelming and obvious expectation out of a queue/flush API is that it should function exactly as advertised: writes are queued up until you flush. There's no such expectation, and there's no explicit queue, there's no explicit flush in the caching interface. You're confusing a cache service for a Doctrine-like ORM. The documentation simply says a deferred write may be deferred. And the rest of your expectations you're pulling, again, out of your behind. I suspect you're thinking about transactions, but deferred writes are more analogous to INSERT DELAYED in MySQL. Read how that works, and why it exists.
You are completely wrong, ie why you are working in go now a days? ;-) . So you are not benefited :-) .
Considering that just barely half of FIG voted in favor, I am very interested to see what the outcome will be.
&gt; It's rather amazing it worked at all. There's a reason /r/lolphp has ~4.7k subscribers and /r/loljava and /r/lolruby have ~40. (And /r/lolpython has *five*)
Please go read the RFCs and look for the word "idempotent". If you're changing a resource based on a GET to it, then you're doing it wrong at the most very basic level.
Wait, what kind of beer?
Rename "Config" to "Context" and we're finally on the same page after a year of back and forth about it. **EDIT:** And we'll need to replace the generic get($string) method with getSomethingSpecific() methods.
&gt; Please go read the RFCs and look for the word "idempotent". Nullipotent, but anyway. [Insert fancy word here].
Not sure if there are any breaking changes that affect it, but Rob Allen has a slightly more involved example [here](https://github.com/akrabat/slim-bookshelf) based on RC2.
here's some documentation on how to build a framework on top of the symfony components http://symfony.com/doc/current/create_framework/index.html . It steps through implementing it with plain php and then adding symfony stuff to it.
How is it unusable ? People pointed out some problems and for the most part those have been addressed over the last weeks. It may not be perfect but it is certainly usuable.
I agree completely, compannies/people had had enough time to check if their application/framework worked correctly under PHP7, considering that PHP7 has a lot less major breaks than php 4 -&gt; 5, 5.2 -&gt; 5.3, I think they should focus on developping php 7.1. (I can't wait for async!)
In case someone isn't in the know, sphinx search is f***ing awesome and fffast.
PHP5 was released in 2004. Wide scale PHP5 adoption, however, didn't happen much until the GoPHP5 initiative in 2008. PHP5.6 wont go EOL until August 2017. I expect it will take at least a year after that until I can safely use PHP7 as the minimum version without abandoning large audiences.
The cider kind
There are two hard problems in computer science, naming things, cache invalidation and off-by-one errors.
PhpStorm or Sublime Text 3 with some plugins. Even Netbeans is better than Eclipse...for me was very slow even with a very good system .
Negative, just straight application. I never really got the use of that other stuff, haha. Komodo Edit by itself does all of the highlighting and dropdown of functions (most of the time), syntax check / debugging I use a browser :)
Short open tags ( &lt;? instead of &lt;?php at the start of your script ) aren't the same as short echo tags &lt;?= $x ?&gt; encouraged by some templating engines. Rasmus Lerdorf himself has said it's safe to use the latter. The docs also say: &gt; Note: This directive also affected the shorthand &lt;?= before PHP 5.4.0, which is identical to &lt;? echo. Use of this shortcut required short_open_tag to be on. **Since PHP 5.4.0, &lt;?= is always available.**
Thanks for your comment. I have seen netbeans being mentioned before. But aren't we comparing apples and pears? Sublime and Komodo are editors and PHPStorm, Eclipse and Netbeans IDEs. Or are we saying that with all the plugins that are available for the editors that they are becoming an IDE as well?
&gt; +1 from PHPixie &gt; Let's push it out the door finally :P And from this discussion &gt; At any rate its better to have one out there anyway. A quality vote from a PHP-FIG member.
With the right plugins Sublime is almost as good as PhpStorm , you can have the Xdebug for debugging , auto formatting , PSR4 correction ...and so one.
Who the hell cares..
You know you can use a framework or not use a framework, don't you? If you want to do it all your own way, you can sit over there and carry on. Me, I'll be focusing on the business needs and bolting together tried, tested, accepted and supported components to do that in frameworks that allow me to focus on the business needs.
["6" certainly is.](https://20poorandfabulous.files.wordpress.com/2012/01/84449.jpg)
If a basic editor fits your needs you are not looking for an IDE. Then you can also just go with Sublime or whatever. Because then you don't even utilise what an IDE like PHPStorm or eclipse has to offer. I used eclipse for many years before I went to PHPStorm and I can say that FTP editing is the absolute HORROR. Every time you click on the file tree the application freezes for 5 seconds or so. Don't even dare to do a right click on the file. Sometimes you get upload errors such as "unable to close upload stream" or "file time could not be set". Then you have the code editor, the most important part basically. Also here eclipse cannot really shine. It somewhat has type hinting but it is not really good. Very often cases you get nothing if you write "-&gt;" and you can't even enforce hinting yourself without chunks of PHPDoc blocks above variables. The only times I have seen PHPStorm failing performance wise is on large (10k+ lines) because there the editor gets really laggy even if you turn of code inspection. Surprisingly eclipse's editor has no problem with large files, but well, the code hinting sucks anyways.
I suppose that PHP5 is your current choice for production. Typing *php* in console will run a script using PHP5. When you want to test certain script with PHP7 runtime, the *scl* command will reconfigure your current console (probably *PATH* environment variable), so that typing *php* you will run PHP7 instead of default PHP5.
Well.... The advice you mention for exceptions has some merit. In general, business logic requirements should not throw exceptions for instance unless the current state represents an exceptional state like bad/corrupt data.
Thanks for your comment. Good point that if an editor fills your needs then you're not looking for an IDE then again maybe some do not realize the benefits an IDE can offer. I've had similar experience with the code hinting in Eclipse. Let's see if there are developers out there who prefer Eclipse.
A recent one https://github.com/Bacon/BaconPdf . The docs are still missing :-/ . May be you want to figure out.
&gt; has some merit And &gt; in general I think I was very clear that my statement was not a universal constant. The person I replied to implied the advice had no merit. So, again, what's "too limited" about my statement exactly since I wasn't, and specifically hedged against, saying it was a constant?
After every vote for a PSR they don't like somebody wants to change how the voting works, that's a sad but regular occurrence. There are some big projects people like that don't actually do anything, and there are some small projects which do a shitload of work. It's hard to point fingers on who should go and who should stay. &gt; I think bundling the valid criticism of the proposal with the one or two people saying "THE END OF DAYS for the FIG" is a bit of a straw man. I didn't bundle, and I think that's a misuse of the term strawman. If I could try my first sentence again with what - to me - is the same, but more verbose wording, it would be: Some people like this, some people don't. Some people have blogged a few valid concerns (which have been known by the FIG and everyone else who has been paying attention) - for years. Many of these issues are not a huge deal, and will not stop the PSR from functioning. Sadly, lots of people have blogged some utter nonsense, and either way this really does not matter in the long run. People always moan, then it turns out to be fine, or we replace it. The FIG will go on, and some people having a grump about it _as always_ is not a large issue. Even if you hate this PSR, and don't use it, you don't need to bemoan the FIG in general. A lot of people may have switched off from this PSR, but better attention has been paid to other modern PSRs for sure. Consider this the shitty halloween special for your favourite show, which will get back to normal next week.
Hey, I've seen people use a "throw new exception" as essentially an alternative return statement. 
... because micro-optimizations. Nonsense.
When you post some data to a Repository the save() method may fail due to various reasons. A code that does this try { $repository-&gt;persist($data); } catch (ValidationException $e) { } catch (StorageWriteException $e { } would be valid, right? Getting the same behavior without exceptions would require more work. The persist method would have to return a 'response'-like object (with status, messages etc).
Never seen any of these, but yeah, would be a bit of a shock to see someone short-circuit a for loop in that way jus to avoid length overhead. On the other hand if you read one of those trivial examples and you don't get it, you probably should not be working on that piece of code... I can also think, now you've shown this of examples where it would be a great control flow modifier. Find first exception and fail out of a loop is great if you want to test a piece of code for a complex problem for viability before deploying that piece of code (think unit testing); I think it just has little to no place in a production application. 
Thanks to Composer, the FIG (for example) could offer PHP 7.0 alternatives to its interfaces right now, and leave the old versions sat around for older PHP users.
I use Eclipse because I only want one IDE, and Eclipse works great with java and python, which are my other two primary languages.
Thanks for your comment. Fair point Eclipse supports many different languages.
I take exception to this article
Just committed this - https://github.com/m1/vars#environment-variables Couldn't really think of a way of doing it other than adding them as another replacement variable option.
Your example is atually the correct use of exceptions, the article is not against these obviously
Oh cock, I'll have to abandon [my project about Exception Based Programming](http://e-mats.org/resources/ExceptionBasedProgramming.php.txt). :(
(Nice to see you Tanks. ;-) Note that I say specifically it's a second-best solution, to be avoided so one is not tempted to put too much into it. Want to avoid anything resembling a service locator, after all.
Or apostrophes. Fuck apostrophes.
I used Eclipse for years, but am currently using Netbeans. It was really a perfect storm of issues that made me switch. At the time I was working primarily 2 projects. On one of those all the other devs were using Netbeans. The other was a Magento project, and quite often Eclipse would die on me while working (lock up, crash, etc.). The former was not real reason to switch by itself and the latter was likely just an issue with my installation. The third issue, which just became un-workable, was a lack of editor support for SCSS. Honestly, as soon as someone makes a good SCSS plugin I will likely switch back.
I agree with what you're saying about the big inactive and the harder working smaller projects. I think the current secretary proposal is a good one which will help make the inactive projects take more of an interest. What I meant was that the group of people who think that the cache proposal spells the end days for the FIG is the "straw man". Most of the people I have seen raising concerns appreciate the hard work done by the FIG, take an active interest in the project and want it to continue making good standards that help the community. I feel that your original comment is a good argument against people who moan for the sake of it and take objection against everything they come across (they do exist), but doesn't have much relevance to those who think that this proposal could have (and should have) been improved. Whilst I accept the "don't like it, don't use it" approach, I also think that a key benefit of the standards created by the FIG is that they are definitive. Encouraging a situation where there are multiple competing standards (especially when they can be easily fixed) is unnecessary and counter productive. The only blogs that I'm aware of on PSR-6 are by tedivm (explaining the proposal), by ircmaxell (on keeping it simple) and by me (explaining issues that somebody else posted in the mailing list very recently). I'm not sure if there are other posts that you are referring to as "utter nonsense", but at the moment I'm guessing that you're referring to mine? I don't mind, I'm just trying to understand what you're referring to and whether you accept the problems that the post mentions or not? I apologise if they do come across as moans/nonsense/winging/etc, but the intention was only ever to expose issues that had been raised on the mailing list late in the process. I retracted the first point of the post (about the votes of Laravel, Doctrine and Guzzle) after speaking with Larry and seeing his response (I also made his response as public as I could). I still regard the other two points as significant unresolved issues. Earlier today ircmaxell wrote a post expanding further consequences that follow from requiring implementations to supplement the specification with their own public methods (https://groups.google.com/d/msg/php-fig/Qr4OxCf7J5Y/tYZoGsQ8CAAJ). As you've said, we'll have to leave time to tell the ultimate fate of the proposal now that it has passed. I understand that your profile means that you're exposed to a lot of the moaning about the FIG on a daily basis. However, a lot of the criticism of PSR-6 is important and shouldn't be brushed off as just baseless complaint.
&gt; Note that I say specifically it's a second-best solution, to be avoided so one is not tempted to put too much into it. You'd think "too much" is defined as "inappropriately combined responsibilities" and *not* as in "more than 3 options", which is about when positional arguments become hard to follow. And "inappropriately combined responsibilities" is not directly related to the number of your config options. So what does "too much" mean here? How much is "too much" and more importantly: **why**? Or are we just trying to dumb the rule down, because the correct advice is too complex to articulate to the dumb masses? &gt; Want to avoid anything resembling a service locator, after all. Right, right, latent service locators are everywhere. Plotting an attack on our codebases. We'll see what you're thinking in a year. Or two. I'm patient.
I'm using both in production (on the same box) at the moment, simply by setting the fpms up on different ports, 9000 and 9001. For command line I ran `'ln -s /usr/bin/php70 /usr/bin/php (My 5.6 is also now a scl, so that resides under /usr/bin/php56, if I need it for anything. Any downsides to this approach?
Atom is a nice free open source editor I've used it for a while and still have it installed on my laptop but found installing the plugins (linters) a bit cumbersome and it crashed on me a few times but it was some time ago. As LMBH said "If a basic editor fits your needs you are not looking for an IDE" when you do not need all the additional functionality of an IDE you're probably better off with an editor like Atom. Thanks for your comment
If you think you can learn something from the course and your company is going to pay for it there is very little reason not to take it. 
You missed the bit where I said there are some valid concerns, and then you're pointing out some of them, but surrounding it with a lot of **nope.** &gt; If FIG member projects adopt this, it means that anyone who uses those projects are forced to use this API. Nope, you can by all means ignore core parts of a framework if you hate it that much. You can build wrappers if using it just makes you want to cry. &gt; The issue here is that it's a measurably bad design. Without getExpires() functionality on Item, it means that there has to be a hidden (non-interface defined) method to communicate between the Item and Pool. However, the pool's save() method types against the Item interface. Meaning that you by definition need to access methods outside of the type you've declared. This is not only dangerous, but is objectively a bad design. Right, but any extra methods that crop up in popular usage get to be part of a new and improved PSR. You can't cater for everything. You shouldn't try to do everything. Isn't this whats been said over and over and over? &gt; You're projecting what you think is happening on the discussion, then seeing evidence to back it up. That's not what people are saying. They are raising REAL issues, measurable issues, which are being literally ignored Some people have valid concerns but there is a lot of fucking nonsense mixed in. I'm talking about them, not you. &gt; It is the end of days for FIG. Not because they are going into obscurity, but because they are demonstrating that they don't care about the one bloody thing that sets the FIG apart from the rest of the community: The ability to lead. FIG has(had) a real chance of being a unifying force. Of being something that brought the community together and led it. If one bad episode killed every TV show then some of my favourite shows wouldn't be around. &gt; Yet all you've done is say "we only make standards for ourselves". Because that is the objective goal of the FIG. It's not a cop out to state the fucking fundamental goal. People either moan that the FIG is trying to force code down everyones throat, or complain that it is not trying to jam it down everyones throat. You can't win. If Drupal decides that the Cache PSR will work for them and their needs, and implement it, then it was as success. If you as a Drupal user hate it so much that no amount of wrapping or ignoring will work for you then you won't use Drupal, just like being forced to work with some core classes that you HATE that don't have a PSR. This idea that because the FIG is responsible for everyone who uses any sort of framework or component or anything is absolute bunk. The implementing projects get a choice about whether or not they want to implement the standard, and they do so intelligently, knowing the pros and cons. The projects are responsible for forcing it upon their userbase, not the FIG. What I'm saying is: If projects vote in a piece of shit, then decide to throw that piece of shit at their users, it's the projects fault. If the projects vote in a piece of shit, then decide not to use that piece of shit, then that was kinda annoying and they probably shouldn't have voted it in, and it's still the projects fault. If the projects vote in something that does the job for their use cases, then it's clearly not a piece of shit, because it solves their use cases. &gt; Rather than constantly fighting these "naysayers", perhaps it's worth trying to understand what they are talking about. If one person is constantly ranting, perhaps they are crazy. When it's literally 50 people, perhaps they aren't the crazy ones. Perhaps it's time to stop and reflect and see if they really may have a point. I've seen about 5 people raise valid concerns, not 50. The vast majority of people have just been wanging on about nonsense instead. One historic example: with PSR-0 deprecation, somebody was [adamantly against it](https://marktrapp.com/blog/2014/02/14/psr-0-should-not-be-deprecated/), then ended up agreeing once I explained what deprecation actually meant. People just don't get stuff then moan about it. Again, I didn't say "nobody had a valid concern", you absolutely have some, but whether or not they are going to be a big deal down the line is what I'm asking people to wait and see on. As /u/AndrewCarterUK said: &gt; Most people who have voiced concern probably hold the opinion that it's not catastrophic and it will work, but it has flaws that are not insignificant and could be better. I'm saying lets not flip our collective shits just because it "could be better", and use those as notes for a replacement in a few years when we have some more learnings. If this PSR is no good it won't be implemented by many projects and the whole thing is moot. 
Oh, right! You could make the 7 support be its own version. Now I see.
&gt; somebody wants to change how the voting works I find this self-referential comment hilarious. :-)
I can build a wrapper‚Ä¶ but then the wrapper needs to use the API. Also, I'll need to put an annoying wrapper at every single entry point. Also‚Ä¶ A wrapper isn't a solution, it's a shitty workaround. I prefer to not use something at all I hate. But I don't have this choice because everyone else uses it and I want to be compatible with them. Also, imagine we'd put a wrapper around it, each time we are passed it in‚Ä¶ we'll get a very deep nesting for each time an object is passed between two different libs. That's architectural bullshit. We should definitely not go for everything, but we should make an interface self-contained, so that, when we have a Pool and Item, these interfaces provide the foundations to make them interact. It's not like you only will have one cache, but there might be more caches (different targets/backends) and you want to shift an Item from one cache to another (or duplicate in a more local cache). Now, the RedisCacheItem won't be compatible with the FileCachePool. ‚Ä¶ because the FileCachePool can't access the expiry time of the RedisCacheItem, because it only knows about the interfaces method and not the concrete methods (after all, they shouldn't be coupled by the concrete impls, that's what interfaces are for). The expiry time is somewhat coupled state nobody else can access. That's bad. Yeah, some things are maybe non-sense, but there are always valid concerns. Don't discard the concerns because of the other non-sense. It's not just one bad episode, but we're already at at least number two (I consider the HTTP one already not very good (let's not discuss this here, just noting)), now this one and it's getting worse. The FIG is responsible, by providing a low-hanging fruit for framework developers who in turn impose the PSRs on their userbase. And once approved shit is usually also faster passed through than non-approved shit. Also, as /u/ircmaxell said, people tend to follow PSRs blindly. And the FIG definitely has some responsibilities there to make the blind followers not follow bullshit. We don't live in the idealized world where everyone deeply re-evaluates everything he's going to take over. You _can_ compare this to any network protocol RFC. The RFC provides one standard, and everyone implements it, with all of its errors, just to reach the largest possible userbase. There are sometimes extensions, but the basic protocol/interface is always at the core. Same here with the interfaces. **If** you want to reach a large userbase, you need a common interface. That's what FIG is providing. And it should provide them on a basis everyone agrees. And not just a 66% majority of some framework devs. Have a quorum of 80% and less than 10% no-votes. Then you can say that it's truly an interoperable standard. But this‚Ä¶ no. I'm not saying you should reach for the 100%, but you definitely should for 90% or more. 66% is not enough collective agreement to put it out as official standard. I seriously think, a bad PSR does more harm than none at all, just because of the people who will adopt it. STOP saying they have the choice. Sure, they do, but they won't use their possibilities of choosing because standard. You always can have some interface you mutually agree on, but it shouldn't be a standard if you don't all agree with a very large consensus. You don't need PSRs for this. Maybe you say, this is the role of FIG: creating interfaces for some of their users, anyone who wants can join. But this is not as what FIG is perceived. You have some power to create true standards for everyone. It's the image I had of FIG until now. Creating standards nearly everyone agrees on, are sane and interoperable. And sadly, PSR 6 (and PSR 7 to some extent) definitely is not in this category. And that's why FIG is on the way to its death bed.
 That is kinda my reason to take it too. They are offering me a chance to understand how a certain framework works since they will have me working on an already delivered product. The problem I'm facing is finding a good course that covers the MVC framework in PHP so that I can use that on this project as well as the certification that the course will give us, in future assignments.
MVC isn't basics, smartui is basics, and you don't have MVC on the backend. You have MVA or Model2.
Sounds legit. Where is the thread where people said GTFO instead of trying to fix it? 
Since 5.4, yeah.
You can put phpstorm in to Power Save Mode, this is in the File menu in the mac. I don't remember all that this entails, but I believe it will stop auto completion.
Maybe PHP needs a new group "PHP Standards Body" with the goals of "We'll kick you in the jiggly bits and knock out your kneecaps if you don't use this code". Again though, reading all of your reply, here is some text from the FIG FAQ: &gt; **What are the aims of the PHP-FIG?** &gt; The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together. Our main audience is each other, but we‚Äôre very aware that the rest of the PHP community is watching. If other folks want to adopt what we‚Äôre doing they are welcome to do so, but that is not the aim. Nobody in the group wants to tell you, as a programmer, how to build your application. Maybe the goals should change, but I am arguing what it is and what it does, as that is what I believe it should be doing. Unless the project gets members who are incentivized much much much more heavily, they won't be able to put the amount of time and effort in place to make it the standards body you want, with the "this will work forever" quality of standards. A standard that gets the job done well enough to solve the needs of those projects involved, and the users of those projects, sounds like a pretty good goal to me, compared to what PHP used to be doing: 1000 (often rather shitty) unique snowflake implementations of the same thing. For now, it's a group of people solving their own needs, and some folks like it enough to use. I get where you're coming from, but it can't be what you want without donations or something. I was dedicating an hour or two to PSR-4 a day, and that was only possible because my company was going bankrupt and I had some time on my hands.
I'm not discounting valid concerns, I know several and so far none of them have me paniced. I've been involved in trying to make the existing FIGers involved try to listen to Anthony and facilitated a few conversations about potential alternatives over the years. I've been involved, and I've seen improvements happen. What's left is meh. As for the rest, I think my reply to Anthony says it well. https://www.reddit.com/r/PHP/comments/3vzvxo/psr6_the_vote_for_psr6_has_passed_in_favor_of/cxsyn6k
It's ok, people just didn't get your joke.
Something like [php-dotenv](https://github.com/josegonzalez/php-dotenv) would be nicer, which allows you to load from `.env` files
Thanks, but that doesn't have enough routes to need splitting up. This old blog post suggests just putting them in separate files and including them in a main routes files. I guess that makes sense. Maybe I'm trying to make things more complicated than they need to be. http://www.slimframework.com/2011/09/24/how-to-organize-a-large-slim-framework-application.html
https://groups.google.com/forum/?utm_medium=email&amp;utm_source=footer#!msg/php-fig/Qr4OxCf7J5Y/OVzzM3rOBwAJ is the thread where it surfaced. Crell explained why it isn't in. IMO the explanation does not make much sense as I can't see a scenario where the pool and item won't need to communicate this. So every impl will need this `if()` as far as I can tell, or just assume it'll be passed the right stuff and all is well, which is fair enough but still sounds a bit odd to me. The one thing I see in favor of the current state of things is that users shouldn't really expect to be able to read the expiration back as doing so would make the cache impls much slower and I assume some backends can't even do it. So having that in the interface would need to come with a big fat warning and a possible null return value or @throws. Anyway it's done it's done so I guess we'll have to live with it or supersede it in a new PSR. It's not the end of the world.
It's maybe in the FAQ, but you're then still having a much stronger effect than anticipated. Also, this tweet sums it up: https://twitter.com/rdlowrey/status/674626923646091264 It's just, we started off with PSR-0 and PSR-4, which are essentially fundamental and pretty much adopted by every single library out there. These are true standards. And then come these "framework standards" 6 and 7‚Ä¶ Also, a good interface don't make 1000 shitty implementations good. It just may improve the core API. If you want a good implementation for a same thing, you need a single great implementation, not an interface for 1000 shitty implementations or a PSR. ‚Ä¶ Or you are a student and have plenty of time ;-)
[**@rdlowrey**](https://twitter.com/rdlowrey/) &gt; [2015-12-09 16:29 UTC](https://twitter.com/rdlowrey/status/674626923646091264) &gt; When you recognize that "PSR" is a misnomer and they're all actually FSRs (framework standards) the arguments become pretty unimportant. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I'm using Eclipse PDT for about 3 years and still very satisfied. And it is not slow, at least when compared to PHPStorm.
Also, consider that group members themselves are talking about the groups ["Perceived Authority in the community"](https://groups.google.com/d/msg/php-fig/7sO6ovPV2Y0/OzPDoAyACAAJ). Tell me that's not counter to the goals you so explicitly state here that you're not trying to be authoritative...
&gt; Instead of constantly marginalizing people who don't share identical views, perhaps listening to them can work. Ok fuck this straight off the bat. You are missing my point. When I say "Lots of people are talking nonsense" I mean people are just making unfounded shitty empty statements and moaning about things that literally don't matter. Saying "lots of people are talking nonsense" that doesn't mean "Everyone who disagrees with me is talking nonsense" and it doesn't mean that you are. I have named you as an exception plenty of times. As an addition to that, even those with legitimate concerns (yourself and a few on the ML), whether they are big enough to warrant overturning a PSR, the death of the FIG, or mass panic in general remains to be seen. I'm asking people to calm down and let the PSR play before freaking out, for the various reasons already mentioned. &gt; As far as funding, if FIG would step up and show that it wanted to be a respected organization that looked out for more than its own interests and actually uphold itself to some level of quality, then money would be there. There are enough people who would support it. Well thats a lovely idea and all but in reality that equates to saying: People should put in 10x more time and take longer than 4 years to build a standard for a project that they're on the open-source team for, which they might not be on by the time the standard is finished, without any help or motivation to do so. This is not realistic. You're basically setting up a false dichotomy where there are two options: 1. Become a much much bigger standards body where standards are agonized over for a decade and then written into stone forever 2. The FIG will die Where the FIG is now is half way between that. Nobody is smashing out standards they think are shit because v2.0 is down the line, but I am saying we can build a standard in a few years which will be used by that team, and quirks and problems will be noticed and removed in a replacement like PSR-0/4. &gt; And how many times have I steered the group wrong? How many times have I raised issues that turned out to be complete and utter bullshit? How many times have I tried to contribute and just shat upon? Can I approach it better? Perhaps. Have I at least earned enough respect to not just be brushed aside? I think so. Yet that's what happened every single time I raised an issue in FIG. It took me pulling political strings with you to get any of my concerns heard. And the standards we did that with were better for it. How many times do I need to be ignored before people realize that perhaps I know something about what I'm talking about? Chatting with you over a pint has lead to many of the biggest improvements in the FIG. For sure. Whilst I would love people to listen to you more on these matters, it doesn't mean that everything you say needs to go into the PSR, which I'm sure you wouldn't ask for. This thread didn't start about you, and you've made it that. You have some realistic concerns, and we'll see if they turn out to matter or not in time. The majority of other people knocking out shit comments need to calm down: &gt; prepare for it not to see usage among key players and be largely ignored and &gt; Ah, so this is when PSR starts it's decline. Happened sooner than I thought. and &gt; PHP-FIG is mainly run by framework fanatics who like to dictate to everyone else how to build their code. That's the nonsense I'm talking about. That and insinuating that Doctrine not using it will matter at all. They f**king hate PSR-4 too. And as I said to Andrew, his were not nonsense, but they're not particularly problematic. 
Yes, my subjective opinion is that PDT is faster than PHPStorm. Also Eclipse is free, has many plugins and as another redditor mentioned - supports different programming languages. I'm using Windows.
The group absolutely has perceived authority in the community, that doesn't mean the purpose of the group is to enforce things on people. Nothing on that thread backs up what you were saying.
&gt; And as I said to Andrew, his were not nonsense, but they're not particularly problematic. You think they aren't problematic. Plenty of other people do think they are problematic. Simple as that. &gt; This thread didn't start about you, and you've made it that. I was simply responding to the one statement you made, and following on off of some other statements people have been making about me. Ultimately it's about the FIG. And that's what 99.98% of this thread is about, so let's stay there. And as far as the nonsense, it's only being raised because people are frustrated to the lack of attention being paid to the concerns that others bring up... So no, it's not nonsense, it's significant.
Thanks I've been using Eclipse on Ubuntu and had a bit of trouble with the code hints but performance was ok
What I think you're missing is that anytime we tried to add things to cover more than just what an end user would need people claimed we were overstepping the bounds. We were told by voting members that the proposal needs to be as simple as possible and that the internal behavior of the libraries (including how Pool and Item would communicate) were out of bounds for this. The interfaces are not meant to cover every aspect of caching, just the aspects that were visible to calling libraries. We don't, for example, have any configuration standards- all the frameworks agreed that they could bootstrap whatever caching library was used themselves, and that configuration was out of scope. There are other examples as well- the Pool and Item interfaces are all that calling libraries should use, but they are not the only portion of the caching library. As the couchbase representative said- &gt; There's not an issue here. PSR-6 is about defining a public interface. The Pool *owns* the Item therefore can communicate with it however it wishes. Items are **not** interchangeable between pools therefore they do not need to communicate using the public interface. So, to get to my point- if the getExpiration function was added it would not be to solve internal communication of the caching libraries. It would be to expose that date to those calling libraries. Based off of how little demand there was for that in other caching libraries, as well as the difficulties in trying to make that feature work with caching systems that don't support any way to return that data, the conversation was started to remove it from the standard. Here's the real kicker- that conversation was basically ignored by many of the people currently complaining about this. No one seemed to think it was a big deal then. It was only brought up again the day before voting ended, and all of the voting members who responded tried to explain the scope issue (as I've shown above). The link you supplied was from a conversation that occurred within 24 hours of the vote ending. All of this combined tells me a few things- * PHP-FIG has not done a good enough job educating people on it's goals. People view it as far more than just a framework interop group, and seem to expect the standards it puts out to be far more encompassing than they are. * The FIG membership really needs to get more engaged in things. I don't think this would have changed the standard, but I do think it would have helped to have more than a couple of people responding to issued about it. * The lack of people engaged in discussion, combined with people not knowing our goals and processes, makes it ridiculously easy for people to spread FUD. Many of them are good intentioned (others less so), but finding out a way to better communicate what's happening inside fig and why will be critical for future PSRs. I think the META docs should start getting filled with "FAQs" and explanations for decisions that are resolved, as just one example.
Can't say I've tried yet, but since he's importing his own whole namespace in the bookshelf example, I'm assuming with the autoloading you'd be able to split however you want within that namespace, no?
This: https://groups.google.com/forum/#!msg/php-fig/Qr4OxCf7J5Y/OVzzM3rOBwAJ Valid concern. I personally wouldn't have put it to vote with that outstanding. _THIS CONVERSATION IS NOT ABOUT THAT THREAD._ The stuff I was complaining about people posting and gave just a few examples of above: definitively nonsense. So lets stop that meta chat. The crux of the disagreement here comes from this: &gt; You're basically setting up a false dichotomy where there are two options: &gt;1. Become a much much bigger standards body where standards are agonized over for a decade and then written into stone forever &gt;2. The FIG will die I find that to be very unreasonable. Sure, if the FIG does nothing other than make poor quality PSRs over and over, then it's not gonna last very long. I'd like to see the coordinators give a bit more of a shit, and Larry has had a few problems managing this one. Making big declarative statements about the future of the FIG based on this one PSR is premature to say the least. That's my main exception, and all I've really been talking about in this thread.
Yes, your understanding is correct. I have never felt the need to try PHPStorm since I was always happy with Eclipse and Netbeans.
In fairness, I don't think the issue is "who should be given a vote" but rather "why is voter participation so abysmal" and "why can standards be accepted with such low participation." IMHO, these are legit problems that should be looked into.
You can set a key combination to activate and deactive it in Settings-&gt;Keymap-&gt;File-&gt;Power Save Mode
Besides the mailing list post /u/Seldaek posted below, the fig IRC channel told me to go away when i brought up my concerns.
It is poorly designed, and I'm not excited about implementing a PSR that is poorly designed from the start.
Exactly. Whats an extra few weeks.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/thepopcornstand] [beentrill90 comments on What is so good about Symfony that it has gained so much popularity in the enterprise world?\[Fixed-Link\]](https://np.reddit.com/r/ThePopcornStand/comments/3w42c8/beentrill90_comments_on_what_is_so_good_about/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; I will also point out to everyone who keeps bringing up how they wouldn't have brought this to a vote with the "getExpiration" issue outstanding that the email they keep linking to was sent to the list the day before the vote closed. Then the discussion should have been had over "is this a big enough deal to cancel voting and return to review". Yet that discussion never happened. The only discussion that happened was "you're wrong" or "we've already discussed it" (which has proven to not be the case).
?, why caching libraries cannot be used together if have a different implementation? 
Hmm, sorry to hear that. Point out the specific people shunning you and it'll be interesting to see why. TBH there have been a lot of people bringing up things that were brought up 5 bazillion times over the last 4 years, and bringing them up _very_ late in the game is often another problem. In that instance, people are meant to link to relevant posts which show the previous discussion, but I guess some folks are getting lazy.
[Quorum](https://en.wikipedia.org/wiki/Quorum) was met. If people are super unhappy with quorum being 1/3rd then I'd be happy to see it knocked up to 50%.
Do you mean they are implementing more methods than there are in the PSR-6 interfaces? If so then there is nothing wrong with it as long as they are used by Stash only.
I mean, besides the fact that it's a bad design, yeah.
Yeah, there's nothing wrong with adapting it to your own needs or to make it easier to use. If it's destined for interoperability with other PSR-6 stuff, then maybe there's a disadvantage to such modifications, but otherwise there's no problem.
It shows the standard is incomplete on the first day.
I think 1/3 is a pretty standard quorum, although I wouldn't mind seeing it at 50% either. The low participation is a cultural problem that a higher quorum probably won't solve (PSR-6 still met around 55% IIRC). I don't really have any ideas, though - maybe member activity bylaws? I just find it a tough pill to swallow that there are gobs of passionate people in the community that would love a vote, and a good number of voting members who seem to squander that privilege.
Yeah he said something we don't like so let's make him scour for sources. Also, by the way, were totally definitely a fair group of people.
The really fascinating reveal for me is that `$func(...$args)` is significantly faster than `$func($args[0])`. I'd guess that it does less data transformation behind the scenes. I also wonder if the result is different for built-in functions compared to the userland one in this synthetic benchmark.
No one stopped you from starting that conversation.
I love (and hate) phpStorm for its features and flaws, but if you just want a performant editor - not an IDE - I recommend you to learn Sublime. Knowing and using both is great.
FWIW, I follow this mechanic. The only difference is I also create a class for each route middleware (no anonymous functions). This allows me to provide unit tests that both confirm I add my routes to app but also allows me to write unit tests against each route as well. 
Organize them by groups: http://www.slimframework.com/docs/objects/router.html#route-groups
I want them in different files.
I think the [Sensio Symfony2 courses](http://training.sensiolabs.com/en/) would be worth investigating. Symfony2 is well written and architected, I'm sure there would be value in learning more about the framework from the horse's mouth. 
Your post wasn't until after the vote finished, so citing that as a reason why we should have cancelled the vote doesn't make any chronological sense.
Python, Java, and C# are all general purpose programing languages, while PHP has, and probably always will be, a language for making dynamic websites. 
You could make a function that returns a closure, and call that function and give the closure it produces to -&gt;group()
Python and PHP are practically interchangeable in terms of their capabilities, including stuff well outside of the domain of websites. But it's still a common view, and almost certainly influences curriculum. It hardly matters though - if you're a good engineer, you can pick up a new language well enough to be useful in a couple of days, as long as you're familiar with the general style. I took on a Rails contract having never touched Ruby before (that project is now handling millions of dollars in sales), and have submitted patches for Python projects despite almost never using the language. Wrote the bulk of a simple desktop app in Swift in under a week. OO code all works roughly the same way. Procedural, same thing. Functional too.
I got my Master's in Applied Computer Science and we spent a semester building an MVC framework in PHP and another course required that we build apps in PHP/MySQL to get database concepts across.
is OPcache support php 7?
I would argue that your first sentence, while technically correct, isn't practically correct. Yes, you can write GUI's in PHP, but should you? Probably not. However, Python has a history of client side as well as server side support (heck, PyGame was a blast to write games in). You also probably won't write many CLI programs in PHP, but in Python, I used to do all my "DevOps" work in Python scripts (in the days before Chef, Ansible, etc). That isn't to say one is better than the other, but we shouldn't say they are equal. Further, I would also say that when teaching at a university level (I am a college adjunct in my spare time), it is much easier to get students up and running in something like Python rather than PHP which really requires a server. Sure, XAMPP, WAMPP, etc are available, but getting a first year student to understand ports and configurations is not a trivial task. Again, not insurmountable, but still another reason why a lot of schools would pick Python over Java. Edit: Yes, I realize that a server has been included into the language download recently, but that is a recent development. Unless I misunderstood, the question was in regards to why PHP isn't taught in universities as often as other languages, and the historic installation required Apache/Nginx/some other server since PHP did not have a built in dev server. I am not arguing from present, as PHP 7 is miles ahead, but instead on what I observed in academics.
Is ships with PHP7. It is no longer a separate piece of code as it was before PHP 5.5. You may need to enable it on your server. *Why the cock are people downvoting the parent?* They're asking about OPCache in an OPCache thread, and for some reason people want to downvote? 
So it's wrong for Cal to speak on behalf of the community but you can? You're fighting an imaginary enemy...
I would say this is because there is a behind the scene reason for "WHY" they teach Python and Java, or C/C++. This reason is because most of these languages have very very well implemented "Built-in" Data Structures. The reason I would guess that they care about this is because when you are a undergrad in university you learn how to code in one of those "general programming, scientific languages" so you can then learn ALOT about algorithms. Before you "elect a focus" most undergrad uni's curriculum is focused around "Data Structures and Algorithms", Which you can argue is the "core fundamentals" of Computer science. Also Python is taught a lot to data scientists mostly because of numpy, and pandas, which are staples for Data Sciences, well used to be I am not sure if people use those in the "real world". Also PHP was not created by Computer Science "Professors", so most computer Science professors deem it a lesser language for what they are focusing in. http://blog.hackerrank.com/why-many-computer-science-programs-are-stagnating/ This article actually probably points at a lot of the "questions" Most Comp Sci teachers are not "industry talented professionals". May this be bad or good is not really up for discussion here tbh. TL;DR Most University Curriculum for undergrad Computer Science, where most of these MOOCs are pulled from focus in teaching students the "theory" behind "what it means to think like a computer scientist", rather then syntax. I mean after you learn Python, Java, etc etc it should be just syntax. and you can learn php syntax in a day tbh. Also PHP's only real "built in Data structure" is the "array". The issue with this is that PHP arrays are not arrays, they are hash tables/maps/dictionaries/, per the PHP documentation: &gt;An array in PHP is actually an ordered map. A map is a type that associates values to keys. This type is optimized for several different uses; it can be treated as an array, list (vector), hash table (an implementation of a map), dictionary, collection, stack, queue, and probably more. As array values can be other arrays, trees and multidimensional arrays are also possible. http://hhvm.com/blog/10649/improving-arrays-in-hack http://php.net/manual/en/language.types.array.php The major issue with this is that PHP arrays are the "catch all" data structure for "everything" this is bad computer science and being taught this is terrible. (I know the SPL data structures exist but those do not really get any love nor attention in any "php idiomatic guides")
To further explain what Brian is getting at, it's not that Python is a bad language. It's that there seems to be a huge bias to use it, against PHP. Sort of like that letter that circulated several years ago where a university instructor threatened to have a student arrested because he was distributing copies of Linux. The teacher said that nothing is free, so he was stealing. She also said that she'd used Linux once before, and it was pretty terrible. So that sort of bias/stupid certainly exists even in universities. To be fair though, there's an opposite side to that fight. I've seen plenty of "PHP is better than Python" stuff. They both have their uses, and at least as far as web development goes, it sort-of doesn't matter which you use.
I agree 100%. The problem is, in regards to universities, is that most accredited schools have move to a committee model for curriculum, so it takes a long time to develop and teach a course. 
I think this needs clarification/explanation.
I make that argument all the time. Once you get the principals down, it's a matter of syntax (and, in some cases, a different way of doing the same thing - even if the new way is monstrously different).
Having studied Eiffel extensively, with SPARC ASM, MATLAB and Prolog during my university degree, I'd be happy with Python or Java.
Totally read temporal displace ...
Yes, it is wrong for Cal to speak on behalf of the entire PHP community, of course it is wrong! I am not speaking for the entire community, never said that! The community is pretty good at speaking for itself. About the imaginary enemy and fighting, damn that was clever!
For a single file (usefull for large sql files) right click in the editor -&gt; Edit as plain text. Or you can right click on a folder -&gt; mark as excluded. This will prevent the folder from being indexed. It is super usefull for compiled files. You have slow autocomplete with what language?
It's very wrong! Simple as that!
&gt; Why not listen to the majority of the PHP community who are voicing their opinions against what is currently going on in the PHP-FIG? Why keep working against the PHP community at large rather than listen? The majority of the PHP community most certainly are not voicing that opinion. You are.
It's not a popularity contest, so real-world usage is not a deciding factor, or at least not the most important one. But if you can program in Python and Java then you can program in PHP as well. The important skills cross language boundaries relatively easily.
In my experience, I think that would be a rarity, but I could be wrong. I used Python because I liked the syntax more but that is a very subjective argument. I am not sure how many other engineers I have worked with would choose PHP over Python for scripts such as server maintenance, data analysis, or configuration management. But again, YMMV.
For a desktop app or proper GUI, I agree - but I would't try to embed Python in those either. Right tool for the job and all that. However, PHP is absolutely fantastic for CLI apps (which isn't to say that Python isn't just as good). But let's be honest here: anything is better than bash. At an ugly primal level, you basically just replace $_POST with $argv; if you don't hate yourself, go with getopt(). I'm not sure I really follow your argument about server config, since PHP only needs a server if you're using it in that context - and in that case, any other language has exactly the same requirements. And PHP is notoriously easy to get working behind a web server, a huge portion of why it's seen so much success. I definitely wouldn't start a basic programming course in web programming though, as there is a huge amount of complexity that newbies would do better to avoid as they're getting basic control flow figured out. But to reiterate, this has almost nothing to do with the language the course is taught in.
Interesting, though. RIT is where I'm looking (possibly) to go to school perhaps next year. I'm scared, because I've been out of HS for over a decade now. Math skills are lacking.
Python devs are not threatened by PHP users. Maybe Django devs, but most Python programmers I have met use it for stats stuff.
The pricing is really vague. For example &gt; CPU 0.12$ 100% usage for 1 hour What kind of CPU? How many cores? Can I choose my processor? And &gt; RAM memory 0.01$ for used 50Gb What the hell does that mean? 
Documentation is busted, doesn't really explain what it is or how it works... Yeah, no. 
I learned most of it on my own by writing a lot of bad code. I still write a lot of bad code, but it gets better every year. I'd say PHP 4 put a lot of people off. What kills me is Javascript had the same hate until recently. Now it's *the* hot language.
Sure there is. What is there to learn from PHP in Comp Sci that isn't better learned from the other languages mentioned?
Java and PHP are pretty much interchangeable syntactically.
While you can do things with PHP that you can do with Python there is almost zero - zip, zilch - reason to do it with PHP instead. The biggest reason being that Python 2.7 (and often times Python 3 at this point) comes baseline on most Linux distributions these days.
I love php, it is the only server side language I currently use, I think it is very direct and has one of the best integrations with the http protocol. But even with all that I don't think it is a good language to teach programming. edit - A good example of PHP shaping the way you think is it's implementation of arrays. They are so flipping awesome that you never even think about other data structures but for some stuff a hash table (aka php array) is way overkill and yet if php is your only language you are pretty much completely oblivious to the other data structures, for example C has linked lists, stacks, queues and trees in addition to hash tables. 
Kind of is if you are learning computer science. I use it all the time but I can't think of it having any real academic significance. Makes perfect sense if you are in a trade school or certification program.
I wish my job interviewers in 2008 - 2010 understood this. So many jobs claimed they wanted Ruby or Python experience along with everything else. I had C++, PHP, Java, and a Masters degree. But the moment I told them I didn't have 3 years in Python they'd cut the interview and that was that. No appeals. The very first thing I did when I got my current job was write a Python script to do some complicated database query and aggregation. And I got it working correctly on my first try without even being able to test it.
As someone who has made most his living over the past decade on PHP, I will say that it should not be taught over Python / C / C++ / Java /... because it sucks. Not trolling. It's evolved, not designed. Now, at 7.0, it is tolerable from an academic point of view, but otherwise, it is unpardonable, academically. Trade schools are another thing, they should start with PHP and maybe Notepad++ as well :)
It's pretty much 100% personal preference.
I like the "class:method" approach, which allows you to sort your routes into controllers ...kinda. You can define routes like this: $app-&gt;get('/users', '\App\Routes\Users:index'); When the route is resolved `\App\Routes\Users` will be instantiated and the `index` method will be called. Your "controller" would look something like this: namespace App\Routes; class Users { public function __construct($app) { $this-&gt;app = $app; } public function index($request, $response, $args) { echo "hello"; } } Just make sure you add autoload to your composer.json so it looks something like this: { "require": { "slim/slim": "^3.0" }, "autoload": { "psr-4": { "App\\": "src" } } } (also remember to run `composer dump-autoload`) I know this isn't exactly what you asked for but thought I'd chip-in with another alternative for anybody who might be interested. I prefer this way personally because I like having all the routes in one file for easy reference, but the handlers separated out and organised.
&gt; I say this as a general statement, but corporate funding makes a huge difference regarding what's taught. It does, but one could make a similar observation for PHP itself - when you start looking for cheap hosting that's accessible to the masses, you see a vast sea of PHP hosts and a few spots of other platforms, like Ruby on Rails, ASP.NET and Node.JS, to name a few. So you could say PHP's popularity is "unfair" on its own. People just have to use it because it's what they have access to.
yep, starting from 5.4 IIRC, and it is as easy as ```php -s```
It allows for easy plug and play. That's the entire point behind PSRs.
My poll on twitter https://twitter.com/vdbDennis/status/674281532400525312 did not attract many voters but the result was in favour of Eclipse PDT. Together with the remarks here I tend to be in favour PHPStorm if your focus is on PHP only and an your projects are such that an editor does not really cover all your requirements. Thanks for all the comments.
[**@vdbDennis**](https://twitter.com/vdbDennis/) &gt; [2015-12-08 17:36 UTC](https://twitter.com/vdbDennis/status/674281532400525312) &gt; Which of these 2 \#php IDEs would you choose? I have difficulty choosing &gt; \#programming \#webdev @phpstorm @EclipseFdn ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
*/me waits ...*
Coming from a partial CS background, I can tell you that once I stumbled upon PHP (which is the main tool for my full time job right now) I felt like a lot of it made no sense. Having gone through C++ and C# (which I still see as a beautiful language), PHP just felt clunky and a lot of the implementations made me question what I learned. PHP is ultimately a not very well designed language, the community has done a massive effort to bring it up to date, and a lot of the contributors have moved mountains to bring it to a valid OOP model, but in the end, the language wasn't originally designed to do what it's doing: I definitely agree it should not be a first choice to teach students with.
If you're in a PHP house, it's not that rare, especially if you want to interact with shared internal PHP libraries that give you easy (effective/maintained) access to driver information. I use the term "driver" generically, of course.
You then wrote tests, right? Right?? 
Sure, but that ceased to be a Geordie beer many years ago, when they shut down the brewery and mm moved production to somewhere cheaper, using people who don't know how to make it properly. Tastes like shit now. Same for Twinings tea - all the skills and experience gone, just to line the pockets of shareholders while the brand moves down a notch in quality and respect.
It actually is. The course is usually teaching something in the field of "computer science", i.e general programming, algorithm design, computational understanding, runtime behaviour, abstraction design, etc, etc. PHP is best at *none* of this. C# beats it in Object-Oriented features (and standard library contruction). Python beats it in science, generality and ease of learning. C++ beats it in speed, Java beats it in existing libraries, Haskell beats it in theoretical power, etc, etc, etc. Unless the course being taught is specific to web programming, there is no reason to use PHP over another language, which will in the end help teach the course better and more effectively.
&gt; Python is pushed by hipsters who constantly feel threatened by PHP for some reason. Yep, PHP is really busting in on the scientific field that Python has a mainstay over. Oh, and also, all the tools that are coming to PHP for configuration management, that are looking to take over Ansible, Saltstack, etc? /s Python has bigger fish to compete with than PHP.
Also Python is super easy to get into and Java/C# kinda force you to do things the proper way
The joke's on all 3 of us. That guy was trolling. Notice how he didn't join the conversation at any point? ‚òë use alternate account ‚òë express controversial opinion with nothing to back it up (mac better than PC, vim better than emacs) ‚òë sit back and enjoy others arguing
**How it works:** Information about vulnerable package versions is extracted from the [FriendsOfPHP Security Advisories Database](https://github.com/FriendsOfPHP/security-advisories). This information is used to build a 'composer.json' that conflicts with these packages. In other words, it makes your project dependent on the absence of known vulnerable packages.
How bad is Codeigniter templates if Magento style templates "reduces frustration at development time and increases productivity"? I have used Magento, but not Codeigniter. 
Do you really need to wear a safety helmet when working with servers? http://elasticweb.org/public/images/servers/2.jpg
Docker that for creating replicable environments...
&gt;With PHP, you have the extra step of needing a server. apt-get install php5-cli -Y php myscript.php
This was already posted once. Languages don't "spawn" vulnerabilities, when the vulnerability is in the application, and not the language itself. The only conclusion you can make by reading the list is which languages are popular and people write software in them. At times vulnerable.
"Python is pushed by hipsters who constantly feel threatened by PHP for some reason." You have no idea what you're taking about... 
- No info about the company or their reg details. - No word on the server location or specs - No word on the datacenter details - No pricing that comes close to the many MANY competitors How about no.
Languages and frameworks can often implement "secure by default" practices, for example many modern frameworks provide CSRF protection by default. If PHP had context-sensitive escaping (see the OWASP XSS prevention cheat sheet for examples of contexts), it could automatically prevent most XSS (except maybe DOM based stuff). So yes, languages can definitely be designed to make it more difficult for programmers to introduce vulnerabilities. Non-contextually-sensitive templating is insecure by default. It leads directly to XSS, SQLi, and command injection vulnerabilities. It's a security anti-pattern. It requires a programmer to check context and make appropriate countermeasures everywhere, all the time. Since programmers are not perfect, vulnerabilities arise. 
Well durr. Of course there are going to be more vulnerable apps written in PHP, when PHP has almost 70% of the "market share" amongst web oriented languages. Don't blame the language, blame the shitty programmers
Then why do so many Python devs feel the constant need to berate PHP? That's my point. They're two different languages with two different niches so they shouldn't be at odds, but for some reason Python devs *make* them at odds. "Our language is ***better than yours!***" Oh...okay. That was unprovoked. But why do you think yours is better? "Because yours lacks x, y, z!" Well... x and y were fixed years ago. Your information is pretty outdated. z is a philosophical issue, which, sure, it'd be nice if the internals of the interpreter functioned that way, but frankly it doesn't make much of a difference in the practical day-to-day usage of the language. "Ours is still ***better!***" Uhm... k.
I love how you tell me I don't know what I'm talking about, but offer no counterpoint. That is a very valuable contribution to the discussion you've made. At any rate, Python should have nothing to fear from PHP, yet PHP seems to remain the whipping boy for a large amount of Python devs. The only serious reason why this can be so is that these particular Python devs hate PHP simply because it's so widely used. Hipsters. Sure, there are both objective and subjective reasons to like or dislike either language, but those who lambast PHP tend to cite issues with the language that were fixed years ago, or philosophical issues that really have no effect on the practical everyday use of the language. That is, their criticisms rarely hold water, as if they're reaching for reasons to hate it because they *want* to hate it. After years of observing this phenomenon, I've come to the conclusion that the majority of PHP haters tend to be Python fanboys, and that suggests that for some reason, PHP makes those Python devs feel insecure.
I just think it's wise to teach students intermediate computer usage *before* they learn how to write applications for them. You shouldn't learn calculus before you learn trigonometry.
This is a good approach except for the part where you are not using dependency injection ;) You should also know that Slim is not passing the App class into your constructor it is actually the the container.
This is not the Slim 3 documentation!
Having done years of development in both php and python I can tell you that's not remotely true. Also while we are discussing why python is being taught, that's because python is a better language than php in virtually all aspects especially when it comes down to concise and clear logic syntax for complex algorithms. That decision was made by people much smarter than you and me, but is a point I agree with, not because "they're just hipsters who are jealous of how awesome php is" 
PHP was built as-needed by working professionals to solve real-world problems. It's messy because that's how it was built. Python was built my college students without immediate real-world problems to solve, so they had all the time in the world to make it elegant. Of course it's a more elegant language. The issue is Python developers tend to talk down about PHP *all the time* when it's completely unprovoked. I'm not trying to argue whether one is a better language than the other, because I think that's a stupid argument. It involves both objectivity and subjectivity and "because I like it" should be an acceptable answer as to whether a person uses either language. The fact remains that Python developers who lambaste PHP unprovoked seem to have some manner of insecurity which causes them to perceive PHP as a threat, for reasons I can't comprehend. If Python is objectively better, what reason do you have for talking down to PHP developers, other than ego? That is my point.
There are two problems 1. Prior versions of PHP was a real shit from security point of view: `magic quotes`, `register globals`, SQL injections and all that notorious stuff. 2. While PHP gets real better, its ecosystem is still the same. Coursera, Code Academy, Stack Overflow will teach you the same crap from outdated tutorials. It's evolving too, but too slow.
I haven't seen a single response in this thread that isn't "because" or "read the http spec!" or "you're doing it wrong". Are there any actual provable technical downsides?
I'm not saying ***they are.*** I'm saying they sure as hell ***act*** like they are. It's not a myth, it's an observation. Python developers have no reason to be so harsh on PHP aside from ego. Ego is usually spawned from insecurity. Ergo, PHP makes these Python devs feel insecure for some reason.
All compliments to /u/ocramius :)
Whoops! Fixed. üòê
I went back for CS many years after HS. I had to take some remedial math classes, no big woop, it's easy if you stay on top of it.
From what I can see here, you're the only person who feels so strongly that they needed to rant away on Reddit. If I was cynical (...which I am) I would think you're jealous that you didn't get there first and be the evil overlord dictating his standards on the world. You can actually even write composer packages without using PSR-0 / PSR-4 for your autoloading if you provide your own autoloader and require it. Nobody is forcing anything upon anybody, people use these standards because they actually make sense. If they didn't make sense, nobody would use them. I especially like PSR-8 and I think it's very relevant to you.
The backwards-compatibility promise is also huge.
You can argue the same for Python. Python forces you to do certain things the _python_ way. It's even one of the Python mantras: &gt; There should be one-- and preferably only one --obvious way to do it. https://www.python.org/dev/peps/pep-0020/ and I'm not bashing Python, I do love python, but I recognize that PHP is a force to reckon with and anyone doing web dev professionally must learn PHP at some point in their career. 
Well sure, but that just adds another point to the list of reasons to learn Python early on. PHP is great if you know how and especially when to use it, I often do things in PHP because it's faster than it would be in Java/C#/C++ and I'm not very good at Python, but I wouldn't recommend trying to do game or software dev in PHP..
Because is a shit language that's why (not implying in any form that Java and Python aren't but their are less shitty indeed)
I asked this [the other day](https://www.reddit.com/r/PHP/comments/3vvh67/slim_30_finally_released/cxrlgto), but never found a solution that I really loved. [This old post](http://www.slimframework.com/2011/09/24/how-to-organize-a-large-slim-framework-application.html) recommends just including files with routes. Each file could contain a "group" in Slim 3.
No programming language has contextually aware templating. In fact, it's an impossibility for a language to be aware of programmer intent. Even dedicated templating languages aren't able to be fully contextually aware without making a lot of assumptions (which can turn out wrong, and still lead to vulnerabilities). So, no, this is neither the language's fault, nor even plausible for the language to improve. PHP can be used to template *literally* any other language (including other templating languages!). HTML and other web technologies just happen to be the most commonly used.
I think it's because it is some mutation/variant of it's base language C, that was directed at processing hypertext. It really wasn't meant for high level software infrastructure. That doesn't mean that it can't be high level, it just wasn't intended that way. I have computer science college interns in my office, and when I let them go on a PHP project it really shows that the language matters less so than the concepts that are taught. They constantly complain about PHP, thinking that Python or (hold me back) Javascript can do stuff that PHP cannot. It really is ignorance on their part, because PHP can do it, they just aren't taught the higher level concepts of programming to seek out the ways of doing it in PHP. I think PHP if taught can teach them that. It is really simple and I think it's really unfortunate that it isn't in more classes.
You do realise that by saying that you're reinforcing my point, right? If Java has none of the above issues, and is considered bad for teaching, then PHP is even worse! As for Dijkstra, you really don't want that guy being the gold standard for the quality of programming languages. Out in the real world, his insistence on program correctness and academic proof would be extremely time consuming and impractical outside of systems that required it for safety reasons. (Like, imagine explaining to a client that their website was late because 50% of the budget was spent proving it correct?). "You probably know that arrogance, in computer science, is measured in nanodijkstras." - Alan Key The thrust of this issue is simply that, as you know, PHP is not a typical programming language as it is designed around the HTTP protocol, requires database config and code to maintain state outside of request, is tougher to set up debug than compiled languages, has dependency on server software, a web-oriented "standard library" etc - the list goes on. This is an objective fact and the quality of any other language has no bearing on this fact. 
The package contains quite a lot of conflict rules, but only the rules relevant to the packages that your project is dependent on would be considered. I spoke to a couple of people who say they've used it on projects and not noticed a difference, but I'd be interested to here from somebody using it on a large app.
Lol you are a whiner
PHPStorm. Hands down.
Anything outside of html templates, front end rendering and simple db interactions is outside the realm of php. Php solves crud that used browsers as fe. That's it. That's the only thing php can rightfully claim it does better than any other language.
I don't think contextual escaping should be mandatory, I just think it should be the default. People who know what they are doing should be allowed to bypass the escaping system. Google's appsec team had a nice presentation back in 2011 where they listed some template languages where this was the case, I'd look it up but I don't believe you actually care. Also, frameworks and languages are sometimes separate, but any language that has built in functions for session_id access and things like that is blurring the distinction. So yeah, I can swap them about.
why do you think that?
Pshotopghap
&gt; I don't think contextual escaping should be mandatory, I just think it should be the default. You're basically saying PHP should drop support for echo and move to an entirely template based output. How realistic is that request do you think? &gt; Also, frameworks and languages are sometimes separate, but any language that has built in functions for session_id access and things like that is blurring the distinction. So yeah, I can swap them about. You want to swap them about, but you also want to completely ignore existing popular templating engines for PHP that have autoescape by default. Interesting how that works. Regarding sessions, check any mature application and you'll see it doesn't use PHP's built-in sessions, it's often custom logic. PHP *did* start as a template engine, and some features are part of this legacy, but it's not one anymore. If you want automatic escaping and what not, you should direct those requests to popular CMS and frameworks, not to a script language which is just enabling them at this point of PHP's evolution. BTW, if you want echo to be automatically escaped, check this out: ob_start(function ($str) { return htmlentities($str, ENT_QUOTES); }); There we go, PHP is fixed. Have fun.
I feel like the worst thing about PHP is all the inconsistent functions in the standard library. Thankfully a nice framework/library (or tonnes of dutiful attention) circumvent this issue. Once you get away from the stdlib it's not bad. Still, the other languages OP mentions win out because you don't have such an inconsistent stdlib.
Absolutely agree! I think the scripted nature of raw (and especially old) php is a blessing and a curse for the language.
I've been using PhpStorm for a few months now. I've used Eclipse, Netbeans, Notepad++ in the past, and I'm convinced PhpStorm is the best. Anyone disagree? Why?
you pretty much summed up how a vocal majority of /r/php feels about phpstorm and sublime.
2.1 million users still use dialup.
but now I keep thinking it's in middle of loading something.
It is somewhat, since GET values turn up in logs all over the place (including referrer headers that third parties can see). But as far as trusting the data, yeah, both need proper handling.
Yes, but since this isn't really a question, it's hard to call them out. But they include: * GET vars show up in logs and referrer headers (including your third-party analytics stuff) * GET will be treated as idempotent by user agents, POST will not (resubmit this form? warnings, etc) * There's a technical limit to how much data you can put in a query string * GET requests may be cached, POST may not There's plenty of others, but those are the most relevant to the majority of people.
vim is growing on me more and more as I get more proficient in it (still barely scratching the surface though!) I keep on typing :w in excel though. That's getting annoying.
Disagree. Reason? It costs money, and there's no "Community" alternative (a la IDEA, their Java IDE).
Some kind of livestreaming should be possible, but I think that PHP is not suitable for taking care of that. I've successfully done livestream chat using [nginx rtmp module](https://github.com/arut/nginx-rtmp-module) with usage of [notifications](https://github.com/arut/nginx-rtmp-module/wiki/Directives#notify) which were pointing to PHP backend (that handled permissions to view stream, counted viewers, took credits for time spent watching stream, ...) and it worked. Also you can have a look at [WebRTC](https://en.wikipedia.org/wiki/WebRTC) which solves all streaming for you. If you are interested in video platform like YouTube (mainly static files, no livestream), PHP would be enough for this as you only point browser to video file (YouTube was originally written in PHP as far as I know).
GTFOHWTB
To me, this reads like "high school baseball is better than the MLB because it's free". Just because you can access something for free, doesn't make it better than a paid version.
Did you mean PotatoShop? 
They kind of are in web. Python developers have been pushing their language for web for a while. But 95% of the time a company will choose PHP for web work. Python devs think their language is inherently better at everything and don't understand the decision businesses are making. Pushing the popularity of your skill set has become very important in this industry. Popularity = more jobs. And on that front PHP is winning at the moment by a very large margin. 
They probably poached a lot of Adobe's employees!
Its basically dynamically typed, interpreted C. Its not Verbose as hell like Java. And it is actually familiar to programmers unlike Python which just decided to be different. I like Python. But a C-style syntax is just so much easier to work with when switching contexts to other languages. There is nothing inherently shitter about PHP than any other languages that doesn't have a significant benefit to offset it. 
It doesn't seem that dopey to me. Okay, maybe just a little bit.
I do CLI PHP all the time. Works just as well as anything else. And most of our servers are webservers with PHP installed on them anyway. I don't think CLI is the place where Python wins out over PHP. Its more in the scientific specific libraries. But honestly thats pretty much it. Even Python's easy-to-read mantra is subjective. I find C-style languages much easier. I like my brackets and semi-colons ;)
&gt; But a C-style syntax is just so much easier to work with when switching contexts to other languages. No, you are just accustomed to it and don't want to deal with anything else. &gt; There is nothing inherently shitter about PHP * Bad design from the first iteration: Irreparable. Please show me how can you compare a shit like PHP to well designed language like Clojure or Elixir. * Scoping is painful ad hoc and ugly to use. * Have to many bad ideas and quirks all over the place. * Is trying to be like Java, that alone make it just shitty enough. * The standard library API is hideous and is as bad designed as its language. * Only useful for web stuff: No one wants to use for anything else nor should. * The culture of "make shit done" is hideous at its core. I don't want to use software with such mindset in-place in it. * The community is full of shitty people like OpenCart devs and the core language committee. * The only advantage of PHP over other language is on the context of making cheap websites for share hosting. Please tell me other reason why one should use PHP for their projects beside the previous reason. 
Note: I described (in yet another different way) how this works at http://ocramius.github.io/blog/roave-security-advisories-protect-against-composer-packages-with-security-issues/
Awesome.
&gt; No, you are just accustomed to it and don't want to deal with anything else. Partly. But also as a web dev I do a lot of javascript. Both on client and server. And switching contexts between javascript and php is simply easier. Switching between a language where whitespaces are used instead of brackets and semi-colons is headache inducing. &gt; Bad design from the first iteration: Irreparable. Please show me how can you compare a shit like PHP to well designed language like Clojure or Elixir. The fact that you like the design of Clojure just shows how different our brains work. Or are you confusing features with syntax? Clojure has some great features but its syntax is as nightmare. But I didn't like Lisp either though so... Its just subjective. &gt; Scoping is painful ad hoc and ugly to use. I don't find that. I guess I'm just used to it. &gt; Have to many bad ideas and quirks all over the place. All languages have quirks. PHP has quite a few I admit. Once you know the behaviour you program for it. &gt; Is trying to be like Java, that alone make it just shitty enough. It's definitely not trying to be like java. What gave you that idea? PHP hasn't seen Java as the leader we are trying to catch since PHP4 days. Now it just borrows ideas from other languages whenever something new comes along. First it borrowed from Ruby, now its borrowing more from nodejs. The good thing about that is we get a mixed bag of the best features from other languages. Yes, there is legacy there which fucks things up. But thats to be expected. &gt; The standard library API is hideous and is as bad designed as its language. Its very similar to C++. I don't see a problem there. The only real issue I have is the inconsistency with return types. That can be a pain in the ass. But once you know what you are dealing with you work your way around it. &gt; Only useful for web stuff: No one wants to use for anything else nor should. I don't see why you would say that. It works great on the CLI. Most of our CLI scripts are in PHP and we haven't had any issues. Maybe 10 years ago that would have been different. &gt; The culture of "make shit done" is hideous at its core. I don't want to use software with such mindset in-place in it. You mean "get shit done" ? Well... isn't that what we are trying to do at the end of the day? Shit needs to get done. &gt; The community is full of shitty people like OpenCart devs and the core language committee. I've never had a problem. Although I haven't dealt with OpenCart devs. The community seems pretty nice to me. But even so there are bad eggs in every community. &gt; The only advantage of PHP over other language is on the context of making cheap websites for share hosting. Please tell me other reason why one should use PHP for their projects beside the previous reason. These days web doesn't necessarily mean website. Everything is on the web and uses web protocols. And PHP has been doing that for many years. Cheap websites are built with a CMS. A CMS can be in any language. Its bespoke software development where the language starts to matter. And thats what PHP has been evolving towards for the past 10 years. The speed and agility of PHP development makes it ideal for business. Because unlike an off the shelf product, one of the key requirements of a business application is flexibility. The ability to move with shifting requirements and business needs. Nothing has proven as capable as PHP in that role. IMHO 
I use PHP and Ruby as well, and to me the thing i most wanted PHP to have is not "unless" or "rescue", but string and array as objects (actually Ruby has Arrays &amp; Hashes), like: "foo".capitalize.center(20) I also end up using lots of $this-&gt;bar() which in Ruby would be just bar, i'd like if PHP had %bar or @bar as a shortcut. The downside of Ruby to me is that everything is just " bar": method, variable, global function, acessor. It might look like a small thing, but it makes harder to understand where things come from. The 2nd thing i most hate in Ruby is how easy it is for someone to write very long and complex chains of calls in one line. Which might seem like a good idea but makes it harder to read things (downside of string as objects). Regex are simple: /st/.match('haystack') #=&gt; #&lt;MatchData "st"&gt; For those who like strictness, while PHP has typehints now, Ruby will not let you use a string as an integer without calling to_i first: bar.to_i + 1
Wow what $10 a month? BANK BREAKER
That's cool. I don't think its the best, and the monetary aspect is why. I don't see a problem with my logic what so ever.
Did they stop providing a version with Java packaged in? I can't seem to find a link for it.
Install the IdeaVim plugin in any Jetbrains product and you'll have both. 
That is definitely better than mine and the original.
You should be using PDO. Here is your basic code rewritten in PDO: // Connecting, selecting database and setting charset $pdo = new PDO("mysql:host=localhost;dbname=mydatabase;charset=utf8", 'root', '', [PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC]); // Retreiving the data from database $data = $pdo-&gt;query("SELECT * FROM table1"); // Using that data foreach($data as $row){ echo $row["menu_name"] . " " . $row["position"]. "&lt;br /&gt;"; } But you have to understand that **in the real application you will never use this kind of code**, and in that real code you will be using lies the **real difference between the APIs.** And no, don't listen to /u/MorrisonLevi - it won't be as silly as just adding "i"s to the function names. The main point of all the deprecation hassle is the use of **prepared statements**. And only PDO will let you use them without driving you mad. So, here are the **real life code examples** with PDO: // Retreiving the data from database applying some filters $stmt = $pdo-&gt;prepare("SELECT * FROM table1 WHERE salary &gt; ?"); $data = $stmt-&gt;execute([$salary]); // Using that data foreach($data as $row){ echo $row["menu_name"] . " " . $row["position"]. "&lt;br /&gt;"; } // getting username from id $stmt = $pdo-&gt;prepare("SELECT name FROM table WHERE id=?"); $stmt-&gt;execute([$id]); $username = $stmt-&gt;fetchColumn(); // Getting number of rows from table $count = $pdo-&gt;query("SELECT count(*) FROM table")-&gt;fetchColumn(); // Getting user names from table matching pattern into one-dimensional array $stmt = $pdo-&gt;prepare("SELECT name FROM table WHERE name LIKE ?"); $stmt-&gt;execute(["%$name%"]); $usernames = $stmt-&gt;fetchAll(PDO::FETCH_COLUMN); You may find other examples and whole guide in [The only proper guide on PDO](http://phpdelusions.net/pdo) If you're wondering why are prepared statements so important, you may read [The Hitchhiker's Guide to SQL Injection protection](http://phpdelusions.net/sql_injection) but it's too lengthy. In short, you should never add a variable into your query directly, unless it has been entirely pre-written in your code. All other variables have to go into query via prepared statement only. Just for sake of completeness, your code **properly** rewritten in mysqli: // Connecting, selecting database and setting charset mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); $mysqli = new mysqli("localhost", "root", "","mydatabase"); $mysqli-&gt;set_charset('utf8'); // Retreiving the data from database $result = $mysqli-&gt;query("SELECT * FROM table1"); // Using that data while($row = $result-&gt;fetch_assoc()){ echo $row["menu_name"] . " " . $row["position"]. "&lt;br /&gt;"; } 
theres a pretty decent vim plugin for phpstorm . its a bit buggy (i sometimes have to hit esc a bunch of times, and it moves the cursor back, and highlighting text (with mouse or keyboard) is a bit buggy but its still decent.
And if you look other language versions too, they all got quite bit same icon. It shouldn't take longer than one glance to recognize what programs you already have open (eg. Im using PhpStorm and 0xDBE usually at same time and I already have IDEA and CLion installed ..) At least Adobe is using different colors for different programs
Thanks. Can you tell me the actual difference between PDO and mysqli? Security aspects or more options in PDO or something else?
It's usability of prepared statements. Both mysqli and PDO are equal in terms of security, *if used properly*, but that proper usage (frankly the use of prepared statements) for mysqli is tricky and toilsome to the point of total unusability. PDO, on the contrary, offers many helpers for the most common tasks. I think I should provide examples, but it takes some time to make it proper. See, the code you posted is *right from the last century* - people were writing this code back in 1998. And still many people are using it and even teach others. So, it needs to do some research to make a proper exampe. I think can spend a couple hours on weekend and provide you with the vivid and convincing proof.
Not really. I mean, it makes things bearable, but there's an awful lot missing when I jump from my neovim setup to PHPstorm. I love the code analysis stuff and the easy debugging (you can set up PHP debugging in Vim but it feels more like a hack), but when I need to hammer out code I prefer Vim. 
I've been using vim for the last two years. Mainly because I don't know how to quit it, but eh... 
Because they are rival of PHP
Also be sure to check out https://www.versioneye.com/ to make sure all your dependancies are up to date.
The only folks who refer to untyped arguments as "duck typing" are Ruby folks. They have a tendency of borrowing terms they kind-of-understand-but-not-quite and then use them in every sentence they write. Another example is referring to every basic Ruby API as a "DSL". Duck typing means that the *language* (not the developer, through manually written checks) infers a type for a variable from the way you declare its value. So if you lack duck typing and you want strict types you'd write something like: int foo = 123; And in a duck typed language, you can do this: foo = 123; And it's still an int because the value literal is one of int. But if you later assign a string to foo, the program may still refuse to compile. Dynamic typing != duck typing. And no typing != duck typing, as well. Because arguments have no value (unless you assign them a default value, which is quite the special case), you can't "duck type" them at the point a function is defined. You can duck type a function at the moment it's *called*, and the compiler or runtime can see what argument types you're passing in, and determine if that function is compatible or not. Duck typed languages do this at compile/parse time, so if you call the same function with three different types of arguments, you internally get three versions of the function automatically compiled for you (this is known as "reification" in some languages), each with different, but very specific and strict argument types. Note that the developer is not doing manual checks for the existence of methods and properties on a given argument. If you do manual "responds_to" checks, you don't have a duck typed language, you have a duck typed... developer. A developer who's manually implementing a feature in every function that's supposedly in the language (but apparently it isn't). If Ruby were duck typed, the developer would be able to simply use a method that they assume must be there, and the language would check *at the calling site* of that function, if that function uses its arguments in a compatible manner with the given argument values. Duck typed identifiers are statically verifiable. You don't need to run a script to determine it's typed correctly. Ruby doesn't have duck typing. Neither does PHP, for that matter. They both have dynamic types for values, and untyped variables, arguments and results (but you can optionally type them in PHP).
You're clearly not a professional then.
I'll check it out later for sure. Thanks 
With pleasure. Both mysqli and PDO are equal in terms of security, if used properly. 
Yes. [PDO section](http://www.phptherightway.com/#pdo_extension) is just excellent, and it covers some adjacent topics which I wanted to address but thought it would be too much. Frankly, `Using that data` part of my example is wrong and by the link above it is explained why. 
So...is this an update for subscriptions only? Or also for licence holders? I'm very much set against opting for the subscription since I just paid for the licence and do not intend to give them more of my money, certainly not on a monthly basis. But I'd like to upgrade my PhpStorm while I'm still able to.
Thanks!
Thanks, this is perfect :)
afaik all JetBrains products were re-branded
I just hate java desktop apps. They never feel native to me. Didn't really warm to phpstorm.
This kind of arrogant snobbery is one of the reasons, why in /r/PHP/ up to this day garbage code is posted and heavily upvoted. 
I don't think what I said can be described as "snobbery". Advice should remain pragmatic. A lot of that linked StackOverflow comment is random conjecture presented as fact, and I'm putting aside that the StackOverflow question itself is beating a very dead horse. Beginners do get confused from old code snippets, but all they need to be told is "check out exceptions". Not much to discuss. And telling people to not exit the script while testing is a bit too much. And this...: &gt; PHP is a language of bad heredity. Very bad heredity. This die() thing is one of worst rudiments Awkward. All "die()" is... is an alias to "exit". Every language has an exit clause or API. It's part of the standard interface between an operating system and a process running in it. A process runs, and when it's done, it exits with a given exit code. You can pass an integer to exit() / die() to set that code. It shouldn't be used all over the place, but it's used sometimes. And it's fine.
try to select the record from the database by it's PK, if num_rows is 0 then it does not exist... How you'd handle that I would suggest is more difficult in CI than some other frameworks
If I posted slagging off Aura on baseless opinionated assumptions you'd be the first person replying defending it, asking for proof.
In case someone is reading the comments but don't read the article. It is not on die() itself, but, *as the title suggests*, on the using die() for reporting mysqli errors. And "this die() thing" mentioned in the text refers to misuse of this function for reporting errors.
&gt; if you are going to use mysqli_query() all the way in your application code (which is wrong but on StackOverflow you will never be taught any other way) Why is using mysqli wrong? Or does he mean using the procedural version is wrong?
You still planning to release this?
Yeah honestly I think this is a terrible logo. Just write "PHP Storm" on the damn thing! There's plenty of room.
From a purist point of view, 404 should only be used when you can't find the resource requested. If you found the resource and the user isn't supposed to see it, then 403 is correct. People worry too much about information leaking. It can be problematic in *some* cases, but if we're talking about leaking that an admin has rights to edit product 123, that's absolutely fine, in my opinion (after all, one assumes an admin can edit any product they like, and that URLs exist for each case).
Yes I am. Appologies for slight delay, I'm currently moving house. I will be working on it tonight.
1. First do not allow people to use non-numeric characters. Make your route match against a more strict regular expression `bookings/([0-9]+)` instead of `bookings/(.+)` 2. You could add an validation key to the URL /bookings/{id}-{key} ... if the key doesn't match the id, no need to make a call to the database. The key should be generated through an algorithm, not stored in the DB. It can be as simple as `substr(md5($someFixedNumber + $booking-&gt;id), 0, 5)`
alright cool, and no worries. I was just curious.
I live(), I die(), I live() again!
My guess is that he's saying that, because if you do this, it becomes hard to swap out. If you have a few classes or functions which use `mysqli` and you call those everywhere instead of the `mysqli` functions directly, then you only need to change the code in a few places if `mysqli` ever becomes deprecated. If you use `mysqli` all over your application, on the other hand, you'd have to change it all over your application.
That's for php-cli, which can be different from mod-php or php-fpm.
&gt; From a security perspective wouldn't be better to not disclose what are the "forbidden" routes? If /admin/product/123/edit is 404 that would tell an attacker to look elsewhere instead of displaying a sign that says "try again here!" Actually, from a security perspective, you should be more worried about disclosing the existence of a product id to someone who's not allowed access to the products section at all.
&gt; I don't think its the best, and the monetary aspect is why. I don't see a problem with my logic what so ever. This has to be trolling. Just because there is a fee, which goes into constantly improving their products, it automatically sucks? This is ass backwards thinking to me.
I think anonimous classes for a series of object literals would be bad for performance, I'd rather use good old (object) cast: $obj = (object) [ 'foo' =&gt; 'bar', 'baz' =&gt; 'quz' ];
Why did you assume I said it sucks? You shouldn't do that. I said it isn't the best.
Apache with PHP / Fast CGI - all manually installed. 
MaxMind GeoIP Database https://www.maxmind.com/en/home
https://github.com/maxmind/MaxMind-DB-Reader-php#example Just be aware that GPS (on mobile) is way better than IP geolocation. I've seen it show the wrong city, you should only trust the State/Country. Even on desktop the javascript navigator.geolocation can use the Wifi information for better accuracy.
You can do IP detection to get a user's city, but its not always super accurate. I just implemented this for a client and we found that even the paid services only get you within a 30 mile radius. So if you need city level you may be OK, if you need to know the actual postal code it may not be accurate at all. **Free Services:** http://dev.maxmind.com/geoip/geoip2/geolite2/ http://lite.ip2location.com/
I know that you can throw 404 at any point in the stack. Let's take the example of making POST request to https://www.domain.com/product/5. Your routing rules says that for that URI (scheme + domain + path) you have a handler only for GET. The result of matching the request to a route can be either: 1. "you are not allowed to make a post request to that uri", hence 403 2. "the route you are trying to access does not exist for your particular situation", hence 404 No matter what you chose, for consistency reasons, you should reply the same way if another matching condition is added to the route, even if that condition refers to the user being logged in and/or having specific conditions. The state of the user is part of the request &gt; you match a request to a route &gt; if you don't find a matching route you display an error &gt; that error should be the same regardless of the reason for failure. Again, I am talking only about the routing part of the application.
Consider these two snippets: One is $user = User::find($_GET['userid']); and another is $query = "SELECT * FROM users WHERE userid=?" $stmt = $mysqli-&gt;prepare($query); $stmt-&gt;bind_param('i', $_GET['userid']); $stmt-&gt;execute(); $result = $stmt-&gt;get_result(); $row = $result-&gt;fetch_assoc(); $user = new User($row); Considering also that several hundreds of such snippets have to be written in your application, how do you think, is it OK to use raw mysqli in the application code as is?
I think you've missed the point. The problem isn't with `die()`, it's with the pattern `foo() or die()`. It's fine as a temporary hack or while debugging, but using it in a real program otherwise is a sign of bad design. 
You can't open multiple projects in the same window and it always seems to forget where composer is located.
you can use exit instead...not much better but still
Updated my post to clarify a bit, but yes - I'm looking for a Windows build of the actual extension.
Have you considered that `User::find` might call `mysqli_query` internally? You just abstracted the funcionality.
Why do you want to do this without the user's consent?
It also doesn't make a cup of tea, which my adaption now does. Fancy releasing a PSR that does not make a cup of tea on day one!
Would you (or do you) build that extra functionality into a separate layer from the core PSR-6 part of Stash? It kind of makes sense building it in layers - even if in one library - so users of the library know when they are sticking to pure PSR-6 (or portability) or standing on higher ground with additional functionality.
The atom feed only seems to list historical / unsupported releases.
die() breaks phpunit, making your code untestable.
There is nothing wrong with mysqli. In fact there are features the mysqli driver has that PDO does not. The switch from mysql to PDO is much harder than the switch from mysql to mysqli. And for completeness, adding `i` will in fact get you most of the way there. It's like you have some personal vendetta against mysqli. And no, switching to PDO does not get you instant portability to other database drivers. I have seen exactly zero projects make this switch without having to change their SQL queries as well.
As mentioned elsewhere you should stop using `escape` functions and start using prepared statements. The documentation on [`msqli::prepare`](http://php.net/manual/en/mysqli.prepare.php) should be helpful. Feel free to ask about a specific example if you need more help.
don't confuse wrong authorization with wrong representation. the latter should be responded with a 406, not a 403, nor a 404. regarding the usage of 404 for unauthorized resources, it's up to you if you want to disclose that the resource exists or not. 
Yes, both extensions are behind in development. The `memcached` extension seems to be more recently active but has never had a Windows release. I say yet because this is important functionality currently missing in PHP 7 for Windows and I'm hoping the authors or some other devs pick it up. At least PHP &gt;=5.3,&lt;7.0 could use the `memcache` extension on Windows, currently there's nothing for 7.0.
&gt; No matter what you chose, for consistency reasons, you should reply the same way if another matching condition is added to the route, even if that condition refers to the user being logged in and/or having specific conditions. I think this is where you're veering off the road. Errors are not hierarchical in HTTP. The request/response cycle is flat, and no explicit order or priority is imposed on implementations besides that which is implicit (e.g. 404 is implied higher priority than 405, since a resource must exist in order for it to have methods that aren't allowed). There is absolutely nothing wrong with responding differently when additional conditions are added to a route, and the priority in which you check your conditions can be completely arbitrary.
Try starting here : http://php.net/geoip
&gt; and redirect This is what you are doing wrong. No HTTP status beside 5xx have to be sent in case of error and 30x would certainly be wrong. A custom error page have to be shown right in place without any redirect, by means of application or web-server. &gt; What does filesystem, image processing, or HTTP errors have to do with it? All these are errors. And you have to show the appropriate error page with the user-friendly error in hand for them. Means it will be redundant to have dedicated error message hadling for PDO. 
It's a matter of preference and you can set whatever value you want 
&gt; one shouldn't use raw mysqli in the application code ... unless you're coding the abstraction, right?
Nope: http://stackoverflow.com/a/12202218/2224584
JavaScript: Never use eval() unless you're designing a framework. (Like trying to create a coffeescript interpreter)
But abstraction means it is not the application code, right? 
And there's PHPDBG.
&gt;No HTTP status beside 5xx have to be sent in case of error and 30x would certainly be wrong. A custom error page have to be shown right in place without any redirect, by means of application or web-server. Again, I fail to see where I made an argument to the contrary. Don't let the ``redirect`` terminology confuse you. If there's some sort of PDO error fetching the desired data, the flow of the view generation is "redirected" to that of an error template. The subsequent error is logged and life goes on from there. There's nothing wrong with selectively handling certain Exceptions. Simply because **you** don't agree with it does not imply it's "bad practice".
Yes you're right with stating the point. But it's a pity that you think it's still OK to use `or die()` for temporary debugging. Just change die for trigger_error, and your code will be good for **both** live and debugging.
True, although I'm not a phpdbg user I think it's a pretty solid alternative to xdebug. 
I made these arguments, but sadly they did not listen. I am alwas for writing readable code because you write it once, but read it many times more
exit and die are the same.
&gt; I think anonimous classes for a series of object literals would be bad for performance Luckily we don't have to think, we can benchmark. :-) Both approaches have roughly the same speed, but casting (yours) is slightly faster. Which is a bit odd, because anon classes are created once per class definition only, not for every new instance. But I guess it's how things work right now.
Every must eventually die
for me it lists 5.6.16 (latest release for 5.6) and 5.5.30 latest release for 5.5 it should list 7.0.0 so thats a good catch but these aren't historical/unsupported releases. or maybe I'm just missing your point.
Get yourself a remote job and it won't matter where you live :) Just stating an available option.
The new icon seems like Photoshop is loading :(
Hmm, for some reason i thought it listed 5.6.16 like https://secure.php.net/releases/ does. My mistake, i assumed it was based off of that page.
This is neat. Some natural evolutions might be reversing the flow (turning crontabs back into readable expressions) and international friendliness.
Oh wow, I wish I had discovered this first, although this looks like it does even more. I also like some of the regex patterns you used in your lexer - they seem very well thought out.
What exactly is a mysqli::prepare doing? I mean, how does it work to prevent injections?
Aside from php cli can be different than what is being run on the web server, if you're on shared hosting, you likely wont have command line access. There are valid reasons for using die during dev.
Thx for benchmarking this. Also the idea of using anonimous classes for a simple object seems overkill, and would not work with nested objects
Moved from Upstate NY to San Diego 5 years ago with 2k and 500 bucks a month rent. Got a job as a Jr QA Software engineer for a start up. I am now Software Development Manager at another start up. Don't regret a thing. A lot of people thought I was dumb for taking that risk, but sometimes you just need to take the first step to get where you are going. 
I was at a meet up earlier this week and a guy there told me he had moved to the city with out a job lined up. I think it took him 2 months, but through the meet up was able to land a job.
In fact, it does. It would treat it as some kind of "string" preventing it to execute unless it can be used as a parameter only for ID. Am I right?
Or use a github pages site which is completely free hosting.
Well, I have been working with PDO a bit today, yet I'm not sure if I should stick with it or go with mysqli. I've seen here people saying both are secure if used well, so do I lose something if I learn PDO instead of mysqli and vice verse?
&gt;From a security perspective wouldn't be better to not disclose what are the "forbidden" routes? If /admin/product/123/edit is 404 that would tell an attacker to look elsewhere instead of displaying a sign that says "try again here!" Hiding routes isn't that useful. If the fact a URL is potentially serviceable to some users is sensitive information then you should reconsider what's in the URL. Even if you did make a 'false' 404 to hide real resources from unauthorized/forbidden users the fact is someone could most likely determine that you were doing so unless you go to extreme effort to ensure that all 404 returns take the same amount of time to be generated regardless of whether the resource exists or not. There are demonstrations of similar timing attacks actually working in real situations - you can just time the response generation and create profiles for how long it generally takes to return 404 for obviously non-existent resources and for known-to-exist resources and, with a few attempts to load an arbitrary resource, you match it to one of the time profiles and know if it exists or not. Real security lies in it being irrelevant that someone knows it exists. 
That's a good idea, but I'd need some sort of PHP backend to demonstrate it though. Cheap enough to throw on a micro instance though. 
I'm in NC right now, even though I'm not in the market and I won't be in the market anytime soon, recruiters still approach me left and right _every week_ about open positions. And these aren't your typical recruiter from a recruiting agency, but recruiters working for the company itself (the good ones, anyways) So if you're worth your dime (not saying you aren't) you'll have no problems finding a job quickly in neither Charlotte, nor Raleigh. Plus the landscape is awesome, BBQ is awesome, people are awesome, and life is cheap, very cheap.
&gt; the idea of using anonimous classes for a simple object seems overkill How? They are basically the same thing. One is just called stdClass and one is called anonymous. &gt; and would not work with nested objects Hmm, haven't tested it but I think you could set a member variable to a nested anonymous class.
He is talking about providing it as a service. It doesn't make sense for someone to download this and run it locally just to use it
How is it not part of your application? You seem to have very weird definitions and dividing lines.
I think he's just trolling at this point.
As for why I'm using PHPUnit now: one of the nice thing about Hack is that as long as you have the type information somehow, how you got that, and whether the library is in Hack or PHP is an implementation detail that doesn't affect how you write code; so I get the benefit of PHPUnit's track record and developer community, and the only difference to me in a developer if they rewrote in strict hack is that I'd remove the 91carriage/phpunit-hhi dependency. The more general form of my reply above is that Hack-specific features that can't be implemented in PHP would be more convincing than the internals :)
I wish I could download the update from the application and it install itself rather than having to reinstall the god damn thing every time.
&gt; For such a request you don't reply 403 because the user is not allowed to make GET requests to /post/5 with the 'application/json' header but it is allowed to make a request with 'text/html' header The proper HTTP code would be 415 in that case AFAIK.
&gt; So, for an unauthorized user /admin/product/x/edit should always display 404. Technically, the correct header would be a 401.
Actually half of my stuff is in javascript on nodejs these days. And swift and java for apps. I'm not a PHP programmer. I'm a programmer. Hey you don't like javascript either do you? That will be around for 30 years too. 
Also WTF with this shit: &gt; As a lead PHP dev when a new junior dev comes in I can tell immediately if they will be useful or not by asking 1 question. "What was your first programming language?" If it was PHP then they will be useless to me. &gt;PHP is horrible to learn how to program in. It lets you do anything. Your architecture can be complete rubbish. &gt;I can understand how it may be useful to learn in the final year of a degree though. AFTER a student has learned how to be a programmer. &gt;PHP is actually great at testing how good a programmer is. Because lets you write bad code a bad programmer will be shown up very quickly. And a good programmer can write very elegant and well architectured code. * So you acknowledge that PHP is shit language to make programs. * You are pretty much a PHP racist that deny jobs to anyone who use it. * You have clear as day that PHP let you to write bad code from the get go. All this and you still defend it? OMG your dementia scare me to no end. Go and find medical help ASAP. 
The `mysqli_` API is more similar to the `mysql_` API which makes it easier to migrate existing code. It also has the ability to do asynchronous queries, but this feature is often not used. The `PDO` API works on more database drivers. There is less code to work with bound parameters in `PDO` when compared to `mysqli`.
&gt; Actually half of my stuff is in javascript on nodejs these days. Going from shit to another shit is not a improvement my friend. &gt; That will be around for 30 years too. This days Javascript is pretty much a runtime, everyone and their dog are using other languages that compile to it, I don't ever need to choose to work in that shit anymore. 
&gt; I didn't say PHP is a shit language to make programs at all. Your comments said imply others thing. &gt; The best PHP programmers learned how to program in another language. Who in their right minds which started programming in a "good language" would end up seeking a job in that shit know as PHP. &gt; Yes I have said that PHP lets you write bad code Which make it unsuitable to right good programs for the get go. &gt; C lets you write bad code too. Because is another shitty langauge too. &gt; Are you so undisciplined that you need the language/compiler to force you to write good code? Do you have so low self-stem that you actually need to use PHP? I enjoy to work in languages that inspired me to write good code, not one which I have to fight and cut myself to do it. &gt; The thing that forces me to write good code is the experience that the bad decisions I make now will affect me for years to come as I maintain that code. Like using PHP? Agree with you in that. &gt; So I need to create a sound architecture now so it doesn't bite me in the ass later. Like if that is possible in PHP. &gt; No one should ever learn programming in PHP. Now we agree in something, but I will go further to say that no one should use PHP for anything. &gt; It is not a learning tool. It is a tool that evolved specifically for business requirements. Shared cheap hosting you meant? Business that revolve around PHP are the shittiest and most unethical out of the whole industry, stay proud about that if that help you sleep better. Good night. 
Agreed, it looks to be forking time to me. 
Surely you are. I've learned that PHP users are more like painters. They don't write their programs, but rather *draw* them. Diligently and industriously. They like the process. And so, writing several hundreds of useless lines doesn't bother them, but rather makes a pleasure. No doubts you are good with your approach.
This is exactly why I love Symfony, and I wholeheartedly believes that it's the best framework for PHP currently in the market. I know at the beginning it's difficult to grasp, and it _seems_ heavyweight, but it's quite robust, flexible, and super fast. My successful web app is built completely on top of Symfony, and I couldn't be happier. 
Yeap, and making quite a good living off of it. 
The router can only return FALSE or a matching route. That means that routes should be matched only on a path and you must have middleware that checks for other conditions that the route must match. Throwing different results in middleware is ok. For example, a middleware for enforcing HTTPS would make a 301 redirect for a request made from HTTP but if the router is the one checking for a HTTPS request you have only one option (because the result of the routing will be FALSE).
Heroku?
So you built it from scratch or used a pre-created service/plugin such as the ones listed below by mrgwilliam? If i tackled a media site any tips on compression and or bandwidth? I know bandwidth wouldn't be a concern since its a personal project. Mainly i want to build experience that will benefit me in the future for example "what steps to implement when experiencing high bandwidth consumption on media sites". 
I will look into this thank you.

I'd much rather have "garbage code" posted (even though it's not), than someone with your attitude posting...
I kinda know what you mean, with the angle the conclusion is pitched from. But to me, it all depends on whether you agree with the points or not. I think this is a good article in that it explains things well. And then you can make up your own mind. So while there were some things I want PHP to have (Nested or Inner classes, I use them in Java, so handy) there was much I didn't. eg Unless. No No No No No No No. Just use "If (!())". It's not that hard. Seriously, if you are introducing a feature that then has the capacity to get so confusing you have to introduce a code standard rule ("nobody at work would let you submit an unless with an else on it") just stop. 
Ask the guy who started this thread and said (in case for some reason you didn't read) &gt; I usually catch the PDOExceptions and format out my errors neatly. 
I don't know whether it's possible for you in your position but when I did over here in the UK, for positions I was applying for I stated that I was in the process of moving towns so I wasn't rejected based on my current location and just made sure when I got interviews I booked a load on the same day and made a trip out to the new town and did them all in one go
Aha, ok. Understood
I'm sure if you ask there will be people willing to provide a backend. And if not let me know. I could do it temporarily for you.
How about the two most used cache library saying "no, too many flaws left"?
[removed]
&gt; in the very very few cases where assigning inside () is appropriate, I can just add an extra set of brackets to indicate that yes, this is deliberate Wouldn't it make more sense to add an explicit comparison? Like one of these: while(strlen($nextLine = $reader-&gt;getLine()) &gt; 0) {} while(($nextLine = $reader-&gt;getLine()) !== false) {}
It all depends on what you're developing. If you're about to create a app that will run only on your own VPSes (or dedicated servers), like a SaaS, a intranet app or when all your customers purchase hosting from you, then PHP7 is the best option. If you have no idea where your app/website will run, feel free to assume everyone is still running on PHP5.3.
Thanks ... This seems to be a good solution...
Thanks Hari :)
I am very tempted to start using PHP7 right away, and there's no real reason not to play around with it ASAP. However, there are real business reasons not to deploy it or code for it in some scenarios. For example, if you are building a product that you expect customers to install on their own - it's too soon for that, especially if "I'm gonna use cheap shared hosting!" is their modus operandi for your project. You can certainly make an effort to ensure your code is PHP 7 compatible, and I **highly** recommend that, but that doesn't necessarily mean you should make it **only** PHP 7 compatible.
this isn't ruby/python. we don't hold ourselves back several majors without some specific reason. unless you intend to purposefully write code that has forward compatability problems, source you write for one will be fine on the other. if you intend to target $5/mo cheapo hosting, then you can't use new, fancy shit. then again, if you had to ask this question, there isn't any specific new fancy shit you want, and therefore you should be unaffected. if you intend to always self host, then go ahead and target the newest stable version of the language. well written modern php generally runs quite a ways back without problems.
Yep, I too think there is room for many improvements. And respecting changes that "save" keystrokes... I mean I get it... but your IDE/editor can/should make that, you may have to configure it... if you don't want to have to do that, you are just way too lazy then. I'm lazy, and even I can spend good time doing that kind of customization to my vim.
thanks, when you finish reading what i wrote you'll realize i already spoke to that
Just slam it on Heroku and let the composer requirements define what PHP version shall be used. Yes, this is 2015 ;-)
Or worse.
I **am** the OP. The existance of `rvm` and `rbenv` have nothing to do with the speed of adoption of ruby versions. It's just a good instrument because, when you can change easily between versions it's easier to work on different projects or to test under all versions. `I didn't criticize anything. ` My bad. 
&gt; I **am** the OP. T-shirt time.
Look at me. I am the OP now.
I was just looking at [a heisenberg hipsterhitler comic](http://hipsterhitler.com/) ..
Something to bare in mind, https://www.facebook.com/apps/site_scraping_tos_terms.php
Yep but 55% is a lot less than 80% and leaves a big wide opening and opportunity for node or other language that might pop into the scene. I agree with you that PHP is not going away but I also feel it may struggle holding on to its spot. We will see in the next 2 to 5 years.
Very worse. There are still shared hosts that offer 4.x.
As well as this, it would be worth making sure that whatever PHP extensions your app will require are also supported and functioning on PHP7, because not all of them are yet. Same goes for any other PHP dependencies you might have. If you know you aren't going to be boned halfway into your project simply because a dependency you've realised you needed isn't yet ready for PHP 7 then so long as you also know for a fact you will be deploying to a PHP 7 server there's not much reason to not go ahead and use it now. 
I assume PHP 5.2 because some popular software packages still support it. It means you have to give up square bracket arrays, anonymous functions and some niceties like that, but it isn't that much of a cost. 
Worse than php 5.5 find a new host Source: http://php.net/supported-versions.php
I'm using PHP 7 in a project I'm developing. I still run 5.6 in production. This will change before February. Just my $0.02
Why would you use shared hosting for a web-app of any caliber?
&gt; some niceties Uh...namespaces are hardly a nicety.
I was hired to refactor legacy code just two weeks ago. I asked for a list of software versions I would be working with, as well as the software versions I was allowed to refactor with. They wanted a PHP 4.0.1 (May, 2000) codebase updated to 7.0. Needless to say I declined. 
Because it's cheaper and not everyone makes that decision themselves. If the boss says use shared hosting, you sometimes don't have any choice.
You should have asked for hazard pay!
You'd usually use code like that in a template. That code will be replaced by the value of $Name when processed.
`&lt;?php echo $Name ?&gt;`
I usually make my projects compatible with the oldest supported PHP release. However, if you're not planning on releasing it for general use and it's going to be run solely by you, then feel free to use the features from PHP7.
I prefer to not share since I'm still in stealth mode. 
I've decided to open source our starter theme (Lumberjack), in the hope that it makes WordPress a little nicer to work with for others. We have tried to bring in some modern programming / PHP principals such as MVC (using Timber and Twig), DRY, OOP, autoloading and coding standards (PSR2). I would love to get feedback on this (good &amp; bad), whether you use WordPress or not. Happy to answer any questions too 
To be fair, I think most peoples' issues with WordPress stem from WP core, not the theme level of things.
Depends on the theme. Most themes I've worked with are ghastly. They are to client-side code what WP core is to server-side code. Worse, even. I've used themes that make my MBP stutter as you scroll the page. Trying to modify the behavior and style of those themes is like trying to clean peanut butter out of a ball of yarn.
Actually I would say that honestly the WP core is not that bad. The issue that I have with WP is that most people who use WP do so poorly. WP's issues is that they target a market of site builders who might know the very very very basics of web development and call themselves "php developers", which is also why a lot of people hate php and php developers. Using WP with "best practices" actually makes for a "decent" start point, though personally I would just use symfony/something else, but I can see the appeal in it. So I would say A lot of it is the theme level, like 90% of WP hate.
Shared hosting needs less maintenance too. For VPS like DO, you have to manage everything like updating your software stack and must stay updated on security bulletins. And... mail servers are a pain in the ass to setup.
No reason not to use PHP 7 if you can control the version.
You are in control: after all, you control the root `composer.json` ;-)
But doesn't that defeat the purpose of having an interface at all? Why should my application care if the cache implementation benefits from bulk operations? Why should my application care if the cache supports deferring? I just want to say: Here is the data, do with it as you please. And if you need to commit, you can do that now. Or you don't, because you don't defer writing. I don't care. Wouldn't these interfaces inherently leak implementation details about the cache? 
Folks kinda missed the point of this one sadly. I knew this would happen when it went on Reddit, which is why I tweeted this: https://twitter.com/philsturgeon/status/667761605044629504 Ha. Anyway: 1. I didn't pick the name. I wanted to cal lit "Stuff I like about Ruby after using PHP for over a decade" but that was a bit wordy. 2. I do not at any point say which I think is better, only that they have fundamental differences in approach and one of the core goals of Ruby is to make things clean and simple and reduce typing, which is appreciated sometimes. 3. These aren't literally the best things in Ruby just some stuff I find myself using often and like. 4. Saving keystrokes is not the most important thing in the world but when you're writing a shitload of code sometimes fingers appreciate it. Yes you can use macros. Yes you can use aliases. 5. Yes unless can be used to do evil but so can _literally any feature_. `goto` isn't the devil either. 6. No anonymous classes are not the same as object literals. 7. No I didn't post it because "Maybe he wants to keep things balanced because Ruby's popularity is waning." I don't care. I could do an article on "Things that PHP does that I like a fuck load more than how they've done it in Ruby" and the /r/ruby thread would freak out instead. I was just showing off some features that I like in a language that I've been using consistently for a bit now and making comparisons to the same features in PHP. 
[**@philsturgeon**](https://twitter.com/philsturgeon/) &gt; [2015-11-20 17:49 UTC](https://twitter.com/philsturgeon/status/667761605044629504) &gt; Oh god, it‚Äôs out. This article is why I‚Äôm hiding in Hawaii. I‚Äôll be deleting Twitter now. Don‚Äôt @ me. http://www.sitepoint.com/php-vs-ruby-lets-all-just-get-along/ ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt; Actually I would say that honestly the WP core is not that bad. This why I can't trust most PHP people code, they lack the ability to recognise when something is inherently broken.
TIL: Ternary operators and numeric continues is considered "clever".
&gt; I didn't ignore it, it's not relevant. I don't want to make anonymous classes, I want object literals. What is the difference, in reality? Both make objects. &gt; Ugh I didn't say that. What are you reading. I don't see how you can read it any other way. Unless being "rather nice" and "saving a bit of typing" are disadvantages now?
If you are handling payments yourself you would never store any sensitive cardholder data in your database, that would be foolish. Most payment processing companies (authorize.net for instance) don't even require you to handle the data yourself, you can forward to their website for the actual payment processing then they'll send the user back to your page with an appropriate response token you can check their server with to see if payment was successful or not.
Exactly! Resolving ternary operator into if/else doesn't help a bit. Making it somewhat like this makes more sense if (!isset($wordsFound[$word])) { $wordsFound[$word] = 0; } $wordsFound[$word] += count($matches); 
There are a number of issues here. The answer to "not trusting someone else's host" doesn't lead you to "hosting on your own PC", it leads to "hosting on your own series of servers". And many organisations do that successfully (we do, though that's more for cost benefits). At some point, you have to accept that a group like Amazon for example has no interest in your codes - the business they get on the reputation of AWS is worth far more to them than whatever you're running. And yes, hosting databases for payments means you store people's billing details - but it sure does not mean storing credit card numbers. 
People keep saying this but here's the facts: I currently offer 5.6 and 5.4 on the hosts we manage. The 5.6 host has one single customer on it (blazing speeds!) and every one else has chosen 5.4. I get at least one helpdesk ticket a week from someone asking if we can offer PHP 5.2. We shut down PHP 5.2 only a few months ago, after more than six months worth of warning people. Roughly 80% of those users chose to move to other hosting companies, rather than move to our more modern hosts (even when pointed out free resource upgrades came with it). I got a lot of abusive phone calls about how "x host doesn't hate their customers like you do". The problem with hanging around and reading blogs from the top tier developers is you forget anyone who would bother coming here is a long, long way ahead of a lot of PHP developers.
If you want to continue down the road of donning the tinfoil hat; then the key word you may be looking for is co-location.
This should carry the GPL license since it interfaces with Wordpress. As far as I know it is impossible to write a Wordpress theme without it becoming a derivative work of Wordpress.
It's more readable for sure but it's not unreadable either, after a short while ternary operator becomes pretty simple to understand. There certainly are far more unreadable things.
I think it's a little harder than that... I recently worked at a company that was going through PCI compliance and and all the devs who were working on it kept whining about it. I think it was less hard than they were making it up to be, but it still looked like a lot of work.
I can perfectly understand why devs whine about it, but I don't think that equates to it being "hard". Having managed several such audits, "yes, you will install McAfee antivirus on your Mac, even though the few obscure Mac viruses are less likely to cause damage than the AV itself" are absurd, pointless limitations on a developer's productivity. But really, it's not a technically hard to achieve compliance.
&gt; the tinfoil hat But how do you trust the hardware manufacturers not to backdoor their devices? /s 
What nice matching tinfoil boots... I don't, I assume that if I were interesting enough my secrets would be a figment of my imagination. I am under no delusions that I have what people might call privacy. --What I do have is a mountain of stuff to sift through. Good luck investigator.
Should I write clever code, depends what your goal is. It might be that a problem has taken some time to solve and your manager / client is a numpty that thinks you should produce 1000+ lines of code per day; but on the articles specific examples... array_key_exists($word, $wordsFound) ? $wordsFound[$word] += count($matches) : $wordsFound[$word] = count($matches); IF you did not understand that, please retire. I would prefer they cleaned it up a bit by calling a function (shorter, more professional, less crammed in IMHO), but this is hardly the end of the world, and should not be confusing. Read it, got it, moved on. Everything is clearly set out, there is no redirection going on here, no confusion, it just works. I would be interested in finding out why they did not write a shorter form, but it's not the end of the world as we know it. The following is a dirtier example that I'd have more problems with. @$wordsFound[$word] += count($matches); more acceptable $wordsFound[$word] = isset($wordsFound[$word]) ? $wordsFound[$word] : 0; $wordsFound[$word] += count($matches); of course in PHP7 we should be able to write the following "clever" code without any issue and it should be clear the intent $wordsFound[$word] = ($wordsFound[$word] ?? 0) + count($matches); The next example made little sense as a piece of code, but knowing your language features such as `continue {$level};` is not IMHO a problem, it is a language feature, that may or may not be understood; and the article should probably be re-titled as "wah wah, I don't understand the language I code in" if that is a problem. foreach ($routes as $route =&gt; $controllerAction) { $routeComponents = array_filter(explode('/', $route)); // ... foreach ($routeComponents as $i =&gt; $routeComponent) { if ($routeComponent == '(.*)') { continue; } elseif ($routeComponent != $pathComponents[$i]) { continue 2; } } return $controllerAction; } There are words in my own language some people use and I ask what they mean if I am unsure; sometimes I am uncertain, or incorrect about a words meaning. It is a basic part of being human to sometimes not get stuff, or get it wrong; but to insist that the entire world does not use language features you do not understand is plain childish. As for the "router" example, the code is terrible. It should not exist, there are many better ways of expressing that router, complain about those instead of the using a valid language feature.
Why so needlessly aggressive? &gt; This why I can't trust most PHP people code, they lack the ability to recognise when something is inherently broken. I'd say other systems have a similar problem. For example the WordPress editor itself (TinyMCE) can be used to visually represent code blocks. What other frameworks do that? How many other frameworks have something as powerful as shortcodes? It's not hard to write your own shortcode parsing library, or to borrow from a flawed project (IMHO there is not a single project ever written that is not flawed if introspected enough including my own) Personally I have no problem writing WP, no problem writing Symfony, or using my own frameworks; they are all just there to help express solutions to problems, no matter how in-elegant the solution, I'm pretty sure, bring me a pretty ballerina of code is not most business goto need for a system.
I'm pretty sure this might not be true, but it did not take away from the discussion of WordPress themes
An honest critique is that, it doesn't do things in the style of the framework / project it's aimed at (which I get is the point); but it therefore needlessly excludes existing framework / project developers who IMHO would have no clue how to work with PSR or TWIG for things like extending a plugin that has theme bindings. So it will needlessly divide your user-base, and produced code. . A better option (IMHO), would be to fork WP Core, or contribute to the core, stating, right now someone can `&lt;?php die('hahahaha'); ?&gt;` inside a plugin, or template and it kills any WP using that template. By using Twig, I'm pretty sure that can be stopped, and therefore eliminate some complex attack vectors. (I don't think they will go for it, but :sigh:). Good luck though, perhaps I am wrong, it happens
Those are not managed. If you create applications you don't want to have trouble hosting them. That's where managed services come in. You let hosting people do the hosting.
I haven't used it in years. It's on it's slow death spiral. Just use Composer.
I have a legacy application that uses a PEAR project.
Thank you for your feedback. I totally get where you are coming from with regards to PSR and Twig. When we originally built the theme, it was only ever going to be used internally. We are familiar with PSR and are using Twig as our templating language in our Pattern Library. It made sense for us to use them. I then decided to write up about how we rewrote our starter theme. About half way through, I decided we might as well open source the theme in case it is useful to anyone else. You're right that it'll divide our user base, but the separation that Timber gives us is worth it in my opinion. This may change thought, the more mature this theme gets. And unfortunately, as a 2 man dev team (who actually specialise in frontend, not backend) we don't have the resource to work on the WP core to make a real difference :( 
Self hosting is like going to live in the woods, keep and hunt chickens with your bare hands, with tools you invented, learning skills on the go that nobody that keeps chickens has taught you, and are probably inefficient; because the price of chicken has gone up, and you perceive it is too high... It's just not the best proposition for a right-minded individual, or business to undertake. Going it alone, or with less people only makes sense when it make sense * Limited funds for a reduced subset of functionality * Innovation * Fun / Leisure My guess is that if you are not running a web hosting company, then you probably don't need to be learning the job of, or focusing on being a web-hosting company. If you do ever need help you'll probably bug the hell out of them with your half-baked suggestions on how you used to do things or perceive they should be done.
I fully favour more separation of concerns around WP, and PHP in general; and think twig's extend and block syntax is a lot more powerful than `get_header()` and `get_footer()`, it is fantastic as a proof of concept, so please don't let my words count against that. For storing patterns as you mention, do you mean front-end markup to achieve a site feature front-end, like a modal box bullet-list etc? If so you can use a front-end template engine with a CPT, and it will give you near identical features. It's a fairly advanced use-case, but I'm betting as a front-end guy you could use WP to do exactly this.
Don't worry too much about the comments. There will always be someone who disagree with your opinions. People act like their language of choice is a religion, some even call themselves "evangelist". If PHP dies and one is a real programmer, one would have nothing to fear. 
&gt; Skips ahead to the next iteration of the loop. In this context it's good to know PHP's peculiarity to consider a `switch` statement as a loop as well. 
Unfortunately I still have to on a legacy application too.
It's because of attitudes like this that people are still using old versions of software. Not only should you not have declined, it most likely wouldn't have even taken all that long to do to a minimum level (i.e. just running, not using modern techniques). Not to mention that it's also a wonderful learning experience to work with legacy code and update it to work with modern systems.
I agree. Stick with Composer packages for all functionality, core and bespoke. Then when the systems require bespoke functionality, create this via a new Composer package and use DI to make use of it in the core system...
Yes, composer doesn't handle lower level extensions like mongodb.
I wanted to read the documentation of some ORM a few days ago. Now I know why it wasn't available and I had to read the source to understand what's going on. 
For what?
One thing keeping it alive is cPanel. As far as I know, cPanel still offers to search and install Pear extensions for you. Composer is probably difficult to use without SSH. A newbie trying to add SMTP emails or something and hosting on cPanel will probably use Pear before they figure out how to use Composer.
Disagreeing with my opinions is absolutely ok, but a bunch of people acted like I wrote something completely different to what is actually on the page. 
Most PEAR packages are in github repos too, but only a few of them have embraced composer and are available on Packagist. In particular, I still use Math_Stats and Math_Histogram on one report I haven't had time (nor motivation) to refactor to use something else.
They ought to rename it the clever operator. Or maybe the inferiority operator. Its the simplest damn thing in the world and it always ends up in this conversation. Why are people so threatened by a questionmark and a colon??
&gt; What is the difference, in reality? Both make objects. An anonymous class is not the same as standard object and misusing them as such should not be seen as an alternative to allowing object literals to be created like any other language. The limit of what can be assigned in vars as you were showing is part of the problem. Try doing `public $one = some_function();` in there and it'll explode. They're not the same thing. I wrote a bunch of that RFC remember. :) &gt; I don't see how you can read it any other way. Unless being "rather nice" and "saving a bit of typing" are disadvantages now? Saying that red wine is "rather nice" does not mean I think it is the best drink, I still love cider. Highlighting things that I think are cool about something is not the same as saying it is the best, especially when I say that neither are definitively better and cannot be multiple times in the article.
Often they are not. For example a LOT of people still use CentOS 5 and 6 - many of the packages PEAR offers are not available without using untrusted 3rd party repositories (many places wont allow their servers to use these repos for security).
Why did you post this in /r/PHP ?
Hell, I have a newer application that uses it because of some weird parser a library for our phone system needs. 
sorry you clearly have no clue what PCI compliance is.
because it seems the original op was mad at php-fig and then decided to switch to go 
I'd be interested in seeing that plugin when you do open-source it! So if I understand it correctly, you have known components that know how to render themselves? So you can effectively say "I want to use this component (say a register modal)" and it'll automatically inject the right data and markup into your template? And you're storing markup for components in the database (in the CPT content)? Do they exist anywhere else? How do you handle multiple devs on a project? Just interested, thanks!
I asked them recently and they said - it's ok. 
For the price they were willing to pay, it's simply not worth my time at all. If you want to pin the entirety of late adopters on me, that's fine. But I really just don't care. I expect to be compensated fairly for my time.
Really? A couple months ago I talked to one of the theme reviewers and he said they not agree with it. Do you have proofs? Is what you said is true, then great.
Extensions? Those are PECL's job. PEAR manages PHP code.
Make a pull request for it. I would imagine it would not be very much work.
Am I reading this correctly in that some kind of "server" was running on a single unraided harddrive? Remediation setups include just now starting backup regiment too?
Most people actually don't store payment details, like credit cards, on their hosted server, they use a third party, certified service for that. That being said, yeah, a clever hacker or coder from your own team could intercept the payment details if they have access to your server, atleast in some cases. And that's a real worry, that's why there's an approval process involved in getting a third party payment provider where you take the cc and send it to the third party. Only did it once and it involved a 20 item checklist or so, antivirus on the server (lol), having clear roles (security responsibilities etc). And a bunch of other shit i can't remember. And that was just to _relay_ the cc, we never stored it, just accepted it from a form, and sent it to the third party using a server side api ... To _store_ cc on your server, self-hoster or not, requires _much_ more security. In most first world countries I guess it's covered by LAW. Atleast in Sweden my home country it is. I imagine the whole EU ... 
I'll never get why people use synfony. Puting synfony on top of php is like putting mustard on top of a chocolate cake. Php... its just not meant to be used like this. I'm not saying synfony is bad. It's pretty nice actually, and we'll written. The problem is that, if I have a problem complex enough that requires synfony, I'll definitely use Spring instead, no? Why should I use synfony instead of Spring? 
My biggest problem is not storing "sensitive" data on the server (i wouldn't store cc info on my server) but more the tempering with entries in my database I thought about some kind of api that i host on my own pc, so my host sends payment data (no sensible data, just general payment data like user X paid amount Y for service Z) so the database is stored on my own computer and "save". Is this too paranoid? Should i not even worry about stuff like that and host my stuff on something like DigitalOcean ? 
From that thread: &gt; seem to be affecting the PHP community on a global scale with their PSRs Yeah. That shitty PSR-0 and PSR-4 that totally revolutionized application development in PHP, and brought it from being a language where all you do is build scrappy haphazard scripts, to a language where you can do robust application development with seamlessly interoperable libraries and components. Fuck that thing. See this import thing in Go? package main import "fmt" func main() { fmt.Printf("Hello, world.\n") } Yeah you can go ahead and thank PSR for making the equivalent to that possible in PHP. `use` is useless if you don't have an autoloader, because then you're constantly using `require` everywhere as well. PSR enabled standardized autoloading to be a thing, which enabled `use` to be properly useful, and PHP applications to "import" modules as seamlessly as other languages. But yeah. Fuck the PSRs and those Fig guys for helping modernize PHP application development. OP from that other thread sounded like the type of developer that "wrote" PHP applications by downloading scripts from PHPClasses, and then complained when the community shifted towards sane software architecture.
I see now, and that's wonderful. Thanks for clarifying that. About reading an ulterior motive in your work, I'm not twisting your words, I'm only reading between lines. And here is the thing, when you like something you implicitly think it is better, in some way at least, doesn't have to be DEFINITIVELY BETTER. And as I said, that's great, I'm not accusing you of liking one more than the other. I'm pointing out that you clearly do, which means you clearly think one is better (could be just one tiny thing, but it's there for you). Again, its a good article but then the title is a shame. More so because you start with: &gt;This comparison is usually quite worthless, but the clickbait titles get them a lot of traffic. The publishers then seem cruel putting a title like that when you stated right there your opinion about it. So yeah, dick move. Maybe publish somewhere else next time?
When I say "weak type system" I mean weak compared to many other statically typed languages. I don't think it is a secret that Go is commonly criticized for its lack of generic types. My point here was merely that if your primary prior experience is in dynamically typed languages (like PHP), Go's relatively weak type system may become a point of appreciation rather than annoyance.
Good article; read and heed.
soon /r/crystal_programming may be a ruby alternative
While little would argue to avoid pear for newer stuff, do you all really want to always continue to update your application to match the latest trend? When was the last time you've built an application whose source was still effective 15 years later? I'm grateful for projects such as PEAR that support their packages for many, many years and it's a goal we should strive to.
Wow, for 10 minutes?? That's too much. Do you work for CodeLobster??? 
By definition much of the FIG things are useful to a very small subset of PHP users - primarily framework authors, but also wider group of interested users. I'm not sure that some users understand that though, in which case they'd likely just see point 1 and 2 here. As an aside, I'd hazard a guess that 99% of people writing PHP couldn't name the "PHP-FIG", and that of the 1% who could, 75% of them wouldn't know what FIG or PSR stand for. In reality, PSRs shouldn't be written for me, they should be written for framework authors, who in turn write frameworks that help me do my job. It's very unlikely that I'm going to write code the implements PSR-6 for instance - why would I? Things like PSR-2 and PSR-4 are of course useful to me, but I'm not that fussed exactly what they are, as long as they are standards that I can use tools that understand them - the fact that there is a decision is more important than what the decision actually is on those matters. I'd possibly suggest that the fact that FIG and PSR are not particularly well known acronyms should mean that they are spelled out in full more often, and/or that they are renamed? Perhaps PSRs could fall into categories (Frameworks/Generic/Lame Joke or whatever). The concerns of people like Taylor Otwell or Fabien Potencier in comparison to me are very different, and that could perhaps be more acknowledged by the FIG's outward facing documents to avoid confusion for the main userbase.
Well PEAR's future looks doomed, but it still has uses to certain people, such as those who on legacy platforms. Also keep in mind that composer is not available in shared hosting, as WHM/CPanel does not support this. PEAR, however, is available in shared hosting, so PEAR will still stick around at least for a little while longer. 
when you want to send email with attachments from the command line, Pear is the way go. 
I feel the FIG is seen as highlighted in #2 - at least that is my impression given the communication of the FIG (and others) in the past. I`d love to see #3 happening in the future because a more in-depth standardization will help us all to move forward and improve as a whole.
&gt;I hope the React intoxicated masses will not start implementing everything with it, just because The very model of an objective article.
I'm inclined to agree, but I think the transition between #2 and #3 is going to be bumpy, and I'm not sure all of the folks onboard want to be #3.
This makes most sense to me. Most other PHP developers I've come across (or interviewed) haven't really heard of PHP-FIG because they're consuming frameworks and packages, rather than creating them.
I pay attention to the mailing list. That's definitely true. 
#2 and should still 2 due to its nature: framework interop... Being 3 would impact too much the php community at large, and we could see as per PSR-6 that not all their decisions are the best one, nor for userland. And guess what? In some threads they can be #1 also.
\#3 to me, useful for library code and making good interoperable components
And that's why most stuff on sell at ThemeForest is just visual sugar covering huge security holes and spaghetti code.
At first I thought that it's worthless to practically add a framework-like extension to Wordpress when it isn't meant to be anything else but a CMS. However, I've seen people using wordpress as many other things that just shouldn't be (including CRM, event calendar, image hosting and forums) so it's pointless to pretend everyone is using it as intended. So, after reading your article, I came to really love what you're doing here. It makes perfect sense to treat the theme components as controllers, making Wordpress inner twisted router act in favor of your desired outcome by mimicking (again in a dark and twisted way) what a proper autoloader would do to require a proper controller. In the end, your project can be seen as a skeleton app that has a dependency on Wordpress, except for the fact that Wordpress isn't meant to be used as such so you have to make a few compromises to overcome global functions and constants. You did a fine job there. Congratulations.
I think fine to objectively compare and contrast on the quality's of your available options. In this spirit here's some information about go that I found helpful. https://github.com/ksimka/go-is-not-good
1, 2, and 3
Non-interoperable frameworks do not help the anti-framework cause.
I wanted to reiterate my reply from the list here because I think there might be more discussion: &gt; I'd like to posit that perhaps the community treats us as a standards group simply because there *is no PHP standards group*. Perhaps instead of turning the FIG into something we don't necessarily want it to be, we should create a new standards group from our ranks. A new standards group made up of individuals who may or may not represent a project that can simply adopt the PSRs (or a subset) as the initial standards would quickly gain support IMHO. That would leave the FIG to remain as a group meant to increase interoperability between frameworks. &gt; Thoughts? TLDR, FIG might appear to be #1 or #3, but maybe that's just because PHP is trying to fill the gaps. Maybe if we just create a #3, we can continue to work as #2. 
`#3`, and I think it's great that I can write a package, and if a need to provide some logging features I just typehint PSR3 and forget about it, and now if I need some caching I can typehint PSR6 and I'm done. I don't see this as anything to do with frameworks, and much more to do with the PHP community
Thank you for your feedback :) I think you hit the nail on the head. We have a saying that no two WordPress sites are the same. And we think that's a shame. Luckily for us, we weren't the only ones who thought this. The work Upstatement have done with Timber meant we were able to 'just' add sugar on top. "A skeleton app that has a dependacy on WordPress" - This! This is what I was worried people wouldn't get. We wanted to build something that can act as a starting point. Something people can mould and extend in a way which fits their use case. I.E. make their own flavour of Lumberjack. It's intentionally stripped back to allow for this.
I saw FIG as #2 but I really hate how I am forced to accept it in my libraries. Forced by missionaries who are not even users of this software (they sees FIG as #3). I think that PHP need userland standards group for coding style etc. But this group should not make the standards for loggers or even service locators.
It is #2 and should **STAY** as #2, and should actively work to ensure that it remains exclusively #2, because it is not anywhere near as representative of the broader PHP community as some may think.
That's totally legit, especially depending on the license. Even if it's licensed in such a way that it's fine, Packagist still generally frowns upon publishing forks since it becomes a divergent mess.
[**@jamwt**](https://twitter.com/jamwt/) &gt; [2015-08-07 20:27 UTC](https://twitter.com/jamwt/status/629750661735788544) &gt; @asbradbury We may rewrite some very "hot" web routes in go, but there will always be a lot of python at @Dropbox. Millions of lines of it. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
FIG is more successful in maintaining the pretence of #2, so that dissenters are given a formal freedom ("it is only for us, not you") even if the reality is everything they use is switching to their standards. I tend to see formal freedoms ("it is in principle possible that...") as slight-of-hand procedures to paper over the lack of actual freedom (ie. some in-practice say over what happens). The reality of FIG is that its decisions have an in-practice effect over the lives of many more developers than they are formally committed to - and this reach is not merely accidental - it is essential to how FIG operates that their decisions cascade, as standards, throughout the community. They should therefore be subject to the same procedures, criticism and accountability as any group with this structure. FIG saying "you don't have to follow us" at this point is like saying, "well you can leave the country if you don't like its laws!"... &gt;Nope, you can by all means ignore core parts of a framework if you hate it that much. However the standards have already been set, and we are already here and subject to them - our right to object to them is guaranteed by that alone. In virtue of being "citizens of the PHP community" with a de-facto standards body (legislature), some process of accountability (etc.) is required.
Oh... It's December, and still on the FIG site for PSRs. If they want to be taken legitimately (along with PHP at large) they should treat it as such. Downvoting a legitimate question? Cool.
Not sure if you're asking for FIG member opinions, but here is just a brief one. My initial understanding of FIG was that it was #2... primarily a way for member projects to define interfaces and possibly share implementations without re-inventing the wheel, regardless of whether those interface APIs were ever consumed in "user-land". However, lately it seems it's trending more towards #3 where you do see these interfaces (particularly PSR-7 and possibly PSR-6) being what frameworks are exposing to user-land (see Slim and PSR-7 and perhaps Expressive and PSR-7). I don't think this is a great idea as I think the FIG interfaces are kept pretty bare-bones to allow basic framework interoperability and don't necessarily translate into good UX. So, in summary - I think FIG should stick to being #2, but is becoming more #3. Whether that is a good or bad thing I think remains to be seen.
agreed!. I appreciate that Go ships go fmt and most people use it. And even though go fmt uses tabs instead of spaces (which I hate), I'd still follow it, because it makes things easier for everybody.
If FIG doesn't wanna be 3, then it'd be nice if somebody would.
Honestly, it's pretty dumb. So now it's just going to stay there forever? Nice.
that's how RFCs go. take it up with the IETF
&gt; when you like something you implicitly think it is better, I'm talking about features I like, and I like a lot about Ruby. There is a lot I dislike. As is true with PHP. You're saying some nice things but you're trying to drive a point home which is just not a valid point to make. I do not prefer Ruby definitively but I do like some parts of it. I'd rather be writing Go than PHP or Ruby tbh but that's a different story.
If you don't use Framework A or Framework B then it doesn't matter if their components can be mixed and matched, does it?
Nope, you don't have to catch. There are many ways to handle an error. Most simple one is just to let it go. PHP is quite good with handling errors, So in many cases it will be enough. If you want more control over handling errors, then you have to write an error handler. But catching an exception only to handle the error message is useless and wrong. How do you see your chain of catch blocks? Each contains the same handling code? Really? Try to compare these vague theories you have in your imagination with possible real implementation. You PHP users never had an idea how to handle errors properly. And when exceptions has been introduced to you, started devising some complex solutions for non-existent problems, based on various delusions. To let you know, an exception is **never** bubbled up no user. 
If all you need to do is restrict access to certain urls, you can get by just fine with Basic HTTP auth (via your .htaccess file, so nothing to do specifically with php). However, this won't work if you're talking about the admin user having additional functionality available on pages that are also publicly viewable.
If you're only dealing with one account, why required a username _or_ password? You could simply implement [OTP](https://github.com/Spomky-Labs/otphp) or something I saw implemented a few years ago was shared key authentication via certificates. That was pretty cool! If you decide to go with a password login, I would do _both_ username and password. The entropy is still needed here to keep things ambiguous. &gt; This won't be connected to a database as there is no need for one. Additionally, I would _still_ use a database, even if you think using one is overkill. You could just as easily do SQLite which is super lightweight and flexible.
The first few PSR's were # 3 but some of the later ones are becoming # 2 / # 1. I think one area that could benefit from the FIG's reach is what http://docs.puli.io/en/latest/ is trying to do. I think the FIG could do that better (if it can be done at all). But stuff like PSR-7... PSR-7 wasn't a standard that needing standardizing.
PHP-FIG is awesome and I immensely appreciate the efforts of this organization to create some sort of standard to work toward. It provides a great example and structure for the PHP userland. That said, the impetus for this post seems to lie in PSR-6. I'll be honest, I skimmed PSR-6 a few times in the past year and it never really clicked with me. PSR-6's stated goal is: &gt; Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. This has lead to a situation where many libraries roll their own caching libraries, with various levels of functionality. These differences are causing developers to have to learn multiple systems which may or may not provide the functionality they need. In addition, the developers of caching libraries themselves face a choice between only supporting a limited number of frameworks or creating a large number of adapter classes. Perhaps this use case wasn't as illustrated as I'd hoped and I'm simply not understanding it, but to me when I implement a caching strategy the solution is by nature of the problem tightly coupled to the code it applies to. I'm not likely to implement a caching strategy until I need to - so when I do, I'm going to tailor the solution to the performance problem it's solving, which may or may not fit well with the PSR-6 interfaces. Maybe I could fit it into the PSR-6 interface, but my initial gut check tells me that's going to be either overkill or an awkward fit in most cases. 
if they don't see themselves as part of a community then they are definitively #2
I don't "know" but `from what I understand` WordPress.com optimizes and runs on a modified WordPress codebase. From https://vip.wordpress.com/codebase/ (The horses mouth) &gt; Automattic have added hundreds of extra features on top of core WordPress that help with performance, SEO, security, social network integration, and more. Anyway, re-reading you seem to have gone off on a tangent espousing GPL, chill...
+1 The basic HTTP auth in your webserver is very secure, and has been checked by tons of ppl. Nice, robust, simple. Job done in 2 mins. (Done this before.) (SSL is good here of course.)
does this single user mostly have a static ip?
I'm not looking for an argument, calm down, its monday
I agree. Today's best practices are tomorrow's legacy code.
It's not very good idea. If you aren't using HTTPs, key will be visible to anyone in the middle. F.e. Your proxy and web server logs will retain your credentials. And even if you are using HTTPs, you can accidentally expose your "key" via URL auto-completion or browser history.
Interesting. It looks like yes, you can pull a bcrypt'd password from DB and throw it at `password_verify`... Isn't it great how these things get added, but never advertized?
It was a big feature for 5.5, I'd say it was pretty advertised at the time.
One of the most interesting things about this middleware is that it can be reused over multiple dispatch cycles. This makes it perfect for use on applications that stay alive between requests to improve performance. If you're interested in this, check out the [PHPFastCGI](http://github.com/PHPFastCGI/FastCGIDaemon) project (my own), [react/http](https://github.com/reactphp/http) and [icicle/http](https://github.com/icicleio/http). ~~On a side note, if you do use this middleware, make sure you use a signing key which has much more entropy than the one in the README :)~~ ~~[edit] Just created a tool for generating keys which you can use for this purpose: https://github.com/AndrewCarterUK/CryptoKey~~ [edit2] Docs now explain this clearly :)
Caching overall isn't simple and often leads to hard to nail errors and complicated debug. Also we're spending most of our time in development environment and if it's extremely slow it's just depressing to work on the project.
Yii computes diff and saves what changed only as well.
and there is backport for &lt; 5.5 https://github.com/ircmaxell/password_compat 
Thanks for explaining the flaws with this. 
&gt; it's not just about sitting down with an editor and changing stuff. Not in the majority of cases. But in moving away from PEAR, I beg to differ. I can't think of a single dependency that isn't easily movable to, or doesn't have a better alternative in, the composer ecosystem.
I started learning PHP after this came out and I have been using something I found in a book. This seems way better so I'm just hoping there isn't a catch. 
There are several layers to PCI compliance. I imagine that may be all that is required for basic compliance, but proper compliance is crazy.
&gt; The previous edition from 2012 recommended md5. That is what I was mostly afraid of. &gt; Not sure if ripemd128 is good or not. http://crypto.stackexchange.com/a/958 I dont think ripemd128 is much good. That article is based on ripemd160 and ripemd256 and they recommend sha256. You are also correct that having a unique salt for each password is much better.
&gt; Alright, fair enough... i agree about amazon or google, but i have no clue how big digital ocean is compared to lets say amazon (but most likely still big enough that it would be paranoid to think an employee would do something to my data) I have one kind of offtopic question, do you know how digital ocean compares to someone like amazon or google? 
&gt; [edit2] Docs now explain this clear Thanks for sending a PR to make that crystal-clear!
&gt; Like can PHP run a php script? Maybe using the command-line? php /path/to/script.php Otherwise I don't know what to tell you since I don't use Node. :/ But I kind of feel this is a better question for Node or something?
Because people shouldn't need to check the date every time they change a file.
Piecing this together you want something similar to this: **Set password** $provided = $_POST['password']; $user-&gt;password_hash = password_hash($provided, PASSWORD_DEFAULT); **Verify password and rehash if needed** $provided = $_POST['password']; if (password_verify($provided, $user-&gt;password_hash)) { if (password_needs_rehash($user-&gt;password_hash, PASSWORD_DEFAULT)) { $user-&gt;password_hash = password_hash($provided, PASSWORD_DEFAULT); } // Success! } else { // Wrong password } 
That too. That may be a good enough reason to remove the year next time the file is edited. Or just leave the year unchanged. When the copyright period runs out, I'm sure your code will be long forgotten anyway.
The spelling is not ok in the language that matters: phpdoc ;)
The year is actually year of first publication, not year of latest revision, so if we're doing things right, you never update a copyright notice at all, ever. That being said, what Evert was getting at is that the notice itself is completely unnecessary, and can just be removed altogether. Copyright has been implicit for decades, and omitting a notice doesn't change your rights in any way. Incidentally, neither does having an incorrect copyright notice (e.g. when you update the year every year). So, ultimately, it's pretty irrelevant what you do.
If you change the year in file, the file changes. So by your definition it always makes sense to update the copyright year ;). In all seriousness though "That's how copyright works." is kind of incorrect, because I couldn't find any proof that the year in the file has any influence over the copyright. The minute you create a file, you have the copyright. It doesn't require an explicit copyright statement up top. And I'm curious as to why you feel you need to raise those issues? 
The PASSWORD_DEFAULT algorithm will change with new PHP versions, this will keep your passwords hashed using the current recommended algorithm.
&gt;It is strongly recommended that you do not generate your own salt for this function. It will create a secure salt automatically for you if you do not specify one. https://secure.php.net/manual/en/function.password-hash.php
If you don't use the framework then it doesn't matter. I still don't understand what you are trying to say here.
&gt; "others can adopt or ignore as they wish" [Mu.](https://en.wikipedia.org/wiki/Mu_\(negative\)) aka I reject the premise of the question. I think people inside the FIG, and those who follow all the PSRs, don't realise how tiresome it is that on the one-hand the FIG says that not everybody needs to follow their standards, when in reality people get harassed for not following the FIG 'standards'. For example, even in this thread where people are explicitly being asked their opinion, people are [being](https://en.reddit.com/r/PHP/comments/3wownq/how_do_you_see_the_phpfig/cxxxjc6) [downvoted](https://en.reddit.com/r/PHP/comments/3wownq/how_do_you_see_the_phpfig/cxxvu8o) for saying that their opinion of the FIG isn't that favourable. The root cause of this, is that the FIG is trying to be a standards body, rather than 'just' helping frameworks and other projects from working together. This has created the current adversarial environment, where the vote on PSR-6 felt like a victory for the people pushing it through, and a defeat for those who didn't like it. The FIG should be helping different projects achieve interoperability, rather than having a single standard for each thing. For example, the developers from the Laravel and Doctrine projects have expressed their unhappiness with the caching PSR. If they want to, they should be able to work together to create their own caching standard. It would be great if this was curated under the FIG umbrella, so that other people could see that there it is there, as an alternative to the PSR6 'standard'. This would remove the adversarial aspect and allow people would be able to choose which they wanted to use. It would also allow evolution of the interoperability agreements; allow people to propose and start using 'PSR's without year long discussions, etc, etc. TL:DR I think the aim of having a single standard for some stuff is good, but the current attitude where people are harassed if they don't follow it, and forcing single standards for inappropriate stuff is not good. 