after a quick google, apparently it's google's marketing term for "I actually did my job and didnt half ass this project"
tl;dw: Read [the Docs](https://laravel.com/docs/5.5#installing-laravel).
Those stats may be a bit biased/skewed, but still, the trend is great!!
This actually made me smile, shows what a great community we can be embracing the new better things and moving forward
ohh people get interested 
What exactly are you trying to do? If you need to know the absolute path to your script root i'd probably prefer to place something similar to `define("ROOT", __DIR__);` in a script file that is located in your root directory.
How about realpath(__DIR__ . "../")
How should I go about, making this for multiple folders down? Let's say "../../" and "../../../../../" etc. How should I make something like this? Sorry if I'm asking a stupid question, I'm new and I wanna learn :)
Could you help me get better understanding of a situation where you need this so I can answer better? With realpath you can chain as many ../../../ as you need.
Composer PHP stats are the only thing we have positive in this. I suppose WordPress/Drupal is not included (even though Drupal has composer, they don't use packagist), which often holds us back with 5.2,5.3, etc. 
Yes. Always use [absolute links](https://phpdelusions.net/articles/paths) in your HTML and you will never need neither ../ nor any magic. Simply tart all your links from `/`following the actual path to the resource and you'll never encounter any problem with a missing link.
realpath(__DIR__ . "../../../../../") 
Is it possible to create a "script", that recognizes where the current file is and links back to the root of the website for easy access to other files, such as CSS, images etc?
If Drupal is being installed via Composer, it will make a lot of calls to packagist for Symfony and other external dependencies, no?
"According to these statistics, 100% of php projects are using composer!" What do You mean, "Biased?" =)
You never need any script to know the root of website, **it's always the same**
I want the site to recognize it by itself, so that I do not have to hardcode the paths on my "local site" to my "online site" every time I want to test something.
I'm a bit confused, wouldn't you access such assets via path relative to domain? Such as /images and /css if your files are located in ~/public_html/images etc?
I don't understand it. why would you want to link from your dev to the live site? Anyway, just delete your question here and re-ask in /r/phphelp and try to explain your problem better. You're the only one to have it you nobody really understands what is so special with your sites
Okay, let's try again. I have a local site "localhost" and a domain "domain.com". From the root of the folder I can have relative links. When I move a folder down, I cannot use the same relative links. If I do, the site will break, and it will not find the files I am looking for. Using an online path can be hard if I am not on a network, or if I do not want to upload every file I am experimenting with. Therefore I would like a method to eliminate this process. Something along the lines of the GitHub project I am referring to, but one that actually will work for me (and others that may experience the same).
Looks like you don't listen to what you are told. It's a pity. And a waste of time.
Nice.
drupal uses composer, but in a weird way, last time I checked it was tucked away somewhere in a subdirectory. drupal is by no means installed by composer as a normal composer project would be. I think in the initial release the vendor directory was even completely in the git repo.....
I actually did move this into a param converter and it worked rather well. There's something awesome about being able to have my controller action look like this: public function createPersonAction(Person $person,EntityManagerInterface $em) { $em-&gt;persist($person); $em-&gt;flush(); return new Response(['id'=&gt;$person-&gt;getId()], Response::HTTP_CREATED); }
There is a difference between the drupal/drupal (What You described) and drupal/core versions in git/drupal/packagist. Not to say how they use it is not weird, but You can definitely start and maintain a drupal 8 project using composer.
I'm not a drupal developer, I just checked it out when 8 was released, and at that time that was definitely not the case.
Honestly does it matter? Even if they are new practices, they are outdated in a few years anyway. I'd frown on a school that just taught a language and didn't just teach the basics of computer science, the web, http, etc. You should be able to take what you learned and apply them to any language since they don't change, yet best practices and languages change.
I use it a lot, but I don't like when it's used in the wrong places. It's very flexible, but it's often overused in situations it shouldn't be. Sometimes you have to pick the best language for the job. We have a lot of PHP systems, but it's not the best for aggregation with Hive/Hadoop. It has longer response times for some critical frontend systems, so we had to use Go. It's a pain to set up workers/queues and parallel processing. It is also much slower for some ETL pipelines, so they needed to be written in Go/Java. There are places for PHP, but you should also pick the right language for the job and the scale.
I may have responded too quickly on that one. Assuming that referencing the type `ArrayAccess` without generic arguments will imply `ArrayAccess&lt;mixed, mixed&gt;` that may work.
Work out how built-in types that ought to be generic will behave and importantly not break backwards compatibility. For example, let's say we have a custom type that implements `ArrayAccess` in PHP 7.1: class ArrayOfFoo implements ArrayAccess { function offsetGet(): Foo { /* ... */ } // ... other methods } We need to make sure whatever semantics we define will allow new code to write properly generic `ArrayAccess` but simultaneously that existing code like this doesn't break.
You might also like [Fractal](https://fractal.thephpleague.com/)
[The php league](https://thephpleague.com/#packages) has some cool stuff.
You don't need to know C++ in order to understand generics. You can find an introduction to generics in Java, for example.
i thought the last rfc was defeated because generics are going to slow down the lang too much???
I love PHP, and do as much coding as possible as I can in it. But forms are so much easier to implement using React (or probably other JS libraries) on the front-end and an api to the back-end. That splits the rendering and processing of the form into two nice parts, for each of which you can use an appropriate technology.
The question is how can a person help progress the introduction of Generics to PHP core
If you live in or around Berlin: there will be a CakePHP meetup this wednesday at Spryker Systems in Berlin-Mitte. Around 20 people attending. Get in touch with the CakePHP community: https://www.meetup.com/de-DE/CakePHP-DE/events/235239013/
I'd like to see Composer support this. Comments are sorely needed and trailing commas are nice syntactic sugar.
Generics may slow down the language. However I'm not aware of any generics RFCs that have been voted on.
To tweak your example, you'd have `$arrayOfFoo = ArrayWrapper&lt;Foo&gt;();` that has `offsetGet` defined with `Foo` as a return type. `ArrayAccess` would be set to use a generic for the return value of `offsetGet`. As you point out, things now break. So tweak things slightly further. Let `?` be a type that can be inserted as a generic value: `$arrayOfThings = ArrayWrapper&lt;?&gt;();` `?` stands for mixed. As in, no assertions about type. Omitted generic types would be defaulted to `?` and leaving off the generic syntax would be identical to omitting all generic types from the declaration. To stay consistent with other languages, types can be declared at instantiation time, like these examples, or at class definition time: `class FooArray implements ArrayAccess&lt;Foo&gt;`
I wrote some more thoughts about this in a gist: https://gist.github.com/morrisonlevi/74ec75a525ab71df0c75c16cd759c701.
If you use DDD, and implement aggregate roots, entities, and entity sets, PHP 7.0 + type hinting will take you all the way without any confusion. The trick is to build your collection in such a way that it does not accept elements that are not of type BlogPost. Why should the language offer generics just to fix bad design?
No, If you want a passionate "teacher", find a **worse** university. The better the university, the more weight is put on a professor's research for career advancement and tenure. Never forget that from the lecturer's view point, a low level "service" class is just something that gets in the way of actually doing their job.
Took 13s to load? wow. 1.86s here
if performance is the issue, then I imagine most solutions would require a deep understanding of C.
//6
Even better, what is a specific set of code that is all jacked up without using generics, that is elegant using generics? What is the use case for generics? 
Do you have any other examples of challenges? I'm legitimately interested in this as I'm about to attempt implementing this for the second time. I have recently abandoned my previous idea to duplicate class entries for generic class references. The threads I've read on internals weren't very useful in this regard.
&gt; Currently lambdaphp runs very fast with 128MB RAM and has an average response time is 400ms That response time seems surprisingly long. 
IMO, the proposal could/should be done in a different way, by adding type parameters to PHP traits. This would substantially improve the usability of traits, incur no real runtime cost, and make generic guards of the type used in Java easy to implement. It would also allow PHP classes at runtime to provide different implementations based on the instantiated type, including a default (which might work or might throw an error exception) and specializations for different type cases of interest that override the default.
I don't see how that would work? I want to create a generic Collection class, and be able to specify what type of collection I want in all my classes... I could create a collection for each of the types and copy all the code, but generics would solve that way smoother... Instead of a BookCollection class, I want PHP to recognize that Collection&lt;Book&gt; and throw a type exception if I pass any other collection type in (hard to write up on a mobil phone, but I hope that makes sense!) 
What exactly does the controller.service_arguments tag do in Symfony? In the documentation (https://symfony.com/doc/current/service_container/3.3-di-changes.html) it says: # controllers are imported separately to make sure they're public # and have a tag that allows actions to type-hint services I've removed that portion of the config: AppBundle\Controller\: resource: '../../src/AppBundle/Controller' tags: ['controller.service_arguments'] and just have something like: services: _defaults: autowire: true autoconfigure: true public: false AppBundle\: resource: '../../src/AppBundle/*' exclude: '../../src/AppBundle/{Entity,Repository}' I assume this means my controllers are private and don't have the tag but as far as I can tell everything still functions properly.
When i studied CS we didnt learn a single programming language, we were only tought what we need to teach us any programming language, so math and theories (algorythms, languages etc) i hated it back then, nowadays i understand it - once you are able to teach something (i.e. have course material, certified the curriculum etc) its always outdated
In Symfony 3.3 do we need: # controllers are imported separately to make sure they're public # and have a tag that allows actions to type-hint services AppBundle\Controller\: resource: '../../src/AppBundle/Controller' public: true tags: ['controller.service_arguments'] If we have _defaults: autowire: true autoconfigure: true public: false As I understand it the autoconfigure should take care of setting up the controllers correctly as long as we have AppBundle\: resource: '../../src/AppBundle/*' 
This gist has some more thoughts but some are not directly related to implementing generics: https://gist.github.com/morrisonlevi/74ec75a525ab71df0c75c16cd759c701
Ok, u r right with the argumentum ad populum. Nevertheless, I don't see a reason why it would bring more cognitive load to have method overloading. I certainly didn't feel it when I developed with JAVA. 1. The method name should always be explicit enough, regardless of what arguments it requires. 2. The intent of the method does not change according to its arguments, otherwise it is in fact a different intent and therefore not eligible for overloading. 3. Not having method overloading does not help u not to stop and think about the variables types, u still have the type hinted arguments anyway, so u have to think about them the same. 4. If u need to dive into the method code to figure out what it does, the problem is not about method overloading, it's about poor method naming.
And the remaining PHP5 installs are probably just some hardliners maintaining backward compatibility with multiple PHP versions installed. 
&gt; In summary generics lead to more reusable and safe code but there are definite usability, interoperability, and complexity concerns. I wish more people would at least mention downsides in a footnote.
Quite a few start with https://github.com/nikic/FastRoute
Presumably it’s the cost of warming up the lambda function, Apache, php and everything all in one request. You won’t have a storage engine so you won’t be able to do opcaching or any of that other shenanigans so it will all have to happen on the fly. It’s all a question of trade offs really, slow free site or faster dedicated systems 
PHP the right way? elseif on same line as the closing brace? Nope. Not even once. 
This is excellent news. Hopefully more developers will see this and choose to drop PHP 5.x compatibility. One other area this doesn't account for is using computer on a workstation with PHP 7 and then just uploading the remaining files directly to a server running an earlier version. I know I've had to do this a few times in a pinch.
This is a pretty neat idea. I'm not sure how useful it actually would be, though. Does it upload your composer dependencies as well? The hard 250 MB (uncompressed) limit is concerning. It would be great to run something like this behind a Varnish cache.
Rhetorical/Rea question to promote clarity: Do you have an example in mind of a language with "generics" that does not have a static compilation phase or programmable pre-processor?? Generating code at compile/pre-processing time is a key feature of all the popular languages using generics. If you want to generate those new pieces of code, parameterized by types, at run time, there is going to be some runtime cost, but hopefully the cost is acceptably low and only happens at initialization. This reality is being slightly hidden in your feature request because you are not asking for fully generic algorithms like C++, but only built in support for type guards like Java collections have. You want to write a class once with type parameter T, and have a different type-guarded realization of that class instantiated when you happen to ask for Collection&lt;int&gt; or Collection&lt;Book&gt;. At runtime, that is like a factory pattern for the class - you could actually write the factory yourself to dynamically pull the routines together at runtime when they are requested, but that is not as elegant and the result that calls 'if !instanceof T throw...' in the code might be less efficent than that the built in mechanics that PHP 7 uses to guard its type signatures on regular functions/methods. You want to write Collection&lt;T&gt; like a regular class, have a runtime preprocessort that takes Collection&lt;int&gt;, replaces T everywhere with int in side that definition, changed the same to Collection_int or something like that. Doing that at runtime is functionally similar to a factory that takes strings representing the type parameters, replaces their use in the code and runs eval on the new the realized class definition to produce a class object. It's a little more efficient in the init stage if it uses PHP internals to do that. It's similar to traits, with extra powr added and a convention for renaming the parameterized class. This would provide something with an expressive power in between Java guards and C++ generics. I suggest that adding type parameters to traits could be elegant in terms of syntax, safer for trait usage, and a well of telling the runtime PHP interpreter/code generator/compiler that you want to use the same mechanisms as PHP7 guards when your trait makes use of parameterized types in its method/function signatures. What does a trait do now? It adds methods and data to a class definition, in a declarative way. You'd like it to add all the type parameterized functions and data members to your type parameterized class, but it doesn't have that kind of power/functionality in the current PHP. The current version of traits is like a special pre-processor that adds only certain types of valid code within objects. S 
rollout your php webapps, websites on the cloud with no downtime. Giving Lifetime Free for opensource projects. checkout http://grandappstudio.com/roll-out
php should be the only language where you have to explain how to use it correctly
That’s PSR-2 compliant! You should be programming to the standards.
&gt; I suggest that adding type parameters to traits could be elegant in terms of syntax, safer for trait usage, and a well of telling the runtime PHP interpreter/code generator/compiler that you want to use the same mechanisms as PHP7 guards when your trait makes use of parameterized types in its method/function signatures. Definitely not the worst type-system suggestion I've heard. Since traits do not exist at runtime there are fewer backwards compatibility issues to consider and I don't believe we ship any traits as part of the language either.
The point is to create standards that everyone follows so as to make code written by different developers seem consistent. Why this particular standard and not closing brace and following branch on their own lines? Because the former's readability issues can be solved by line spacing settings in the developer's IDE, while the latter forces a less compact structure into the code that can't be solved as easily.
OP, was there a reason you were posting this, or did you just assume no one here was aware of it?
[www.techempower.com/benchmarks](https://www.techempower.com/benchmarks/#section=data-r14&amp;hw=ph&amp;test=json&amp;l=7ro933)
Stupid question, but where do discussions about RFC actually happen among core devs?
You don't see any value in type guards either then.
I've been trying to find a right way to write PHP for 12 years. Trust me, it doesn't exist. Hopefully we will be switching to Kotlin soon.
Not really, no.
Good, because you're not forced to use any of this, it's an option for those who want to. So it's not a problem for you anyway.
Wouldn't the best solution be to just do the C#/.NET thing and leave the current ArrayAccess as is and a new generic ArrayAccess. Therefore both ArrayAccess and ArrayAccess&lt;T&gt; can both be defined. Implementing non-generic ArrayAccess is still possible and is identical to current semantics. But implementing ArrayAccess&lt;int&gt; would also be possible with greater type-safety. 
I'd like to see a potential syntactic example of this as I'm having a bit of trouble wrapping my head around how that work. 
The mailing list. Don't join it if you value your time or your sanity. 
Here are some benchmarks https://benchmarksgame.alioth.debian.org/u64q/measurements.php?lang=php https://benchmarksgame.alioth.debian.org/u64q/measurements.php?lang=go https://benchmarksgame.alioth.debian.org/u64q/measurements.php?lang=node
Oh it will be no time at all before the cargo cultists start demanding it be required. But if I wanted to work that way, I know where to download Java. If you want Java - go use Java. This is "not java". This is PHP. I like it as it is.
I looked at what they have there. IMO it is not very realistic about "production" environment. It is single process, single threaded test, arbitrary database, and everything can be precoded. The optimal PHP "solution" would store the queries and an anything else that was relevant as fixed constants, use the built in PHP "web server" (-S) and maybe a SQLite file database. That would give a huge performance boost to the PHP "solution"...
Aaaand that's why we can't have nice things. 
At present, the syntax for traits is: trait Identifier { ...data and function declarations .. } That part is trivially each to change because there is a unique space between trait and Identifier we can fill with whatever we like - e..g &lt;Type1, Type2 implements Interface-I, Type3 extends Type4&gt;...etc., inspired by C++ - then within the body, Type1, Type2, and Type3 are used as written where PHP allows types to go, which is in method signatures, instanceof, new, and a few other places. We get more power from the design if they are allowed to call or instantiate other type parameterized code, but that also comes at higher implementation and, in PHP's case, runtime cost where it is used. At present, traits are only allowed within class definitions. At present they also don't declare data members though they can define __construct functions and dynamically create data members... So we have currently legal PHP: trait preGeneric { public function __construct(int $x) { $this-&gt;val = $x; } } could become trait &lt;T&gt; actualGeneric { }
&gt; Kotlin I'm sure you'll find many developers versed in Kotlin.
&gt; The engine would complain: &gt; Fatal error: Declaration of GenericCollection::offsetSet(?T $offset, $value) must be compatible with ArrayAccess::offsetSet($offset, $value) interface &lt;T = mixed&gt;ArrayAccess { ... } This is a generic interface with a default "mixed" for T, which means if you don't specify any type, as it is with legacy code, the item type is assumed to be "mixed" (which is the default typehint if no typehint is specified), and if type T is specified, then it's enforced. So we need generics with defaults, and a type like "mixed" or "any" to stand-in for "any type at all, including no typehint". Simple.
Are you willing to write some phpt files? It's just a php script and the expected output, for functional testing. The authors of the previous rfc wrote some, but the coverage is not complete and I think some changes are necessary too. I'm going to attempt implementing generics for the second time after symfony con. If you want to assist, let me know and I'll keep in touch.
I don't think that the slowdown is much of a concern. For all existing code (classes and functions without generics) we'd only be evaluating a boolean when doing type checks. Everything else is done on compile time. As for classes/methods with generics, the types would have to be looked up in a hash map (likely on runtime, when type checking), but it's faster than the instanceofs that people are currently putting in userland right now to compensate for lacking generics. It's possible that a solution where you duplicate the class map when compiling a generic class reference and translate the generic parameters to their respective arguments is doable, saving the runtime cost. But I couldn't figure out how to reconcile that with the fact that getting the class map which needs duplicating might require autoloading which is only triggered at runtime. The opcache size cost of duplicating class maps is roughly the same as what we do today in userland, defining multiple classes instead of a generic one.
Since demand for creating website is increasing so doing a PHP developer course is very beneficial these days.
Comparing php to go in terms of speed would be like judging a fish by its ability to climb a tree. One is interpreted and built for development speed. The other is compiled and built for runtime speed.
That's an awesome proof of concept, I've been wanting to do that for some time I'm really happy to see this! On GitHub I couldn't find the code that compiles/prepares all the utilities like the PHP binaries, do you have a link to them?
PHP 7 has had such great improvements in speed, it would be interesting to find out the results. I don't really understand the analogy as speed is certainly a factor in deciding which backend language to use. In the past, Node.js has been touted to have incredible performance, while PHP was considered slow. A benchmark performance for running similar tasks would be nice.
It's true that it's possible to do this without generics. But offering an easier way to do it, requiring you to write less code, not only makes for a clearer codebase, but also prevents a lot of bugs. I'd prefer that this kind of abstraction is something the programmer should not always code from the beginning himself, but rather let the interpreter take care of it. Less room for errors.
Feel free to make it better then: https://www.techempower.com/benchmarks/#section=code&amp;hw=ph&amp;test=json&amp;l=7ro933
There are downsides?
Call me stupid, but why not introduce the ability to pre-compile php where static optimizations can be done because all code is known?
I wonder if you could run it behind cloudfront to lower requests, and somehow optimise it to get the response time down
good to know
no, there is no native function. you should ask this kind of questions in /r/phphelp 
You can use the modulus operator for your specific example: ```php // Somewhere in the loop, $x equals 13 $x = $x % 10; // $x now equals 3 ``` You can then offset it by however much if you want a different range, e.g. 11-20: ```php // Somewhere in the loop, $x equals 28 $x = ($x % 10) + 10; // $x now equals 18 ``` The modulus operator is a mathematical operator available in pretty much every programming language.
Interresting, are you thinking about complecity and interoperaility in the Compiler? If a function takes an argument Collection&lt;Book&gt; $books, then it shouldnt accept an array with a tea-pot in it, all this does is gives us more opertunities to write safer code (against ourselves ;) ) 
Yeah, I like this too, but it might make the php source code bloated if "we" need to copy a bunch of types, to make a simple version, and one generic version :/ I think having ArrayAccess&lt;mixed&gt; to be a generic default sounds pretty good to me :)
Thanks! I will look into what /u/MorrisonLevi have made... What other Types/Classes do we have to consider? Traversable Iterator IteratorAggregate Throwable? Serializable? Closure Generator Is there any "working-group"/repo where this is already worked on?
Cleaner code :) Right now I have: /** @return Book[] */ getBooks(): array {...} In a perfect world I want getBooks(): array&lt;Book&gt; I have 2 reasons: if I create a function that should only have a list of `Book`s, I want PHP to controll this for me so I don't have to Second, I don't like Annotations/Docblocs and want to avoid them as much as possible (i feel it's okay for Aspect oriented programing, like defining routes and table relations etc), but not for defining argument- and return-types. 
I feel like this article doesn't do enough to explain why you should want to use one over another. All of these packages are not, strictly speaking, directly comparable. For example, PHPUnit is the _de facto_ standard framework for writing unit tests in PHP, but Codeception is a framework for sending commands to Selenium, the browser testing automation system. There are times when unit tests make sense (most of the time, probably) and times when browser tests make sense, but browser-based testing is slow and fragile so its use should be limited to test cases that are very deep and critical to the application (think "checkout"). Unit tests are meant to be isolated and by necessity very shallow, so you want lots of them to create a breadth of coverage. These are just a few of the considerations when testing software written in PHP; it's more than TDD vs. BDD, it's also about ROI on your testing efforts, runtime, maintainability, and accuracy.
Alright, interresting :) But if we "preprocessed" any Generic class the same, wouldnt the end restult be the same? $list = new \ArrayAccess&lt;\App\Book&gt;() Would have PHP notice the *&lt;* tag, and generate a new class... $list = new \ArrayAccess*any-sepeartor*\App\Book(); Which would look like this (with the nessecary types rewritten): Class \ArrayAccess*any-seperator*\App\Book extends \ArrayAccess But maybe this would make a mess of the PHP sourcecode :D This would also allow a method requiring `ArrayAccess ` to accept `ArrayAccess&lt;Book&gt;`, same with return types 
Isn't that what OpCache does?
Opcache won't throw errors if you try to pass a string as intended to a function, that's all runtime
I have no idea what a phpt file is (but I think I remember something about a project that could extend(?) the php language with macros or similar, that would then be compiled to regular php code... Is that the same? Also, /u/ircmaxell made this something, which looks scary :P https://github.com/ircmaxell/PhpGenerics 
It's essentially a functional test. https://github.com/php/php-src/blob/master/tests/basic/001.phpt
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php/php-src/.../**001.phpt** (master → 0618d7d)](https://github.com/php/php-src/blob/0618d7d2ee9a4c04a009ed12145794691cf7b362/tests/basic/001.phpt) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I agree but there are far more than just unit and end 2 end tests. There are also integration / functional / api tests. And you can decide which level of testing is the most efficient for your case
Sixteen days.
I'm not sure what you mean, but I will take a guess. In Java, "generics" are just type guards surround a common implementations of containers that all take the same type: Java's root object class. The Java compiler does a static check to see if the programmer is really putting Integer in Collection&lt;Integer&gt;, map's ints to Integer, etc. C++ templates are a different beast with completely distinct implementations for each distinct set of type parameters. These different instantiations can, in general, have completely unrelated behavior depending on how the programmer choices to specialize the code. The elements which give the different behavior in C++ are a combo of - distinct code objects for each type combo that gets instantiated, 2) overloading and template specialization - in C++ (as opposed to C), function names are mangled to include their argument types in the name and templates instantiations similarly get distinct mangled names. It's a grief causing misfeature of C++ that the name mangling is not standard across compilers or programmatically accessible to the programmer. But it should be. So the idea is to map PHP generics to mangled names - e.g. Collection&lt;Book&gt; maps to something like Collection, book, a library function or other concrete mangleName('Collection','Book') or built in concrete syntax returns that actual name, and instantiation is a factory that creates the relevant class name if necessary, or retrieves the class (&amp; constructor) with that class name, and makes a new object. 
There is an article about a contest to write a web server which can handle 10k rps. It's in Russian, so here is the google translate link: [https://translate.google.com/translate?hl=en&amp;sl=auto&amp;tl=en&amp;u=https%3A%2F%2Fhabrahabr.ru%2Fpost%2F337298%2F](https://translate.google.com/translate?hl=en&amp;sl=auto&amp;tl=en&amp;u=https%3A%2F%2Fhabrahabr.ru%2Fpost%2F337298%2F) Original post: [https://habrahabr.ru/post/337298/](https://habrahabr.ru/post/337298/)
aha :D Thanks, I would love to help out :)
You 
Except where x is equal to the maximum of the range. So in this case 10 % 10 equals 0, you'd need to add an exception for that.
The example given in this post seems like a very strange way to use events, is this an actual use-case for them?
Actually as said in the article, is the way to use to hook into symfony or wordpress core, laravel is a bit different. is something in particular that looks strange?
bye
I meant the way events are used to load a sidebar / add items to a sidebar. It seems a pretty convoluted way to do something quite trivial. As far as I've seen events being used it's mainly for sending emails after a certain action has completed, logging data for an action or firing off a second action to perform.
&gt;Remember the good old days when you used to FTP your PHP files, static HTML files, css files to a web server? Now you can do that using AWS haha, what kind of troll page is this?
Currently that's the way how I saw it done in some projects, and explained by some PHP consultants (and is the way how is one with wordpress hook system). if you have an alternative approach, I would be really interested to see it and to add it to the blog post!
Anthony covered multiple approaches on this topic [here](https://blog.ircmaxell.com/2012/03/handling-plugins-in-php.html)
Everything boils down to use case and which technology is better suited for it. You won't be choosing Redis over MySQL when you heavily use FKs although Redis is so much faster than MySQL...
You could say that about any benchmark: you can always write fake code to game the system. In this case, all the solutions are in github so you can look at the code used in the benchmark to see if there's any cheating. Re realistic, Techempower has several benchmarks (look at the tabs in the wide darker grey bar). "JSON Serialization" isn't real production but does show the framework's relative overhead. "Single Query" or "Multiple Queries" are closer to realistic production environments.
This is because it's actually running nodejs with a bundled PHP binary. This is an absolutely terrible solution.
Computer science is agnostic of the technology. University isn't about learning how to bang out code, it's about learning how to apply the theories and methodologies to build software. Aside from that; it's kind of pointless for them to try to keep up. It's not job training. They cannot prepare you in the specific stack you'll be using. The technologies are replaced too quickly. A four year cycle is incredibly long in terms of software changes.
I've just finished the introductory PHP series on laracasts. I wish I finished it before touching Laravel: building up an MVC mini-framework from scratch really *peels off* a layer off Laravel's magic. Anyway, coming from other languages, my personal preference when refactoring is to spot repetitive code and place them into functions. If these functions work on similar data, I place them on the same module. If they work on *the same data*, I place them into classes. I noticed that the instructor's first choice when refactoring code is to create a class and store the refactored code as a static method. I mean, in the whole series there's like only 2 custom functions created. Is this a PHP convention? An example would be when connecting to a database: class Connection { public static function make() { // stuff... } } // vs function connectToDb() { // stuff... } `Connection:make` feels better to use, and adding another related method is a plus. But the function itself doesn't look bad either. What exactly is the reason to go for either choice in this situation? 
I think PHP has merit in the fact that deployments are simpler and that it is resilient to errors. I don't mean resilient to bugs; breaking a PHP application is harder than breaking a Java/.NET application with bad programming. The boiler plate required is less than some of the alternatives which means that a small development team can can more easily handle the cognitive load of bigger applications than they could a more verbose language.
In my case, I used to think that way since that's what I was taught very early on in my learning journey. I mean, a million people hated it, so it must be terrible. As I mature (though still a PHP newbie), then I realized that all languages has its flaws, and it's up to the developer to work around them while utilizing its strengths.
If both of them solve your problem, speed is a valid comparison to base decisions on.
Wow, great and thanks a lot 
Think of it this way: you're a third party plugin developer who needs to add a sidebar item without modifying the core, without extending the core, and without creating conflicts with the userland code. Since the framework/CMS fires an event you can just listen for it and add your sidebar items when you're supposed to. This let's you interact with the system without changing the system at all.
Some of us prefer to be employable.
I understand the useful ness, but I hope we can avoid 1 function packages
If only PHP had some way to classify functions in a way that didn't create conflicts in the global namespace.
I agree, but wanting to see speed comparisons and *strictly* choosing it for that reason are two different things.
That would force people to upgrade to PHP 5.3
Of course. However, one of the main goals of the helper is simplicity. Qualifying namespaces or importing `use` statements can take away from that.
2\. You mean explode(",", $var)? 3\. It's called null coalesce and it was added in php7. $x = $a ?? $b I doubt any other language does a = b ¦¦ c as that's boolean or. 
I see how using generics as an array collection works, but if that's all there is to it, RFC for arrayOf would have passed. Except for defining the types of items in an array, I still am not sure of the whys and whens of Generics. That's probably a really good article title for someone to run with. 
If your target audience cannot import a namespace then surely they don't even know what testing is
Because those applications have tests.
Perl, JavaScript.
1. Use a library. 2. https://3v4l.org/hlWBh - Not sure which variant you want. 3. https://3v4l.org/vKXGP
If everyone were so concerned about "convenience" you wouldn't be able to have more than one plugin. But hey, you do you.
I stand corrected. Ruby does it too. I thought it was just ||=. Tbh I think it's confusing to use ||. 
I want to declare an object on the fly like this: $o = {}; Or like this: $o = { hp: 50, name: "Bob" }; Instead of doing this all the time: $o = (object)[ "hp" =&gt; 50, "name" =&gt; "Bob" ];
Generics, please.
Since I started doing a lot of JS, this is my biggest wish for PHP.
Would love to see 1 &amp; 2! But 3 is actually implemented, you just have to write 'or' instead of '||'.
Nah, it basically reads as _this OR that OR other_ which is how it works regardless of it being boolean context or not. 
This is probably asking for too much, but I want JavaScript's setTimeout in PHP :)
Having thought about this more I really, really like this idea. Very nice idea, u/misc_CIA_victim. I began a branch last night and progress is going well.
http://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html [PHP 7 vs Node.js](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=php&amp;lang2=node) [Node.js vs Go](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=node&amp;lang2=go)
Curious why you presented individual measurements rather than side-by-side comparison?
2. No I mean `$var 1, $var2` as I shouldn't have to resort to using a function for this task. 3. I already conceded in the post that you can do it in ternary shorthand as well. It's just more convenient when you have common syntax among languages. Null coalesce is one of my favorite PHP 7 additions, but that's a bit different as it's also a check for isset().
&gt; Basically I want Javascript in my PHP. Sure, why not: http://php.net/manual/en/book.v8js.php
* Field type declarations * Enumerations * Generics
re: point 3: $x = $a ?? $b;
* Generics * [Typed Properties](https://wiki.php.net/rfc/typed-properties) * Annotations * Remove function declaration (KISS), something like "public myMethod(): void", instead of "public function myMethod(): void" * Main method * [String behaviours like in Python](https://docs.python.org/3/library/text.html) * [BigInt](https://wiki.php.net/rfc/bigint) and BigFloat * [Unsigned integers and float]() * [long long (Integers) and long double (Floating point)](https://en.wikipedia.org/wiki/C_data_types) * [Number Format Separator](https://wiki.php.net/rfc/number_format_separator) * [Lambda: JavaScript and Java style](https://wiki.php.net/rfc/arrow_functions) * Use JSON natively, like JavaScript * Remove "&lt;?php" declaration if the file just contains PHP code * Declare strict_types globally * [Enum types](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html) * [Hack: Async](https://docs.hhvm.com/hack/async/introduction) * Include resources and mixed (or any) as type declarations * [Hack: Null Safe](https://docs.hhvm.com/hack/operators/null-safe) or [Java Optional](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)
**C data types** In the C programming language, data types are declarations for memory locations or variables that determine the characteristics of the data that may be stored and the methods (operations) of processing that are permitted involving them. The C language provides basic arithmetic types, such as integer and real number types, and syntax to build array and compound types. Several headers in the C standard library contain definitions of support types, that have additional properties, such as providing storage with an exact size, independent of the implementation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Why would you hook into laravel? it has its own event system so does symfony
You need event loop for this kind of features. ReactPHP
*Why?* I could understand that in JS since it doesn't have an associated array, but in PHP there's no real reason to make a generic object over an array no?
If I remember right, I actually do use a react loop for a server push websocket feature I'm running. 
I'd like to return multiple variables, like in Python: def select_choice(): ... return i, card # or [i, card] my_i, my_card = select_choice() Of course I can use arrays, but I'd prefer to do like this
I wish scope was like Javascript. I want to automatically access variables above my current function scope like in Javascript. I'm pretty sure this will never happen though.
Can you give a better example of #2? I'm not sure I follow what you're asking for.
Personally, I would rather use `x-&gt;y` than `x['y']`. Fat arrows, and double-quoted keys for setting values is also verbose. (actually, I'd rather use `x.y`, but...) I don't know if that's a "real" reason or not, but interacting with PHP arrays isn't exactly satisfying.
Why not? I return JSON with arrays of objects from my server all the time. Query the database, fill in the object. Return it using json_encode($o); Das it mane.
well if you can create a function inside the object declaration I can totally see the benefit { someFunction: function() { return $return; } } 
And last I checked an associative array passed to `json_encode` also produced a json object. (With the exception of "Objects" with all numeric keys edge case) So `json_encode($stmt-&gt;fetch(PDO::FETCH_ASSOC))` will do exactly what you described no?
The biggest reason is that objects are passed by reference and arrays are passed by value.
You can currently only do one variable per line. Most languages allow you to combine them into one line, comma-separated. Not a huge deal, but very odd why it's not possible in PHP.
Completely agree with this. Ya unfortunately you're probably right.
Support for an array of objects as return type. (Generic arrays, Generic Types and Functions) Example: public function findUsers(): User[] { ... } 
Objects and arrays don’t behave the same way. Picking one over the other due to syntax can lead to some pretty weird bugs if you’re not aware of the difference. 
I can't remember, honestly. I always return an object from the server. I rarely return an array. Objects are so much more flexible and it's easy to expand upon it.
Bolt 3.4.0 has been released with a ton of new features: - Named Repeater Blocks field type, for dynamic fields - Singleton ContentType, for 'one-offs' like a Homepage - ENV vars support - PHP 7.2 support, Nut, Bundles, and more. See the site for details, or check out the huge changelog here: https://github.com/bolt/bolt/blob/3.4/changelog.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bolt/bolt/.../**changelog.md** (3.4 → e024387)](https://github.com/bolt/bolt/blob/e024387fa3732e9c309d9ced8022eba776b95c46/changelog.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dptekft.)^.
Async/await functionality would be nice.
I only agree if outer scope is captured instead of being available as references.
All this, plus method overloading!
But what do you mean by "do one variable per line"? What are you doing to the variables?
That makes sense in theory, problem I am seeing with the current graduates (at least in my area) is they are being taught "this is how you do this in this specific way" instead of the general "here is how the logic flow should work, from there make it your own".
You can use global keyword, but it's not the same.
It's just to group variables that are similar `$var1, $var2;` is the same as: ``` $var1; $var2 ```
Using array looks almost the same now: function select_choice() { ... return [$i, $card]; } [$my_i, $my_card] = select_choice();
Oh, I get it. I But the original example shows the OP wants an object shorthand. And, the reply was "use an array", and I say "no way, Jose!"
The article forgot to mention Nette Tester. For me, one of the best testing framework.
Typed arrays and shorthand closures that actually close over their parent scope.
Ok, you're talking about declaring them.
**Method overloading** Strict datatype without method overloading really pinches. 
This is what happens when JavaScritpers get their hands on PHP.
&gt; Remove "&lt;?php" declaration if the file just contains PHP code Have you even spent a minute thinking about just how fucked up that would be?
Yep, sorry for the confusion.
I did look at github prior to drawing my conclusions. The most relevant question isn't whether or not their rules are precise or whether any solutions cheat the rules. The relevant question is about whether the implied conclusions are accurately informing the consumers of those conclusions. I say "No, they are misinforming them". Why? Because the implementations of their test cases vary a lot in terms of the amount of interprocess communication they are doing and the amount of processing to go from a general readiness to their toy test case, and those factors appear to be dominant in the ranking of results. That isn't what people looking to make a conclusion about languages and frameworks are expecting. 
I want a composer drop in sensitization and validation library for super common data-- like top grade a open source checks on things like a US postal address data structure-- definitive decent name validation on strings representing a name using the Roman alphabet characters and limited other characters. Begged, borrowed, or stolen... but with the idea they would be for super common app data and standalone so that you can just use it-- probably leaning heavily on HTML purifier for comment posts or content submitted from text areas. Currently trying to figure out what structure to use, what parts I think I am good enough to do myself, and what I want to hire Paragon Initiatives Enterprises for in regards to parts I think they may do better with and checking my work. They haven't accepted the work yet, but that is my plan. But, while the built in filter libraries are sufficient-- they aren't great or drop in or fully encompassing of basic application needs at this time. A library with a nice consistent API as such would make designing secure apps so much easier for all parties. And having a parallel library eventually built-in would be even better.
* Method overloading * LINQ * Property Accessors like C# * when() from Kotlin * Data Class from Kotlin (One Line DTOs) * Named Parameters Also a bunch of other features from kotlin. Reading through the kotlin features makes me jealous
It was actually considered somewhere IIRC, but the file would have a new extension, so no problemo.
Because we can, and it's not necessary. It just bloats are code. The extension is called php, then why complicate it. It's a reminiscent from the past. Abstract Syntax Tree, check it out: [PHP AST](https://github.com/nikic/php-ast) [ANTLR](http://www.antlr.org/)
It’s great until you need anything bigger than a simple component. I can’t imagine maintaining even a middle sized application with two templating engines (twig and react) that need to match exactly, even including whitespace.
List comprehensions like in Python, CoffeeScript. http://www.secnetix.de/olli/Python/list_comprehensions.hawk http://coffeescript.org/#loops
Happy to hear that. I had two additional thoughts about design that might be helpful. 1) The '@' symbol isn't used in PHP outside of comments, so @Identifier makes a nice syntax for template variables - less clunky than &lt;Identifier&gt; in case of 1. @T1,@T2,@T3 is less of a win over &lt;T1,T2,T3&gt; in declaration, but a convention of using @T1 and @T2 within the body of the template code would make the code more readable. 2) C++ allows ints and bools as specializations, which is helpful in some designs, especially conditional logic. 3) C++ rules for finding the most specific template to instantiate or partially specialize are overly complex. A lot of that complexity comes from the fact that in template &lt;X,Y,Z&gt; C++ treats X,Y,Z as equal in priority for resolving to the most relevant case when there are specializations available. It is a much easier and more intuitive implementation to think about the first column being the most significant "digit", dominating the 2nd, etc. The second breaks any ties left over from the first,...and so forth. 
Kotlin, Scala, Groovy as JVM languages. This would be awesome for PHP. Imagine this for PHP [PHP VM](https://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html). Not a super set like TypeScript or Flow for JavaScript. 
Enums, generics and the ability to describe function signatures (for callable parameters and return values). Maybe Array keys and values, too. I always wonder why PHPDoc doesn't allow you to specify this. Sure, Javadoc (the thing they copied) doesn't do that either, but that's because Java supports these features itself so the documentation doesn't have to. And maybe first class functions. String- and array callables are just bad. I'd also appreciate something like C#'s properties (using __set and __get really isn't the same) and object initializers to replace the current "fluent setter" approach. Sure you could use a constructor with an array, but then you'd have to memorize all the members because array keys can't be hinted and thus not auto-completed or at least statically checked. It also leaves a lot to be desired as a templating language. That's what it was initially designed as, and it hasn't really become better at it since then. Things like chainable filters, auto-escaping, blocks and inheritance is really missing. Sure, I could just use twig (and I do), but it makes backtraces hard to read, adds overhead and it's a different language when it doesn't have to be 
It's not a matter of _cannot_.
My comment was intended as a general warning, not directed at you specifically :) I too would prefer a more terse syntax, but I work with what I've got. See also: short closures.
Why ? Genuinely asking. I understand their role in compiled languages, but PHP ?
I want: * a hash type * a wholly separate Array type that is a continuous numerically-indexed list. Or at the very least: is_list() that returns whether an “array” is a hash or an array.
If you wanted to throw together an open source project, I'm down for collaborating on it. I have experience with data validation and writing composer packages and if you wanted to write a composer package with an extensible API to allow for different validation types, I have some ideas on how that could be accomplished. 
Doesn't hack have them?
It's for the same reason why we can assert types on arguments and return values. The idea is to have types enforced at the language level to tighten up expectations within a given chunk of code about what a given variable is or contains and preempt a whole class of bugs. Today, I can assert that an argument to a function is a `Foo`. With generics, I could assert that an argument is a collection of `Foo` objects, and exclusively of `Foo` objects with something like `Collection&lt;Foo&gt; $pitiedFoos` in the function argument list.
I can't agree more, static typing and even overloading are IMO the big steps on the path to generics. But bringing AOT compilation to PHP with a static type system (alongside the BC use of default variant type aka zval) will introduce a lot of BC breaks, especially because a function call resolution can involve run time user side logic due to autoloading system.
Dunno, but it seems Hack is diverging from mainline PHP and I'm not willing to jump ship to a fork.
Hmm, wonder if this is going to create another SAPI.
`$var1 = $var2 = null;` 
regarding lambda functions. Do you know why they're considerably slower than imperative for loops? My understanding is that PHP doesn't support true higher order functions and this has something to do with the speed of lambda functions. 
Do you perhaps know which one of the GO tests use IPC or Shared Memory during the runtime? Not a troll question, I simply thought GO would only use when it's doing some type of process communication such as a goroutine.
All this, and dropping the `$` on variables plus explicit variable type declaration, i.e. `User user = new User()` instead of `$user = new User()` or `int i = 1` instead of `$i = 1`.
Is it bad practice to use variables in double quotes? Because I don't see how this could work with variables in double quotes unless people don't really care for that feature. One of the unique things about PHP that I personally like, even if it means all my variables have to have a prefix $. 
But since generics support can be viewed as a whole bunch of additional hints, having related checks still occurring at run time, once the given code path is executed, make it IMO less relevant than if there was an AOT compilation.
"AOT"?
The is_list would be simple to code function is_list(array $array): bool { $count = count($array); for ($i = 0; $i &lt; $count; ++$i) { if (!array_key_exists($i, $array)) { return false; } } return true; }
&gt; With generics, I could assert that an argument is a collection of Foo objects I think i get your point, though this can also be done today with having a class that stores only objects of certain type(s) internally and use it in type hints. 
Ahead of time, you compile to produce something to be executed later (you might say "OK simply compilation"). 
As I stated in the post, `$x = $a ?: $b` is the equivalent to `$x = a || b` (in other language). The null coalesce does `$x = isset(a) ? a : b`
because is a common practice https://laravel.com/docs/5.5/events
Really should be top priority.
Yup! Thanks for pointing that out. Rookie mistake on my part.
Gotcha. I don't really know about internals, so I don't know if it would be nothing more than a run-time check or if the engine could use the additional information to optimize. I would just like it for purely selfish reasons.
This ide was very good for C, but now there is CLion which is awesome !
no.
Yes, but it gets messy quickly, as there'd have to be a subclass of the collection class for each combination of contained types. (And yeah, there can be more than one class reference templated in with a generic.) With generics, you can simply define it once. Note that this extends beyond just collection classes, but they're the most common instance of this being useful and the most straight-forward example.
For the pure language itself, number one problem is lack of tools to do static detection of basic issues like "method not found". In practice, many people use Phpstorm for an IDE that does these sort of checks statically. Other lacks: 1) An easy case/pattern match system that gives better syntax than if (instanceof X){} else if (is_string()) elseif... 2) Ability to compile a subset of PHP to javascript for running in a web browser 3) Preprocess/parse/build tools for doing static/compile time things where that is desired (never required) - e.g. optimization, static metaprogramming, using native libraries, etc. 4) Type support for restricting the ubiquitous array class in interfaces to relevant subsets - e.g. only string keys and values from this set {MyClass,null,string}... 5) To help support threaded programming, it would be nice to have primitives for creation/access of static variables that default to the standard code when a program is not being used for threading and transform to a thread local access when it is - e.g. look up the data structure first using a thread_id key. Library writers would be able to use those primitives with no overhead to create thread safe code. 
Compilation has nothing to do with that, it's about typing.
Right, and how would the Unix magic file work from then on?
For example, everything using MySql or Postgres communicates to a different process. Whereas using Sqlite as a file could be within process, calling a library. Running Apache with mod_php would be within process. Other uses of Nginx and Apache are mostly more than one process so far as I know. I didn't see any use of mod_php in the PHP frameworks I looked at. 
You can in php7
Is your intended target legacy code that needs to be tested? If not, then there should be nothing standing in the way of using namespaces.
You mean like how ES6 does it: `let s = `a string with ${foo} variable in it.` 
This feels like a code smell where a class should be used.
+1 for actual Enums. SplEnum does not seem like a proper solution.
Ah I did forget that JS does that also. I guess I'm too used to PHP's way that I find that method unsightly. Extra parentheses and all. And I never use the backtick so that's also kinda annoying to use. 
... jQuery is dead. Long Live jQuery.
Isn't that what the "use" keyword is for? function blah($param) { $closure = function() use ($param) { //do something using $param } } No idea why you'd want to do that in PHP anyway. 
Threading probably. Or async calls. Probably the biggest drawback for PHP
How would it work with things like PHP FPM ? PHP is blocking 
In PHP, method/function calls are expensive, but yes, we tend to have many small methods. However, for refactoring, I think the author (Jeffrey?) went for it because 2 static methods in a class is a lot better than procedural messed up code. IMO, you should aim for encapsulation first. If your class constructor takes 25 arguments, it is still fine, because now you know that you have 25 variables to work with. Without this, the variables might even be coming from a global variable, declared in a separate file and included on the fly. Then, you can iterate and improve. See for the variables that you do not want to show. Make all but absolutely necessary methods private... this is abstraction. I have recommended this book a few times before in this subreddit because it's so good. Read Paul M Jones, Modernizing Legacy Apps in PHP.
I think you're confusing runtime and language. 
Like the magic method __toString I'd love to see __toInteger, __toBoolean, __toFloat methods added so I could go `if( false === $someobject )` and have the method decide truth
key word args!
A good package manager, and yeah... composer is great... 
[removed]
Implicit scope causes side effects that explicit declarations prevent. There's nothing unfortunate about it. Working, bug free, code trumps pretty code.
Stacks for various languages are obviously different. If you're suggesting that a multicore server will run differently in various languages/stacks then you're probably not wrong? Suggesting that it's misinformation.... That's simply not true. It's just more information. You also suggested "readiness". Many languages have various first time or "startup" costs?.?. It's just a different viewpoint. Too many factors to consider. Suggesting it's misinformation is simply wrong. There's a thousand bad analogies of cars and quarter-miles. It's just one metric, not misinformation. The metric is obviously more complicated than most think.
In the summary charts they show, the headings are recognizable by software package, but one has to dig into it to see what it is they actually tested and what the implementations look like. When one does that, one feels mislead by some of the summaries - because the part that is recognizable and what you want to use to describe the conclusion of the test is NOT what is dominating the difference in performance, and many of the implementations would never be considered because the lack basic functionality that is often taken for granted. IMO, they should have used more realistic tests and required more realistic implementations to run them. Those two things are related. You want an analogy with cars doing short distance. Okay, I ran a test about acceleration getting on to the freeway. The winner was the car that came with a special offer from the dealer that included pre-paid usage of the fast toll lane. "Wonderful! Now I know which fast car to buy. The one that comes with the pre-paid usage of the fast toll lane!" 
There is a project doing that... http://j-php.net/ and https://github.com/jphp-compiler/jphp Not sure I'd run my production code on those, but it does open up some interesting possibilities for the future.
Array type hinting. This would solve so many issues.
Can you give an example of what you mean by PHP doesn't support higher order functions? I don't think that is true. Regarding speed, there is the issue of an extra function call and the extra effort to assemble the lambda function. One expects those to have some cost. If it's a big loop, it doesn't matter. If the lambda function makes the code a lot shorter or easier to understand it's a win. 
Explicit type declaration is overrated and is rarely needed. In static types languages the idea of type inference has gained popularity, to avoid the redundancy in explicit type declaration. Even Java will add this in version 10, while C# and C++ have had it for a while. PHP absolutely doesn't need to go backward this is stupidity, just typed properties is more than enough. 
The point is to avoid the use keyword.
Arrow functions! And proper multi-threaded promise support.
First, `@` is our error suppression operator. I hate it. I don't think using it here will work. The design I am working on does not do any inference; you must declare that your trait has a number of type parameters and when you use the trait you must explicitly pass the correct type parameters. It does a simple substitution at the usage sight when the class is compiled. I *think* this means that `int` and `bool` will work just fine. An example of a trait that might actually be useful: trait OuterIteratorTrait&lt;Value, Key&gt; { abstract function getInnerIterator(); function rewind(): void { $this-&gt;getInnerIterator()-&gt;rewind(); } function valid(): bool { return $this-&gt;getInnerIterator()-&gt;valid(); } function key(): ?Key { return $this-&gt;getInnerIterator()-&gt;key(); } function current(): ?Element { return $this-&gt;getInnerIterator()-&gt;current(); } function next(): void { $this-&gt;getInnerIterator()-&gt;next(); } } Use it and apply type parameters: class C1 implements Iterator { use OuterIteratorTrait&lt;Int, Int&gt;; function getInnerIterator(): Iterator { return new ArrayIterator(range(0,9)); } } There isn't any overloading which means your issue #3 doesn't happen. So... aside from the fact that it's limited to just traits and is limited to simple type substitution... pretty good.
I was looking into becoming a Rail developer.
KISS https://github.com/mrkrstphr/array-config
Classes can be autoloaded when needed, functions cannot. 
Compiled languages in general will have better performance than interpreted languages. Go &gt; Node &gt; PHP
Anyone use it? I tried out the app image for a minute today but have not used it enough to comment
Generics Enums Nullable types readonly properties Also, (this might fall under generics) It would be nice to specify a callable with a return type such as public function doSomething(callable&lt;DateTime&gt; $callable) { } In this example $callable must be a callable which returns a DateTime instance.
I checked a list for operators and tokens and didn't notice @ - must have been a junk list, but perhaps there is some other unique non-identifier character that could work - C++ ran into parsing headaches with &lt;&gt; being ambiguous with less than in some contexts from lt,gt operators. Let's say we are using '-' to separate chars in name mangling. So OuterIteratorTrait gets read initially and stored somewhere as 'OuterIteratorTrait-*-*' (with a field noting it is not yet instantiated). If someone instantiates it with &lt;string,array&gt;, then it becomes instantiated as OuterIteratorTrait-string-array, with a link to an actual compiled class object. If we are going a route with specialization, like C++, then the user is able to right there own implementation of OuterIterator-int-array and there own implementation of OuterIterator-string-*, so the former overrides the default for the arguments (int,array), and the latter overrides for the arguments (string,*/any). What I meant by bool and int is that C++ also allows overriding for, say (int,false) - the specific value false - it could be further overriden by (MY_SPECIAL_CONSTANT_INT,false) if one actually had a need for that. 
I think the problem with that is ArrayAccess&lt;mixed&gt; would be a different type from ArrayAccess&lt;int&gt;. The .NET solution is that ArrayAccess&lt;T&gt; is a subclass of ArrayAccess therefore when you want the untyped version you can use the non-generic version. It is possible to make ArrayAccess&lt;mixed&gt; type-compatible with ArrayAccess&lt;T&gt; for any T but it's that is a more difficult problem. 
Really love stucts and doing just this in Go. Especially just nested structs.
Depends on what your code looks like. I don't think I've closed a PHP tag in years and it only gets opened at the top of the file. If you're opening and closing PHP tags throughout your file, you're doing it wrong.
I like multiple return arguments similar to Go. So I can return my object and an error. Makes error handling so much simpler.
PHP doesn't really have variable declaration. It only has definition. `$var1;` is the same as `$var1 = null;`, and both are the same as not defining the variable at all. I've honestly never even seen anyone use `$var1;` syntax in any modern PHP project.
While I'm sure you had good intentions, this is a very extraneous comment that completely misses my point.
Sounds like you've completely overlooked templating.
The side by side don't show as much information and I don't think there is a way to get all 3 on one page. Here are all of the side by sides: https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=go&amp;lang2=node https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=go&amp;lang2=php https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=node&amp;lang2=php
Probably because I've only used Twig or React and not done in the outdated/bad way in years.
The authentication bit encourages plaintext passwords. :(
Use Java?
Something started the header output. Do you have any empty lines before &lt;?php tags?
Nope, looked for blank lines before/after tags. The weird thing is that this effected files that haven’t been changed for months and never had any problems. Not sure if someone updated PHP or made changes to ini.
Why? If you're expecting a DateTime, just require a DateTime
idk what anything said in this thread means
examples of each?
I'm a fan of syntax sugar $a-&gt;field so it'd be nice if I could just access the standard `[]` as either `['field']` or `-&gt;field`. It gets confusing when you have numeric keys I can understand that.. I tried to implement the standard practice of using objects everywhere but it just got too cumbersome and returned to using the standard arrays unless a class was more appropriate.
Can you log the output of ob_get_clean to a file? I.e. file_put_contents("/tmp/buffer.txt", ob_get_contents());
It would _have_ to be a new extension. It would break backwards compatibility otherwise to use it with just `.php`
PHP defined that `||` is a logical operator and hasn't been overloaded, I use it as a logical operator and would break a few things if they changed it to match the idea of `?:`. There's a reason they added the operator instead of overloading `||`. I'm a fan of having the separate operator, makes intention clear.
I think you're stretching on the *most* part of that statement. There are some, many of the higher order languages do not support auto scope akin to javascript. 
What _is_ your point? Re your comment below. `$var1; $var2;` is exactly the same number of characters as yours above.. I predef variables when I intend to use them as a base normally it's `$var .= 'value';` or similar otherwise it's merely syntactic sugar for your own process..
Seems it's blank as nothing is being written to the file. Another weird thing is that $html = ob_get_clean(); $html = str_replace(" ", "", $html); needs to be at the beginning permanently. As soon as it's removed, the content-type goes back to text/html
Hm, so you're setting the header at the beginning of the php file... are you including any other libraries or is it just one php file? Do you have a closing php tag ?&gt; at the end of the file? If so try removing it. Otherwise, how are generating the xml? Generally I wait until the whole output is ready then set the headers. It is generally good convention to use ob_clean() before the header output then echo $output but if you're inlining the output by opening/closing php tags it's a little more complicated (not much, just have to tweak your output process)
Well, then I'll be the 3rd person to have to ask you: what *is* your point?
Solved: I went through files that were included and in those there were some includes and sure enough, one of the included files had a text/html header that was causing this issue.
Also you might need to replace /tmp/buffer.txt with /srv/www/htdocs/buffer.txt or whatever you document root is because of permissions if the file isn't being written
Thans for all your help. I have found the repetitive header in an included file, so there we two header content types. Dumb mistake.
No problem. I saw this on php.net which would explain the php.ini changes http://php.net/manual/en/outcontrol.configuration.php Anyway I just always do a ob_clean before my headers just in case 
For #2, In PHP 7.1+ you can do [$var1, $var2] = array('val1', 'val2');
The fact that you hijacked this comment thread with an irrelevant strawman, along with having to explain this to you is pretty absurd, but I have a lot of patience. Let's say you have some related variables you want to create that are related. Maybe you'd want to group them together. I'll give a simple example off the top of my head. Let's say you want to find the volume of a rectangular prism. If you were to declare these variables, you might do $length = 2; $width = 3; $height = 12; echo 'Volume is: ' . $length * $width * $height; But maybe you'd want to do this instead. $length = 2, $width = 3, $height = 12; echo 'Volume is: ' . $length * $width * $height; Probably not a great example, but that's the basic gist of it. It's something that I've used a lot in both Java and JavaScript, and really like it (some don't). It is obviously not a huge feature, but I would definitely used it if it existed. 
[See here](https://www.reddit.com/r/PHP/comments/7cwx81/what_features_do_you_thing_php_lacks_the_most/dpuct1o/)
wouldnt use PHP-FPM. PHP would use an event loop like nodejs
In order of how badly I want them: 1. Named parameters 2. Proper multi-threading 3. Generics or at least typed arrays
I was annoyed with CodeSniffer and PHP-CS-Fixer and all their CLI options required to run a simple PSR-2 analysis. It's also not always obvious which tool a project uses for code formatting. `pretty` is a simple command that will guess which command to run based on the config files in your project (`phpcs.xml` or `.php_cs`). If no config file is found, it will run a PSR-2 analysis (and ignore the `vendor/` directory by default). Ideas are welcome!
[removed]
&gt; a wholly separate Array type that is a continuous numerically-indexed list. You might be interested in [Data Structures](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd) extension. Vector seems like the thing you want. 
A proper module system
It requires phpcs and phpcs-fixer without declaring the dependencies. It assumes phpcs and phpcs-fixer are installed globally and that the global composer bin is added to $PATH. All you needed was a couple of bash aliases.
Or putting those commands in the `composer.json`, as I did: "scripts": { "phpstan": "phpstan analyse src tests -c phpstan.neon -l 7", "cs-check": "php -n bin/php-cs-fixer fix --dry-run --diff", "cs-fix": "php -n bin/php-cs-fixer fix" }, (`php -n` is to disable extensions, hence xDebug which slows down the execution)
True, but those bugs would still be catched by IDE or static code analysis...
Yes it assumes that they are installed globally, requiring them as dependencies would install too many things for such a small helper. I plan on adding more features like more helpful messages (e.g. for the case you mention above), the ability to run several tools with one command (i.e. "don't make me think"), `pretty ci` for running in CI and `pretty fix` to fix the code. That is why it's a PHP package and not simply a bash alias :)
A function to make a code snapshot, so php can load the snapshot on consecutive calls. Would elimante loads of bootstrapping code.
PHP can short circuit with the [null coalescing operator](http://php.net/manual/en/language.operators.comparison.php).
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This is bad.
i live and work in mexico, if a client leaves usually do it in favor of a south american country or india, usually it boils down to the new teams delivering unmantainable crap. i had once someone put codeigniter over yii2, all the models, views, etc i wrote were doomed and the new version was just as spaghettified as it sounds. another time they found a 'yii experts' team, just they were ~5 years behind and only used yii1, they didn't even knew how composer works and were used to 'download library'. other time i warned extensively the client to not let the guys do that, and force them to deliver yii2 code or it will simply not work. the team was from india and they didn't understood MVC, they had a controller like this public function actionCreate() { $model = new Product(); $model-&gt;name = $_POST['name']; // ... etc if (strlen($model-&gt;name) &lt; 4) { $model-&gt;errors['name'][] = 'name too short.'; } // ... etc Yii::$app-&gt;db-&gt;createCommand('INSERT INTO ...'); } I even asked at a PHP meet up in my city how many yii devs assisted, counting me and a coworker we were 4 and we all agreed that we kept the client for good after first delivery because they can't go anywhere else.
Just in time compiler (JIT) Async/await - https://docs.hhvm.com/hack/async/introduction Generics - https://docs.hhvm.com/hack/generics/introduction Enumerations - https://docs.hhvm.com/hack/enums/introduction XHP - https://docs.hhvm.com/hack/XHP/introduction 
At the very least you should add them as suggestions to composer.json. Claiming that there are no dependencies, while requiring those tools will only result in confusion and issues titled "halp it say phpcs: command not found".
Let's be clear here - framework has nothing to do with this :) This is just relying on shitty companies with code monkeys and general greed and not understanding the IT side of it at all. You can deliver absolutely unmaintainable piece of crap with Symfony, Laravel or any other framework out there. This has nothing to do with frameworks at all.
JIT is [in the works](https://github.com/zendtech/php-src/tree/jit-dynasm/ext/opcache/jit), though, we probably will not see it anytime soon.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [zendtech/php-src/.../**jit** (jit-dynasm → b0b450e)](https://github.com/zendtech/php-src/tree/b0b450eb8000fb088127f9af17c9852f3cc46b6b/ext/opcache/jit) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Why not thanks for the idea, I think very clear error messages with good instructions can be helpful too.
This is the POV of the maintainer of a single project. As a contributer or user, when I clone your repository, I don't know what to do. I don't want to check out composer.json to see if by chance you set up those aliases (and what their names are). I just want to run the same command every time and be done with it ;) Also as the maintainer of several dozens of projects I don't use the same tools on every project (blame me of course). Simply running `pretty` is a good abstraction on those details.
Why not thanks for the idea, I think very clear error messages with good instructions can be helpful too.
This is the POV of the maintainer of a single project. As a contributer or user, when I clone your repository, I don't know what to do. I don't want to check out composer.json to see if by chance you set up those aliases (and what their names are). I just want to run the same command every time and be done with it ;) Also as the maintainer of several dozens of projects I don't use the same tools on every project (blame me of course). Simply running `pretty` is a good abstraction on those details.
i know, my point is that its very hard to find a team knowledgeable enought to NOT deliver crap in yii2 at least in my experience. yii2 is the best framework for me, and on my team everyone has a hard time learning it but once they manage to get the grip they really learn to love it. 
Why not thanks for the idea, I think very clear error messages with good instructions can be helpful too.
This is the POV of the maintainer of a single project. As a contributer or user, when I clone your repository, I don't know what to do. I don't want to check out composer.json to see if by chance you set up those aliases (and what their names are). I just want to run the same command every time and be done with it ;) Also as the maintainer of several dozens of projects I don't use the same tools on every project (blame me of course). Simply running `pretty` is a good abstraction on those details.
Arrow functions so we dont have to use ($variableOutsideFunctionScope) all the damned time.
Last updated 15 days ago. This is good news.
Sounds like a good plan, but it's disappointing to see no mention of named capture/subpattern. If the user writes a pattern with a number of alternatives in an alteration, it's helpful to get a tag back saying which one was (already) matched.
Do you remember the name of the fork?
PCRE has supported named subpatterns since forever and the upgrade to PCRE2 doesn't change that. Though what you describe sounds more like marks rather than named subpatterns, which PCRE also supports since forever, but PHP only exposes since 5.5 (I think).
collections, mostly. so we can have some nice syntax sugar.
[yes, they do](https://docs.hhvm.com/hack/generics/introduction)
&gt; Method overloading Out of curiosity - can you show an example use case for these in PHP that you think can't be done already?
AFAIK, named subpatterns is the PCRE term for what I described and marks is something different, changing control flow. Why bring up named sub-patterns as a desirable feature while it already appeared in later version of PCRE (1)? Because it's a desirable feature that would have to be exposed within the std interface, and here language developers are revisting the std interface and may add to it in the future. I imagine that the exiting interface was created before named sub-patterns where added to PCRE, though I don't know the actual history.
Good introduction to events. Be curious to see where you end up. Hopefully you have some sort of production ready plugin architecture in mind. One very minor point. I tend to have a custom event class for each event therefore the name becomes a bit redundant. I use something like: $dispatcher-&gt;addListener(SidebarEvent::class, $addHomeListener); You always need access to the event class anyways so it's just one less thing to have to name and maintain.
So, first of all, I didn't hijack anything. I replied to your own confirmation that you were, in fact, referring to variable declarations [here](https://np.reddit.com/r/PHP/comments/7cwx81/what_features_do_you_thing_php_lacks_the_most/dpth87k/) by pointing out that PHP *doesn't have variable declarations*. You seem somewhat confused by this (still), as evidenced by: &gt; If you were to declare these variables, you might do Secondly, you completely conflated your point by citing `$var1;` and `$var1, $var2;` syntax in your prior examples, which thoroughly confused not just me, but basically everyone else that replied to you. No one could understand why you would ever do something like this in PHP. Those are variable declarations, and in languages where you have to declare variables before using them, it's very common. But PHP isn't one of those languages, and you don't declare variables before using them (being loosely typed, there is nothing to declare!). PHP has something of an "assignment is declaration" model. `$length = 2` is *not a declaration*, it's a definition (assuming it's the first assignment), hence my last reply about the distinction between the two. Lastly, there was no "strawman" in my reply, because there was no argument. My intent wasn't to argue with you. It was to explain to you that the language doesn't have declarations, and the syntax you were referring to doesn't make sense in a language with no declarations. With respect to your latest explanation, the whole point of comma-delimiting such code in other languages is to avoid keyword repetition for each variable (whether that's type keywords [`int`, `float`, etc.] in a typed language, or just `var`, `let`, etc. in others). The languages that you cite (Java, JavaScript) both have definition keywords of some sort (types in Java, and `var`, `let`, `const` in JS), and stand to benefit from shorthand syntax like you're talking about. For example, in JS, `var length = 2, width = 3, height = 12;` saves you from having to repeat the `var` keyword several times. PHP, on the other hand, doesn't have definition keywords, as variables are defined whenever they're assigned to. There is no repetition to be avoided with this kind of syntactical sugar, and you can already just do `$length = 2; $width = 3; $height = 12;` on a single line if you wish. The ability to use `,` instead of `;` there wouldn't save you a *single* keystroke.
In the works https://github.com/fiberphp/fiber-ext
Can you please provide an example of what you have in mind here? This is what I have in mind when using the term "named subpatterns": https://3v4l.org/I6IJV (see the `"a"` and `"b"` keys in the matches array).
Thanks, that is what I meant. I looked in the manual at php.net and didn't notice any mention of it. I saw a question on Stack Overflow that claimed PHP didn't have that capability. Now I see it does and the manual has a brief note embedded within the section on sub-patterns: "It is possible to name a subpattern using the syntax (?P&lt;name&gt;pattern). This subpattern will then be indexed in the matches array by its normal numeric position and also by name. PHP 5.2.2 introduced two alternative syntaxes (?&lt;name&gt;pattern) and (?'name'pattern). " Clearly there was consensus about that being useful. 
I actually find this more of a flaw in other languages like JavaScript. `||` should return a boolean. Making this operator behave completely different in another context doesn't make sense to me.. 🤔 
Generics and typed properties.
Are you on Twitter?
I did pick a poor example. I think a better example would be for things such as middleware. This is a typical example with PSR middleware. public function __invoke(Request $request, Response $response, callable $next) : Response { // Do something with $request/$response // Call the next middleware return $next($request, $response); } The $next callable must return a Response instance.
Hello Java, my old friend. I'll simply entertain myself. https://www.youtube.com/watch?v=38i3lMOkwAw
My old friend, I recall The times we had are hanging on my wall I wouldn't trade them for gold Cause they laught and they cry me and somehow sanctify me And they're woven in the stories I have told And tell again My old friend I apologize For the years that have passed since the last time you and I Dusted off those memories But the runnin' and the races and the people and the places there was always somewhere else i had to be And time gets thin my old friend Don't know why, don't know why Don't know why, don't know why My old friend this song's for you Cause a few simple verses was the least that I could do To tell the world that you were here 'Cause the love and the laughter will live on long after All of the sadness and the tears We'll meet again my old friend Goodbye, Goodbye Goodbye, Goodbye My old friend
Lost me on that one. 
If you take a look at the post, a lot of people actually agreed me. It's because it's common in other languages, and would be useful to someone with background in JavaScript for instance. That's fine if you personally don't like it and I respect your opinion. However, some people might and it wouldn't hurt to add it. Like I've been saying, it's certainly not a game-changer (especially since you can just do semicolon instead), but would still be useful for a lot of people if they're used to it.
The top performing entries will be/are the ones with webserver, middleware, and database all running in the same process space, with no form of IPC required. Running special purpose code that is mostly only useful for a given test is a secondary factor that helps in these examples. Is that the kind of real world configuration/performance the consumers of the benchmark are interested in, or is it more like a red herring??
&gt; As a contributer or user, when I clone your repository, I don't know what to do. I don't want to check out composer.json to see if by chance you set up those aliases (and what their names are). I just want to run the same command every time and be done with it ;) So you simple fiddle around in a cloned repository without reading the README.md or CONTRIBUTE.md? If there is none available... don't fork/clone the repo. A good repository should always have at least a README containing a notice on what to do if you change stuff in there.
Pretty sure you could run it (or any other Amazon service) behind Cloudfront.
I thought `phpcs` had an XML file that would let you make configurations without putting them on the command line. 
covarient object return types template classes (i am not sure if this is the correct phrasing)
https://github.com/HakimCh/Router
I agree, feels so sloppy to say: public function findUsers(): array { ... } 
This is why I’m switching to Golang. It trumps PHP performance, as well as being fun to write. It’s not as easy as PHP at the beginning, but once you get used to it it’s actually pretty awesome.
Have they implemented internationalization support?
If you use the Translate and Labels extensions together, it's pretty easy to do multilingual websites. 
Sometimes, but other times you have a model or set of data that does not have a specific set of attributes (common in mongo/dynamo world), then you just end up with magic methods being used which I consider worse...
&gt; it doesn't show as much information That's correct, it only shows measurements of the programs with the fastest elapsed time at-the-highest-workload for both language implementations.
the point is not only that this could be done due dynamic nature of language, but how many `if`-s this will introduce.
Will there be any performance boosts with the newer implementation?
I recommend PDO
hi! thanks! The idea is to have a 360 degree overview on strategies to build plugin based applications. Regarding your example, is a bad practice to call the even in the same way as the event object. is not uncommon to have the same event object binded on different events. An example can be found here http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#listening-and-subscribing-to-lifecycle-events There are two events (postUpdate and preUpdate) and as event object they have LifecycleEventArgs. the naming of the event object with a suffix "Event" is just a convention and is common to not adopt it
While PDO is great too, there's nothing wrong with using MySQLi prepared statements. If you're switching among the small amount of databases it supports, then I can see a reason to use it. Other than that it's a matter of preference.
**Modularity**. Meaning the ability to declare arbitrary variables scopes. see the [wikipedia!](https://en.wikipedia.org/wiki/Scope_(computer_science)#Module_scope) For me this is critically important in a non-compiled language. Sadly the directions of development seems to be more about trying add features of compiled languages.
&gt; small amount of databases PDO supports I don't think 12 is a small number for supported databases if you've got all your money in mysql, then okay but otherwise, yikes if you ever have to support something else! outside of that, PDO has named parameters. I could never go back to mysqli
Too long with a lot of irrelevant rant, some false claims and one epic blunder. &gt; it should be noted that bind_result() may not be used with the * wildcard selector. Bullshit. &gt; get_result() - can be used in any case; wrong. &gt; Error Handling mysqli_report() and forget of that "fairly easy" `echo "Prepare Error: ($con-&gt;errno) $con-&gt;error";` on the every fucking line &gt; You're probably thinking that I'm an idiot for making that query susceptible to SQL injection. You are. This alone paragraph makes whole article unsalvageable, making apparent that you don't understand what prepared statements are and what for.
There is too much wrong with using mysqli prepared statements. [Mysqli WTFs](https://phpdelusions.net/mysqli/wtf) and it's not even finished
I greatly appreciate your feedback, but certainly not your attitude and cursing at me. Just a tip, if you're going to act so arrogantly and ridicule someone, at least be correct 😉. Everything you mentioned is just plain wrong. Try and use `bind_result()` with wild card. And yes, `get_result()` can be used for every case in a SELECT. If you're referring to the fact that you can do [this hack](http://php.net/manual/en/mysqli-stmt.bind-result.php#85470), then you technically can. Though I did link to it in the article anyway. I suppose I could make that clearer. I provided error handling that pretty much just uses the `$con-&gt;errno` and `$con-&gt;error` for the MySQL connection and `$stmt-&gt;errno` and `$stmt-&gt;error` for the prepared statement after execute. This does give meaningful messages and has helped me debug problems 100% of the time. &gt; This alone paragraph makes whole article unsalvageable, making apparent that you don't understand what prepared statements are and what for Explain to me how you'd be able to SQL inject a statement with a server-side variable that you have full control over. I have all day. 
https://twitter.com/hikari_no_yume/status/921764677926969345
&gt; Try and use bind_result() with wild card. Try it yourself. &gt; get_result() can be used for every case read updated version &gt; I provided error handling that pretty much just uses the $stmt-&gt;errno and $stmt-&gt;error for the prepared statement after execute. You didn't. The only example follows that monotonous `if ( !$stmt ` sermon. (which is outright wrong by itself but that's another story) &gt; Explain to me how you'd be able to SQL inject That's *too* commonplace. I'm just not going to waste my time. 
You realize mysqlnd is built into PHP since 5.3, right? How many people are still using versions before that? I can add that as a note though. &gt; You didn't. The only example follows that monotonous if ( !$stmt sermon. (which is outright wrong by itself but that's another story) You need to explain yourself better. Checking for truthiness is correct, unless you can explain otherwise. &gt; That's too commonplace. I'm just not going to waste my time Whatever helps you sleep at night. But you just affirmed my notion that you really have no idea what you're talking about.
Nice, you can work with a lot of the modern frameworks out of the box.
I realize much more than you can imagine. mysqlnd is not the integral part of PHP, it's independent library and you can have 7.0+ without mysqlnd all right (and you do, in many distros. It gets better but still). Let's put it straight, given you consider this "sick" line $age = $con-&gt;query("SELECT age FROM myTable WHERE userId = $_SESSION['id']")-&gt;fetch_object()-&gt;age; as a summit of computer wisdom, you should learn some programming first.
So I proved you wrong on everything you said and now you're moving on to another issue, which what exactly? That it's too long of a line? While that's true, it's still pretty interesting and not that well-known that you can do it. I'll take this as your concession in defeat, as you seem to have no comeback to my replies. All talk, but no action. There's nothing wrong with being wrong. It's only an issue when you combine that with insults and arrogance.
So....the current Apple Macs have a more up-to-date version of PHP than Debian does. Nice.
What are these so called higher order languages. As far as I know, the mainstream programming languages all allow auto scope like JavaScript for their closures. My daily work involves with C# and I can tell you there's absolutely no such thing like use statement for C#'s closures. Other languages like Java, Python, Ruby and Swift also don't make you write such use statements either. 
Its nice to see but updating it isn't as easy. I normally just use brew to pull me the latest. Will move to 7.2 in the spring
Do most people use vms/containers?
Maybe of interest to you: Liip maintain a nice set of php packages for osx. They include a lot of useful extensions I didn't find in other packages. https://php-osx.liip.ch
Given billion dollar funding, I'm sure the Debian project can prioritize such endeavours. For all others just install docker and pull as many versions as you like :wink:
I just meant for the hype it receives it is. But I concede that comment seems misleading. Named parameters in PDO are awesome for sure, along with a few other features. But I still prefer MySQLi myself if I'm just using MySQL. This is what I love about programming. The fact that you're free to choose.
There is another benefit of Golang. It won't type-mangle integers and strings which JS and PHP do and can trip you up.
I Like golang. This is not a reason to use it like a hammer.
True. But the types of backends I’m writing right now are far more suited to Golang than php. 
Right now although it's a total PITA, you can implement a container class that only accepts Book to add, is much more readable, and hides the specific implementation. You can also get template snippets for most IDE's to make it as simple, but a little cleaner than modding the language.
Learn how to use Debian before trying to be whitty.
Yeah, and there's a bug with vagrant and high Sierra that I'm waiting out until I upgrade :(
We use the latest version of Debian at work. Stretch was released 17 June 2017 and has PHP version 7.0. The next version of Debian is likely to be released in summer 2019, by which time PHP 7.3 will likely to be out. Exactly which bit of Debian do I need to learn how to use before being 'witty', by pointing out facts? Is it the unofficial repos that have actually up-to-date versions of stuff? Because those aren't maintained as part of the Debian project, which can make persuading the legal team that it's okay to use them, quite difficult. 
&gt; For all others just install docker and pull as many versions as you like We use docker. It installs packages from the Debian repos. How does that help?
Good for you. More people run PHP on Debian vs. OSX, that's why Debian and other similar arches choose to stick with stable (and maintain the security patches) vs. the cutting edge. You have plenty of options you want to run latter, it's not a limitation of any sort.
Wat? https://hub.docker.com/_/php/ pull the docker hub image? Are you all using a Debian image and installing through apt? Is there are reason for that?
I actually very much dislike that from JavaScript.
Thanks for the heads up on this. Probably saved me a few hours because I was thinking about updating soon.
Generics (even for arrays), union types, method overloading, annotations, some sort of native JSON type, removing the word "function" from class methods (it's literally useless), some syntactic sugar here and there, and finding a way for dealing with haystack/needle order, for food. To be honest I'd like to have an automatic extension of scalar types, so that they can be augmented with methods, and the haystack/needle problem wouldn't simply be there anymore. I think Java did this, in the past.
Here's some more info, I was on my phone before. https://github.com/hashicorp/vagrant/issues/8788
I have built probably ~15 sites on Bolt and I will continue using it for the foreseeable future. This looks like a fantastic update with stuff I will use often. AMA if you have any questions about my experience with Bolt as a developer!
According to a [recent Twitter poll](https://fr.surveymonkey.com/results/SM-3ZC6HGZK8/instant/) by Fabien Potencier, Homwbrew is the most common choice, followed by Docker.
&gt; you can have 7.0+ without mysqlnd all right (and you do, in many distros. Which distros are these please?
Why does it even include PHP at all? Seems like a very odd thing for a graphical operating system designed to be easy to use, where two mouse buttons are considered too complicated for their target user...
Checkout [Rector](https://github.com/rectorphp/rector) - AST-based tool for automated upgrades of Symfony just in CLI
It pulls docker images from dockerhub, not debian (by default)
Which is fine. Like I say, I love golang, I just wouldn't auto-dump php
sorry, inbox on reddit didn't show your awesome comment!
The bundled xdebug is broken (segfaults at boot). Quicklu fixed by recompiling it though
Portability has always been a bad argument for PDO as SQL code is rarely portable itself. A better argument is the common interface and its (relatively) good documentation.
macOS is a true UNIX system with all that entails. It’s only natural it includes some scripting languages. Although I don’t know why PHP specifically is there either. I think it’s to go along with Apache.
Going with PDO will decouple you from the binds of MySQL.
Macs are very popular with web developers that use open source software.
There is no reason not to. Imagine having your dev stack up in seconds with the same version of PHP, mySQL, Redis, Postgres as your production environment has. Or bringing up legacy systems that use much older versions and be sure your code works with those versions. If you're just running any version of PHP and developing with it, are you on PHP 7.0 or PHP 7.1. So how do I know which one the production server is in? Can I use nullable type returns on not? If I'm working on some legacy code, do I know if I can use the new array syntax or not? Is your Postgres 9.4 or 9.5? Can I update my jsonb fields by key on not? Is your caching Redis 2 or Redis 3? Am I able to run mass insert commands on all my sorted set data?
nice job ripping off jafartke's blog word for word. Can't write your own content so you steal other peoples? https://jafartke.wordpress.com/2011/07/25/prepared-statements-in-php-mysqli-to-prevent-sql-injection/
This is my original content. I updated it recently, since I added stuff to it. Take a look at the Wayback Machine if you don't believe. But thank you for bringing this to my attention. I'll contact him to take it down.
Only since 26-Sep-2016 10.12 Sierra. When Apple finally gained a certificate that mac was 100% Unix. It's stupid because Apple took a Unix base and tried to move it away from Unix. And now they want to be Unix again.
Here it's obviously this jafartke is a plagiarist, as there are links in the article to the pages created past 2011/07/25/ so the date is obvious fake
Thanks for sticking up for me 😀
It's not "sticking" "with you", but rather with truth. It's not "disagreements". In many parts you just don't understand what are you talking about and don't even realize that. 
Well the documentation is not that good as it's rather inconsistent and makes many features hard to find. The best argument is that PDO's interface is consistent, predictable and handy. Mysqli is picking up but for the most part it's still a thin wrapper for the mysql API, means you have to do a lot of dirty work (i.e. bind_param, store_result, get_result etc) if using it as is.
You must not be a native English speaker, but "sticking up" means defending. But are you really trying create another unnecessary debate. You lost badly last time, so I suggest you stop now. I tried to end this peacefully, but clearly you like arguments too much.
Why isn't there a cringe emoji 😖
Your main problem is that you don't really understand why prepared statement is so important. You even failed to explain that in your article, bluntly stating &gt; prepared statements are clearly more suited to protect against SQL it is **not** clear from your article at all. There is not a single reason provided. Having no real understanding, you came to the part where you say like "don't use it if you think if's unnecessary" which is an epic fail and makes whole article a pile of garbage. You're a usual PHP cargo cult programmer, who don't really understands the code he writes and whose ideas are just superstitions, like with * in the query. You just heard someone somewhere having trouble with it and took it for granted, neither giving it a sanity check nor a test of your own. And this latter is a problem. Being a honest researcher, you would have tested it yourself and proved it wrong. But you're just a lazy troll saying " I proved you wrong on everything you said". "Proved", my ass. 
&gt; Your main problem is that you don't really understand why prepared statement is so important. You even failed to explain that in your article, bluntly stating I literally explained how SQL injection works in the article. &gt;You're a usual PHP cargo cult programmer, who don't really understands the code he writes and whose ideas are just superstitions, like with * in the query I linked to how you would do it in the article along with a comment, so I'm not sure why you're still talking about this. You should really work on your reading comprehension. I just felt the solution to do `*` with `bind_param()` was hackish for that usage and isn't really meant for it. &gt; you would have tested it yourself and proved it wrong. But you're just a lazy troll saying " I proved you wrong on everything you said". "Proved", my ass Everything in the article is fully tested. Look, I'm all for conceding when I'm wrong and gaining more knowledge, but I've responded to all your notes and explained why you are incorrect. Stop embarrassing yourself with vague comments on how I'm doing things incorrectly without solutions. You're just making yourself look like a foolish jerk.
Your "error handling" code is a distinct example of cargo cult programming that violates every basic rule. If it's intended to be used as is, then it's just an epic fail, spitting errors to the site user. If you would try to excuse it as "it's only intended for debugging" then it would make it even worse, exposing you you a hard working idiot who laboriously rewrites every fucking line in the code every time it stopped working.
\* 2007 https://arstechnica.com/gadgets/2007/08/mac-os-x-leopard-receives-unix-03-certification/
&gt; I literally explained how SQL injection works in the article. You're an idiot. You don't even understand the context of your own article. It's not about "how SQL injection works". It's about "manual escaping/casting vs. prepared statements". And you "clearly" have no idea why the latter is a must. &gt; I linked to how you would do it in the article along with a comment, **You don't need no fucking tricks** to use * in the query, you dumb idiot. 
[The PHP docs](http://php.net/manual/en/mysqli.quickstart.prepared-statements.php) does it like this as well. Not saying they've never be wrong, but just saying. You still continue to give ambiguous responses and avoid mine when I prove you wrong. &gt; If it's intended to be used as is, then it's just an epic fail, spitting errors to the site user I sincerely hope you're joking. Have you really never heard of the concept of using an error log in production?
Stop your tricks. its not about me heard anything. And not even about the PHP docs. It's all about the stupid code **you** wrote and **recommend** for other people to use.
&gt; You're an idiot. You don't even understand the context of your own article. It's not about "how SQL injection works". It's about "manual escaping/casting vs. prepared statements". And you "clearly" have no idea why the latter is a must. Yet again, another ambiguous statement with an insult without any substance or explanation. Either give concrete facts or just stop. I honestly feel really bad for you. &gt; You don't need no fucking tricks to use * in the query, you dumb idiot This shows your ignorance, as `*` shouldn't be used in production anyway. Come on, that's amateur stuff.
Until you prove me otherwise, which you still haven't (embarrassingly not even one of your point), it's fine. I'm all ears, but you only seem to want to curse and insult me without giving any concrete explanations.
You're as sneaky as fuck :) There is **nothing** ambiguous here. In your article *dedicated to prepared statements*, you state that manual escaping/casting is all right. Then you turn to prepared statements **without a single explanation** why it should be used instead. So a reader would think "why bother?". And what's the fucking point of your article then? &gt; * shouldn't be used in production Come on, stop your sneaky tricks, it's not about production. It's about you, not understanding a "problem" with * :)
I can't believe my eyes, you managed to admit that your code is wrong and you have not a faintest idea how to make it right!
Never tried so I might be wrong. Don't you end up with each project running on the same URL and it depends which one you have started at the time?
You're actually wrong yet again (shocker). In the examples I showed, `$con-&gt;real_escape_string()` or casting it to an int or double should suffice (not identifiers like columns or table names, but just values like you are strictly allowed in MySQLi). I'm sure you're going to refute this with absolutely no evidence, as this seems to be your speciality. &gt; It's about you, not understanding a "problem" with * :) Wow, you've really gotten desperate that this has shifted to be your main argument. So let me get this straight. Your lead argument for why my article is so bad, is that even though I showed how to use `*` with `get_result()` in the article and linked to how to do it with `bind_result()` (and really shouldn't be used anyway), I have no understanding of prepared statements? Correct me if I'm mistaken.
I think you've gone insane, which is pretty consistent with your erratic behavior. What exactly did I admit? I just said I'm open to it if you explain it to me, as I'm not arrogant like you to admit when I'm wrong. But I didn't admit a thing.
If you are at a point where regex evaluation performance has any impact on overall system performance, you’re probably doing something wrong. 
\* With hypocritical web developers that only use *some* open source software, but have no problem going full-proprietary where it really counts.
I maintain around 40 open source projects, this is hard. Those don’t always have the same tools. My goal is to save some time to some people. If you don’t need that that’s fine.
Pretty sure IRIX, Solaris, etc. never came with PHP. I'm not even aware of any Linux distributions that come with PHP preinstalled. Just seems very odd, particularly when such a high percentage of users will never even touch it.
nice
Stop pretending you don't understand what I am talking about :) You failed to provide any reason why a prepared statement should be preferred over manual casting/escaping or, in your own words, "why it's more suited". The * query wouldn't have made *any* point if you checked your premises right after you were told that this statement of yours is outright wrong. Instead you started to devise pointless excuses, so naturally it made a hassle (and also made evident that you have no idea what it this "problem" and a "hack to solve it" is about).
You're really all over the place with your arguments. This is the basic gist of what you did. Your initial post was filled with so many incorrect statements and cursing. I then kept proving you wrong so you shifted your focus. There's no sense in arguing with someone with an odd combination of ignorance and arrogance. I've explained this to you already too many times. Either you're stupid or you're being disingenuous. In any case, I truly hope you see a psychiatrist as you seem to have a lot of social problems. Maybe then you'll know how to deal with people.
With hypocritical web developers that only use some open source software, but have no problem going full-proprietary ~~where it really counts~~ when it makes sense. FTFY. 
- removal of globals. - removal of all RDBMS drivers but PDOs - a proper http client. I shouldn't have to use CURL or http_* or download a library for such a simple task. - removal of this array/map in favor of a real array and a real dictionary literals. - access modifiers for classes, right now there is no way to write a private class - removal of register_globals and all these unsafe API In general, too much things are delegated to php.ini. While it made sense 15 years ago for shared hosts, it does not today. PHP security shouldn't depend on an php.ini configuration file.
I personally use Heredoc a lot when writing big snippets of other languages in PHP, eg in tests. I like this change a lot!
Ok, ok, you didn't admit. You just have no idea how to write a code that is good for both production and debugging environment :) Either way, as you rightfully noticed, all these mistakes are just nitpicks compared to the main problem of your article. I am glad it woudn't make a ten points on Reddit and thus will go unnoticed. If some day you'll decide to make it better, first try to understand why it's so important to use prepared statements, make your article less bloated with irrelevant stuff and NEVER EVER mention that fucking shameful query with a session variable stuffed in it. Good luck!
What a surprise, yet another ambiguous comment with absolutely not substance. The PHP manual even checks for truthiness with `error` and `errno`. It's not wrong just because you say it is without any explanation. I'll ask you yet again, though I know that you actually don't know the answer and will hide behind an excuse like "That's too commonplace". Explain how an attack works with an SQL statements attached with a server-side variable that the client has access. That's what I thought. But keep making unsubstantiated claims that do nothing other than stroke your ego and reveal your insecurities.
With Homebrew I don’t even remember the last time I used the built in PHP or Apache.
Debian packages are pretty much always old. Its kinda their thing. "Stability"
I'm not mad as the other guy seems to be, but I run Debian sid on my desktop and can say that calling it unstable doesn't make it justice. It's unstable in the sense that it's not settled, not that it breaks any often. So this is a choice as far as official repos go. I'd probably not run sid on a production server though. Not that it's particularly more unsafe, just because it'd have updates available every day. And as a side note, CentOS doesn't come with PHP 7 by default either and also requires us to meddle with additional repos - although there seems to be official ones.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Wow pretentious much? I'm sorry every version of gnome or kde I've ever used was a piece of crap. 
You still didn't clarify what you meant by that comment tho
https://deb.sury.org/ If you want battle tested version use Debian stable. If you want latest, use this repo or compile it yourself. Apple Macs are not used in production but for local development, nobody cares if they change or break the compatibility of PHP in between the version, nor does apple distribute thousands of packages that may depend on the specific version of PHP as Debian does.
Pretty much this. We're still supporting projects written in 5.6 while our newer projects are on 7.1. switching to a new environment is as simple turning on the corresponding VM. I assume a lot of dev houses has this problem as well. 
This work looks like a promising foundation (updated to PHP7 since the posting): https://pecl.php.net/package/libevent https://github.com/expressif/pecl-event-libevent
Honestly any good IDE/editor with a decent auto-completion would do the auto-import for you. Promoting bad practices (putting more stuff in the global namespace) for avoiding a use statement is asking for trouble
That's a sensible option, and what we're planning on doing....however it still just feels weird, choosing Debian for a reasonably up to date platform, and the first thing we do is have to use an external source to be able to use a version of PHP that isn't security updates only. &gt; If you want latest, It's not just latest. At the end of next year, PHP 7.3 will be released and Debian will have missed two point releases. Also, the only official PHP on Debian will be one that is no longer supported by the PHP team. Which, again, is just weird.
That was more or less the point I was trying to make. There are many choices available, and more of importance than simply which PHP framework you choose.
You do realise that the sole purpose of that application is to interact with the Wordpress API... which is and always will be PHP. We've all been writing JS front ends for our PHP server side code for the last decade. Same goes for .Net, Python, Ruby and a dozen other languages.
To the five people who voted against: why? 
I really like using heredoc, even if the indentation makes my code look a bit uglier, the tradeoff is worth it imo. So I'm glad for these upcoming changes.
Just don't
at least we can maximize our windows
To quote the rfc: &gt;So far no negative performance impacts could be sighted at least from the linked patch. The performance is of course pattern and input specific, the tests show at least same performance PCRE2 vs. PCRE. Some test suite runs with phpunit show even a faster operation on the side of PCRE2, when preg_* functions are involved. 
I think /u/RichardEyre's issue is with NSF. I'm on High Sierra right now and my vagrant box runs just fine.
My reason for using PDO is that there are many many 3rd party packages that rely on PDO. If you build all you code individually then fine, use mysqli. But if you want to take advantage of php's eco-system then PDO is really your only choice.
Gonna be harsh... The first paragraph is just cringeworthy. I get you were trying to set a scene but it's so far from what would actually happen it just made me want to stop reading. Then I scan further to see the code and it's what I would have expected to see in 2005 or something. It seems you're also quite a distance from what is considered normal php development practices.
It's not something I've tried. Homebrew has been enough for my needs and gives the flexibility to jump between projects without waiting for it to up/down. 
&gt; a wholly separate Array type that is a continuous numerically-indexed list. [SplFixedArray](http://php.net/manual/en/class.splfixedarray.php) ?
Thanks! My OOP is a bit rusty, so these are some great points to think about. The more I use it, PHP is starting to feel like a hybrid of C and Java :D &gt; If your class constructor takes 25 arguments... How often does this happen? There should be a better way of structuring classes, especially in a language that doesn't support (AFAIK) constructor overloading?
jwilder/nginx-proxy was the first viable solution for this use case (and it's still very good at doing its job) but nowaday, there are more powerful alternatives. Take a look at [Traefik](https://traefik.io/). It answers the same problem (it's a reverse proxy) but it does much more (SSL encoding, Certificate renewal with Letsencrypt, advanced logging, etc...)
Thank you for sharing. I'll look at it.
Probably, but not always. If you need to withstand thousands of regex matching, based on the user's input, I'd be glad if there were _any_ speed improvements. :) I don't think I'm at that point, actually,... I was just being curious.
Yeah, I read that, too. I was just curious if there are, maybe, some difference benchmarks, or whatnot.
You were right. So I deleted.
&gt; Then I scan further to see the code and it's what I would have expected to see in 2005 or something. It seems you're also quite a distance from what is considered normal php development practices. I will welcome criticism. But please elaborate on this. 
That's the entire point of Debian stable. No breaking changes on a release - security updates only. You think that's bad? RHEL and CentOS are on 5.4.16 and will be so until at least 2019.
The change has no real advantages ("pretty"), and moving from ^SYMBOL; to SYMBOL; for the string terminator is a breaking change. (Didn't vote, just instinctually conservative about engineering).
My guess would be because it overcomplicates the feature by adding a number of additional rules and restrictions that must be followed, increases the chance of the end token being false flagged in the content as well as parsing the content relative to a token which isn't known until after the content is defined, and parsing content that is explicitly defined as not to be parsed. For a feature request that only brings syntax-sugar to the table, that can be an uncomfortable trade-off. 
Considering the question is "how are you installing PHP on MacOS" I'm not surprised. The containers/vms wouldn't be MacOS.
I'm not gonna visit that page if that's what you want. Just use regex101.
Given how often writing “beautiful code” comes up non-ironically in articles and conversations, I’d argue that “pretty” is indeed a real advantage. A small one to be sure, but not one that can be completely ignored. 
I’m not affiliated with them in any way, so I don’t care if you do. How does regex101 answers my question? Did you even read it?
While your code does work and is functional it would provide some issues for maintenance and while this is example code it still makes me cringe. 1. Using super globals directly. Basically, it's like using globals and you then become dependant on the super global instead of using sessions or request objects. 2. You don't have brackets around your one line if statements. This can become a real pain. 3. You used the way of binding that uses the variable instead of the value. Then change the values of the variables this obsfucates what is going on and makes it harder to read. 4. $age = $con-&gt;query("SELECT age FROM myTable WHERE userId = $_SESSION['id']")-&gt;fetch_object()-&gt;age; This provides the chance for a fatal error. Also, the session id comes from the session cookie, therefore, can be subject to tampering. 5. Overall I get the feeling that you're building from scratch instead of using a framework. I may be wrong but it's just a feeling I get.
Looks good.
Thank you for taking the time to write your remarks. I truly appreciate it. 1. That's correct and I see your point. Normally I'd do something like `$age = (!empty($_POST['age']) ? $_POST['age'] : '')`. Null coalesce could be used too if truthy doesn't matter. But this was another purposeful choice to keep things as simple as possible. I'd be open to changing this as well, but it's kind of a trade off situation. 2. I agree that explicit `if` is better than implicit, but again, this was purposefully done to be terse. Also would be open to modify this as well. 3. Sorry I don't quite understand this, can you please clarify? 4. Some sort of sanction would be more ideal with a ternary or null coalesce, but again this was to be concise. Your second point about it being subject to tampering is actually incorrect. In the article I noted that the session cookie representation can be tampered with client-side, but `$_SESSION` is a superglobal server-side variable that you have full control over. 5. Yep, I generally don't use PHP frameworks. Especially not for small projects, but that's just my preference. Overall, there's a lot of tradeoffs going on. Should I be more concise/readable or should I be more correct syntactically? Like I said, I'm very open to modifying my article and listen to suggestions. Thanks again for the feedback.
I'm not massive on docker so I could be missing something but this seems so blatantly obvious it's not even worth talking about. Using virtual hosts to host multiple sites on a single server has always been done this way, has something in docker made it difficult in the past that you thought it now needs a tutorial?
You can map different ports to different services. So you can have one site running localhost:8080 and another running localhost:8181 (or whatever you specify). Unless you are working with a lot of systems up at the same time that communicate with each other, you can just leave them as the default port.
&gt; My guess would be because it overcomplicates the feature by adding a number of additional rules and restrictions that must be followed I think it does the opposite. It takes away the rules and restrictions of the terminating symbol having no indentation and requiring a newline. The side effect is there's now a little room for error I suppose, but I think it's pretty self evident and easily avoidable.
I can be bouncing between 3 or 4 separate clients at any one time.
It hasn't been updated in 4 years.?
Nothing about ubiquitous language or domain expertise. I think you should remove the DDD from the title of this post as it focus only on technical details. This is how you end-up with applications which have lots of Controller, ValueObject, DTO, Command objects but you can spend hours trying to understand what the fuck it does or what value it adds to your business. And for most php applications it gives something so over-engineered it becomes a mess to maintain. Just to handle http requests. It's not like most of php code is for long-lived processes.
&gt; I think it does the opposite. It takes away the rules and restrictions of the terminating symbol having no indentation and requiring a newline. There are three new scenarios that can cause parse errors, and the changes in the end token can cause backwards compatibility issues with existing code. I also would not expect the following code to fail at a glance: echo &lt;&lt;&lt;END END{$var} END; &gt; The side effect is there's now a little room for error I suppose, but I think it's pretty self evident and easily avoidable. I'm fairly neutral on the change, but from an engineering standpoint it's bad form to simply handwave the issues away like that and I can fully understand why certain individuals may be opposed to the change.
Pointless title, this has nothing to do with Laravel you're explaining how you to use the Highcharts library which is Javascript. Even linking this to Laravel the code is of extremely poor quality. You've used Javascript directly in the view template file why not use separate JS files and include them using blade. You directly link to the highcharts CDN whats the point in this when NPM is set-up already for you, simply include the library. Your controller, although small, you still manage to make an absolute mess. Business logic in your controllers instead of having it in a model and the logic you have is running raw queries with unfiltered user inputted data. Complete car crash, please no one copy this.
hire php developer
Probably, the best tool for your case would be [Phinx](https://phinx.org). It's really easy to use and has nice documentation.
Doubt you'll get an answer to this, as this is yet another a dubious claim by /u/colshrapnel
simple stack overflow solution: https://stackoverflow.com/questions/7401141/php-mysql-like-button
Ubiquitous language is mostly reflected at class, method and variable names, so its a much more fine grained level than what im aiming at in this post. DDD is also about services, repositories, adapters, and so on, of which i talk about in the post. This post is not about DDD, its about how i fit it together with other concepts. Ppl write whole books just about DDD... It actually feels like you didn't really read the blue book... And yes, we get plenty of objects, it comes together with the SRP, and thats how we keep applications maintainable. Not following some kind architectural strategy is why many companies with big applications have to rebuild their applications every 3y, when not less. Long lived processes have nothing to do with it, long lived applications have everything to do with it. Anyway, tkx for the feedback, I always appreciate it. :)
A lot of devs, including myself need to use xcode and photoshop. It’s part of the job. You like putting food on the table, don’t you?
Have you tried reaching out to the author and seeing if he'll compile a version for linux for you? If he could do it for Windows and OS X, I can't imagine why he can't do it for linux as well. OS X is close enough. 
You might try : https://alternativeto.net/software/regular-expressions-101/?platform=linux https://alternativeto.net/software/regexbuddy/?platform=linux has other results as well.
Huh? The question was 4 months old and the github project (links above) focusing on libevent for PHP looks like it is active and was updated to PHP7 since the parent reddit posting. Docs say it provides an event loop that responds to IO available, signals, and timers and can handle long lists of event sources. 
How is it breaking? Existing heredocs continue working, don't they?
Excellent content! Thanks for sharing!
Which part? 1) Given the money that Apple has (multi-billion dollar funding) I'm sure Debian could offer everything OSX has and it would be of at least equivalent quality. 2) You don't need to worry about the PHP version shipped with Debian because you can pull an official PHP docker image for the required version. I'm unsure what needed clarification. There is nothing saying you need to use debian based docker images or APT repo for PHP.
Buzzword overload! And I don't think I've ever seen such overcrowded software architecture graphs!
&gt; Business logic in your controllers instead of having it in a model To be fair, a lot of blogs/examples will do it this way for readers to easily consume
Why would you write such weird code? Just pick a different terminator so it is not confused with the content. And even if you do, thats a parse error right there in the IDE. I feel this argument is like "if we really try, we can fuck this up using some weird edge case noone needs in the forst place" -- but this applies to any code. 
 $str = &lt;&lt;&lt;STR STR; STR; 
True, the post contains a lot of buzzwords... Buzzwords because extremely knowledgeable and experienced developers made them so... shouldn't we learn from the best? Should we, instead, learn from the inexperienced? True, the infographic is overloaded, my designer colleague warned me about it... However, if u go through the post, piece by piece, hopefully you should be able to understand it and you should start to see it quite clearly, at some point. Tkx for the feedback :)
http://sqitch.org/
Nice work, thank you for sharing!
Yes you pretty much need the controller specific configuration unless you really know what you are doing. The public: true is needed because when the route has been resolved to a controller, the controller object is pulled from the controller. Only public services can be pulled. By default, services are private. The controller.service_arguments is needed to support what is called "action injection". In a Symfony controller you can define an action method that takes various dependencies: someAction(Request $request, EntityManager $entityManager) The controller tag triggers extra processing when the request is mapped to a specific action and automatically injects the action dependencies. The tag also does some additional controller specific service container work. If you plan on being a Symfony developer then it is well worth the effort to dig into the docs and the code to see what is going on. 
+1 for phinx, used it on several projects, works perfectly !
That. :)
Either Phinx (on PHP projects) or [Goose](https://github.com/steinbacher/goose/) for Go projects. But both of them work nicely standalone. I like Goose a bit better but the workflow is very similar.
This following doc describes Python's module system: https://docs.python.org/2/tutorial/modules.html It implementat a mapping between nicknames and file names and dynamically loads those on request. It's trivial to write a PHP Module class you could call with Module::import to do that. Then you can decide whether or not you want that overhead in your program and whether you want to implenent it using exactly the same rules as Python. I don't see the basis for calling the built in version "power" since it is such a trivial step beyond file loading, and namespaces. One key trick for making PHP easy and pleasant in terms of code loading is to use composer with the ps-4 autoloading convention described here: https://getcomposer.org/doc/01-basic-usage.md#autoloading If one does that, it isn't necessary to use so many require_once and use statements. 
I don't even use vagrant
Great article about events! Do you think there is a difference between 'hooks' (as can be found in Drupal for example) and events? Are there alternatives to events to make application modular? When will you post your next article?
PHPMig is good. https://github.com/davedevelopment/phpmig 
 * built in debugger (cli) * a serious repl * convenience/streamlining around http stuff * self esteem 
Interesting stuff. I prefer the plagiarized Indian guy version however.
Colshrapnel you sound like a spastic moron. Did this lax guy fuck your wife?
If you're not working on a project which is developed for years, and you're not part of a team of a dozen developers, then you don't need DDD. PHP devs loooooooove their abstractions, up to a point where nothing gets done. Just open you IDE, write some coding, write some tests, refactor and don't expect it to be perfect. You don't need DDD, CQRS from the start. Cross the bridge when you get there. 
I would beg the difference. Working, and gaining experience with, large/complex architectures is not something you want endeavour on when the opportunity presents itself, because you will have to solve a large/complex business problem AND familiarise yourself with an architecture that suits it. Being good at architecture takes years of practise and you will make a mistakes (a lot of mistakes). I highly encourage you to over-design and to over-engineer your "simple" projects so that you gain experience combining abstractions and architecture techniques so that when a problem does arrives that demands these skills from you, you can focus on solving the business problem, not the software problem. In the beginning you will over-do it. Over time you learn to balance. Find an architecture buddy you can discuss software philosophy with. 
Let me know if you have any questions.
I've learned to love the sid.
If you have to keep telling us what a port (specification) is, or what it might be somewhere else, for instance when it's a port (interface), then I highly recommend you stop using so many imprecise terms, and just use the actual term the rest of the civilized world uses. Also, inversion of control is a solution designed to orient around strong type systems. It's about regaining abstraction in the face of a bracingly difficult type checker. Luckily, PHP doesn't suffer from that, and the entire IoC abstraction is wholly unnecessary. Duck-typing is idiomatic and solves the problem simply enough for most domains.
I understand your point, however i disagree a bit: 1. Its not at all about the PHP devs, to be honest i think Uncle Bob, Martin Fowler and the others never did PHP; 2. If u wait for years and a team of 10+ developers to start using DDD, organizing and decoupling your code, you are likely to be too late and the team will ask for a total rebuild, or you are losing business because you are too slow to change your codebase; 3. Both DDD and CQRS can be implemented to different extents. We can use CQRS and not use a Command Bus, for example (as i explain in the post). &gt; Cross the bridge when you get there I totally agree, as i mention in my post, we should understand all these patterns but use only what we need, when we need it. Tkx for your feedback, i appreciate it :)
 Be sure to use odorless paint-thinner. If it's not odorless, you'll find yourself working alone very, very quick. 
As I understand it Docker makes a private network that containers run on that your dev machine can talk to thru a single ip address of the docker host, so for you to communicate with a container you expose a port (like 80) so the browser can make requests against the container. Because it's a single host ip it can't have multiple containers all listen on the same port, so you need a proxy in the mix to direct traffic around the private network. The big difference here is your dealing with multiple discrete servers each hosting a single site/running a single process rather than a single server running multiple sites/processes
A port can be simply an interface, but it can also be a set of interfaces, DTOs, and abstract classes... so i feel the correct name is really 'port'. Furthermore, it is the terminology used by Ports &amp; Adapters Architecture, and thats what the civilized world uses. I think that the fact that PHP can be used with loose typing is one of its biggest pros to build simple applications but also one of its cons to build complex enterprise applications. In a enterprise application, duck typing alone is a recipe for a buggy system. Tkx for your feedback, i appreciate it. :)
If you don't want to give your controller hard time figuring out what returned data means (in http context) I suggest taking a closer look at arrow types on presenter-interactor boundry in one of Uncle Bob's [diagrams](https://i.stack.imgur.com/UpCvB.png).
 Shwooop. Hehe. You have to make those little noises, or it just doesn't work. 
Why do you need an intranet version?
&gt;Session is Full OK.
&gt; DDD is also about services, repositories, adapters, and so on, of which i talk about in the post. It's not. Is all about ubiquitous language. Technical things is just a way of how you could separate domain logic from infrastructure in order to clearly express domain. The difference is in a way of how you think about design. Instead of "oh, i will just put check here in order to prevent race condition" you asks business "how should we handle case when...". And the DDD part here is that you could express clearly technical problem using business language.
Yeah, that's it. You do need a web proxy of some kind (+1 for Traefik, despite the daft name that still makes me curse every time I try to use it) but you get a much more flexible and powerfull set up. We have one big server with Treafik running and behind it are all kinds of PHP apps, each with it's own webserver and it's own webserver configuration. Dev's can mess with one webservers configuration as much as they want and they won't cause problems elsewhere. We even have some Go apps serving web traffic to, and they sit in their own Docker containers and don't cause any problems for the PHP apps at all - Traefik routes it all easily.
&gt; which is developed for years So you need to know future in order to make such decisions? What if DDD will allow you to build much more stable system which will have more chances to live for decades? DDD is needed when you don't know domain enough or it's to complicated or unexplored enough. &gt; PHP devs loooooooove their abstractions, up to a point where nothing gets done. The point of abstractions is to simplify things, not to complicate it to the point where nothing gets done. This is true, that in order to apply DDD you already should have solid background on how to design/refactor large systems. But this is not problem of DDD but devs who just learn new buzz word and put it to every hole. &gt; You don't need DDD, CQRS from the start. Let's me rephrase: - you maybe need DDD but since at the beginning you don't know your domain enough you should not spend days on trying to build clear domain model. It's easier to refactor it as you get new knowledge. - You don't need command/query bus and so on in order to have CQRS. 
&gt; Is all about ubiquitous language. I have to disagree. The Ubiquitous Language is maybe the most important thing in DDD but, for me, it is definitely not the ONLY thing in DDD. I see it as the tip of the iceberg, where it all starts, but then we need to express that language into code and that's why Eric Evans added all these technical constructs and patterns to the blue book. What I think is that it is all about expressing the domain in the code, and both the Ubiquitous language and the technical constructs are part of it.
&gt; that's why Eric Evans added all these technical constructs and patterns to the blue book. and also he regrets that he put bounded context only on 14 chapter. Since this is most essential part of DDD which most of us missing. &gt; and both the Ubiquitous language and the technical constructs are part of it. Since we are writing code it's important to know how to separate concepts in our code, that's why he putted it into a book. But this is only tool, not the idea. Technical implementation is just a details. You could have all this patterns in your project but this doesn't make you DDD practitioner. 
There are many good ideas here, but I think in combination they cross a complexity threshold that affects the ability to bring new people into a project. To be blunt, if implemented in its entirety this design is too clever, and in projects that are maintained by many people over a long period of time clever is bad (especially once the original architect leaves). While I've used every element described here in isolation at one point or another, I would never go this far towards completely abstracting out all external interaction. Simplicity is a key design attribute of successful software architecture. E.g. wordpress is sort of the anti-body to this architecture, replacing the clever bits with stupidly simple bits at every turn, but I would argue that this is one of the main reasons why it is so successful. People can understand wordpress, even if they barely understand PHP. I generally would recommend that people start out with the standard architecture of whatever framework they're using, without trying to be clever. It is usually Good Enough (tm). It dramatically simplifies decision-making and on-boarding when the decision of how to architect something is "just do it like the framework docs tell you to". After a while, the points at which it is necessary to deviate from that standard architecture will become obvious.
Maybe so but that doesn't make it correct, it might be fine if your application shows one chart and does nothing else but it will become messy, unmaintainable and untestable very quickly.
Isn’t this a natural use for Nginx? Not the virtual hosts but the port proxy? Nginx port 80 PHP -&gt; php fpm port 9000 Nginx port 80 nodejs-&gt; nodejs port 3000
Yes, it is. Though the container does auto-configuration of the proxy. It finds other containers, checks their env vars (VIRTUAL_HOST, VIRTUAL_PORT and so on) and use them to generate the config. It also subscribes to Docker events. So whenever you start a new container or stop another it auto-adjust the config. 
To add to this, DDD patterns like value objects and other domain objects can be seen as the building blocks of your domain. If you have a rich domain, you can use these to compose your application intelligible.
I feel you, I had same issue with this couple of years ago, but this is the only sensible option to deal with software upgrades and release cycles. PHP 7.1 was released in December 2016. Debian Stretch freeze was a month a so before that. Even if it wasn't, Debian packages have to go through unstable/testing transition. The situation is somewhat remedied by backports, but in case of PHP, the same maintainer for the official PHP package in Debian is the same guy running https://deb.sury.org/ so I trust he knows what he is doing.
nice (y)
Great solution and a great guide to getting started. Very useful!!!!
Thank you Sara, you are doing gods work. Hopefully I will be able to push it into production in the first week of December!
`$arr === array_values($arr)`
Symfony sucks :D 
Anything than Symfony is fine
I agree with this. It works great as a stand alone. 
Both /u/msoica and /u/npbeckett are exactly as old as this post and these are their only comments. Sorry OP, I don't appreciate vote manipulation
We're using Traefik, I've been really happy with it
Yes I understand that. However, an application written just to be an example of what it is will not become unmaintainable. If this example was about separation of concerns, good design etc, then I'd be with you on that one.
Meh. I use a lot of heredocs for large bits of SQL. This will likely have very little impact on how I use heredoc. What I'm waiting for is the ability to use class constants in them without first having to first assign them to a regular variable. $sql = &lt;&lt;&lt;SQL SELECT * FROM table WHERE status IN ({self::ACTIVE}, {self::IN_WORK}) SQL; Now that is something that would be genuinely useful, and actually impact readability. Well, at least for me.
Propel is an option also. It can create classes and configuration files from an existing database. 
People will basically just describe Hack :) and that's where IMHO I think PHP should go, as well.
Thanks! &gt; Do you think there is a difference between 'hooks' (as can be found in Drupal for example) and events? "hooks" or events are very similar. different implementations (symfomy, laravel, wordpress, drupal...) all of them have the same concept, but they customize it to match the project's philosophy &gt; Are there alternatives to events to make application modular? yes of course, will talk about it in the next articles &gt; When will you post your next article? The next article is expected in prox 10-15 days
 if( count( array_intersect( $array, explode(" ", $string) ) ) ) { // The string contains an element in the array } implode/explode might be my favorite functions.
Doesn't work if you remove 'quick' from the search array
A couple of ideas: if(array_sum(array_map(function($e)use($string){return(strpos($string,$e));},$array))){ or if(array_reduce($array,function($c,$e)use($string){return $c+strpos($string,$e);})){
This will work but I was looking for a solution that would find any string in the string not just the words. But my code didn’t make this clear, please see the updated array.
That's harder indeed. If this needs to be done at more than two places I'd create my own function with foreach or whatever someone else propose and use it everywhere I need : it could be 5 lines it would not be an issue since it's just one call in my function. As a side note, you don't need to look for capitalization or special characters at all ? I would feel safer with my code knowing it tokenizes values before matching them, but that depends on your strictness requirement.
I am interested-- the more the merrier. It'd be nice to have someone to bounce ideas off of and code review with.
Oops, the above solutions won't find substrings at the start of the string, but this one will and is 92 chars if(array_reduce($array,function($c,$e)use($string){return $c+is_int(strpos($string,$e));})){
I do have an RFC for [arbitrary expression interpolation](https://wiki.php.net/rfc/arbitrary_expression_interpolation), but I'm still not 100% keen on the syntax (due to the BC break it introduces for regexes). May go down the sigil route.
There has been many use cases in the past so in some cases using a function that is case sensitive would have been the best route. But as far as this post goes, I’m just interested to see how the PHP community approach this.
Got rid of 3 more chars: if(max(array_map(function($e)use($string){return is_int(strpos($string,$e));},$array))){
In 68 disgusting characters: $t=0;foreach($array as $e)if(is_int(strpos($string,$e)))$t=1;if($t){
Crazy thing is, stuff like the following works... $sql = &lt;&lt;&lt;SQL SELECT * FROM table WHERE status IN ({$this-&gt;active}, {$obj-&gt;inwork}) SQL; Not entirely sure of the full ramifications of your RFC though. May not be a great idea to have method calls inside of a heredoc. Heck, it may be a great idea, but sounds like an area to tread carefully. I tend to think of a heredoc as a simple template were only values are able to be pushed in there. Just a shame that one of those kinds of values isn't a constant.
Ya PHP definitely learned a lot from Facebook already and I completely agree.
PHP and MySQL are like peanut butter and jelly; most PHP developers are using it and don't plan on switching. And like I said, if you think you'll be switching among the databases it supports, then I can understand that. Though as someone else mentioned the ease of portability has been overstated. For myself, and I'm sure plenty of others, the choice of databases is either MySQL or a NoSQL db like MongoDB or Firebase. I'm sure this post will receive plenty of downvotes, as it seems too much groupthink is going on. It's pretty funny that my neutral comments where I say that both are great, but I prefer MySQLi get downvoted, yet posts that say you must use PDO get a ton of upvotes. Come on guys, think for yourselves. Programming isn't about dogmatic philosophies. You should choose whatever method *you're* most comfortable with. 
array_filter and count?
 $array = ['quick', 'uick brown fo']; $string = 'the quick brown fox jumps over the lazy dog'; $matches = []; if (preg_match(sprintf('/(%s)/', implode(')|(', array_map('preg_quote', $array))), $string, $matches)) { var_dump($matches); } Result: array(2) { [0] =&gt; string(5) "quick" [1] =&gt; string(5) "quick" } 
if(preg_match('/'.join('|',$array).'/',$string)) This will work only if you can depend on your array values having no regex characters. Otherwise, you would need this: if(preg_match('/'.join('|',array_filter($array,'preg_quote')).'/',$string))
49 chars if(strtr($string, array_flip($array))!==$string){
array_filter should be array_map, no?
You just want a TRUE and FALSE? (str_replace($array, '', $string) !== $string)
&gt; wordpress is sort of the anti-body to this architecture, replacing the clever bits with stupidly simple bits at every turn, but I would argue that this is one of the main reasons why it is so successful. I don't know. I have nothing to backup my claims, but I would think WP's users don't care about its architecture. &gt; I generally would recommend that people start out with the standard architecture of whatever framework they're using, And here I am, the guy that didn't read that article, but with a very opposite advice. Don't let the framework come into your way! I very much advice to keep frameworks as a tiny implementation detail.
Currently using VSCode with Dracula default theme. Loving it so far!
PHPStorm user here. What am I missing out on?
I love monokai pro on vscode and also for sublime
Nothing.
So Jeff has a new toy. Since I’ve been following his posts on tooling he’s advocated Sublime, Vim and PhpStorm just over the last few years. Maybe he’s seeking perfection. Maybe he just gets bored. Is there a TL:DR on why this is better than PhpStorm other than new/shiny?
Quicker load times for less functionality. Not to be blunt but yeah. The targets probably not for those of us who have a fully functional IDE always open. I use it all the time to quickly edit code or play about. It's for those users who are FE or use Atom/Sublime/notepad++ and stuff. Or maybe just those you can't afford the PS license. 
PHPStorm is an IDE, while VS Code can be compared with Sublime text, Atom.. VS Code is a step up from Sublime text.
Tip: I found that most PHP formatter extensions for VS Code either didn't work (specifically the one mentioned in the series) or didn't offer enough configurability for my needs. I've had luck with both https://marketplace.visualstudio.com/items?itemName=fterrag.vscode-php-cs-fixer and https://marketplace.visualstudio.com/items?itemName=calebporzio.simple-php-cs-fixer.
&gt; PHPStorm I'd like to interject for a moment. The IDE you appear to be referring to as, PHPStorm is in fact called, PhpStorm. Don't worry, I don't expect developers to pay attention to details, but you would do yourself and everyone else a favour to get it correct in future.
&gt; PHPStorm I'd like to interject for a moment. The IDE you appear to be referring to as, PHPStorm is in fact called, PhpStorm. Don't worry, I don't expect developers to pay attention to details, but you would do yourself and everyone else a favour to get it correct in future.
&gt; Dracula I'd like to interject for a moment. The colour scheme you appear to be referring to as, Dracula is in fact called, Darcula (because it is dark). Don't worry, I don't expect developers to pay attention to details, but you would do yourself and everyone else a favour to get it correct in future.
Please stop.
I'd just like to interject for a moment. What you're referring to as PhpStorm, is in fact, PHP/Storm, or as I've recently taken to calling it, PHP plus Storm. Storm is not an IDE unto itself, but rather another free component of a fully functioning PHP IDE made useful by the PHP executable, syntax highlighting and vital development components comprising a full IDE as defined by ISO.
The requirement for escaping `#` if not followed by `{` is not strictly necessary. Just like right now escaping `{` is not necessary if not followed by `$`.
Thank God you're here, I had no idea what he was going on about
The file with '.swp' is a Vim swap file, you can restore that file with `vim -r .www.conf.swp` → then press `:wq` and you'll have `www.conf`.
I’d just like to interject for a moment. What you’re referring to as PhpStorm is in fact p^h^p^s^t^o^r^m^ohnoooooo....
I've had VS Code installed for a long time now, but it's never been so good that it made me want to replace Sublime as my default text editor (PHPStorm being MUCH better for PHP code than either one). The only feature that I'm looking forward to and it might actually make me switch to VS Code is the newly announced Live Share feature: https://code.visualstudio.com/blogs/2017/11/15/live-share Does anyone know if PHPStorm or any other JetBrains IDE offer this feature?
Point noted, I apologize for the mistake. Please don’t be an asshole about it though. Not needed. 
They’re all fantastic. I run an education site. Important to cover all choices. 
with only 44 characters and its clean syntax I think this is the winner!
Stop this. Fuck. Every time someone mentions PHPStorm, phpStorm, PHP Storm, pHpStorm, or any other version of PHPStorm, you copy and paste this same stupid fucking comment. It's annoying and unnecessary and it's not doing anything but make you look like an asshole. You're not adding anything to the discussion. Just stop. 
I think this is the winner, it's only 42 chars and it's by far the best syntactically
Javascript in eating ram 
PHP = Pretty Home Page for us old folks.
Thanks! I'm putting this on my resume next to my W3C certificate.
He isn't it's just a meme. Don't be offended :)
I’m slowly becoming familiar with Rediquette :)
do you mean like quires in model like scopes ?
VSC is getting coffee collaboration features. Which is pretty neat. https://code.visualstudio.com/blogs/2017/11/15/live-share?source=techstories.org
Not if it means selling my soul in the process. There are better jobs out there, trust me. Also, as developers, it's up to us to lead and set an example.
&gt; How do you add a comment in PHP? [select one] &gt; * /* ... */ &gt; * /// ... /// ಠ_ಠ
Personal Home Page ;)
Because php is primarily used for web environments (not exclusive) and pthreads isn't safe for web environments.
Why did you write this?
But it's semantically invalid because it performs mutations when this should be a read-only operation.
But it should be stated that if anyone actually did this they would be asking for it. Although those sorts of people have typically already left the projects they did this to.
Unfortunately the PHP plugin intellisence cannot compare with PHPStorm. It takes years to build a completion cache (pro type : if the completion menu doesn't show up for an imported class, navigate to the source class `go to source` and open it, it will show up faster) and the completion is nowhere near as good as PHPStorm. Aside from that it's fine, I use all the phar tools available to generate phpunit tests, fix the indentation and formatting ( the default one doesn't work very well for some reasons) so it is an enjoyable experience. To me, moving forward, what really matters is that people stop writing PHP IDEs. Write tools that can be used in all IDE, write language servers, ect ... instead of writing a plugin for sublime in python, a plugin for Netbeans in Java,... write the plugin as a standalone then just write a thin wrapper for each IDE. It is really something that should have happened earlier. Somebody who wants to use VIM should have the exact same PHP dev tools available as someone who use Netbeans or Eclipse.
Any solution must perform *some* mutation. That aside, this requirement was not stated anywhere.
&gt; Even if it's mostly for edge cases around high performance workloads, threading is the cornerstone on which some languages are sold to people Not everybody agrees whit that I guess, one can for example chooses a simple multi process approach which is available out of the box and can even scale across several machines with a broker service. For extreme performance issues, the best solution might also be to implement critical parts in a faster programming language. In pure data processing a single c++ thread can still be hundreds of times faster than 4 PHP threads. PHP threading support also appears to be still experimental: &gt; Note that only PHP 7.2+ is now supported (requiring the current master branch of pthreads). This is due to safety issues with ZTS mode on PHP 7.0 and 7.1. 
The requirement is intuitive.
It’s difficult and I think it’s great you cover them all. I think there’s a tendency to obsess over tooling though and lots of people will take this as an endorsement and switch. Maybe it’s great and they should.l but maybe there’s nothing to gain. 
From [Multi-Threading in PHP with pthreads](https://gist.github.com/krakjoe/6437782) by krakjoe: &gt; PHP was written for the non-programmer, it is many hobbyists native tongue. The reason PHP is so easily adopted is because it is an easy language to learn and write. Multi-threaded programming is not easy for most, even with the most coherent and reliable API, there are different things to think about, and many misconceptions. The PHP group do not wish for user land multi-threading to be a core feature, it has never been given serious attention - and rightly so. PHP should not be complex, for everyone.
It is an endorsement. 
I don't disagree, but for me the idea of DDD is to make the domain explicit in the code. We can't do that without the processes to understand the domain, the Ubiquitous language and the tools to make the domain explicit in the code. For me, all of it is DDD. As you said, we can use all these tools, these code constructs, but if we didn't distil the domain to understand how to structure them... we are not doing DDD. The same thing goes the other way around, you can be great at distilling the domain, but if you cant code it, you are not doing DDD, you are only doing part of it. In my post, the intention was not to talk about the DDD process, but instead to talk about the constructs that can be used to make DDD explicit in the code. Talking about the DDD process would be a long post on its own... Anyway, tkx for your feedback, I highly appreciate it. :)
Well, I started writing about software development because it helps me put my ideas together when I read articles and books. I've read a lot, and wrote a lot, and it helped me be a better developer. This specific post has more of my ideas than my past posts, so this one was both a way of putting my ideas together, give something back to the community and get feedback from the community my thoughts.
I agree that for a small and/or short-lived project, applying all this will be too much. I say it in the article several times that we should know all these patterns, but use only what we need, when we need it. However, I have no interest in small projects. I have experience with big PHP projects. Codebases that must live for decades. In my current company, a few months ago we refactored the whole codebase (which was following the framework architecture) to reflect this architecture. The last 2 weeks I've been onboarding 2 new developers and it's fantastic to see how fast they come into the project!! - It's just easy to know what command handler is gonna handle a command because together they are a use case and, as such, they sitting next to each other. - It's just easy to know what templates your controller uses because, again, they are sitting next to each other, contrary to the Symfony traditional structure which places them in a completely different folder structure that easily gets out of sync with the controllers folder structure. - It was just easy to switch our command bus implementation because it's completely abstracted behind an interface. - It's just easy to switch our 3rd party push notification service because it sits behind an interface. - It was just easy to add a 2nd event dispatcher to dispatch the event asynchronously because the symfony event dispatcher was hidden behind our own interface so we just added the new dispatcher to the adapter and no other change was needed in the whole codebase.
So continuing to do what he does best is "just getting bored"?
wtf why are you so harsh, the person's just trying to be nice
You are totally right!! I completely missed that piece of the puzzle!! Although I do it differently than Uncle Bob. He injects the presenter into the interactor, which populates the presenter with data. I rather have the interactor spit out a DTO which the controller injects into a view model, that may have some view logic. The view model is then used to populate the view. I updated it now, tkx a bunch!
For PHP use both. Switch to VSCode when PhpStorm's memory usage becomes a problem. If I have one massive project that I'm working on for a while then I'll use PhpStorm. At the moment I'm on one big project while supporting 2 others and I'm using VSCode. Having all 3 open in PHPStorm as well as all my chrome tabs makes my laptop fry. On that note I've switched to Firefox developer edition recently as well. Its actually very good and isn't the resource hog chrome is. For purely front end Javascript or Typescript development, (like an Angular project) then I recommend VSCode above anything. Its JS and TS support is second to none. Same goes for nodejs. 
[removed]
Why is PHP (and many other langs) bundled as default? Its not used by the OS so its just wasted space. 
I switched to Elixir, its crazy how much thruput i get with a sigle node. And the language is sooooo much nicer than PHP. I can utilize all cores (php could not) I have massive concurency (php has none) Immutablilty is a gift Bonus, i dont need any other deps, like redis, message queues etc. Its all handled very well by the runtime! Plus im super productive!
Also, read the 2 comments here for a few corrections : 1. [It's O(log n) ](https://stackoverflow.com/questions/2473989/list-of-big-o-for-php-functions#comment23484963_2484455) 2. [Dependence on array size is caused by CPU cached effects](https://stackoverflow.com/questions/2473989/list-of-big-o-for-php-functions#comment57857960_2484455)
The mutation is in garbage memory. Like the other examples this algorithm does something then throws it away only to care about boolean. `$string` is never changed so I'm not sure what you mean. In fact, the most obvious problem is if I had an array with 100,000 elements in it then this solution would try to replace 100,000 times before returning a boolean. This is inefficient. Personally, as the author of this submission, I would never do it this. I would stick with a `foreach` encapsulated inside a `is_substring()` function with a break point style return value. I agree this is a hilariously wrong solution... but hey... It's code golf I won :) 
/u/fork_that are you seriously "gonna be harsh", yet not even respond to my rebuttals? Maybe actually understand what you're talking about, before you do so next time 😉. The fact that you thought the server-side representation of `$_SESSION` can be tampered with seriously made me cringe. If you can't trust your server-side variables, then you have much bigger problems.
&gt; Dependence on array size is caused by CPU cache effects More generally locality of reference issue. A huge PHP array could even have part of its memory swapped on disk, slowing down even more random access lookups.
I don't have the apptitude to understand any of that
Named parameters?
Experience, not aptitude. You'll learn it!
Oh jebus.. here comes the interview questions for interviewers that have never interviewed before.
[This](https://www.interviewcake.com/article/big-o-notation-time-and-space-complexity?collection=dsa) is the link I share when new co-workers wants to learn about Big-O notation. Pretty down to earth explanations. Switch code examples to PHP. 
http://php.net/manual/en/pdostatement.bindparam.php example #1 is PDO, example #2 is still PDO but that's why you have to do with mysqli (? vs. :var)
Half true/funny. But really, if you don't know big O basics (at least the differences between constant, linear, logarithmic, and exponential) and the expected complexity of standard library functions, you're probably going to cause problems for the company at some point down the road because of it. Though, there are definitely bigger red flags for them to look for in the interview process, admittedly.
Optionally, provide the link with PHP already selected? https://www.interviewcake.com/article/php/big-o-notation-time-and-space-complexity
Paging u/Saltub, you're missing another opportunity to get downvoted
inb4 u/nikic
Actually there are a few ways to make PHPStorm faster: https://www.stitcher.io/blog/phpstorm-performance It's probably still not as fast as VSCode and Sublime, but the amount of features you get with PHPStorm really outweigh the small performance cost.
The invalidate caches/restart option under file reduces memory usage, and sometimes fixes little false alarms that creep into the editor diagnostics, though you have to wait for it to restart. I wish there was a way to tell it to do most of that, periodically, when idle on an automatic basis. 
&gt; But really, if you don't know big O basics (at least the differences between constant, linear, logarithmic, and exponential) and the expected complexity of standard library functions, you're probably going to cause problems for the company at some point down the road because of it. any business that worries about algorithm cost shouldn't be using PHP for the task at first place but a faster language. 
Well, yeah, not really quite suprising if you read the documentation (which you should for everything you use or want to use) and understand what they say there. Still a nice write up with actual tests conducted, just when you really want to optimize, read the docs. Still the best documented language I have seen to date.
You are confusing speed and (time) scalability, these 2 concepts are orthogonal. Time complexity is about scalability and a sub-linear algorithms are often said to be scalable. A fast algorithm can scale very poorly, and conversely, a scalable algorithm can be very slow. So I agree that if speed/latency is your main concern you might choose another language (at least for the critical parts). But this is rarely the case IMO as things are often fast enough and, if you want to contain the performance degradation under higher loads, the solution is not to choose another language but to make things scalable whatever the language.
Agree with your metaphor given history and a lack of options at the time. However,* today *PHP and PDO are like bread and butter. Try it.
I'm so old, that my mind change it's original name. =P
that posst is from the time when people used php
This is an excellent article about how to use it in combination with docker: https://www.digitalocean.com/community/tutorials/how-to-use-traefik-as-a-reverse-proxy-for-docker-containers-on-ubuntu-16-04
Did try it many times, and I have nothing against it; it's great too, like I said on a few posts. I just personally prefer MySQLi and there's nothing wrong with that, unless you view programming as a religion where you have to stick to one of doing a task a specific just because a lot of people say to. I'll say it again, **programming is not about dogmatic philosophies.** This is a similar train of thought for people who unironically say that Node.js is the only true developer language. I love too, but I prefer PHP. However, it does have plenty of advantages, and I personally prefer using Socket.io for WebSockets and Casper.js for data scraping. Just my two cents, but I think part of evolving as a coder is understanding the technologies and methods that exist for a task and choosing whichever one *you* prefer. Not this rigid nonsense.
Agree that you should use what works best for you, regardless of dogma, that can be developed to meet app needs. I'm just trying to highlight that PDO is an evolved approach from mysqli (that I have used in the past) and actually makes the outlook less rigid. At the end of the day, you are the boss of your code. Cheers.
Very well said, and you make great point. You're the only person on this thread I enjoyed debating with, because you were very logical, civilized and just wanted to get your points across. Thank you for that 😀.
Yep and if PHP is even in the table as a possible language choice I’d bet in those cases speed/latency is probably not your main concern.
[removed]
For anyone reading this and want to learn: you should definitely check out CS50 on edx.com https://www.youtube.com/watch?v=U9o49qwa6hk Their week 3 module has a condensed version of the above. Super interesting stuff. https://courses.edx.org/courses/course-v1:HarvardX+CS50+X/
PHP jobs usually never require any compsci knowledge at all (joomla, laravel etc) thats also why the pay is the worst. 
This is really badass. Thanks for your work!
Ahocorasick keyword match a implementafion:https://github.com/imaben/php-akm/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [imaben/php-akm/.../**README.md** (master → c696e5b)](https://github.com/imaben/php-akm/blob/c696e5bd42a96c5957217f284b48c17f0f1580bd/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
a more english native repo by wikipedia:https://github.com/wikimedia/AhoCorasick
Looks like there is a need for legacy PHP to non-legacy PHP translator.
Oh wow, I was surprised to see this post is still around after I made it so many years ago. It’s probably pretty out of date, but I’m glad to see people still getting value out of it!
Electron apps consume far too many resources for me to remotely consider them. Neither VSCode nor Atom hold a candle to Sublime or vim.
VSCode uses on average 300MB (&lt; 2%) of memory on my PC. I don't really see the problem.
I find it particularly amusing that you're okay with a text editor using 300 MB of memory.
I think you haven't try php in a while. And if you want a fast development (sometimes is the case) php can be a good language too
FWIW this is after many days of having VSCode open with a medium sized project (1GB all up including version control and composer/node libraries. And yes, I think 2% is a perfectly fine amount of RAM to use. I would be happy for it to use more if it needed. It is one of the most important pieces of software that I run when coding. And not to mention this is only a mediocre workstation. 
&gt; you're probably going to cause problems for the company at some point I can't tell if you're baiting or just trying to scare off junior devs here. A good programmer writes maintainable &amp; testable code; optimization is almost always a luxury problem. Hardware is cheaper than developers.
He posted a while ago about how array's hashing in PHP can have very poor performance. https://nikic.github.io/2011/12/28/Supercolliding-a-PHP-array.html
Reread my comment. I wasn’t talking about speed of development I meant speed and latency of the language itself.
I know, php speed has improve a lot, that's one of my points. Take a look on php7.1 and you will see it
I get your point although. If you only need speed an latency, maybe C++ or go can be a better option 
You're right 
Preach it!
Floobits is far superior to this (note: I haven't used live share or teletype for atom). Floobits works in intellij, sublime, atom, neovim, and emacs. Floobits also has a terminal sharing plugin. Real pros don't even need floobits, ssh + terminal editor ftw :D
There was more “if”s. I removed them, don’t know why..
/r/PHP is not a support subreddit, you will want to post this over on /r/PHPhelp 
Threading is never easy, pthreads makes it look easy, but the way it is integrated into php makes it a minefield. I have no experience with pthreads but the fact that the whole main environment is shared, will cause crazy problems if you do not act with great care and insight. Consider you spawn multiple threads that foreach on a global array, foreach resets the internal pointer of that array, the result will be weird because you start from beginning multiple times. The threads may not even complete! Again no experience, but that is a question i'd ask. This problem carries over to anything shared from the main thread, most notably resources but also configuration. So the minimum requirement to not suicide constantly is to copy all data you need into a thread and recreated necessary resources within the thread and never ever even touch something shared. This already, is *hell* to maintain as programmer in a php world where globals are always present and people are eager to use "static" here and there. I'd also expect that php extensions might have some global state that would make them completely useless or dangerous for threading. It is always in question if parallelism is an advantage. It comes at great complexity cost and is often hard to predict if it will perform better. You may end up with more serializing / bootstrapping overhead then the actual workload is. Consider bootstrapping an ORM within a thread. To be on the safe side, it cannot have any internal or external caches. You will maybe start reading yaml configs to configure it for each thread just to pull some data. If the core workload is not heavily io or cpu bound you will gain no advantage. Remember this is not a php problem, it is a parallelism problem and my example is just a bold exaggeration. Eventually parallelism in php (cli apps) is insanely easy if you make up you mind. Simply have an central database (i.e. a queue) that can carry you workload, start as much processes until you have 70% cpu load and be fine. Many programs can be adapted to this pattern with only little changes and low risk. 
Not for non-trivial database queries.
It's pretty reasonable. The incorrect hash table lookup complexity was already mentioned, which is average amortized O(1). Since PHP 7.1 array_rand() with num=1 is O(1) instead of O(n). Since 7.2 in_array() can be O(1) if passed a constant array. Some of the array functions have optimizations where they become O(1) instead of O(n) under favorable conditions.
a bit more explanation and demo perhaps? practical use? i know async and reactphp but the rest of the readme is like ...
Composer will be able to pick up a class automatically, so just popping a few functions statically there will serve thf purpose. Making functions in the global namespace means the file will need to be manually included before the functions can be used. You can namespace functions but I'm not sure if the auto loader picks them up. Also, static functions are like Java, purely stateless, so the method can be called without creating a new instance of the class
The first paragraph of your comment can be reduced to "Again no experience". But I guess, that sums up the main point that multi threading should not be a user land main feature, but only for people that want it actively. Also, foreach doesn't change the internal array pointer anymore since 7.0, I think. They changed the way foreach works.
Algorithmic complexity kicks in when hardware doesn't cut it anymore. What are you going to do then? Nobody is trying to scare junior devs, but at some point they are going to need to learn.
If you happen to choose Laravel to move to, there is a plugin you can add to generate all the laravel migration files from an existing schema.
php sucks
I just did this OS upgrade and ended up with PHP 7.0.7
[The Fish That Climb Trees](https://quantumbiologist.wordpress.com/2011/01/28/the-fish-that-climb-trees/)
- a Date class - if/switch as an expression - inlining of short function calls by the runtime - easier way to bind an argument to a function 
I'd love to see it in core, even if it's restricted to the CLI. On Windows there's no pcntl_fork, so a threading solution is really needed there. Unless pcntl_fork could be emulated with threads on Windows like it is in Perl (seems like a mess though). But now it's not really possible to make a good cross platform multi-process/threaded component due to different inconsistencies.
Source? 
Such discussion, very crowd
It's a really good editor and a passable IDE but only once heavily massaged. There are really good IDEs out there and they aren't Sublime.
You can read about output buffering to capture any outputs. Then you can save the results to a file.
Sculpin?
I've looked into that. I think you need to use the command line.
Why would that make any difference, if the end result is static HTML?
Is Symfony with twig too much for what you're thinking about?
That is what Spress is, I think. I'd love to be able to not have to use the command line but the more I'm looking into it, I may be limited to that.
Is this a response being generated by php from a request received by a web server like Apache? If you have some special need, or you just want to roll your own CMS, Apache mod_rewrite and a simple php script to load a template and echo it out would suffice.
Yeah, it could run on a local environment. I only need the html files as output to upload to a server later.
It's Monday... What do you expect? Look at last weeks if you want more.
Oh I think I get it now. So you want to create a blog on a local machine and have the static files generated for upload later? It's been a while but wont WordPress do something like that? Save to a local machine? At any rate your example would work. Your script would load a template with file_get_contents () and then what, maybe load text files to find/replace fields in the template, and file_put_contents () to file system. 
&gt; It's for those users who are FE What's FE?
I used to swear by Monokai, but might I interest you in [Material Theme](http://equinsuocha.io/material-theme/#/default)?
Use a template engine, then put the output to a file.
If only I could think of a place where such information could be found. /s &gt; In PHP 5, when foreach first starts executing, the internal array pointer is automatically reset to the first element of the array. This means that you do not need to call reset() before a foreach loop. As foreach relies on the internal array pointer in PHP 5, changing it within the loop may lead to unexpected behavior. In PHP 7, foreach does not use the internal array pointer. http://php.net/manual/en/control-structures.foreach.php
If I am hiring, they are going to no all three. Optimization isn't a luxury, its just as important as everything else. For the record, I know of Big-O notation, but I'd probably fail interview questions on it. My counter-response would be optimization almost always occurs at the point where engineers interact with a database. Slow queries, running queries in a loop, subselects, and poorly designed databases will make your application slow. Get that stuff right, and you'll be okay. You could change switch up your arrays to make us of isset over array_search all you want and you'll never sniff the increases you'll get by adding one well-placed index or switching a in-loop query to a WHERE IN clause.
I assume isset() is still king, just makes sense it would be. It's also less characters to type than the other options.
I really wish they would build support for this into PHP, but disable it by default via a ini setting. Seasoned developers who get it could really benefit.
It shouldn't be restricted. Just add it and disable by default in INI. Experienced devs can opt-in.
Sorry but you're being dishonest here and you know it. Nobody in their right mind would argue that optimization is more important than testing because no customer wants fast but error prone code. You're arguing about IO and that's another problem altogether. It's not a new fact that web apps are often limited by latency and/or IO. In the end, a good programmer would profile their app before doing anything.
I actually moved from material to monokai :)
Read the whole thread answers and found much needed features for PHP. I also want to see these features in next versions of PHP: 1. Threading/Multithreading 2. Method Overloading 3. Async behaviour This would help many developers and me too.
There are limited spots available as its an interactive session :) There will be another one in the new year (We plan to have then every 1 - 2 months) 
To add more to the pot: in the end, a good programmer will ask about what they don't know; and take responsibility for the mistakes they make and the learning they need to do. Being able to communicate, and willing to take responsibility, are worth more than all other skills.
&gt; If I am hiring, they are going to know all three Enough said.
Let me post a question first: Can anybody tell me that why PHP create Serializable interface when we already have 2 magic methods __sleep() and __wakeup() , thanks ?
Frontend
Return types in a subclass are contravariant not covariant. 
I think It is a nice article because I know about Behat, PHPUnit and PHPSpec but not about the rest. Thanks for letting me know about those one's too.
It's 2017, why are people still developing on Windows machines? If anything, use bash for windows or another VM solution.
Too bad that the example with the "multi-line ternary" is *wrong*. $result = $firstCondition ? 'truth' : $elseCondition ? 'elseTrue' : 'elseFalse'; Returns `'elseTrue'` just because `$firstCondition` is `true`, regardless of the `$elseCondition` being `true` or `false`. That's because **ternary operators are left-associative in PHP** - which is *totally* [counterintuitive](https://stackoverflow.com/a/38231137/1285669) and [sad](http://phpsadness.com/sad/30). http://php.net/manual/en/language.operators.precedence.php
You could render the php file and save the result into a file. Here is an example. function render($fileName, $data = array()) { ob_start(); extract($data); require $fileName; $result = ob_get_contents(); ob_end_clean(); return $result; } Usage: file_put_contents(render("categories.php"), "categories.html"); ?&gt; 
They work slightly differently. `Serializable` allow you o mutate the data before/after serialization. `__sleep` only allows you to return an array of properties to include in the serialized data. And `__wakeup` is simply a callback/event when the instance in unserialized. 
 return ob_get_clean() Bit more terse.
If only PHP had some way of showing how you meant to group this expression, perhaps some day they will implement brackets ( '(' and ')' ) which may help?!
Factory methods should really be factory classes. `Foo::make('bar')` is an anti-pattern, too. If suddenly you introduce a dependency, the method will become polluted with arguments, which could've been passed nicely to a factory class in its constructor. I agree its uses are valid for certain helper methods, like generating slugs (like you suggest), creating UUIDs, validating values, etc. Basically "in, out, forget". I myself have used `getInstance()` from time to time. But very often it has come back to haunt me, and the refactor game began.
Not sure what you mean. A warning or notice if you use a ternary without parentheses? You can force whatever order you want already with parentheses...
https://wiki.php.net/rfc/null_coalesce_equal_operator this has been voted, but the proposed version is `7.x` any idea when this is coming? also, in the PR of that RFC, there's some more interesting thoughts: It would be nice if both ?= and ??= would get implements. So: $var ?= 'foobar'; would be the same as: $var = $var ?: 'foobar'; And: $var['key'] ??= 'foobar'; would be the same as: $var['key'] = $var['key'] ?? 'foobar';
Oh boy, PHP 5.2 dates back 11 years ago. No way to upgrade to a newer version?
[removed]
I'm afraid not :(
Of course you can't find great ones. The latest 5.x stable release is 5.6.32. See https://packagist.org/packages/league/plates or Twig if you switch to the 7.x branch.
Hence why I'm asking here. I'm well aware that 5.2 is not optimal, but I'm not in a position where I can upgrade to a better version.
I guess I'm old enough to know about it: https://github.com/smarty-php/smarty/
Twig supports PHP 5.2 up to version 1.33.2: https://github.com/twigphp/Twig/blob/v1.34.0/CHANGELOG https://github.com/twigphp/Twig/tree/v1.33.2
I've dabbled a bit with Smarty, but it's just so.. Clunky, right? The structure and execution seems like a mess.
That's more like it! It lacks some sort of documentation for 1.33.2 though
[removed]
Here's the documentation for 1.x, don't know if that might help you: https://twig.symfony.com/doc/1.x/
Ah, of course. Thank you very much!
It's clunky but it still works. I use it on PHP 5.6.x, though I'd choose Twig for new standalone applications. If you're on 5.2.x your options will be limited at best.
You don't have to buy or rent the software as you do with storm. You're not in the VSC target market so you're not missing out on much.
&gt; Is there a TL:DR on why this is better than PhpStorm No one said it is. Two completely different products, one is free and open source whilst the other is costly and proprietary. People have different reasons to pick one over the other but that doesn't make x better than y. If you're happy with renting PhpStorm then stick with it.
&gt; I find it particularly amusing that you're okay with a text editor using 300 MB of memory If you find that particularly amusing I suggest going out and interacting with people more, maybe talk to a woman or 2 or have a beer.
[Danack/SlimAurynInvoker](https://github.com/Danack/SlimAurynInvoker) allows you to use Auryn within the Slim framework. In short - it allows you to use the more powerful Auryn dependency injection library in a PSR-7 framework. In addition it allows you to return stub response objects, rather than having the mutate the PSR-7 response object. I find that easier to test, and reason about.
[ReactPHP Promises Testing](https://github.com/seregazhuk/php-react-promise-testing) - a library that provides a set of convenient assertions for testing ReactPHP promises. 
Thanks for pointing that out! I've addressed this issue in the blogpost.
I think he's saying that you can use brackets to avoid the problem.
It will be in PHP 7.2: https://wiki.php.net/rfc#php_72
The wiki says "Pending Implementation": https://wiki.php.net/rfc#pending_implementation
Out of box way to run application only once and keep it all time in memory os it's not recreated all the time. (like any object, etc)
We used this when I got my first webdev job, back in 2000: https://github.com/bevhost/phplib/blob/master/inc/template.inc Works with PHP3!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bevhost/phplib/.../**template.inc** (master → 852fbfc)](https://github.com/bevhost/phplib/blob/852fbfc2e6916ead3471e3a09b56e2b6d6ac276c/inc/template.inc) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I see, apparently the author of the PR abandoned it
How much effort would it take a programmer to include brackets round each logical block (by that I mean evaluate A first and then use the result in B). It's more a case of creating self documenting code rather than relying on side effects of evaluation order.
I actually switch between the two pretty frequently. I dual boot Ubuntu and Windows 10 at the moment. I sometimes use the Linux subsystem in Windows to get around certain things or test something, other times I use VMs. But it shouldn't matter where someone chooses to do their development, or ultimately run their code.
Does anyone have real world examples of the shorthand ternary operator? I understand them, I've just never encountered a situation where that would be a good solution. Null coalescing operators are a godsend tho. `$array['lastName'] ?? 'Doe'`
If you want, you can always use `Zend_View` from Zend Framework 1. Just to give you another option.
I fixed it :-) Thanks.
A just for fun template enginge ;-) function render($fileName, $data = array()) { ob_start(); extract($data); require $fileName; return ob_get_clean(); } Usage: echo render('home.html.php');
Interviews aren't just for junior developers. But even ignoring that, a junior developer should absolutely be expected to know algorithmic complexity basics. People around the dev community often minimize what a junior dev should know going into their first job, and to a certain degree, that's appropriate (esp. as it pertains to specific technologies, languages, packages, libraries, etc.). However, big O complexities are development fundamentals. Understanding that you can't get away with solving a problem in a blatantly inefficient manner is something along the lines of an apprentice carpenter understanding that they can't build a house by gluing boards together. They don't need to know the nuances of big O (like any of the notation at all... that much is mostly academic), but they sure better know the conceptual difference between a constant complexity algorithm and an exponential complexity algorithm, or they need to get back to learning before getting paid to do this for a living.
&gt; it's better to use one single product that has the same workflow and multiple language support then a few totally different tools for each language. In which case IntelliJ seems to be the clear winner for a fully functional IDE.
&gt; I find it particularly amusing that you're okay with a text editor using 300 MB of memory in the first place In the year of 2017 this isn't a massive amount. Is it negligible? No. But for everything it provides over it's competition there's no question in my mind that I'll accept the memory usage. Yes, I know that memory prices have gone up recently but I'm not suggesting you get a set of 16 or 32 gb RAM. &gt; ...hold a candle to Sublime or vim. Sublime has fast startup times and lower memory usage but at the cost of features IMO. I won't go into a list of them but Sublime simply doesn't offer what VSCode does. And vim? I use vim every day, but to pretend it's comparable to VSCode for VSCodes intended use case is laughable. 
Symfony sucks
I used to dislike annnotations, and my first symfony project was annotation free. After using annotations, I have changed my preference. Everyone else is doing it, after all -and I don’t just mean Symfony. It seems like every major framework in every language uses annotations. 
Better upgrade now, don't even bother working on it as your PHP version is slow, buggy and most likely full of security holes. You can always upgrade, you're just not trying hard enough.
Some of the 'cons' may be true for newer developers since they aren't Symfony's target demographic. I can imagine using it without a console is hard, needing a lot of files may seem more complex but you are getting structure that is good for keeping much larger projects organised. Low performance / high overhead. Yes possibly, but equally if you need to optimise on performance then you have plenty of tools to help you and a good sysadmin will have no problem getting sub 100ms page renders. Documentation too is perfunctory but the code itself is excellent, if you use an IDE you can click through your methods and very quickly see what the code is doing. Finally, yes annotations aren't very popular with purists but they are optional, you can set things up to put that metadata in PHP code too if you so desire.
&gt; Does anyone have real world examples of the shorthand ternary operator? I understand them, I've just never encountered a situation where that would be a good solution. $foo = Bar-&gt;getThing($id) ?: new Bar(['id' =&gt; $id]);
 &gt; You need a lot of files to display a single page It's a framework, it's going to have a lot of files to display a single page. You need a router to figure out what page to call, you need a response class to format what you return correctly. You need a container for dependency injection for testing, quickly changing the services you are using, etc. You need a separate entity class to keep your business logic separate. You need a controller to bring everything together. You need a template to keep all view logic. All these files make it easy and save time to build a single page or a giant site/application. &gt; Promotes bad development practices Isn't the opposite of this in the pros? Annotations in comments are great. It's nice to be in a controller and see the route that's calling this. Or in your entity to see what data type, if it's nullable, the max length, etc. If anything it promotes good development practices like no global variables and functions. &gt; Very hard to install It's a single command to install. It's 2017, you need to learn how to use the command line for development. &gt; Doctrine ORM Doctrine is great, supports all different types of databases and makes development so much easier. And if you don't like it, it takes a few seconds to uninstall. &gt; Bad documentation I think the documentation is great. It's easy when you are just getting started and I've never been able to not figure out my issue by just googling. &gt; Low performance/Somewhat high overhead Pick the right tool for the job. If you want to develop something quickly, use Symfony. If you need speed, maybe pick another language. If you don't want to learn another language, strip out the components you need and bundle it into your own framework. Get your own container library, pull in http-foundation, twig/doctrine and you've got something much lighter, but without all the features.
&gt; IntelliJ seems to be the clear winner On what assumptions do you class it as the "winner"? &gt; a fully functional IDE VCS is not a fully functional IDE nor pretends to be, it's like comparing apples to oranges
&gt; On what assumptions do you class it as the "winner"? If you're looking for an all-in-one development solution that supports various languages(e.g. Java, PHP, Python, Go, Ruby, Perl, Scala, Bash, Markdown, JS, etc. as plugins) then IntelliJ is head and shoulders above any other product I've seen. &gt; VCS is not a fully functional IDE nor pretends to be, it's like comparing apples to oranges But the person you were replying to was speaking in the context of being a PHPStorm user, meaning a fully functional IDE. 
Considering this oddity only applies to nested ternary operations, it's not a whole lot more code
Development jobs are relatively easy to find, would recommend a proper employer.
A few of those Cons are going away with the Symfony 4 (flex) release later this month
Why not, if I may ask?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Quite often the developer is not the sysadmin. I was stuck developing on 5.1.x a couple of years ago and didn't have the authority to order (or even request) an upgrade.
The PHP version is too old.... I think updating the PHP version is more important than finding the template engine for PHP&lt;=5.2.
I prefer not using it because it makes the code less readable in my opinion. You need to break it up as soon as you want/need different keys than var names anyway... 
The similar library is available here. https://github.com/thephpleague/html-to-markdown
I think the compact() function is bad because it's not "human readable", a source of bugs, hard to debug, hard to refactor, not a good coding style (lower_snake_case variables). compact() will not issue a warning if the specified variable name is undefined. compact('var1', 'var2') is the same as saying array('var1' =&gt; $var1, 'var2' =&gt; $var2) as long as $var1 and $var2 are set. I consider compact() deprecated and would avoid using it in any new code. Long story short: don't use compact().
I keep forgetting these exist - I'd even written a function that basically does what ternary operators does called `iif()`, that clones the function of a similar name in mIRC's scripting language.
Ah. The typical scenario where everyone ends up working for IT support...
what is bad about lower_snake_case ?
fucking symfony
MUH EYES
Don't poke the zealots. There is only ONE way to capitalise / indent / space / curly brace and DEATH TO ALL HEATHENS WHO USE THAT OTHER WAY!
IoC is entirely unrelated to the presence or lack of a static/strong type system.
["Look, it's very simple"](https://herbertograca.files.wordpress.com/2018/11/100-explicit-architecture-svg.png?w=1100) he said... All this fails at being a conversation about architecture, because architecture is a concrete solution to a concrete problem, and this entire article doesn't specify any concrete problem being solved. Instead it seems to be an exercise in how many things you can mention or refer to, without saying anything at all. Look at that diagram up there. - Tell me what is the application about? - Tell me if the architecture is well-conceived, or it can be improved in areas? - Where are the strengths of this architecture, and where are the potential bottlenecks? You can't answer any of this, because that diagram doesn't show *absolutely anything* except to serve as a mental diagram of the author's buzzword skills. 
I use it often. My IDE deals with it well, personally I probably wouldn't in your ```save()``` method because it is a little unclear and I would never have my own keys named like that... But take for instance: controllerFunctionGet() { $stuff = $this-&gt;service-&gt;things(); $more = $this-&gt;service-&gt;more($stuff); return compact('stuff', 'more'); }
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Good change, I love that mixed white-space will trigger a parse error, hence there's no chance that this will result in ambiguously parsed strings.
I don't understand why Mac OS comes with PHP in the first place. What is it used for there?
Still hating on it for no reason. Is that also why you sent me a private message where you told me to fuck off and called me a dumbass with 0 explanation?
I did not say it is simple, where did you read that?! Now, to your questions: &gt; -Tell me what is the application about? I did not mention any concrete application, the goal here is about a generic way of thinking of generic solutions to recurrent problems. I guess you didn't read the article, although you are very welcome to comment on it anyway &gt; - Tell me if the architecture is well-conceived, or it can be improved in areas? This is a concept map. Its objective is to help us reflect about how we can improve the concrete architecture &gt; - Where are the strengths of this architecture, and where are the potential bottlenecks? An architectural style can help us identify and segregate code responsibilities, keeping the codebase modular, decoupled and cohesive, which is fundamental for maintainability. The danger is that someone might not properly read the article and end up trying to implement all these generic solutions without having the actual problems they solve. I suggest you go read a few books, from renowned software developers with decades of experience, like Eric Evans, Robert C Martin and Martin Fowler. Maybe start with Robert C Martin blog post about clean architecture, where he actually also has an architectural concept map very much like the one i created. Thank you for taking the time to give me some feedback.
I've read the books you base your blog posts on. If the resulting diagram is your conclusion about what architecture is after having read all that, you've learned all the wrong lessons. Keep it simple, stupid.
Well, i suggest you read them again, maybe you will learn the right lessons next time. Making it simple, is not the same as making it stupid. ;)
Perhaps I'm misunderstanding you, so let me clarify what is wrong with the current syntax. If a `\` precedes a `$`, then it will be consumed because the dollar sign is special. So var_dump( preg_match_all("/$/", '$$'), // match end (1 match) preg_match_all("/\$/", '$$'), // match end - PHP consumes \ due to $ (1 match) preg_match_all("/\\$/", '$$'), // match $ - PHP consumes first \, regex engine consumes second \ (2 matches) preg_match_all('/$/', '$$'), // match end (1 match) preg_match_all('/\$/', '$$') // match $ (2 matches) ); This is problematic, because if a `#` is used as a delimiter in a regex, then escaping that delimiter in the body of the regex now requires two `\`, since PHP will consume the first one, and the regex engine will need the second one. So the following: var_dump(preg_match_all("#\##", '#')); Must now become: var_dump(preg_match_all("#\\##", '#')); var_dump(preg_match_all('#\##', '#')); // single quoted strings are fine still 
Hmm, writing out the above reply has made me realise that I can perform some hackery in the lexer to not consume the `\` if only a `#` proceeds it (but still consume it if a `#{` sequence is found). It will be inconsistent with the semantics for `$`, though...
Funny enough, he had an earlier comment where he didn't seem to think Symfony was so bad or deserving of the cons listed.
&gt; Making it simple, is not the same as making it stupid. ;) Are you seriously the last person on the planet who doesn't know what the K.I.S.S. principle means?
Hi! Cmmon you were waiting for me to come here 
Yeah, my whole life revolves around you, sweetheart.
Your question us a clear follow up to your previous comments... 😂😂😂 You are the one who does not know KISS very well... it does not take a comma before the "stupid", otherwise we would be calling the other person stupid. That would be rude... I want to believe you are not rude, i rather believe you just don't know what you are talking about. [Go read a bit more](https://herbertograca.com/dev-theory-articles-listing) Live long and prosper. ;)
I'm genuinely confused about the rise in popularity in static site generators. What actual problem are they solving? Is this so you can push your framework-generated sites to static-asset only hosts (e.g. [S3 Website Hosting](http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) or GeoCities/Angelfire/Tripod/FortuneCity/other-90s-hosts-that-no-longer-exist) or is at a misguided attempt at performance optimization?
Would be nice if you paired this with some code
Im working on it for my next post, although it's gonna take a while...
Using the common spelling with a comma doesn't mean you call anyone anything, it just means you list two words. &gt; That would be rude... I want to believe you are not rude, i rather believe you just don't know what you are talking about. Well, at least you being rude and condescending is not a matter of "belief". It's there, black on white. &gt; Go read a bit more How about: stop spamming your low-quality shit in this sub and all over Reddit?
Hehe. For me, I like the simplicity of static html and I hope for improved performance. But a lot of the reason is WordPress is too much for what I need and I'd like to avoid any possible security concerns.
you don't know their situation to be casually recommending people to quit their job. sometimes you're stuck with a shitty job until the right opportunity comes along or until you can afford to make that move to make that happen.
With the caveat that you need to make absolutely sure none of the values PHP considers "falsey" (`0`, `'0'`, `[]`, etc.) are actually valid values that you'd like to keep from `$bar-&gt;getThing($id)`. That might seem like a ridiculously obvious thing to say, but I've seen `'0'` bite people quite a bit in form POST contexts where zero is valid input from the user, but the developer naively only considers the empty string and/or null cases when choosing to use `?:` to assign a default value. Since `'0'` is technically "falsey", the default value will always override the otherwise valid user input, and if the default value just so happens to *not* also be zero, you're in for a real debugging treat.
Im really learning a lot from you... How about you share some of your knowledge and experience with the community? Please, tell me how its done. How do you keep your codebase sane, flexible, decoupled... how do you compartmentalize the domain, make explicit the boundaries of the bounded contexts... and so on. Maybe you did already... please, tell me where can i read about your ideas and your experience. Just talking bad about others ideas is easy, please tell me how i should do it better. ;) How about: you learn some manners, stop being rude, contribute with something positive for the community?
probably using it wisely here and there might actually be the best option
probably using it wisely here and there might actually be the best option. About the &gt;I would never have my own keys named like that what do you mean exactly?
That blue-on-blue color scheme on the code blocks is almost unreadable (also the font is tiny).
Once it's set up you barely need to think about the underlying PHP from a designer point of view.
It's dead because it's hard/impossible to implement properly.
`?:` is really useful for sorting things. `0` as a three-way-comparison result means “equal”, is falsey, and if the first thing you're comparing by comes back equal, you would like to move on to the second. So: `($a - $b) ?: strcmp($c, $d) ?: ($e - $f)`
God, I wish it worked like JS's falsiness. Or rather, I wish `'0'` weren't falsy. `||` in JS (the equivalent to PHP's `?:`) is really useful against empty strings, but `?:` in PHP isn't because of `'0'`.
Assuming your web server's configured correctly, it will contain only and exactly the raw contents of the request body. However, this is user input, it comes from an external source, the client. You should never trust user input. You cannot control the client and must assume the worst.
&gt; What actual problem are they solving? Static sites are simpler, faster, cheaper. If the site doesn't need to be dynamic, why make it so?
&gt; what do you mean exactly? Just personal preference but I think: return compact('name'); Is quite clear what's happening as to me it's cleat the $name variable is being compacted. Whereas: return compact('motr_title') It doesn't scream that $motor_title is a variable.
But you're generating it dynamically you're just adding in the most inefficient caching process possible.
so in other words... in theory its safe but in reality there be dragons ahead?
I don't think it's more readable since there is less code to read and it's not a obscure feature. I like to compare it to the `{ var1, var2 } == { var1: var1, var2: var2 }` from JS. 
No, it's safe if you don't allow user input to control it.
Majority of "unsafe" operations in any language are because of potentially malicious (or erroneous) user input. When working with web applications just about every security concern comes from user input. Why does it matter if it's safe "in theory"? It's simply not safe to trust user input, ever.
I don't think he's so much suggesting that there are dragons in file_get_contents. But reminding to be careful with it's output. Apply validation etc as you would any user input. Don't go passing what it returns to any shell commands... etc.
I find it nice to use in a return statement or when passing to another method. Take for example, instantiating a DTO: ``` public function saveRequest($request) { $name = $request-&gt;get('name'); $email = $request-&gt;get('email'); // Maybe we validate the fields here... // Create our DTO and pass it to the database $user = new UserDto(compact('name', 'email')); $this-&gt;database-&gt;store($user); } ``` To me, using the compact function works here. My preference is if you're just passing data around and your variables are short and concise, it becomes more readable. 
I'm using htmlspecialchars($maliciousXSS, ENT_QUOTES, 'UTF-8') For my response. I'm more concerned about the server
As long as the variables are defined same scope , there is nothing wrong. I prefer to pass it as parameter or return value
Sadly this blog post only tells me that there are 2 feature complete libraries but doesn't delve into how they are different. 
To clarify: $var = file_get_contents('php://input'); This will not, in and of itself, lead your server being hacked. What you do with that server AFTER you've grabbed the POST body, however, can still be dangerous. See what /u/the_alias_of_andrea's comment.
Furthermore, it breaks PHP static analysis tools and makes it harder to reason about the security of your software.
To be fair, there’s nothing inherent to it that prevents static analysis - it just requires some additional special handling. All of the necessary information is available. And way less janky than `extract` I get what you’re saying though and largely agree. PHP still has a loooooong way to go when it comes to static analysis. 
Just to be a jerk, since $arrays and $string are hard coded, I will say my answer is true Becuase it is :P
I feel like there's always a refactor that would eliminate a need for compact() that's more readable.
This is more or less what Drupal's phptemplate is. And it worked for several years for us. 
Do you really need a template engine for this? One could easily do this with a simple PHP template (PHP is a templating language after all), and it will work out OK if your team is small and pay attention to properly sanitize the variables. 
Depends if you are executing the input or modifying it or checking tje data before using any. If you check the data you should be fine :)
That'll be $2,500 per person-day, with a billing unit of one day, plus tip.
Step debugging.
i can use xdebug to step debugging only some of the logic because they may exit at any line
A sequence diagram could be helpful for solidifying lifecycle of the methods and any external dependencies. 
I only use it when I'm purposely making arrays for the sake of actually having arrays (for instance the above could be part of an JsonSerializable() object)
Take a small confined block of logic from the method, and cut-and-paste it into a new (private) method that you call. Make sure the new method is very descriptively named. Keep doing this, and the top-level method should end up reading a lot more like a sentence (or several). It should be a bit easier to follow than reading the code directly, and should translate pretty well into a flow diagram. Even if they don't want the changes committed, the process of doing this will help you become more familiar with the code and break down the logic into smaller, easier-to-follow chunks.
i am afraid i can't do it. i can understand the code but i can't understand the bussiness. why check the input here, why check the inlut there, i don't know....so it's difficult to draw a squence flow diagram.
Sure, but often you can just assign the values straight to keys in the array instead of making variables first.
Not if you need to do something with the variables, like in my example above, $stuff is used twice. (I specifically did that on purpose :P)
&gt; With the caveat that you need to make absolutely sure none of the values PHP considers "falsey" Not particularly hard if ```getThing()``` only returns an object or null..
Assholes. He got tired of them.
http://www.timewellspent.io/ maybe?
Firstly, be sure that you actually need to access the *raw* POST data. Both jQuery &amp;&amp; PHP have built-in support for the convention of using `Content-Type: [www-form-urlencoded](https://en.wikipedia.org/wiki/POST_(HTTP)#Use_for_submitting_web_forms)` to transfer data via POST requests. The easiest treatment of form data would be to use the `[.serialize()](https://api.jquery.com/serialize/)` method of a jQuery object wrapping the form element itself. This would result in a separate key in the $_POST array for every field in the form. However, in your case, you could easily use `data:[$.param](https://api.jquery.com/jQuery.param/)(formObject)` to the same effect. Normally that would convert the keys of the `formObject` object into the keys of the $_POST array. If you absolutely wanted to be dealing with a single variable from the $_POST array, then you could achieve that with something like `data:$.param({myVariableName:postObject})`, and if you absolutely wanted to be dealing with a stringified JSON object at the other end, you could use something like `data:$.param({myVariableName:JSON.stringify(formObject)})`. That said, the result of using `php://input` to pass data into PHP isn't inherently more dangerous than reading data from a file. The difficulty and risk lies with having an extra layer of home-baked code to interpret the raw data you've received.
Do you have test data? You could refactor it and just teat to make sure you get the same output. While your code may not handle every edge case since you don't know the business requirements that it addresses, you should be able to get the gist of it. My guess is it's poorly written, no single class should be incomprehensibly large. So this is someone throwing their entire business in main() Also, you could try walking through it and just comment the shit out of it. Start with what it's actually doing since you don't know why. If you're using an editor that allows you to collapse sections, comment then collapse leaving the comment visible, this will leave you with the flow. Your comments will suck without the why, but it might be enough to figure it out. 
Another potential reason is that Taylor has some pretty strongly held views about how to actually get things done. There's a sect around here of puritanical and dogmatic folks who made every interaction with Taylor a slog that was tough to get through as a reader, I cant imagine having to deal with all of them as Taylor. I remember when people were acting like it was the end of times because an Invoice class in a laravel project was able to write itself to disk. The horror.
Doesn't he just have a new account? Something like /u/taylorotwell? 
All the shit he's ever said finally caught up with him.
Correct, but that means you'll have to start looking. If nobody tells you what you're doing is a bad idea, you won't know that it's a bad idea.
I've personally witnessed Laravel draw an irrational and disproportionate amount of criticism from /r/php. The general attitude I've seen here is "Laravel is good for small personal projects, but good luck building anything complex with it". So if I were Taylor, I'd nope out of /r/php too.
 function controllerFunctionGet() { $what = [ 'stuff' =&gt; $this-&gt;service-&gt;things(), ]; $what['more'] = $this-&gt;service-&gt;more($what['stuff']); return $what; } Personally I'd probably be more likely to write this: function controllerFunctionGet() { $things = $this-&gt;service-&gt;things(); return [ 'stuff' =&gt; $things, 'more' =&gt; $this-&gt;service-&gt;more($things), ]; } or maybe add a method to $this-&gt;service: function thingsAndMore() { $things = $this-&gt;things(); return [ 'stuff' =&gt; $things, 'more' =&gt; $this-&gt;more($things), ]; } function controllerFunctionGet() { return $this-&gt;service-&gt;thingsAndMore(); } There's always ways.
They aren't fashionable. Get with the times! /s
Oh, the irony of an infographic advertorial complaining about technological tools subverting our desires in the name of advertising.
Laravel is dated and based on a pattern that was used maybe 4 years ago. Devs that use it today are way behind the game. It's a shame for Taylor considering how much work he has put in, but at the same time, you cannot have such an opinionated framework (which is a copy of rails, which is also dead,) and expect it to survive when the opinions of the surrounding community change.
Ask them? 
&gt; which is a copy of rails, which is also dead Implying that Laravel is dead, despite still being the most popular PHP framework?
Oh? And what, in your opinion, is the state of the art? What is the front of "the game"? 
Taylor couldn't stop replying to every mention of Laravel, his fingers nervously pecking the keyboard keys in a hopeless, desperate attempt to set the naysayers straight. It has become an unhealthy obsession, a Pavlovian instinct consuming him entirely, eating away at his time and turning him into a mockery for the entire community to see. "This is not good, why am I doing this", he said to himself countless times... and then kept posting. One boring morning, as he was in the middle of crafting a long response to someone who has said "Laravel is not actually MVC", he suddenly knew: he's not using the account... this entire time, the account *was using him*. Upon this shocking realization, the next step could be only one thing - extract this parasite and destroy it. With trembling fingers, he Googled "delete Reddit account" and the first link was precisely what he wanted. He entered his username and password, ticked the disclaimer checkbox, moved the cursor over the "deactivate account" button, closed his eyes, and plunged in.
Thanks for the mention. Although I'd be much happier if I haven't had to say anything - if PHP would just get it right. :)
Taylor couldn't stop replying to every mention of Laravel, his fingers nervously pecking the keyboard keys in a hopeless, desperate attempt to set the naysayers straight. It has become an unhealthy obsession, a Pavlovian instinct consuming him entirely, eating away at his time and turning him into a mockery for the entire community to see. "This is not good, why am I doing this", he said to himself countless times... and then kept posting. One boring morning, as he was in the middle of crafting a long response to someone who has said "Laravel is not actually MVC", he suddenly knew: he's not using the account... this entire time, the account *was using him*. Upon this shocking realization, the next step could be only one thing - extract this parasite and destroy it. With trembling fingers, he Googled "delete Reddit account" and the first link was precisely what he wanted. He entered his username and password, ticked the disclaimer checkbox, moved the cursor over the "deactivate account" button, closed his eyes, and plunged in.
Hahahha that was fucking rediculous. You’re either trolling super hard (in which case good job) or you’re insane. If not, I’m interested to know what “pattern” Laravel is based on that was popular 4 years ago.
I use pHPstORm daily, I like it.
I am a PHP developer who has been forced to work with crappy code in the past. If you're using PHPStorm or a similar IDE, try breaking it up into many smaller methods and see if you can make sense of it that way. In any case, refactoring is probably the best way to go about this sort of thing. If it's as bad as I suspect it is, rename everything so the names make sense. Once you finally get it, go back to the original code and see if it clicks then. You need to understand it at an intuitive level, if that is even possible. If refactoring doesn't work, then first of all I feel your pain, and second of all, often this sort of code tries to put things in arrays and shuffles data around in them. Assume that it used to be a single procedural file and is now wrapped in a method and the original author had no idea what OOP is. HTH 
I get that Laravel may not be the new and trendy thing that it was 4 years ago, and if you want to follow the community and use every "new" design pattern (usually old ones that become relevant again cyclically) it's awesome and a good way to stay in the loop. Unfortunately many of us have products to ship and need to ship them in time if we want to make a living, so we don't have that luxury, and ab opinionated framework that we know works well and will get things done quickly is just what we need.
He is active on Twitter - he could answer this important question. https://twitter.com/taylorotwell/status/931898473812779008 
This spam feels about as useful as a joke without the punchline...
Complicated methods are code smell, imho.
This php project did have some problems in db migrations, dev environment sharing, and other drawbacks. But it is basically tidy and has complete tests. It's OOP and uses many design patterns. It's not crappy. It's just that the bussiness is too complicated. well, as an experenced PHP developer, I am quite famillar with php ecosystem. I started to doubt that maybe I'm not a native English speaker and that make me can't understand it.
That opinion is correct, though.
👏
Again, exactly what I'm talking about. I don't have the energy to explain why "Devs that use it today are way behind the game." is weaponized stupid, so I won't bother. I'll just leave this as further evidence for why Taylor felt the need to nuke his account.
[removed]
That shit-eating grin gets me every time.
Use PHPMD on this file. If the complexity level is above the limit. Tell them they need to refactor.
his new account is /u/TaylorCodes
But it's not evidence, it's your opinion.
&gt; and expect it to survive when the opinions of the surrounding community change. I read this as "Laravel isn't a good fit for the specific types of projects I work on, therefore I declare the entire community agrees with me."
You're absolutely correct: [this guy's post is indeed not evidence, and only his opinion]https://www.reddit.com/r/PHP/comments/7efb2l/why_did_taylor_otwell_delete_his_reddit_account/dq4oz7o/) 
Do you have evidence that Laravel is a bad choice for anything complex....or is that your opinion.
I have experience. 
So do I.
Because /r/php is a toxic shithole.
I'm not trying to change your opinion. If you earnestly believe laravel is a good choice for your next enterprise-level project, that's your mistake to make, and you're free to make it.
The 'mistake' is 100% your opinion. I'm telling you right now that we use it in a large enterprise-level project, and have no issues with it despite the massive amount of traffic and continuous additions we make. Blaming a framework on your own fuckups is weak. Maybe you just need to learn how to use the tools provided to your advantage.
#MeToo Works fine.
Isn't the whole PHP not a good choice for enterprise-level developments ?
He phrased it badly, but he probably meant activerecord. 
There is a magical technique that lets you understand the precise intent of the code author: **ask**.
Professors are notorious for saying the most powerful programming language is called "Graduate Student". 
Agree about compact calls and SCA. When it comes to SCA tools for PHP, I'd say it's high competition there and it's already on good level: https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-, https://github.com/FriendsOfPHP/PHP-CS-Fixer, https://github.com/phan/phan, https://github.com/phpstan/phpstan Just in case, I'm the author of Php Inspections (EA Extended) - we have already reached the level of c/c++ SCA tools (quality and covered topics), but I'm biased and probably missing your point.
The thing is this isn't irrational or disproportionate. This is merely having an opinion of what Laravel is good for and what it's not. The same applies to Symfony, Zend, etc. Also, it's completely rational to have these opinions. A lot of the issues people point out with Laravel have been considered bad practice for over 10+ years. This is stuff coming from Javaland which for the most part transfers 1:1 into PHP. A good write up would be, https://github.com/carnage/carnage.github.io/blob/master/_posts/2017-02-15-laravel.md. Plus I think we need to remember that what some people consider complex and what other people consider complex are two very different things. For example, some people would consider something complex if they had to assign 4 devs for 2 months to it, while other people consider that a small project.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [carnage/carnage.github.io/.../**2017-02-15-laravel.md** (master → 413fdd3)](https://github.com/carnage/carnage.github.io/blob/413fdd3cdee114792e5bae569539da289234b003/_posts/2017-02-15-laravel.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Perseverance is needed. I've had times where I've stared at someone else's code for days not understanding the business logic. Eventually something clicks and 10 minutes later, I can see what everything does.
What is your input, what is your output. How do they relate. What has changed from your input to your output. Then start identifying the mutable operations of your code. Start to call them step1-stepN. Then identify which each step is doing. This will identify a pipeline for your data flow. Then you can break each up into it's parts.
&gt; Quite often the developer is not the sysadmin. I was stuck developing on 5.1.x a couple of years ago and didn't have the authority to order (or even request) an upgrade. Exactly this :-)
The development work is rather bad, no real version control, really old legacy systems etc. But my co-workers are amazing people, I've got no real schedule (Just gotta work x amount of hours total each month, it's up to me whenever I want to do it) and I'm free to work on what I want to, pretty much whenever I want to. I wouldn't trade that freedom for anything :-)
Not true, I'm afraid. Trust me, I've tried several times to suggest upgrading. Upgrading is out of my hands, since I'm neither the manager nor the sysadmin.
If it already has tests, is fully commented, and meets the appropriate style guide then things shouldn't be too bad. It might be worth running a few code quality tools against it to see what they say. It might also be worth seeing what you can do to refactor it to make it more self-explanatory - with good test coverage that shouldn't cause any problems. One thing I will say is if it's doing that much it may be too complex, and it might be worth considering if there's functionality that should be moved to other classes.
Make a gif of it, publish it on facebook as trivial-game with a header: "Only for genius".
case in point
Only text conversion without regards to ergonomics of "translated" text? Formatting numbers, dates? Left vs Right text? Languages with ligatures and/or special fonts? What will be consuming those translations? Who and how will be updating translations? Any hard coded texts as images?
Not even for your sanity?
Technically Rails is also the most popular Ruby framework.
&gt; What good localization libraries do you know? The terms "translation" and ""localization are often used so interchangeably, it’s not uncommon to be unaware of the differences. In the context of youre question I think you mean text translations. I'm using the [symfony/translation](https://github.com/symfony/translation) as standalone component (without the whole framework). For convenience, I've created a little help function for myself. function __($message) { $translator = ...; // @todo fetch the translator object from the container $translated = $translator-&gt;trans($message); $context = array_slice(func_get_args(), 1); if (!empty($context)) { $translated = vsprintf($translated, $context); } return $translated; } Usage: echo __('There are %s people logged in', 7); // There are 7 people logged in 
I'm not a fan of things that hack into the current symbol table, like compact and extract. To me, they are one of those remnants of old PHP (like variable variables) which should be killed sooner rather than later...
Did you considered using msgpack instead of json for structured data transfer? It is faster and more compact in both Go[[1](https://github.com/alecthomas/go_serialization_benchmarks), [2](https://github.com/smallnest/gosercomp)] and PHP[[3](https://github.com/msgpack/msgpack-php/blob/master/benchmark.php)].
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [msgpack/msgpack-php/.../**benchmark.php** (master → 943d272)](https://github.com/msgpack/msgpack-php/blob/943d27267fbf6da6b4d225f344f4731aec0c671b/benchmark.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
What do you mean by "exit at any line". That's not PHP feature. You can not exit at any arbitrary line. You have to either: a) run past resource limits b) die() c1) throw exceptions that are not caught c2) throw exceptions that are caught by something a) need not be considered for DFD, b) should be shown as final stage of DFD if it occurs, c1) treat same as b), c2) DFD do not have to distinguish asynchronous from synchronous data flow, so mark it as ordinary line, but name it properly Also, I think you are a bit confused by what should be presented on DFD. Data processing IS unnecessary detail. Here is link that may help you: https://www.lucidchart.com/blog/what-is-a-data-flow-diagram?drtb=4 There should be lot's of processes on your diagram, even more arrows, and some external entities. Stores for db/cache or other storage mechanisms. Also DFD *may not* be reverse-engineer-able from code alone. Talk to people who understand the processes implemented. "Capitalize column A" is wrong name for a process while "Sanitize and clean up text" is OK.
It is possible. We specifically extracted sockets from codec implementation so can you use any custom serializer. JSON has been used as an option which works everywhere.
First two paragraphs are pure gold. Architecture/Design are meaningless without context. Bullet points highlight context of bigger/longer living applications where given architecture (or something partly that way) brings concrete benefits. 
Could you explain some more. From what I understand then, there is no architecture diagram that could show "how should we handle case when...", cause that's not a thing at component level of whole system. It looks to me like properties of some of the elements of the diagram. (Like "good" command is modeled after business need and/or process, while bad command is modeled after technical change to data. Both will look like same box/circle/whatnot on architecture diagram). However I would really love to hear how ubiquitous language can be "brought in" into architecture as first class concept.
I think that KISS is meant to give offense, to anyone who tries to over-complicate stuff. For complex apps though I would argue that over-complication is actually going into both extremes. There will be some (or many) sweet spot. Going too complex mean too many useless abstractions. Going without many necessary abstractions will make code unnecessary verbose, brittle, and repetitive. Call it complicating and multiplying code for the sake of avoiding abstractions if you will. But KISS is meant to give offense. Convey harmfulness. Put a peer pressure on faulty party.
&gt; Annotations in comments are great. It's nice to be in a controller and see the route that's calling this. Or in your entity to see what data type, if it's nullable, the max length, etc. If anything it promotes good development practices like no global variables and functions. I think the opposite is the case. Annotations are a very bad practice, as they cause unnecessary coupling and break the separation of concerns principle.
Absolutely, and without knowing the context, this may be the answer they want you to give. If I see a big complex method I ALWAYS want to refactor it to be smaller. Maybe try breaking the method up gradually into much smaller functional components?
LOL
fuicking sumfny
&gt; The thing is this isn't irrational This is merely having an opinion of what Laravel is good for and what it's not. The same applies to Symfony, Zend, etc. Also, it's completely rational to have these opinions I have some bad news for you that you may not like: some opinions can be more rational than others. Having an opinion does not automatically mean it is immune to assessments of its rationality. An opinion that Laravel is only good for small projects is inherently irrational, because it is factually inaccurate. Many large projects are built using Laravel, and there is nothing fundamentally problematic about Laravel's architecture that would prohibit from being used to build large, complex apps. But it does require you to actually *know* how to use it, which most of its detractors do not adequately no. This means their opinions are based on incomplete, inaccurate information, making those opinions irrational by definition. &gt; or disproportionate. The amount of hate that Laravel gets on /r/php is absolutely disproportionate to how widely used it is.
I lost that a long time ago, my friend.
1. Define "enterprise-level" criteria 2. Enumerate why PHP might not meet those criteria.
&gt; can be "brought in" into architecture as first class concept. What is architecture in the first place? If this is set of constraints that you put onto system, then we could move to object naming and life cycle, how you separate boundaries of different context. For example in case of author we could make use of domain events and commands (sagas) to express complex processes using just business terms. Or we could make use of mediators in order to do same thing. The point is that every technical decision should be driven by business. For example: https://www.youtube.com/watch?v=NZ5mI6-tNUc
&gt; An opinion that Laravel is only good for small projects is inherently irrational, because it is factually inaccurate. Many large projects are built using Laravel, and there is nothing fundamentally problematic about Laravel's architecture that would prohibit you from building large, complex apps with it. Just because you can't doesn't mean you should. I do a bunch of stuff that I can do, but I really shouldn't do. &gt; But it does require you to actually know how to use it (like literally every other tool in existence), which most of its detractors do not adequately know. This means their opinions are based on incomplete, inaccurate knowledge of the framework and its capabilities, making those opinions irrational by definition. The people complain the loudest in my experience are the contracts who work with multiple different types of the framework over the years and have experienced the pain they felt with Laravel because of the way it was written. The not so loud ones have looked at the code to write it the Laravel way and have noped out. Others such as myself talk to Laravel developers and I ask them about the rumours such as BC breaks. The answer I got was "No there aren't really any BC breaks. Well, of course, you need to check every release of every module to see if they've changed something but you do that once per release and it's fine." I noped out there, especially coming off a project built on a framework that had BC breaks constantly, spending a week just "upgrading a module" just didn't sound nice. But if you're building something and not going to work on it again, Laravel looks great. If you have to maintain that bad boy I start sensing it's not going to be fun. Then you also have the fact that majority of people using Laravel are not in-house devs building something that the company knows is going to be maintained for years, but Agency devs building one-off websites that when they change the website they do a new build. If you really want to discuss the merits on Laravel on long-lived projects (3-4 years minimum), then I think the best way to do this would be to write a rebuttal blog post to Carnage's. I've literally not seen anything written about this, all I've seen is "People are doing it so of course you can" and the like. Instead of talking about the merits of the code. &gt; The amount of hate that Laravel gets on /r/php is absolutely disproportionate to how widely used it is. It's an extremely large, extremely well-used piece of software. This means a lot of people have an opinion. We can liken it to WordPress, again does it's job well, people still hate it and because so many have experience with it more people have a reason to feel like they hate it.
Good point. Might be even a trick question how OP handles it and eventually engages the right people. 
Code clarity. You can assert that something is a `Duck` and can `quack()` without being forced to make assertions about that duck's ancestry or probing the poor thing for duck-like anatomy.
An interface is not needed for me to call fly() on a Duck, you got that part right. But as soon as I add FlyingInterface to my Duck class I'm making this behavior official and better documented. Now my method can check for FlyingInterface, just like some functions check that the type of an argument is integer or string. And I can stop to care if it's a Duck or not, as long as it implements the right interface I can tell it to fly. 
Just to clarify on "implements"; A duck isn't the only thing that can fly, it could just as well be a bug, eagle or even a helicopter. So when checking if something can fly, you don't want to check if it's a duck, you're only interested in flying. So you simply ask "can this fly? aka $obj instanceof FlyingInterface", instead of checking for all possible flying entities "$obj instanceof Duck || $obj instanceof Helicopter || $obj instanceof Bug" etc.
Wordpress uses .po/.mo files for translations. Thanks for your suggestions.
Simple string translations. Such as: "banana" to "apple". Or even single word to two/three words translation.
Unit testing. Need an interface to mock it.
PHP is also dead.
Those are all happy side effects. Interfaces help you properly design your system. Your description is exactly why we use interfaces. Dynamic or not, we still reap those benefits.
With containers or such configs you can create your own class to send to a library which expects a class to have certain methods which are defined by an interface. Without replacing the original class you can replace the class inserted in the constructor/container. 
Dynamic dispatch is just small step further than just using interfaces. With DD you can decouple the instantiation a little it more. Anywhere your application needs an instance of `IFoo` it just grabs the registered instance and goes about its way. You no longer need to new up that implementation in multiple places, and whoever instantiated the service didn't need to be aware of its dependencies.
What is the use case for this?
But you need a service container for that, right? Most modern frameworks have it I know. That's when it makes most sense to me, on a service container it's very elegant to use interfaces, otherwise you'd need to use strings.
We are using it as part of Go microservice which isolates and supervises legacy application and allows us to invoke its methods via RPC. We also use it to connect to message broker from PHP processes. 
Let's disregard pseudo interfaces like callable for a moment. It's true that PHP do not require interface or class to route method call on an object properly. PHP will simply track such info at runtime and will do it's best to execute specified method or will fail with error/exception. It's true that if we wanted we could use reflection API to guard any requirements we possibly could have for object with witch our code need to cooperate. Interface can be thus understood in PHP as common name for existence of specific methods and/or properties on a given object. However while such existence can be assured through execution of dynamic code, Interface gives such guarantees statically. So at one hand Interface is just an optimization of programmer time ( we specifie single guard "is interface X", instead of "have method Y, Z, ... and property A, B, ..."), but on the other hand it's great help for the tooling that can now better support code. Interface is also more explicit then guards spread across codebase. So interface is better suited for signaling intent to programmers who will have to write implementations. Interface state not only what is provided by object but also can state what is *not* relevant (ie anything not covered by interface). So with interface code that deals with such object can say "I only care about those methods/properties. Nothing else matters. Nothing else will be used. Nothing else is needed." That greatly improve reuse of code, because various implementations of interface can differ in *antything* not covered by interface. With interface it's explicit. Lastly interface can be more easily included in documentation. But not all is roses. One limitation of Interfaces in PHP is that while objects can support multiple interfaces, we can type after *only one of them* (*). We can on the other hand write by hand as many guards using reflection API as we like. (*) There is technically a possibility of creating yet-another interface that extends all those interfaces after which we would like to type after, however we would have to change all classes to implement that extra interface too. 
Obviously this was me being sarcastic to underline how ridiculous this debate appends to be. I spoke to some Java "expert" about how PHP was dying and sketchy of a language it was and how toxic of a community it has to finally understand the guy never worked on a PHP Project and was just referring to random old blog articles he read about PHP 4. It's exactly the same here, some random guy comes, says Laravel is bad because he "doesn't like the pattern" and grabs the popcorn.
That's mostly correct. Since `ClassName::class` and `InterfaceName::class` are both strings you can help cover up the magic a bit though, rather than using `interface_one`. Beyond that point it's on the developer to decide what is acceptable to allow. The benefits provided here significantly outweigh the drawbacks in any case.
Brillant, thanks!
For next time, post this in /r/PHPhelp. You're forgetting that you're scraping ALL quotes matching that structure. This means `$quotes` is returned as an array. Iterate it :) foreach ($quotes as $quote) { echo $quote-&gt;innertext; } You quotes variable looks unnecessarily complex. Looking at the toscrape.com source, it seems you should be able to use something as simple as the following to get all the quotes: `$quotes = $html-&gt;find('span[class=text]');`
Is that Maybe implementation a true monad? Can Either implementation be used instead? How hard it is to compose? How hard it is to extend this library with new functionality?
Exceptions are ok if your code *must* have completely different code path for failure. Propagating null is ok, if value is optional and thus failure path is similar to that of success and only end value is different. (You still need to handle it properly somewhere down the code flow ;)) There are also constructs that would allow us to synchronously return error message, however I do not know weather Grabber have support for those. So depending on context, excpetions are not *the best* thing ;)
Isn't ML-style based on sum types, with guaranteed exhaustiveness?
You mixed Dependency injection with Dynamic dispatch. DI -&gt; instantiation of objects DD -&gt; deciding what to execute when code want's to call class method (or function, cause DD can happen over function argument too!)
I grant you there are times when you don't want to fail. You just want to pass the null/false/0 value forward. I get that, but it'd be better to catch an exception and then pass a null/false/0 value forward using that. The problem with quietly doing this is that other developers often wont test the value. Better to fail hard so that a failure is obvious and a developer can cater for that than to fail softly and hope that they do.
Because his wife caught them crossdressing in /r/traps
Exception + null forwarding do not help with how downstream code handle or mishandle null value. Exception will also introduce asynchronous code and possibility of crash if callee do not catch it. So we get possibility of mishandling of null and possibility of mishandling of exception ;) Exception do get us that error message though! Sometimes useless if call graph is complex enough, but null value give us useless error message if call depth is greater then one. For that we could introduce similar structure that can represent correct value **or** error message, that is forwarded if structure contain it. We could also introduce debug-only structure that logs all the calls, parameters and stuff like that to get minimally more meaningful call graph for complex cases.
I guess I'm a little fuzzy on the difference. My assumption is that a different implementation would mean a different object. Even if it's a function call the implementation object would be passed in by the container. Could you give an example of what you're explaining?
Hello to be honest, for now, it cannot be extended easily. I'm not this far in the development process but i'm thinking about it. My first goal was to have a first stable version with a good test coverage in order to have a strong basis to improve from version to version. Extending Grabbag would certainly be one of my next topic :) You can follow the project repository on github if you want to be notified. Thanks for your interest. 
Yes, you're right. If you use it in a situation where the expression is guaranteed not to return any falsey values, then it's not particularly hard to make sure none of the values being returned are falsey. Thanks for the insight.
$obj-&gt;method($param) That is turned into CPU executing some piece of code right? That process of selecting what to execute is called dispatch. There could be static dispatch. We declare someting as of type/class/interface/whatnot X? so go to X find *method* execute it with *parameter*. Done There could be dynamic dispatch. Track *obj* by what it is thought code execution, and then check for *method* inside it. If it's not there go up it's inheritance chain. (Methods from traits and interfaces will already be inside class) Whatever is found first with name *method* will be executed with *parameter* passed to it. There is also version of dynamic dispatch that works on arguments of function by matching types of arguments to known definitions of function. Language need to support function overloading and or parametricity at run time (e.g. List&lt;Apples&gt;) for it to work. DI is only concerned with instantiation of dependencies. DI may provide proxy to deffer instantiation to the last possible moment, but finally such instance will be provided. Both may be at play at the same time of course.
Go fuck yourself.
👏👏👏👏👏👏
That's true for statically typed languages.
Google also added protobuf support to php recently too. Though msgpack might be preferable for not having to define the schema. I agree, it would have been better than json.
I use this in my script if you look at the code
In phpstorm is it possible to sort the contents of a directory by type (trait, abstract, regular class) and then alphabetize each type instead of just having all of the files alphabetized?
A quick analogy from the business world. The interface is the license to provide a service, the objects are the companies providing the licensed service. It ensures the license requirements are specified in a clear way in one place, and then you can refer to the license shortly by name, and have multiple companies implement it in the same way. You don't need licenses for everything, but a license ensures you don't have to start from scratch with every new service provider, you have a common platform to start from - you know what you're getting from them. 
As the OP said, PHP is dynamic: variables and properties are not typed - only their values have types. However it's often useful to pretend that static types exist. They don't exist in the PHP compiler, but they can exist in the minds of programmers and in static analysis tools like IDEs. For instance we might want to annotate a $log property with /** @var [\Psr\Log\LoggerInterface](https://github.com/php-fig/log/blob/4ebe3a8bf773a19edfe0a84b6585ba3d401b724d/Psr/Log/LoggerInterface.php#L20) */ . Then when we're working with that property we'll know to expect it to be a an object from a class that implements LoggerInterface, and to only call methods declared in LoggerInterface. IDEs will offer those methods as autocomplete options. At run time the value might be an implementation of [\Illuminate\Log\Writer](https://github.com/illuminate/log/blob/9b76b5fd57bd9786fcc725c3b092488aab970dd4/Writer.php#L21) in one context and [\Monolog\Logger](https://github.com/Seldaek/monolog/blob/7405bb5d673df9ee05698876843e85b0b8a599d4/src/Monolog/Logger.php#L27) in another.
Thanks to all who explored my recent work on [Agile UI](https://github.com/atk4/ui) and I really appreciate all the encouragement. I started posting some articles on Medium explaining various decisions I've made and some comparisons to your current development patterns. Hopefully you will find that interesting! (your questions and feedback inspires me to write more)
This is quite awesome for those who only plan to learn PHP
That’s basically it, interfaces in php are just sugar, the language doesn’t need them, it helps programmers reason about code.
Until native typed-enums exist... I think I'll just stick with good old fashioned class constants and a static array to provide the mapping to text. Almost every enumeration I use is put through persistent storage at some point or another, and I'd rather not deal with the faff of type juggling them into classes on IO, as that presents a much larger scope to introduce errors IMO. When the time comes, I do wonder if I would switch to using a separate class for each enumeration, or perhaps the enumerations would still be part of a class (for autoloading). I kinda like having them within the class that contains the properties.
Refactoring shouldn't be an end itself - by definition it provides zero value to the user. That doesn't mean you shouldn't do it, but don't think of it as a project in itself. It can be an important aspect of *how* you work, not *what* you're working on. In *Refactoring*, Martin Fowler writes: &gt; ...many people ... are more driven by schedule [than by quality]. In these cases I give my more controversial advice: Don't tell [your manager about refactoring]! &gt; &gt; ... Software developers are professionals. ... A schedule-driven manager wants me to do things the fastest way I can; how I do it is my business. The fastest way is to refactor; therefore I refactor. So work through your top priority issues. It sounds like many of them are performance issues. With the support of your lead dev and team, refactor the particular code that you work with on each issue, either to make it easier to fix the issue or so that next time you come to touch the same code it will be easier to work with. Similarly add tests around the code and functionality you change. Get a good IDE and learn how to use it to find out where any method is used, while remembering that it won't be perfect and can miss things depending on the structure of your code. As xiongchiamiov says read Working Effectively with Legacy Code by by Michael Feathers, as well as Refactoring by Martin Fowler. 