Here's my situation: I *have* been "developing" (well, making small websites) for a long time; as a freelancer, working on anything up to 4 different websites per week, with quite a high turnover. I.e. a similar situation to that described by /u/everstone below ("If you are working for alot of different clients, side projects etc it may not make sense to provision a virtual machine specifically for each client - thats alot of set up.") Do you still think it's unprofessional of me to use xampp? Genuine question. 
Because by doing that you're building your application "inside" AWS. AWS is an "infrastructure" environment, not a "hosting" environment, i.e. you're supposed to build your own hosting on top of AWS with the building blocks AWS provides you. Services like SQS, SNS and Lambda are there to support programming the AWS environment, not to build applications with. E.g. you can set up a trigger on S3 that calls a Lambda function that dispatches a message through SQS for the purpose of scaling the environment, or whatever. E.g. I just happen to have inherited a monstrosity of a Laravel code base where all business logic is hard-coded inside freaking controllers, plus that it will only work in AWS because of SQS queues (hard coded endpoints). I can't run the thing in isolation in a local dev environment. In the same way that you should separate your business logic from your framework, you should separate your application from it's infrastructure. I.e. You should run your apps "on-top" of AWS, not "in" AWS. PS: This is not an opinion but a lesson hard learned... 
XAMPP works fine for me.
Vagrant for bigger projects, xampp for smaller. I've been using xampp for years.
Use what works. If at some point xampp isn't the right tool for the job you know there are other options available. You can waste a lot of time chasing the perfect setup when you could be delivering for your clients. I used mamp for a long time but switched to vagrant when the mamp customizations became too cumbersome. If you're not there yet then stick with what's working.
Bitnami doesn't keep their software very up to date sadly, Most of their installers are very old versions of frameworks and crash. Even Xaamp will crash on the latest mediawiki for some really strange reasons, not to mention that their apache and PHP config, even with php7, is incredibly slow. My $5 servers load pages 3x faster than my local xaamp install.
I just set up a couple vms on virtual box install the distro I want and set up a lamp environment for development. That way I can add/remove what I need to. Xammp is OK but it's in a Windows environment might as well work on what it's going to be hosted on and you can knowledge that can be used in the real world.
I've never had speed issues with Vagrant. For medium to large projects the little time to invest into a Vagrant setup is worth it when you get a happy deploy. What specific issues have you had with it?
Don't expect a rational explanation for his subjective preference.
I think it's a different kind of bloat isn't it? Vagrant, does take up disk space, but it doesn't (or shouldn't) ever effect anything in your machines OS. I'm on a SSD mac pro - so space isn't ample - so all virtual boxes Vagrant or otherwise go onto an external drive. But it doesn't feel like bloat. All the crap I have installed via brew, gem, and pip locally feel more like bloat (although they are soooo tiny) because they are polluting my paths and local system. For me the beauty of vagrant isn't "vagrant up", it's "vagrant destroy". 
I'm surprised more people haven't said this. I do it this way and it seems it can't be beaten speed wise. Only thing is I use nginx instead. I also created a module called [dynahosts](https://www.npmjs.com/package/dynahosts) to update the hosts file based on symlinks in a directory.
Indeed. This is the healthiest approach from my POV. After all we are all trying to get things done with less hassle. Whichever setup gives you less headaches, you should stick with that one. 
I see, thanks for the response. Does it make a difference though if I'm deploying to shared hosting (not my decision)? How easy is it to match the production environment in that case? It might also be worth mentioning that some of these sites are so small that they are max 4-5 hours' work, so an hour setting up a local environment is proportionately pretty expensive.
Honestly if your clients are using shared hosting they probably don't invest enough time or money into whatever their business is to care if they have errors, so I wouldn't worry about it.
You should replace "wrong-arguments" by an actual Facebook ID. e.g. : https://graph.facebook.com/v2.6/23456 Then you'd see a more expressive OAuth Exception "An access token is required to request this resource" which hints you at getting a token first. Why don't you use the [Facebook SDK for PHP](https://developers.facebook.com/docs/reference/php/) ? 
When file_get_contents() receives anything else than a 200 (or possibly 2xx) it will return a null and iirc an E_NOTICE will be raised. You can get those notices if you want, but long story short, if the server doesn't give the OK, it returns a null regardless of the content. 
Look into docker. It's even better than vagrant once you set it up correctly.
Small time web developer here. Xampp works just fine for me, anything more specific and you can VM it
file_get_contents is not recommended to be used on URL's, use a library thats meant for it like cURL.
That was only an example of an url which returns error. I know how to construct valid url. I dont use sdk, because I didnt figure out how to authenticate, when I only have token generated by another FB App. It always wants app id and doesnt approve the token then. I use the token to download FB page insights from commandline script. It seems to me SDK doesnt support scenarios where I dont have FB app and connect with only token. 
Vagrant let's you keep the server settings in your source code. If you have to change php.ini, all of your coworkers will receive that change and everyone knows their code will work on the production server. You shouldn't need to send out an email every time you make a change on the server and have everyone else manually catch up to it.
Thanks! I agree and that was the reason for me to create the library. In stead of storing it in a database/file/storage... I thought it would make more sense to have them calculated (rather than stored). Majority of the global holidays are based on some kind of algorithm :)
I use wamp due to how easy it is to set up on a pc. it works wonders with all systems (windows atleast). i have not had much luck with xampp due to how much ram hogging it is. it hogs allot of ram. now i would like to know a alternate to wamp that is good but i haven't really found any that works good. 
this would make it into its own row after 3 to 4 records shown?
guzzle &gt; curl if you want testing. Plus with PSR-7 is best to make use of a library that supports it. I have a feeling curl doesn't directly
this is what it looks like on the source: &lt;div class='row'&gt;&lt;div class='col-lg-4'&gt; &lt;div class='thumbnail'&gt; &lt;img alt='300x200' src='http://lorempixel.com/600/200/people'&gt; &lt;div class='caption'&gt; &lt;h3&gt; &lt;a href='showtopic.php?id=4'&gt;Psychic&lt;/a&gt; &lt;/h3&gt; &lt;p&gt; &lt;a href='showtopic.php?id=4'&gt;Read More&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='row'&gt;&lt;div class='col-lg-4'&gt; &lt;div class='thumbnail'&gt; &lt;img alt='300x200' src='http://lorempixel.com/600/200/people'&gt; &lt;div class='caption'&gt; &lt;h3&gt; &lt;a href='showtopic.php?id=4'&gt;Psychic&lt;/a&gt; &lt;/h3&gt; &lt;p&gt; &lt;a href='showtopic.php?id=4'&gt;Read More&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='col-lg-4'&gt; &lt;div class='thumbnail'&gt; &lt;img alt='300x200' src='http://lorempixel.com/600/200/people'&gt; &lt;div class='caption'&gt; &lt;h3&gt; &lt;a href='showtopic.php?id=4'&gt;Psychic&lt;/a&gt; &lt;/h3&gt; &lt;p&gt; &lt;a href='showtopic.php?id=4'&gt;Read More&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='row'&gt;&lt;div class='col-lg-4'&gt; &lt;div class='thumbnail'&gt; &lt;img alt='300x200' src='http://lorempixel.com/600/200/people'&gt; &lt;div class='caption'&gt; &lt;h3&gt; &lt;a href='showtopic.php?id=3'&gt;Terms of Service&lt;/a&gt; &lt;/h3&gt; &lt;p&gt; &lt;a href='showtopic.php?id=3'&gt;Read More&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;
I personally would choose guzzle over curl even if you're not planning on testing. It's the simple API that curl should have had from the beginning. CURL is good if you're seeking to not use any dependencies, or you want to support any version of PHP 5+ (As opposed to only &gt;=5.5), but Guzzle is better for most other use cases
I don't think you need to worry about creating a new row after 12 columns, bootstrap will automatically but it down below and keep going.
i went ahead and did a slider with bootstrap. it looks better anyway
&gt; compatibility without compromises Don't know is it good or bad.
&gt; almost all Eloquent models will be entities. Nope, Eloquent models are row data gateways.
I suggest using cURL.
Well, you get a better tools that map into a more efficient queries, why would it be bad?
I recommend guzzle for http calls. it has very nice api and is quite powerful 
The [gnupg](http://php.net/gnupg) extension may be what you're looking for.
For testing purposes I have images/vboxes for IE7 thru IE10 from modern.ie - so I'm into the GB's before I even look at vagrant. I literally don't unplug the external drive anymore. In this regard, I prefer to not clutter my own OS, and instead just "go crazy" within the safety net of vagrant 
Looks as if the "primary developer" is some sort of prima Donna. Do what you need to do with the code, and if they get offended it's their problem.
If you want to get an error response body, set the ignore_errors stream context option. http://www.php.net/manual/en/context.http.php $context = stream_context_create(['http' =&gt; [ 'ignore_errors' =&gt; true, ]]); $body = file_get_contents($url, false, $context);
They're also table data gateways. Being AR implementations, they are a LOT of things, *including* entities.
[Don't Use .dev For Development](https://iyware.com/dont-use-dev-for-development/) there is a list of reserved domains that you can use instead _(.test being my favorite)_: &gt; [RFC 6761](https://tools.ietf.org/html/rfc6761) reserves the following four top-level domain names to avoid confusion and conflict. Any such reserved usage of those TLDs should not occur in production networks that utilize the global domain name system: &gt; &gt; [example](https://en.wikipedia.org/wiki/.example): reserved for use in examples &gt; [invalid](https://en.wikipedia.org/wiki/.invalid): reserved for use in obviously invalid domain names &gt; [localhost](https://en.wikipedia.org/wiki/.localhost): reserved to avoid conflict with the traditional use of localhost as a hostname &gt; [test](https://en.wikipedia.org/wiki/.test): reserved for use in tests. &gt; &gt; In addition, [RFC 6762](https://tools.ietf.org/html/rfc6762) reserves the use of [.local](https://en.wikipedia.org/wiki/.local) for link-local host names that can be resolved via the Multicast DNS name resolution protocol. &gt; &gt; From WikiPedia — [Reserved Domains](https://en.wikipedia.org/wiki/Top-level_domain#Reserved_domains)
Sigh. Guzzle.
&gt; They're also table data gateways. [not at all](martinfowler.com/eaaCatalog/rowDataGateway.html). Active Record is simplified Domain Object + Row Data Gateway. Table gateway is DAO, very different thing.
This is the only correct answer. Anyone who says, "file_get_contents is not recommended to be used on URL's", doesn't know the first thing about what they're speaking of, not to mention how to use apostrophes correctly.
This. If @function() throws an error it will always return null because of the @. Edit: Because some people say they can still return other stuff, i am talking about fatal errors that stop the execution not notices or something like this.
In addition to being more "correct", in my experience, curl is **much** faster than file_get_contents for HTTP. I used to be lazy but when I saw the speed benefit, I never looked back. 
When building apps, say we have a User object, User can have one or many roles. Permissions can belong to one or many roles. What's the best approach to verify a User has access to a certain permission? Should I load all permissions when creating the User object, or just make a SQL query to determine for each time I check for a permission?
I did something like this recently, let me get back to you on Monday as to if my solution fits with what you're trying to achieve. 
don't use php ( ͡° ͜ʖ ͡°)
I've installed xampp, but never made much use of it as it was similar enough to mamp, which I used before vagrant. For me, the biggest reasons to switch to vagrant had less to do with my site code per se. It was more the server as a whole. A lot of developers use dedicated servers, vps, ec2 or other cloud solutions where you have complete control over everything. When you need to upgrade php or make other changes. Sure you can switch the version in xampp. You can't actually go through the live process and see how your environment reacts to it. If you're using shared hosting this is less a concern. 
Static cache! It depends on the application, but since I'm a Drupal guy, I can comment how we do it. It doesn't have to be Drupal or even PHP specific. We have roles, each role has a set of permissions, and each user can have multiple permissions. The list of permission we have are boolean values, whether a specific permission is allowed or not. Now, note that this is not the only access systems you'll need. For content, you will need different kinds or acess restrictions because there are additional contexts. For a simple permissions system, load the permissions list for the roles the logged in user has, and merge them. You can then statically cache the results. 
GPG is huge on the whole keyring rigmarole. If you have the public pgp key, you'll need to [import](https://secure.php.net/manual/en/function.gnupg-import.php) it to the keyring and get the fingerprint from the import process, then choose that key as the [encryption key](https://secure.php.net/manual/en/function.gnupg-addencryptkey.php) using the finger print returned from the import, then [encrypt the message](https://secure.php.net/manual/en/function.gnupg-encrypt.php) EDIT: also, per the `gnupg_encrypt()` comments, you need to set the `GNUPGHOME` environment variable to someplace readable/writable by PHP for the keyring file to go.
Exactly, you will most likely spend 2-3 years on that project... Just stop and do something uncreated or improve existing library. You don't see engineers deny the utility of for example computers and say nop, I dont trust computers, let me reinvent the way computer works. 
I have only used "ORM" in the title, because that is where I started my research a month ago. There are some similarities with object mapping, but the concept is certainly different. I'm using "Agile Data" throughout the document. Actually I am having difficulties comping up with a catchy name too. The actual implementation of the concept and interaction with the database shouldn't raise too many problems for me to implement. I have built a DAL with a similar concept in 2011 and it's been pretty good and users of my full stack framework loved it. I wanted to refactor and create a stand-alone mainstream framework for data modeling. I couldn't understand your point about "coupling with data layer" and how this lock me up in a DB-driven design. I did omit the mapping part of my concept as the article was already getting large, but I'd like to know in more detail what kind of problems you think I might have there. Currently I'm anticipating ability to either split up domain models into multiple tables/collections (joinable) transparently, substituting and changing fields in persistence logic before it hits the database, but maybe I'm not thinking deep enough. Can you please share some examples of a typical problems in this area? I will really appreciate more feedback from you.
That @ sign is a definite code smell. Never use it without implementing your own error handling. Or better yet, never use it. http://php.net/manual/en/language.operators.errorcontrol.php
I wanted to like Bitnami, but for some reason it kept caching my pages and wouldn't update when I reloaded the browser page, whereas other server apps worked fine, so I just gave up on it in the end.
A couple of interesting ones that we have on at the moment are developing a mobile ad delivery network and a professional development portal. Not to mention the usual mobile apps, etc.
Really depends on your setup. But my guess would be to use memcache or some variation. Plug that into your wrapper for database interactions and set the timeout. 
You must import the key first and then encrypt. You cannot encrypt with an "anonymous" key
&gt; If you throw an error the interpreter stops the execution of the code Unless it's an `E_RECOVERABLE_ERROR` or you have a weird error handler, errors do not stop execution. If a function returns after producing an error, it has done so explicitly.
[removed]
hm what you mean? cause there is no html within database queries and extra php code. 
It's absolutely possible to encrypt a message with just the public key of the recipient. In that case you don't have authentication (signing) though.
cURL is a library every dev should know how to use, its universal and gets the job done. But yes, there are better libraries out there for API requests.
Do error handlers still work when you supress with @? Other than that i now made an edit to my original comment. Errors are fatal errors to me and Notices are notices. Sry for that.
Typical caching methods will involve saving stored cache to disk, pretty much giving you the same problem of disk access. What you're looking for is something along the lines of [Memcached](http://php.net/manual/en/intro.memcached.php) which is essentially an in-memory object cache. If you want to use newer tech, learn about Redis, though it may be overkill for your projet. 
There's no simple, trivial, drop-in caching mechanism like you want. MySQL (and I assume Postgres and others) has built-in caching for some stuff, so if you have a small amount of data it won't have to hit the disk at all. I don't believe sqlite offers that. If you add an ORM on top of your database access, many of those offer various forms of caching, but you're adding a pretty significant amount of probably-avoidable complexity to do that. Unless the page is quite high-traffic or your queries are completely garbage, it probably won't matter either way. If you're currently running it off a home server and intend to keep it that way, I'm assuming it's low traffic. For what it's worth, there's almost certainly disk access *already* every time someone hits the page. Moving the data from your source code into a database just changes which part of the disk is getting hit.
Here are some things I would critique. **Dependency Injection for clarity** Overly technical name, but basically it means if something depends on another thing, pass the dependency as an argument rather than pulling it out of thin air. public function __construct () { $this-&gt;config = parse_ini_file($this-&gt;ConfigFile, TRUE); $this-&gt;setDatabase(); $this-&gt;setClient(); $this-&gt;setGeneral(); } The problem here is in a few places, but let's start with the constructor. It is parsing a config file, which means it depends on this to continue, however it's not being sent through the constructor at all which makes it ambiguous at a glance what's going on unless you read through the code. Best practice would be public function __construct($config_path){ $this-&gt;config = parse_ini_file($config_path,TRUE); // etc } and somewhere in your code : $path = "/path/to/ini_file.ini"; $config = new Config($path); That being done, you can then loosen the tightness (known as "tight coupling") of the $this-&gt;config with the rest of the functions, like setClient and setGeneral can now look more like public function setClient($name){ $this-&gt;client['name'] = $name; } and use it in the constructor like $this-&gt;setClient($this-&gt;config['client']['name']); I know it seems like "who cares, why bother when I can just refer to my config?", but it's because you may change this at some point and if everything depends on the $this-&gt;config at the function scope,you have to track down all instances and change it. Also for "at a glance" clarity. **Naming Conventions, be consistent!** In the first chunk: private $eh; // potential to bite you in the arse later private $conn; // mostly obvious what it is, but just follow through with "connection" private $table_prefix; // Good private $col_prefix; // continue with consistency, use "column_prefix" Also your function names (to follow naming conventions) should be camelCase rather than TitleCase , similar to your latter object. Verbosity in variable names are ok, so long as you don't go overboard eg: $shp_crt // ?!?! what could this be $shopping_cart // is fine $sessionBasedUserShoppingCart // gtfo Let these also start with lowercase private $confg = []; private $Client = []; 
Perhaps you should update your original post with that additional information. It might help others understand what it is you are trying to accomplish. As for premature optimization... you are still doing that. Trust me. But hey, it's your time. Do what you want with it.
&gt; The thing is, every time someone accesses the webpage, there will be a DB access. Since this is my home server, I want to limit that. Why not totally remove it and just use sqlite? You've already said it's not a lot of data. If you're going to cache database elements then you're already going to be using your disk to store the data. So cut the server out of the equation.
For now , but what will I do when I will be putting it online. I am new to thisn
Piggybacking... An example would be to check if a user is authenticated, or to convert POST JSON data to a request object. It is something that will likely be reused throughout your application on a lot of requests.
Ecommerce is good for money but it's a pain in the ass. Maintenance of legacy systems (also very good money). In the end though it's mostly all the same it feels, it's just a different scale at which the stakes are higher and the work is more complex but it also gets a lot more fun.
For most use cases, Memcached is awesome, and all you need. If you require more persistence options (RAM + save to disk), or complex data structures, then Redis is very handy. Both are solid projects, memcached performance is very stable since little is being changed on it these days.
Generally-speaking, using __get() and __set() in place of traditional getters and setters is considered an anti-pattern outside of fairly specific use-cases. They make it impossible to fully enforce an interface and can make debugging more difficult. I'd stick with defined getter and setter methods, even generic ones like get($key) and set($key, $value). Apologies for the lack of formatting, I'm on mobile.
The only sane answer so far. What the OP needs is just mysql instead of a monster combined from sqlite and memcache.
And possibly reused *between* frameworks, since it'll be compatible with any framework that supports PSR-7.
With PHP frameworks, there is a bit of work going on before you can respond to a request. One is parsing the HTTP request body to JSON-decode it -- this is relatively straightforward, and, when your code gets a hit and you can work with the request, it will have a JSON-decoded request for you to handle. The `middleware` did this -- it operates between your code and the initial request. If the JSON parsing fails, the middleware will automatically return an error instead of passing off the request to your code. Another kind of `middleware` is authentication -- checking cookies. If, for example, the user tries to run an HTTP request without being authenticated, they will be automatically redirected to the login. This is the purpose of middleware: before running your application code, check something. It may be request body parsing, it may be authentication, it may be anything.
Man, someone gotta tell you that. I created my own mvc 4 years ago, spent something like 1 year on it. It was extremely good practice, but now I just use symfony. I didn't want to discourage you, just redirect your effort towards something more useful to you. 
I am not OP, but I find your constructive criticism very useful, thank you.
Well get/set magic methods perform somewhat slower and I agree using them without a specific use case is bad. Generic get/set() methods are something I'd avoid because that completely eliminates the use of visibility modifiers. It also makes it harder to use autocomplete and complex setters ( like $this-&gt;data[key][other_key] = test ) will be hard to use because you can't really merge stuff with them. Individual setters for each property makes sense. A global get/set(), not that much. 
This is all really good feedback, thank you. When im back at my desk im going to go through them in detail. Ill also be upvoting all constructive critiques 
A lot of the techniques described in this thread can be found on http://www.phptherightway.com; you should have a look, it's an excellent guide.
I would load permissions with the user object in the same query (using some kind of join). 
In such case you could generate a static html page and rebuild it on update. Nothing is faster then that. Second option: Use a mysql memory table and save/load this small portion of data. This is a very fast cache without more complexity and standard sql.
It will be faster to use array_walk_recursive. It may be clearer to use RecursiveArrayIterator
Thank you for that detailed explanation. I really enjoyed 👍
what are you currently using?
And since we're talking about OOP practices: function foo (SessionBasedUserShoppingCart $shopping_cart) :)
Ah, actually now that you mention it... I don't think so. It's early here. :D
&gt; Is it better than PHP builtin server? It *is* the builtin server. 
https://github.com/StanAngeloff/php.vim/blob/master/syntax/php.vim
Atm Exceptions are PHP's poor man solution for not having method overloading. But in general in your first example where you 'log' the error to "$this-&gt;errors[]", you're leaking implementation details to the outside world. I need to know when consuming your API that it will not return the actual errors when something goes wrong. Instead I'm forced to do something like `getErrors()` to retrieve them. Worse, your errors are public so anyone can accidentally overwrite them by doing $this-&gt;Usermodel-&gt;errors = null, at which point I never get to actually see the error. Exceptions suffer none of these issues. They bubble up to all your (indirection) layers until handled. In a framework this usually means that the framework has a catchall handler that will show a nice 500 in production, but will show a nice stacktrace in dev. Without having to write any code! Furthermore any consumer of your API will immediately get feedback when something breaks. With the actual reason why it breaks. Now he can choose to handle that, or he can choose to not care. Lastly as other have pointed out, since you can throw specific typed exceptions, you can simulate method overloading, by handling every type of exception differently depending on the severity of the exception. 
Even better! Nice find.
As an aside, if you ever hear anyone pluralise "middleware" as (brace yourself) "middlewares", you are legally allowed poke them in the eye. In some territories you are even _required_ to do so. Fun fact.
So is middleware like hooks within WordPress? You are essentially tying on new functionality without touching original source.
Not necessarily. Remember, PSR-7 is the standard for Http messaging, which gives us the Request/Response Interface that is used here. It does not dictate the middleware signature that is being used, which can be different between frameworks.
At a really high level, middleware is a way to implement cross-cutting functionality within your application that handles a request or response in some way. It exists to allow you not to have to stuff unrelated features into a base controller (thereby reducing cohesion) and to prevent you from having to implement the same functionality in multiple controllers (not DRY). Good candidates for middleware are features like: - Logging. - Authentication and Authorization. - Caching. - Serialization. - Compression. - Error handling. 
Please any help ?
The "drop-in" solution to your problem is to use an opcache which would require zero code changes (unless you need to modify your code to bring it into the 5.x era but you should do that anyways). In fact, if your code is Php 7 compatible then simply installing it would do the trick since the opcache is built in and enabled by default. Plus you'd then get all the other massive speed benefits of PHP 7.
Doesn't sound like this app has a very healthy culture between the devs if you're looking to go through this much work to hide ideas.
You can create the database at your local maschine using phpMyAdmin and then export it into SQL code, which can be loaded by an php script. The SQL code will contain all the table constructions, settings, and contents from your phpMyAdmin. 
The error handler is actually very robust. I wish I could share it, but like I said it isnt mine. It interfaces with PHPs error handler but it also allows us to log our own application level errors should we choose. Includes error log file handling as well.
Ill definitely look into PSR Standards. Im fundamentally opposed to frameworks. Its a personal preference. While I will look over them to learn ways of structuring OOP I dont think Ill be using them.
You use a "database migration" library. If you are using an ORM then it might have support baked in. If you aren't using an ORM because you don't know about them, get to a point where you are comfortable with SQL, then look at Laravel and Eloquent to get the idea.
Have you looked at Monolog? https://github.com/Seldaek/monolog Imho an logger and an error handler are 2 different things :-)
Not "against" it per se. Just a matter if I feel I have the energy to maintain it.
[Phinx](https://phinx.org/) is a pretty awesome way to handle the database without the complication of an ORM.
Short Answer: leftpad Dont get me wrong, I understand and recognize the purpose of frameworks. If your just putting a blog together, use blogger or wordpress. You dont always need to reinvent the wheel. I dont think that core code should rely on something that you dont control or potentially fully understand. Frameworks are often created to solves certain problems by dealing with repetitive or mundane tasks in a specific way. The way the framework solves handles these tasks might be great for someone doing thing A it might not lend itself well to how you would do thing B. Honestly I think my personal preference really boils down to something outside of the technical and delves more into the social/personal level. Like I said Ive been writing code for a long while (yes i know i should have learned OOP a long time ago but being self taught I stuck to what I knew for too long) and I have come across far too many "programers" who only knew how to work in specific frameworks. To me if you only know how to work in Framework X and you dont know how to write code in the language that Framework X is built on; then your not a programmer, your a framework drone. Again this is just my personal opinion, its not meant to insult anyone, its not meant to insight a riot. Person who only knows Framework X = Construction worker Programer that understands the underlying language = Engineer the construction worker puts the pieces together in the limited number of ways the pieces will allow. The engineer is able to create his own pieces that will fit together however they want. The engineer also isnt going to have their project blow up when someone redefines how those pieces should work or fit together. Again its just my opinion. I dont have anything against people that work in frameworks. I dont think less of them (as long as they understand the underlying language) as programmers. Its also been a while since ive investigated the frameworks that are out there. My opinion may be based on old information and maybe things have changed and I need to reevaluate my opinion.
I have to say, Im blown away. You have all been really cool. You are providing constructive criticism, offering conceptual feedback all without being dicks. Ive posted in other places on the interwebs before, asking for help, or feedback, and most of the time I get really dickish answers. You have all been great. I think Im going to be spending a lot of time here. 
Thanks. I think I sort of understand the idea but can't imagine the code (I'm still stuck in php4 purgatory). I can see this being used to secure an administration area or something like that but not much else. It would only really work on a frameworked site that has a single entry point right? Not a typical older site where each php file is its own entry point unless you copy the same code to ever file.
&gt; having to implement the same functionality in multiple controllers (not DRY). I thought that was what traits were for.
Technically you could with an older multi-entry point site, just need to include the middleware stack I whatever `init.php` or `bootstrap.php` you include in your entry scripts.
Mobile ad delivery network. That's very interesting. Bet that has raised your profile a bit.
This is what I am thinking is the next step, it is a big leap though. Did you guys higher people specifically to work on apps with Java/Swift knowledge, or did your devs just learn how to do app development?
This is interesting, because, at least in my area, I don't really see any of the other agencies advertising e-commerce or maintenance solutions. Can you elaborate what is so bad about e-commerce?
heh heh, assuming every entry point consistently uses the same bootstrap code... :'(
&gt; My opinion may be based on old information and maybe things have changed and I need to reevaluate my opinion. I think you hit the mark there. The first part sounded to me like NIH syndrome, but I understand where your sentiment comes from: up until a few years ago, most framework forced you into working a specific way. Those days are long gone. With composer and re-usable components, the era of framework-less frameworks has begun. Basically nowadays everyone kinda just puts all the stuff they want together, and in that way create their "own" custom framework. Then there are minimal approach frameworks (so called micro-framework) that just give you a bare minimum skeleton, and take away the tedious job of wiring everything together (take a look at [Silex](http://silex.sensiolabs.org/), [Slim](http://www.slimframework.com/) or the fancy new middleware approach called [Expressive](https://zendframework.github.io/zend-expressive/) The question begs: what to you defines a framework. Most micro frameworks are basically: - a Router (map url to X) - a Request/Response handler (using the SF2 HttpFoundation or the PSR Interfaces all the frameworks that use this can basically work together... kinda) - a Dependancy Injection Container (if class needs Foo, give it Foo) It doesn't get more bare metal than this most of the time, and tbh writing these are tedious, so why re-invent the wheel ;-)
This is really good to know. I think while im breaking out of my procedural methodology comfort zone ill start taking a look at some of the frameworks that are out there
E-commerce isn't bad by itself but.. - the requirements can be quite stringent, and the clients will almost always want what's not supported by default. - There are often issues on caching (\*mostly WooCommerce) or server resources. - Magento is the big one, it's "nicer" to the extent e-commerce platforms can go. None are really pleasant to work with. - There is a big need to accompany the client with their platform, and when sales didn't sell a support package it's very troublesome (**don't**). - Sometimes we'll also do custom platforms for very specific needs, and you need to have at least one person who's pretty good at understanding the payment gateways and processes (it's not impossible to learn though you just gotta be really careful, and Stipe for e.g. have really good tech support for example). - Also if you have a bug in the payment process, people will get really angry, understandably. - Unless it's just theming basic install, you'd also need to have people who are **at least** intermediate level and finding good programmers is hard. A lot of places just hire any kid who can write "echo" and move tags around and call them programmers, and we've had trouble in the past delegating this kind of work (spec compliance, bugs, awful code organization, etc) because once they couldn't find the answer on Google, they would just complain it couldn't be done and we knew it could, we just didn't have the time. Though I'll admit this is true for pretty much anything in programming. - Sometimes we try to use plugins when doing lower budget web shops but the quality is often real bad, even official ones from places like WooCommerce. That said, once you get good at it, the demand is really there and the income is very, very good. We do advertise e-commerce solutions on our website, it's in the first things you see. We don't advertise support but people know we do good things so it comes in.
Here's a little library I've been working on, to calculate the differences (and their boundaries) between images. Keen for feedback...
oh i'm sorry i didn't write the name of the script https://github.com/shofhna
Maybe eventually we will get typed tuples (and pairs) etc backed by arrays.
I have not kept myself updated with RFCs. How often do these RFCs pass with unanimously?
Not sure but 41 people agreeing on something unanimously is usually odd I would imagine.
I secretly disliked this one personally. However, the other way to "return" multiple values is the pass extra empty variables by reference. With those two, I would prefer the former. 
OPs probably creating a shareable code or just wants to have multiple running g instances. 
You'd probably want to include an example script of how the zip file is created. 
For a web company I would recommend hybrid apps first. There is a better crossover of skills. I've recently moved to Ionic apps and the required skill sets compliment my web skills very well.
Ooops... sorry my bad, the script currently looks like this : if($pack == "pack2") { $zip = new ZipArchive; if ($zip-&gt;open('./download/RCF.zip') === TRUE) { $zip-&gt;addFile('files/pack2.png', 'pack.png'); echo 'Added Pack Icon (pack.png) variant : pack2 &lt;br&gt;'; $zip-&gt;close(); } else { echo 'Error adding Pack Icon (pack.png) variant : pack2 &lt;br&gt;'; } (Took out the variables being loaded and stuff as the list is quite big and well, it does work but as i said the name of the .zip stays the same which is the problem.)
next step: destructuring with spread! (I hope)
Another way to return multiple values is to create a new type for the tuple of values. Also, if you're returning more than one value, you're probably doing too much in one function.
I think there are a lot of people in the community who are willing to help (me included). I see there's one pull request already which made reasonable changes. The thing is, this stuff won't change any time soon on most distributions. 
Not too often... RFCs often pass with large majority, but get something up to like 10% downvotes. It's just as rare as having a RFC pass with a very close result.
Users of my Laravel 5.2 app often leave the app open in their browser for many hours. The session expiry is set to the default 120 minutes. If a user leaves the app open on the login screen (or any screen with a form on for that matter, but almost always the login screen) they when they submit the form a CSRFTokenMistmatch exception is thrown and they get the grey "whoops!" screen because the session has expired since they loaded the page. I don't want to disable CSRF protection on any routes, so I'd prefer another solution. After some research, the most appealing option i I've seen so far is to do an Ajax request every 90 minutes or something, which stops the session from expiring. What I'd like to know is if there are any security implications of doing this? I'm not an expert in CSRF, so I want to be sure that Ajax polling isn't going to somehow invalidate the CSRF protection. One other solution was to catch the CSRFTokenMistmatch exception in the exception handler and redirect with error message "your session has timed out". My issue with this is that I don't really want that to happen when there is a genuine CSRF mismatch (I.e. someone is trying to hack the site), in those cases I think the grey whoops screen is fine. Alternatively, I'd be interested to hear any other solutions you guys suggest?
It seems like a very different thing. It's still comparing derivatives of image files, but that library creates a fingerprint of images (using very different methods) and measures the distance between them. This library just does a straight bitmap comparison and de-noise. If that one is what you're after use it. This was just abstracted out of an integration testing library I'm working on, and it suits my needs perfectly (especially with the intentionally limited public API). Edit: I just want to stress - the intention of that library appears to be to match as closely as possible two potentially-matching images. This one is intended for you to be able to compare two images you know are the same, to find small differences.
We're still writing the functional and technical specifications at the moment. But the scalability will certainly prove to be an interesting challenge.
Maybe just a class at this point.
The main thing is to compare screenshots during tests against baseline images, to detect UI changes above a percentage threshold. "Is this screen within 2% of the ideal interface? If not, draw a red box around the changes for review"...
Ah right. That sounds really cool. I think this could be useful for me down the track a bit. Starred for later. You should put that example in your readme too. :)
I created my own framework 14 years ago, now over a several thousand developers use it even though I haven't promoted it much and it has been under an awkward AGPL license. We all love it and want to make it easier for more developers to try by modularizing it and you fault me for trying?
That is actually quite easily implemented if you have a language with proper inheritance and leveled patterns. I've done such things with Java where you could inherit certain methods from an abstract class to implicitly do the job (Like cache invalidation of objects after applying changes to such). As relatively new PHP developer I find it quite hard to pull off such things out of the PHP context (server side)
&gt; I thought that was what traits were for. Nope.
Thanks , dlegatt but if you saw the script folder there is a missing of the vendor file and i don't know where i can find it 
I see a lot of hostile reactions here. I'm not sure why. It seems like an interesting concept. Ofcourse if you know SQL perfectly, then that will always be more versatile/expressive. Except when circumstances force you to switch to a NoSQL system... As for ActiveRecord, I believe there are more than enough well researched and thoughtful articles online about the problems inherent with them. If you haven't read these yet, please do so before you dismiss alternatives out of hand. I myself have long struggled understanding why programmers used ORM systems, untill I finally understood that most people see 'ORM' as anything that helps you to avoid writing SQL directly. In that sense, what you are proposing is an 'ORM'. To me this looks like a much more explicit way to get the ORM benefits, while not tying 'objects in your code' directly to 'records in a database'. So this would help those developers who don't want to learn SQL, while preventing the major problems with ActiveRecord style ORM's. Please continue :)
&gt; How does this fare for Frontend developers and Editors? Right, and since the other thread, we've added a WYSIWYG editor (for Editors) and we're working on the parts that allow frontend developers to create themes (for Implementors). We're using Twig as a template system, to example. This post is simply about how we're securing the "share your own themes and plugins" component. The idea is simple: We take care of the security at a fundamental level so the community doesn't have to sweat these details. Use the APIs we give you as intended (which will be documented) and you should be golden. Make a mistake, it's fixed worldwide within an hour. &gt; "Secure" means nothing, if people can't use it. One of my friends who specializes in front-end said, "Your UX is fine, your UI is shit. It needs to be pretty." I'm not sure "people can't use it" applies here.
I don't get it. You USP is security? Top be honest, to sell a CMS security is one of the points people are least interested - I wish it'd be vice-versa. Also, throwing a WYSIWYG editor at it doesn't make it automatically good for content editors.
&gt; Also, throwing a WYSIWYG editor at it doesn't make it automatically good for content editors. You're right, it doesn't, but there is literally nothing else I can say here that will convince anyone that it's "good for content editors" without actually trying it. * In additions to categories and tags, we have the built-in capability to create [series](https://github.com/paragonie/airship/blob/master/docs/en-us/5-Minute-Overview.md#series). * Our custom page system is smooth. * We've strived for "simple and intuitive" everywhere we could. But nobody cares about these things.
FYI, You are not running Debian, but a FrankenDebian. I wouldn't recommend that to anyone. https://wiki.debian.org/DontBreakDebian#Don.27t_make_a_FrankenDebian
This is the message that i get https://suar.me/MBq0
opcache doesn't cache the output of the page just the content's of the original PHP file. meaning that if you are dumping 1MB of data into your page, opcache doesn't care about the 1MB of data.
I haven't encountered too many ppl that recommend memory tables, but they are most certainly awesome when you have a proper use case.
I currently use https://github.com/spf13/PIV.
Ambitious. Some organizational comments: - put the "base" and "vendor" directories in a "src" directory, so the code is not at the top of the package - create a namespace for yourself and put the classes in that namespace, instead of in the global space - add a composer.json file and set up autoloading through it, instead of using require-once 
[removed]
Didn't I say just that?
What would be the main point to fake installs on packagist? It doesn't really have top 100 or any other kind of list where you would be able to self promote yourself this way
For all I've heard of PHPixie here (mostly due to /u/dracony's posts), I've never actually heard of or seen PHPixie anywhere else. I mean, there was that minor controversy over the logo a while back (Which is kind of weird, since PHPixi was already v2 or v3, and it was the first time I'd ever heard of it. Not exactly a major player), but other than that... eh? I feel like if /u/dracony didn't post, I'd never hear about the Framework ever again.
AKA an attempt to become 'relevant' in the community.
Hi, if you are still interested, there is a small blog post about the include functionality http://blog.peachpie.io/2016/05/working-towards-php-interoperability.html. We'll of course prepare detailed documentation once we finish the conceptual part of the project.
Wow. That's a hell of a takedown.
PHP PIXIE RULES!
Credit where it's due, he's trying *really* hard to become relevant (without actually addressing any of the concerns with his project nor his discourse).
Creating alt accounts to upvote your own posts goes against Reddit's rules. He should be banned from Reddit entirely, not just from /r/php. Isn't that what happened to Unidan?
Thanks, i will take a look :)
&gt; Packagist does implement some protection against this type of fraud. I am not going to go into detail about what this protection is Is there a link to read about this somewhere?
That's really something that it should be up to Jordi to share. I'd approach him individually if you're interested in that.
Except a botnet fits perfectly with your past actions and personality and previous behavior. You have all the credibility of a North Korean spokesperson. Actually I might trust the North Korean mouthpiece more.
I have only one project that has over 100,000 installs, according to Packagist: [random_compat](https://packagist.org/packages/paragonie/random_compat) (for obvious reasons). Upon reading this headline, I suspected maybe Continuous Integration was the culprit. However, given that the spikes occur rapidly at about 2 AM, that's a smoking gun that *someone* is trying to keep the numbers inflated.
pff sure. There's really no 'points' since 3/4th of the post is a recap of his previous hunt. The only point he has is that the graph spikes at 2 am, which can literally be anything. Ofc I can't say that there isn't some dude trying to help pixie with popularity (I honestly haven't checked the packagist graphs for a bunch of months), but again it doesn't mean that I'm doing anything with it at all. Tbh if I did do smth like it I'd be smart enough to spread it out with a simple sleep() call, really. 
The graphs don't spike at 2am. That's the only time where's any activity, the rest are just flatlines. Downloads go from 5-9 to 1500-1900. That's almost like if something was programmed to make installs at those specific hours...
Did your post get removed from /r/php's front page?
You're the one who's fucked. In the OS world your most valuable currency is credibility. Consider yours destroyed.
I would have thought in the OS world the most valuable currency is contributions.
&gt; I'd be interested to get a look at the data from the SitePoint framework survey! :p All up [on Github](https://github.com/sitepoint-editors/php-fw-survey-2015).
I agree. PHPixie came out of nowhere, had no sponsor (at first), and had been denied once on his application. Hopefully, folks at PHP-FIG will be more careful on sponsoring/voting on unknown people from now on.
A very interesting analysis.
[removed]
A very good point....I think people rely too much on the "popularity" of a library as a selection criteria for the tools they pick for their stack. While it's a nice contributing factor and can help weed out some of the lesser used, less mature projects out there it should stop there. Picking something just because it's popular is a bad idea. Evaluate your tools before you make a final choice (you *do* review the source of each library you use....right?)
&gt; It's like watching an extremely entitled, angsty, teenager try to convince his peers that he's cool enough to hang out with the seniors ha. I wouldn't cast him in that light, personally. It might lead a lot of junior devs to identify with this edifice of /u/dracony and feel like they'd be afraid to contribute for fear of retribution from the in-crowd. The PHP community isn't like that at all.
It's not as bad as some framework, it's not as good as others, and replete with NIH-syndrome. Most of the components are knockoffs of other framework implementations with its own idiosyncrasies thrown in just to differentiate it. And it's constantly redesigned to (poorly) adopt whatever the latest fad in design principles seems to be floating around /r/php that month. In order for a framework to differentiate itself from the Laravel/Symfony/Zend troika it will have to take a relatively creative track at tackling the core problems frameworks are meant to solve. There's only so many meaningful ways to spit out HTTP responses.
As a developer, I want to know that my dependencies are supported by an active community. As an OS developer, I hate the fact that nobody uses my stuff (possibly just because nobody uses my stuff - chicken and egg). I think the solution is to try and solve unique problems or problems in unique ways - not this.
On one hand you have to admire the guy who worked hard on his framework and even went one (or more like 10) steps further, despite feeling that inevitable guilt to promote his project (which is actually not bad imho, minus the name) but on the other hand, it's way more important and effective in the future to listen to peoples' feedback if you want to get more attention, and turn some heads around. Which /u/dracony sadly failed to recognize despite being told to change the name many times. No one is going to find a serious employer as a certified PHPixie developer. Anyway, I think it's better to stop now, and PHPFig should remove dracony to maintain their [standard whatever] until he earns the right to be there, which I'm sure he will, and I would support him *then* for the reasons I mentioned first. 
Please refrain from making this personal.
I like your work, but stop the stupid "name something according to a weird-ass steampunk theme" thing, please :)
You're pragmatic, I can respect that. 'Tis not the man and all that. But you have to admit that, at some point, the devs will all need to apply some sort of denial or blind-eye to these shady strategies. When you have TONS of options to choose from (like it's the case with PHP frameworks), why even bother trying to figure out if phpixie is good or bad? The egg's rotten. Done. PS: Also, no one asked that question because that's not the topic here.
It must be said that there were some hilarious fake fake PHPixie sock-puppets (e.g. /u/WowDraconyIsAwesome) created after the original post.
What do you use now?
i would say that at this point "honesty" is more of a factor then stats.
There may be no I, but if you're not careful you can get suckered. Well, sucared.
It's **PHPixie**! Where's this bot's repo? It needs a PR.
I have considered your recommendation. I accept it. I'm tied up at the moment on some gigs, but will work this in within the week unless someone forks it on Github and does it first. (Of which, I would review the fork and merge it in if it is functional.) 
Composer if life. Without it we are lost.
Which is why CI configurations should disable Composer's [notify-on-install](https://getcomposer.org/doc/06-config.md#notify-on-install). 
[And nothing of value was lost](https://github.com/PHPixie/Database/blob/master/src/PHPixie/Database/Driver/PDO/Query.php)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/subredditdrama] [PHP developer fakes 95% of the installs of his framework and uses bots for Reddit &amp; Github promotion, yet is a voting member on PHP's standards body](https://np.reddit.com/r/SubredditDrama/comments/4ikuua/php_developer_fakes_95_of_the_installs_of_his/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
its inception trolling.
[The images are still being worked on](http://i.imgur.com/RU4WOFG.jpg) Launching LaraCon 2016.
I disagree, what matters it the trend in install count, not the actual number. If stuff gets used, be it by CI or not, it still is an indicator that stuff gets used. If it's used more than last month, great. If it's less then it's slowly decaying and maybe not so trendy anymore. But whether it's 50 dls or 50000 it doesn't *really* matter, as that highly depends on the domain you're looking at. When you look for some edge-case lib you aren't going to find one with a gazillion downloads, and that's ok, it doesn't mean they're all crap.
the difference is that he posts packages and lets people talk about them. You and /u/dracony post that framework and then use puppet accounts to vote it higher. 
The data in any inline strings or constants is cached along with the byte code. Edit: added the word "inline" to clarify. 
how the fuck many puppet accounts do you have?
Since I was bored, I collected the data about how often each of the stargazer surnames which was also in the linked faker really occures in the US based on [this list](http://www.census.gov/topics/population/genealogy/data/2000_surnames.html). * Schimmel: 2811 * Waters: 65817 * Anderson: 762394 * Wehner: 3045 * Braun: 32676 * Koepp: 1750 * Spencer: 134443 * Rowe: 66205 * Oberbrunner: &lt; 100 * Mosciski: &lt; 100 * Roberts: 366215 * Connelly: 22747 * Fahey: 9118 * Predovic: &lt; 100 * Hodkiewicz: 160 * Beier: 2631 * Rohan: 2612 * Cartwright: 21654 * Hessel: 1233 * Labadie: 1774 That's about as much as I wanted to check. Note that **every single name** on that list is in the linked Faker, but some of them are really, really rarely in the linked database - note that the mean occurence of each name is roughly 1596 times, the probability that there are some with as few as under 100 occurences is really low.
oh the plot thickens.
huh?
happy cake day friend!
If you mean sharing hosting companies they may operate in a variety of possible ways: * Share the servers resources (CPU, RAM) within virtual machines running inside * Have a pre-installed sharing resources tools like WHM with cPanel, for what I recall everybody has the same MySQL server for instance and they can manage PHP versions through CGI. Scalability in either of those scenarios is nearly impossible. For that you have to have control of the servers machine to either vertically do it (more memory, more CPUs) or horizontally do it with more machines running. 
So if I fill a variable with data, e.g. from a POST request, the variable will also be cached? Could you send me a source for that? Because I tried to look around, and I didn't find anything. Especially with OPcache being a default in PHP7, wouldn't we hear a lot more about database caching problems, where users are shown incorrect data?
Many of our projects (e.g. Pharaoh, ASGard) were named after ancient religions and mythology, as a jibe at the seeming-arcane nature of infosec and cryptography. Halite is a sodium chloride crystal (libsodium is a NaCl fork). We try to make the names meaningful. Keyggdrasil (an Airship component) is basically a pun. The only thing that is named steampunk-esque is our CMS.
I meant more along the lines of the inane class names in your CMS. Barge, Continuum, Gears. . .wtf? I hate themed class-naming, it makes reading the source an exercise in semantic juggling.
Well, I happen to like our naming scheme. We'll have to agree to disagree on this. :)
True but it's clear he does't even understand what he's asking. His *end goal* is simply to lower load and response times as implied in the original text and explicitly clarified in his other comments. 
Source? Edit: Actually he does say it should be in a database but doesn't say why. It's also clear that speed and avoiding disk access is his priority. If he wants the info in a DB, then great. He hasn't given a reason for it.
\o/ because Slim should have some comments :)
&gt; I have a prehistoric webpage I created way back in like ~1997 when PHP was brand new. The page is basically a list of information which I would update every so often. The page itself is as crude as can be. Something like: f1("info1", "info2"); f2("info3", "info4", "info5"); f2("info6", "info7", "info8"); &gt; within the body of an html page. Twenty years later, I would like to do this the right way. The information should be within a database. Sqlite maybe. &gt; The thing is, every time someone accesses the webpage, there will be a DB access. Since this is my home server, I want to limit that. Does PHP offer some automated caching mechanism that I can use? I'd prefer to cache the data to circumvent sqlite disk access, but wouldn't mind caching the entire page to achieve the same purpose. &gt; What tools can I use to circumvent disk access via caching for info stored in a DB?
Why do you keep saying "our" and "we"?
oh nice.
Presumably why Debian and Ubuntu have : /etc/cron.d/php5 or /etc/cron.d/php for some time..... (Obviously dependant on the app not having a custom session.save_path).
Yes, Slim really is a nice project.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/subredditdrama] [Prominent \/r\/PHP developer responds to claims that 95% of his library's installs are fraudulent and that he uses bots for its reddit and Github promotion](https://np.reddit.com/r/SubredditDrama/comments/4ilgr7/prominent_rphp_developer_responds_to_claims_that/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It's interesting to know that Reddit itself was raised in this manner, by faking accounts to get people to think it's popular until it actually became popular. Eventually it stuck because it was superior to the other options, not because there weren't any other options (there were many).
&gt; Basically if your package gets on a /trending page of github, you immediately get followed by bots that try to seem legit following popular packages (I guess that is what happenned to pixie). I can't confirm this. php-pm was for several days trending and doesn't have pages full of people with no picture (or registered at the same day). What you describe is rather usual for Twitter - there are more bots that automatically retweet stuff.
I do all my API implementations with it, it's just clean and light... and having PSR7 is just middleware heaven
Not to be a pedant (!!!) but just because something is older and not updated does not mean it is "unsafe." It might be "mature and stable." The real questions are: does it serve your needs, and in a way you like? Can you understand its workings? Will the developer(s) still answer questions and commit patches that you provide? If not, can you fork it and fix it yourself?
This is one of those 'so obvious no one though about it' ieas
So then this would also be happening to other peoples packages? Well, that should be easy to check...
Other data on Packagist seems to support /u/AndrewCarterUK's claims. Here's a quick comparison of `dev-master` installs for several frameworks: - Symfony: [~48 per day](https://packagist.org/packages/symfony/symfony/stats#dev-master) - Laravel: [~30 per day](https://packagist.org/packages/laravel/framework/stats#dev-master) - CakePHP: [~1 per day](https://packagist.org/packages/cakephp/cakephp/stats#dev-master) - PHPixie: [~2,000+ per day](https://packagist.org/packages/phpixie/framework/stats#dev-master) I find it hard to believe that literally 99% of users would prefer using the bleeding edge of `dev-master` over stable releases...
I thought that Slim had PSR-7 support since v3.0.0. TIL. 
This is funny cause it says "prominent" :D
What's the state of the Issues/PRs on the repo? If there are loads of unanswered issues then it's more likely the project is dead. 
I wonder if I can get that flair added.
Those installs that happened right [before and after you approached the FIG for the second time](https://packagist.org/packages/phpixie/framework/stats) in August? "I'm not saying anything, I'm just saying..."
Correct, but now it also tells the rest of the world (or at least Composer) that it does :)
Goodness. I don't know what's worse, the hypothetical scam artist or the people that go through great lengths to bring this individual to "web justice". Either way, this is why I lie to my friends and family about my occupation. It's much simpler if I just say I sell glue sticks door to door.
Ruby &amp;amp; Python mostly, with preference towards Python + Flask. However I do find Ruby incredibly comfortable and a simple pleasure to code in.
e.g. https://github.com/makaylagoodwin
Yeah, I've been using this for a while so this isn't really news. Slim is pretty nice. 
It is, one of the accounts was https://github.com/larryheathcote , I mentioned it in the PHP-FIG, but that account is banned now. Which should give you an idea on the average window of such a bots lifetime (less than a day). Which just shows how important was timing in Andrews post, and how a lot of these bots go unnoticed.
Okay, so that survey asked the number of years programming experience and the number of years of PHP experience. An obvious mistake is people who claim to have **more** PHP experience than programming experience. Looking at non PHPixie users (claimed), that statistic is 2.3% [170 / (7735 - 423)]. Looking at PHPixie users (claimed), that statistic is 60% [251 / 423]. [Raw Data](https://raw.githubusercontent.com/sitepoint-editors/php-fw-survey-2015/master/dump/survey.csv) [Parser](https://gist.github.com/AndrewCarterUK/b4245f5e8adc5c0148d1f4cad8b41680) 
Not different browsers. Repeated screenshots of the same interface elements to check that nothing's broken. At least, that's what I made it for... :) I guess you could use it to compare different browsers though.
This is quite an important topic; the PHP-FIG tries to establish itself as the de-facto userland standards corpse. Would you really want a fraudulent member in it?
Well, it's a great way to throw your rep as a professional into the garbage.
I understand the controversy over the vote and download fraud, but is there really a need to mass downvote all of /u/dracony's works? Dracony is, in my opinion, someone with huge dedication who's just a bit misguided with hopes of his frameworks being more known. 
Really excited to see where Continuum and Keyggdrasil go. Not a fan of Airship, itself, though. The themed naming of everything is too confusing and feels amateurish. It's also an unnecessary barrier to entry.
getLabel *is* an array or *returns* an array? Try: if (in_array($_item-&gt;getLabel(), array("Blue", "Black"))) { ... }
I've heard FB code is very bad. Can confirm?
Well... No
Then this should be handled on the PHP-FIG mailing list. I just don't get the public shame. Seems like everybody loves the gossip though judging by all the wonderful comment-less down-votes I'm getting. Also I'm pretty sure they've stated many times that they don't *wish* to be the de-facto PHP standard, but just a standard among the framework creators (Framework Interop Group), but that's obviously it's own can of worms.
It's not especially bad (way above the occasional "look at this awful homegrown framework I made!!!" posts), but it's just kind of uninspiring. I don't like to criticize because it's still a few orders of magnitude more than my open source contributions, but my strongest reaction to reading the documentation was "oh, that's interesting."
I'm actually interested in your use case. It'd be nice to see a working demo/screenshot of it in use.
Congrats!
How do those people find time to set those fraudulent scripts up ? And also, how can those people think nobody will ever find out, when the fraud is SO obvious when you look at the stats ?
Popularity is a factor in my code, because one of the largest things I think about is who will maintain my code when I'm not at my job anymore. How easy will it be for them to pick up and use effectively a tool that they may not have heard of or used before? As opposed to a tool/framework that they likely know of or have used? And has a larger community documentation base?
This is what I find most obvious (and hilarious) : &gt;Packagist has a helpful API for extracting daily installs and the [PHPixie data can be found here](http://web.archive.org/web/20160509134416/https://packagist.org/packages/phpixie/framework/stats/all.json?average=daily) in JSON format. &gt; &gt;As you can see, there have been some days where the scripts have not been run. On these days, there are 2-10 installs rather than 1000-2000. This could just be because a laptop or computer was turned off rather than left on over night. For whatever reason, it gives us an indication of how many actual downloads the PHPixie project should have.
Looks like you need a unique ID: http://php.net/manual/en/function.uniqid.php There are some gotchas so please read the manual and try it first to understand what it really does.
I typically have multiple websites on their own database in the same server. Putting things in the same database is just messy.
Reddit is certainly _a_ community. It's not completely representative of the PHP community IRL though...
Like others here, I never actually checked out the framework and I honestly don't know really anything about it. But I do know that the creator has been childish, angry, a lier, and is generally just a bad person in my experience. And there is no way I'm going to trust anything important to a framework under the control of someone like that. I honestly wouldn't be surprised to see him do something like intentionally break the framework for someone he is having an argument with.
I think it'll be fine. I'm being honest, and I believe code shouldn't be judged on the actions of the creator. Code is code, and if it is beneficial, it is welcome here. However personally I have a recommendation for you: write a neat blog post justifying and rebutting the claims made, instead of going in the comments section in the site. 
He was getting mass downloaded for being a spammer long before the sock puppets came to light. He violates Reddiquette in that you're only supposed to link to one of your own creations for every ten links you share. Instead, he hardly posts anything unrelated to his framework. His use of sock puppets, fake GitHub accounts, and bots only furthers his spammer behaviour. 
Is there any particular reason you are going about this in a public forum rather than discreetly reporting the matter to the relevant organisations, Andrew? I appreciate the effort in uncovering this potential fraud but I'm ~~appalled~~unnerved by your handling of the findings.
I completely agree. I just meant that some people can think this is just nonsensical drama, but I don't think this is the overall feeling in this community.
I did report this to the relevant organisation (Jordi from Packagist/Composer) before publishing the article. I respect your opinion, but I don't share your belief that there's any requirement for discretion. Edit - To be more explicit: &gt; Is there any particular reason you are going about this in a public forum... We're discussing the routine abuse of highly valued community tools by a representative of one of the most important organisations in the PHP open source ecosystem. I think it's important that people are aware that they were the target of a systematic campaign to manipulate their understanding of how significant this project actually is.
It was a calculated attempt to dupe the community - whether the community was actually duped or not is besides the point. I fail to see how bringing the specifics of the scam to the targets of this scam is at all "toxic". 
Understood, and I appreciate the work you've done. It's important that the issue is addressed and I certainly don't mean to trivialise it. I'm just a bit fearful of any repercussions this might have on the well-being of Roman given your article has already propagated as far as Hacker News. This thread alone is skirting the line between legitimate concerns about conduct within a community and personal attacks. And as expected, the down-votes have arrived. Good job, guys – I can feel the empathy from here. Edit: As far as I can see, the appropriate way of going about this is by informing the targeted organisations (GitHub, Packages, Reddit) and letting them handle it as they see fit. I'm not convinced this has to be a public spectacle.
can you tl:dr; the reception?
I fail to see where the "scam" is. It's a free, public library. The toxicity is the fact that this is considered worthy news. We, as developers specializing in PHP, were considered a joke not that long ago (or even still - I just don't care anymore) and witch-hunts like this make me wonder if we aren't a joke as a "community" (community being used as we are representing ourselves on reddit). His framework was never considered to be a big front runner and even with his potentially inflated numbers didn't pickup the steam like this thread has. This is just a further attempt to defame his character. At the worst end of the spectrum this could have been handled on the PHP-FIG mailing list to have him removed. While I don't agree with artificially inflating your downloads and stars - in the end - he made a library/framework for the community to use and used deceiving methods to promote it. His framework isn't malicious so I still fail to see the significance and this is why I never promote my own work - for fear the pitchforks come out and I'm caught as being the fraud that I already worry about being.
Interesting coincidence that random_compat is a dependent of [PHPixie/Security](https://packagist.org/packages/phpixie/security/stats#dev-master). I wonder how many of your installs can be explained by PHPixie's "unusual" install numbers.
I read through this thread and was tempted to try PHPixie. And then I had a flashback to 'samy is my hero'. The dots are now connected.
Yeah, that's a good point. I'd ask /u/AndrewCarterUK if there's any relationship. The only reason, as far as I'm aware, that it has anywhere near that many installs is because it has 112 dependents, including some of the most popular frameworks. (Technically, everyone on WordPress 4.4 or newer also uses it, but I don't know the statistics there.) None of the other projects we've started have broken the 2000 download mark yet. That one library is kind of a special case, and it will be totally useless once everyone's on PHP 7.
What you should have done is report to me and I would check with the community. Instead you accused me of increasing counters having 0 proof and basing on your own interpretations.
Dev master was the only version untill very recently. I encouraged people to update composer.json, but afaik nobody did
Kudos to you. At least one guy has a bit of sense here....But see the downvotes you are getting. It is absolutely disgusting. It is pure mob mentality at play. It just shows the real world reality, that you can be shit to your fellow human beings as long as you are supported by a majority of your peers... As for what the phpixie guy is accused of, even if he did that, I don't think he has done anything really damaging. Maybe he has devoted so much of his time, and just need some feedback. But /r/php just wouldn't give it to him. Why? Because he wouldn't get rid of the fairy! So may be, he was desparate...but still not willing to bend over... So being a programmer, he tried to do solve it technically, some SEO and took advantage in the weakness of a couple of platforms...Is that cheating users? If yes, then so is every kind of SEO ever...Ever used a shit load of keywords to improve your rank (with out improving your actual content)..Yep. Cheating.... So, the point is, this wouldn't have happened if /r/php was just nice to him in the first place...Not worship, Not follow...but just be nice.
I'm trying to write PSR-7 middleware, and I'm kinda stuck with how you are supposed to write a response without depending on an implementation. I'm trying to write a new response body to the response the middleware received. I can't call `response-&gt;withBody` without an actual `StreamInterface` implementation to set. I can `rewind` and `write`, but if there are more bytes than I am writing already written, I would need to clear those. There is no way to remove data from the stream without just writing padding. Was this intentionally omitted to make the stream immutable-ish? Am I missing something? Do you just pull in a streams only library? It almost seems like there should be a `StreamFactory` interface or something.
From one of the comments: &gt;He used install statistics as a reason for PHPixie to become a FIG member project (they author the PSRs) and it also results in very high rankings for his projects on Packagist searches.
In other news, Bernie Madoff seeks to become trusted investor...
Until then I've got you tagged as... http://i.imgur.com/iZpaFOd.png
&gt;Do I want to build my next project around executable code from a source that has integrity-problems? Do you use Php?
That's like the first thought that runs through my head when I encounter a problem. "OK, what's the probability that someone else has encountered this and posted about it online?" Sometimes I spend more time searching than solving.
These days I find that the person running the ship is at least as important as the code/framework itself.
So mob is a valid description of a community if that community has a majority in agreement? 
Congratulations on the first step! It's a good idea to specify a licence for the project by adding a LICENCE.md file to the codebase
The graphs /u/AndrewCarterUK made are bases on PHPixie/project, so there is little relationship.
I'll also add that although very significant for his packages, your package has so many genuine downloads (over 5 million) that his traffic would affect your install count by less than 2%.
wordpress.com has made multiple presentations on this topic, they have &gt; 500 Million MySQL tables nowadays. they are sharded over multiple clusters and partitioned, you will find a lot on this topic when googling. the simple start always is simply "splitting" read and write queries, sending the write queries to a different server (master) then the read queries (slave) ... as usually you have much more read queries than write queries, this usually scales to easiliy accomodate some million users (in average, it depends on the actual project). 
sure, but I've never seen any warnings about the return value being null. I've been on a quest for some sort of feature or plugin that will warn you when you use a potentially null value without checking the type first.
It needs a proper standard library built in, which is why we are in this mess in the first place
It is not about having a majority in agreement, but how it manifest among the members. Mob mentality enables people to do acts that they won't do when they are not being part of a mob. Take the comment of /u/gripejones, currently at -10 votes. Normally, people won't or feel good to down vote a harmless comment like that. But when they are part of a mob (currently hellbent on shaming phpixie), they suddenly feel free to down vote such comments and use strong language/name calling and other such things that are usually frowned upon. Similarly they feel ok to upvote comments that are otherwise considered as rude. For example, name calling and personal attacks are supposed to be not ok with this sub. But when there is an active mob, those things are upvoted and cheered upon...
Thanks for this post though, because of you I am now getting a lot more installs!!!
I think you are asking, if these companies have one big f* off database for every single account. Or do they create a new database for each account. I cannot speak for these companies and other users have provided some great insight on how you can scale a single database. My company has 1000s of accounts all stored in their own database vs one massive database. The advantage of multiple database vs one big one. * Data Isolation - Each database is separate from all other databases. This makes it much easy for the developer not having to worry about isolating tables from bad SQL Queries. * Debugging - So much simpler to open the customers database and see what is going on. This process sucks on massive databases. You will need to query your self out of that hole here. * Testing - If a customer is having issues, you can make a copy of their account and test it locally pretty quickly. This is close to impossible with a single database. Especially when your database is 10s or 100s of gigabytes in size. * Scaling - All your databases do not need to be on the same server, you can very easily split out which customer databases are stored on which server. So essentially you can add lots of servers if required. You could even store a customer's data in a different country depending on their privacy laws.... There are issues with this approach and that depends on how they have crafted their solution. * Schema upgrades have to be applied to every single database. So if you need to add a new column to your database you have to add this to every customer database. For our solution, this is not a problem. * Data scrubbing - have an issue where some value has been saved wrong. To fix this you need to write some code/query that can be executed on every database. If you had a single database this is pretty easy to do in SQL statement. From my last 5 years experience of doing a database for every customer, I would say this is a good way to go, MySql doesn't have a database limit so you can a huge number of databases without issues. The main reason I love this approach is that is super easy to debug customers data, I can easily download their data and run their app in less than a minute. But the big one is that I dont have to filter my PHP/MySql queries by account so this prevents accidental data leakage which would be hugely damaging. 
[removed]
interesting, but does it go any further than really simple unit testing? i mean looking at the average test suite and the amount of bootstrapping, mocking and stubbing thats going on... i dont see this going any further than testing utility stuff such as a fibonacci calc. also, not having access to php or phpunit for that matter... meh :( and there doesnt seem to be alot less code than a separate phpunit class. 
Fixed now, silly mistake on my part :) 
Trying to setup a Webpack / React / Redux / HMR / Babel etc project at the moment ... I'm still somehow stuck at Webpack ... And I've done recently Gulp / Browserify / React / Reflux projects so it's not like I'm totally out of touch. It's insane.
Yeah, the cron jobs read the appropriate php.ini file ... so they try and get it right. 
People were hesitant at first to remove him. Then, he started calling people names and flooding the mailing list. People who were neutral have lost their patience with dracony. Kayla is conducting a vote soon and I dont think dracony will have much support now. UPDATE: /u/pmjones, who is also a voting member on PHP-FIG, has spoken and is still undecided. He said dracony's actions don't necessarily affect FIG, ~~so it is not necessary to expel him~~. &gt; What I'm left with is: "How exactly does this behavior affect the group?" &gt; * If the answer is a generic "It makes us look bad!" that's not quite enough; any behavior anyone disagrees with anywhere will "make us look bad" to some group. &gt; * If the answer is "We don't like to look like we ignore purposely misleading manipulation of common objective measures of project statistics", I think that's a much stronger appeal. These kinds of statistics are the closest thing to a currency or scoreboard we have in this world, aside from unquantifiable "reputation." &gt; I'm not a fan of banning anyone, even temporarily, for out-of-group behavior. But this may straddle the line between out-of-group and in- (or of-) the-group sufficiently to warrant attention. I won't speak again on the FIG mailing list, for it's already very flooded (dracony alone sent 14 emails on the subject) and it doesn't really concern me directly. However, I do not agree with /u/pmjones. I think the exact motive of this fraud was PHP-FIG. I think FIG members were purposely misled, and that is FIG business. But if the other voting members agree with pmjones, I'm OK with their decision. I just thought it was worrying enough to raise the complaint and let the members know. UPDATE: /u/philsturgeon has spoken for dracony's expulsion.
Ran out of popcorn already...
&gt; Kim "Dotcom" been on my shitlist since the late 90s, and it's frustrating how many Kids-These-Days have been taken in by his underdog status with the law. Well, I don't know about inside the US, but outside it's less "Underdog of the law" and more a stand that we *don't want American copyright laws extending overseas*, or Hollywood convincing our Governments to **raid someone's house** for hosting a piracy site. We just don't want the US' Hollywood industry trying to exert control over our countries
Came for the nuggets, stayed for the peace &amp; quiet. I am a father of three, not real picky about where the quiet comes from...
Wasn't he rejected the first time because of it?
https://github.com/bradchesney79/2015DebianJessieWebserverProject Stalled a little while I do other things, but progressing over time.
"Any man more right than his neighbors constitutes a majority of one"
Maybe you can consider for a bit that some of people found his comment to lack relevance and usefulness to the discussion of wether cheating on installs numbers is ok or not and if that should lead to expulsion from Fig?
Are you allowed to do this?
I don't know if these posts are satire or not anymore...
Why would you not be? In the context given on the GitHub link I specified that the users had signed up to the website, and therefore they are giving permission for their Gravatar images to be used. Even if this wasn't the case, I'm fairly certain you are allowed to do it since Gravatar themselves provide an API for accessing the Gravatar of email addresses. 
When you use my gravatar I am in control and can change one place and it is changed everywhere. Also it is abit of a stretch to say that because I login to your site using github I gave you permission to host my profile picture. Depending on how you use it, there may ofc not be an actual issue. I did wonder if it is within the gravatar agreement though. 
I always though code reviews were about making sure: - the code is readable to another developer - the code matches the spec - there's no edge case issues
Keep in mind this post is just an author trying to sell his paid service... I'm not sure I agree or disagree. The sentiment is good, but I'm not sure code standards are a big enough "cognitive load" to warrant yet another build process speedbump. Every code review I've ever been a part of emphasises code standards in one way or another. Sometimes it's as simple as tabs/spaces, sometimes it's a lot more. It's really dependent on the environment you're working in and the people you're working with.
His first attempt never came to a vote, because of political opposition to the pixie logo.
Same for Hoa. Each time we have a library trending on Github, we don't receive that much bots… :-(.
Lmafo
Hello ! I'm the author of this tool/experiment. Rusty wasn't created with unit testing in mind. The project is really young so what I'm going to say might not be true in a week but the main idea behind Rusty is not unit testing, it's documenting your project with real/executable code samples. The goal here is to show your users how to use your code… and make sure that the examples you write actually compile and run. That's why code samples can be written both in doc-blocks and in markdown files (ie: in the documentation) I see a real interest for that in libraries or "domain-related" code. But you're right, it does not replace unit-tests. &gt; not having access to php or phpunit Code samples are written in plain PHP so you potentially have access to anything you want. To keep these samples small, you can include bootstrap files using the `--bootstrap-file` option. Each file given using this option will be required at the beginning of each code sample. Example: `rusty --bootstrap-file=./tests/some/bootstrap.php src` Just so you know, I'm currently thinking of a way to natively integrate PHPUnit and Atoum test frameworks. Just to see what kind of benefits we could get :)
I think the people who code review like that would just rewrite the code anyway without the review so. y'know.
Seems like it is. In the opposite direction.
He's not suggesting it be the determiner though, just the catalyst. If the community has a pretty sound consensus on something like this, it should at least be brought to a vote, no?
&gt; If the community has a pretty sound consensus on something like this, it should at least be brought to a vote, no? In my opinion, no; or rather, not for that reason. That's "catalyst by mob" (no offense).
or maybe it's a maintainability thing, who knows 
I mean the framework was on version 3 and still used dev-master for release. Anyone that gets to your 2 questions is already a 1/4 mile down the wrong road IMO.
The findings and conclusions are facts, how you revised it while trying to seem impartial was just, you trying to use the power of persuasion. They have been verified from the likes of reddit, github and packagist. It is a closed case (!), you just walked and talked gently, sugar-coat hard facts, insinuated straw-man, to carefully end up where you wanted it to end. It's ok not to want /u/dracony banned but to overlook, and play around the facts while making your judgement seem impartial *isn't*. And wth is this? &gt; I'll go so far as to say that nobody here actually qualifies applicants by quantifiable measures; they qualify applicants by how much they like the applicant. This kind of nepotism should *not* have a place in a community that advocates for *quality* above anything else. And it is not fair also for those who reject someones bid to join, objectively without taking 'likability' in mind, you can't make assumptions about the others like that. 
(/me nods) In return, it's my unsubstantiated opinion that the bigger, perhaps even the major, factor in his acceptance was that he had changed the Pixie logo.
What are you talking about? what github verified them? Github banned some account sfollowing pixies, and also yesterday it banned some other bot accounts following random projects (that I actually linked to). The bot lifetime seems very short there apparently. Nobody proved it to be any kind of deliberate act. As for reddit, and I keep saying this time and time again, only 2 users apart from me got suspended, all because they voted when they saw me announce stuff in the pixie chat. Reddit deemed it vote manipulation. But Andrew is playing it as "sockpuppet accounts" which they weren't, they were real people who got suspended because of Andrews crusade. And please don't tell me their 2 votes were influencing anything. 
&gt; leads the direction of which php is going in its decisions Don't confuse the PHP-FIG with PHP itself. The vote being discussed there has nothing to do with "the direction of which php is going."
Was it this one? http://splashnology.com/uploads/2013/07/4KdWqDd.png
If i needn't it I wouldn't ask - that's the problem. Basicaly I want to parse argument as an array, so app --test foo, bar, "with space, and comma" outside returns ['foo', 'bar', 'with space, and comma'] as value of `test` argument, kinda like powershell.
Newsflash: reddit admins don't ban accounts because they like your posts. They have tools for establishing frauds such as yourself.
https://www.reddit.com/user/geekphp is a user that was [banned](https://www.reddit.com/r/PHP/comments/4bgoou/multiple_sockpuppet_accounts_used_in_rphp_by/d190eoj) by *reddit* when it was revealed dracony was using them to vote up his posts in here. 
On the node side of things, I used express pretty heavily (and still do to a lesser extent). It's frustrating to have wasted time getting good in a framework that is probably not even going to get security updates.
&gt; Packagist has controls that prevent the activity Looking at the code the only control is a maximum of 10 downloads for a single package coming from a unique IP per day. Are there more controls other than [here](https://github.com/composer/packagist/blob/6afcdf8b57f802997f68f24a1b583361f7c0e2d8/src/Packagist/WebBundle/Controller/ApiController.php#L205-L218) and [here](https://github.com/composer/packagist/blob/a07b9f715b301a414f7a12f166432df7e9b956e1/src/Packagist/WebBundle/Model/DownloadManager.php#L115-L141) ? &gt; This is the raw data that my script collected. I have slightly modified [your script](https://gist.github.com/renan/a4b8da0d67edb06d829d314ebbcb20ed) and indeed it shows that between 2 AM and 5:30 AM is where those packages had most downloads, for the 4 days you captured the data it is.
My opinion is that Tabs vs spaces shouldn't make it to a human code reviewer. This is something a tool can easily automate before the review takes place. It doesn't *have* to be hooked into continuous integration but it's certainly an option.
I am sorry to hear about this but "fake it till you make it" is the mantra of the modern civilization. It is kind of like girls using professional make-up to become way more attractive than they are in reality. Because nobody has more than a few seconds to spare for the first impression. And once that first impression is stored in memory you cannot easily delete it. I do understand /u/dracony's frustration for lack of traction for his framework even though it is the fastest out there so he must be doing something right: https://www.techempower.com/benchmarks/#section=data-r12&amp;hw=peak&amp;test=fortune&amp;l=13yebk. The OP's work will remain a source of inspiration for other people that will try this. They will know how to fake it better. Thus, they will have more chances to "make it".
Reddit admins don't issue permanent bans because you up voted a post at the wrong time.
So it is interesting that he commits with another Git config/GitHub user and not with his normal account. Maybe he committed with other ssh keys by accident.
Have you seen http://omnipay.thephpleague.com/ ?
If you're basing admittance off of logos than the FIG needs to be immediately disbanded for malfeasance.
So why don't you just use a different file name every time, based on current time and date?
You could pass the arguments like this: php test.php --test "foo,bar,'with space, and comma'" outside ...and it would work fine. The shell uses a space as a delimiter between arguments, so you are going to get 4 different arguments unless you quote them.
I'm not sure what system you're using, but you don't really have to upload your code anywhere. You can use some local environment like mamp, xampp, wamp and whatever else you'll find, or install php on your computer use it's built-in server http://php.net/manual/en/features.commandline.webserver.php. There probably even exists something like plunkr for php where you'll be able to run your code online.
/me shrugs No more so than any other voting process.
bake 'em away toys
TL:DR; Lets talk about the root of evil and the phylosophical implication about our actions.
No, most organizational voting processes have explicit definitions on the criteria involved in their votes and attempt to reduce the amount of subjectivity that the voters can have in determining their choices. They don't just allow people to vote based off their own arbitrary criteria.
Oh, finally!
"I am not a member of any organized party — I am a Democrat." -- Will Rogers That aside ;-) if there were explicit and objective criteria, there'd be little need for voting, only calculation.
&gt; I think you are asking, if these companies have one big f* off database for every single account. Or do they create a new database for each account. Yeah, this is what I was asking. I could imagine one of these huge sites having hundreds of thousands or millions of separate databases. I always wondered how that works. 
&gt; and inspirited by [the ADR pattern](https://github.com/pmjones/adr). Nice. :-)
Wow, I didn't expect to deliver the "most damming evidence". I nearly gave up, when I didn't find email information in the API response for the pull, but found it then in the pull commits. &gt;But Andrew is playing it as "sockpuppet accounts" which they weren't This ~~blatant lie~~ really shocked me.
Nope. It's actually one of the most pleasant PHP code bases I've ever worked on, and that includes search.yahoo.com which I built the framework for from scratch (well, with one other person, to be fair). Part of that is the availability of the Hack Typechecker and features like short lambdas and async not found in PHP, part of it is just the well disciplined organization of the codebase. I spent most of my time on C++ code while there, but whenever I had to work on the www codebase, it was always a smooth reintroduction to the components and easy to write reliable, well tested code.
Hoooorrayyyy! \o/ gratz /u/bopp and team
I had to refill twice now.
Just FYI, I've finished this section and added it into the script which has been updated on Github. Gave you credit in the readme akeniscool :) 
I don't know if you know this but the download links aren't working (they 404).
This is great. The only think I didnt like about Java was that any reference and type hint is nullable. Having an explicit nullable type is a great idea and Im glad PHP went this route. This also means IDEs will be able to warn you about not handling possibke null returns
I'm not sure on what planet `md5($username . $salt . $remoteIP . $hostName . $userAgent)` is considered a good way to generate a security token in 2016. Also, use a random string for password reset tokens, please.
Congrats, I've found Bolt to be a nice alternative to Wordpress in terms of performance and being able to monitor it well. Question, though, do you know of any way to have a custom admin panel where posts are seperated by page? Like an average website, but each page has a series of specific posts in it.
What exactly do you think is wrong with it?
+1. Listen to this man.
* Use of MD5, which is vulnerable to length-extension attacks. * Not using a CSPRNG. * Using user-provided data to generate the string. (You can't trust HTTP headers!) * In many places, comparing hashes with `===` instead of `hash_equals()` (there are polyfills available).
I don't think point one is that relevant in this particular use-case, but in the realm of better-safe-than-sorry you're probably right. No disagreement on the other two points.
Great work! The new model repositories looks a lot nicer!
Thank you! :-)
Been waiting for this release, gonna give it a go soon!
Oh, pay that no mind. I'm confident there are a few people with downvote-bots that have me in their target list. It's probably not actual /r/php users doing it. (I'm used to this treatment.)
It was at -1 when I posted.
Whether something looks exploitable isn't really relevant, because there's almost always going to be exploitable cases you didn't think of initially. When something is using a broken technology or approach, then unless you have a *very good technical reason for keeping it*, it should be fixed. Regardless of what you think the impact is. MD5 is one such technology. It's a ticking timebomb otherwise, and you're betting on yourself being more competent than an attacker - which is a very dangerous bet to make even for experienced developers. EDIT: Also, security tokens should *always* be random and *never* derived. These kind of complex derivations might *look* cool and hard, but from a security/predictability point of view it's just needlessly asking for trouble. That something looks secure doesn't mean it is.
My email address is draconyster actually a reddit mod can confirm that for you if you like )) also the dots betwee dra and cony seem like a gag, no idea what grip is though. Grep maybe ? Why would I care of the random email in commit actually ? Actually I know the dude, he hangs around the chatroom. For a while yesterday I actually suspected he's the one doing me a "favor" with packagist installs. But any well meaning person would stop doing so after yesterdays post, and from what I can see the counter is still going up. So yah (
Personally, I do my development work on [cloud9](https://c9.io/) so I don't have to setup a local server environment on every computer that I want to develop from. For PHP, it shouldn't require any extra setup once you create a PHP project, and it's free. There are other similar offerings (like [nitrous.io](https://www.nitrous.io/)), but cloud9 is the one that I use. 
Hadn't heard of Bolt before, reading the feature list nearly made me cry with happiness! I will definitely be checking this out!
&gt;no idea what grip is though. Grep maybe ? Maybe "grip" is an allusion to "gimp" which is in your Twitter id [1]? [1] https://twitter.com/dracony_gimp
We moved sites this afternoon. SSL cert should've been fixed by now. 
You always have my upvote :)
Is it throwing an error? if ($result = $dbhandle-&gt;query($query)) { ... } else { var_dump(mysqli_error($dbhandle)); } Also, /r/phphelp would probably be a better place to ask this.
I'm forced to confess I always get back to Google. ;-) What's the point?
I just found it interesting that you talked about how popularity should not be use used as the most important part in choosing a product, but you yourself use Google instead of one of the many other search engines. :)
True. I suppose you've heard about the expression "Javascript fatigue". What I find very funny, it that Js as a scripting language, the intent was to avoid compiling... ^_^ Now they all using a fucked up chain of preprocessing/transpiling/wtf to be able to do what Java/M$ does for decades... let me guess...servlets? jsp? or asp? "You don't get it, that's far better" "And, can you tell me *why* it is better?" "baa, it's just cool." "but, in the end you just throw out html or json over http right?" "Ya, but You don't get it, that's far better: it's *new*" ^_^ 
And just so you understand what I'm talking about, here are some examples of library functions you might use in a real-world application that would be used across many different classes: 1) Doing an application-specific cleaning of URL's 2) Convert a string into the HTML for a message box of various types (error, success, etc.) 3) Set/unset a cookie in the way that your application needs cookies to be set. 4) Check to see if a string is an email address or not. 5) Get the extension of a string that is a file name. 6) Conversion of weights or lengths between types.
You are right! Well spotted, thanks :)
It's not a performance thing, it's about composition. Traits are a way to automate copy and paste without multiple copies of the code living in your code base. But once compiled, the code is treated exactly as if it's there For example, if you use a trait to add a function to a parent class, a child class can override it and call parent::function (or not). You can also interact with trait-provided methods in mocks for testing. You can do similar things with functions, but those are harder to mock for testing and you can't inject them readily.
Has anyone here used Bolt? Is it a developer CMS like OctoberCMS or is it a user CMS like Wordpress. I'm in the market for a CMS I can setup for my agency that offers the ease of use of Wordpress and the ease and sanity of development like Symfony or Laravel.
Just to drink the devil's advocaat - Symfony, Zend, Laravel and Doctrine all use annotations. How can something that is so popular in PHP world be the wrong thing to do[1]? [1] https://www.youtube.com/watch?v=nxXEPk3dzFg 
Nice!
&gt; hastily "analyzing" code (grepping for "md5"). In what scenario is the use of MD5 *not* a problem?
Haven't seen that clip in a while – thanks for the laugh.
That's exactly what they are.
I'm aware it tries, but as I commented on the article itself and as is clearly illustrated in the source code [it's purely IP based](https://github.com/composer/packagist/blob/fe5bd85e7e9300745bc09e36fa83863b3de0596d/src/Packagist/WebBundle/Controller/ApiController.php#L210-L217) and has no way of detecting autoscaling. For example with AWS where a new instance is spun up to scale up, it gets a new IP. You have no way of detecting that that IP was part of an auto-scaling group. We fluctuate anywhere from 4 servers to 40 servers throught the day depending on load. Every time one comes online "composer install" is executed on a **new IP**. There's no reasonable way to block autoscaling.
Hell no.
IMO reviewing test code/documentation is as/more important than reviewing the code itself: - make sure that unit tests are added to cover the behavior change - make sure that the unit tests are sufficient - if unit tests aren't practical for the change, insist on a written test plan, and review that too There should be enough information between written test plans and coded tests to: - make you reasonably confident that the change is functionally correct without looking at the code - make a competent developer who isn't familiar with the code understand what the change is meant to do - make a competent developer who is trying to fix a related issue make sure that their future change doesn't cause a regression
While i like Dunglas' work I just wished we had directly support for middleware and PSR7, not just the Request object... I'm wishing for something of the likes of Slim or Expressive for instance. Then I'd make it my framework of choice again. Yet, Symfony community needs this, so I'm upvoting this
Can you expand on your last paragraph? I don't understand why functions can't be injected readily with testing. Are you referring to Unit testing not being able to access functions for some reason? Also, your second paragraph where you talk about overriding a function added to a parent class via a trait. I'll have to think about that. I can't come up with a situation right now where a library function added to a class would then need to be overridden again in a child class. I'm sure there's a situation where it could occur, but I think I would normally add an additional variable into the function header. Anyway, thanks for the stuff to think about!
So you're comparing methods from traits to global functions? I wouldn't call that "exactly the same".
Thanks, I was pulling some of those examples straight out of a piece of e-commerce software that I used to work on fairly regularly. I came on later, but they started working on it in the PHP 4 and early PHP 5 days, so I'm guessing they needed that function back then before 5.2 came around. You're absolutely right, filter_var is the way to go for any modern application that doesn't need that sort of backwards compatability!
If you are using a trait to effectively 'import' functions into the current (class) namespace, you're doing it very wrong. Just keep using standard functions for that.
Directed by M. Night Shyamalanadingdong
I work hard. I feel like I should get paid more. Does that mean I should lie on my resume in order to get what I think I deserve?
you don't need a bundle to test your controllers, just declare them as services and test them as you test any other class.
I will always share my popcorn :)
Good catch, but I fail to spot the pun or smth
Hello, it seems your account has been shadow banned. You should probably contact the Reddit admins to get unbanned. The /r/php mods did not ban you. We cannot unban you. We had nothing to do with it. This is just an FYI. Good luck.
that was kind of my point - no, you shouldn't. Not making excuses for his behaviour, merely pointing out the thought process which leads one to do these sorts of things.
Thanks for your comment and for sharing your opinion! I am glad you liked the allover article.
When you just need a hash of something and it doesn't need to be secure. For example, I've used it to cache requests to a service. If a request to an endpoint has the same arguments, return the cached results. The cache key includes an md5 hash of the parameters so I don't need to make sure that the parameters don't have any special reserved characters that would make the cache key do weird things. 
When I spoke of injection, I'm referring to dependency injection. Normally you wouldn't have a class where one of the parameters in the constructor is a callable. You can certainly call a global function from within a tested class but then you can't mock the result of that function, so your "unit" test is now testing both the code under test and that global function.
I have used Bolt for about three to four websites now and highly recommend it. Since I don't know your business needs or want, I would recommend downloading, installing, and trying it out for a few hours. If you run into an issue or have a question feel free to hop into IRC #boltcms. Bolt is extendable through extensions and is pretty easy to use overall. Need to create a new custom content type with relationships to other tables? Easy. The community surrounding it is also very active, and usually respond quickly to bugs or issues.
Annotations are just a way to attach data to particular code elements. You can do that with XML (yuck) or YAML (yuck) and you accomplish the same thing writing a lot of error prone code with string literals referencing identifiers. 
Opcache makes file size and quantity optimizations pretty irrelevant.
I have been playing with it for a little while and have found it to be a lot of fun. The code is easy to walk through and it took me longer the read the documentation than it did to build a usable extension.
"I'll accept it later" because: - "I'll do it later" pretty much never happens otherwise - Until that happens, you have untested behavior, increasing the chances that someone (maybe that developer, maybe someone else) will break stuff without realizing If it's a new developer who doesn't know how to write tests, I'll sometimes send a PR to their original branch adding the test for them if they need help, but it's not viable to offer that help long-term.
Thanks. Appreciate it!
"The lady doth protest too much, methinks" You get off on telling people they're wrong
A native implementation of Fortuna would be fantastic
It's not Fortuna, but it is [probably just as good](https://github.com/paragonie/seedspring).
&gt; I think we should be looking for ways to leverage "normal" PHP code (or at least syntax) and keep the new stuff as thin and simple as possible. You want something as simple as possible than propose something that is significantly more complicated. Annotations here as simple a PHP function calls. The syntax and semantics are well defined. You're proposing we go from that to parsing strings -- that is much more complicated. 
C# controls whether or not attributes can only be specified one or multiple times with an attribute on the attribute class. :)
Been waiting a while for this one. Nice to finally see it come out, and congratulations! With that said, I'll be holding off a little on upgrading. I have a feeling you'll have a few patch releases coming out shortly.
I think I explained my perception pretty well in the sentences after the one you quoted, but from what I understand, Single Responsibility increases the number of files in an application if you follow PHP-FIG rules (which I intend to do as much as possible) and separate out your namespaces, interfaces, traits, classes, etc. into separate files. I'm worried that many files with too little in them will slow down my application. But the other user brought up a good point that Opcache will probably take care of that particular issue if I mess with the default settings.
As I lightly mentioned in [another comment](https://www.reddit.com/r/PHP/comments/4ird2x/rfc_in_vote_attributes/d30ks8r), you could definitely use annotations/attributes for something like that, but there's quite a few drawbacks: - coupling your entity classes to table definitions - meta-data becomes behavior - performance without caching is rough, due to reflection/AST-based accesss - testing becomes more difficult/cumbersome - etc Ideally you could use an alternative to attribute mapping. In Doctrine, for example, you could use a few alternative methods: - XML: no thanks - YAML: potentially even worse - Plain old PHP code via static methods or bootstrap/loaded code. My personal favorite. I personally would rather have my application's Doctrine `EntityManager` register mappings via lazy-loaded plain-old-PHP code that's testable, easily version controlled, and doesn't rely on comment reflection. For that, I use the [`ClassMetadataBuilder`](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/php-mapping.html#classmetadatabuilder).
That's so meta.
Yeah, I came across this when I was looking to see if something existed already. Looks slick, but didn't look to have been updated in a while. Glad the effort wasn't for nothing :)
https://groups.google.com/forum/#!msg/php-fig/ahdPYge4UOs/PHsaQCm4HqYJ &gt; And by the way it's really not hard to inflate Github stars by writing a bot in like 15 mins.
Haven't used it, but check out Pagekit too while you're looking into Bolt. It looks pretty neat. I think they both target ends users in addition to developers.
Can't browse your website on chrome on Android 5.1.1 (Oneplus 2). Certificate authority invalid. 
For a few small projects that require entities but don't justify using an ORM, I build a simple DatabaseMapper class that would build an entity from an array and vice versa: $mapper = new DatabaseMapper; $data = $pdo-&gt;execute($sql)-&gt;fetch(); $entity = $mapper-&gt;toEntity($data); 
Currently none of my projects are experiencing lag. But, over the 6 years or so that i've used phpstorm, there has been versions of phpstorm that was laggy in certain projects. Maybe it was due to binary files, but i recall at one point i had these massive combined &amp; minified js files in one project. Also i seem to recall massive 7k lines css files causing trouble ... ofcourse riddled with errors. Same with one project where we had js-files that was compiled through php .. so a file with name something.js .. but it had &lt;?php blocks inside.. This caused the entire file to be full of errors .. red everywhere .. and this seemed to cause lag as well. 
In this case it is. We just need a reproducible hash, depending on a few factors. It could've been Base64'd or ROT13'd twice, and it'd be just as "secure". 
A few other people have this too. It's weird though, because I don't see anything wrong with it: http://i.imgur.com/0fSi9ME.png What error exactly are you getting? 
Reflection is nearly always a performance concern, more-so in some languages than others. For a language that's often used in a kill-the-chef style like PHP, definitely. You can use caching to combat it, but then you have another problem. :P
 - Bolt is production ready and mature. - Bolt can be used both as a simple CMS, or as the basis for a custom application, or anything in between. - Bolt is built with Silex, Symfony and other third party components, that are well-designed and thoroughly vetted. - Bolt is very extensible and flexible. - No legacy PHP cruft, requires PHP 5.5.9, and fully PHP 7 compatible. - Bolt is Free and open source. - We take security seriously. - Bolt has a welcoming and inclusive community. I'm not sure what qualifications you're looking for exactly. Take a look at [the features][1] and the [release posting][2] for more details. If you have any specific questions, feel free to ask. [1]: https://bolt.cm/features [2]: https://bolt.cm/newsitem/bolt-3-0-0-stable-released
Anything sarciszewski writes! He is, after all, god's gift to mankind, here to spread the word of the lord!
&gt; Annotations here as simple a PHP function calls. I disagree, writing turing-complete code inside pseudo-comments is the complete opposite of "simple". The RFC suggests that the parameters to the &lt;&lt;attribute&gt;&gt; can be *any valid PHP expression*, so consider this: /* What does this do? * Exactly when does it do it? * How does it warn or error? * (Whitespace added for clarity.) */ &lt;&lt;foo( array( SomeClass::Go($_SESSION['SERVER_NAME'])), (1/0), exit() ), NONEXISTENT_CONSTANT )&gt;&gt; function myFunc() {} In contrast, I'm saying "put in a fixed string, and give people better tools for *presenting* the meaning of that string at runtime if they really want to." &gt; You're proposing we go from that to parsing strings -- that is much more complicated. On the contrary, my suggestion involves **less** parsing by the AST/engine, because all it does is *recognize* a single string (based on existing PHP syntax) and provides a jump-off-point for **user-land code** to do the rest. This has several huge advantages: 1. The core PHP language does not need to contain a complicated island-of-grammar that tries to solve everybody's use-cases. 1. It leverages existing PHP grammar and behavior, both for namespacing and also for string quoting/escaping rules. 1. If someone actually needs to embed something complicated (like an XML snippet) they can seamlessly leverage existing libraries to process it. 1. A commonly-used annotation can be *published and shared* as a library, allowing many sub-projects to interpret the attribute/annotation correctly. 1. If someone does try to trigger something horribly wrong in their annotation (like a division by zero or a web-service call) it will at least happen in a regular function in user-land with a reasonable stack-trace and debugger-support. 
I'm a fan of Attributes syntax. If we need to use docstring as an attribute, we should have this syntax rather than docstring. It's much better and nicer way to read the code.
The point of single responsibility is exactly the opposite of that. Do NOT repeat yourself, have one class that has this responsibility and inject it whenever you need it. Magento is indeed bloated, but even then I think most of its performance problems are because of the architecture itself (and the immense size of its database when you have a lot of products), not the amount of files. 
If your the sort of the developer who wants to cry while working with WP or Joomla then Bolts a great choice. Bolt is far more directed at actual Developers i believe rather than just web designers wanting to throw a bunch of pre made widgets together. The backend is dead simple though and wonderful for clients compared to Joomla or WP. Try teaching someone to navigate Joomla, its no fun. Or trying to explain why a Post isnt the same thing as a Page in WP. Have yet to try 3.0.0 but loving 2.8. 
&gt; SSL See https://www.ssllabs.com/ssltest/analyze.html?d=bolt.cm Apparently, you do not also send the intermediate certificate.
Here you go: http://imgur.com/6h43otz did you read this (I know you are probably not using IIS, but it could be something similar)? https://support.comodo.com/index.php?/Default/Knowledgebase/Article/View/1019/1/untrusted-certificate-error-on-android
&gt; * No legacy PHP cruft, requires PHP 5.5.9, and fully PHP 7 compatible. This is one thing I will give any project severe kudos for doing. :) &gt; * We take security seriously. Not to disparage your point, but just in case nobody had brought it up before, that exact word choice is the subject of ridicule in the hacker community. [Example](https://www.troyhunt.com/we-take-security-seriously-otherwise/). [Another example](http://krebsonsecurity.com/2014/09/we-take-your-privacy-and-security-seriously/).
4 to 6 currently, i really don't want this... Crossing fingers.
Just because the libs and frameworks are big, doesn't mean it's good.
because there is no better way? the RFC looks gross. PHP tries a way too hard to become java anyway.
Any new developments/improvements on multilingual sites?
So that includes function like `get_class_vars()`? I'll run some diagnostics to see what kind of impact it practically has. I usually use some form of `get_class_vars()` to convert an object into something that can be stored into the database, so I don't have to remember to add a new field to it whenever the object changes. (I do need the translation however as dates and other special types need to be converted into some database friendly format).
Thanks, should be fixed now! https://www.ssllabs.com/ssltest/analyze.html?d=bolt.cm
Thanks, should be fixed now! https://www.ssllabs.com/ssltest/analyze.html?d=bolt.cm
Thanks, should be fixed now! https://www.ssllabs.com/ssltest/analyze.html?d=bolt.cm
Ive been using Concrete5.7 recently. The ux is really good. Seems pretty easy to develop too. 
Whats really nice about features like this, is that they don't need to be used by everyone though. I get the arguments against using it, but i still want to, and if they are implemented in the language itself, it'll be faster than using comments.
Seems to be a problem with the demo /u/bopp - `An exception has been thrown during the rendering of a template ("The "/var/www/public/theme/demo" directory does not exist.") in "editcontent/fields/_templateselect.twig" at line 50.` - FYI, I am also getting fatal errors on the front end.
Controllers are just the glue for your *already unit tested* objects.
Wow. Your library looks awesome! Thanks :)
Thank you very much! It works fine now! :) Have a nice day!
The thing is, you're going to run some tests and then come back here and tell everyone about how in your microtest it took umpteen million tries before the difference was noticeable. But in the real world we're not running the same metadata fetch repeatedly so cache lines get blow, etc. Looking up metadata is always a performance hit, and while it's useful, you should treat it like candy. It can be super enjoyable, but too much and you'll feel the pain later.
Maximum in current PHP is 1m I think. Just comes down to memory.
I haven't looked at 3.0 yet but writing extensions in 2.x is a complete ball ache. Hope they fixed that. 
Oh, I'm not saying that library functions all go into one single file or that they should be unclearly named or obtuse. Ugh, just the opposite. Every function should be named clearly and have a phpdoc-style explanation above it (and they do) about what it is, what goes in, and what comes out. Along with that, the files need to be clearly named and their directories need to be clearly named and laid out too. What I'm after in everything I do is creating clean, easy to navigate, highly-documented code that is also maintainable and not bloated in width or breadth. I know you read that and probably roll your eyes and say "Yeah, right." But that's because you haven't worked with me yet. I decided a long time ago that if I'm going to work on things, I'm going to build code that is a joy to work with for the next guy. And that's why I have the concerns I have. Imperceptible differences become perceptible in e-commerce. 1/10th of a second can be the difference between cart abandonment and a purchase. As can two steps in the user interface where one would suffice. And a thousand other things... That's why I'm asking these questions that you and others have lightly mocked. I need to get to the bottom of things that people on the general forums aren't talking about. Thanks for your input! I really appreciate it!
Because PHP is also a CLI [edit] and PHP can also be a cli-server, which gives three behaviours 1) print stderr to stdout 2) Throw RequestException with status 500 2) Send header("Status: 500") 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I've released 2 new tools today, which are in fact decoupled from another project into independent ones. The first is PHPT tests runner: https://github.com/nazar-pc/phpt-tests-runner I was using official PHPT tests runner from PHP's sources, but was not satisfied with it and thus decided to write alternative implementation with slight differences (runs many original unchanged tests though) Second is much simpler and is called Stream slicer: https://github.com/nazar-pc/stream-slicer I've being working with streams in various projects recently (parsing multipart messages, processing binary files) and was wondering why there is nothing in PHP to get slice of stream as new stream, so I ended up writing such thing (uses previous project for running tests).
does bolt feature comments to articles / content objects yet? i didnt see it on the feature list
Because I think someone installing via composer.json only might not download the same version as the one the developer used
PHP knows if its running as CLI though: php_sapi_name(), and it knows if headers are already sent (it reports this warning when trying to set a header on CLI), so I guess it could just do it for non-CLI scripts where header hasn't already been sent? But maybe other reasons why it shouldn't? Seems like a reasonable default to me though, it would help a lot of people avoid SEO &amp; ajax issues when they have bugs. 
Thanks for the reply. I did check out the how-to in an earlier version but it didn't seem very complete. For reference, if you guys would like to see a very great multi-lingual implementation you can check out OsTicket's setup at https://github.com/osTicket/osTicket/pull/1410 (yummy screenahots included) Congrats on the new release!
And like the pirate code, it's more of a guideline than an actual code.
... huh... this does make a lot of sense.
That's true. I mean, we can't ignore the hundreds of thousands of PHPixie users that are nowhere to be seen on Reddit.
Should be working now! Thanks!
Hmm I don't know. I think that from the client's perspective, an uncaught exception does mean that "The server encountered an unexpected condition which prevented it from fulfilling the request". I think HTTP status 500 is correct.
The built-in web server does, just tried.
Well I think the question is just applicable if asked as 5?? - the exact code doesn't matter right now, it would be something in the 5?? range. &gt; Better make sure to implement proper error handling to your API and catch all possible exceptions instead of sending misleading HTTP error code headers. I agree, and do this myself. But we're talking about n00b friendly defaults here. To me, making this a default behavior would be less harmful than returning 200 in most cases, especially for the people it mostly affects: the n00bs. 
Maybe if you're running the built in HTTP server, but PHP itself is a language, not a server. HTTP status errors are the responsibility of Apache, Nginx, etc.
It would be PHP setting the status code since its rather trivial to do. `http_response_code(500);`
Actually thinking back on this, due to output buffering it's actually not possible for PHP to do this. Since you can flush the output buffer before the entire script is complete, the Status Code as well as the rest of the headers are already sent to the client. Think of it like a Piece of paper, You are already writing at the top and then somewhere along the line something happens. The stuff you already wrote can't be changed it's been written.
We've actually covered that before (in the abstract), and a lot of related topics: * [Basic cryptography terms and concepts](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded) * [Why you want authenticated encryption](https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly) * [PHP cryptography library recommendations](https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide) * [Why to use libsodium outside PHP as well](https://paragonie.com/blog/2015/09/how-to-safely-implement-cryptography-in-any-application) * [How to store your users' passwords](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016) * [Random strings and integers with a CSPRNG](https://paragonie.com/blog/2015/07/how-safely-generate-random-strings-and-integers-in-php) * [A gentle introduction to application security](https://paragonie.com/blog/2015/08/gentle-introduction-application-security) (probably the best starting point for junior developers) I could probably do a better job with increasing other developers' exposure to this material, but I've been trying to err on the conservative side with that.
What? Absolutely not. A PHP error should be a 500, because it is exactly an internal server error. It tells the client that the problem lies with the server, and there is nothing the client can do, to fix this. The client needs absolutely no distinction, whether it's a problem with the webserver connecting to the backend (like what you described), or the problem is in the backend.
[500 Internal Server Error](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1) [The server encountered an unexpected condition which prevented it from fulfilling the request.](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1) I’d say the script generating the resource failing to properly execute counts as “an unexpected condition which prevents [the server] from fulfilling the request.” But the server needs some way to know that the script was unable to produce the requested resource, rather than just send the server an HTML-formatted error message. So PHP telling the server to use a 500-level status should be appropriate. Not really any different than having a PHP script tell the server to send a 404 when the script can’t locate a database record.
True, but tell that to the other 80% that don't do it. Although, the 80% probably wouldn't be looking into this bundle...
Sounds like a XAMPP problem. Using ubuntu/apache I get a 500 status code for both of these &lt;?php echo "hello world"; // $1 / 0; // throw new Exception("kaboom"); 
HTTP status code should be sent from the application, in my opinion. I won't argue whether PHP should send 500 automatically or not, I don't really care, but keep in mind that it already set status 302 if you send a Location header. So this argument of web server responsibility isn't really accurate.
(My reply to the person claiming responsibility follows, for discussion; "here" means the FIG list.) * * * Thank you for admitting to your actions here. However, as Dracony has admitted to sock-puppeting in the past, I think in the interest of full disclosure, it is necessary for you to provide some bona-fides here to help clear Dracony's name. One or more of the following would be a reasonable start: - The name, address, and website of the agency you work at, with you listed on the website somehow. - Links to your Github, Twitter, Facebook, or other social media presence, with some historical activity there for comparison; these would probably need to point to your ballinox@mail.ru account somehow. - Links to where you have participated in online forums or mailing lists (besides this one of course) with some historical activity there for comparison; these too would probably need to point to your ballinox@mail.ru account somehow. - Links to a personal site where you publish your writings or code, with a domain name or IP address that can be tracked back to you personally somehow. (For what it's worth, I googled your name and email address but found little that appears to be related to a PHP developer using PHPixie.) You appear to be truly apologetic, and to want to help clear Dracony's name from your own actions; showing some bona-fides will go a very long way towards doing that. (Yes, I'm aware that you may shun all other forms of public internet interaction, but that's an easy claim to make if someone does not want to be discovered to be faking an identity.) Andrej, the choice is yours. Your actions here can still lead to a good outcome for Dracony. Dracony, for your part, I encourage you to press Andrej to make the fullest possible disclosure, to defend your own position here; as Andrei claims repentance, it should not be too difficult. If bona-fides are not forthcoming to this list, though, or if it looks like they have been constructed primarily as a result of this correspondence, it's going to look a lot like Dracony is now sock-puppeting the FIG directly. In that case, I personally will do what I can to have Dracony expelled for fraud and malfeasance. 
They'll probably be using Laravel instead.
I just tested with Apache + PHP5.6 and it throws a 500 response. Just wondering are you using an type of framework?
This drama is delicious.
There's the JSONAPI extension, which implements (more or less) jsonapi.org. It needs to get an update for Bolt 3, but i suspect that won't be long. 
When my boss decides on a framework or a vendor that I think is not the better option, I suck it up and do the best I can. With a clear chain of email highlighting who decided on what. He is the one who is paying me and the vendors. If one is so fanatic about software that they abuse public tools and platforms to influence their managers, they ought to leave the current job.
Look up contravariance, invariance and covariance. Basically it is type-safe to do it this way.
Just doesn't add up to me. At all. A random developer appears out of nowhere who is so committed to Pixie, of which they would be one of the only users in the world, that they are willing to lie to their boss and manipulate the entire framework's installation statistics in order to keep using it? Rather than using one of the more established players in the framework space? Does. not. compute.
&gt;Time Tracking plugin Interesting, someone knows how this work and what statics show? 
My LAST last post... I think :) Objectively speaking, there is sufficient hard facts of manipulation of stats (thanks Andrew) but nothing linking explicitly and without any doubt to Dracony. All evidence is implicit and/or circumstantial. Sure he has sock puppets and dick moves all around, but I wouldn't discount the good he has done for the community. I have seen him responding to questions, being enthusiastic about new developments and taking criticism all the same. Humans are not black/white and Dracony is in a solid grey area right now. If voting members of FIG feel hurt, deceived and "triggered", do a re-vote. It's not unheard of in a democratic system and it's not rocket science. FIG at this point is more drama than action. And I like action :)
I think that there are so many posts with so much info is the problem :) It just needs to be condensed into a nice DO THIS LIST. I was fairly certain this information already existed. Maybe I will have a stab at it to reduce it to a few pages. Actually the Recap section on the basic crypto page is perfect. Now if we had that for ALL of that stuff on a single page :D 
Not to mention the boss was apparently concerned with the usage then was totally satisfied when miraculously the popularity went up. In the meantime, no work was done. There was no cost to switching from whatever to the now wildly popular framework. It's so far beyond bullshit. If this guy isn't a sock puppet I'll eat my hat. 
&gt; Hmm, could be your display_errors setting. Well, that’s good to know about. Not entirely sure why they can’t do anything about the bug in the cases where the exception is generated before headers and output have already been sent, though.
Are you looking for [Thomas Ptacek's spin on Cryptographic Right Answers](https://gist.github.com/tqbf/be58d2d39690c3b366ad), perchance?
Same thoughts here! Actually the web server is just the base PHP is running on. In the end PHP is responsible for how the response of the server looks like. So as /u/mikedelfino mentioned, from the perspective of a client PHP "*is the server*".
I will be messaging you on [**2016-05-18 14:32:02 UTC**](http://www.wolframalpha.com/input/?i=2016-05-18 14:32:02 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/4iuw3p/someone_admits_to_manipulating_phpixie_downloads/d31bkgg) [**13 OTHERS CLICKED THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/4iuw3p/someone_admits_to_manipulating_phpixie_downloads/d31bkgg]%0A%0ARemindMe! 1 week ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d31bl8a) _____ |[^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^([Custom])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^([Your Reminders])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^([Code])](https://github.com/SIlver--/remindmebot-reddit) |-|-|-|-|-|
[Taylor Otwell's answer](https://groups.google.com/d/msg/php-fig/cjLBp2weYaA/OosGg5wgDgAJ) is exactly on point : &gt;Agree, more information is needed here. I find it hard to believe that a developer was told they couldn't use PHPixie, and instead of just saying "OK" and choosing a more popular framework like Symfony, Zend, Laravel, Slim, Cake, Silex, etc. they decided to instead go through this elaborate plot of writing scripts to artificially inflate Pixie's install numbers all in order be able to this framework that apparently, according to Andrew's adjusted stats, is used by essentially nobody else in the world. I'm not saying it's impossible, I'm just saying it sounds unlikely. **At this point, the crazy one isn't your manager, it's you.** *(Emphasis mine)* Edit : Didn't see /u/utotwel actually [posted here](https://www.reddit.com/r/PHP/comments/4iuw3p/someone_admits_to_manipulating_phpixie_downloads/d31appe) as well a few minutes before I did.
Actually not, is it depending on the error settings?
The only thing I don't like about this RFC is that there might be some confusion between the behavior of `?string $foo` and string `$foo = null` but honestly that seems like a pretty minor nitpick. This makes me really want to push PHP 7.1 as soon as it's out though. I've got a *ton* of code that I can add return types to with this feature.
Yeah that looks better, still a little long winded for my liking. **edit** I know I am being very picky :) **edit** Actually what I would like to see is how to do all of these things IN your library. Encrypting data... ` HaLite::Encrypt() ` .. etc **edit** Also thank you for all the stuff you do!
Not my intention to sound like "omg, stop being so dramatic". Apologies if that's how it came across. You are right about this being a relevant discussion. It is important to question the integrity and motives of the representatives of a community. I was merely pointing out the fact that such discussions should not be stretched over a long period and should be resolved with celerity and clarity.
It returns code 500 only if error display is disabled. So to make it return status code 500, it's enough to do: ini_set('display_errors', 0); basically it's to overcome a limitation from Internet Explorer hiding the error message if status code wasn't 200 further explanation can be found here: https://bugs.php.net/bug.php?id=50921#1404847711 also here: https://www.reddit.com/r/lolphp/comments/3wjzqp/200_ok_internal_server_error/
Hey, I like it! The only thing I'd need before I started integrating that package would be the ability to construct models instead of passing an existing instance in. For example, this is a database mapper ripped straight from a recent project: public function toEntity(array $voteStatusData) { $status = new CountyVoteStatus( $voteStatusData['County'], $voteStatusData['VoteStatus'] ?: 'No Results Entered', $voteStatusData['TotalPrecincts'], $voteStatusData['PrecinctsReported'], $voteStatusData['VoteTimestamp'] ); if(!empty($voteStatusData['VoteIncludes'])) { $status-&gt;setIncludes( explode(', ', $voteStatusData['VoteIncludes']) ); } if(!empty($voteStatusData['Notes']) { $status-&gt;setNotes($voteStatusData['Notes']); } return $status; } I could theoretically get around this by using a builder class in place of an entity but I'd rather avoid the additional complexity if I can manage it with a sane constructor method.
it's lonely at the top
It wasn't you saying "omg, stop being so dramatic", but some people definitely said that on the FIG mailing list: &gt; Let's not be the PHP Drama Group or the PHP Court of Social Justice. I didn't think I was creating drama. If dracony took it too personally, that's on him. He called me stupid, said it was a witchhunt... I feel like he's lost a lot of the support he had there just because he was acting childish. I strongly doubt that russian guy is a real person, and if he turns out to be, I think he'll be a friend of dracony's posting on his request. The story is just too inconsistent. "I'm not following reddit nor FIG, but a friend told me about all of this" "I REALLY wanted to be the only PHPixie user in the world, so I deceived my boss and wrote a lot of scripts, connected to a lot of proxies and messed with packagist installs statistics." "even though dracony is known to use sockpuppet accounts, I'm not one of them, I'm just a random russian guy who defrauded statistics to fool my dumb boss".
Moving PHP forward through collaboration and undiagnosed mental diseases.
PHP should not be deciding the status code based on the result of code execution. That is the developer's job.
That was my first reaction as well until I stopped and really thought it through. What comes out of a method should only be allowed to get more specific, as that does not break the contract the parent method set up. If you could change that, then the parent is no longer valid for a return type. If the parent method allows for nullable parameters, then the child has to as well in order to maintain the contract. A child method allowing nulls when a parent doesn't still maintains the basic signature. Feels like I'm not explaining this correctly.
Ahh. Sorry about that, Andrej. I just assumed that in this particular fantasy the boss was concerned about enterprise readiness based on popularity, given that it prompted an Oceans Eleven style response to prop up the numbers. My bad. 
I mean, I could do a Fortuna implementation, but I'd rather use ChaCha20 than RC4. ;)
What?, is an internal problem of a private organization, the responsability is Dracony's only if is guilty. Many people have frameworks that nobody use and they do not do this nonsense of use bots or socket puppets. 
for your own sake, come clean before you go too far and completely spoil any good name you have worked so far to build up.
Not built-in. We usually use disquss of facebook. Not having to deal with spammers is a godsend. 
Got your reminder request! Sorry if I don't really get your reminder right, I'm sort of solar powered but only with those tiny solar powered chargers you find on those old calculators. You know how when you block them with your finger and the numbers start to fade? That kinda happens with me at night and mt tpying skelisl tstart to diamsinish rpetty fukcn in g qukclikyly
Wait... but how does this "confession" explain the framework survey fakery? This company's employee is so dedicated to one obscure framework he'd rather write not just Packagist-raping scripts but also a form-filler script than learn the basics of a better known framework?
So why does PHP not do this for regular classes? A "Foo" parameter is more specific than the nullable "?Foo" so you can replace "Foo" with "?Foo" when extending, but you can't replace "Cat" with "Animal".
The fake stars could have came from [this site](http://githubstars.com/) dracony may have heard of it from [here](https://www.reddit.com/r/PHP/comments/4cbni6/never_heard_of_this_one_but_apperently_it_has/d1hfd1h) then [this](https://twitter.com/dracony_gimp/status/727790568420585472) happened. The amount of stars phpixie got is roughly the same as sold in the site. 
I do agree with you, but don't throw out the hypothesis of stupidity. Not everyone is as rational as you. People do stupid shit.
&gt; Berlin, Germany [@dracony_gimp](https://twitter.com/dracony_gimp)
Has the gnupg PHP extension been updated for PHP7?
&gt; The problem here is, that there's so many ways to do multilingual, and nobody agrees on what the best way is. Could you elaborate a bit on this?
Bolt is like Wordpress, except it has a sane codebase :). It is the perfect sweet-spot between the flexibility of Drupal, the simple UI of Wordpress, and the flexibility of Symfony for me and my clients. Keep up the great work.
It's at least slightly better than plain passwords or just md5(password). Since they at least understand why passwords must be hashed, I would start by explaining them how fast today's computers and may be come up with some examples of collisions. 
That's my feature request then :)
Thanks! I will look into it. I actually had something a little different in mind, but I suppose a framework might be helpful as well. I was thinking of something along the lines of [KerbalStuff](https://github.com/KerbalStuff/KerbalStuff), which used to be a mod repository for Kerbal Space Program and upon it's closure had it's source files released. But it's written Python, I would like to see something similar in PHP. A properly written web app (I suppose the OOP part isn't all that necessary), because I feel like I'm lacking a lot of proper programming ethics as well (since I taught myself from Youtube tutorials, documentation and Stack Overflow).
This will get really meta if someone writes a reddit bot that responds with `lara{{ noun }}: {{ description }}` to every Laravel post.
Bullshit, try to think like Dracony, what would he plan next to justify all of this ? Since he doesnt want to admit... obvious fake
&gt; return types on entities due to how Symfony processes forms and said entities. You just shouldn't use entities with form. Work with DTO instead, this will make life easier for larger projects.
That wasn't an intermediate mail server though. That was a header added by mail.ru. The user who used mail.ru to send that mail was in Berlin or using a VPN that was terminated in Berlin. 
Bitbucket offers unlimited users/repos for $200/mth. I would just move over there.
Holy shit, the sites for [AuraPHP](http://auraphp.com/) and [PHPixie](https://phpixie.com/) both start with `&lt;DOCTYPE html&gt;`... we might be on to something here.
It's highly probable that it's all him, especially since the origin of the mails is somehow linked to Berlin. &gt;obvious fake He even concurs. &gt;I just emailed a bunch of FIG members about this, but seeing how I have further proof I might actually come out publicly on this. &gt;I believe Andrej is an actual sockpuppet, but not mine. I find (as an outsider) this whole discussion interesting and educating, but it has also become a sad story. 
I used bitbucket last year, and it is just painful to work with its UI and general slowness. Currently coupled to GitHub due to their API, their look &amp; feel (consumers of my thingy want that, and it cannot be copied) and their general support and uptime (don't use GitLab if you need uptime without a dedicated ops person).
I hope this never ends. It's theater!
oh my god. I will pay money to watch this :)
&gt; I assume most solo-devs will be happy to have infinite repos "repositories": [ { "type":"vcs", Bleh. I feel I'll be hurt more in the long run by eventually-public-but-not-yet useful projects struggling due to this, than I'd ever benefit from having a gajillion of private repos for myself. The org I work for only has two private repos and it's only the ~3 core devs working on them, so we are probably ok.
From the PHP-FIG group: &gt;That it an be spoofed? It's actually my IP. Maybe that's what the dude wants to infringe me by. Hmm, maybe Dracony runs his servers with a static IP address, so "Andrej" knew the IP and was able to spoof it. **Update:** New message by Dracony: &gt;I mean, Andrew retrieved it just like seconds ago with his "trojan email" Ohh... 
I've made a suggestion on how to do that in https://github.com/Rican7/incoming/issues/4#issuecomment-218520130 Hope it helps! :)
&gt;A random developer appears out of nowhere who is so committed to Pixie.. I don't know, it does not seem surprising to me that people will go to great lengths to keep using what they are familiar with ;-)
Indeed! I'm the one that recently commented on said issue, as a matter of fact. I look forward to using Incoming on my next small-scale project. :)
Can confirm that there's no need for hat eating. [I just matched the IP from the sock-puppet to the IP address of a visitor to a link that was only sent to /u/dracony](https://groups.google.com/d/msg/php-fig/cjLBp2weYaA/rAAubJQqDgAJ)
Messed up.
Further on in the thread its proven that his IP matches yours from a link only sent to you and pmjones... so #rekt.
"If you find yourself in a hole, the first thing to do is stop digging."
Can we get some "Official Witchhunt Thread" flair for this post?
Well, you are safe. :D It turned out, the ip of this guy has the same ip as dragony's. I can't barely work today due this theatre performance, it's incredible :D
Then don't use it. Even Taylor suggested others and not just Laravel. edit. To clarify: If you think Laravel sucks, there are plenty of good alternatives that even the creator of Laravel thinks are worthy of mentioning.
Dracony is PHPixie's representative. Dracony will be expelled. What kayla meant was that anyone can interact with FIG, it's not exclusive to members. The entire thread was opened by me, and I'm not a member. He will still be able to participate with suggestions, he just won't get a vote.
I see, thank you!
In terms of lowest required effort, [Lumen](https://lumen.laravel.com/) is probably your best bet. A decent alternative would be [Slim](http://www.slimframework.com/), which I used to prototype a simple read-only REST API recently. You'll need to write a bit more code, but what you've described seems simple enough that it wouldn't be a big deal.
Yeah come on PHP community, send him to rehab! http://imgur.com/0THrfB4 
I will have to bump up the repos number at some point, and that will be reached soon. When that happens, it will switch to the new pricing model.
Ah! Haha, well then, glad to hear it! Thanks for the discussion contribution. Always appreciated. :)
If it weren't for his continued attempts to deceive the community, he'd probably not get as many votes for nullification. Dishonest behavior does not need to be encouraged. When you lie to someone, you insult their intelligence. When you lie to someone, you cause long-term harm (even if there's a short-term gain, as with white lies). Continuing to lie, and fabricating a whole new persona to try to save face, it dishonorable on top of dishonest.
Since we have our pitchforks ready can we go at him for this sexist remark? https://twitter.com/dracony_gimp/status/726165884260241408
gitlab ftw
&gt;It's over now anyway, I'm never going to be able to get more conclusive then that. That's true. My teacher tended to say "si tacuisses, philosophus mansisses", if only he kept silence he would not deliver more evidence.
You create tasks, and the plugin tracks the time you spend in the enabled task. Apparently, you can also link tasks to git feature branches.
Yes, and they already gave you the username to use :D
Also, he's saying that his IP was spoofed to send the mail. That's not possible. Both SMTP or HTTP (I don't know whether mail.ru is a webmail service) run over TCP and you can't spoof the origin of TCP connections because the server sends a SYN/ACK packet back to the origin which then has to respond with ACK before the connection can be established. The spoofed origin would never accept an unsolicited SYN/ACK
While i do agree, and don't think that should discourage the addition of the feature. We still have eval and goto, even though they are both very dangerous to use. I think people should try to properly educate people on how to use these features, instead of outright saying "Don't use these! Most of the time they are bad". It's disingenuous, and not fair to the people that have an actual good reason to use it. (Not attacking anyone, I promise. Just playing the other side of the argument)
I like that he then says that the guy is trying to clone his ip. If that guy was trying to frame Dracony, WHY WOULD HE COME OUT AS THE CULPRIT?!
If they vote no then they might as well disband, because I can't imagine many people will trust any organization that turns a blind eye to liars and cheats. I keep reading some farcical bullshit from people who seem to lack the intestinal fortitude to do the right thing by hand-waving away his actions as not relevant to the group. No, you are the company you keep, simple as that.
It could of course still be a spoofed X-Originating-IP header. Mail headers are (bottom up until the first consecutive Received header) all text that can be added by a mail client. But if mail.ru is a web mail service, that's much harder to do if not impossible. I'll leave this investigation to somebody who really cares. 
It's adding an extra dimension of same origin request. The password reset token is a cryptographically secure token, as an extra measure an extra token and validity period are stored in the DB which means that outside of the time window, and should the ip address change between reset request and new password save then the reset token will be invalidated.
RemindMe! 1 week "Check how this drama tv show ends" 
This is true, I did have a think about how to do that but couldn't think of anything. In the end, he panicked and admitted it was his IP anyway.
Devil's Advocate: Maybe I haven't been following closely enough, but doesn't this seem a bit quick for a vote? Sure, the evidence seems pretty well stacked, and nothing the dude's said has given me cause to like him very much, but considering http://andrewcarteruk.github.io/programming/2016/05/09/phpixie-fraud.html was only posted two days ago, I would think there'd be a cooling-off period at the very least.
I love building APIs in Slim... which is why I became a contributor to begin with.
Me too... I guess that is just how it rolls... *shrugs*
2 resigned. Ouch
FIG is a great idea that was haphazardly implemented. They are trying to clean it up some and formalize things but that necessarily entails a lot of tedious minutia over parliamentary type procedures that bore most contributors to tears. How it works moving forward will be interesting to see, as it lacked a clear direction even before these fiascos.
&gt; Further, I see nothing in the bylaws that permits "nullfication", only "expulsion." Eh, I lack anything approaching concern about the semantic distinction between those two states. "Expulsion" certainly sound more "and don't let the door hit you in the ass on the way out", but membership ends just the same either way. Unless you're suggesting "nullification" would have a retro-active effect, potentially altering the outcomes of previous near-miss votes. That way lies madness, IMO.
We use it in house and its pretty good. Keeping up to date and (some) manual steps if you want hooks into cli tools are the only downsides.
Whaaaaat? How come this is the first I'm hearing about this? 
So we're moving some stuff from MongoDB to MySQL, anyone know a good query builder?
If you said every 30 minutes, then it sounds like the copy protection. That's been giving us a problem for a while.
You can also make sure your error messages are greater than 512 bytes to keep Internet Explorer from hiding them. 
Awwwwww.....some!!!!
&gt; Whats really nice about features like this, is that they don't need to be used by everyone though. Up until you wind up working with a pre-existing codebase that makes heavy use of it.
We have a relatively small dev team (about 10 of us), so it moves us from paying $200 to just shy of $100. I'm skeptical of how much it might cost us in the long term with expansion, but I can't deny that with the takeover of modularising everything as separate projects the new pricing approach seems to make more sense.
Very said day for all of PHP.
That's right! The Command Handler shouldn't return a value. The series is about going "towards" CQRS by refactoring a regular application through small steps. Here it's done by misusing a little the command bus pattern to let you get familiar with it and once you're accustomed to it you can push forward. To fix the "unknown return value" issue you could also decide to drop the command bus and use directly command handlers: the command bus is mainly here to enable middlewares, which depending on your requirements isn't something you necessarily need (something you'll know after using for a while). You'll find that people disagree a lot on whether or not we should return a value from a Command part (e.g. our command handler here): does that value imply a "read" (query)? Does it indicate that your system is synchronous, therefore unsuited for CQRS? To be honest there's no right answer, it really depends on your project, team, etc... Which is why I advocate the following: try it for yourself, and make the " right" decision afterwards.
I honestly feel like this is step 1 for Github to move to a storage based price model. Having users pay for private repositories is just plain stupid, and with alternatives having unlimited private repositories for free is impending disaster the way things currently are. Having developers pay for the space their projects take up? That makes total sense.
sabre/DAV left a few days ago: https://groups.google.com/forum/m/#!topic/php-fig/FV4aL-noVZk
This should be listed to the FIG itself. They, the secretaries, need to know why teams are leaving other then just "lack of time"
For my personal work, I see no reason to put private repos on github at all. I have a server with SSH access, so having my own private repo host is literally as simple as `git init --bare` in a new directory on that server. On the consulting side, everyone I work with self-hosts in some way or another. Some on Github Enterprise (which I assume is unaffected by this), but a mix of other tools. My preference by a *wide* margin is Phabricator. I feel that Github's collaboration model for private repos is straight-up awful, so if I had to throw money at someone to solve the problem, it would not be them. The fork + PR model makes a lot of sense for open-source, but is unnecessarily cumbersome for internal projects. 
We use Laravel as our framework where I work and I definitely agree with this guy on all points. Lumen was developed as a lighter version of Laravel with both working seamlessly together. Laravel is also very much on the rise as a solid framework to use in any PHP project with a large community of devs supporting it.
nope, &gt; You can also upgrade or downgrade in the legacy repository structure based on the number of repositories you need.
Don't see the option. I'll poke support then :-\
Laravel leaving is a good thing. This strengthens the FIG.
Looks good on my end now! For what it's worth, I was receiving the typical Chrome "Danger, this website is not secure!" warning page.
As someone not associated with a member project, I've always felt that the community is somewhat under-represented (particularly during voting). While limited membership has a very practical upside, the current process leaves significant gaps that end up falling on the end-users to deal with. Basically, components -- actual *implementations* -- designed to be framework-independent seem to have a disproportionally-low representation in voting compared to the frameworks accepting those components (and usually producing their own default implementation). They can discuss all they want as the list is open, but it's like being an unregistered voter campaigning for a politician. I'd personally prefer to see the voting phase of proposals be based on having some sort of expertise in the same domain of the proposed standard (e.g. someone working on Guzzle wouldn't automatically get a vote on the caching standard, their resignation notwithstanding).
They are obviously making statements. It is not clear what those statements are though. Such a cop out to leave due to "lack of time" when they are saying this minutes after the expulsion vote. "Interpretation is left as an exercise for the reader"..
Generally speaking, I'd say that's a good thing. I won't go nearly as far as to say that Hack is what PHP should be, but I'm confident that its existence is hugely impactful in kicking PHP's development into high gear.
Hmmm can you give me an example of a general-purpose language that automatically (with no developer action) returns an HTTP status code? I can't think of any (but that doesn't mean there are none, I am curious). Ruby does not, Python does not, Perl does not, Java does not.. Even PHP, which many people argue is *not* a general purpose language (CLI support was added in later as an after-thought) doesn't do this, and with good reason. Either way, it should be up to the developer to decide how their application fails, not the programming language. 
So just to make the distinction here, I believe this "exception leads to 500 HTTP error" logic being handled by FPM, not the PHP code itself. Remember FPM is a separate thing from PHP, it is a FastCGI application server that processes and runs your PHP code and communicates the results of that execution back to nginx. It adheres to the CGI spec, which includes setting sane defaults for headers, environment variables and response codes when the underlying code does not set these explicitly (such as sending a 500 error up the line to nginx if the PHP script fails). I'm probably splitting hairs here, and I'm sure many people consider FPM to be "part of PHP", but I think it's a distinction worth calling out here because CLI is also a separate thing that's designed to let your PHP script run in a command line environment (and provides sane defaults and other tools there as well that make sense for that environment). As an example, if you were to redirect the output of "php &lt;yourscript&gt;.php" out through port 80 and hit that from a web browser directly, PHP would definitely not be adding headers and response codes to your output automatically. That's what FPM and nginx are doing together. I hope that makes sense.. I'm just trying to point out that it's a bit more subtle/complicated than some people on here seem to think.
(disclaimer: Propel maintainer) I can only speak for me (not even the whole Propel team, because most just don't care) - I don't know why others have left, but one thing is for sure: Some (if not even most) FIG member are just there to vote and be on the website. Most member just don't participate on the whole project/idea. Really, this is no hating. FIG did awesome work on the first steps of make PHP more solid and standard, especially with PSR1,2, autoloader, logger (all rather little/simple concepts). However, with those new complex, very big proposals (like psr6 and psr7) it feels more like they want to standardise now bigger and broader systems, which I really doubt will work. Standardising little parts where developers have enough legroom is totally cool and practical, but now stitching together such big concepts is rather suboptimal. The whole idea of having a group of selected elites that build stuff and then decides which goes in, which goes not in, appears to me rather odd. This is always very fragile: people who are the loudest and most emphatic often win in debates, which is completely contrary to the goal of FIG. If you ask me, I'd let vote the whole community. Propose stuff, let it build on Github, let it vote via Github accounts, and just throw it out. If people are using it: fine, if people are not using it: who cares. If there are two variants (e.g. coding style with tabs, one with spaces): then the community decides through evolution who will win. Then everyone is satisfied and there's room for all kind of ideas, not only for people which have been selected as decider. I know, theoretically everyone can participate, just join the mailing list and contribute. However, this is not completely true as I stated above, because especially at PHP FIG there are people with strong opinions; convincing them is the biggest part of the job of contributing, which is completely odd because we don't build proposals for those guys, but for the community - which doesn't give feedback at all. Thinking someone is able to speak for the whole community is not only presumptuous but also plain wrong. Best standards are those who have been established by evolution, not by those guys that are the biggest stakeholder/have the biggest community. Also this whole debate about so much political, bureaucracy, who's allowed to do this and that, who's secretary etc, that is in my opinion just ridiculous. Whatever, I really haven't looked into PHP FIG for months (actually ages) (I think most php developer haven't), so actually I don't care what's coming next. Someday PHP-FIG isn't relevant anymore and a new concept of building standards pop up. I'm really interested how this would and could look. edit: based on the feedback, I created a first draft of how a better PHP-FIG could look: The PHP Community Driven Standards, PHP-CDS: https://github.com/php-cds/php-cds. Feel free to leave a comment here or in its repo.
I think it would be a shame to see the FIG disband before the event PSR is finished. IMO it's more important than people realise.
I use it however the frontend guys dislike it because there is no software that can be used with it on Windows: they dislike command line
I thought PSR-7 was totally fine?
- https://www.sourcetreeapp.com - https://tortoisegit.org 
Looking up 3 acronyms in first 3 sentences is really a bit tedious. YMMW isn't for example in Google. However, thanks bobloco64 :)
[lmgtfy](http://en.lmgtfy.com/?q=bing)
I'll send them over tortoise, they tried SourceTree and it isn't stable enough for them. Its annoying they don't use it due to command line. Its not hard to use at all. Thanks for the link. 
I love gitKracken. But to be fair, I am just taking them on their word so these links are helpful.
Event dispatch. The reality is frameworks like Magento will always roll their own for this sort of thing unless a standard is created.
I think those libraries would seriously benefit from standing on their own. They've gotten too steeped in framework implementation, and it will be nice to have more of these robust libraries go back into that mode.
&gt; The S/N ratio was too high I think you mean *too low*?
I've done lots of caching in large apps. There is almost always tuning to be done at the time the item is put in the cache to truly optimize caching. One cache timer does not work. It is absolutely an interface detail in any mature, highly tuned, app. The end result often is that caching is backend, cache timing is not. I would argue, and am, the exact opposite of the above post. The UI or some other non backend layer often knows things like user level that the backend does not. I've had apps that cache data for short periods for logged in users and long periods for unauthed users. Is that now a backend consideration? No. It might be in your app, but it is more than opinionated, it is actually limiting to act as if the only consideration of TTL is a backend consideration.
Yep, sorry :-)
so true!
Disagree: the interop documents produced by FIG have improved both the library and the framework ecosystem. I wish there was more implementation detail discussion, but that's what is actually missing.
It truly is. It is not perfect, but I rarely got ambiguity when using it. Quite impressive, considering we don't have generics :-P
&gt;And that's why I have the concerns I have. Imperceptible differences become perceptible in e-commerce. 1/10th of a second can be the difference between cart abandonment and a purchase. As can two steps in the user interface where one would suffice. And a thousand other things... &gt;That's why I'm asking these questions that you and others have lightly mocked. Again, it's not mockery. It's simply that it's such a small optimization it won't have any gain, except losing in readability and maintainability. We are not talking of a few ms here, we are talking of a dozen of micro seconds at best. If performances becomes a problem: 1. You're doing something wrong 2. You're doing something PHP is not good at And if you want to talk of performances on PHP side, I recommend you to use Blackfire as a base for your numbers.
PSR7 is supported in Symfony and this bundle supports it. It's just not the default because it's slower than HttpFoundation in Symfony based app. PSR-7 is not going to be the de facto standard before years.
Ugh... How many others realized their year was up and had to cough up $56 bucks? Damn them and their critical security update! PS I love you Intellij.
&gt; It's time to ditch mcrypt, abolish hacky home-grown unauthenticated encryption protocols tbh I kinda see libsodium has hacky and home-grown lol. I mean, it's developers (well, NaCl's devs) are well respected within the crypto community but the format it employs hasn't been standardized by any standardizing committee. Not by IETF, ANSI or any of the others out there. And PHP-FIG doesn't compare with IETF / ANSI lol. Altho that said, if libsodium / NaCl aren't aiming to be interoperable with anything then I guess it doesn't really need an IETF RFC either..
Ive been thinking the same thing ever since /u/philsturgeon left
[removed]
Yeah I knew someone would disagree, but in all honesty these giant interwoven PHP machinations are cumbersome and not very extensible. I'd prefer modularity over stuff being embedded. It's the true reason why projects like Symfony branched out int laravel and Silex, which are way easier to get up and running and can be modularized. Build tools for us to build the houses, don't build the houses for us. Propel was way better before Symfony came along and stripped out a lot of great reusable features. Doctrine was a victim of the same thing before it even had a chance to be its own thing. Frameworks killed libraries toolsets. I'd rather have libraries along the lines of Java or C++ than have to hack away at a pipelined framework, this way I can break things down if the code gets too heavy or needs an refresh. I don't want to have to depend so heavily on an overly integrated system that gets easily outdated. Even Zend has sold out to the interested framework crowd. I like that it tries to preserve some standalone instances of the API but I ran into a ton of dependency headaches with it a few years back and I decided to completely remove it from my projects. I thought no it was the OAuth instance that as I kept moving up in versions it just was a project hindrance.
&gt; FWIW, voted to leave due to lack of actual work on concrete stuff. The S/N ratio was too high, and we couldn't catch up with it, nor thought it was relevant to the core of what the FIG should be doing. And the S/N ratio looks poised to get worse with the FIG 3.0 proposal, suggesting producing ever-more standards with ever lower general applicability (it's literally admitted in the proposal). 
Did some moron say tabs? I think we're about to have a riot on our hands.
We would go from $50 per month to $106 per month. Safe to say we won't upgrade unless we're forced too.
My guess is for tournaments that a collision in UUID v4 is so exceptional it can just go unhandled. This collision is *extremely* unlikely.
You're repeating the same thing over and over, banging on pots and pans all the while. Yeah, I get it. *everyone gets it*
Tabs AND spaces! In the same document!
Tabs are superior, dare say thee! En gaurd
Man... MVC is so confusing to new developers, and rightfully so. The concepts are all so nebulous when you compare it to what you ACTUALLY do in a typical app: 1. Take in a request with some user input 2. Do some stuff with that request/input 3. Build an HTML document or JSON object with the results of that stuff you did 4. Send the HTML or JSON back to the browser/client in a response That's what EVERY request/response cycle looks like. MVC is meant to be a convention that prescribes a way to separate and organize the code needed for those 4 steps, but it's a really terrible convention IMO because it doesn't intuitively translate to those steps. * #1 is what the controller does, * #2 is what the model does, but the model isn't any one thing, it's a layer made up of many smaller things, which is a fact that's easy to overlook when learning MVC, because people learning MVC are learning it because they haven't really learned about the single responsibility principle yet. * #3 is sort of what the view is for, but not really, because a view isn't HTML, that's what a template is. But "template" is nowhere to be found in the MVC acronym, but MVC frameworks often have a `views` folders that really is where the HTML templates live, which aren't actually views... Plus not all responses are a "view", they might be simple JSON objects. * #4 is what the controller does again It's just all very shit and needlessly confusing all because someone got the bright idea to morph a small stateful GUI pattern to a full blow stateless server-side web architecture, and big surprise, it doesn't really translate all that well. Sorry for the rant, OP.
The kind of standards you're alluding to and cryptography don't mix. NIST, for example, actively holds organizations back from being secure. That said, IETF has actually adopted most of what libsodium offers: BLAKE2, ChaCha20, Poly1305, X25519, Ed25519. The only thing not standardized yet are: * Xsalsa20 (which could be upgraded to XChacha20) * Argon2 (in progress) * SipHash (narrow use-case for PHP devs) Note: I'm the kind of person who keeps up with the TLSWG and CFRG mailing lists. I've only sent one email (to say "don't even consider supporting compression with HTTPS").
Just because there were suggestions for standards doesn't mean every project should be compliant to every recommendation. It's on each to adequately evaluate and determine which fit the desired need and which miss the mark. I don't know how anyone could not see this coming as it's absurd to think one standard wouldn't ultimately alienate everyone at some point. Either way some medium to communicate some uniformity is beneficial even if it expects some level of freedom or requires some level of reform to exceed. Why so many are ready to blow up everything without debating the current trajectory is beyond me. Quite frankly, the mechanic reference is quite shit because there are plenty of conforming standards found between manufacturers that show interoperability to allow for most tools to work across most manufacturers.
Correct me if I'm wrong, but it sounds like the true value/effectiveness of the FIG is for bringing a lot of concerted pressure down on the final 5% of a specification, providing set-in-stone details for an overall approach that had already gotten unofficial/organic agreement. 
The IDE contains a web server that listens on localhost and provides an API for some IDE functions to be made available to external tools. Unfortunately, the web server also served a CORS policy that allowed any web site you were in to make AJAX requests to that API, which would give every web site you are on some control over your IDE
&gt; I am not going to link to examples because I don't want this to be another witch hunt or argument over specifics. Let's call a spade a spade: The recent incident was not a witch hunt, categorically. Throwing that phrase around is harmful: You devalue its impact for when a *real* witch hunt occurs. &gt; We as a community can do better than this. We should not be reveling- or helping to cause- the disintegration of other communities and projects. If someone deceives us it's far to get angry, but we should not be forming pitchfork mobs and should understand that these situations are easier to solve with cooler heads. Finally, all the hyperbole really needs to stop- it accomplishes nothing but makes this community look just awful. There's nothing that warranted pitchforks; nor did anyone make any physical threats of violence via pitchfork. What happened is someone was called out publicly for repeated acts of dishonesty. This isn't a witch hunt, this isn't being tar and feathered, and the pitchforks are staying in the barn. It's called **being held accountable for one's actions**. Accountability is a two-way street. If someone had, say, hacked his websites, they would face severe ostracization for life in addition to whatever criminal charges resulted from their actions. ---- That being said, I have noticed that the Overton window has moved towards conflict instead of understanding ever since the CoC was first proposed. This place used to be much friendlier.
I say let's propose a new standard: **PSR-9** for standardizing of how *PHP-FIG* members should correctly and interoperably rage-quit! *Edit: Incremented the number, because I just found out PHP-FIG wants to standardize how objects should hug each other in __PSR-8__.*
On the same line!
And there is the toxic behaviour coming out again. Phil may have been outspoken and said shit not everyone agreed with but he did make several good contributions to the community but was shat all over because of his personal opinions. We're (mostly) all adults around here but most of the time act like a rebellious teenager. Sure, you'll not like everything everyone has to say but instead of creating a thread on reddit and yapping about it, be a fucking grownup and simply ignore it. Stop creating shit when it doesn't need to be created.
I had to put a ban on sourcetree on my previous client's workplace: random merges from random branch to random branch everywhere, constant pulls without --ff-only (due to lack of clearness), crashes on rebases and completely messed up rebases. It is a good tool, but it makes potentially dangerous (newcomer) users an even bigger threat. We ended up teaching basic CLI commands to everyone, and that worked better than the 1% of features of SourceTree that they were using.
In a mixed php + html block!
I'm pretty vocal on Github issue threads, but not these Google newsgroups. Newsgroups/mailing lists just feel dated to me. 'Course whenever I say anything on Github people just respond with 'submit a PR' which I don't really have time for either with all the shit I'm involved in.
signal divided by noise... if noise is high, the result will be small...yep, math checks out.
[Restler](http://restler3.luracast.com/examples/_008_documentation/readme.html)
Despite Github being the de-facto place to host open source code, I always disliked them for private code. If you use JIRA and Hipchat, Bitbucket makes a lot of sense to host privae code. You can host unlimited private repos, with only the destruction being the number of collaborators in each plan. They support deployment keys, and they dint count towards the collaborators count so your CI server, test bots, etc do not count. Gitlab has both unlimited private repos and collaborators. But bitbucket doesn't break out banks. 
tf? you weren't even kidding. is this some kind of stupid april fools joke?
&gt; "signifying their joy over the drama." We (in the sense of whatever PHP-FIG turns into) need to lower the stakes, to make it so that it is possible for some people to work together without their efforts being seen as negatives by other people. People are happy to see that the PHP-FIG is coming to an end because it was producing crappy solutions which were allegedly going to be PHP standards. Having standards that most projects are meant to be using which are actually crappy standards, is a worse position than having either no standards, or having limited standards that are only shared between a few projects. I wrote this when the PSR-6 caching standard was forced through: --------------------------- Stop trying to have one PSR for a certain thing which is the ONE TRUE WAY OF DOING THAT THING and instead make the PSR organisation just be a central place for projects to work together on thing, but not force everyone to use them. And instead of having unique numbers allow those projects that want to work together to claim namespaces for the stuff they want to work on. e.g. if the Laravel and Doctrine guys want to get together and define better interface definitions then allow them to do that under the PSR\LDCache\ namespace. If the Stash, PHPixie and other people want to continue pushing this design through, if it was under the namespace PSR\AwsomeCache\ there would be no fighting over who would be the ONE TRUE CACHING PSR!!1! Yes, that would mean that there would be competing interfaces for similar things. This is a good thing. It allows for natural selection between the different implementations. Having everyone just use a single design is the end of innovation (and the biggest thing I dislike about the idea of the current PSR organisation). Oh, it would also allow for stuff to get done more quickly, as people designing standards wouldn't need to cater for every single use-case under the Sun. Having it under the umbrella of the PSR would still be useful, as it allows for a single place for people to discuss stuff, (for example organising BC breaks in a planned way, rather than them just being done haphazardly) as well as giving some back up in case the original developers get hit by a bus or lose interest in maintaining the standard.
It should be extremely unlikely, but you should keep in mind that 1. Shit happens and 2. Bugs happen, like this [issue with OpenSLL that caused UUID collisions](https://benramsey.com/blog/2016/04/ramsey-uuid/)
I have registered version. The other thing is a problem with rendering -&gt; http://i.imgur.com/C1ZGjYl.png
Is there any good knowledge base systems available for free or small cost (&lt;$200)?
&gt;&gt; that had already gotten unofficial/organic agreement &gt;But it sounds like the big players *aren't* agreeing. Right, implying that it's a different kind of situation, where the FIG's model might not be as valuable/effective.
On Windows, SourceTree is *notoriously* crap. The OSX version isn't bad, a lot more bloated than it used to be, but not terrible. I've got the Windows users on GitKraken for the moment.
Well /u/ocramius spends a lot of time in Germany
I personally detest the entire suite of Atlassian offerings, but if you're using some of them, it makes sense to go all-in. I've seen people try to piece-meal it mixing in other offerings, and it's a horrible mess. But that shouldn't be entirely surprising: it's the same "we handle everything" concept as Github, Gitlab, or Phabricator (and others, I'm sure), but you pay for the pieces individually. That may or may not work out favorably. Unfortunately, the market leader that prides itself on openness has done relatively little to create open standards or even protocols to manage all of the not-pure-git stuff, so all of the tooling needs a custom integration with every host.
I.. what? :-) 
Prepend your query with `define:`.
You forgot about that nested inline javascript with php values injected in.
I alzo zpiken Englis zometimes.
We have 40 members with 200 repos on one org, and 5 members with 40 repos on another org, and the change in the price model will save us quite a lot of money. We have mostly been using monolithic repos for client projects until now, but we expect this to change due to GitHub's new pricing model and so that 200 number is likely to increase a lot this year, meaning this will work out far cheaper for us than the old pricing model. Note that BitBucket has the same pricing model as GitHub, but is far cheaper. However, we find GitHub is more than worth the money.
I think that most of PSR-1 and PSR-2 was unnecessary. I have to use tabs and not spaces? I have to have a soft line limit of 80-120 characters? Why? It doesn't affect any part of the operation. Let me write code however I feel like. PSR-3 was good, but PSR-4 is really where the magic happened. PSR-4 was one of the best things to happen to PHP. But now it already exists. So... not much else left to do. PSR-7 is also fine. But it's so specific that they might as well have just made PSR-7 as a package and then released it for people to use. There's not really a whole bunch of usefully different ways to make PSR-7.
Based on the feedback, I created a first draft of how a better PHP-FIG could look: The PHP Community Driven Standards, PHP-CDS: https://github.com/php-cds/php-cds. Feel free to leave a comment here or in its repo.
&gt; This community has become toxic. How do we fix it? I disagree with the leading title. This community is alright in my opinion.
The Symfony implementation is great and widely used. The proposal is not so great.
I have honestly no idea what you're talking about... 
Tabs are for indentation, spaces for alignment. 
I think that the fluent interface is wrong. That's for the lazy ones. That's not "beauty". (mainly because along the calls types changes and it is not good for maintainance and error management) for the rest, I think it is basic c/paste of the related java specs as far as I remember (serlets)
That isn't the point though. I can't hook it up to Magento's event system without some sort of bridge. And what if I come across a package that integrates with the PHP League's event package? I'll need a bridge between all 3. Just curious, what don't you like about the event proposal?
I just wrote a first draft of how I think that whole standard thing could work together with the whole community. What are you thoughts about that guys? Any improvements?
&gt; Even before the events of the last few days there has been a high amount of witch hunting and basking in drama. This is expected to a certain amount in any community, but has been growing quite a bit. Not witch hunting. We're talking about someone who was proven to have systematically abused highly valued community tools with the explicit intention of misleading the FIG and the entire PHP community. Upon being exposed, they build a larger and somehow dirtier network of lies that ultimately collapsed upon them. &gt; The declaration that the work of dozens of people will be invalidated by a single person's bad behavior. I haven't seen this anywhere? Certainly doesn't look like a majority view point. &gt; A number of posts saying only "popcorn", signifying their joy over the drama. Agreed. In the end I made the mistake of letting this get personal for me. The network of lies that he built in his cover up directly implicated me and called my integrity into question - I would be lying if I said I didn't gain some enjoyment out of extracting the conclusive proof. That was a mistake and I apologise. &gt; The export of the drama from here to other PHP communities and groups. His actions raised questions that the FIG needed to responsibly answer. The only person who is responsible for those lies escalating inside the FIG is him. Had he come clean with an apology there probably wouldn't have even been a vote. &gt; No longer valuing things based off of actual technical merits, but off of the heroes and villains involved in the community. You're welcome to keep the company that you choose. But I certainly will cease involvement with the FIG if it requires the name I use professionally to be associated with his fraudulent behaviour.
[GitLab](https://about.gitlab.com/) is pretty good.
1. I really don't need to be involved in this project except in spreading the word as the whole concept is based on the community. No need for me to spend as much as it would require in PHP-FIG to justify a "membership". The good think about that concept is, nobody cares about my opinion on a particular PSR that match, so there is no need to have more time reserved. I just vote, like everyone. 2. Honestly, you should rethink about your words. What you basically describe is completely contrary to democracy. The community is everyone, not only self-defined elites. So everyone needs to have the right to vote, comment and propose things.
If you want issue trackers, wikis, a web management interface for adding users, etc etc, use GitLab or Gogs - if you pretty much just want git and a web viewer, gitolite+cgit is very lightweight.
I understand. In any case I like the approach and broader inclusion of the PHP community so I'll follow this closely.
+1 for gogs, we've been using it and it's almost an exact copy of github gui. Really convenient, feels like home.
I've just set up [gogs](https://gogs.io/) at home and very happy with it so far. Another option is gitlab. It sounds like you're looking for just a repository browser, rather than a full management interface like gogs, but I've found bare, shared git repositories within a team are a lot of hassle.
I would really recommned GitLab. It is an excellent application. It can be a bit tricky to set up, but it is totally worth it. You basically get your own "github".
Use the tab key, but have your text editor spit out the appropriate number of spaces instead!
You're missing the point. It's not about elitism, but quality responses. Say what you will, there are morons out there, including me in some scenarios. It's a reality. Everyone can vote, yeah, relax your "community" fist-raising. If wanting quality makes me an elitist, I'll gladly accept it. I think one reason FIG relied on popularity is that it's one politically-correct/social-vague/community-friendly criteria of being "good in what you do" - aka "professional". That's because, without it, you'll end up with numbers winning - instead of quality. That's always a problem with democracy: how to yield good results, without leaving people out. Not everything is a matter of popular opinion, you know. This is not "what's your favourite color?". Some say FIG is too elitist (I don't know about that, don't really care). But if they are/were, you're going in the _opposite_ direction. Which is not that good, either, but definitely better than having 10 guys voting for the rest of us. So yours makes it better for us, code grunts.
Completely ignoring the fact that this organisation claims to be both for creating standards and not creating its own standards... Using the same terminology (PSR) is a bad idea. Come up with your own names (call the CDS-# or something). It's also going to be massively confusing if you try to ignore PSRs which actually exist and are searchable on the internet. Additionally, trying to dictate the people ignore standards produce by another group is just dumb. People can decide for themselves what standards they want to use. By doing this your are immediately putting yourself at loggerheads with the other organisation and creating a magnet for drama and strife. In my opinion, the belief that just because there is no formal membership, you won't get any kind of "lobbyism" is dumb and misguided. There will always be people who try everything they can to get their own way, regardless of whether it's what everyone else wants.
So like $50 of RAM? Isn't providing a good tool to your development team worth a $50 one time cost?
I'm going to say that I don't really think an open system like this could work. One of the criticisms of FIG is that it was a small group of monolithic (in terms of influence) frameworks and projects deciding things that they may or may not have been right to decide. But, isn't that why it worked? Take PSR-2. It's got holes in it, but it's considered the closest thing we have to a real standard. Tabs vs. Spaces wasn't settled for a long time. Hell, I'm a tabs guy, and most places I worked at pre-PSR-2 used tabs. But then PSR-2 came along, and all the big players said "This is it, this is the way things are working now" and now almost everyone I know conforms to PSR-2, or some standard that extends it. Even if they disagree, it's become the definer. Same with PSR-4 and PSR-7. Sure, PSR-4 was going to come naturally, PSR-0 was describing what already existed and PSR-4 was the next natural step to PSR-0. But it went from "Would be real nice to autoload" to "Well, now we have the standard, and now we have a tool that uses that standard". Maybe the same could happen with CDS. Maybe. But all I know is that before FIG, we all knew roughly on some standards, but the whole "usage will win out" thing didn't really work, did it? People went their own way and only integrated when needed. If Usage Will Win Out, then FIG would never have been needed in the first place. I guess what I'm trying to say is that having community driven and sourced standards doesn't seem like it's much different from the "Everybody do their own thing" that happened before FIG that accomplished nothing.
&gt; Completely ignoring the fact that this organisation claims to be both for creating standards and not creating its own standards... "community is making standards" vs "php-cds" is making standards" is fundamentally different. Since PHP-CDS has no members, it is not able to make own standards. That's it what it means. &gt; Using the same terminology (PSR) is a bad idea. Come up with your own names (call the CDS-# or something). It's also going to be massively confusing if you try to ignore PSRs which actually exist and are searchable on the internet. I believe in the opposite. I believe it's very good. Nobody said PSR7 exists or not, they are there if you search it. How says that PSR-CDS becomes the new single-point-of-truth? Nobody. What needs to be avoided is that PSR names collide. Then it's easy to find the author of the PSR. Since PHP-FIGs PSRs has numbers and PHP-CDS not, it's easy. &gt; Additionally, trying to dictate the people ignore standards produce by another group is just dumb. People can decide for themselves what standards they want to use. By doing this your are immediately putting yourself at loggerheads with the other organisation and creating a magnet for drama and strife. First of all: Please stop being so aggressive. That doesn't help anyone. Nobody dictates anything. As you said already: You are free to accept any standards you want. If you like PHP-FIG adopt it, if you like other standards use theirs. Also please read https://www.reddit.com/r/PHP/comments/4j05df/phpcds_php_community_driven_standards_alternative/d32jjwf about that. &gt; In my opinion, the belief that just because there is no formal membership, you won't get any kind of "lobbyism" is dumb and misguided. There will always be people who try everything they can to get their own way, regardless of whether it's what everyone else wants. There is nothing said about general lobbyism. There is always lobbyism. However, it's a huge difference whether the organisation that proposes standards is able to do actually lobbyism inside and is able to suppress ideas, thoughts and comments beforehand or not. PHP-CDS does not have any members, so there's noone able to suppress upcoming ideas, lock stuff etc. Only the community decides. I quote from the readme: &gt; Due to the fact that there are no members involved, there's no in-house lobbyism. That's a huge difference to that what you said.
What would stop people such as Dracony from using his spambots to influence the standards instead of using his spambots to gain a vote on the PHP-FIG? Arguably malicious people could gain even more voting power with this system, no?
Well, what do you expect from community to decide on those? I believe it is hardly viable to change those 4 PSRs just because majority of people are using them "because they are standards". Some people I've being talking to do not admit that some PSRs can be (well, not wrong, but) even better, they just take it as fact unconditionally. TL;DR: PSR-1..4 might be better taken as is (though, I don't personally like some points in them), this is my own opinion.
Why are you not just using the bit bucket installation you've already got? Sorry am I missing something? Did you blow past he 10 users level or something? Edit: are you using atlassians hosted bit bucket? If so why not just run your own internal bit bucket server? That's what we do at my company. 
the whole CoC issue left a lot of people angry and frustrated. Definitely noticed the "gud" post count on this sub-reddit diminishing over the past year.
While a "free for all system" may seem like a good idea, standards have never been effectively made this way. Standards have (usually) come from two main paths: evolved over time because it's a best practice with the language or a smaller, select group has focused on creating and refining them into something the community needs and can use in the real world. I'm not saying that there's not smart people out there that could make this happen but, well, you've seen the recent catastrophe that's happened even within an organized group like the PHP-FIG. They're a group dedicated to making these standards happen, including champions of each cause according to rules set in place. With an open system like the one suggested here and no real accountability, I just don't see any standards evolving into something useful and refined. Given the types of "discussions" that happen here on /r/php and in the various mailing lists (even just around RFCs for PHP) I think - especially without some kind of moderation - not very many useful things would come of it. The optimist in me likes the idea and wants it to work, but the realist in me just doesn't think it will. I think one of the reasons the PHP-FIG was able to define the standards it has (and will) is because of the dedication of its members to see things through. I'm not sure that kind of dedication would happen here. Starting over with a completely different process is not the answer here. Refining what's already there into something more effective is. The PHP-FIG is learning from past mistakes and is evolving even as you read this into something different and, from what I've read of the new standard, more effective at their work. I want to thank all of the current (and previous) members of the PHP-FIG that have gotten us this far. Your work helped to usher in a new era of modern PHP that I wholeheartedly believe we wouldn't have reached on our own.
&gt; I'm not sure that kind of dedication would happen here. I guess the only way to find out is to find out. :) I see your concerns about how standards become standards. I think the same. I also think standards are self-evolving, so when there are several for the same purpose, evolution will pick the right one. The aim with PHP-CDS is the same. Propose stuff, throw it out and let all decide if its becoming a standard or not (not by voting, but you see whether its becoming a standard by the usage/adoption). Completely self-evolving.
I like the idea. Mostly I didn't like the underlying "elite" concept of the FIG. Let's see if it is possible without cacophony. Besides, do we need standards? I prefer design patterns. I would rather discuss the sad direction taken by the language itself. 
I'm not sure to be honest, looking at the last version it was plain text so I'm not sure what the rationale was for md5, probably just to get a predictable length/format string but I'd be second guessing there. I can't really see there being a collision risk, since the collision wouod have to happen within the 60 minute time window of the token being generated and then even if a collision did occur nothing really happens, two users with different ip addresses would generate the same token that would be stored in their user account table, but the two would never really meet. I'll raise an issue on the repo and see if there is any more to it, but IP address in itself is not really that hard to spoof, so all this does is add a little extra friction to a bad actor who wants to try and gain access to an account.
&gt; If there are two variants (e.g. coding style with tabs, one with spaces): then the community decides through evolution who will win. Haha, lol. Any historic examples of one side of a perpetual holy war ever "winning"?
https://xkcd.com/927/
The discussions often resemble discussion about patterns. I think, as long as it's only about interfaces, it could be "standard". But it means it must be on items that needs interoperability. Only. ie fake example: Logs. Do we need a standard interface to be able to replace a logger by another? (rather than: let's state that the standard is now Monolog) "I quite like pretty much everything added to PHP in the past 8 years, actually." &gt; there are a lot of good things. But it's like PHP wanted to become Java. 
This is what I prefer, but I've sacrificed my personal preference to follow the "standard"
I agree when considering the entire implementation of caching in an app. There are better ways to handle the maintenance of TTL. I disagree when I consider whether it should be standardized at a level like the PHP-FIG that TTL is not an interface concern.
Someone post that XKCD where the punchline is "now we have 10 standards"
Could also try Phabricator, built in PHP and all. It's pretty nice.
Great read, thanks for the link :)
OK, i probably don't have the complete picture, but damn Andrew Carter really HATES that PHPixie dude. It's kinda funny from where i stand :) did the guy steal his girlfriend or what?
&gt; But I think it can handle much more. No it won't and you will see that when you will have at least some decent traffic. You are running it with only 1 GB because you have setup at least 1 GB of swap. It will run with swap, slow like a drunk snail, but it will run. 2 GB of memory it is the minimum recommended to run an installation for &lt; 100 users and even then can run pretty slow.
$40 a month for 4GB on vultr. About that much on AWS, too, before bandwidth costs, and $27.15 for 3.75B with a 40GB disk on Google Cloud Compute before bandwidth costs. Assuming you're employing a handful of employees, paying taxes, and just about afloat, $40 a month is pretty much negligible. It's the sort of thing that in many companies, your boss would be annoyed if you bothered them about it instead of just going for it on the company card.
Oh trust me I know... I just moved a server from a co-loco DC [$400/mo] to the cloud and saved literally what... 90% ... When someone says its a hog on RAM i immediately think MS SQL SERVER which literally eats all the RAM.
&gt; Do we need a standard interface to be able to replace a logger by another? (rather than: let's state that the standard is now Monolog) I feel like the answer to this is essentially the same as "why rely on an interface instead of a concrete implementation?" There are tons of well-defined reasons. What if I wanted to enable SMS notifications for certain log entries for a particular library, but it only supports Monolog internally? I would be forced to fork and subsequently maintain the package. The PSR enables me to decorate or replace Monolog with something that supports SMS without any other part of my application having to care.
Shh bb it's okay. We'll call it the multispace key instead.
With all sincerity: best of luck.
You don't need hundreds of users to push your Gitlab instance to its limits, considering that you are running it with only 1 GB of RAM. A few users online at the same time will be enough. Run some diagnostics and you will see what I mean. For personal projects I can't find any good reason why someone would prefer Gitlab over something more light and fast. I can't find any compelling reason at this point in time to push a machine to its limits with a Gitlab instance when I have an alternative which is not memory hog.
It's not a fluent interface, it's an immutable interface :P I wrote a lot about it at https://ocramius.github.io/blog/fluent-interfaces-are-evil/, btw
Oh. Well why don't they spell that out in the code? Why do I have to read an entire page of documentation, when a more clear and concise code sample would do. A lot of its documentation assumes that you're already a seasoned Symfony developer. I am not. This authentication section is awful. It basically made me dump using Symfony, because I don't understand it. Simple as that. I've been working in PHP since 1999, and honestly this manual makes me feel really stupid. I've asked for help, and have gotten useless irrelevant responses, or none at all.
&gt; Since PHP-FIGs PSRs has numbers and PHP-CDS not, it's easy. You are there assuming what the PHP-FIG will do in the future. Honestly, I wish this all the best. But using the same namespace as an already active group strikes me as picking a fight when there is no need to. Use a different PHP namespace, let each group do it's own thing and let the community decide which to follow over time.
Am I too late to bring up inline styles? (edit: inline not online...FU autocorrect)
SugarCRM development was my first web dev job at an actual company...I still have shakes.
If that works for you, awesome! Yes, I had some issues with Gitlab which made me search for an alternative. Those issues are mostly about performance (_can become slow at random times and for unknown reasons_) and high memory usage even during the night, when there where no users online. Leaving those issues aside, it is a great piece of software.
I think he secretly want to bed me
Well, for 2016 at least, I anticipate having more private repos than I do having more team members added, so this pricing model works well for me.
I fully agree. Just call them CSR (Community Standards Recommendation) or something. Also, numbering them is smart. Much easier to uniquely identify them and shorter to refer to. RFCs and PSRs use them for goid reason
The key point with the mechanics is that while they definitely have some standards they are vague. Every mechanic will have a metric socket set, and an imperial one. Plus they will have a broad range of sockets. There are actually very few standards among manufacturers. If you look at something as fundamental as hydraulic disc brakes, there are almost as many ways to attach them to the car as their are models of cars. Usually each manufacturer will have a certain flavour they stick with for a number of years, and a few models might even use interchangeable parts. But at best the standards among manufacturers would be best described as roughly inspired by each other's innovations. The simple reason is if they locked into a standard on the various parts, then cars would probably get stuck in some old shitty design. The freedom to continuously innovate is critical. This is why I am extremely happy to see the PHP-FIG burn in hell. This is the sort of shit that kills a language. Sticking to someone's "best practices". What would be next? certification in that standard? 
The only way for this to work is if you only allow standardizing an interface that already has an implementation. In that case you'll avoid the "now, who's going to build it?" problem that the FIG didn't have. If you take the implementation-first approach it might actually work.
We have already enough people on board that have pretty known projects, who are likely to adopt new standards from this community. So, I don't think this approach suffers from that problem.
Pure democracy doesn't, and arguably cannot, work. Not everyone interested in or affected by a topic is knowledgeable enough (either in general or on that topic) to have guiding control over it. A lot of people are interested in cars, most drivers don't know enough about vehicular engineering to actually design one. And that's perfectly fine. The frameworks are "elected" by popularity, the community having unofficially decided they have their shit together, and we casually trust them to make good decisions...*as they've already been doing*. 
you must be new on the internet ))
&gt; basically allege that the mass will not be able to make a "quality decision" Ok, I'll flat out say it. Just because you are a PHP programmer and *use* it doesn't mean you know what's best for the language, and your view will tend to be very myopic: how does this benefit *you* and *your* projects? It's the same thing with, say, taxes. Very few people will ever vote to raise taxes on themselves. But sometimes taxes need to go up. Sometimes you have to vote against your immediate self-interest for the overall good of the community.
True. Using interfaces is always good (except PHP implementation of interface is not as good as Java). I would love having somthing like typescript's implementation. 
I don't even need to click to make sure it's what I think it is. Upvote.
&gt; While a "free for all system" may seem like a good idea, standards have never been effectively made this way. Rust does it this way.
This assumes multiple things 1. Experienced people are involved in a particular RFC 2. That they become involved before the majority of voting progresses 3. That inexperienced people can find the comments by experienced people 4. That inexperienced people will listen In particular, 2, is difficult because there is no discussion time before voting begins. 3 is difficult in part for the same reason because once you vote there isn't any incentive to return and check the status of an RFC. Further, if an RFC is contentious or popular there may be too many comments (perhaps of the +1 and Me Too! sort) for a reasonable person to read through to find the expert comments. The system, as described supports mob rule over the actual needs of the community. In reality, it is little different from searching Packagist itself and sorting by popularity.
We both don't know how this will concretely work and ends. Just sit back and enjoy what happens. In either way: we will surely learn something new.
hehe I like that too :) just out of curiosity, is there another relevant recommendations making group than php-fig yet?
Such a shame really. What it *does* fills an amazing gap in the market. How it is written layers up over a decade of technical debt that means what should be the simplest of things to do, are immensely cumbersome and long-winded.
What it does is fantastic, and the degree to which you can customize it is the quality that kept my client working with it. It's just so damn frustrating to get to develop new, useful functionality that in subsequent years I turned to using it as-is out of the box if I used it at all :(
I don't think you deserve this, even if you did use bots, I don't give a hoot; the nonsense being touted is all worse than what you have supposedly done. Worst case they reset the counter and ban the IP's used to download, or something else to that effect. If anything botting the system helped to expose a flaw in the vanity stats; 
This is too close to a personal attack for me to leave it here and feel right about it. Please expand it to a clear criticism, so it's clear that it's about what he's done, not who he is.
A community only exists when there is a diversity of people. People are fleeing the community left and right, because they feel it's only a matter of time before they're personally targeted for who they are. Being different or controversial is turning into career suicide, with all of the witch hunting, and people calling for personal consequences for unpopular beliefs or actions.
Just went through the pain of installing an after-market stereo. The auto-industry could definitely use some wiring/connector standards in that regard.
we need superdelegates!
[removed]
Honestly I don't remember anyone complaining about any of the old ones except the coding style ones which died down once you pointed out that it was good because now everyone is unhappy instead of it just being the lead that is happy.
Was pointed to this thread and just wanted to say, yes, this is exactly what's happening.
Stating the facts about a person and their character isn't being unprofessional, nor is it a personal attack. And who is this "we" you speak of in this "community?" I get paid ~~very handsomely~~ Skittles to develop enterprise-class PHP applications, which pretty much is a definition of "professional" work, and I never subscribed to this community ideal that you can't make your opinion of a person known in a public forum in order to warn others of their nefarious behavior. I'm not writing off dracony, either. If anything, I want to see him do better and succeed and earn the respect he so clearly craves. But on the right terms and after he's done pulling his inane shenanigans. Anyone who wants him to do anything more than own up to his actions and do better in the future, I am not in agreement with. But I'm not going to sugercoat my current regard of him, either. It's when people tolerate bad behavior in the name of harmony that bad behavior proliferates. Stand up, tell someone exactly why they are wrong, and if they are penitent help them do better in the future. Conflict and drama are not elements to be avoided, but resolved.
Can you please explain to me why the mods locked this thread this morning? There was no reason given, and no one responded to my mod message (although the thread has obviously been unlocked so someone clearly saw it).
No. However, if Rust’s standards-making procedures have been effective, then that stands as counterexample to the assertion that “standards have never been effectively made this way.” *Disclaimer:* I am familiar neither with Rust nor with its standards-making process. The above comment intends no assertion as to the effectiveness of either.
&gt; Of course there are always trolls, however I believe the majority is interested in having a good future. Unfortunately, it does not take a majority to ruin an otherwise good thing. It is important to expect the best from people, but to prepare for the worst.
Design by committee is an anti-pattern where a product or standard is decided on by a large group of folks with different requirements in the absence of strong leadership. It tends to lead to products that give compromise the highest priority. That usually leads to a product that doesn't meet anyone's requirements or leads to products not being built because the group can't come to a consensus on what to make. More info is at https://en.wikipedia.org/wiki/Design_by_committee . 
Thanks! Didn't know that. We will see how it turns out :)
You are not alone! I much prefer tabs but the tyranny of PSR-2 rules at my workplace :(
[Great minds discuss ideas; average minds discuss events; small minds discuss people...](http://www.brainyquote.com/quotes/quotes/e/eleanorroo385439.html) 
I am curious who the people you already have on board are. What projects. I see php-cds as a way for you to gain traction at a time of duress in another already established set of standards recommendations. I dont see how something like this will work without a body behind it outside of the community as a whole. 
Love it or hate it, there's no point in abandoning ship just yet.
**T O P** **K E K**
Gitolite works great. All management of repos and users is done through a master repo. Throw it up on a Linode $10/month server and be done with it.
[container-interop](https://github.com/container-interop/container-interop)?
Yep https://r.je/php-psr-0-pretty-shortsighted-really.html I recall also some unhappy people with PSR-4 :)
Oh definitely, and it amazes me every day that the people that speak out here and in other forums don't think about the fact that they are the leaders in this situation. There are some that put fingers to the keys to voice their opinions in Reddit comments and focus on sharing only that. They don't think about how this silent majority would take those comments. They don't realize that, even if they're not in the PHP-FIG or an internals developer, they are helping to shape the community for better or worse. There's a constant cry around here for constructive comments and posts rather than sensationalized stories revolving around a small group that most of the readers may not even know. Would people comment the same way or post about the same topics if they knew that just by the act of posting they're shaping the community?
I'd encourage you to raise that as an issue. Feel free to raise it with me directly, if you think I may be able to help. I like to think I'm a reasonable person, so I'd be willing to address it alongside you, even if it relates to a topic that I stand in opposition on.
I try to be very precise and very limited in the rules I set when I have to. Our rule relating to this is "No direct, personal attacks". The wording of that should speak to exactly what I mean. You can criticize someone, you can swear up and down, you can be a complete asshole about it, but you may not directly insult someone as a person. There is nothing good that can possibly come of doing that. Criticism is allowed and encouraged here. Personal insults are not.
You should talk to github and advocate for outside contributors not counting against the limit... Spark can't be the only pay to play with repo access project out there.
In my mind, it's that there is a greater culture war going on in the world with respect to identity politics and "social justice" (which is just a synonym literally and in spirit for mob justice). We are seeing the manifestation of this in our own community.
There should only ever be a single environment through the application runtime. Global state is usually bad when it's mutable or makes code hard to test. This is not given here, it's immutable and easy to test. In this case a global variable is a far simpler design. Without global state some part of the application could run in dev mode and some other in production. Here are some great articles on why DI is sometimes not the best solution: http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html and https://gist.githubusercontent.com/raw/4466492/2ebbe8ba20f7ec37c8e19dde280323ee04e1a535/gistfile1.txt
This thread could benefit from the omission silly gifs and pithy comments in favour of something approaching sober conversation.
Is there a particular reason you're locked to a shared host for a prototype? Why not just spool up a $5 / month Digital Oceans VM or an AWS EC2 instance? I don't have experience with any of these on a shared server, however I know some of the more slim frameworks are: - Slim (heh) - Silex - Lumen
I've asked, my boss says no. We're using an existing shared host. Just don't ask, it's already driving me nuts. I've been looking at the microframeworks and they seem too light, or something, so I'm wondering if there's a happy medium out there somewhere that'll play well on a shared host. Like CI except not ancient. 
Are you sure you don't use any component at all from these projects: Composer, Agavi, Assetic and Buzz, Aura Project and Solar Framework, CakePHP, concrete5, Contao Open Source CMS, Drupal, eZ Publish, Horde, IBM i Toolkit, Icicle, Jackalope, Joomla, The League of Extraordinary Packages, Lithium, Magento, PEAR, Phalcon, Phing, phpBB, phpDocumentor, PHPixie, PPI Framework, PrestaShop, PyroCMS, ReactPHP, Revive Adserver, Sculpin, SilverStripe, Slim, Stash, Stormpath PHP SDK, SugarCRM, Symfony, Neos and Flow, Wikibase and Semantic MediaWiki, Yii framework, Zend Framework 2, Zikula?
Composering! 
I have yet to see the "insult" aspect in what I said. You can take each aspect of what I said and find mountains of evidence for it as a fact, not an opinion designed to harm an undeserving reputation. "prolific" "unrepentant" "liar" Where is the insult? Where is the fact?
You can mock environment variables with something like: function mockEnv($name, $value, callable $context) { $previous = $_ENV[$name]; $_ENV[$name] = $value; $context(); $_ENV[$name] = $previous; } mockEnv('PHP_ENV', 'production', function () { assert($_ENV['PHP_ENV'] == 'production'); }); &gt; Also it's much more simple to have simple classes that do only one thing, and then compose then through configuration based on the environment and other values. Yeah, polymorphy is actually a really cool way to handle this. Because of the many different ways of doing a implementation of environment management, the discussion has moved more into the direction of specifying a default environment name and a default value set. It's still in a discussion phase, so feel free to jump in at github and let us know your thoughts :)
Please keep it civil.
I hate this "use a framework" attitude, it's becoming as bad as the JS JQuery guys. Yes, in a large enterprise setting it's a good idea, but for learning and practice all you end up learning is how to use X framework and not PHP
I still have this experience. Thx npm install!
Seems outdated. In general, I endorse staying away from the `resource` type nowadays, unless hidden behind a better userland interface. This is mostly due to `resource` having loads and loads of quirks, including their messy stream wrapper API.
I'm sure it's easy to avoid all of those projects when you spend all your time reinventing the wheel. No sweat!
What would be your direct recommendation? I'm in the process of writing some code that loads a huge JSON file, so I'm all ears here.
Holy shit this guy is obvious as hell. In my years of moderating online communities I've only seen a few people go to such... sociopathic lengths to make every self-incriminating mistake look like a personal attack against them.
If you load huge files, I'm afraid streams are indeed the way to go, but I'd still wrap them in a tiny iterator, for example (rather than buffering and looping manually) due to how messy they are. Generators are also fine there. The article suggests using streams whenever there is a file name somewhere: I would agree if streams in PHP weren't so ugly and quirky.
Also you could use and RRule library like https://github.com/simshaun/recurr
Somewhat related: I wrote an API for [simple file cryptography in Halite](https://paragonie.com/blog/2016/05/solve-all-your-cryptography-problems-in-three-easy-steps-with-halite#file-cryptography) that accepts either a filename or a resource. Which means both of these will work: File::encrypt('foo.txt', 'foo-secret.txt', $encryptionKey); ...or... $inputFile = \fopen('foo.txt', 'rb'); $outputFile = \fopen('foo-secret.txt', 'wb'); File::encrypt($inputFile, $outputFile, $encryptionKey); Internally, it creates an object that wraps the resource (i.e. `ReadOnlyFile` which aims to prevent race conditions especially for file decryption, and `MutableFile` which is where output is expected to be written) that abstracts these operations away (and checks for failures every step of the way). I suspect most folks will want to use filenames.
Don't tell my boss.
That sounds really terrible to me. Swapping global state when running a function is basically like shoveling dust under the carpet. Relevant: http://imgur.com/c4jt321
[async-interop](https://github.com/async-interop)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I normally use [SplFileObject](http://php.net/manual/en/class.splfileobject.php) as it is easy to mock and can be type hinted (at least until a native resource type hint is added)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Election of what, government? Government forces you to do something, PHP-FIG or whatever alternative suggests you to do something, but eventual choice is always yours. I'm libertarian, if you know what I mean. But this is clearly off-topic if elaborate on this here.
You can pronounce it as see-a-mess.
Why?
I am using a plugin called tempo in Jira. It comes with a tracker to log time. When you stop the tracker, it automatically brings up the log time modal for the ticket you are working on with the fields pre-populated. I finid this very useful. 
I answered a question on StackOverflow a long time ago pertaining to this: http://stackoverflow.com/questions/5925356/reasons-to-not-use-a-php-framework/5925446#5925446 Building my own framework was a great learning experience, but for actual deployment and everyday functionality using a pre-built one that has dedicated maintainers is the best.
This is an awful tutorial.
I'll try to recap answers and let my own slide in aswell * Look towards other projects and try to understand why they did it the way they did. * Try to create something unique. Not everything has to be reinvented but having an thriving idea helps * You have to remember that it's going to be an throwaway product, yet you will definitely learn from that * If it's for yourself, optics don't matter that much * Maybe try to decipher patterns that occur to you in development. And ask yourself, is there another way to solve this. * Have fun
I use laravel and just use the htdocs to redirect the public folder. 
Spaces don't seem to be rendered correctly in code blocks, e.g. `&lt; body &gt;` doesn't look right. If you're the author, can you tweak the CSS? Hmm, after the "PHP Echo" chapter, the next one is "Remove empty null undefined values from JavaScript Array", which doesn't seem very related. 
Modern trend for CMS is adopting frameworks or their components or widely used libraries. Before creating CMS I would learn some common libraries / frameworks. (routing, authentication, athorization, templating, caching, ORM). {{knowing composer is assumed prerequisite}} There are also Content Management Frameworks (CMF) for example [Symfony CMF](http://cmf.symfony.com/get-started) they provide decoupled components for creating customized CMS. So you can learn and use only components that interests you. If you want to dig into code of existing CMS I would suggest [EZ platform](https://github.com/ezsystems/ezplatform) - established and stable CMS, but very active, last year they finished adopting fullstack Symfony framework.
Once again, the community is wider than you or Reddit. Your experiences sound terrible but they in no way signal the death of the entire PHP community in any way that I would personally agree with. You've just had a shot time of things and I wish I could change that for you.
... http://www.reactiongifs.com/r/whaaa.gif
For a beginner I would say, no. A CMS has very very much components, much more than you are thinking about now, believe me. All of these components also require much more of your time thank you would think. Especially when you are a beginner and do not yet have a lot of experience. If you want to become better at programming in PHP, look at some **modern** PHP frameworks like Symfony2, Laravel or CodeIgniter. Create something **small**, but do it **perfectly**. Use all the modern tools and conventions. Let your code be perfect. There are tons of tutorials available for that, you will not find any tutorials on how to create a CMS, just because it would need to be a huuuge tutorial. Never think 'I'll do it messy now, but clean it up later'. That is definitely what will happen if you start developing your own CMS, because it is just simply a tremendous amount of work. Source: I have created my own CMS from the ground up. And I know it would have been a disaster if a had tried to build one when I was still a beginner. I think it would have been very discouraging.
You don't get it, do you? When you say "There are no black swans" and some guy tells you "Look, this is a picture from Australia. See those?", *you don't get* to moan and groan that Europe works different than Australia. Relax, only your assertion was attacked.
besides learning coding - never do it on your own, syndicate an existing one, i personally always took wordpress in the past, considering using bolt in the future instead as it has much more modern code and getting to a maturity level where it can compete. 
&gt; Which leaves them open to be able to enforce it later or they're already planning to enforce it later. Indeed. They also, in the same sentence, go on to say that if they do announce a switch, they'll give 12 months notice. (or at least, that's the way I'm reading it)
I think annotations are really useful regarding serialization, validation, entity frameworks and general meta-information, but they shouldn't contain any kind of expression. I don't like this RFC, I liked the "annotations" RFC that Guilherme Blanco wrote in 2010. It was simple, it only allowed scalar values and it used single &lt; and &gt; (I don't exactly get why Hack uses them doubled). It also was simple to use, you just need to extend a class and it gets loaded via normal autoloading. Every annotation is a valid object instance. It seems most people here prefer folders of hundreds of configuration files. I mean, most frameworks out there use annotations really successfully. I see the JMS Di Extra Bundle in every symfony project I encounter and the laravelcollective/annotations package has 235 daily downloads. What you're doing with declining annotations is just cluttering the code-styles of people even more. Everyone can create their own fancy annotation syntax based on DocBlocks and needs expensive caching and fetching mechanisms. Hooray! We need annotations. But I'd rather have Guilherme's RFC re-validated.
Would you be able to elaborate on some of the quirks?
From what I've seen resources are the only things I can't type-hint for in PHP 7 as well.
No one is going to take this seriously unless you unit test. I think it's rude to ask for a review until testing has been completed. 
I am not a native English speaker so I was wondering which is correct.
Except none of the existing CMS's are really good.
Hello, I've just developed this last night so unit testing will come gradually. Don't judge me, I've just wanted to know if people are interested in this and motivate myself to allocate more time to this.
Well the cookbook entry you posted is about creating a User entity without doctrine. You do not need Doctrine at all. The issue is that you started with Symfony standard edition which is a RAD tool. After a while you know what you need and what you do not need. Since we started talking about documentation, a few "googles" away are also these two entries: * How to Build a Traditional Login Form: http://symfony.com/doc/current/cookbook/security/form_login.html * How to Customize your Form Login: http://symfony.com/doc/current/cookbook/security/form_login.html I do not know much about Guard since I do not use it. Symfony and other frameworks are nice because you gain knowledge that you can take from project to project. Working in teams is also easier because there is some common ground where things are and how they work in the infrastructure layer. Not to mention that is is easier to bring in new developers and handle tasks that could take hours to solve with your custom framework because you didn't think of that use case when you were developing it. It is nice to have all these tools by your side. When you now what you do not need you can strip it out. I highly recommend reading this article if you haven't already http://symfony.com/doc/current/create_framework/index.html You do not need the full stack Symfony framework to benefit from thousands of hours that were put into developing/researching/bug-fixinging each of these components.
Look great! I'll be incorporating this into my own ldap package. Nice work.
&gt;This results in blind and stubborn beliefs (for ex, if you are not going SOLID, you are wrong...) haha, it's so much better to have absolutely no standard whatsover and believe as in JS. More seriously there is stubborn people everywhere and everyone has belief, it's not about PHP.
Aren't Lumen and Slim the opposite of lowest required effort? They provide you with the minimal set of tools that you then create your own abstractions on top of. Symfony, Laravel, and APIgility come with the kitchen sink and all the opinions dealt with for you so you're doing less thinking and less coding yourself.
That's an indication of mandate bloat if I've ever heard one...
I agree. I also think the group got far afield of what sorts of things really need to be standardized.
&gt;give me some feedback &gt;don't judge me Make up your mind.
I agree I would abstract it further (and not using resource or filename at all).
+1 I'm happy with gogs too
oh god incoming drama llama post.
There is nothing to be ashamed of. Software development is a journey of learning, and nobody ever gets it 100% right. There is always something can be done better, or a process that is more suitable in one situation or another. Every day is a school day..
the problem of making your own CMS is that it's a very complex topic that others already solved. Probably better than you could. But if you learn their approach, you can learn a lot for your own coding. The other problem is, that CMS is already an outdated concept. It was flawed as it made things more complex for developers, since users should be able to change everything. On the other hand users didn't like doing it and developers were stuck with methods designed for people without programming skills. The more modern approach is to use Frameworks and to include the packages you want for your project. start by looking into OOphp, Frameworks like Laravel and git versioning. Mastering those three should give you enough tools to make really awesome projects. Just trying to make your own CMS will only show you where you would have done things wrong and end up with you using a 3rd party product instead. You will learn a lot of things, but none that you wouldn't learn by trying to understand existing code. 
My advice for anyone building a CMS is to focus heavily on your data models and schema. After all, the purpose of a CMS is to fundamentally manage data. Get this right before even writing a single line of code. I can't stress that enough. Without a well executed data layer, your system will suffer from day 1.
Wow. Andrew traced his ip with a gui. Just like in csi 
Interesting.. I was just contacted about a WordPress job in Colorado that pays $115,000 a year. I'd definitely switch to Drupal to rake in $1.2 million a year.
Drupal is the biggest piece of over-engineered crap ever. 
On top of that he faked an email as a Russian, lol
If you are serious about wanting to learn how to build a CMS, and do not care about what everyone else here is saying, there is one piece of advice from a developer on a 4 man team who built a custom framework to enhance the speed of development in our workplace: Take ideas and concepts from the bigger, more highly maintained Framework Systems and implement the features you want / have interest in but implement them in your own way, that makes your life faster. Ultimately the reason a framework should even be considered being built is if you intend to use and reuse, and hate it some days, and praise it others. If it is not making your job easier down the road with other projects, then at least you can say it was a learning experience. If you are doing one-off projects, please use something like Laravel, or Symfony or anything else that is out there.
Maybe you could contribute to the https://github.com/Adldap2/Adldap2 package as well - I know his library has it's own builder.
The credits for that go to the EAV (Entity Attribute Value) model. The thing is that in order to make an RDBMS very generic (and not specific to say an Accounting or Inventory system), the data has to be contained in generic *entity* tables where each data element is not a field in a specific table (say product.id or orders.date), but is stored as *attribute-value* pairs inside a row of a generic entity table (say item.attribute and item.value). This type of database design makes the system very complex to understand and cumbersome for the data to be queried, linked, sorted, etc. However, since Drupal wants to be an "all in one" generic kind of CMS, this kind of design is the only way possible there. In other words, its a necessary evil.
Wow, nice. I didn't know about this package. After I will get my package to a ready for production stage I will contact him for contributing.
It was good for us, we saved 50 bucks a month. We have a small team though (6 people), for larger teams I'd imagine it's more expensive than Bitbucket now.
Disagreed. What a CMS like Wordpress gives you out of the box is not that difficult to spend some time building into a simple, ***low assumption***, reusable package for a REAL framework like Symfony or Laravel, and then you don't have to deal with all of the technical debt that is the Wordpress code base. I have never had an "easy" or "fast" time building sites in WP, Joomla, or Drupal. To be fair, I've not tried newer, modern CMSes, but working with the "legacy" CMSes is like trying to put out a dumpster fire with gasoline...
&gt; never do it on your own ... except you have a good reason to do so.
You have no chance. If you are going to use tutorials, you'll end up with the same old shitty CMS types like drupal or wordpress. We need to innovate. But CMSystems are just so tricky that no-one wants to deal with it. If you really need a tutorial... google it.
phpStorm will highlight the variable unless you do a instanceof or isset() iirc.
https://github.com/fzaninotto/Faker is great for acceptance testing
&gt; the problem of making your own CMS is that it's a very complex topic that others already solved. Probably better than you could. I hate this argument. The "dont reintent the wheel" argument is one that hinders progression in development. Without this argument in place, or for people who ignore it, is the reason we have great new frameworks being rolled out. If Taylor was told not to reinvent, and he listened, the Laravel framework would not exist.
&gt; Please keep in mind that all attributes or values will not be LDAP escaped. You have to do that manually. People won't. Are you interested in making the LDAP escaping automatic?
Wooh! Simply brilliant. It often takes a lot of time and work on a particular subject to be able to take a step back and realize there is such a simple solution available that fits the needs of most people. I love how easy to understand this is (both from a framework developer and from an end-user standpoint). I would never have thought about such an idea, and yet, now that is is here, it seems obvious. And so many advantages... (easy code completion in the IDE, ...)
Here's some meta-advice about CMSes: A pre-built, "General purpose" CMS designed to be as flexible as possible so as to be able to build any kind of site is an inherently flawed approach to building websites. Why? Because on the one hand, the point of a CMS is to save development time and minimize coding, but in order to do that, it MUST make lots of assumptions as to the kind of site you want to build, and how it should be built. But by definition, that limits flexibility. So how do you attempt to maintain maximum flexibility AND still require minimum coding? Abstraction upon abstraction - dozens of configuration options, function hooks, plugin architecture... hey speaking of plugins and function hooks, you remember that part about saving you from writing code? Well if you're writing lots of plugins and hooks to bypass the assumptions the CMS makes, then you've sort of defeated a lot of the purpose of the "general purpose" CMS - to save you from writing code. Except now you're writing indirect code that's inherently limited to what the hook/plugin APIs expose to you. And inevitably, you'll run into situations where you can't really bypass assumptions made by the general purpose CMS, so you start working *around* them, and now you're accumulating even more technical debt. So my advice, don't try to build a general purpose CMS - it's an illogical endeavor. 
I would approach it like: * `where('cn', '*dan*');` escapes `*dan*` wholesale * `whereBegins('cn', 'dan');` escapes `dan`then appends a * * `whereEnds('cn', 'dan');` escapes `dan`then prepends a * * `whereLike('cn', 'dan');` escapes `dan`then puts a * on either side * `whereRaw('cn', '*dan*');` doesn't escape at all It adds a few options to the API, but makes the simplest (default) case is secure. To implement, rename `where()` to `whereRaw()` and create simple methods that preprocess the parameter then `return $this-&gt;whereRaw()`. Your mileage may vary. EDIT: Pull request: https://github.com/avadaneidanut/ldapquery/pull/1/files - I don't expect this to get merged, I just wanted to illustrate it. ;)
Hope we can get something like this.
Disagreed. In the fact that you state that it is not that difficult. I'll even concede that maybe technically speaking it's not hard. But it would still be time consuming. To make something as user-friendly, developer-friendly, and customizable as WordPress would be pretty decent undertaking. Now, if you're just talking about basic CRUD, then maybe you're right. But that's certainly not the same thing as WordPress
Exactly, that's why PSR-6 and PSR-7 is not as good as PSR-3. Also, who said the goal of anyone is to standardise everything? Nobody, because that's actually what it is: Nobody needs standards for everything. However, some standards makes the interchangeability of library way easier or even possible. That's why CacheInterface, Request/Response, Container interfaces make sense. Also, '[RFC] Standard email sending interface' is a RFC as you see, a request for comment. Nothing more. If people decide that there are too many cases so it ends up being such as complicated as PSR-6, then nobody is able to build a interface the majority is satisfied, and it will likely be no recommendation at all.
Yeah, i know that this is only rfc, but I'm wanted to see others opinion about trend not particular RFC. But that's great that everyone have voice and can make comment. Overall I think that PHP-CDS and FIG are really great especially CDS which is not so closed, but I'm little bit concerned about that trend, and so asking about it here
I clicked on the title knowing this would be in the comments.
You don't understand backward compatibility concept. If version is backward compatible it means, that it can run code from previous versions. Running newer features from older versions is called forward compatibility :) 
That's not what backwards compatibility means. By your definition, any language addition isn't backwards-compatible.
No I was not :)
&gt; They're being pushed out of the community for who they are, instead of anything that they do. Yet you're against a CoC which would fix these issues. Hmm. 
Same thoughts as /u/MyWorkAccountThisIs (i.e. Yoda), along with: If you're looking to build a site quickly w/ WP, you absolutely can do it with a little knowledge leading in. W/ known plugins, a defined theme, and a customer that has a brand, you can (literally) have a WP site out in 2 hours. That said, the shit I mentioned is usually the stuff that customers don't have down, so you've got to come to the table w/ a lot of it.
Exactly this. It should be a requirement for any code that is about to be reviewed to have passed whatever automated tools you (should) have enforcing coding standards. I don't know about anyone else, but ignoring this stuff during a review is *hard* for me, so I want it all taken care of before I even look at your code. That keeps the focus on the things that actually require and benefit from peer review, IMHO.
You realize that Anthony Ferrara and Derick Rethans are chief among those who are pushing people out of the community, and are the ones who proposed the CoC, right? The CoC would have given them the tools they needed to procedurally shun people from the community, and to punish those in the out group. If you think the proposed CoC would do anything but codify their ideological zealotry, you're foolish. I am not opposed to a CoC in theory. I'm opposed to the one they put forward, and who put it forward, knowing who they are and what they're doing. Anthony brought Randi Harper into our community - someone with a documented history of leading groups to harass unpopular people, and extort those who she can get something over. It doesn't take much looking to figure out who's behind this, and the power they're looking to gain hold of in doing so.
To be fair, WordPress is the biggest piece of guy-wanted-to-learn-programming crap ever. So they're kind of on a level there.
**Jaeger CMS Agnostic Framework** I'd mentioned this previously, but I've built a backup solution that works with 5 of the major CMS's out there and Jaeger is to be a framework, of sorts, to allow others the tool to do the same if they want/need. https://github.com/jaeger-app/jaeger https://github.com/jaeger-app This is VERY much early. I've built a single client project with it so far, but nothing's tagged or ready for official release. Far, far, FAR, from official release. There isn't even a demo app just yet but a good deal of tests and 80% have examples for each object. It does have quite a few useful libraries to add useful functionality to an add-on or plugin: 1. Agnostic Console Routing 2. REST Server Base (with Client library) 3. A simple DB object that uses both mysqli and PDO (since CMS's requirements differ) 4. Remote Storage stolen from Flysystem :) 5. An Email library that works with either SwiftMail3 or 5 (again, since CMS's differ) 6. And the Platform object that provides access to the CMS logic in a consistent interface. I'm honestly not at all sure what's going to happen with it. Consider this me dipping my toe in the water to see if anybody in the PHP world is interested in something like this. 
I want to say it was because /u/ThisIsMyWorkAccount was taken.
I like this RFC a lot more than the other one. The only downside i see to this proposition is that you can't use annotations for optional dependencies. A soon as you try to fetch the annotations, the engine will instantiate every annotation and fail on any annotation that use a class from an optional dependency. You AFAIK you can't do that either with Doctrine annotations so it's not that much of a problem.
And one key ingredient: a client that likes being told "No".
Even the average ones are better than what a beginner will develop in a month. 
This, definitely this. The reason why PSR-3 worked great was that everyone was already using monolog, they (more or less) just extracted the interface, and now the standard is adopted by everyone. I think a cache standard extracted from say CacheProvider in Doctrine/Cache would see wide adoption.
If you created a library that does something really useful, let's say predict how much a given stock price is about to change, you could use your own autoloader, people would complain, but it wouldn't force you to change. Actually they are forced to use your library. It would be a waste of time/effort to create your own autoloader but you would get away with it. Or let's say your boss forces you to follow PSR-2. If there wasn't PSR-2 he would force you to follow Zend Framework coding standards, or His coding standards. So it's not the FIG forcing you, it's your boss or your users. And they would do it anyway.
I love they picked existing PHP operators ( http://php.net/manual/en/language.operators.bitwise.php ), let's make them ambiguous! 
Perhaps I am dumb, but what is the point of annotations? Why would I want to use them?
O man, going from C# (as example) where [JsonObject(Name="blah")] public string Something { get; set; } to &lt;&lt; foo &gt;&gt; is worlds apart in aesthetics.
There are some use cases, but like any other feature it maybe just not for you. First thing that I can think of is metadata for some ORM mechanisms, when creating model you just tell library with annotation that `$fooBar` in class corresponds to `foo_bar` column in database: &lt;&lt;&lt;new ORM\Column('foo_bar')&gt;&gt; public $fooBar; And now library can access this metadata of property via reflaction and assign data from proper column into it. Another usecase (in fact, currently I am workin on it) is assigning arguments from command line into object properties like it's done in powershell: [Parameter(Position=0)] $argument // translated into PHP: &lt;&lt;new Parameter(['position' =&gt; 0])&gt;&gt; public $argument; And now command executor has access to that. And so on. So this is useful for storing meta information useful for other libraries and components. 
&gt; Drupal wants to be an "all in one" generic kind of CMS And that's not necessarily a good thing. Don't get me wrong, Drupal is great but — like Wordpress — it's not great for everything.
That and total lines of code, yes, that's more or less how most shithole companies work.
It's amazing that a programming community can't stick to what they should be doing: programming. I see the benefits of FIG, I just don't understand a lot of the people behind it. You're there to come up with standards to make PHP a better tool. You're not there to talk about whatever else or to get personal with others. Reading comments here I'm just left baffled, there are actual accusations of sexism and misogyny, name calling and fear for professional repercussions... What the hell? Can't people just program, publish, vote and integrate the solutions? How can something that requires 0 physical presence between contributors generate so much shit?
I am not aware of any of the stuff you're talking about, but having been on the bad side of their brigading before I have to say that I would be very uncomfortable with any CoC that was pushed forward by them.
But say it, you cannot?
that's not exactly true. The standard was set by syslog, and monolog just decided to use the same names, because lots of people know syslog's way of doing things.
Well that and Log4J, Log4net etc...
I would rather see /r/PHP_CDS where we could listen in if interested. Not that I am against any of this... just not interested and will likely never use it unless those doing the implementing happen to cross my desk.
&gt; Everything is ~~highly~~ poorly abstracted FTFY. Putting your crappy implementation behind six layers of inheritance is not abstraction, it's obfuscation. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I mega-loathe EAV (my day job is also as a report writer), but like you said - there isn't a much better way to deal with that level of generics. The only other solution I've ever toyed with is creating tables for new entities and the columns will be the properties of that entity, but the huge drawback there is users don't understand (nor should they need to) normalization or for that matter what if one of the properties ALSO has it's own set of types.. now they need to understand relations too. So then it's back to EAV.. 
So much this. Yet many popular tools and frameworks use non-executable code to affect runtime configuration, so there's something to be said for having a standard way to apply this bad idea. At the same time I fear ease of use will increase adoption in more places where config files are a better approach. 
Which are also inspired by syslog ;)
I think a standard should only define the smallest possible subset. A standard should not say how to exactly implement it. That's why PSR--7 is failed. Immutable is an implementation detail and doesn't belongs to an interface. A standard should say: If you like to clone every change then use the clone construct. Keep it simple! 
This is black magic. 
There are DOZENS OF US, DOZENS I TELL YOU! Here's how I like to think about it. When a computer looks at characters, it sees this: \t vs \s\s\s\s ¯\_(ツ)_/¯ what is simpler? ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯ TABS FTW
Isn't this valid? &lt;?php $a = 4; $b = 1; $a &lt;&lt; $b; class Hello {} Anyway, a different marker could have been picked like the widely used `@`.
Seriously boggles my mind as well.
It's barely language-level if you still need to use reflection to act upon those annotations.
You could just have `@('parentheses like this for longer' . ' expressions too')`
Because `Command` instance is created by some other class like `CommandExecutor` rather than human :) 
&gt;but before building my own CMS i would like more to see how did others coded their CMS. I'll throw my own example into the mix, found [here](https://github.com/glossal/template). It's not database dependent, though. It's got a lot of features that you'd expect from a blogging-centric CMS (like WordPress/Ghost) like multi-author, tag archives, markdown, etc. while skipping a lot of the resource-intensities of PHP-driven applications by relying on a build-to-HTML (static-site) output/backend. I've been developing it off and on for about 4 months now, and use it on my personal site, so the majority of it is pretty much specifically tailored to my own use cases, although it wouldn't be too hard to add/remove functionality.
Then build on top of OctoberCMS or Silvercreek. 
FTA: &gt; Drupal projects are put together by modules and glue That's preposterous. Everyone knows they're put together with sadness and hate.
Well since you're allowed standard PHP code within the `&lt;&lt; ... &gt;&gt;` you could have a try / catch block around the annotation you're loading. You might consider this not handy maybe. But at least it shows why it's a good idea to have actual PHP syntax in here.
Eh? Annotations are an excellent system for serialization. C# and Java use them liberally. You can serialize freely without having to redefine parsing logic. i.e. I can define this class property is an xml element, thats an xml attribute, it has this name, it must be of this length, etc. You end up keeping code in tact rather than splitting it off and having to maintain separate definition files for what is the same exact object.
How long is the contract?
So, by that logic, we should pile everything into the language that gets requested and seems useful to some subset of users, right? Everyone can just pick out what they want and ignore the rest. Sounds like a blast.
&gt; I disagree that it's risky or wrong for a person to be both involved in and a moderating influence on a discussion I think that's where we disagree then. I don't believe someone can be completely impartial to judge others in a conversation they are deeply involved in. That fundamental purpose of an "impartial third-party" is that they have no "skin in the game". Can you also see why it might be harder for your fellow moderators to side with the person whose comment you've removed than to side with you? It's a system steeped against non-moderators which you may rightly or wrongly, knowingly or unknowingly, fairly or unfairly be propagating by wielding both your powers of moderation and your deep involvement in the topic under discussion...
How did a legitimate concern for impartiality become an implied accusation of "concern trolling". If I've failed to convince you that the "appearance of impropriety" is an easily avoidable, that's ok. But accuse me of "concern trolling" just because you don't agree with me. I'm objecting to any moderator removing comments of a discussion they are deeply involved in, and it's a reasonable position to have. I'm disappointed that you've chosen, instead of reasonable discussion, you'd rather force me to stop talking to you. That's what I'm going to do now.
You mean the error suppression operator? ;)
Anyone else here that has used and experienced what WPML do to WordPress websites with the Aim of multi-lingual tooling? I'll give you a clue as to it's suitability for purpose IMHO... [Another plugin](https://en-gb.wordpress.org/plugins/wpml-to-multilingualpress/) exists to help migrate their users to a more sane multi-site experience, and this is a snapshot of the issues a client website (luckily built by someone else) we are migrating away from their product line(s)... ## Plugin mayhem * Gravity Forms Multilingual * WooCommerce Multilingual * WPML Media * WPML Multilingual CMS * WPML String Translation * WPML Translation Management I'm sure it makes http://www.onthegosystems.com/ a lot of money, but problems we've detected * Plugin &amp; Theme incompatibility * Woocommerce Product Tab Pro * WooCommerce Table Rate Shipping by Mangohour * Child-Theme pagination of search results using built-in WordPress functions * Quantity is not kept in-sync between translations accurately * Categories sometimes seem to loose their associations with products and parent -&gt; child relationships My point is I'll take advice from WPML when they ship a product that doesn't make me, and them so much money that could be spent on more exciting and showcase features. For anyone that wonders, if you have to use WordPress and WooCommerce (they are okay), then use multi-site to have multiple sites. There are plenty of post cloners, site cloners etc that can leverage the platform, rather than invent their own way of doing things that breaks other plugins and themes (although admittedly most premium themes are also a steaming pile).
I apologize if that's how you took it. That's not how I meant it, and I had assumed from how reasonable you were speaking that you'd understand my purpose in saying it. My mention of concern trolling was purely to give insight into why I'm so quick to defend the practice of moderating while being involved in the discussion. I have taken part in the leadership of many communities over the years, and one thing I've grown quite accustomed to is that many will quickly fall back to exactly that sort of poor argumentation - claiming that a perceived misbehaviour is wrong because it has the appearance of insensitivity to people's snap judgements. That's what concern trolling is to me. I don't think you're one to concern troll. But *if* you were telling me now that I've behaved wrongly here, that's the only basis I could find for such an accusation. And so I'm fairly certain that's not what you're looking to do, so if we're going to have this discussion, I'm simply going to stop defending my actions, and discuss what you've proposed on its own merits. I also apologize if I'm being confusing. I have the tendency to argue both for what I believe, and for why I believe it, and I sometimes mix the two together more than I should.
Point being that folks that don’t personally use a feature have every right to an opinion on that feature. Including an opinion that leads them to get “so upset.”
Is there a video recording of this talk?
What's good for me won't be good for others. I'm writing my own (mostly because the metric I care about most-- security-- is low on the list of concerns for every other CMS), so if you want a specific recommendation, wait until that's released and that's what I'll offer. https://github.com/paragonie/airship/issues/20#issuecomment-218938925
Does anyone know the costs of annotations in PHP vs JAVA, C# or Python? I'm pretty sure those languages implement annotations fairly uniformly in an alternative, yet fairly standard syntax, so two things... * Why use `&lt;&lt; nonsense &gt;&gt;` rather than `@nonsense` // at least keep nonsense to a standard (ignoring C#) * What would be the performance impact of annotations // I Like annotations, they are a useful nonsense, but there is no point adding them if we have to slow to a crawl. If it works like that, then make them an extension
This just in: not wanting to hand write queries leads to performance problems when ORMs try to guess what you mean, story at 11.
Absolutely terrible advice, terrible. Please ignore this article.
Thank you for you appreciation. 1. I plan on integrating unit testing asap. Thank you for the examples. 2. I think $query-&gt;select('attribute') will mean that I have to integrate a component,or develop one to handle communication with the ldap server. For the moment I focus only on the development of query builder strictly because my aim is to let other people use this in their ldap packages.
Meh, there's a table holding the entities, a table holding the field setting and a table holding the field values IIRC. That's EAV as far as I'm concerned. Either way, fields and entities are separately stored and linked together. Whether or not field values have their own table is an implementation detail. 
Illadvised.
Can you expand on why you think this approach is a bad idea?
I think you are thinking of something like Django Forms, alas there is nothing that I know of that couples tightly to a PHP framework that does this. I would however be pleasantly surprised to find out if there is something like this out there.
It's an article from 2013. 
&gt; Well, with that said you basically allege that the mass will not be able to make a "quality decision". Definitionally the mass will be at best average.
Sounds like idiomatic PHP to me.
Perhaps you will learn something new, but it appears that many of us already know what will happen.
&gt; What a CMS like Wordpress gives you out of the box is not that difficult to spend some time building[...] 
Heck, SQL databases are incredibly fast at joining data. I wish the author would show some numbers, because this article seems broken to me. Also, related, here's advice that suggests using joins even with the ORM: http://ocramius.github.io/blog/doctrine-orm-optimization-hydration/ Here's an attached repo to play around with the performance of joins and hydration of them with an ORM, should you want to benchmark it: https://github.com/Ocramius/Doctrine2StepHydration In general, using manual "single hit" queries is a bad idea for any SQL RDBMS. That is *NOT* what these systems are built for, and the performance impact is massive (in a bad way). Interestingly, I tweeted about it today: https://twitter.com/Ocramius/status/730936403408916480 
I don't really care for WordPress either but, if I had to choose between them and my life depended on it, I would choose WordPress over Drupal each and every time. And to be totally honest, when it comes to WordPress, I don't mind working with WordPress core, it's the ton of shitty plugins that make it a nightmare. Granted, how WordPress is built is kinda out-dated, but at least you can built solid websites with it in a reasonable amount of time without going completely insane. 
But.. but.. formatting is for humans... Computers don't care... 
Overview [here](http://www.sitepoint.com/can-php-be-even-faster-light-speed-with-the-blink-framework/) but via the Blink framework which uses it.
Standardizing everything? Absolutely not. Standardizing elements that are commonly implemented between frameworks and libraries? To me that's worth it. I don't necessarily think the caching PSR was a bad idea, but the fact it went against existing implementations is kind of worrisome. I'd like to see that EventManager PSR come through in some form too. It'd be nice to one day not have to configure the Symfony, Doctrine, and JMS Serializer dispatchers for one project and instead use one dispatcher for them all.
We use it as a worker for medical data processing. Currently have a 32 day uptime record, and the only reason it's not longer is cause it has to come down when we patch in new code! I really like reactPHP.
Except that "serialization" is not a singular, definitive operation. Nor is "XML serialization", or any other type. You can serialize the same object to XML in lots of various ways, for various contexts and security levels, and... the list goes on and on. This type of thinking is what leads to garbage software. Stop solving the problem right in front of your face with the first, most obvious solution that comes to mind and give it some critical thought. The people maintaining what you leave behind will thank you for it.
I agree. They should really just copy C# attributes. In C#, an annotation is really a constructor for a class called *AnnotationName*Attribute. They should be evaluated at parse time, stored, and that's the end of it. A good annotation/attribute should be immutable but we don't have enforce that. 
These should be avoided: PDO, ~~mysql~~, file system access (you should also avoid that in usual blocking apps), ~~network access~~, ~~third party APIs~~. - Mysql: https://github.com/amphp/mysql - Filesystem: Libevent / Uv / Eio - Network access: Just keep it non-blocking - Third party APIs: Not sure why third party plays a role here
Found the guy who commented before reading the RFC.
I use XML mappings or external configs (not inlined, basically) for reusable code, but for things like response/request serialization inside an app this is much simpler, easier to follow and much faster to build. A JAX-RS style app is much easier to maintain than layers and layers of custom transformer code. "proper" works until it's just building castles of cards in the air for the sake of doing it. A statically built end-to-end serializer brings no business value to your clients, and is probably going to be a load of wasted time at the end of the months you spent building it. I can agree with you for cases when this actually leads to business value, or is open-sourced (I have no annotations in my OSS libs).
I was speaking in general terms, as 99% of the time, when you're avoiding industry-standard packages you're doing something someone else has already done. Also, Guzzle does async out of the box and they *were* a member until this week.
I took a look at your link to `amphp/mysql`, and then further to the `amphp/amp` repository. I feel a bit ignorant that I had not noticed them before. Then again, they were published in the last 10 months or so. It seems fairly new. Are you a collaborator? Is there a sample app using it? I'm earnestly interested.
There's kind of a sample app: https://dev.kelunik.com/login. Not everything of it is open source yet, but it might be enough for a start: https://github.com/search?q=user%3Akelunik+chat Regarding its age: It's way older than 10 months, first tagged release was back in 2013: https://github.com/amphp/amp/releases?after=v0.1.1. The server we're working on has it's first commit back in Jan 2013: https://github.com/amphp/aerys/commits/master?page=30 Yes, I'm a collaborator. If you want a really simple sample app with the server, have a look at https://github.com/kelunik/demo-chat
Excellent! And thank you for all of the info. I'm going to check it out now.
Pardon my french but fuck PSR-7. It's the most shortsighted and needless shit FIG has done.
&gt; But the initiative makes a few good points: Ultimately the key to the success of PHP-FIG will be a more open group, a much lower barrier to entry and the ability to more rapidly release PSR’s; allowing them to fail quicker so better versions can rise from their ashes. Whatever result/impact that PHP-CDS will have: If it made PHP-FIG more open and more productive, then it was a whole success.
And might change quite a lot once https://github.com/async-interop/event-loop is a thing.
&gt; While I think it’s fine for something like monolog to provide this interface to its end-users, this goal should not have been conflated with the PSR. If it isn't in the standard, you can't rely on these methods existing. You're bound to monolog again. What's the point of the standard then?
I mean that I can run/debug PHP from PhpStorm, even though the settings panels says that they don't recognize the installations.
No, I'm running it from PhpStorm and I can see it's using the full path I gave it in the settings, not just php.exe from my system's path
Exactly, that's the kernel of... well, *poison* that was present in [an earlier RFC](https://wiki.php.net/rfc/attributes) and still present in this "simplified" one. If somebody really really *really* wants to tie some dynamic behavior to an annotation, at least make them put it in a regular PHP class which takes the immutable annotation-data as an *input* and then interprets it. Here's a sketch from when I was [ranting against the earlier RFC](https://www.reddit.com/r/PHP/comments/4ird2x/rfc_in_vote_attributes/d30q5xd), where I took the (slightly-extreme) position of all annotation-payloads being single-strings. &gt; So you (optionally) define an annotation handler/wrapper/helper-thing: &gt; namespace Example; class MyAnnotation extends \Annotation{ private $num; private $message; protected function init($payload){ // Read string $payload and set state, but this one's simple $parts = explode(";",$payload); $this-&gt;num = $parts[0] $this-&gt;message = $parts[1]; } public getMessage(){ return $this-&gt;message; } public getNum(){ return $this-&gt;num; } } If someone using the Reflection API wants the `MyAnnotation` with your special parse-behavior or other side-effects, they have to explicitly trigger it. 
I'd like to tack on the requirement that the class **never** be instantiated automatically just because the annotation exists. Instead, the user (whoever is writing code calling the Reflection API) should have to make an explicit call to kick it off. In this hypothetical example, that would be the the `parse()` call, which commands the Reflection API to pass the "raw" data to the named class and have it "do it's thing". &gt; $reflFunc = new ReflectionFunction("foo"); foreach($reflFunc-&gt;getAnnotations() as $a){ if($a-&gt;getTargetClass() == \Example\MyAnnotation::class){ $ma = $a-&gt;parse(); // Throws exception if class not available assert($ma instanceof \Example\MyAnnotation); } }
Right, and even if someone says "that's not best-practice, nobody should be putting classes there", there's still the situation of: $a &lt;&lt; $b; function foo(){}
&gt; I've yet to see an actual argument against annotations Meta-logic masquerading as actual logic makes code more brittle and harder to reason about. Describing how a function should behave, using reflection in a separate proxy/interceptor to detect that annotated behavior, is needlessly slow, complicated and confusing. Annotations used to help third party tools like IDEs and documentation generators is great, but I have yet to see an actual argument that shows how annotations/attributes improves the design and structure of programs in such a way that current language tools do not allow for. This is not a case of "prove to me why it's bad", the onus is on the people who want it to prove to everyone else why it's unambiguously good.
The alternatives are [foo] class Foo but that is easily confused with: [foo]; class Foo where foo is a constant, define('foo', 'something'). Another suggestion doesnt work as well: @foo() class Foo is actually a function call to foo(), and the errors are supressed.
&gt; validation - mark a DTO's fields with validation information, then let the validation framework deal with it. Only valid objects get through Disagreed here. Validation is often complex. It's not as simple as "must be an int of length X". Thus you end up with the need to create special syntax for use in annotations, instead of a consistent syntax used in "normal" code. Validation is logic, therefore it's *CODE*, therefore by your own definition, it does not belong in an annotation. We have `__construct()` for a reason. We have `public function ....()` for a reason. Want validation in a DTO? Put it where it belongs: in the constructor or a setter, not bolted on to a public property. &gt; memoize - mark a method as cached internally Agreed, this would be very useful provided the interpreter did this for you automatically upon execution. If you need to set up the memoization via reflection, you've ADDED complexity.
That still doesn't solve the problem of having to keep strings in sync with the code, you are just limiting duplication. Your password field constant is still going to break if you rename the property.
Because you can just annotate the property.
 &lt;&lt; new ORM\Field('password') &gt;&gt; public $password; Same problem..... Annotating it as hidden is just one issue. You still need it to be mapped to a column in the DB. If that column name changes, so too must something in your code.
&lt;&lt; new ORM\Field('password') &gt;&gt; public $password; &gt; Same problem..... It's not the same problem at all. Before you needed the exact class name and property name in a string somewhere, and now you don't. You can refactor your code without breaking the ORM. &gt; You still need it to be mapped to a column in the DB. If that column name changes, so too must something in your code. Of course, I'm not arguing annotations will keep your code in sync with the database. They just keep your metadata in sync with the code.
How about... SELECT post_id FROM comment ORDER BY create_time DESC 
Decoupling isn't the holy grail imho, it can be means to an end. But in most of these cms systems decoupling will lead to bridge / adapter code that will slow things even more down and cms'es are not that fast to begin with in the first place. Plus what makes drupal, drupal is rather hard to decouple. Sure the world would benefit from having a module like views available decoupled,but views is so tightly linked with the drupal entity query system it would need a whole lot of bridge code to function. At the other end, giving back to a wider community isn't allways about decoupling your inner works. Drupal contributed back with several patches and fixes to the upstream libraries it consumes, and that is not limited to Symfony components. Alos D8 was used as an extensive test case for PHP7. I can not speak for wordpress, as it is not my ecosystem. But i do believe that the smoothness of the backend interface of WP inspires and motivates other OSS systems that the UX matters just as much as Developer Experience does. In that way WP gave back to the community in general. 
There's two problems in the query you linked. The first is super-easy to fix: replace `select *`with `select post.*`. Then the DB knows you don't care about any comment fields other than date and so will probably be able to fit everything in memory. The second problem is that you're joining the tables and therefore returning POSTS*COMMENTS rows when you only want one row per post. If I were writing the query I'd probably start from: select post.*, lastcomment.create_time from post left join (select post_id, max(create_time) from comment group by post_id) as lastcomment on lastcomment.post_id = post.id order by lastcomment.date desc; And see how that performs. (I'm assuming mysql now supports enough SQL to actually run such a query these days).
I think it's not that simple. It's not about whether to use joins or not using it at all. It's always about to know your database well and to know when use joins. I used to profile our ecommerce app and most of time it was better to create hand written sql with joins instead of running many single table queries. 
Yes but that's just what it is, an opinion. Everybody has an opinion, and we know that opinion. It's 2016, everybody on earth knows that opinion since it comes up every time annotations are even mentioned. It's not constructive at all anymore, we all know some people don't like it but it won't change the fact that some do. I just hope that some day we can get beyond that…
&gt; Meta-logic masquerading as actual logic In Doctrine annotations are used for metadata, not logic. &gt; using reflection in a separate proxy/interceptor to detect that annotated behavior Now you are just making stuff up to prove your point. With the RFC it's just "using reflection", that's as simple as that. &gt; slow, complicated and confusing Slow is mitigated so easily that it's not a problem. Complicated and confusing are just your opinion, which isn't shared by the large community using Symfony, Doctrine, etc. &gt; the onus is on the people who want it to prove to everyone else why it's unambiguously good. But nobody wants to convert you to annotations. Yet some people want to convert people out of it. So no, it's not that way.
In the RFC metadata is represented *using code*. Code *can* store/return data.
You can rely on them in your framework if your framework provides them as a wrapper. That's the point, it's a nice-to-have, but something not really needed in the standard.
If I were you I'd probably learn laravel. It will teach you a lot about modern PHP and provide a good toolset for building sites. A good way to learn something new is to make a portfolio site. 
no, thanks ... its not in php, and i really want it integrated with the main cms either bundled or as plugin as there are too many convenience feature people (might) want like email/push notifications on replyies, avatars, up/downvotes, internal bb codes and so forth
I think this matters to both framework authors and end users as _both_ want components that are interchangeable. First let me say, as someone who has to have lots of logging in their code, I disagree with the author's comment: &gt; This would actually have been enough, but we got 8 additional methods that make it easier to to call this (already fairly simple) method having to call `$log-&gt;log(SomeStatic::INFO, 'hellow world');` gets to be very tedious (and repetitive) vs `$log-&gt;info('hello world');` If PSR-3 were only public function log($level, $message, array $context = array());` Then framework authors would be free to add nice pluming of either public function emergency($message, array $context = array()); public function alert($message, array $context = array()); public function critical($message, array $context = array()); public function error($message, array $context = array()); public function warning($message, array $context = array()); public function notice($message, array $context = array()); public function info($message, array $context = array()); public function debug($message, array $context = array()); or public function emerg($message, array $context = array()); public function alert($message, array $context = array()); public function crit($message, array $context = array()); public function err($message, array $context = array()); public function warn($message, array $context = array()); public function notice($message, array $context = array()); public function info($message, array $context = array()); public function debug($message, array $context = array()); I'm looking at you [ZF1](https://github.com/zendframework/zf1/blob/master/library/Zend/Log.php)! While a framework author can change the underlying component without caring, the end user cannot. I'd have to go through all of my code (not by hand of course!) to correct these errors. PSR-3 becomes meaningless to me, the end user. "Well that's the framework's fault!" would be the typical response and then we are left with the "unofficial standard" of these 8 methods that framework authors "should" implement. This signals to me that PSR-3 made the right choice. Now if I see a logger is PSR-3 compatible I have high confidence it is a drop in replacement which /u/kelunik was getting at
Compared to "all projects/users of PHP", that's **exactly** what they can be called, because that's exactly what they are. And a very small one at that.
True. In Drupal 8, properties are now called base fields. Those are the fields that the entity always has and can't be removed. As a developer, you kind of get the best of both worlds. A single value base field in a custom entity is stored as a single efficient column in the base table. If the entity is set to be "fieldable", an admin user can add more fields which then involves the more complicated table structure. The nice thing for developers is that both types of fields look and feel the same when accessing them with the entity API. I think it's pretty cool.
I literally downvote everything that comes out of /r/PHP
Well, as I implied with this statement... &gt; the metric I care about most-- security-- is low on the list of concerns for every other CMS ...*none* of them live up to my standards. Which includes: * All outbound HTTP traffic forces HTTPS (and/or Tor if available) * Uses a CSPRNG for security purposes * [Boring cryptography](http://cr.yp.to/talks/2015.10.05/slides-djb-20151005-a4.pdf) especially with password storage and data encryption * Automatic self-updating to apply security patches as soon as they're available (to reduce the effective window of compromise after a vulnerability is discovered) * The update should signed by Ed25519, Ed448, or RFC 6979 (deterministic ECDSA) * The public key should be pinned on the client rather than relying on a Certificate Authority infrastructure * Sane session configuration out-of-the-box * Point-and-click Content-Security-Policy configuration (yes, [it can be done](https://github.com/paragonie/csp-builder)) * No [insecure data serialization](https://paragonie.com/blog/2016/04/securely-implementing-de-serialization-in-php) methods used anywhere, even for caching * CSRF mitigation baked into every form, turned on by default (this is where some, such as OctoberCMS, fail) * No useful timing side-channels (i.e. against the [remember me cookie's](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2.1) database lookup) Any CMS that uses a CSPRNG likely does so because of random_compat. WordPress has a self-updating mechanism, but they still don't sign the update file (pwn their update server, you've just pwned millions of websites). Virtually no one has integrated with CSP-Builder yet, even though I've demonstrated how easy it is to do so with my own CMS project.
How are you using it in the IDE?
You can use the [Form component](http://symfony.com/doc/current/components/form/introduction.html) separately from full-stack Symfony as well.
Thanks so much!! 
Sure, but then everyone has to write the same wrapper again and again. And you can't hint against the interface anymore, but need to hint against your wrapper. So everyone injecting a PSR logger would first have to wrap it every time.
i think that's still fine. If you "run" php usually it just launches the web browser with the server name &amp; path you specify. If it's a PHP CLI, it just runs the bin path that you specify, even if it's wrong. Whether it fails or not would happen after you actually run it. In any case, I would send an email to PhpStorm support.
It would awesome if could (I'm speaking for Drupal). If you take Drupal 7, it includes several files (cache, form, database, mail, etc) in every full bootstrap. D8 cured a lot to decouple things, but there is a long way for it decouple completely. Compared to Wordpress, Drupal is probably in a better position. You can at least switch the password backends rather easily. I completely with what the post tells about sharing their own components. The Form API, and the translation systems are probably components worth sharing. 
That's just what you get when you're automagically generating a class who's properties are bound to a table. If you are really adverse to this stylization, use repositories or find a way to tie in annotations.
I would search https://youtrack.jetbrains.com to see if the issue exists on their tracker, if not, create it. They may end up giving you things to try out to fix it.
Standard answer: don't use Active Record. It is pattern of very limited use and easily abused.
Right so error suppression stops `@` char from being used, why not use `[nonsense]`? It's not that it matters so much, it's more about not driving PHP further into a corner of strange conventions. It's great news that it is op-cached, and I do like using annotations; I suppose I'll have to play with it to get a feel for it, but good work! 
I prefer the CodeIgniter instead. Its small and minimal and most importantly looks the least like a framework (according to Rasmus Lerdorf, the PHP creator). I think the only drawback is that no components can be pulled using composer as can be done with Symfony. But otherwise, its usually the right fit for the majority of web projects.
Why not reserve your downvotes until after you've had a conversation about why you disagree with the post? Otherwise you're bringing nothing to the community you expect more out of.
Naming properties has absolutely nothing to do with auto-generation of model classes. It's up to the auto-generator how the properties are named, so it's not per se the exactly same name. Also, what the heck has repositories with naming properties on models to do? Absolutely nothing.
Everyone? Every framework maybe. But then, a wrapper could itself be a shared package - use which you like, or even multiple wrappers. I understand what you are saying, but in the end a line needs to be drawn between the portable interfaces that give access to some common functionality, and the layers that inevitably get wrapped around them. Wherever that line is drawn, there will be an inconvenience to someone.
Totally disagree. PSR-2 means to me that one thing - across many projects - does not need any time, effort or energy to think about, plan for or fight.
Indeed. It means we have consistent coding style across big teams, and people joining are already familiar with it. IDEs can support it easily, and do. It's never been anything other than positive. 