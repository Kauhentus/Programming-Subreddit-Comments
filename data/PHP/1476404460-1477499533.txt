Shhhhhhh... We don't want those who jumped ship for Python coming back, the market is too good for us right now.
&gt;I am not 100% sure what Wordpress is doing with converting to Javascript http://wesbos.com/wordpress-calypso-react/
I'm not. I think PHP's vast vocabulary of functions actually makes it really easy to learn and look things up. The naming and parameter-order inconsistencies don't bother me. I love that I can just type php.net/*some-function-name* and there's the documentation for it.
Sound like a perfect case for UUIDs. https://github.com/ramsey/uuid
LAMPHP. Checkmate. 
&gt;PHP stands for “Personal Home Page.” In 1995., hell, this was a perfectly acceptable name.
Yeah, but my point is since then it's evolved into a general purpose programming language.
I don't think Mockery supports that without using expectations (could be wrong). Mocking libraries like [Phony](http://eloquent-software.com/phony/latest/) and [Phake](http://phake.readthedocs.io/en/2.1/) are better for that approach, because they treat stubbing and verification as separate concepts. 
Thanks. :-)
All that comes out is : bool(true)
ok, we're getting somewhere. what do you get from doing a var_dump( $_POST ) or a var_dump(file_get_contents('php://input')) we need to see what we are receiving before we can work with it
&gt; var_dump( $_POST ) array(0) { } bool(true) YES!!!!!!!!!!!!!!!!!!! the second sent back the JSON array!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
SWEET!
I agree completely, but I think you missed my point. Both Phony and Phake give you the ability to return whatever you want: - Phony - [Returning values](http://eloquent-software.com/phony/latest/#returning-values) - Phake - [Method Stubbing](http://phake.readthedocs.io/en/2.1/method-stubbing.html) Phony even supports sane [default values for PHP 7 return type declarations](http://eloquent-software.com/phony/latest/#default-values-for-return-types).
Because `$data = var_dump(...);` isn't valid. var_dump returns nothing. You want: $data = file_get_contents('php://input'); $amount = $data['order']['total_btc']['cents'];
blah...so I went live with it and made a real order and nothing came through. It works now using Postman though. SSL certs are fine. Paypal and coinbase work great.
Why are you getting into arguments with retards in the first place? Why are you defending someone else's work? Tell them PHP sucks, but you use it because of circumstances that are out of your control and manage to make things work (which is what you should do).
1. Totally different now, most frameworks are full MVC, with dependecies handled using composer. 2. Laravel is rapidly gaining traction. [Laracasts](http://www.laracasts.com) is an awesome resource to learn PHP/Laravel 3. Servers can get complicated quickly. Local development is easy enough, but you'll find production deployments tricky unless you go with a specialized solution (forge, docker, heroku, etc) 4. PHP7 is just an optimized version of PHP5. You can dive right into PHP7 without much concern. 5. I mainly use JetBrains PHPStorm.
Thank you very much, that's exactly what I wanted to hear (you probably misunderstood #5 tho). Ah, by the way, one thing I totally forgot to ask: what is the main dependency tool. Something like NPM is for node
Node code and python code don't need to use web servers written in that same language. When people choose to do so it is because they think there is an advantage to it somehow. Also you could have the server be written in one of those languages and have it start a new instance of node or python to process the request like what happens with Apache and PHP (not that Apache is written in PHP...). Actually I have not been able to wrap my head around why that is not the standard thing to do in Node. They make such a big deal about how you can have non-blocking, asynchronous code. It sounds like selling a fault as an advantage. You wouldn't even need to worry about that if the server and script processing were separate processes. Honestly I think PHPs biggest problems are psychological. The camel casing used by the standard PSR-2 is very ugly. Underscores would be much more readable and pleasant. The PSR-4 autoloading standard means every directory is it's own namespace. That is way too many namespaces and makes instantiating objects involve way too much ritual. People can talk all they want about how that stuff doesn't really matter and it is more important to stick to a standard, but I don't buy that for a second. Those problems make me feel miserable the entire time I am writing code in PHP, which has many subtle, bad effects that are hard to recognize. It is important for languages and communities to do what they can to their users feel good.
Ruby, JavaScript and Python have no type annotations at all, and nobody attacks them for it. The problem isn't what PHP has or doesn't have, the problem is that one is trying to defend it, against people who don't care about objective arguments, as you noted. The best way to win an argument is through results. 
okay...a little more tinkering and I get this var_dump(file_get_contents('php://input')); $data = file_get_contents('php://input'); then when I echo data it is :action=invoiceStatus&amp;invoice_id=PFzP1BafhdGSdjdsFWXY9&amp;amount=0.02&amp;posData=undefined&amp;btcPaid=0.000032&amp;currency=USD&amp;rate=633.71&amp;status=confirmed&amp;exceptionStatus=false
The slack clients are using websockets for communication. They are not using PHP for that. They are using PHP for connecting all the external integrations. 
&gt; PHP is a flawed but powerful language. Well aren't they all.
&gt; I find it ironic that Slack, the go-to communication tool of virtually every hot startup, is ran on PHP. Slack is a messaging app, and the messaging server is run on Java, actually. PHP is used for the "front-end" logic (not to be confused with client-side), which is arguably PHP's strong niche. 
Hi, I'm a terminology nazi. You mean procedural, not functional. Thanks for your time! \^_\^
Not a book, but http://www.phptherightway.com/ is a really good resource.
&gt; 5 - Just out of curiosity, is it possible to develop desktop apps with php? I think there were no stable nor popular solution yet. So the answer is no(t yet).
Ah; It's a query string. Have a look at parse_str() : http://php.net/manual/en/function.parse-str.php parse_str( file_get_contents('php://input') , $data ); $amount = $data['btcPaid'] ; Not so sure about that second line, but I'm sure you'll figure it out. 
Note that the PHP language is very quirky and inconsistent, and will leave you scratching your head at times. The PHP interpreter doesn't complain easily and you can just concatenate strings with floats with booleans and PHP just doesn't care and does what it thinks it's best. One prime example of this is variable types and [comparison operators](http://php.net/manual/en/language.operators.comparison.php). Notably the difference between `==` and `===`. Another small tip I can give you: If you want the documentation of a PHP function: php.net/functionname (eg: [php.net/in_array](http://php.net/in_array)), though your IDE might provide it too. Also +1 for Composer, phptherightway.com and Laravel and/or Symfony.
Does it support bulk inserts in the unit of work?
https://en.wikipedia.org/wiki/User_agent Can't trust it for authentication because the user can change it easily
I can't find an entire book about it. But here's a good reference from wikipedia: https://en.m.wikipedia.org/wiki/Goto
exactly. Unless you are looking to improve yourself, you won't. 
&gt;Discord Discord works OK, but lags when I download their desktop application (Electron based), it does lag. In fact, Slack is usually fine for me, but starts lagging or being a dick after it has run for a day or so. &gt; Google Docs Google Docs is black magic. We don't speak about Google Docs.
you offer no details about what the raffle system should do, how does the raffle run? How many winners does it pick etc etc What have you tried so far? This isn't really a support forum anyway 
/u/pmjones probably you should correct me here, if I am wrong.
You need uniqid for this, if you are using it for logging. It makes sure your value is always unique and it is not a resource hog. It's based on microtime() + some random. Just give it the $more_entropy = true and remove the "." with strrt/str_replace
/r/PHPhelp 
 &lt;?php echo mt_rand(1, 999); // if it's 69 ur a winner [POC](https://3v4l.org/Ep20aT)
or really functional ones ))
If You want types don't use arrays directly but some ArrayAccess object instead 
Exactly, which is why taking a language out of your toolbox and throwing it away because of a presumed failing is silly. There's the task, and there's a bunch of languages that can complete the task (or hell, given another medium, tools, or pencils, or knives, or whatever it is). Pick the one that best drives you to that goal.
Accurate.
Thanks /u/utotwel! I've been using your framework to release software for private companies for years so it feels good to give a tiny bit back to other developers.
There is no 100% hack to find out which device the user is using. You can do the best to find out and "hope" that it's correct, but that's all. There is no constant which you could use to determine it's a specific device. Try out some existing device detection software, they have a big database that mostly fits to the correct data. I mean.. if someone has to fake his device, he has to deal with the consequences. Maybe http://wurfl.sourceforge.net/
Just installing some CMS/e-commerce system is usually fine, the tricky part is 'updating' that software. And I've yet to see a developer call up former clients and do an update for them, even if paid, or site owners calling developers for periodical maintenance like they would on a car, you know... before it breaks. Most people have no idea how the internet works, and that's fine, they only want to sell homemade soap. But there's only so much updating and security patching you can do on a new medium that may end up costing 300$ per hour to get something fixed, only to have an update 2 weeks later break your site again. Because, you know... 'free software'. Most clients end up in the scenario where they either pay that guy a couple heavy hundred dollars to update, or stick to older versions and deal with whatever, if ever, will happen.
try this : $data = (array) json_decode(file_get_contents('php://input'));
Yes I'm in the same boat. It used to have a higher level of entry which scared away most of these 'have a go heroes' who would install things like Wordpress and then sell it to clients for thousands $$$$ but now web hosts are offering one click installs for things like Magento unfortunately its now going down the same route. **Marketing guy who knows little about real software development, probably calls him self and entrepreneur:** "Hey I can set you up a fully Enterprise ready store and you can edit all the products yourself to save on future costs and I will only charge you $5000 to do it" **Client:** "Wow that's amazing a digital agency wanted to charge me $50,000 for a custom made solution" **Marketing guy who knows little about real software development, probably calls him self and entrepreneur:** *Clicks install Magento in cPanel takes $5000 and moves on to the next unsuspecting person* **Client:** "Wow this is amazing that you can do it for this price those agencies are a rip off" **Client 6 months later:** "My site has been compromised, my customer details leaked and my business has been ruined"
Multi insert seems not that easy given it has events before fired, after fired ( yes that is not a big deal though ) and last getting the auto increment value. May be a different method for multi insert seems easier than the current one. Just my thoughts.
A very simple, first step could be to add fundamental [CSP](https://developer.chrome.com/extensions/contentSecurityPolicy), disallowing the execution of `eval` and other unsafe functions. That alone may bring the number of skimming incidents down significantly. Some templating engines (e.g. underscore.js) use `eval`, though. However, templates should not be compiled on-the-fly in a production environment anyway. Now - as always - we just need Internet Explorer aboard this ship. Sadly, IE only supports the same-origin policy, which does nothing for inline scripts and code in script tags.
It's a bug in Laravel. I've found the cause and should have a fix out today. 
You will commit suicide within weeks. I have never heard anyone say oh yeah XML for templates is a really good idea or not having any namespaces is a really sound architectural decision 
&gt;Also you could have the server be written in one of those languages and have it start a new instance of node or python to process the request like what happens with Apache and PHP... Actually I have not been able to wrap my head around why that is not the standard thing to do in Node. Because then you have to re-bootstrap the system every single time a web request comes in. A long-running process -or a few of them - that each only have to pay the cost of going from process-start to a fully running, prepared environment once is easier on the system. And it also makes some thing easier like, for example, updating the system. It's pretty easy to automate the process of updating the routed application servers in the webserver and slowly getting rid of the old, outdated ones such that no client is dropped or suddenly switched between the old code and the new, and such that there's no downtime. &gt; They make such a big deal about how you can have non-blocking, asynchronous code. It sounds like selling a fault as an advantage. You wouldn't even need to worry about that if the server and script processing were separate processes. Well I do think the Node.js people tend to overvalue it, there are definitely advantages to the asynchronous setup in many situations - even ones the mod_php system can run in to. If I need to perform a database query and also make a request to some other service to determine how to service I request I receive the ability to do something like $query = async_query($sql); $request = async_get_data($other_server); do_some_other_stuff_meanwhile(); process_query(await $query); process_response(await $request); would potentially help cut down my average response time quite a bit considering that waiting on the network is a pretty big time-sink. Being able to wait on both network requests simultaneously - and perhaps even do some other work in the meantime - can make a good difference.
[Php Desktop](https://github.com/cztomczak/phpdesktop) at github is quite a solution [for windows], very customisable 
Also, to the folks downvoting /u/kemmeta: Could you not?
That site is absolute gold, I had no idea it existed, thank you.
Well, it being MySQL, you really only have two options - run a bulk insert in a single query, or run them in a bunch of individual queries and accept that your database is going to get curb-stomped if you're not keeping tight control on the number of records in a incoming batch. So the best method for multi-insert that doesn't involve curb-stomping is to have an auto-incrementing primary key, then run the bulk insert in a single query and get the last_insert_id() to extrapolate the auto-increment values for the inserted records. You'd have to be absolutely sure that the extrapolated values are correct, though. I'm trying to think of a situation where the insert would have succeeded but the values might be incorrect.
&gt; I was just curious. /me nods Yeah, for imports/migrations/etc it seems to me that an ORM (per se) is probably too "high level." My guess is that a "lower level" tool would be more appropriate (even SqlQuery might be a bit much depending on your constraints; perhaps Aura.Sql or even the underlying PDO itself). 
I have been led to understand that doing a ton of individual inserts *as part of a transaction* can be more-performant than doing them outside a transaction. That, in turn, lets you do some PHP work intermingled with the SQL work, and keep everything in sync.
Of *fucking* course it got flagkilled.
You are right...the percentage is going to lower. I'm not sure Go will eat a lot of it...Javascript(Node) certainly will. Right now in most of my project is a mix of 80% PHP and 20% Javascript (Node). &gt; Do they teach PHP in college? http://online.stanford.edu/courses/topic/4 And you can search for PHP. I had videos of step by step application building from one university but I don't remember which one.
I'm a Magento developer and it's basically impossible to just install Magento and just leave it as it is. Magento stores require constant maintenance. Magento is a very complex system and installing a security patch sometimes can take days of full time work. Even with a fully patched system chances of being hacked are fairly high because more popular stores are very profitable targets for attackers trying to steal CC information. Unless you are willing to pay for ongoing maintenance I don't recommend using Magento to anyone. Hosted solutions like Shopify, Bigcommerce or Squarespace are much cheaper to run for smaller stores. Magento only makes sense if you push a lot of volume or need the ability to heavily customize your site. 
But humans only use 10% of their brain!!! Source: Morgan Freeman
That seems like an extreme example of a potentially broader range of victims who suffered the general fate of time and neglect resulting in an outdated and vulnerable code base. Penetrations are rare if you're properly maintaining, but we've all had to deal with outdated code, especially sysadmins.
It find it easy to make everything I need in php, it powers all my sites serving tens of thousands of users every day and makes me money. I don't really give a crap what the cool kids has to say about php, I like it.
problem for me is that, though PHP support multiple operating systems, it depends on the OS, and behaves slightly differently on some corner case details (caused by OS's settings), and any one of them drive me mad. i.e. I have a script for personal file management, changing file name to another one containing UTF8 characters, it's works perfectly fine on ubuntu and mac, but when running in windows, all out of control. 
I believe this person has a problem of over-architecting. Never once have I ever used the term "infrastructure service"... nor do I believe I ever will.
&gt; But in general exceptions should be only used when they're really unexpected and more technical fault (MySQL server has gone away, File could not be written due to file permissions, ... Uh, why? Sorry, but I don't accept the premise...
Yeah like something that might fit .... CacheService? but that is an Application Service... 
I would argue that business logic *should* use exceptions for invalid state - it is an unexpected situation. Taking the example of redeeming a voucher code; You would have a validator that validates the codes (is valid, not expired etc.). There would exist a separate method for redeeming, and passing an invalid code to that function is an unexpected situation, or an invalid state - it should have passed the validation first. Another argument in favour of using exceptions to control program flow involves return values. If you say that a method should always return a valid value (e.g. a function that gets a user by their ID), then returning null is not a valid state. The proper way to signal an error here would be an exception.
Thanks. This helped me to understand some stuff better. What you said actually matches up with what I said when I said "When people choose to do so it is because they think there is an advantage to it". So whether you are using something like node or PHP, the choice of running the server and the responses in the same process or not is up to you. I'm sure there are servers written in PHP...
&gt; In my opinion you should use it when you want to handle an unexpected situation. As /r/Quetuo pointed out, unexpected situations in business logic are still considered unexpected situations. Back in the PHP 4 days it was common for functions to return true or false. The problem was, when you were 5-10 function calls deep in your call-stack and a function returned false, you had to make sure all of the functions further up the stack handled that "false" correctly, and sent the appropriate status message to the user. Exceptions greatly simplify this as an Exception thrown at any level of the call-stack will automatically bubble up to the first try/catch block it finds. You can also, very easily, introduce custom error-handling logic for special error cases by simply defining new Exception types, and adding the corresponding catch blocks for those types. In my experience I've found Exceptions to greatly simplify the error handling process of an application. I don't see anything inherently wrong with using them, in fact, I actually see a lot of benefit. So yeah, I'm afraid I don't accept your premise that exceptions should only be used in specific, system-level error conditions...
I was really hoping that PHP would fix a lot of the annoyances and inconsistencies in the internal function naming with v7. They did fix some stuff, but what they really ought to do is completely rewrite a whole pile of their built in functions so that the naming and layout is standardized.
How to create trait for php in c(zend engine) ? Any sample of code how it should even look ?
[removed]
Codewars 😉
Am I wrong in assuming that only more strongly typed languages will tell you you screwed up?
If you're not aware, we prefer support questions in /r/PHPhelp (see the sidebar notes). Thanks! 
I made no assumption about your example, I only wanted to expand on my specific needs. There was no need to be a smug asshole just because you offered a pedestrian answer which you assumed I did not already know. 
Thanks for your condescension. Buh-bye!
to be fair, I don't think very many people understand Magento... I did 1 contract to setup a Magento site and decided I wouldn't touch that shit ever again.
The statically-typed ones will do so at compile-time, and the dynamically-typed ones will do so at runtime (if strongly-typed) or at least do something more sensible than what PHP does.
While I've rarely had such issues, I would most certainly support PHP yelling at the user when doing foolish comparisons.
Comparisons are a bit of a difficult case. PHP could outlaw certain types of comparisons and throw an exception if they're attempted, but that would be a backwards-compatibility break, and it would be a strange move given PHP's general weak typing. We could change the behaviour to produce more consistent results, but that would be a very insidious backwards-compatibility break that would be hard to check for in existing code. We could introduce warnings ([like PHP 7.1 will for other operators](https://wiki.php.net/rfc/invalid_strings_in_arithmetic)), but by nature I'm not sure we can actually say what invalid cases consist of. In principle, for example, `==` and `!=` should work on any two values. Nonetheless, maybe some progress will be made here eventually.
I suppose I never hit these edge cases as I don't pass random non-numeric strings where numbers are expected. In JavaScript the result would be a NaN outbreak, which is about the same, in effect. 
Imagine scaling your state model method up to something as simple as registering a user for a social media site. It'd be an insane amount of needless code cruft. Exceptions exist for a reason and State Models do **not** effectively fill that reason.
Thanks for the well explained answer. I'll apply this to my issue and report back. I appreciate the insight.
This is why I never enter my credit card on any website, and only pay through off-site payment gateways. If your site does not support Paypal/Amazon/Google checkout I'm not shopping there. Also, not only stores can get hacked but store owners can do really shady stuff with your data as well, I've seen employees sending CC details to salespeople by email, jotting them down in notebooks, and using really dumb passwords for their admin accounts in their stores. --- That said, I've been working with Magento for several years and had only 1 site hacked, it was due to an exploit in a third party extension that came with a theme that we bought. Luckily we didn't have any on-site payment method so no customers lost their CC details there. Magento itself is pretty safe if you keep it up-to-date. It's extensions (and often your own code) that put you at risk. 
I doubt the two examples you cite are using server side detection. I'm sure both are responsive front ends. If you can't achieve a completely responsive frontend with what you have now (we've all been there) then you need a site redesign. Yes, this usually means more time and dollars spent to achieve a responsive front-end but it's entirely worth it. In regards to the quotes you cite both are completely accurate. The second quote is pretty edge case though. What I mean by that is not a whole lot of users will even know how to alter their browsers User Agent and even if they did they're typically doing something a normal (dumb) user would not be doing anyway. Even so, it is a valid concern. Bottom line, you need to put in the effort of redesigning your site to be responsive. I hope you consider my thoughts here as you're going down a rabbit hole of potential problems and QA issues. Even so, take a look at [Mobile-Detect](https://github.com/serbanghita/Mobile-Detect) php library. I have used it in the past for very desperate times and it seems to have done OK.
In rare cases does it make sense to really make a mobile version of your site. Your money is better spent on redesigning the site in a responsive way. In the cases where having a separate mobile site makes sense, it would probably also (more so) make sense to offer an app to mobile users, as it's likely you're serving a web app. 
One thing I love about PHP is how easy it is to work with things like nginx. Getting a LAMP/LNMP stack setup is probably the smoothest process in comparison to go, ruby, nodejs, etc... I truly hope other languages improve in that area.
&gt; Some of those sites had text files in the web root where the CC info was being saved before being sent off to the hacker I worked on a store like once. I *assumed* it had been compromised. But their developer cleared it up for me. The payments.txt file that lived under the web root and contained full billing details was how their accounts person tracked the payments. 
In go, python or whatever that exposes a local port, setting it up with nginx is just a proxy_pass configuration item away. I don't know what you are talking about.
Nah, I can live with some inconsistency in function naming or parameter order. IDE handles it for me. Great backwards compatibility is way more important and one of the main strengths of php. Breaking half of the internet just to change some function names and argument order would be really bad for the future of php. If you like rewriting your code every week, go pick a trendy js framework. I love the fact that code I wrote 10 years ago not only still runs in production on php7, but does so much faster.
I would define it like a code merge. Keep what's the same, but only once, and keep the diff's from both. Seems like the standard definition of merge. Otherwise it's an append or combine.
&gt; I'm sure there are servers written in PHP... Yes. * NodePHP: http://nodephp.org * IcicleIO: https://icicle.io/ * amphp Aerys: http://amphp.org/docs/aerys/ * somehow AppServer: http://appserver.io/ * and lately KrakenPHP: http://kraken-php.com/ They're all used in production by the way. For example http://jarves.io/ runs on ReactPHP. Some people reported a 2 year uptime for their ReactPHP app in production.
I've noticed scholars tend to confuse categorization with insight. I've myself done this error many times in my younger years. We can split things endlessly in categories, but this is useless, unless we can assign useful and well-defined rules for handling each category differently. We can indeed differentiate "infrastructure services" from others in that applications (public clients) can't access them. But there's no significant difference between a domain service and application service, as I see in the article. A service may be used by one app or multiple apps, but that's subject to change, it's not fixed in stone, so it doesn't tell us anything *useful* for the service. In general we can use the more simple and self-descriptive terms "public service" and "private service" to differentiate services based on access. As for services which hold no domain state themselves, but simply represent a facade calling other services in order to make it easy for a given app use-case, those are usually referred to as "orchestration services". And let's not forget that all those categories are relative. What's a "domain", what's an "application", what's "private", what's "public" depends on your PoV, because in any complex enterprise you have multiple "onion rings" of access, each with its own domain and applications. So when you say "this is a XYZ service" you should remember this is not absolute, but only true in a specific context. 
&gt; The advantage of other languages is they will tell you you screwed up. PHP gets scalars "wrong" in terms of strictness, but it has a nominal type systems with easy to specify and enforce type hints and lock down object implementation (member visibility, methods you can't overwrite etc.). Ruby implements scalars right, but completely lacks type annotations and encapsulation for objects in general. I'm not sure why Ruby gets a pass for its omissions, and PHP doesn't. In larger projects, I'd say that Ruby is quite more prone to make a big mess compared to PHP.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions. 
 - Application Services = Objects - Infrastructure Services = Objects - Domain Services = Objects - Domain Entities = Objects - Domain Value Objects = Objects... I think you got my point. The only important thing it separation of concerns, encapsulation, dependency inversion and so on. The "categorization" doesn't illustrate it well. I seen many developers just uses domain entities as state and app/domain services as just stateless "procedures".
Then just do the conditional outside the array definition. $var = condition ? 'thing' : 'otherthing';
https://www.reddit.com/r/PHP/comments/2xe8t4/experimental_php7_jit_is_faster_than_c_in/cozefhb
I did not talk about PHP, rather JIT in general...
Cool, looks great! Definitely gonna use some parts of it in my framework, thanks! Will give you credits. 
Why is it that when something is published that is made in india 100% of the times sucks?
Well to quote me: &gt; I don't think there are most any servers written in PHP **that have widespread adoption as a webserver or application server**, and that makes sense given the nature of the problem and the nature of PHP. Between the top 3 web servers, for example (Apache, IIS, nginx all C or C++) you've already accounted for a bit more than 3/4 of the market. After that your next biggest competitor with a measly ~2% of the market is Google's own which is going to be Java or C++.
What kind of queue backend would you want? Resque? Redis? Can't it installed on windows? If anything else is failed, just use linux VM and install it there, or just use database backed queue
PHP Suitable for billing Software
https://wordpress.org/plugins/tags/terminal Here are some wordpress plugins to help you!
https://wordpress.org/plugins/tags/print These wordpress plugins do support printing.
Yes. I would like to have laravel to queue stuff instead of running it instantly. However how can I setup something for this on Windows. I am used to Ubuntu.
Maybe because there aren't enough PHP meetups over there so people don't get feedback on their skills/presentations to realize they don't know as much as they think they know?
This service needs paid plans. That would be the guarantee. Now... They could just shut down and you would be fucked.
how can programmer get pragnant
I like how the Php community takes pride in how Php enables people like OP to build stuff. But at the same time mock them privately....
&gt; dos print support php
"Privately"?
I am just here for the mocking, this is not /r/PHPhelp But I also am not really a part of the PHP community, apart from the mocking…
Things I've normally thought of as "Infrastructure" services are things like abstractions that work with things like Mailgun, Slack, metrics APIs, etc.
Thanks everyone, really doesn't sound like this job is for me. Was something a recruitment agency had lined up, not something I was particularly interested in myself. This agency in particular seems to recommend any job they can find to suit their own priorities, they've wasted enough of my time already.
Thanks for your help! I am gonna go with Diactoros :) Glad you were able to answer my question before moderators for some reason (maybe I am not allowed to ask questions?) deleted my post..
So curious as to why you aren't wanting to mirror dev and production? 
I think for the most part your problem can/should be solved by environment based configuration, eg. disable caching component in dev, enable in production.. as for dev only dependencies, [composer handles that already](https://getcomposer.org/doc/04-schema.md#require-dev).
Adding BC breaks or duplication for *naming consistency* is not a big win. I've seen many PHP users annoyed by the naming and can sympathize, but I don't think it should be changed at this stage of PHP's lifetime.
Right. Sorry I didn't explain clearly. I'm doing that currently, but I have some dependencies that are "production only" . Any way to do this?
Well for the most part I am, but I don't want caching enabled. I do that in staging as the last step so it doesn't get in the way. Does that make sense? I basically don't want to be having to go in and disable this and that in dev environment. When I sync the db's the caching will always get enabled (annoying), so I use php to auto-disable certain plugins I don't want in the dev environment. This works, but I would rather have composer not install it in my dev environment in the first place. But maybe this is an error in my thinking. Maybe I should be testing the caching plugin in dev too like everything else. I'm sure this is the correct way of doing things, the more I think about it. What do you think?
If caching is apart of your application you should be testing it in dev, staging and production. You could set an environmental to enable/disable caching. But if it was me, and my app relied on caching, I wanna make sure it works with what I'm doing in dev.
Come to think of it, you could gitignore your composer file and create one for dev and one for staging and prod and as your code moves up, composer install everything. However I would imagine the code will have exceptions cause of missing libraries when you write it out?
Interesting. Thank you for sharing! Always fun to see real-world comparisons with HHVM and PHP 7. Note that they did not use repo-authoritative mode, but that would have been fun to see as well.
Thanks for the reply! Do you mean a textarea which allows individual users to do on-site displaying and editing of their own personal notes?
Here's a challenge...follow a tutorial! Sorry, I couldn't resist.
Haha! Believe me I've tried with html and CSS, and i ended up downloading websites for experimentation instead. Changing this and that just to see what happens. I started learning about a year ago ago and I've gotten fairly good at converting what I create in Photoshop into html/css and Joomla templates.
Choose a project that aligns with your interests and just keep improving it! Start simple and add more things along the way. Naturally you will learn more as you expand. You will learn and care more about your baby than blindly following tutorials.
This makes me realize how pitifully little I actually know about databases.
Your second point is worded in such a way that it sounds like InnoDB is also getting cut. I almost shat myself (On mobile, confused comma with period)
utf8 being the default, rather than ini modification is very much overdue and welcome!
Do a few tutorials, but then move to some project that you wish to do. When you get stuck, google for answers, program, repeat. Otherwise string challenges is a good start to get you thinking: http://javarevisited.blogspot.si/2015/01/top-20-string-coding-interview-question-programming-interview.html 
Register it as a normal class and set the `ZEND_ACC_TRAIT` flag: https://github.com/php/php-src/blob/bce17764be6bd5ca43a512db51c030fb8d0437fd/Zend/zend_builtin_functions.c#L418
Create a script that will render every HTML element
I'm not a fluent French or German speaker so I can't really comment, but learning them in school they felt much more "rigid" than English to me. 
You're not the only one.
Finally utf8mb4 by default. I was so annoyed to write sed scripts for this each time I provision mysql. And most developers don't even do this much. Although nowadays frameworks usually insure you don't mess this up (by the way, Laravel still defaults to utf8 instead of utf8mb4), a lot of legacy projects use latin1 (or worse, some tables are in latin1 while other in utf8) and it's tiresome to account for this when you are writing code.
If you haven't read it, High Performance MySQL from O'Reilly is a great primer for getting more familiar with the intricacies of MySQL, then the Paul DuBois books, then Understanding MySQL Internals. Though, I suppose, as a developer if you know enough to optimize given the output of `EXPLAIN` then you're in a decent enough place.
Heh heh, you beat me to it! 
Agreed. I really enjoy having multiple schemas in one database, and array data types, and json data types, the list goes on. 
that just escalated quickly
Also psql isn't owned by Oracle. Watching what they've done with java over android I just don't trust that company. 
Is support for descending indexes a big deal for anyone else? So many of my queries are ordered by DESC that this seems like it would give my application a significant performance improvement. Other than the usual considerations for indexes, is there anything to watch out for with descending indexes that should make me hesitate in applying it to many of my fields used in DESC order queries?
I was referring to feature set
When I first learned PHP and MySQL, I dove head first and built a blog system. Posts, categories, and tags. I'm like you, ADD, so reading tutorials or learning the "fundamentals" of the language made me easily lose interest. I always need to learn by doing or building something that excites me and seems useful, no matter how hard. I'm not saying you should build a blog. You can if you want, but my point is to find something to build that excites you and then figure it out along the way. You'll probably rewrite it many times along the way as you learn more, but it's really about the journey and not the destination. Good luck! Have fun!
This is more like SOA rather that microservices. Take a look an another approach: - User makes GET request to /api/shops to get list of available shops - Request passed to middleware server (this could be event nginx + lua scripts or even javascript scripts) which will add additional information (for example current user profile and permissions) to request and pass it to php-fpm of separate microservice. Or oauth + jwt could be used, there are hell lot of possible solutions. - This microservice then will just do the job just as usual application. Pros: - Real microservices - No single point of failure (rabbitmq) - Usually faster 
Drupal 8 got in bed with composer. There are fewer modules available than for 7 but Commerce for Drupal 8 has reached beta so I wouldn't start any new site with Drupal 7 unless you put a gun to my head. If you're doing custom development with Drupal 7 you can use `composer_manager` to at least have a sane way to require some dependencies.
Completely agree. I used mysql for ages, but had a project that required GIS and mysql was just not cutting it. Used PostgreSQL for it, but noticed I liked the other features so much more as well. I still use mysql almost exclusively as it would require a lot of work porting things over, but someday I hope to switch
Just come up with a side project, I hate doing tutorials too and that's how I learned. You're better off figuring out something that interests you rather than taking people's suggestions. If it's something you want, you'll end up sticking with it and finishing it. Do you play any games seriously? For me some of my first stuff was a gaming community website that integrated with phpbb forums and users could upload quake demo files.
I really want to be done with RDBMS, desperately trying to build whatever projects i can with graph DBs like Neo going forward. But it's way harder when entire frameworks marry into a ORM :/ not impossible just.. harder.. 
No CTE's? Read about it in the same place [a couple of weeks ago](http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/). That's gotta be the biggest one for me personally if they can make it happen for this release.
Meanwhile, I can't get my legacy code and queries updated fast enough to even get onto 5.7.
Not quite, features are starting to diverge between them. Documented here: https://mariadb.com/kb/en/mariadb/mariadb-vs-mysql-compatibility/
Well, yes -- I know it's a fork, and I know they're capable of pulling in features. My comment was more or less intended to convey that MariaDB would get the features only if the MariaDB team decided to implement them.
Yes, you are correct. I stuck to the colloquial "Apache", only because I was using it in the context of *AMP stacks, but "Httpd" is the correct name for the software.
Thank you for the link, I shall study it :) cheers
Well, here`s hoping for CTEs and ROW_NUMBER in the next version.User variables are hard to read.
Or you can just version control your components in a private repository, use [Composer's repository setting](https://getcomposer.org/doc/05-repositories.md), and then include your own component in any number of projects as a composer dependency. Hell, just [set up your own composer repository](https://getcomposer.org/doc/articles/handling-private-packages-with-satis.md) and you can host your own private suite of composer packages.
Hosting each component in a private repository is not a good idea in our case as some components can / have to interact with each other. 
What? If one needs to talk to the other, include it as a dependency. This is a MUCH better approach than just copying everything into a folder over and over again.
How about tools? Postgres tooling still sucks compared to mysql
Thank you for that explanation. Makes Alot more sense now! Alot of these php concepts seem weird until I can find a valid case where it would be used and then it makes perfect sense lol. Is it ok to ask anything here also? Like if I'm having issues with code etc?
Try to inspect the community's sidebar. There, you often could find some guidelines.
I hear that refrain constantly, and yet haven't seen a single datapoint beyond more sensible defaults that says what makes Postgres so much better. Would you mind explaining what about it you prefer?
Any word regarding better online ALTER support? I remember reading about it a while ago but haven't seen any real updates (beyond the Percona CLI tools)
Because you can actually disable it now. A lot of MySQL deployments are entirely InnoDB (for example, at Facebook all our tables are InnoDB), but MyISAM couldn't be disabled as MySQL used it internally. 
I might get some downvotes for suggesting it, but IMO PHP can be just as useful on the commandline as Python or Bash or whatever. So, aside from the cases already mentioned, also consider all of the instances where you might want a locally run script to write to a file. Like if you wanted to scrape a website or parse a large log file and write some result to a text file, you could do that in 60 seconds with a few lines of PHP.
Nothing is copied. I don't get your problem with our solution. Please try to explain it. Perhaps this is a misunderstanding and i should rewrite parts of the article. Thanks in advance.
What you're looking for is a win32 API library. There are a few floating around but from what I've read they're all pretty bad.
Entities should only have the __constructor called once, when they are first created. Retrieving them back again from the database shouldn't create a "new" instance (call the construct), it should just hydrate an object with the existing entity's data.
Now work with C#, etc, and you will say the same thing about PHP...
PHP is a server side language. I'm not sure of a context where you would want to write a desktop app in PHP or even how you would pull it off.
I mostly work with Laravel and have recently had Drupal 8 shoved down our throats... it definitely makes me need to drink more. I don't know much about magento, but if you actually enjoy writing code and feeling productive, don't use Drupal. Ever. For anything. 
&gt; I don't see any benefits compared to instantiating classes with constructors or static methods or builders/factories (which again use the ctors). It's beneficial because you have two very different use-cases going on: 1. How can I structure this class' API so that it is nearly impossible for a programmer to assemble an object in an incorrect or illegally-reached state? 1. How can I seamlessly save this object and load it up again exactly as it was, given that it's impossible to keep all objects in memory forever or share one memory-space across all PHP processes? You're seeing one possible solution, where developers create a constructor which enforces "first time" business rules and invariants... And a separate system to magically bypass it to provide convenient save/load functionality. Now, another possibility is to make `__construct` non-public, and require each of those use-case a to go through a different static method ("named constructor") on the class. This gives you more control, but forces your class to be "aware" of persistence details. What *doesnt* work is trying to jam both sets of requirements into one constructor method. I've seen it done, and it's the worst of both worlds: The constructor becomes a meaningless parade of arguments; nobody knows "the right way" to create the object without research; and it has to be updated every time you add or rename some supposedly-internal property.
&gt; While it should be noted that the MySQL 5.7 optimizer is able to scan an ascending index backwards (to give descending order), it comes at a higher cost. As shown further down, we can see forward index scans are ~15% better than backward index scans. It was already able to use a regular index for descending ordering. But now it can be further optimized at the index definition level for cases where the queries always do an ORDER BY `col` DESC. In most schemas I've seen, the queries don't even get optimized by building indexes for sorting, so they end up with a query plan that does an extra temp table/filesorting operation. Which is pretty heavy for queries that return a ton of rows. For most cases the descending index feature is not a big thing, but is definitely nice to have and a welcome addition.
I've seen people work around this with GOTO *shudder*
&gt; Something like non-blocking SQL dump mysqldump --single-transaction exists for ages 
As an ex C# developer I couldn't agree more...but Windows, Yuck!
Not sure what you mean. Yeah mysql and php have a long history and is pretty standard, but the [postgre functions have been around just as long](http://php.net/manual/en/function.pg-connect.php), and the built in [PDO class has supported Postgre](http://php.net/manual/en/ref.pdo-pgsql.php) for as long as it's been around I'd say not only is PHP and PGSQL friends, but they've been on the same level of friendship as MySQL. Postgre just wasn't a popular DB choice for shared hosting providers for the longest while, but now even hosts like Namecheap offer full PostgreSQL support 
In general you have a pretty good grasp what a microservice is, so what you have to do now, that you have things working is to profile and find your bottleneck. There are many things you can simplify. For example, using Laravel for the "front-end microservice" is probably an overkill. It'd be like 50-60 lines of plain PHP to tunnel messages from and to HTTP this way. But we can't tell, as we don't know where the exact bottleneck is.
Hey, genuine question/suggestion here. Would a long term deprecation plan be possible? You seem to say it's too late in the lifetime, but considering PHP probably has at least another 10-15 years to go (very likely probably more considering how it's evolving) I think it might really not be that bad. I'm thinking something like this: 1. Release version X: - Make names uniform in style (PSR, format is already agreed upon, no politics to manage here) and add aliases to old names. - Officialize this style for new additions and refuse to add non-conforming additions (might already be the case). - Keep the old functions/classes/methods/etc in PHP.net docs but only as redirects, notify of new name on redirect. - Create tool to automatically refactor everything, check for possible incompatibilities and notify of possible calls made with string names (minimize transition pain). - Make the engine spit out deprecation notices. - Add opt-in strict naming mode for the daring ones. - Maybe have a build setting without support for legacy names. 2. Keep this going 2-3 years: - In the middle of it, switch the opt-in to an opt-out. - Have a build setting without support for legacy names. 3. Remove all the old aliases in next major version, remove opt-outs and build options. Naming consistency isn't a big win, but it's a nice to have. Technically it doesn't seem very hard to do and refactoring a project with the right tools, even a big one, is a few days at most. Consider people who won't update their apps probably won't update PHP anyway, I wouldn't be too afraid of backwards compatibility within a few years. I see there already are two proposals towards this. This [seemingly abandoned one from 2014](https://wiki.php.net/rfc/consistent-names) and this [other one apparently under discussion but not updated for a while](https://wiki.php.net/rfc/consistent_function_names) from 2015.
And ironically but totally expected, the comments are filled with criticism about PHP. I simply stopped caring, they just want to be negative for the sake of being negative. Keep calm and carry on...
That`s how floating point works. Even in other languages. Very deceptive but not a bug.
Interesting `echo floor((0.1 + 0.7) * 10);` is not the same as `echo (0.1 + 0.7) * 10;` Edit: I'm an idiot.
&gt; var_dump ((0.1+0.2) == 0.3);
&gt; Would a long term deprecation plan be possible? It's possible but again I don't really think this is that beneficial. A decent amount of the reason proposals like this rarely make it to RFCs is that few people want to champion an RFC with a BC break that doesn't add any functionality (or remove harmful functionality) at all. Personally I'd rather try to deprecate bare strings which can mask actual mistakes or deprecate passing too many parameters which could allow arity overloading. But deprecating and removing functions that have existed for a long time just to rename them? No thanks.
Hi everyone, i'm a new guy exchange from .Net. So i have a question, in ASP.Net Core it easy to implement new Web API support everything developer need. And in PHP right now what PHP framework can response our require ? (Sorry my english not good, so if i have any mistake pls forgive me)
i wonder if **you've** actually seen it, where did I or anyone else suggest that it's a bad thing. it doesn't straight up give advice either. it's mostly a story about how they grew on microservices and the things they encountered they didn't expect or think well about. it's a pretty good presentation for anyone building microservices, seeing how well it went for them
Pretty much any modern php framework would give you everything to build an api easily. My personal favorite is Symfony. http://allan-simon.github.io/blog/posts/create-a-rest-api-with-symfony2/
Who said I work with PHP exclusively? :) My main backend language of choice now is Go, but I think PHP is a good language as well, not to confuse this with pretty. PHP does the job, it's in the hands of the developer how he uses it.
I always felt that Postgre was always lacking behind and when we were talking about PHP always MySQL was the choice
So, every microservice should have its own HTTP entry point? Isn't that a violation of single responsibility principle?
&gt; 3 - What is the way to get a server up and running? I would say sudo apt-get install apache2, first this IS the quickest way and secondly it gives you the highest level of configuration + interacting with your terminal is always good for learning about interacting with Linux systems. I wouldn't bother with these pre-built stacks, they make a lot of assumptions and usually wrongly and insecurely. Once you have your local stack installed you can move onto things like Vagrant and Docker once you're comfortable with how the stack works
We are aware of that. Thing is that you always have to decide if you have the resources for the perfect thing. As e.g. versioning is not a factor right now, going with our namespace solutions is neither quick&amp;dirty nor insufficient. it suits our case with zero overhead. i will adjust the article naming debian packages, git submodules, composer packages..
Hi, mate I don’t know yore skill level, but this is possible if you are up for a steep learning curve. Alto this may not be the best way to do this, PHP has win api hooks, here a good starting point http://php.net/manual/en/book.com.php I have done some nuts stuff in PHP be fore so id say go for it. 
You didn't give any detail on how you are authenticating users.
Just to add: Magento is not the culprit. The store owners are. The actual exploit is pretty complicated because Magento is really rather well engineered. You can read up on it here: http://blog.checkpoint.com/2015/04/20/analyzing-magento-vulnerability/ The fix had been available since April 2015. 
Nice
I wouldn't use AMQP as a synchronous messaging transport, it's really designed to be asynchronous (it even stands for Advanced Message **Queueing** Protocol, implying that messages are not always consumed immediately, which is also the point of the technology). A protocol like HTTP is better suited to the scenario you describe because the protocol supports request/response and is easy to use in that fashion. Use AMQP for out-of-band notifications or background processing where receiving the result is unnecessary.
&gt; your arguments about how the presentation suggests its a bad thing. That was never "my argument". On the contrary.
Interesting, I wonder what the returns are from this kind of system, I will have to look into the figures 
CTEs are in MySQL 8
Forked before Oracle's purchase 
Got a written variant?
No. if you think about it, in your current architecture every entity as a queue in front of it. In microservices land you would have a http server in front of every service. Then you could orchestrate them all. 
Direct link to the video: https://www.youtube.com/watch?v=9HLQWeBDFcw&amp;feature=youtu.be
&gt; It's floor() not float(). yeah that's what i meant to type
Use AMQP for any async/heavy stuff, for the actual microservices you want RPC type functionality (HTTP, Thrift). I would suggest using an RPC proxy that all traffic is sent through, this enables you to maintain good metrics and solves a few other problems, take a look at https://linkerd.io. Also latency becomes very important as everything is a network request, you will need to measure that stuff - https://www.youtube.com/watch?v=9MKY4KypBzg This is another good article on handling transactions (or not) when doing MS - http://www.grahamlea.com/2016/08/distributed-transactions-microservices-icebergs/ Oh and of course - https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing I have done some experiments with Linkerd and PHP microservices - https://github.com/muteor/microservice_experiment you can see how complex even a few simple services become.
Just have an opt-in system for global backwards compatible functions. In the ini file. Then have functions like String::replace at the very least.
You should use additional tool something like https://ritchielawrence.github.io/cmdow/
It looks like there's a hotspot of use-after-free vulnerabilities in unserialize(), given the number of bug reports solved, so it's likely there might be more. http://www.php.net/ChangeLog-5.php I admit I don't understand much from the reproducible scenarios in the bug reports fixed throughout the year, but are those only manually crafted serialized strings? Basically, is unserialize() safe to use as long as the string always come from a previous serialize() call, right?
working with Spatial data/queries is immensly better in postgres. 5.6 and 5.7 made improvements, but still not anywhere on the level of postgis
There's [this](http://gtk.php.net/)...
If anyone wants to go this route, I implore them to also use `hash_equals()` when verifying the MAC provided with the one you recalculate over the message.
its still exciting.
&gt;tracing JIT takes an enormous amount of effort, skills, and persistence.. Shouldn't be a problem considering what happned to unicode/Php 6.\s Wait a minute? Is isn't this some kind of plan to skip version 8 and go directly to PHP9?
Ah I didn't realise he was using Windows, so my first advice would be, don't use Windows even more so if you're deploying to a Linux based system. I haven't seen anything Windows does better than Linux/Mac for PHP development everything I have come across it's actually worse (harder) to do PHP development on Windows than it is Mac/Linux
For completeness sake, php 5.6 will be supported until december 31 2018. (Now you don't have to look it up yourself) edit: security updates! Normal support december 31 2016
That makes sense, thanks. Ironically, I did find this year two cases throughout the codebase that was storing a serialize() result in cookies. And yes, they did get refactored :)
On the previous thread I posted this asm dump for bench.php: https://gist.github.com/nikic/210d12a1172ab94d92c143083f410754 The current state is: https://gist.github.com/nikic/358523749b969aa45d9cbeac54f06ce2 At this point the assembly is becoming somewhat impenetrable because many opcode handlers have been inlined (or rather, specialized variants thereof). I'm currently seeing a bit over 2x performance improvement on bench.php. However: From a quick, non-scientific test on WordPress it doesn't seem to make a difference there, or even regress performance slightly. This is pretty similar to how things looked like with the previous JIT attempt using LLVM (though with the significant difference that LLVM took ages to compile the code, while dynasm is fast). However, there is still a lot of unexplored space here, in particular the current "JIT" is really more of an AOT compiler, because it does not use any kind of runtime feedback. It simply compiles everything upfront. It's quite likely that performance characteristics will change with proper runtime feedback (wrt hot functions and type info etc).
Maybe sometime before then PHP 7.x will compile out of the box on systems that are not just debian or ubuntu.
Does Debian already get php7 ootb? 
Is HHVM not a tracing JIT?
&gt; First question you got to ask yourself is do you really need all of the complications of running microservices versus a monolithic app. This is what we did at work with our latest big project. Initially started to plan out a gorgeous micro-service based architecture that would (in theory) scale perfectly and be able to shard cleanly and whatnot. Realized after a week or two of planning that best estimates still places concurrent users somewhere in the thousands, maybe 5 digit range. So yeah, we went monolithic but modularized. Sped up development time a LOT. And with the exception of a couple of pain points, it could be split up into micro-services without too much stress.
It IS harder, but only in the sense that you have to get things set up a certain way. It doesn't quite work out of the box in the way that it does on Linux/OSX, but once it's up and running, it's fine. I personally use OSX at work, but Windows 10 at home. I've run into a number of annoyances at home, but they're generally pretty simple to work through. For instance: I was able to configure my command line by adding the Git binaries to my Paths variable. This allows me to run ssh username@website.com commands straight from the cmd prompt instead of PowerShell or the Git Command Line. It's not *hard* per say, it's just annoying that I have to do it.
I've spent that much with both and i ended up using the third, that is PHPStorm... Thing is i still use Atom for quick edits, but for all serious stuff, PHPStorm.
Love it! I do data imports almost every day at my job, and this is basically a way nicer version of my software. If I can port it over (ha) with minimal effort, I will. Thanks for your hard work, and I look forward to contributing!
Using the PHP COM class is a good starting point. - Setup (Windows), open php.ini: add this line extension=php_com_dotnet.dll - Install Microsoft Word - Allow PHP access to COM objects Example code: // Start word $word = new COM("word.application"); // do something here // ... // Close word $word-&gt;Quit(); $word = null; You have to consider - You can only start a single application instance at once (on the whole server) - You have to prevent display alerts - Each instance must be closed properly (if not, the next instance will fail) - You have to check if there are other word applications already started - Sometimes a word instance shows hidden alerts which must be disabled
I would just do private $_expiration; function __construct($expiration = null) { if (!is_null($expiration)) { $this-&gt;_expiration = new Expiration($expiration); } } It's not that verbose, and wrapping it in a routine that created the appropriate type of object would make it harder to read, ihmo.
Don't generalize 3 lines, it does not worth the shot and make things less explicit.
You don't have to `eval`: function NullOrObject($value, $class) { if (!is_null($value)) { return new $class($value); } return null; } 
EDIT: D'oh. Can't read, wrong DB type. https://github.com/dshafik/php7-mysql-shim &gt; This library attempts to create a drop-in replacement for ext/mysql on PHP 7 using mysqli. &gt; &gt; For the most part, it should just work.
As long as the code works, and it is isolated in this function, don't ever try to change it :)
of duh.. thats so obvious thanks!! I forgot you can call functions like that now. vim is my ide.. no complaints at all. 
I have a few years of Gentoo experience behind me, and if you try to fix versions, you end up with very peculiar problems real quick. If you need PHP7 for performances, upgrade your code, if you don't, compile it manually aside instead of using the portage tree version.
thanks man! totally forgot you can call functions like that 
Isn't it a duplicate with another RFC that was abandonned due to performance problems in implementation (runtime checks were actually creating too much overhead because triggered on every property access) ?
I'm glad it was helpful! I think `new $className()` and the like have been supported for quite a long time, but newer PHP versions complain less when you try to do something with the result. 
thank you good suggestion... I could possibly rewrite it to create the internal objects first then use them in the constructor. 
I have used PHP Storm and Sublime. PHP Storm is better, but Sublime is more lightweight. You can add only the packages as you need as needed. I personally miss the simple annotate toggle, but i have similar alternatives once i have the git package installed. Sublime has multiple cursors, before it was introduced to PHP Storm; I was one of the few people who might have requested that on PHP Storm, quoting Sublime does it already and they delivered with the upgrade back in the day and i loved it. It all boils down to does your laptop has lot of RAM, do you have lot of things running in the background and can it handle a heavy IDE. 
A similar RFC was discussed and had an actual implementation, but was rejected: https://wiki.php.net/rfc/typed-properties
It looks like OP is looking for mssql\_* (Microsoft SQL Server), not mysql\_*.
Honestly, that's probably a better approach. It will also come in handy when you want to write tests, since you can have option of passing in another implementation of an interface. But it all depends on the overall design, i think.
for my lower level objects thats what I am doing and I encapsulate most of my checks in their constructors. These higher level ones where I am wanting to use this are essentially where I just capture the data and create the object. I capture any exceptions and report an error. Its all for a web service so I'll never be prompting for a user for feedback. Just reporting an error so this way is appropriate as well. I'll probably try it both ways though and see what the best fit.
I've answered PonchoVire down below, if you're interested :)
Thank you, I did find that myself. Sadly, the extension isn't in portage so it seems I might need to build a package for it myself. To me it didn't seem as if simple rename would suffice - I might have to look further into that.
Thank you for your feedback. However, it's m**s**sql function I'm interested in. 
Unless you need replication that works properly.
It's bad, but like others have said, I've seen worse.
That was my question, yes, and it was academic in any case. Merely curiosity.
dafuq
Despite the fact that I am in full agreement, I believe withdrawing membership means your view is irrelevant. As an aside, the current state of that PSR is awful and does not come close to the standard of its predecessors.
Hello! I'm creating an REST API and need customers to authenticate when making requests to this API, which authentication method is advisable?
[removed]
Then you don't have any choice, you need to upgrade your own legacy code. There is still another solution, you could have 2 PHP versions, one for a specific HTTPd/application and the other more globally used for your other new applications, but this would probably be a sysadmin maintainance nightmare. I strongly suggest that you upgrade your code or keep it running on a different physical box/VM.
With php7: public function __construct(Expiration $expiration = null) { $this-&gt;expiration = $expiration ?? new Expiration($expiration); }
Yes, you either need decimal floating point or integers (representing the smallest unit such as pennies).
Id prefer to bitmask the flags with named consts, or an assoc array of named flags as one config argument But it is stuff like that that makes me want the named parameters concept from python, i.. really like those...
/r/badcode
Assuming that bench.php is primarily algorithmic and WordPress primarily IO.
Has already been written here in the comments, but I also think the best solution would be named constants &amp; bitmask.
As someone who can write basic programs and web apps, what are you going to use instead? I am aware of switches, arrays etc and my code would definitely be different, but I'm wondering what approach would you take as someone who definitely knows more than I? Thanks!
Wordpress is a good sample of real life usecases. And it is relevant to compare the real life performance gain to cost for development. Traditionally PHP is for many parts, even in the engine, quite trivial and anybody with basic understanding of computer software and some motivation can dig into it and understand it. Thus there is a chance to debug issues and new contributors can learn about it and participate. The more JIT/AOT compiling and other tuning you put in the harder debugging and the bar for entry raises and PHP never had the situation of too many engine engine contributors, quite contrary. Still it's a fascinating area which certainly should be explored.
Didn't you get the mailing list? We're going from 8 to 10 to be more like Microsoft.
This is probably not the best way, but a whole lot more readable in my opinion. $thumbnail = true; $vtt = false; ...encode...(['720p','1080p'],$vtt,$thumbnail); _______________ ...function...encode...($dimensions,$vtt,$thumbnail) { return [ '270p' =&gt; in_array('270p',$dimensions), '480p' =&gt; in_array('480p',$dimensions), '720p' =&gt; in_array('720p',$dimensions), '1080p' =&gt; in_array('1080p',$dimensions), 'vtt' =&gt; $vtt, 'thumbnail' =&gt; $thumbnail, ]; }
1. Stop abusing arrays in PHP. &gt; No processor class needed and a lot less code to get at the exact piece of data i need. Of course the calculation has to take place somewhere and you can’t escape looping through the data to add this up but this behaviour should be nicely encapsulated inside the relevant classes. Because I guess if you are using an array and want to count all of this then you are too stupid to think of doing so with a function to aggregate the data? The only advantage a method has over a function is it is encapsulated in the class and as a result it is easier to keep track of. I love it when the OOP fanatics base their arguments on the assumption that whenever you aren't using OOP the only alternative is the most ridiculous scenario imaginable.
That's the impression I'm getting from other people. Is the win32 API library better in python?
I've not been able to find a text style for PHPCS in PhpStorm that is subtle enough for legacy code that totally ignores PSR-2, while also good for new code that is compliant. I still have it enabled, but I really don't like that massive chunks of code are underlined. And obviously it's not practical to refactor code simply to make the coding standards warnings go away.
I was really fond of it while I was using Firefox. I ended up switching (which my phone tried to autocorrect to detoxing, lol) to chrome because of the much faster loading time on start up. I haven't really followed it since then.
Please don't use PHP-GTK2, I was simply pointing out its existence. Yes, Python or native are your best bet. 
Thanks. I had forgotten about Code - I'll open it back up and give it another shot.
There are tons of Python tutorials about MySQL. Check out [pywinauto](https://github.com/pywinauto/pywinauto) for interacting with Windows. &gt; pywinauto is a set of python modules to automate the Microsoft Windows GUI. At it’s simplest it allows you to send mouse and keyboard actions to windows dialogs and controls, but it has support for more complex actions like getting text data.
I appreciate all the feedback about PHPStorm. I'll give it another shot (haven't used it in quite a while). 
Can we for a change focus on readability rather than cramming as much ASCII on a single screen as possible? I mean, white space exists for a reason. Take the first example: https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md That `if` block. Fuck me. For the same reason you want your variables to be meaningful, you explicitly use white space in code formatting to give meaning to individual blocks of code, i.e. so they stand out to "the eye": if ($a === $b) { bar(); } elseif ($a &gt; $b) { $foo-&gt;bar($arg1); } else { BazClass::bar($arg2, $arg3); } I would strongly suggest that you would do some actual scientific research in the readability of source code before pushing out yet another PSR based on "personal taste" or OCD line-cramming. Good luck with it... 
Ditto. FireFox got too slow and I think most developers and end-users as well moved away from it.
That article is wrong. Use integer, and divide by the correct amount based on the currency (usually 100) only when rendering. Source: I work in payments. 
The CRUD code examples look a lot like Active Record. I still don't understand how this is any different :/
Wait. Why did they even do this? I mean, Why? Just. Why? This reminds me of a time that I tried to run some Java code through a decomplier, and it turned all the switch statements into nested ifs that called gotos that led to the right code...
Looks kinda iffy
Get the legacy app to run through docker: https://docs.docker.com/engine/installation/linux/gentoolinux/ 
Am I the only one that absolutely can't read grouped `use` statements? I really can't stand them...
The difference is simple, no doubts you can learn to tell it on sight. With AR, a data entity has all the methods for the database interaction implemented in itself. I.e., a book has a method to find itself: $book = Book::find($id); With DM, some external object is used for the purpose : $book = $atlas-&gt;fetchRecord(Book::CLASS, $id); You see, in one case the data entity is outside, and in another is inside. As simple as that.
Or just object of a class with a small, simple, clean constructor
FIG and everything they do is hot garbage. I guarantee this thread will turn into another FIG drama thread.
I completely agree. This is the only point I deviate from PSR unless I'm working on open source code that requires it. I really dislike the else statements on the end of that previous parenthesis.
That reminds me of when I was a kid and was playing the original *Twisted Metal* on Playstation. I thought the 3D models has a separate sprite for every possible orientation and thought "no wonder they needed a whole CD for this game!"
Well, games like Doom did do that, they "cheated" on rendering by overlaying 2D sprites on a 3D background.
woosh ... :P
Why not just use bcmath?
Sorry that didn't come off as well as I'd meant for it to. I just meant in terms of precision, assuming speed and availability weren't issues. Edit: judging by the downvotes it seems that no one should ever do precision math in PHP, /thread.
Nice! Improvement is always welcomed! But I must register that PHP is already fast enough for 99% of our needs. That remaining 1% being webscale™®©. Currently the bottleneck usually is the database. Yet PHP devs are still pushing the limits and I love it.
It's a seriously grave mistake to not support 1440p, I agree!
Even if those weren't issues (and they always will be), it's less practical for day to day work. There's a small skew towards taking API inputs as integers (so less conversions), and having to wrap every. single. calculation. in the bcmath functions is a huge pain. Granted, this is largely all abstracted by using a Money object ([e.g.](https://github.com/moneyphp/money)), but it also varies wildly by language, and my work is by no means PHP exclusive.
Great, now it's stateful :-/
I just started learning PHP a day or two ago, so excuse my nooby-ness. This is said in the article: &gt; Most programmers who have only casually used PHP know two things about it: that it is a bad language Why is that? Should I avoid PHP and focus on other languages? 
Unless your AR can guarantee that your objects are always in a valid state, it's nothing more than a typed array with a save method.
Not to mention the off by 1 cent issues caused by rounding issues in JS. Integers are the way to go.
There's a case where I deem it valid. Symfony has a configuration component that allows you to build a tree to validate the array, which can than be used to manipulate the DIC. However, this is part of the compiling process, thus not run-time.
You're lucky that it has comments on what it does. I just finished refactoring a function that uses F1 ... Fn (where N reach to 12) as a toggle what should be done in a huge nested IFs with no comment whatsoever what it actually does. You know the worst part? It was written 6 months ago by someone that has left the company.
I hate these kinds of shitpost. Here's your validation buddy. 
Damn, I knew I should have raised some "irony" sign.
There is no reason for it, it's likely the "simplest thing that worked at the time" as is the case in many, many legacy projects. The snarky title in this post when the patch is so simple really throws me off... folks just like to shit on everything, I think. Better solution, in this specific example, would be a legitimate use of singleton + factory procedure that all clients would use. Since this is (was?) the only place that uses HTMLPurifier, I could see someone just not caring all that much. All that said, it's a good opportunity for someone to send a PR :P
Shit like this is why I try and limit how often I /r/php daily. I can only imagine (by the tone of this article) what the initial emails notifying the maintainer of this project looked like: snarky, dismissive and aggro as fk. To be sure, for such a trivial fix to mitigate, several months is excessive but I, as a fucking human being, understand that folks that maintain open-source software have lives outside of GitHub and sometimes they're dealing with some VERY REAL shit. So in the time it takes to type up a blog-post slamming a project for "not knowing how to use HTML Purifier", why not contribute the +14/-1 patch that might not be perfect, but solves the immediate problem and serves as an example for further work done by others. Idk... maybe I'm just a pissy dick. /edit Oh... and https://github.com/philippK-de/Collabtive/pull/120 /edit2 PR was merged within 2 hours of submission
I don't read them and don't write them, thanks PhpStorm!
Another terrible tutorial that teaches bad practices. WHAT YEAR IS IT?!?!?!? STOP USING MD5 FOR HASHING PASSWORDS! password_hash / password_verify is now available in every supported version of PHP. On the plus side, at least this code doesn't use the removed mysql_ functions or suffer from SQL injection attacks.
Do you remember what the reasons for voting no were?
I don't understand why we need to spread all those ::CLASS references around our code. I thought we've learned that the ability to configure objects' state and implementation is good, and one of the prerequisites for this is we refer to configurable instances, and not to static class names. Also makes an impression on me that the constructor takes "raw" connection settings, that look like PDO DSN. Why doesn't it simply take a PDO instance, or whatever connection object it prefers? It automatically means you need to open two connections to the same data if you want to do a direct query *and* use Atlas for other commands and queries. I'm also unsure of why Record is being used instead of arrays, when both seem to be simply indiscriminate bags of fields. Arrays have their issues, but at least they work with the huge set of *array functions* for flexible transformation and processing of data, and they're *copy on write*, unlike objects, which helps us avoid "spooky action from distance" bugs, or having to clone records defensively all over our code.
&gt; PSR-12 isn't made of thin air. It's made of PSR-2. By that definition we don't need PSR-12 as we already have PSR-2. If the goal is to represent what the community does, then polling from some mailing list with a low visibility is not scientific, while sampling actual PHP7 projects is. I don't see why you'd reject the notion. Additionally, I checked the poll, and the questions are unclear, and you can't judge the correct response out of context, without practicing this in your PHP7 code and seeing what the implications are. This poll is simply put quite the amateur effort.
For a short period of time I worked for someone who made a good chunk of money by selling a PHP shop system with this kind of crap in there. Oh, and he also complained about open source projects, because then he couldn't charge more for his software. So he literally had no fucking clue about programming, built something on top of a stack of hugely popular open source projects (LAMP), earns his living by relying on all this software to be free, googled all his code and got is answers probably from SO, and then complains about other programmers releasing stuff for free. Needless to say, I quit after 3 or 4 weeks.
Haha what an idiot. No, wait. You can't tell from that **image** what the source code is doing or why it was written that way. But now that I look at it, it looks maybe like something I'd do to make a [facade](https://en.wikipedia.org/wiki/Facade_pattern) to bridge the structure of my application with some different code base. Or maybe he was trying to rewrite some CS code into PHP and copied over their conventions without thinking. Maybe he has to add to some legacy code that is too old and brittle to risk major restructuring. Maybe he started off with just *two* video formats and now has to support *seven* and rather than refactoring, he's chosen to live with the less-than-optimal pattern he started off with because he knows it works. Maybe (this is my bet) he's connecting a PHP application with a video encoding library with a very particular signature. Or, and this is a total guess, maybe he actually wrote it that way because that's the best way he could think of at the time to solve the problem he had at that moment. Haha. What an ultra-maroon. I bet he still loves this code. Best thing he ever wrote. Glad I was never like that. I'm a God! Just don't look at anything I wrote three years ago. What embarrassing garbage.
id do it, if its for my own use, you never know what you will learn along the way.
If you're using something like PHP-FPM then it would be trivial to install PHP 5.6 alongside 7.0. You'd just need to set in your virtualhost which PHP-FPM socket it should connect to.
or maybe don’t run php5-fpm as root, but as the project user instead?
&gt; we don't care much about precision Remind me to not give you my card information.
Probably yes. If you don't agree, vote against it while filling the poll.
Have you looked at the Drupal 8 Migrate API? Taking a quick glance at your docs it seems they have a bit in common, you might even suggest Drupal uses your library for Drupal 9 :)
I am not familiar with the Migrate API, though a [cursory read](https://api.drupal.org/api/drupal/core!modules!migrate!migrate.api.php/group/migration/8.2.x) does indicate many principle similarities, so thank you for bringing it to my attention. I wouldn't be so bold as to suggest a project with which I am not familiar should adopt my solution though anyone is more than welcome to integrate Porter into their projects if they wish, including Drupal.
Yessir!
https://developer.mozilla.org/en-US/docs/Tools/Web_Console/Console_messages#Server Firefox 43+ has native support for ChromeLogger messages, though that’s also out of date. Not sure what there is that might need specific updates.
No you definitely are not!
It amaze me how easy you can spot Indian contributions trying to self promote just by the title on this subreddit ... And everytime the article content is a tutorial on how to enable a basic thing. Already answered a million times on google. Btw, where is `mod_deflate` ? Proof on their twitter : &gt;We are IT Company. &gt; &gt;Gujarat, India &gt;awesomeinfolab.com As a png : [pic of twitter](http://imgur.com/a/rzrjd)
More than what?
Yeah I do not understand this either ;)
I can't stand that namespace grouping, it becomes quite difficult to see in one blink which namespaces you're importing. I also feel sorry for the people that have to implement changes for stuff like phpcs and IDEs. Namespace grouping is one feature that php didn't need. edit: Note to mention you can't copy-paste a line that easily and refactoring would take a lot of extra lines if 2 imports become only 1. Lots of unnecessary line changes in a commit with extra chance of breakage.
This is still a terrible idea. You shouldn't elevate any privileges for an application user ever. Period. If you find yourself needing to hack like this to make things easier for yourself, you need to find a better way to do it.
I haven't seen it run like that before. It may be possible, but php-fpm typically runs just like a web server and similar tools: 1. Starts as a master process, run as root 2. Creates a resource pool as your configured user (often www-data on deb/ubuntu or apache on centos/fedora/redhat). Processes handing PHP requests are run as this configured user. In that standard setup, sudo is still needed as the master process, run as root, controls the resource pools life cycle (restarting/shutting down/re-creating them). So, you may know more than me (altho I've never seen a different setup from above), or you may not understand how this works. I'm not really sure, but you can see where I'm leaning I'm sure. This is the internet after all.
&gt; Integers can work, but when you're calculating this such as strange tax rates you'll frequently end up off by a cent. This is super easy to mitigate. If anything, I prefer the granular control over what kind of rounding happens. Only a naive first implementation will have "off by a cent" problems.
Fair criticisms; longish answers follow: &gt; I don't understand why we need to spread all those ::CLASS references around our &gt; code. I thought we've learned that the ability to configure objects' state and &gt; implementation is good, and one of the prerequisites for this is we refer to &gt; configurable instances, and not to static class names. When calling (e.g.) `$atlas-&gt;mapper(MapperName::CLASS)`, you are in fact getting back a configured instance from a Mapper locator. The `MapperName::CLASS` is just an identifier for which mapper you want. &gt; Also makes an impression on me that the constructor takes "raw" connection &gt; settings, that look like PDO DSN. Why doesn't it simply take a PDO instance, or &gt; whatever connection object it prefers? Couple of reasons, mostly related to underlying layers. Atlas uses [Aura Sql](https://github.com/auraphp/Aura.Sql) at its foundation, and the ConnectionLocator therein. The connection settings you see in Atlas are passed to that locator for it to manage lazy-instantiating of ExtendedPdo objects (which themselves lazy-instantiate an underlying PDO instance.) &gt; It automatically means you need to open two connections to the same data if you &gt; want to do a direct query and use Atlas for other commands and queries. I can see why you'd think that; however, I have anticipated the situation you describe. Atlas is built in several layers, and you can reach down through those lower layers to get at just about anything you might need. For example: $extendedPdo = $atlas -&gt;mapper(MapperName::CLASS) -&gt;getTable() -&gt;getReadConnection(); Now, that violates a lot of reasonable sensibilities, but the point is that there's no need to re-create a connection if you want to do more "raw" work. (EDIT: After re-reading this, I think it might be reasonable to add `getConnectionLocator()` on the Atlas object itself.) While we're here, the layers are: - The overarching Atlas object - Mapper, MapperSelect, Record, et al. - Table, TableSelect, Row, et al. - Aura [Sql](https://github.com/auraphp/Aura.Sql) and [SqlQuery](https://github.com/auraphp/Aura.SqlQuery) - Pdo &gt; I'm also unsure of why Record is being used instead of arrays, when both seem to &gt; be simply indiscriminate bags of fields. Mostly to keep track of the main Row object vs Related records and record sets. It's also place for (careful!) addition of minimalist behaviors. As Atlas is a persistence modeling system, not a domain modeling system, I officially recommend against doing so. However, it can be super-convenient to (e.g.) expose a Row date string as a DateTime through a record method, and perhaps provide other trivial behaviors prior to building out a full domain model. I don't expect these answers to satisfy, exactly, but I do hope they begin to explain some of the rationales. Thanks for taking the time to critique it in the first place. 
OH, but that would be personal preference.
I can offer this experience from one Atlas user: &lt;https://www.futureproofphp.com/2016/10/10/complex-database-relationships-with-atlasorm/&gt;
ChromeLogger has a fraction of the functionality of FirePHP, although the basic concept is the same.
As of PHP 5.6 the default is `MCRYPT_DEV_URANDOM`.
Yes, well this is not changing any day for PHP so... I'd like to point out that guards can be practically free on a modern CPU. Less than 10% slowdown for JS if I remember correctly. 
Input doesn't have to be HTML. Accepting untrusted HTML should be a last resort solution. 
Interesting idea, but I don't know if someone would like to slow down their method dispatch several hundred times through reflection and what not, when the alternative is pretty simple: function bar($baz) { if ($baz instanceof A) { $this-&gt;functionThatProcessesObjectA($baz); } elseif ($baz instanceof B) { $this-&gt;functionThatProcessesObjectB($baz); } else { throw new \Exception('Expected A or B for $baz'). } }
&gt; using mcrypt There's your problem! But to be fair, this was written in 2012.
https://wiki.php.net/rfc/mcrypt-viking-funeral
I don't see the benefit of a user land implementation and merely looks like a hack to me. Interesting how it works though.
Except you can't see how it really works because it's buried in some Laravel shit.
&gt; You should be able to start here and work your way through from there. First thing I see there is that a static method "getTableClass()" is directly invoked on that passed-in class name. You said I can set a configured instance, and instead it's static. I've been lied to. It hurts a lot. EDIT: It actually gets worse down that method... the given class is used as a prefix for an "Event" class. Come on, man... What is this, PHP4? &gt; Not quite; the use case is the reverse of that. That is, if you are already using the ORM, you can get the raw connection out of it. What happens if I need the connection, and I might or might not use the ORM in this request? That was the obvious and original use case I was referring to. It makes no sense to instantiate a higher level component, in order to obtain and use one of its lower level dependencies. This is something that, frankly, I'd expect to see in code from late 90s, not today, when dependency injection is obvious to everyone. Good thing is, fixing it should be easy, so I hope you'll consider it.
The slowdown depends on the code surrounding it. It basically is a simple cmp+je, typically getting perfect branch prediction. You cannot express this as a percentage. Anyway, types aren't that dynamic in PHP. It's trivial to just generate multiple variations of a function depending on the input type and use the matching variant on the caller sides. Depending on the code you're executing, tracing JITs may end up slower than actual AOT compilation.
Not going to argue that; but the main point here is that it's unnecessary to wrap a generally self-contained thing except for a "fluent OO array manipulation framework" into Larevil…
Well if Facebook's early HipHop experiments mean anything, AOT for PHP turns out to be performing worse than a VM.
the best book! :)
&gt; In an ideal situation, it would query each table once or join some tables and have less than 20 queries. I wasn’t expecting this. That's probably where you'd use a [fetch-join](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html#joins) which returns the root(s) of a graph where your joined objects are already set up because it was done in one query. &gt; $query = $em-&gt;createQuery("SELECT u, a FROM User u JOIN u.address a WHERE a.city = 'Berlin'"); $users = $query-&gt;getResult(); &gt; When Doctrine hydrates a query with fetch-join it returns the class in the FROM clause on the root level of the result array. In the previous example an array of User instances is returned and the address of each user is fetched and hydrated into the User#address variable. If you access the address Doctrine does not need to lazy load the association with another query.
Uuuuh… ehm… AOT is pretty much what we have right now, without any real optimizations yet. … and it's not slower. I see a lot of potential there...
I mean that an optimal AOT is much slower than an optimal JIT VM for PHP, due to inability to retrieve runtime type information to do type-specialization.
What's the output of: $output = shell_exec("po..."); var_dump($output);
Not sure, but this contains some history : https://github.com/pmjones/php-history#a-history-of-php-frameworkslibrary-collections 
&gt; Honestly, Laravel is the one thing that kept my company and me from converting to being a Rails shop. Spoken like a true engineer. It's kind of unfortunate you guys didn't convert. You'd feel right at home on Rails.
bool(false)
You could run a script after composer install/update command to delete dependencies in the vendor folder. https://getcomposer.org/doc/articles/scripts.md#defining-scripts
That hasn't been updated in a year and a half.
The last time I wanted/needed some overloading (for event-handling methods) I put the responsibility in a separate class which was responsible for scanning targets, caching the mapping, and sending to the appropriately-typehinted target, ex: public class MyClass{ public function handleFoo(FooEvent $evt){...} public function handleBar(BarEvent $evt){...} } public class EventDispatcher{ /* Finds functions named handle* with one argument * that is typehinted with a subtype of Event */ public function sendTo($target, $evt){...} } $obj = new MyClass(); $ed = new EventDispatcher(); $evt = FooEvent(); $ed-&gt;sendTo($obj, $evt); In this way, the actual name of the method wasn't really important, so there wasn't a problem with name-collisions. Obviously it's not as useful if methods *on the same object* need to call one-another, since you'd have to inject the dispatcher as a dependency to each object.
I tried out [Fusebox](https://en.wikipedia.org/wiki/Fusebox_%28programming%29) sometime in the early 2000's, which is not on that list. Not a comment on the list, but just adding to it.
It's not complete though, missing Symfony 3.0 for example
Yeah I know, and the latest stable release is from 2008! I'm not advocating the use of it, just pointing out that it can be done.
 &gt;it's impossible to mistake my asshole personality with anyone else. But... I also think my arguments are objective. You misunderstand me -- it was delight in recognition, not reason to dismiss. :-) Regardless, your earlier point about injecting a pre-existing connection is well taken. The latter points I may or may not address in a timely manner, but they are noted. Again, my thanks for your critique.
I think technically you'd want to throw an `InvalidArgumentException`, but otherwise this seems like a much better solution.
You can pre-compile specialized code sections and have a runtime switch for that. But you are talking _optimal_ AOT and _optimal_ JIT. An optimal JIT starts with all information which is statically available and then adds runtime info. Usually JITs do tradeoff a bit more between compilation time and optimization than you do with AOT compiling. But yeah, sure, in a bunch of cases JIT is faster, especially when the code is very dynamic, but the types passed at runtime always the same.
Who said there is anything wrong with Laravel? There is, but that's besides the point.
Or you just use selenium or phantomjs to do it for you. No need to get iffy scripts from this page ^^
FYI, you need to double all your backslashes and escape that properly. Should look like shell_exec("powershell.exe -File C:\\inetpub\\wwwroot\\altirisinstall\\startinstall.ps1 ".escapeshellarg($computername)); 
Still no luck, I can't get anything to run, .bat or .ps1 All of my scripts run fine by themselves, but if I try to initiate them from the web page, nodda.
Ain't it silly to use Google's tool to create thumbnails...
The best you'll be able to do is capturing the progress of the whole HTTP request using the progress handler you're already capturing. So in order to get the progress of single files you'll need to split up your upload to one request per file. Alternatively you can try to get the individual file sizes (not sure if you can do that?) and basically try to guess what the file progress is based on the progress of the whole request. 
I started to work with PHP frameworks in 2006. These days it was Seagull PHP Framework which was powered by PEAR components. If you read its description https://web.archive.org/web/20051201041431/http://seagullproject.org/ you will noticed that nothing dramatically changed in FWKs world. OOP, standards, modules, good practices, everything was there back in 2006 :)
I expected to see posts like these, this was really fast! :) I don't disagree with the core of what you write (...except for YAML. YAML sucks and should never be used, ever.) I wrote this for myself, and it's been a big productivity boost -- enough to set the academia aside and consider sharing it I suppose. It subscribes to what Doctrine proposes with its own annotations I would think: 1. Make a mess with (insert favorite expletive) annotations while you build, it helps you build rapidly. 2. Clean things up exporting to array routes (as this module does) or XML configs (as Doctrine can) for production. The end result doesn't feel forced. It's simply an optional convenience for those that want to work on routes/controllers right against the actions that make them work (in a same file). Gear switch time to me, is a worse demon than using artificially supported annotations. I imagine I'll be able to leverage the documented routes in developer documentation too. 
I'm with you.
This is what PSR-12 requires as well. See the second example underneath ["3. Declare Statements, Namespace, and Use Declarations"](https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md#3-declare-statements-namespace-and-use-declarations)
I have to be honest, I'm not very likely to do any open ended "Scientific Research" on something like that. Like /u/sam_dark said this is an area where we could certainly use help and there are many ways to get involved! Do keep in mind that one of the [stated non-goals is contradicting PSR-2](https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide-meta.md#32-non-goals): &gt; PSR-12 will also not change anything stipulated in PSR-1 and PSR-2." So a change like this is likely to be an uphill battle.
As unwieldy as that is just to start, I imagine it becomes *far* worse when doing this with multiple method arguments. Though my take is to not pretend PHP has a feature it doesn't, and adjust your naming accordingly. Ideal? Not really, but also far less likely to confuse people.
You are just trolling, arent' you? 
I highly suggest you look into Goutte: https://github.com/FriendsOfPHP/Goutte
https://laravel.com/docs/5.3/collections
It's also creating an iv to decrypt? And using ecb mode. This is a terrible example all around.
&gt; Make a mess with (insert favorite expletive) annotations while you build, it helps you build rapidly. I have to say I disagree with this. Making a mess by definition, slows you down. A centralized route configuration (or even one broken up by module), gives you a frame of reference for what maps to what. It requires *less* convention. It also lets you group routes together to apply common middleware to them, which requires much more configuration when you use annotations. Also, annotations are fundamentally slower for development. You need to glob over the controllers directory (and even specify multiple controllers directories depending on the complexity of your app) and reflect each and every file to get a list of routes. Doing this on every request adds *NOTICEABLE* performance issues when developing locally. Laravel 5 tried doing this and it tripled the TTFB for me once I got to a sizable number of controllers. I quickly abandoned annotated routes and went back to route files.
&gt;The reason why using /dev/random as default is that /dev/urandom is predictable Bullcrap. This is wrong, wrong, wrong.
You really shouldn't be relying on /dev/random not blocking, regardless of how much seed material you feed it.
I agree to the extent that this was poorly titled. Instead of PHP, it should have been "method overloading is possible with laravel". As for Maltradee's comment, it shouldn't be tolerated here on /r/PHP but It also makes him look like a clown.
It would depend on what you want to classify as a framework. Things like typo3 are from 1997: https://typo3.org/about/the-history-of-typo3/ 
I meant, making a mess in the academic sense. The system still compiles a standard ZF route config, complete with FQCNs as one would create manually, so there's no less stricture with convention. Reflection and mapping only occurs in development mode, when you set it to prod (ZF config) it's business as usual. The overhead is actually negligible as I examine it on a current app. Here's a comparison graph as profiled with Blackfire: https://blackfire.io/profiles/compare/1dd2b62b-b578-47fd-8107-ffba4536d4be/graph 394ms render to 691ms render 5.8 to 5.9mb usage I'm not sure how Laravel had implemented this, I have always stayed with Zend Framework; but things do seem fast with zend-code and doctrine-annotations. Note: I'd certainly ditch it too if it became a performance bottleneck, but I suspect it will continue to be well behaved. I profile regularly, it's certainly something I'll monitor. Thanks everyone for the discussion! These considerations, are near mirrors of thoughts I'd had along the way. I think with the time saved, it'd be trivial to split them by module as de facto route configs if it there was ever a want to extricate it completely post-dev. I'd still win on the time aspect of things. 
Assuming that data always needs associated behavior is not any less naive than programming everything as arrays. 
What don't you like about it?
2nded, do not use SimpleHtmlDom, it's terrible. 
If it's just a one time clone maybe you could use something like https://www.import.io I haven't used it (beyond a free trial they used to have) but it seemed to work for some sites. Also, if it doesn't have to be PHP there are some good tools out there for web scraping in Python that I have used before.
So, I did this as a job for almost 2 years. Worked for company that scraped a lot of data. To be honest with you, I got way more done with curl and regexes, then you would think would/should be okay. (like recreating the request cycle of an asp.net page). Now, a lot of the time, the data I was scraping was on crap websites with barely (if at all) valid html. So, if you are dead set on using php, the pages you are scraping better be well formed. Otherwise, use javascript, casperjs sits on top of Phantomjs, and is much much better at this than php ever will be. Feel free to send me a message, I'd be interested in helping out if you hit a brick wall. 
&gt; However, this breaks the fundamental principle of programming. Can you please link us to this fundamental principle of programming? What does it say? Who coined it? How was it proven? Annotations are indeed easy to abuse, because they apply implicit behavior that's hard to track in your code, but that applies also for Java. The fact it's in a PHPDoc comment for PHP is largely irrelevant. BTW, how the heck isn't everyone getting tired of posting the same shit over and over again? Amazing.
&gt; Code MUST use an indent of 4 spaces for each indent level, and MUST NOT use tabs for indenting. Oh come on, please, let people use what they want, this is silly.
&gt; It's a mess in a real sense, in that if you follow the source that your app runs on bootstrap, you reach a dead-end where nothing happens, except when you run it, something happens. Only in dev mode while you are sorting things out (faster than the next guy, who is stuck routing in a more-obscure yet traditional manner). Consider for argument's sake, that one could remove the automatic init aspect, and replace the load listener for a simple CLI command that compiles routes "in the right place" as though it were manually done. The automatic aspect becomes a convenience, no implicit jump occurs. &gt; the effect of the annotation should be where the annotation is. I understand why you write this, and agree. But, from a productivity point of view there's no denying that the route being defined immediately next to the method it targets, is tremendous. How much time have you spent debugging magic param routes in code written by others? Scanning bad routes is a thing of the past when the route config and method are right next to each other. &gt; When we don't follow this rule, we're effectively obfuscating our code using goto-like logic, and this is a step back. That's a strong abstraction one could translate to the event manager (widely accepted, and quite ubiquitous if you use ZF) I'd think. Highly effective, it can be trapped anywhere throughout the code - triggering disjoint snippets throughout the module space. One wouldn't call its usage a magic goto -- but you'd have a hell of a time mapping its invocations at bootstrap. Conversely, I do agree that goto is not good. 
I may be misunderstanding you but if you look at the gist you can see what I though was a clear indication of what the allowable signatures are? public function someMethod(...$args) { return $this-&gt;overload($args, [ // Call this closure if two args are passed and the first is an int function (int $a, $b) { return 'From the Closure'; }, // Call this method if the args match the args of `methodA` (uses reflection) 'methodA', // Call this method if the args match the args of `methodB` (uses reflection) 'methodB', // Call methodC if exactly 2 arguments of any type are passed 'methodC' =&gt; ['*', '*'], // Call methodD if 3 args are passed and the first is an array 'methodD' =&gt; ['array', '*', '*'], // Call methodE if 3 args are passed and the last is a closure 'methodE' =&gt; ['*', '*', Closure::class], ]); } private function methodA($arg1) { return 'Method A'; } private function methodB(\DateTime $arg1, array $arg2, int $arg3) { return 'Method B'; } private function methodC($arg1, $arg2) { return 'Method C'; } private function methodD($arg1, $arg2, $arg3) { return 'Method D'; } private function methodE($arg1, $arg2, $arg3) { return 'Method E'; } 
&gt; But, from a productivity point of view there's no denying that the route being defined immediately next to the method it targets, is tremendous. I just can't see it this way. A method is a method, it shouldn't care who calls it and how it calls it. The only thing a method should care about is three things: - Its input. - Its output. - Its object's state. When you put this information there, you increase the cognitive load on thinking about this controller, you add additional bullet points up: - How is this method called. - Is the way this method called conflicting with the way other methods/controllers are called. A trivial way to demonstrate why "how it got called" doesn't belong at the method is that a method can be called more than once, in more than one way. Do you attempt to create reusable controllers? Not all controllers are reusable, but some are. Controllers for exposing JSON APIs, RSS feeds, or even controllers in reusable modules, like a blog, or an admin CRUD editor - they are reusable. Also error controllers, like 404 controllers. Same class, different routes. I also have a single controller for exposing static pages. I don't mindlessly create lots of empty classes with a route on them. I just point multiple routes at the same controller. Common sense, I think. But not with annotations. When a component encourages such out-of-band information to be embedded *in the class*, singleton-style, then developers simply aren't looking for these opportunities, because it puts them in a mindset to think about controllers as mindlessly repetitive, redundant copy-paste snippets in their projects. They fail to think about reuse. With routes in annotations you explicitly couple the method 1:1 with something outside of it, with which it should have an N:1 relationship (method invocation:method) not 1:1 relationship. &gt; How much time have you spent debugging magic param routes in code written by others? Scanning bad routes is a thing of the past when the route config and method are right next to each other. On the contrary. One route can still shadow another route, easily, and to figure out which is the "bad route" you'll have to open all your controller files and inspect their annotations. If the list of routes is centralized you can open a *single file*, and sequentially inspect the list of routes and identify the "bad" one. You can also resolve conflicts by route prioritization, i.e. their linear order of resolution. With annotations, you lose control over order and it becomes arbitrary: whatever the code generator decides, that's the order. I also wonder if order might change due to some innocent change like renaming a class. Depends on how the annotation processor is written, but it's certainly possible in the general case. &gt; That's a strong abstraction one could translate to the event manager (widely accepted, and quite ubiquitous if you use ZF) I'd think. Highly effective, it can be trapped anywhere throughout the code - triggering disjoint snippets throughout the module space. Yes, in fact, that has a similar "implicit spaghetti" effect and I avoid it for the same reason. Or more specifically, I avoid confusing events with delegates. An event is something that has happened, and someone listening for it can't affect the domain, or change the fact that this event happened in the way it was communicated. A delegate, however, can return a result and affects the would-be-outcome of the system. Decentralized events are harmless, and when used correctly, incredibly useful (case in point, my nickname). Centralized delegates are also harmless, and when used correctly, incredibly powerful. But decentralized delegates? Ouch. Event handlers and delegates are very different, but frameworks like Symfony and ZF confuse them, and yes, the outcome isn't pretty. It's not incidental that Symfony uses annotations with indirect effects, and uses events as delegates. It doesn't seem that its architects understand the implications of scattering their control logic around the codebase. They just accept the resulting complexity as a fact-of-life of managing a large application. But it really isn't. It's poor architecture.
Annotations are nothing more than metadata. Your application also stops working if you remove a config file, its what you got tests for. I love annptations, they make configuring stuff way easier, especially when configuring class/property specifics. So whether they are language specific or in docblocks (NOT comments!), I don't care, they work and they work well.
Annotations are metadata if they are defined as native syntax, like how they are used in Java and C#. The problem with PHP Annotations is that, PHP does not support annotations natively. The docblock annotations approach is just a terrible workaround that turns comments into metadata, which is totally wrong. I already stated that I am NOT against annotations in general, but I am definitely against comment-based annotations. Apparently, you didnt read carefully at all. Maybe you dont care about good practices, but many people care. A rule of thumb is not to fight your tools, PHP does not support annotations, this will not change at least in foreseeable future. And again, docblocks ARE comments, and are treated by the compiler like comments, just because you dont consider them as comments doesnt mean they are not comments. Every newbie coder knows that he should be able to edit or remove comments without breaking code, but docblock annotations make this impossible. PHP Annotations are abominations, Id say they should not be used for configurations per se. 
Tabs mess up every default setting and browsers. I hate it when someone pastes some code and everything is indented 8 spaces and they use a bunch of nested statements, reaching and indent of 32+ on most lines. PSR makes sure that everyone working on the same project keeps the same codestyle and same way of indenting. It also specifies how code style fixers should format things in case of stubborn developers. I don't like every element of PSR, but it makes for great consistency, regardless of codestyle.
Example 1: Common floating point problem: https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems Nearly every programming language has this kind of "problem". Example 2: This array does not make any sense to me ... $array = array( 1 =&gt; "a", "1" =&gt; "b", 1.5 =&gt; "c", true =&gt; "d", false =&gt; "e" ); var_dump($array); Array key 1 will be overwritten by "1" (converted to int -&gt; 1) which will be overwritten by true (converted to int -&gt; 1). 1.5 is not a valid array key. And false will be converted to int -&gt; 0 Result: array(2) { [1]=&gt; string(1) "d" [0]=&gt; string(1) "e" } Edit: formatting
I care about good practices a great deal and I think even comment annotations are superior to other forms of object metadata configuration. I did read carefully, you are against metadata in comments, but in php comments != docblocks, the compiler in fact does NOT treat them the same and even have a different constant. Docblocks are even available in the reflection of a php object: http://php.net/manual/en/reflectionclass.getdoccomment.php If you want, you could also write a parser and read yml or xml from those comments, potato potato. In the end you're doing nothing more than reading a bit of text and converting that to php, regardless of the contents being in a yml file, text file, php file, xml file or annotations in a php file (which provide way more context than the previous stated). &gt; Every newbie coder knows that he should be able to edit or remove comments without breaking code And they should also know to write and run tests before pushing code. As I've stated before, you can't simply remove configuration and expect things to still work. Yes, it's configuration, a newbie should be able to see that annotations are different from documentation, even though it's "fragile" in docblocks. I 100% agree that the current way of having annotations is a hack. However, I consider it rather elegant and extremely useful. I also think that php should simply port the doctrine annotations behaviour. If you want to write everything in files which give you an extra find step to collect info about the object in question, be my guest, I'm not going to argue about personal preferences. But saying Annotations are abominations is not true. They work and they work fine and I don't consider them a bad practice. I am of opinion however, that in vendor/open-source packages, you should use XML where possible: * You don't have control over their configuration thus can't rely on the comments option * They might not have the ability to use the caching layer and thus suffer run-time performance loss. For everything in-house/private I will _always_ suggest Annotations where possible (at least where it makes sense to use them), simply because it makes the life of a programmer easier. 
&gt; If you'd use symfony, it doesn't matter whether you use tank, XML or annotations. All info is compiled into a static route matcher. You should see annotations as another configuration method, not executable code. It's nothing more than adding metadata to an object, which can be used to manipulate your app (preferably cached away). If the form of your source code was irrelevant, we'd be programming in assembly. How code looks, and where it's located in relevance to its related concerns matters. So I reject the notion that only the final form matters. You're not building the final form, and you're not using it to reason about your project. So the abstraction you're actually using to model the project should be designed to easy to reason with, and unclear code jumps are in fact a big problem. Additionally the source is not just a unit of reasoning, but also a unit of sharing. This has real implications: for example by using annotations you're fusing your configuration with your library, so when you share this library it is far less configurable, than if the configuration was explicitly factored out. When people fuse configuration with behavior, they fail to recognize reusable aspects of their code and tend to copy-paste and write redundant code. Have you felt making controllers is a bit repetitive in Symfony, probably? That's one big reason why.
&gt; The annotation has 0 effect on anything until someone or something decides to do something with it. This applies for your entire codebase. It's a bunch of text until something (say, PHP) decides to do something with it. I don't see how this changes anything I said. &gt; Take for example Silex [...] This is practically the same as [annotations]. It's only (roughly) the same if this method is on the class of $app, which is the router here. Is it? No. I understand the difference is subtle, but let's get the syntax away and describe *intent*. Your first example's intent is this: *call the function I'm passing when you, $app, match this route.* Your second example's intent is the precise opposite: *call me when SOME app matches this route.* Which app is the app in question? What if this controller finds itself in a library and is invoked by two different apps that use annotations? How'd you resolve the conflict that those two apps need different routes? Would you just have one ignore the annotations, and let that thing sit there as some vestigial organ, pointing back to simpler times where having "THE ONE AND SINGLE ROUTE" for that controller made sense, but it no longer makes sense? Implementing principles like SRP requires that you ascribe agency on the objects you write, and analyze the flow of code this way, as without agency there's no clear "responsibility" an object is handling. Instead the code becomes a soup of statements, that can be executed in arbitrary (to your source) order. The responsibility of routing is not at the thing you're *routing to*, but at the router. It's a fundamental difference, as you can have *more than one router* invoke a controller. This is not at all addressed via annotations. Instead the routing configuration is scattered around the route targets. As implemented, annotations for routes implement the same logic as AOP. And you can read about the drawbacks of AOP, it's often described as the complement of GOTO, called humorously "COMEFROM". The method is saying "COMEFROM route XYZ" and this is as obscure as it gets in the context of structured code. If you believe the constraints of structured code don't matter for creating maintainable code, that's probably a larger topic to discuss, but I hope you can at least see that the constraints are violated here. &gt; You don't know how it's called but it changes how the caller treats that URL. Ok, so we're on the same page that this method modifies its caller's behavior. That sits right with you? Is it customary to stumble upon code like this? How would you trace this code's execution path without having to constantly look "under the hood" into generated code? And what does it say about an abstraction so leaky you need to constantly poke holes through it in order to understand it? Again, what's the outcome when you need to have *multiple callers*? How would you specify this via an annotation? If you can't, then it by definition means you're writing "use once code". This is the opposite of reusable code, which is one of the major achievements of structured code. What would happened to your code, if arbitrary functions in PHP were annotated with instructions like "call me, array_flip() when SOME function has a specific array pattern as input." There would be no end to the possible levels of obfuscation here. &gt; The annotation shouldn't have an effect at all until some process is being configured to do something based on this annotation. This is once again restating the "code means nothing until something interprets it". It's not a get-out-of-jail card for ignoring the semantics of your code. Thanks to code analysis, reflection, code generation you can turn PHP into anything at all, violating all sane principles of software design. Just because you did it indirectly, it doesn't mean you didn't do it.
&gt; you just use selenium or phantomjs to do it for you. No need to get iffy scripts from this page What is best way to take website screenshot ?
On 2.c your reasoning is wrong. 
You see, some questions are not about writing yet another wordpress plugin. Sometimes it's just about understanding and curiosity... ...yet sometimes it can help you to find the issue with your wordpress plugin.
Ah, programming in a textarea, good fun.
Not programming in a text area, writing examples (such has here on reddit) or pasting code because you want to share it.
hey reddit pls can ai have gf pls
&gt; full web page as a PNG image that you can download &gt; data:image/**jpeg**;base64,/9j/xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
So he should have made it the same as with true and false then, not highligting as "not valid". Speaking of invalid keys, it would be rather array that you can call that. 
Thanks for the hint. I always thought that float values are invalid keys.
You can send 2 concurrently, yeah. However the http/1.1 spec doesn't allow both in 1 request iirc. Edit: why is this confusing for php folks btw? 
I'm trying to think of use cases for encoding other data types into strings for array keys... Care to help me out? I guess the 'weirdest' I've gone is create an actual hashmap by hashing some unique properties of an object and using that as a key. 
Ah! Confusion with the super globals. But if you've ever programmed an api or used silex or another routing engine you should probably know better, right? So when you said 'php developers' maybe you meant 'WordPress plugin makers'?
Your making this even more confusing. Whats wordpress got to do with it? The PHP code makes more sense than your comment.
Nowhere did I say 'PHP developers'. I said PHP folks whom I see every day trying to answer questions on SO or in /r/PHPHelp
unlikely. I understand why you created the post, it is nice to gloss over confusing aspects of PHP. But the two examples you gave, well, they are not very confusing. More like, why? why even do these things.
oops sorry, I thought you were the OP. But no, I havnt any problem with my understanding that I'm aware of.
It is interesting how Redditors take posts they read. From the comments above one could tell that they take it as a sort of /r/PHPHelp post, trying either to explain the obvious gotchas to the OP or just inquiring what is the practical use of the above code. While the question was actually "Could everyone please contribute the other examples?"
The reflection could be avoided in production by compiling a cached version of the class, i.e.: /** * @Overload **/ public function bar() { return $this-&gt;overload(func_get_args(), ['alpha', 'bravo', 'charlie']); } Becomes: public function bar() { if ($argumentsMatchAlpha) { return $this-&gt;alpha(...fuc_get_args()); } … } Just like doctrine proxy classes. It would be problematic to use this optimized class instead of the base one though.
Which is interesting because MVC isn't really a thing for just PHP. I would rather call it an http framework.
If they do skip 8, I am willing to bet there will still be PHP 8 books published.
You're not forced to use PSR code style at all. The intent is to stop teams from starting holywars and tools to be with pre-bundled code style. If your team is against 4 spaces and prefer tabs then take PSR, replace 4 spaces with tabs in it, put it into your repository and enforce it within the team.
&gt; Here is some examples that might confuse PHP developers. Your first example behaves the exact same way in most common language; it's an inherent property of how floating point numbers work. This makes your emphasis on PHP a bit odd. Your second example is better, but again it's hardly unique to PHP. The equivalent code in JS and Python both exhibit the same quirk (ie, it yields a hash with fewer keys than you started with), due to illegal keys being coerced into legal ones. Understanding how floating point numbers and your languages data structures work is important, but it's not *uniquely* important to PHP developers.
So the live edit works, but i still have to reload the page manually in chrome, every way i open the file
You've been downvoted heavily, but you're not wrong. The trait lives in and uses code from Illuminate\Support, which even utotwel says you shouldn't use for framework-agnostic code. https://www.reddit.com/r/PHP/comments/4fulme/dont_use_illuminate_support_for_your_framework/
Use an IDE like PHPStorm for a while and you'll see why explicit method signatures are useful for boosting your productivity.
MVC is a design pattern, it isn't a PHP or HTTP framework. 
Which doesn't really work well with php as your view and model are not communicating until you introduce Javascript. I'd say Angular is more of an MVC framework than ANY php framework for example.
This is weird, because the documentation for shell_exec does not specify a bool as return value. Try using the function [exec](http://php.net/manual/en/function.exec.php) and read the third value to see what return code you get. Is the script containing things which cannot be done in PHP? Why do you need to execute a powershell script? This is usually not a good idea.
I suppose that giving at least some hope to a terminally sick patient is humane, but these cheap, easy, 100% natural remedies will probably not stop hackers from taking over.
&gt; So, it seems safe to say that the future belongs to micro-frameworks, micro-services, containers and cloud computing. It’s time to think in our projects this way and enjoy all the technology that is emerging around us. For about 5 minutes, until the next fancy thing is out. I'd just like to use the chance to disabuse people of the notion that "microframeworks" are "micro" in any way similar to "microservices". In the case of microframeworks, all the popular examples (Lumen, Slim, Silex etc.) are simply thin facades over a "full stack framework". They're not any better than their underlying implementation, and in some cases worse, as their God class API fits well only the smallest and simplest of apps. The ideal use case for a microframework is writing a "Hello World" snippet to post on the project's home page. It's downhill from there. 
&gt; When the great names of PHP realized this, they got together and created PHP-FIG, the group that came up with the PSR standards, which allowed the appearance of Composer and other innovations. I’m thankful to PHP-FIG for allowing the appearance of Composer ;) &gt; The next major evolution that led us to this path was the approval of PSR7 (…) Instead of using the MVC pattern (…) we now have a pattern that was born for this dynamic and specific environment. TIL PSR7 replaces MVC. ;) &gt; we’ve seen large frameworks like Zend Framework, Symfony and Laravel becoming micro-frameworks Symfony 2 is full-stack, but Symfony 3 is micro… Because of reasons. &gt; So, it seems safe to say that the future belongs to micro-frameworks, micro-services, **containers and cloud computing** Wow, that escalated quickly. In recent news: more and more cars are powered by electrical energy. It’s safe to say that the future belongs to self driving cars, hoverboards and interstellar travel. &gt; What do you think? Are we seeing the end of the full stack frameworks? Clearly.
It seems like you might want to check out Symfony, with its "bundles" system for modules, and "event-driven system" which is just scattered delegates under disguise. I'm not a fan of such a system, but it seems that's what you're looking for.
Maybe they were confused by the symfony 3 micro kernel?
Agreed.
Probably, or maybe by the [Symfony 2.8 micro kernel](http://symfony.com/blog/new-in-symfony-2-8-symfony-as-a-microframework) ;)
STOP with the blog spam. Your posts add NOTHING that isn't known already and most of them are wrong or useless.
[removed]
&gt; Symfony 2 is full-stack, but Symfony 3 is micro… Because of reasons. Can you expand on that please?
You're only here for self promotion and profit. That sucks. 
Bundles in Symfony are not to be used as modules
&gt; You've been downvoted heavily, but you're not wrong. Why would anyone think being downvoted means being wrong?
"we’ve seen large frameworks like Zend Framework, Symfony and Laravel becoming micro-frameworks (ZF3, Symfony 3, Lumen)". They are talking about micro versions of those frameworks.
Essentially every modern full-stack framework provides this kind of event system.
I've literally been hearing this for the entire 6 years I've been building Laravel. 
They are/were used like that indeed, mainly because symfony1 did have a "modules" concept as such. However, a bundle in Symfony is nothing more than an extension point to manipulate the container: - It provides the ability to extend the configuration, which allows you to add custom configuration that can be processed - To process this configuration, you can create an Extension and use this to manipulate the container - Your Bundle can register compiler passes to manipulate the container (not everything can be done in your Extension) - Bundles can provide other resources such as translations, templates, controllers etc, but imo should be done as little as possible as they are the responsibility of your app and not of a vendor package. So actually a bundle is definitely not meant to be a module and in theory you don't even need one in your application. I've worked with multiple bundles in an application and eventually they end up intertwined with cross dependencies. Even if you try to restrict this, templates will refer to routes defined in another bundle and often extend a base template which is located outside of the bundle.
I think what /u/iltar means is that bundles are not standalone, the Symfony [components](http://symfony.com/components) are (mostly). Bundles are meant to be used with the full stack framework or at least the HttpKernel &amp; Dependency injection packages. You're correct that bundles can add things to the container and hook into various Symfony events, but that's part of the HttpKernel's bundle system not an independent stand-alone thing.
No that's not what I meant. You are right that Bundles are something for the whole framework (but can be used without). Components are indeed "stand-alone", but a component is merely a library that is being used by the framework. The "Framework" is actually nothing more than a bundle wrapping everything together. You can also use the DependencyInjection component and still use the Extensions. Bundles merely use the Extensions from the DI component
But because of those standalone components, Symfony can be used as a micro framework. See: https://gnugat.github.io/2015/12/23/symfony-micro-framework.html (Note that I'm not even mentioning MicroKernelTrait).
Well, this is why I don't do modules the Symfony way :P
The release notes and downloads are linked here: http://php.net/archive/2016.php#id2016-10-19-1
I've not need a "module" system in since I've started working with Symfony 2+. Modules are rather generic (A module can refer to anything) so I guess it kinda depends on what you mean with Modules.
Okay this gets worse and worse. Are we now advertising?
I mean essentially "modular programming", as covered here: https://en.wikipedia.org/wiki/Modular_programming Or in other words, a large self-contained unit of code, with a focused and small-surface API, exposed typically through a single "public class" (we don't have visibility of classes in PHP, but by convention). The separation is roughly the same as with microservices, except modules run in PHP, not in a separate process. It's a simple way of retaining your sanity in large projects, and encouraging high reusability of high-level components. 
Your best bet is probably Symfony's [DomCrawler](http://symfony.com/doc/current/components/dom_crawler.html) component. It's really easy to use and highly tested.
So pretty much just a layer of abstraction where you program using a specific interface where you could provide multiple implementations. This is exactly where a bundle comes in, not to provide the module, but to connect it to the container (PSR6 would be the best example). Package visibility would be really nice to have :( 
There are a lot of solid options out there, but allow me to toot my own horn. [Opulence](https://www.opulencephp.com/) is extremely modular - 20 of 22 of its libraries have 0 dependencies. It has a simple [event system](https://www.opulencephp.com/docs/1.0/events) that doesn't bleed into your domain logic. It comes bundled with a synchronous event handler. If you'd like to use some asynchronous event library, you can easily incorporate one and wrap it with an [event dispatcher](https://github.com/opulencephp/Opulence/blob/1.0/src/Opulence/Events/Dispatchers/IEventDispatcher.php). Opulence is new to the world, although I've been working on it for 2.5 years before I released it. The main drawbacks to using it are that it is new and doesn't have a big community (yet), and it only supports PHP 7 and higher (although some might argue that's a positive). These facts are deal-breakers for some, so I just wanted to make sure you were aware of them before you made your choice. Good luck!
[use components, not a framework](https://github.com/PatrickLouys/no-framework-tutorial/blob/master/README.md)
&gt; This is exactly where a bundle comes in, not to provide the module, but to connect it to the container The problem with this approach is that the application should control what goes in the container, not some bundle on its own volition. You said yourself it all becomes a spaghetti of dependencies, and that's one reason why. 
Only if you use multiple bundles in your application (read: manage the source). A library/component: your module A Bundle: configures the said library/component An application, depends on a bundle (via Composer) and loads said bundle in kernel. Now you have the ability to configure that bundle via the configuration. The bundle will then prepare the container with configured services for the module/library/component. Re-usable code often requires a re-usable bundle. With a de-coupled bundle with no real application dependencies, it won't become a plate full of spaghetti :D So bundles are not the modules, but the allow for re-usable configuration thereof.
It was my understanding that 1+1 = 1?
Well, I always think microframework as some ~~Router + IoC~~ HTTP + Router + IoC Container. It's usefull when you need simple stuff, without downloading tons of dependencies.
By IoC I suppose you mean dependency injection, and you don't need anything to do that, so... basically you just need a router. 
...or if you create documentation for your APIs with https://www.phpdoc.org/.
Ah, by IoC, i mean IoC Container. That's also why i believe Lumen is not a microframework...
Always Framework.
found the junior dev
&gt;A brief story… In the beginning there was chaos, then came Ruby on Rails… Wow
I get why this was an interesting exercise, but I'd love a debate as to how this is beneficial to software design or if this is more of an anti-pattern. I'm more in the latter camp in that, I feel that methods should serve their purpose and do it well. If you have one method with 2 or more implementation, I can imagine this making understanding code and debugging a lot more complicated than it needs to be and I'm seeing very few benefits. I would prefer if we also had a discussion about this rather than, "well another language can do this, so it must be a good idea."
I've not used `extract` since my first ever foray into PHP, and feel it's best avoided even when you trust the datasource 100%. Someone correct me if I'm wrong!
This gets my vote provided there is a deliberate convention for the mirroring of variable names/formats and DB column name formats, and that this is closed off in a scope that isn't letting any other symbols potentially extract data out of unwanted fields. Also, the extract call has to be inside of the condition, else it will complain about `$a` being null.
Imagine you pass some paths (an array) to an method that essentially contains PHP arrays that are merged together. How would you test such a task? (As the method includes the files)
I really enjoy N++ for quick edits. I just learned that I can get PHPStorm for free using my EDU email. I guess I will give it a shot. 
Its a circle. Right now we are at the separate front and back end work from each other and use an API layer to connect the two parts, but Im sure at some point we will be back to full stack frameworks. 
Everthing is always a circle... There was a moment in time back in the ancient days where having a mainframe and terminals that used the mainframe for computing was the way to go. Then came personal computers, where everyone would have their own system isolated from the rest unless needed, with private CPU, ram, etc. Then, again, came the terminals...with online editors, video player, streaming, etc. we're now in a mixture of the two, but everything has been pushing for terminal based computing again. We never learn, haha.
23/35 submissions: codequs.com 12/35 submissions: codek.tv Gotta make that affiliate money
I usually go with #2, I'd do #3 if I would be returning the value (return $a['firstname'] ?? ''). I'd never do it on this scale though. I'd likely be making a User model, generate getters and setters, create a new User object before the "if" and set the values of the query result using the setters.
Because of the hate of java! 
Well you can easily change the name of variables 
Have you tried using a regular expression?
any objections to using the build-in php functions, password_hash() and password_verify(), for passwords?
Too much self-promotion in this sub.
Indeed, I use it already. Was asking simply because I've been using the native functions for a while but have been curious as to if there are better solutions. Thanks for the confirmation :)
Great stuff. I'm not a cryptography expert, but that's rather the point - we should be using the security-assessed built-in methods and only deviating from that approach if we _really_ know what we're doing. 
No explanation of what `realpath_cache_size` and `realpath_cache_ttl` do? No actual benchmarks and before/after comparisons?
[removed]
https://github.com/samdark/realpath_cache_tuner
Because I can. That's often reason enough for me to try interesting things.
I will be messaging you on [**2018-10-19 21:58:59 UTC**](http://www.wolframalpha.com/input/?i=2018-10-19 21:58:59 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/589nz4/the_end_of_the_full_stack_frameworks_age/d8ze3qr) [**2 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/589nz4/the_end_of_the_full_stack_frameworks_age/d8ze3qr]%0A%0ARemindMe! 2 years) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d8ze4ip) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
This is a top comment.
The paragraph about logger isn't incorrect, but doctrine doesn't do it by itself, it's caused by monolog-bundle. Here's the issue for that https://github.com/symfony/monolog-bundle/issues/165
with luck it will compile with a strict compiler. Thus far .. nope. 
If Doctrine is hosing a lot of memory when batch processing data, then maybe it's a sign that it's a bad choice for the job. And it's ALWAYS the logger. I've seen the same thing in Codeigniter and Yii2 at this point so I am completely not surprised that Monolog does this. I swear it's like the big frameworks were designed for nothing but basic CRUD, and the very notion of them being used for heavy data processing where logging all the things is a bad idea never occurred to anyone. Took me days to figure out why CI was choking before I found the answer (switch off the fucking query logger) and thankfully only a few hours before I figured it out for Yii2. Still a major pet peeve.
The only reason 8 would get skipped is *because* of books being published. But I doubt that the core PHP team is stupid enough to repeat the PHP6 mistake again.
Easy answer: Use https://github.com/jeremeamia/super_closure Harder answer: Implement your own version of what that library does, which is basically parsing PHP files to try and find the text of the closure, then using `eval()` to turn it back into code to de-serialize it. Crazy stuff.
&gt; I am completely not surprised that Monolog does this Monolog, as with the rest of the Symfony ecosystem, only does bad stuff if you tell it to do bad stuff. The "fingers crossed" handler, which is [the default in symfony standard](https://github.com/symfony/symfony-standard/blob/6832c7baae2d757b12bbd5342aea2993c21ee9eb/app/config/config_prod.yml#L13-L15), is particularly brutal on long running processes. Can't really blame Symfony or anything else, though. Probably 90% or more of their use is for CRUD apps.
Sharks better look out, the orca is coming 
FireFox began bogging down a long time ago. So long ago I can't remember when. I occasionally use it when doing browser testing and its quite speedy now. However, Chrome isn't broke so nothing to fix. Firefox was broke. So no joke, it was slow and it was a well known issue by their developers at that time. Not a Firefox hater, just stating history.
The default configuration works fine for web apps, I don't do crud and I don't have this problem with the web part. When building batch jobs you will always have to tweak a little bit though. Note that my company has over a dozen big batch jobs and its working fine so far.
Mock them or use test fixtures
Mycollegeintern,an educational arm of Arition Infotech
The author is throwing in terms liberally in this description while understanding them in only a superficial way. Not a good sign. 
Found the guy thinking everyone else's code is crap :) But really, why would you waste time creating something yourself if there's a ton of decent frameworks out there, that probably solved a lot more edge and corner cases than you have? Take Symfony for example, 1200+ contributors, 1200 people surely know a lot more than 1 person ;) 
Nah here is plenty of good code out there, including a lot of components put out by groups luke Symfony. I know more about the problem that I need to solve than 1200 people who were trying to solve their own problems. You know the thing about too many cooks... Frameworks are the meal that results when a lot of people try to solve completely different problems with the same approach. You take on a LOT of unnecessary baggage with Symfony that you'll never need. And often you need to work around things if it doesn't do things by default how you like them (I use Symfony at my current workplace, used a component based approach at my last one). From my experience (which is shared by a lot of people outside reddit, check out the stackoverflow chat for example), a component based approach is far superior to a using a cookie cutter framework. I don't know why reddit is so stuck on frameworks, I guess it's because everyone has one upvote and junior devs (who are in the majority) often gravitate towards frameworks (I did too a couple years ago).
If nobody that is capable of doing this is willing to donate their time, I completely understand. If they are able to accomplish something like this, obviously their time is worth money so I wouldn't blame them at all. Anyone willing to do this would be doing it out of the kindness of their hearts and for a good charity. As for me coming up with more demands and changing my mind etc. That wouldn't be the case. I would have a list of what I would like (and would be very open to suggestions) and from there on, the person handling it is the professional and that is that. I am pretty sure we don't know each other because if we did, you would know the assumptions you made are the furthest from being the truth. If this were something I could handle myself, I would but I am honest enough to say that I am not at the level most of the people here are at. 
thats an issue with the DebugHandler then, would be good to link to that issue. right now its written as if its normal behaviour and its caused by doctrine ;) might as well still be a problem if you have another service that does a extreme amount of logging
[removed]
The idea actually did spawn from a Facebook group dedicated to the music scene of 1 city in Virginia from the 80-90's. I presented the idea though told them it was something I didn't have the skills to do on my own but there was/is a lot of interest. I was hoping I would find someone with the skills in that group but unfortunately I didn't. That was a great idea though and really how I got the idea to start the site. I saw the group dedicated to all of the great music and people posting every day "do you remember this band? I wish I still had that CD" and then every few weeks it seems there would be a post "the guitar player of _______ from back in the 90's overdosed over the weekend" and then of course when the singer of Gwar overdosed, it was a big deal. You can act however you want. If you weren't interested, I would think the best thing to do would be not reply. I am not expecting anything from anyone, I just posted hoping someone would be interested in doing a website that will have a positive impact on others lives. This is something I am very passionate about and if I could, I would actually pay out of my own pocket to have someone work on it but the fact is, I was laid off from my job a month ago and simply can not afford to do so. I have spent countless hours gathering very hard to find music and contacting very hard to find people to get permission to use their music for this site and cause. I appreciate the post. There will always be someone with a negative outlook and that is fine. Like I said, I came here with no expectations. Addiction has had a major impact on my life and I have lost close friends. I am sure a lot of you have as well. I got this idea as I saw there was a demand for the music and I thought it would be a good way to raise money for the charity. I simply and honestly do not have the skillset to accomplish this. If you are not interested, I totally understand. I also understand that if this is something you have the skills to do, your time is valuable which is why I was very clear that it is a volunteer position. If you are not interested, you don't need to reply. I didn't come here to argue. I just came to see if there was anyone with the time and skills who would be interested. If there is not, I understand. 
Is the camera man drunk?
I would recommend this Part from the Symfony documentation: http://symfony.com/doc/current/create_framework/index.html It's awesome for everyone who wants to create and understand the big frameworks!
&gt; You take on a LOT of unnecessary baggage with Symfony that you'll never need Sure, you'll have it in your vendor dir... But that's about it. Once the container is compiled you might have a few extra services (which might be fixed with 4.0: https://github.com/symfony/symfony/issues/20048), but there's no code executed that you don't need. Sure you can write your own glue to connect the components, but then you're reinventing the wheel and spending time optimizing things that might not need optimizing. I've tried using a component based approach but it always ends up in "yeah but if I just throw in symfony it's already done for me and those 5ms overhead are worth the development overhead and stability". And I'm not talking about RAD, I dislike RAD a lot. Stability and maintenance are something I really care about as I work with applications that are 10+ years old (and keep being improved upon). When you start working with bigger teams (currently having 25+ devs), you don't want them to work with a "custom" framework. You want them to read the docs and get into it quickly, as getting domain knowledge is already taking up more than enough time. It's also partially about consistency between applications. When you have 20+ applications (in-house in this case), you don't want every application to have a different structure or framework.
Reading the docs won't work with symfony, since everyone is doing different things and the docs are often wrong anyways (according to symfony's own consultants). They recommend using a service locator... really? There is no custom framework, it's just a bunch of components with their own documentation anyways. Or do you limit yourself to the symfony framework components? Why limit yourself to their often suboptimal components? Compare their DIC with something like [auryn](https://github.com/rdlowrey/auryn) for example... Symfony's always gives me headaches while auryn just works as I expect it to. And I don't even want to start with the mess that is yaml, xml or comment based programming...
&gt; They recommend using a service locator... really? The docs are meant to get people started with Symfony, not to explain proper design patterns. People will learn that in time and that's what I always tell them on IRC. &gt; Or do you limit yourself to the symfony framework components Nope, but configuring a component takes an extra step which is already done by the frameworkbundle in case of Symfony. &gt; Compare their DIC with something like auryn for example... Symfony's always gives me headaches while auryn just works as I expect it to. I've never had issues with the DIC of Symfony, I think it's pretty damn good actually. What gives you a headache? &gt; And I don't even want to start with the mess that is yaml, xml or comment based programming You prefer to define everything in arrays? Be my guest, nobody forces yaml, xml or annotations (thought they are simply far superior to plain arrays in terms of configuration). Oh it's not "programming", it's configuring, they are not the same. Been using Symfony (starting with 1) for over 8 years now. There's simply no solution that I found that matches the superiority of Symfony. Sure it's not perfect, but that's what the community is for. 
1. You can not guarantee that your database migrations worked properly and are being rolled back on failure since most databases do not support transactional DQLs. You either can't automate it or make migration scripts that do not harm the application when not all have been successfully executed. 2. in PHP? 3. I don't think so. Most of the time a simple tag checkout of git works, running some scripts and done. I currently don't see how a framework exactly for this purpose is giving any value. What you need: checkout, file migrations if necessary, database migrations using a database migration tool (some ORMs do support it out of the box), run some other scripts your app needs, and then switch to new version using symlink. However, especially the file migration is often a problem in a full automated updated since the client could have gigabytes of files in it and you need to make sure that you do not blindly copy stuff (that could end up in a very long auto-updater) Long story short: depends highly on your actual application. 
Here is a comprehensive list of different options in this SO answer : [http://stackoverflow.com/a/3577662/165969](http://stackoverflow.com/a/3577662/165969)
I understand, thank you for your answer. :) I extended the text a bit with some bullet points about the environment/application. 1. I put "transactional" in quotes meaning it for the whole process, not only the DB migration part 2. Creating and checking them, yes. Aka "is my downloaded data valid?" for example. 3. Yeah, being able to use git would be convinient but I think we don't want to roll out with git credentials to some kind of update repository. Not sure about this one but maybe worth thinking about it.
The Full Stack Developer Swindle. A fabulous fraud. Only 40 hours to learn that enormously wast amount of technologies - HTML, HTML5, CSS3, Bootstrap, JS, JQuery, Node.js, Meteor.js Angular, PHP, ROR, MySQL, PostgresSQL, CouchDB, Cassandra, Memcached, Redis, Lucene, Solr, Git, SVN, Grunt, Gulp, Xdebug, Firedebug - even if most of these technologies will be just *mentioned* somewhere, it's still not enough even for just PHP alone. After watching this you'll no doubt will become a Full Stack Cargo Cult Programmer who can copy and paste some part of code here and there, but have absolutely no idea what does it do.
Thank you for the answer. Ok, this would be the happy path where we control the server. :) I extended the question a bit with what I mean with "Update": The application is rolled out to many servers not under our control and the customers have an adminpanel telling them that a new version is available and a big button "Update Now".
How separated are plugins/ modifications from the application core? It becomes much easier if you can guarantee that the core files have not been tampered with.
The video and sound quality is so extremely poor... Hard to follow. Can't say anything about the content, because of the bad quality I just turned it off again.
&gt; My hosting is decent. Lol it's not at PHP 4.4. Lol
&gt; The idea actually did spawn from a Facebook group Sources cited: 0.
Your explaination makes sense, but please be prudent when you tell things like that, it might be wrong, especially after a few years or even month in It stuff. It might spread wrong ideas in weak minds. Being a critic is good, being virulent is not :)
ARKA Softwares is a top ZEND Development Company in USA providing Reasonable and cost effective PHP ZEND Development Services. Contact us at +1-682-235-3275 for hassle free solutions. https://www.arkasoftwares.com/zend-development.html
Somebody using Yii?
I do.
True, yeah.
Any file of the application should be updatable.
From a business perspective, it'd make no sense at all to switch an existing team to Rails, regardless of the upsides it's a massive change to make, and would likely cost more than you'd gain.
Stuck on Yii 1.1 at my old work. It was horrendous. Wouldn't be against giving this a try if there was a chance you could get any support though
Missing from that list: all the CMSs that were used as makeshift frameworks back in the PHP-Nuke days.
&gt; Can you please not do this...ever! Ok Ok Ok Ok No Ok 
what kind of support do you mean? Yii has a great community and also commercial support is available by some people.
Thank you for making my day a bit better :)
I love working on these. cd /to/project/directory git init git add -A git commit -m 'Legacy initial commit' git tag legacy git remote add origin git@host:user/repo.git git push origin master git push origin legacy rm include.php3 # ... clean clean clean git add -A git commit -m 'Cleaned out all the distractions' After this... either build a manual test plan or (preferably) write some BASIC end to end tests to test critical features. After that... go review the project for all commented out code, usages of `if(0) { /* ... */ }`, code rot, etc. Delete them all if they don't add anything. If tests pass, commit and push. After that... profile your end to end tests using literally anything. We're not concerned with performance, we're looking for code that isn't called. Identify it all. If it is unreachable (code rot / legacy) remove it and commit. If it is reachable, decide if you need to write an acceptance test for it to poke it with a stick and keep on moving. ... It's not a long day. It's just part of the job. They did that because they didn't know about version control. You don't have that disadvantage. You'd be amazed how much "better" these projects seem after even the SIMPLEST of baseline checks. For added pleasure, run php-cs-fixer over the codebase after you kill all the rot and... good times. (Don't do this on mixed HTML/PHP *.php files, it causes dumb) //edit POINT OF NOTE I *have* had a project or two like this where the `index2.php` or what-have-you was *actually* what was used in production instead of `index.php`. Don't let that bite you. Writing a simple script to spider your code and build a DOT file to throw in graphvis to find unreferenced files is trivial to write. 
Use [`memory_get_usage()`](http://php.net/manual/en/function.memory-get-usage.php) to find out.
There will be no initializing of gits or refactoring. Its our old knowledge base tool. It was written in 2006 and last modified in 2008. I know it goes against every recommendation I've seen here, but we are rebuilding from scratch so we can design it to integrate with our other systems. I've already presented my boss with a 2 year, multi-phase plan for how I am going to build the new one, should be a decent well maintained tool when it's done.
Generally you don't want the web server to be able to write to files that are part of the application and you'd use something out of band to do the update - a script outside of the web server's control, perhaps.
This doesn't answer your primary question, but I'll leave this here. If you end up forcing indexes then it's generally a symptom that the stats sample pages haven't been properly configured on your MySQL installation. The query planner uses previously collected samples from each table to determine which index is better for a given query. Once the tables grow bigger, it's recommended to collect more samples. [docs for 5.7](https://dev.mysql.com/doc/refman/5.7/en/innodb-persistent-stats.html) or [docs for 5.6](https://dev.mysql.com/doc/refman/5.6/en/innodb-persistent-stats.html) You can test if your index stats are bad by running the following command and check if the `Cardinality` next to an index is way off than what it should be. SHOW INDEXES FROM `my_table` The actual cardinality can be determined by simply counting the distinct values (or combinations for composite indexes) from the indexed columns: SELECT COUNT(DISTINCT `indexed_column1`, `indexed_column2`) FROM `my_table` For example, this the config on my server (MySQL 5.7) and I haven't seen a wrong index used in a long time: innodb_stats_persistent = ON innodb_stats_persistent_sample_pages = 1024 innodb_stats_sample_pages = 1024 innodb_stats_transient_sample_pages = 1024 
I've seen it repeated numerous times when people talk about legacy apps, but I think that applies more to situations where the app is under active development. This one is running PHP 4 and hasnt been touched in 8 years.
At least you can be reasonably sure that the files ending in `~` are irrelevant.
Yes. Many.
Don't know if I should up vote or throw up. Maybe both.
Like I said, old legacy code.
Nothing is absolute of course. I guess a codebase unmodified since 2008 can't be saved without making all your developers quit. http://www.joelonsoftware.com/articles/fog0000000069.html At my work today they scrapped an ongoing rewrite of a b2b app that has been going on for a yeah and a half. But no worries the same people will get the *new* new version just right.
&gt; Where do you check what checksums? [Don't rely on checksums](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded), verify a digital signature instead. If you can't make libsodium a dependency, using [EasyRSA](https://github.com/paragonie/EasyRSA) is probably your best bet.
&gt;There are many who still know how to do stuff with 1.1 so if you need it bad, you'll find people to help you. This is completely false. You'll be lucky if anyone will respond to any queries unless you're up for paying for it. Worked in it for a year and was my first taste of MVC being a solo developer. Was a fairly painful experience. Not quite as painful as hearing the only reason it was chosen was "The office downstairs can help me and it has add-ons". urgh.
 &lt;?php var_dump(1.0 - 0.9 - 0.1);
&gt; The chances of getting support for old Yii was minimal. And by minimal...non-existent This is simply not true.
Why does any of that mean you can't check it into git? Init and commit, it's done in five seconds and starts to give you at least a little sanity.
Thanks! Looks like indeed I took the wrong turn. First, there was a legacy index hint which I was to replace and second, mysql was reluctant to pick up the newly created index. But when I tested it now, several days after, the indexes fitted exactly. So I just removed the hint. 
My life has become this, as it seems everything I inherit is like this. My favorite is the poor man's revision control. You know files like index_10-02-2007.php or index_1-3-2009.php or index_2010-05-7.php. You know because I like to sort dates used in filenames in multiple formats in my head.
``` $img = imagegrabscreen(); imagepng($img, 'screenshot.png'); ```
Git isnt installed on the server that its running on. The server is running centos 4.8. I suppose I could put it into our git repo.
Your question would be better served on r/phphelp or better yet on a web development help subreddit.
You might want to check out The Update Framework: https://theupdateframework.github.io/ Though you probably can't use it from PHP (yet), you can read their docs and see their practices for software updates. They protect against a wide range of threats to software update systems.
It's so bad, don't worry. I've always claimed that maybe 2.0 is better and yii isn't total garbage but thankfully I got myself out of there before I could find out.
It doesn't matter if you filter it correctly using a whitelist. The issue here is that it is filtered on input rather than on output. This + MySQL automatically truncating values when not in strict mode is the problem and creates the vulnerability.
Lol the worst is when you setup svn or git and they do index_yymmdd.php I kept telling them to stop and gave up
We had been looking for some time, but couldn't find one that would integrate the way we wanted. 
You're right about the fact that there isn't much activity at the forums about outdated 1.1 since 2.0 was released in 2014 and 1.1 active support EOL is 2015: http://www.yiiframework.com/news/90/update-on-yii-1-1-support-and-end-of-life/. Still I'm pretty sure it is possible to get help from community about 1.1 even nowadays. Have you tried IRC btw.?
Well, that's non-profit OpenSource + legacy version community lost interest for because there's newer better one. It is basically the same as with any other product, commercial or OpenSource... Try get Cobol support or PHP4 support and you'll get into alike situation.
Why? Sticking to a single framework doesn't do you any good in the long perspective...
Funny this shows up about a week after I had to accomplish the same thing using Vue and then I find out Vue2 came out and my two-way bindings need to be fixed before I can upgrade (sorry unrelated side-note).
Somebody has to maintain legacy code. Everyone can't just quit when they're assigned to it. Lol, that's mad.
I didn't know he got kicked out! I always heard that he'd out. 
All scenarios are technically valid. You're really only trading off readability (which is subjective) and micro-optimizations (the first scenario will be fastest, IIRC). Perhaps another question to ask: What are you doing with these variables? Is there a better way to separate the record-exists and record-doesn't-exist functionality where you might not need these conditionals or defaults?
 # cd /to/project/directory # git init -bash: git: command not found # apt-get install git Reading package lists... Done Building dependency tree Reading state information... Done E: Unable to locate package git
Are you developing on the server? I was assuming you had a local copy of the code. In which case, you don't need to PUSH to a REMOTE with git, you can take advantage of cheap local branching.
Two-way bindings were removed and aren't coming back D:
&gt; do you not fancy the ability to just check this with a quick if ($objectOrNull) {object}; else {null}; Actually, no, I find it unclear and dangerous, and if someone is doing this in our code, I usually change it. `is_null($object)` states its intent *much* more clearly, and is safer. Every time I see `if ($var)` my mind races through all the possible bug scenarios. It makes this kind of code impossible to test: you basically have to be careful that no falsey value is ever passed there, i.e. 0, 0.0, `""`, `"0"`, `array()` or `[]`, or… interestingly, `SimpleXML` objects created from empty tags. You know, I had to look up this list again, because I always forget, between JavaScript and PHP, which exact objects the hare-brained devs decided to be 'equivalent' to false. BTW, this isn't overloading, this is autocasting, and it really is everything that's wrong with PHP. Especially since all of these false equalities don't translate at all to comparison operators.
Wishful thinking this has any kind of source control ;-)
There is a Wordpress updater called [InfiniteWP](https://infinitewp.com/) - it's free and may be worth checking out for ideas.
i do
Yeah, sometimes I also noticed a delay in picking up the right index, but it's happening faster, after 5-10 query runs with different values. I have yet to figure out what mysql is doing internally.
this is called transliteration. For example in the Drupal CMS simple strings can have placeholders filled in with variables and the pieces of the string which are not variables can be translated into various languages which the API supports: Some more general background on the drupal t() function can be found here: https://www.drupal.org/node/1844980
&gt; The hosting will handle the site This statement right here, is the biggest red flag of all. This is the sort of thing that keeps me away from jobs like this. 
Transliteration is going from one set of character to another one I believe. For example 你好 =&gt; NiHao. Though it's not clear to me what the answer to OP's question actually is. Internationalization (I18N) comes to mind if she's looking at the translation part of it. 
I suppose I should have either taken time from my day to explain that the folder is inexplicably 9gb, or that I didn't modify a single line of code to fix the issue, I was digging around in a backup for database details so I could find out what was wrong with the record in question. I didn't build this particular system and wouldn't have done half of what the original author did. I also never mess with code on a production server. I guess I'll explain myself more clearly next time. At very least, I'll leave my original comment and take my licks, even though I don't think it was wrong 
You are so terrifyingly wrong, that I almost don't know where to being. While PHP is language built for the web, and has some features/quirks that make it more easily suited to web development that other languages, it's still at it's core a general purpose language. Dependancy injection, user management, access control, url routing, templates - these are all requirements of any decent sized site, and PHP doesn't provide these out of the box - and that's what frameworks provide.
It's more like, why do people buy cars instead of building their own? Most people just want to transport something from A to B (often themselves) and they don't care how the car works internally (maybe a little).
What are you talking about? Two-way Props and two-way Filters were deprecated, but [two-way model binding](http://vuejs.org/api/#v-model) is absolutely not removed.
This pretty much sums up my feeling as well, hence I've decided to keep my hands off frontend stuff as much as possible. 
Above function have so many limitation. 1. It grab current open screen. 2. It will only work in window. 3. if we to grab it trough url, it's not possible. More info read : http://www.whatacode.com/take-screenshot-current-screen-save-image/
I use the right tool for the right job. To me Yii falls in the category of legacy frameworks: Symfony1, Zend Framework 1+2, CakePHP, CodeIgniter etc. Therefore I will never use it. Edit: forgot to add that Yii doesn't follow semver which is a mandatory requirement for packages I use.
&gt; You have nothing left to learn, and you are the best developer in the world. I reached that level couple of weeks ago. Unfortunately, turns out I still need to poop and so on. Overrated.
I did ;)
Most IDEs will write the use statement for you, so from a purely pragmatic PoV: - Name the class the way you want to type it across your projects, or else you'll be manually writing aliases all the time. This means don't use names that make no sense out of context, once the namespace is stripped away. - Repetition in namespaces doesn't matter as you'll never have to manually type the namespace, if you use an IDE. That said, having namespaces like "Exceptions" is uncalled for. People do this, because PSR-0/4 fuse the idea of directory tree with namespace, so when you want to group files in a directory, you by necessity also isolate them in their own namespace. But what makes sense for directories, doesn't make sense for namespace. A namespace is... well... literally a space for names, where you put *cohesive units of code together*, i.e. code that's related and will likely be used together. An Exception does literally nothing by itself, so it makes more sense that it's nearby the code that'll be throwing it (unless it's a generic set of exceptions used across modules). So those are two opposing views of how to organize code in your namespaces. By category/trait a.k.a. "horizontally" or by module/cohesion a.k.a. "vertically". I always go vertically, so for ex. I split everything in small modules with a specific responsibility, and then I put the views and controllers (if it's a MVC module) in the same namespace, the namespace of that module. One notable thing, however is that I use an autoloader that's a superset of PSR-4, which allows me to group files in directories, without "generating" a namespace. So I can keep both concerns separate. In the end... do as you prefer. Just keep in mind most of your users will be using an IDE to use your library.
I tend to go for the last of your extample, but without the "as ..." part; use \MyBundle\Offer\Product\Patch; use \MyBundle\Offer\Product\PatchCollection; There are not too many times there are collisions anyway, it's "probably" unlikely you're utilizing a product from one developer at the same time as you're using another. At most one product extends another, but that does not affect the end-user / developer. Yet of course, there are instances where you use two classes of the same name, in which case I don't alias them, I tend to leave the 2nd one fully qualified in the source code. Basically, in my opinion, you don't want to repeat yourself when it comes to regular classes.
Here's one of the best OOP tips I ever heard. It made OOP click for me overnight. Classes and their properties should be nouns (names). Their methods should be verbs (doing words). For example, if I were developing a way to interact with the database I would do so like this: class DatabaseConnection { private $databaseName = ""; public function query($sql) { // do query } } In that example a database connection is a noun, query is a verb and database name is a noun. Hopefully this rule of thumb will give you a rough way to flesh out your classes. I frequently refer to a dictionary when I'm writing classes. That old adage of "There are only two hard things in Computer Science: cache invalidation and naming things." is so true. That rule of thumb helped me almost solve the second one. ;)
It seems you're talking about legacy 1.1. Indeed, there's no reason to start a project on it. Current Yii is 2.0: PHP 5.4+, more isolated request-response, DI container, REST, etc. Also Yii follows SemVer. Full version numbering is 2.x.x.x. There are almost no patch releases. Mostly minor ones. btw., CakePHP3 isn't as legacy one may think.
You’re describing an array. :) I think you’re looking for the [Translation component](http://symfony.com/doc/current/components/translation.html) or the [gettext extension](http://php.net/manual/en/book.gettext.php)
I'd suggest you try and post your question in /r/phphelp 
&gt; Dependancy injection Dependency injection container you mean. PHP itself provides a way of dependency injections so that DIC can work. ;) &gt; url routing Well, it does. Think `products.php`. :) But it does so without the usage of a common front controller, so there’s that. And you can use `auto_prepend_file` and `auto_append_file`, so your PHP files in the document root act as the controller actions. So yeah, I’d say PHP has a somewhat usable url routing. &gt; templates PHP file is in itself a template. Not very good one, but nonetheless. You are right of course, a framework would make all those things easier / better / more powerful
I know the feeling man, I went away for a year or so and was using Laravel 4.2 and jQuery before. Now I've come back and started a couple projects using Laravel 5.3 and now there's all this bundled in stuff that I had zero idea how to use, it really is a mine field, it's great once you've got it all setup, but at the beginning I was spending half the time just knocking my head against a brick wall whenever I needed to add something.
Simply not true, back end development is certainly the hardest part of an application to develop and most importantly do it correctly. I'm currently building a micro-service architecture (for a major online retailer in the UK) that communicates across 12 different front ends and they access 17 different closed source propriety systems. This is incredibly difficult to manage and get your business objects correct. Creating an Angular frontend has nothing on this, ironically there are a few Angular frontends being developed to interact with the micro-services I'm putting together 
OK. With that definition of "legacy" you're correct. Yii isn't strictly following defensive type of OOP so it's definitely not the style of the framework you personally will enjoy. Thanks for elaborating.
What's the joke behind B. Tables?
When I was in college, I remember using tables to layout a website. I suppose tables can still be used for layouts...
You should work on some bigger projects then
Its a reference to a comic strip about SQL injection: https://xkcd.com/327/
Flex box. It's tables for layout, basically. Check it out. Very easy to use. Here's a shocker, though. You can actually use actual tables and yes, it'll work fine, including on screen readers. I remember how overblown people's reaction against tables was. And for what? Mostly nothing, as usual. I also remember that HTML was totally out of fashion and everything had to be XHTML. Funny how that turned out.
Yeah but HTML layouts done with tables really suck on e.g. phones, which on some websites creates half or more of the traffic. Of course it's not abut the tables itself but how they are used &gt;90% of the time.
There's also EAP (early access program) https://blog.jetbrains.com/phpstorm/category/eap/
Unfortunately what I was referring to were two-way props.
there's an overwhelming set of tools out there -- frameworks, pre/post processors, module management, etc -- but teams usually pick a set, and stick with them. in our case, for front-end work, node is a necessity, and we use it for the following: 1. grunt for... 2. scss-to-css pre-processing (requires a node module) 3. js obfuscation and minification (requires a node module) 4. image minification (requires a node module) For the templates, we use dust.js, peppered with react.js. You don't need to know everything that's out there, a small subset of it is enough to get you through everything you need. You can even choose to just use regular PHP templates + jquery, and just have grunt minify your css/js/images.
This looked amazing when I first saw it a year ago and they promised phpspec support after version 1.0. But in that time it's gone from 1.0 alpha1 to alpha2. Shame I'd love to use it but I'm a phpspec guy. **Edit** this isn't meant as any criticism of the project or the people working on it. Just wish I could use it.
It is complicated, the upside is that for the most part, Vue or whatever works for most problems, since you just want two-way binding usually. I think the problem isn't in the framework, it is that there are so many tools making up for javascript and browser deficiencies. I see the need for a transpiler, but having to need it just makes it seem complicated if you are PHP dev.
Yes I'm glad it grew, but the way JS is growing is just ridiculous. A new framework/tool/library every 3 months instead of perfecting what already exists. For example, I started with React, but then learned I have to use Redux, and then learned that I need babel and as if it wasn't enough I need webpack. SERIOUSLY? 
For most projects, front-end is vastly more complicated. Your use case, while 100% valid and true, is much less common. Most php apps are run on 1 device and only serve &lt; 100k people a day. They are not incredibly difficult to optimise for (heck most you wouldn't even need to, just add varnish unless you have a lot of dynamic content based on sessions). Combined with simple to use MVC frameworks Symfony/laravel/silex which do most of the complicated work for you, most php devs are building out models and simple controllers to handle basic CRUD. The folks working on a single app, or a bunch of small apps in a domain that really require that type of optimization is a much smaller audience. Granted this is all anecdotal, if you have evidence to suggest otherwise I'm 100% open to it but from what I've seen in my career and peers most of them are building small simple MVC with a few tweaks here and there.
I think the issue with that is though, as a beginner I don't know what I need, I want to be able to download a full framework and have it built in. That's more tricky in this space. If you have a team telling you what tech to use, it's easy, just npm install, but if you are trying to decide, that's where I think the biggest complaint is. Yes I know I can use just the symfony routing component, however most beginners would probably want to start off with the full cms framework since all the tutorials, and tools make this the easiest way to start.
Sure, but then you need to add a compiler to your tool-bag - something like babel. Though, I honestly feel you should you use a compiler most, if not all, of the time. Also JS is probably my biggest weakness so I may not know what I'm talking about. :) EDIT: Typo
I too was in this boat of building stand alone applications about 5 years ago but I have seen a significant shift towards a de-centralized architecture now with 3rd party API consumption almost vital. Yes frameworks make things 'easy' for backend development but to say its easy to model out a companies business objects correctly and in a scalable way, you're not kidding anyone. Yes building bob's hair salon a website and blog anyone can scaffold something together in a matter of hours but I have found (in my location) all the work has moved away from this style of website into more data driven/data consumption business environments. I'm not for one second saying frontend dev is easy, its tool chain makes it fucking painful to work with but righting a single page app in Angular and consuming a backend API is much easier in my eyes than trying to create a consistent, secure, well documented API. Personal preference of course 
I wouldn't say the PHP tool chain is anyway near as bad as JS. You have composer for package management, phpunit for testing and 2 major run times (which the dev doesn't really worry about its more for the sysadmin), I would hardly call this a difficult tool chain to understand. JS you have to at a minimum * transpile, the list of options is silly so I wont list them all, lets just take Babel * a module bundler, again the list is stupid lets just say webpack here * build system, there are 5 big ones that come to mind lets go with Gulp (my fav) * package management, NPM is the obvious choice * test framework, the list is ridiculous, lets go with mocha * make sure your code is following best practice? okay lets get ESLint as well * need help putting some of this together? Okay lets install Yeoman as well I'm sorry but anyone who thinks this tool chain is okay are out of their fucking minds, no back end has a tool chain like this. I love JS frameworks like Vue and Angular but the tool chain around them is a joke.
How does this differ from https://github.com/liuggio/fastest? Can you run tests in parallel per test function (where a testcase may contain X tests, and you would run X parallel instances while fastest will only run 1 at the moment)?
I think the biggest difference is this tool was built around the concept of the chunks running in parallel across different servers/jobs and not multiple processes within a single parent thread. This tool could be enhanced though to run the chunks in multiple parallel threads in the parent PHP thread. In my scenario though that would not work as well because each chunk is quite CPU &amp; memory intensive so I prefer to have them running in entirely different jobs/processes which means they could also be spread out across multiple servers.
Holy moly. I remember when flexbox was being supported by just 1 or 2 most bleeding-edge browsers. It got me super excited but highly reluctant to pick up thanks to its market share back then, combined with the fact that there's no graceful degradation on a fundamental level. Times have really changed in 3 years.
From a slightly different perspective, the server paradigm is more or less a highly mature one, and we've basically discovered all the major design patterns that fulfill 98% of use cases. On the other hand, browsers are both much worse than native apps in terms of performance &amp; features, but also rapidly improving in those fronts. As a result, the front end continually grows in maximum complexity which requires new tools to rein those into the dev's workflow.
Front end has only JavaScript. Well maybe you can count some of the other that compile to JavaScript as a different language like elm. Backend has dozens of languages. Sure you tend to only learn one (it's a php subreddit), but when comparing front-end programming to back-end programming they are the same complexity. It's just that front-end has all of it under the roof of JavaScript and backend has different languages. 
I haven't watched any of these so I can't give you a definite answer, but my company has a pluralsight subscription and I did [a quick search for php](http://i.imgur.com/8yUiHuz.png). I would simply look at a combination of the title, skill level, and rating to decide where to go (based on your needs). The release date is usually good to check too, so you aren't learning old information, but that's going to be less important if you're going for the basics. If you're brand new, I'd start with "PHP Fundamentals" or "PHP: Get Started." Maybe watch the first 10 minutes or so of each and see which one you like better. Once you're comfortable with those, moving up to more advanced topics like object-oriented PHP would be the natural progression. 
Back-end guy turned front-end here. If the site is simple enough go with jQuery. If the site has a bunch of complexity then start looking at frameworks like angular, vue, or react. I think you should start with vue though. I like what Taylor Otwell said about vue, you can just put it into the head as a script and start using it. You don't need all the build environment stuff of angular or react. After using it on a few projects and getting comfortable you can decide if you want to add in more tools like webpack, eslint, or babel. 
TLDR: The more you know, the more useful you are.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required).
Flex or CSS columns, made my recent front-end dev so much more pleasant. 
https://media.giphy.com/media/EldfH1VJdbrwY/giphy.gif
lol there's always one person who wants to just be annoying in a thread. If you aren't interested that's fine. I admit this will be a big learning experience. The hosting should be fine but if we need different hosting, we will get it. A host has volunteered their services. 
The great thing about Vue is you actually don't need a compiler to give it a shot. Can just include it in your header like jQuery. I was absolutely garbage at front end and Vue felt really natural after an hour or two and now it seems way easier then using jQuery.
Just seen the rest where you mention that you aren't a developer. No worries. There is 3 parts on this. - the part that will enquire the database to auto-suggest - the js that will use the autocomplete to call back to the script that enquires the database - the part that displays it all and ties it together Im pretty sure that if you look for autocomplete jquery and php you will find a good amount of tutorials. It is not complicated. Mostly javascript work. Note that if you are looking to do something like a google maps address fetch that requires a different api / javascript and it is a bit more specific.
This should be a higher rationale/use-case in the readme, until reading your reply here and digging waaaay down into the read me, it didn't strike me that the purpose was *repeatable* sets of chunks so that your could start each set on different servers for extremely parallel testing.
I agree. I will update the readme to try and emphasize that.
I felt the same way, and then to get around that, implemented a "front end build chain" in PHP - a bunch of straightforward tasks / compilers to minify my CSS / JS without ever needing to touch the rot of NodeJS and NPM. Example [here](https://github.com/swader/nofw). It's quite simply gotten out of hand - the JS ecosystem is just now discovering stuff we've had in PHP for 15 years (server side rendering and pjax) and acting like they discovered hot water - it'll take a while for things to calm down. But like the others said, the old stuff still works. I still love and use jQuery even when I have other JS "frameworks" in my app - my favorite is VueJS because it's really easy to pick up, and does almost everything the others do, but doesn't require you to be running Node, except for some of the more esoteric features. IMO jQuery will be needed for another while for sure, at least parts of it, because browsers are still crap at agreeing with each other (see innerText chaos). And given that people use background videos and 4MB header images on landing pages today, the load size of jQuery relative to total page weight is *nothing*. Feel free to keep using it if you're at home with it.
Something I often use: https://symfony.com/doc/current/components/finder.html
What autoloader do you use?
I updated the readme. I hope that is a little bit more clear.
Thanks. I updated the readme to hopefully make it more clear.
364% doesn't necessary mean that your real app will be 364% slower. It only means that small operation that took 3 microseconds might take something like 15 microseconds which you wouldn't notice. Anyway, it is up to voting members to decide, but I personally hope this inconsistency will be resolved.
It's a 364% penalty on something taking less than ten microseconds, something which probably wasn't in use anyway (because it was fast *and useless*), so there'd be little impact.
&gt; There was a time when looking things up on Stack Overflow whenever you had a problem just wasn’t an option, and many pieces of software had unreadable documentation, if they had any at all. Correct &gt; I remember trying to fix a sound card issue as a kid, and reading the card’s manual, only to find assembly code listings there, with interrupt codes and all. That is the environment where hackers thrived, and **that’s what we are going back to, sooner or later.** Source or evidence to back that up? Quite the bold claim there.
The 360% performance hit is irrelevant, because it's for the case that's currently completely broken. If it's 360% slower, but you can actually use the result of the conversion, I'd say that's a win. As to the fast-path case, I wouldn't be concerned about it either -- it's a moderate hit on an operation that is not particularly common. (There's a lot of practical difference between making object/array conversion 20% slower and, say, making method calls 20% slower, even if the number looks the same...) There was recently some discussion on list to store whether an array has string/int keys. If this lands, this change will be essentially free. Unclear as yet whether it's worthwhile.
Isn't Symfony's Request class PSR7? It has the `createFromGlobals()` method.
&gt; &gt; If your first instinct when dealing with a complex issue that affects multiple technologies is to start with a Google search, you should reconsider your working habits. What kind of shitty hacker doesn't use the best tools at their disposal? "Back in the day", RTFM was the catch-cry - the hackers of old didn't shy away from checking documentation. php.net (usually via Google) is PHP's manpage. &gt; The problem is when Google yields nothing useful and you don't know where to start to fix the problem on your own. True - which is most of the time. If you have a complex issue you'll almost never find someone describing the exact issue or fix. Google/SO/php.net won't save you from having to understand non-trivial issues, because you first need to describe the problem before you can Google it.
Lol... And before that 20 years of frameworks and standard libraries in the non web world.
You can, but instead you'll write div's with identical amounts of markup to achieve nearly the same effect.
They don't have to. The blowback against tables had merit, but the degree was cargo cult.
Routing, basic crud, registration, templating are known things. There isn't much value to be created there. A framework does that and often a bit more while imparting some code level layout/architecture best practices. The end result is you can focus on the parts of the app that do add value.
That's probably the worst line of the post. Later on, it passes on some half-decent advice about how to make best use of Google results as if looking for answers only was the most normal thing in the world. No, sir, I don't feel he attempted to manipulate my insecurities at all.
# A BOOK REPORT: "HOW TO WRITE ABOUT HACKERS!" ## ON A BOOK REPORT ## ON A BOOK REPORT BY JOHN CARMACK ## ON A BOOK BY NASSIM TALEB **BY ~~EMIL~~ /U/ESCAPE_GOAT** ------ ##Step 1: start with a true statement, in bold text: &gt; **Many developers have been building websites without having a good grasp of how things work behind the scenes.** ##Step 2: add another true statement, in bold text. This time build some sort of thesis around it. What kind of thesis doesn't really matter. Maybe something about how maybe the reason people can't understand the full web stack is because they were self-taught and didn't get a formal education like at university or college: &gt; **Language-oriented courses cannot cover the complete web stack ** ##Step 3: *Panic!* In bold Text. &gt; **how can we keep up with the exponential multiplication of web libraries?** ##Step 4: Nassim Taleb!! As the sole substantive concept in your blog post, introduce a key concept that happens to be the title of Mr. Taleb's new book about something unusual and counter-intuitive that we can see everywhere and thus be very much wiser. ###Helpful Tips: * Bring it up because it was mentioned in an article by *programming rockstar* John Carmack. * Relate it to *Hackers!* because ~~that's your angle~~ the idea reminded you of *Hackers!*, plausibly. * Don't forget to remind people that *Hackers!* are cool and not bad. * Don't forget to include a nice picture of Mr. Taleb's good book. Don't forget to put that picture inside a helpfully clickable link to a place where everyone can find Mr. Taleb's good book: &gt; https://www.amazon.com/Antifragile-Things-That-Disorder-Incerto-ebook/dp/B0083DJWGO/ref=as_li_ss_tl?ie=UTF8&amp;btkr=1&amp;redirect=true&amp;ref_=dp-kindle-redirect&amp;linkCode=ll1&amp;tag=chrimaiospo06-20&amp;linkId=4e7ef17ce6f211b37d91cd6334370b83 ##Step 5: An Ominous Warning! In Bold Text. This is a little more vague and unsettling than *Panic!*. Don't make people feel energized to act, or say anything actionable. &gt; **That is the environment where hackers thrived, and that’s what we are going back to, sooner or later.** ##Step 6: Say Something True. In Bold Text. Make it be something everyone knows but phrase it so as to sound pithy and possibly about *Hackers!* Totally *do* put down 'programmers' who might "pragmatic" and just be in it to "impress the boss". Emphasize that writing unit more tests is *never* about procrastination. *Make sure to put it in language that* Hackers! *can relate to:* &gt; **Giving value as a developer requires a certain amount of skill in time management and in setting expectations** ##Step 7: Conclude By Praising Your Reader. In Bold Text: Say something wise about how bosses should hire so as to avert this dystopian future of expomultiplicates where real men will need to LAN-hack their TI-88's with bare teeth. Make sure the hiring advice is applicable to almost everyone ever who has ever programmed a thing ever, so that everybody feels a little bit good for a moment: &gt; **Ask a candidate what he likes to do on his spare time, or what fun projects he worked on as a hobby, and you might be onto something.** ##Step 8: Point-Form Folksy Finish. For those who insist on reading unbolded text. (Punish these!) Spend a few minutes thinking of some original advice. Talk about how everything is growing fast and learning is great but not going to cut it it is survival of the fittest. Remind people that they feel anxious about how much they know and having so many frameworks makes them feel anxious. Remind them to feel anxiouser. Remind them that they are just charlatans that will be the first against the wall when the revolution comes if they don't somehow become: *Hackers!* 
Without JS/PHP: https://developer.mozilla.org/en/docs/Web/HTML/Element/datalist
Sorry no library, but here is the previous Library / Tool Discovery threads, https://www.reddit.com/r/PHP/search?q=Library+%2F+Tool+Discovery+Thread&amp;sort=new&amp;restrict_sr=on Edit: sorted-by-new link
You're missing the point, the entire tool chain above is for one single language, never mind anything else. PHP, .net, Java are all different languages with their own tool chains which is understandable. There is absolutely no reason for one language to have such a mess of a tool chain as Javascript
Vue is by far the stand out project in Javascript for me at the moment, React seems an anti-pattern to me all the years of progress about separating concerns and React comes along and says nah lets go back to the 90s and smash everything into one instance. I think that's why the jQuery crowd jumped towards react rather than one of the more strict MVVM frameworks
&gt; I'm coming from Laravel, so it feels like a big step backwards Since we're a bit biased, it would be great to get proposals about things to improve. &gt; Yii::$app shit You're unlucky if you have an app full of it since there's proper DI container in Yii 2.0: http://www.yiiframework.com/doc-2.0/guide-concept-di-container.html &gt; documentation is the best I've seen Thanks! We're improving it constantly and newcomer feedback is the most valuable for improving it. Overall, you're very welcome at GitHub. That's the way to improve the tool you're working with making it comfortable for you: https://github.com/yiisoft/yii2/issues
I was considering mentioning those proposed flags in the RFC, but because they're only a proposal right now and my patch doesn't use them currently, I omitted them. It would speed up array to object conversion, but it wouldn't do anything for the reverse (we'd still have to iterate to check for numeric string keys). Object to array casts are inherently more difficult to optimise, unfortunately. But it's only a tiny performance hit, so it doesn't matter.
put these at the top to see errors ini_set('display_errors', 1); ini_set('display_startup_errors', 1); error_reporting(E_ALL);
 curl_setopt($curlh, CURLOPT_INTERFACE, "&lt;value&gt;"); Where &lt;value&gt; is one of interface name, an IP address or a host name. 
The next steps are to grok the output and provide better messaging for end users. This spun out of downtime from the Dyn DDoS. I wanted to launch an MVP as soon as possible for community feedback and end user needs.
I must have missed something. Why is jQuery dying?
&gt; Isn't Symfony's Request class PSR7? If you are talking about symfony/http-foundation. No. It has a Bridge though to make a psr-7 request and response to http-foundation and vice versa. 
Like hypercard?
### Slim describes Middleware as code you can run code before and after your application to manipulate the Request and Response objects. Is this a correct definition? Yup, seems allright ----- ### Things like routing and authentication are now part of my framework. Is it better to make Middleware of certain components of my framework? If yes, which components could be turned into Middleware? Yes and no, it depends how much control you want vs how much automation. Taking laravel as an example : * routing is done before middlewares enter the picture, but the subtitution of url params with object is done in a middleware. * You can specify in the routes files when you want a route to use a middleware : authentication is one of thoses cases. * I am currently thinking about a multitenant app, and experimenting with middlewares to scope all eloquent request depending on the user at the middleware level, instead of in every repository/queries. * Many things. But if you look at yii2 (as far as I know, might be wrong), use a lot of beforeSomething hooks when you can at equivalent logic. Auth logic for a specific route/action could be in a `beforeAction` hook, and all "related" code would stay on the same class. And you could also go full middleware madness (might try someday) and do everything from routing to controllers as middleware. (model and service classes aside). I could see it usefull in some small and really specific use cases. What if I can add a middleware to the current stack in a middleware ? Middlewareception ! As far as I am concerned I go the laravel way, because I know how to dev fast with it, and think of it as a manageable balance between middleware purity and complete granular control, but I wouldn't go as far as saying it is the defacto solution. ---- ### On the PHP-FIG site I saw that PSR15 (HTTP Middleware) is still in development. Should I wait for it to be finished before implementing support for Middleware in my framework? If yes, does anyone know how long it approximately would take for PSR15 is accepted? If no, any tips (or tutorial) for me how to implement support for Middleware? Do. Don't. Whatever. PSR-0 to PSR-4 are (almost) requirements, other aren't. Or are they ? PHP-FIG used to be only for their members and thoses who wanted. Now, I don't even. **PHP-FIG sate of affairs isn't the core of this thread, please don't aswer about it. Wouldn't help /u/laurensV6** ---- ### Do I have to treat my framework as a Middleware layer as well? Might be fun, but not everything can (or should) be shapped as a middleware. When you have a hammer, not everything is a nail. Some thoughts : * Could you shape your front controller as a middleware and would it benefits you ? * What would launch your middleware stack ? What about config ? And again, would it benefits you ? * ... And similarity of design is not similarity of purpose. ---- ### Any good reads about Middleware? Lost all the favorites with my dead computer. Sorry.
Honestly theres no reason to use mysql_ or mysqli_ functions. Use PDO and have better resistance to SQL injection out of the box, plus have the power and usefulness of prepared statements
If your looking to use standalone scripts that perform maintenance tasks **Outside if Framework Environment** Use cronjobs to trigger scripts. Setup a shell script in /etc/cron.hourly/ or something and use tell php to run the script **Inside Framework Environments** Use cron jobs to call curl against specific URLs in your main application **Legitinately want to run a script on a port that does something, kind of like a continuously running node instance** Php isnt designed for that kind of stuff, though tools exist that can aid to acconplish the effect. ReactPHP is a async tools/franework that makes php act like a node tool, launching the script would attach it to a port of your choosing and just run until you either tear it down or it crashes lol Good luck 
I think this is a great start. Some useful features for power users would be the ability to do things like alias a forked package to a required package, which I need to do infrequently and can never remember how to do :) I've seen users struggle with composer too, and I think this is a good start on a solution. The hardest part will be providing useful feedback to help solve problems that they run into. 
As a symfony command, you should be able to output composer logs as json. That should go a long way toward formatting. I'd also consider parsing composer.lock yourself to show a comprehensive overview of installed packages, versions, patches, etc. Also, if you incorporate "why" and "why-not" commands in the ui in order to help people understand version conflicts, that would be amazing. Composer's "problem" summaries are incredibly esoteric even for seasoned users. Lastly, if you can make this pluggable in any sense, that would be amazing. I'd love for composer plugins, like composer-patches, composer merge, Drupal scaffold, or BLT to be able to provide ui components. ~grasmash
This kind of silly, pointless and harmful video is the very reason why PHP is still frowned upon by many programmers.
I was one where I didn't fear the command line. But I sucked. Hard. And when I'm paid and on a tight deadline... It's more frustrating. That was my experience with SourceTree. After 6 months I got comfortable with Git enough to use on the command line. But I agree your sentiment. However do we really want to exclude those users and put up a barrier or hopefully build a bridge? In the Drupal community, I do.
Curl in general is a bit of a clusterfuck but it's still the swiss army knife of ${random internet request}
Agreed. I find GUI slower now. But it's time and experience. Think of PHP devs who all started using phpMyAdmin. I now hate it and use MySQL command line direct. Also, SourceTree is the only CLI-&gt;GUI that I found to be spot on and useful. I'd love to mimic their impact. Honestly this would be easier as a PhpStorm plugin, but that doesn't solve the greater problem.
&gt; The next steps are to grok the output and provide better messaging for end users. Why not take the step of turning it into a training tool instead of a crutch? Show the commands that are run in the background for every action in the GUI and show (optionally?) the console output as well as the improved messages.
How exactly is the method used harmful? It works and it works well.
Or like a console output tab, thing. Kind of like IDEs and their VCS integration. Usually there's a tab which shows the command it generates and output. Right now there is a console output section that is raw. Maybe a "learning" flag can print raw command and raw output rather than processed.
There are many problems with this code, but the main, the fundamental one is that your code is *exactly the same* as a code that has been written in the last century with PHP3, 20 years ago. You are just re-telling this old shit, adding nothing new or improved. A cargo cult programmer, zealous to spread the word and create as much cargo cult programmers as possible - *this* is a real disaster. 
mysqli by itself is neither outdated nor insecure. Let alone that it's hard to make a breach in a code that practically consists of just one meaningful line. The point is different here. 
SourceTree was the only git gui I actually liked but lately it just seems so clunky and in the way. I don't mind mysql command line but [Adminer](https://www.adminer.org/) is *so* much nicer and easier to install than PHPMyAdmin and it's not limited to just MySQL.
You see, adding an "i" letter to the function call is not that a big deal. An *ape* could do it. It's your *approach* which is the same old shit. Even with "i" added. But well, I quite realize that you are so ignorant that you won't get it anyway. May be in time, if you take some effort in learning. You'll see what a dead shame your video is.
On the other hand, there are those that will simply never learn or feel comfortable in the CLI, and for whom GUI implementations represent a way to gain access to a tool that they'd simply never have otherwise. Will it make life harder from a CLI perspective? Maybe. But that may not be a negative to some.
Everyone who has to do things with composer should be familiar with the CLI or they will have serious problems as a developer. If they are not a developer, they should probably not be doing anything with composer.
How is it insecure? Not saying you're wrong. Just not sure how it would cause a problem.
Honestly dude, I'm not sure what your problem is. If you can point out a legit, specific problem with the code that makes it unsafe or inefficient then I'm willing to accept that. But so far you've provided no such thing. I have no problem with being corrected. I made a series of videos explaining the method I've used for the past two years to work with MySQL. Perhaps I've been doing something wrong without realizing it. If that's the case, then by all means point it out and I'll be happy to learn from it. However, going on and on about how my video sucks and my code is 20-year-old, outdated, horseshit without explaining why is little more than trolling.
This shitty video deserves nothing else. 
LOL whatever man. If you're not going to make any logical criticisms then I don't see the point in continuing this conversation.
we've all been there at some point :)
I would just use echo statements to see how far it is getting, like echo $_GET['page']; I do this a lot because usually it is something simple. Maybe analytics is getting included but not outputting anything.
&gt; - Static methods invocation via '-&gt;': follow PHPUnit best practices (do not report it's assert* methods); Too bad, we've started converting all cases to assert::, I know it's the "best practices", but the warning is still correct.
Could always use Guzzle: http://docs.guzzlephp.org/en/latest/
Thank you for pointing out, I'll provide an option where you will be able to reactivate this behavior. A ticket for it: https://github.com/kalessil/phpinspectionsea/issues/6
I'm not opposed to GUIs for cmd tools, but they have to offer something better, ie make it easier to use composer - and easier for everyone, not just newbies. I'm not sure that's the case so far (but it's hard to judge from one gif). The key is not to approach it as a GUI for a cmd tool, but as a GUI for some set of tasks. 
Cool, will definitely try to use the PSR-15 implementation :) Do you know if there are any other projects already using PSR-15? I will continue to follow the PSR-15 progress in the PHP-FIG Google mailing list, hopefully it will be accepted in the near future :)
Middleware doesn't have a "proper" definition in web development. I always thought it be a glue layer, agnostic. So sure, casting from a raw request to some object is middleware.
All the projects I know of are experimental. You can check out the dependents list on Packagist for more info.
Using Guzzle, you can do it like this: `$client-&gt;get( '/login.php', 'curl' =&gt; [ CURLOPT_INTERFACE =&gt; xxx.xxx.xxx.xxx ]);` From here https://github.com/guzzle/guzzle/issues/590
I can get stuff done quicky on the command line but I could not *learn* the git concepts correctly via only the command line. Sourcetree was a god-send.
cheers, i guess i'll just have to hardcode it in to my scripts
apples and oranges
is it sarcasm? :) there are scripts attached, you can run yourself and check
They should have used PHP7 instead of PHP5. CPU was basically idling. I have always used PHP for scraping. I love PHPs string parsing and charset functions. All tools are there. Tons of documentation and examples on every single issue always.
We do not compare languages in common, we do comparison regarding practical usage just in web scraping, why do you think we are comparing incomparable things?
I'm not doubting that the scripts were written. I'm doubting that Diggernaut has the experience and/or inclination to write efficient scripts for their competitors.
You've compared: a) a proprietary solution which the reader is unable to run. b) a language c) a language d) a web scraping framework e) a language Those are not comparable things. 
a) Everyone can build and run it, its completely free b)...e). We are talking about comparing a solutions written in diggerent languages for some specific purpose, and we are comparing speed and server resources usage, what are you talking about? Why its not comparable?
Yes, probably you are right, that's why there are all scripts attached. Anyone can read them and point out non-efficiently written parts of code and give some suggestions how to improve it.
&gt;no, you cant All I needed to know, thanks.
I don't know much about PHP's internals, but it seems like unnecessary complexity to have to convert numeric keys back and forth when casting arrays/objects. Why not instead store numeric object properties as numbers, just as they are for arrays? Then no conversion would be necessary when casting. Currently numeric properties are inaccessible, but couldn't this be changed so `$obj-&gt;{'1'}` would work just like `$arr['1']`?
There might not be a need for the keys, but they do make it a whole lot more obvious which key corresponds to which element.
You could use environment variables? When you run your script, right before, run a command to extract the network interface IPs from the machine and set those as environment variables, then load those in PHP with getenv()
I was thinking curl in general, less as a PHP library. Guzzle is what I would typically use for PHP, just like requests for python.
A custom one. Works like PSR-4, but if you wrap a directory name in square brackets, it's not a namespace. 
I've created a small PSR-7 oriented php component framework (just for fun and learning purpose). Maybe it will inspire you. https://github.com/odan/psr7-full-stack
&gt; Why not instead store numeric object properties as numbers, just as they are for arrays? That is an option, and it's suggested under Future Scope. That would be a much larger change, though, with potentially more downsides. It's possible we'll do this in future; it might be the only way to fix some other edge cases.
I would say it's purely educational. If you're learning about the internals and want to try out different things than what the compiler gives you or want to play with building your own control structures this allows you to do it.
Uses register_shutdown_function and calls fastcgi_finish_request if possible.
have any of you used microservices and what sites would you recommend me to get them from 
Sounds interesting. When you say "emit", do you mean it prints opcodes to stdout? I wonder if you could add to your `README` the result of running the Hello World example?
Ah, right, thanks - learned something new! 
I didn't actually look at what their exact values were, but sure in this specific examples the keys wouldn't be necessary. 
I use PHP for scraping too, but I am not sure that PHP7 would help. I imagine that scrapers are either mostly sleeping (since you don't want to DoS a single target) or are bound by a relatively slow network connection. 
I use [Goutte](https://github.com/FriendsOfPHP/Goutte) to scrape the web - supports sessions, and CSS/XPath expressions. Pretty easy to use, but docs are a bit on the light side. No JS support, but you don't always need that. 
Interesting article, thanks. This test would be good if you had a large number of different scrape targets on different servers. However, in your example, you're seeing how fast you can scrape from one site, which is not good practice when it comes to scraping. If you wish to scrape a single site, the ethical approach is to scrape it slowly, otherwise you are placing on the remote server owner the costs of taking their data. At the "high performance" end, you may create a denial of service, which will get you IP blocked or may result in your upstream provider receiving complaints. Now, I expect US gov websites can take a bit of a pounding, but if your specialism is web scraping, it is good to lead by ethical example `:-)`. 
Having had a quick read through the OP's site, it looks like [a reader can run the proprietary GoLang version](https://blog.diggernaut.com/self-hosted-scraping-no-problem/) - you just need to be willing to trust their binaries `:-)`. It's probably quite safe to run it in a Docker container. 
It's not because we invented the drill that we can't use screwdrivers anymore. I don't see how adding more tools to the toolbox is a bad thing. GUI tools may have limited options compared to their CLI version, but they can do wonder in simplifying the most common used functions and present the information. Sure, if you only use GUI tools and have no knowledge of the command line, you handicap yourself. But at the same time, I saw basic coding errors by developers using VIM and command line GIT that were easy to see just by using PHPStorm or SourceTree. As long as the job is done, who cares if you used a drill instead of a screwdriver?
Hypercard is a form of hypermedia. This is specifically about REST services, which are/should be hypermedia api's. 
Even better, thanks! 
Optimizations of course ( ͡° ͜ʖ ͡°)
Was looking at slides for 5 minutes. Still have no hypermedia API.
I'd have a super lightweight endpoint (hell, if you're on AWS then use Lambda) that would receive the information you collect on the frontend, post it to a queue, have workers to pick it up and add what ever you need then send it off to your reporting system (what ever it might be). The less moving parts in a high volume system, the less room for failure. Edit: Oh, and, plan for failure. I forgot that. Your frontend should have a timeout in case the endpoint is down. Use RMQ in a cluster, for high availability (this is additional to their default cluster setup - read http://www.rabbitmq.com/ha.html) because machines suck and interwebs are flaky. Make the messages persistent (assume boxes will fail), assume your workers will fail and force ack before it can dequeue a message. Edit: the above is a whole lotta stuff by the way. Ime, 10s of millions of simple data points per month can be sent to a webapp and saved in a properly set up db pretty speedily. So if you just want to _start_ record it then I'd probably start with that and then start setting up the infra described below. Hell, you could get fancy and run both setups just to make sure the $scalableSolution works (have frontend client randomly select /v1/ or /v2/ of endpoint).
I learnt this algoritm last year and I remember implementing Additive smoothing (Laplace), with k=1 usually. http://i.imgur.com/esgeWJZ.png https://en.wikipedia.org/wiki/Additive_smoothing I really like the implementation though. We implemented this algorithm in Python. I really like Machine Learning and neuronal networks, I studied that stuff in "Artificial Intelligence"
Cool. I actually had to get into machine learning. Great post! I'm so nerd I'm actually happy tomorrow is Monday and I can do some tests in less than 12 hours
Educational is a use case ... and a pretty good one ... Kudos for sharing ... Not everything needs to make a buck, it can just show you something you haven't seen before, or just be interesting in some way ...
Why the move to github? Just mildly curious :)
These days, you’re nowhere without a car, so there’s a huge value to car development skills.
Cool tool. It just baffles me that people think they need to be on a first name basis with Linus Torvalds to use a terminal window...
These days, you’re nowhere without food, so there’s a huge value to food development skills.
I did my masters in applied artificial intelligence. With all the fuss over deep learning it's good to remind oneself of how beautifully simply yet effective Bayesian classifiers can be for some problems. I did a short article on PHP machine learning [HERE](http://www.syntheticminds.co.uk/blog/is-php-now-suitable-for-machine-learning.html) that you might be interested in.
What is your favorite deploy system to deploy github code to production server? Do you know some good tutorial to configure that deploy system? Thanks! ;)
I think it appears when there are no comments... hence the depression!
The ideal solution would be that all keys are strings, in both objects and arrays. Internally it can still use more efficient storage for integers. It would eliminate decades of awkwardness in how array keys are handled, and it'll match what JavaScript does, which is precisely what I just described (if you iterate an Array in JS, keys come out as type string, but internally they're an integer). Unfortunately this would be a minor BC break, so I guess for PHP 8?
Scenarios where this is vital: * serializers * generic factories * hydrators * data-mappers * property accessors * reflectors At least from my point of view, this is absolutely vital. You will not need it in domain logic, but for library code: hell yeah!
hello Dykeanhorrors; I posted directly, not with node. 
Could you please include, as well, an array of objects as you are already working on this RFC. That will be extremely helpfull. Thanks a lot.
It's to make sure that if my method accepts only objects, I can annotate this so that people get a slap in the face if they put an integer in. You can't always type-hint against a specific interface (or object).
All keys being strings can't be efficient, because even if it's integers internally, you'd have to convert back once its touched in userland.
https://wiki.php.net/rfc/arrayof was proposed for PHP 5.6 and was declined.
Nah.
The conversion could be quite trivial, you can even intern the strings for the first 128 or so keys, and put them in a table where table[num_index] = string_zval, because when you use numeric keys, they're typically 0-based and sequential (list semantics). Optimizing this wouldn't be a problem. The larger issue is whether string-only keys would make more sense semantically, and frankly I think they do.
&gt;This method is called p No, it isn't, and I seriously hope you guys don't do this. The function should be called, *calculateProbability*. I don't know why some people think that the more "maths-y" you get the more terse your function names may become, but if you think that, [you're wrong](http://codelegance.com/semantic-method-naming/). Similarly, *totalP* should be renamed *calculateTotalProbability* and *getWords* should be renamed *filterWords*. 
&gt;With all the fuss over deep learning it's good to remind oneself of how beautifully simply yet effective Bayesian classifiers can be for some problems. My company hires AI and ML specialists, lately. It usually goes like this : - me: How would you classify textual content ? - them: I would start by blabla &lt;scoring&gt; blabla &lt;neural network&gt; blabla &lt;various complex systems&gt; and blabla and... - me: What about a simple well-trained Bayesian classifier ? - them: Oh uh...yes...well...in fact...crap, yes. *Edit: Formatting*
Exactly. Like: * Sometimes stuff is easier to understand as a diagram or a scrollable list * Sometimes hitting a button is easier than remembering a command It's literally the same reason why we use GUIs for anything else. Otherwise we'd all be using command lines for everything. 
You're posting this here for the second time. We got it. You chose PHP because there are a lot of cheap PHP coders in poor countries. Thanks for sharing.
How confusing it would be if a method were named according to what it does.
Posting it again as there was a problem reaching the article in the first time by some users. Sorry, new to reddit. Interesting the way you view things. There are cheap coders in every programming language. So, rather, would love to hear your comments or feedback if we have missed something. At the end of we are startup and part of what we have to do is making strategic choices. Only time will tell if they are right or wrong. 
I think he's referring to the definition written down in the description compared to the actual function in php
Rather than hard coding special cases in core, the union types RFC provided a way of doing this in userland, by allowing users to combine arbitrary types. typedef scalar = string | int | float; or typedef numeric = int | float; However....not enough internals people could see the value of it. 
&gt; The whole concept of this feels like it's trying to allow sloppy code to present itself as good or modern Disagree, it's to avoid to pass a parameter without any typehint, typehinted as `object` in the phpdoc, and checked with a `is_object` in userland. As /u/Ocramius said, there is little benefit in your domain or a regular app, but for a lot of libraries this would be very helpful. 
Nice, I was wondering how it was done as well, thanks for digging into it in my stead :P
You don't get it. The goal is to have a tool to develop easily powerful APIs (validation, pagination, filtering, sorting, security [strong typing, security headers...], serialization groups, hypermedia, authentication...) with sensitive defaults. By default only JSON-LD/Hydra support is enabled as we think that it's the most useful format out there (especially because it's a W3C standard and backed by Google). Users of the API only have to understand JSON-LD (and it can even be used as an old raw JSON API too if keys starting by an `@` are ignored). Mason, JSONAPI etc all are not supported yet by API Platform and there will always have only 1 hypermedia format enabled by default (but it's technically possible to add support for other formats by creating an adapter, fi a contributor is working on an open source JSONAPI adapter). HAL is supported but is not enabled by default.
It's not how I view it, it's how the article describes it. "It was much easier for us to find highly-skilled PHP programmers in Oryx Cloud operating locations in Eastern Europe, India, and the middle east." I'm suspicious about the "highly-skilled" assessment. The pool of PHP developers is indeed very large, but the majority are of very low skills, comparatively. The PHP job market is full of WordPress tweakers, and people who write code like it's 1998. Once we strip the beginners/intermediates, what's left is not bigger or smaller than the pool of talented developers working in other languages. So PHP is not at a disadvantage, but also not an an advantage, either. Well, maybe subjectively it's at a disadvantage, unless you don't mind the chore of having to go through tons of "dirt" to find the few nuggets of "gold" among the candidates you'll see come apply for a job with you. The bigger problem of your article is that it contains general musings about various web platforms and almost zero details about what your application's needs are, what you MVP includes, and how you plan to evolve this MVP in the long term. Any discussion of language cons/pros are pointless without us knowing exactly what your app is about. And I don't mean just on the surface, but I also mean various parameters of expected scale, business requirements on the back-end, that users can't be aware of, and so on. The only thing I can tell you is this: it's nearly impossible to stick to one language for your platform in the long term, either if it's complex, or if it scales up, or both, because no single language has everything you'll need. So feel free to start with PHP, or Python, or *just about anything*, as long as your problem is so trivial and generic, that you don't bother to go into the details of it, then it doesn't matter what you use. But if you plan for your platform to see heavy use or significant complexity, not to mentions things like failure recovery and redundancy, then you'll need serious architects on-board, that can create a modular (and later service oriented) architecture for your platform, and I can guarantee it won't all be written in one language, let alone in a single framework.
 Does anyone know why it was declined? It seems very useful and doesnt even break backward compatibility. 
Unions are great, but I don't agree "scalar" is a special case. It's essentially the only way to describe that you want a scalar, without forcing a cast on it. It's a use case that's widely predominant throughout PHP code, it's essentially how all of PHP code operated when it took scalars, before PHP 7 added scalar typehints (which unfortunately also are picky about what kind of scalar you get). The thing with unions is that while they capture a particular problem in dealing with types (and so do intersections) they can't capture the way PHP operates de-facto. Your example above for "numeric" doesn't include numeric strings, which is by far the predominant way numbers come in PHP (from HTTP fields, SQL etc.). Oh and your scalar example forgot "boolean". I want "scalar" typehint to remove complexity and runtime burden from code that does casts where I need none, and using unions for this purpose is precisely the opposite result. The "array" typehint is no different in that regard: you don't know if it's a list or a map, and what is the type of the values. Yet we have an array typehint, but no scalar typehint, for some reason.
Is this just to accept an "object"? Any random "object" type? It doesn't seem very specific. Maybe this should be more explicit about concrete object types; this would lead to accepting and returning interfaces too -- which would be much better. Although, this may cause a problem with object type hinting. 
Apparently here: https://www.reddit.com/r/PHP/comments/1z6y8n/php_rfc_array_of_in_voting_phase/
&gt; Imagine you pass some paths (an array) to an method that essentially contains PHP arrays that are merged together. How would you test such a task? (As the method includes the files) When an object performs an action, that action is always visible in some ways. Test the outcome. It's hard to say how to do it exactly as you don't go into enough detail.
Always Git, there are bunch of tuts in youtube.
Sorry to bring up an old topic, but after attending a recent talk on the ADR pattern I decided to have a go at implementing it in Laravel myself: http://martinbean.co.uk/blog/2016/10/20/implementing-adr-in-laravel/ I then came across this thread and see it’s quite similar to the approach Taylor wrote in his Gist, and using invokable classes as the route actions.
&gt; you can even intern the strings for the first 128 or so keys, and put them in a table where table[num_index] = string_zval Yes, sure, but that doesn't completely eliminate the issue. As the huge performance delta for this RFC's uncommon cases shows, heap-allocating a ton of new strings in a loop is not fast. &gt; The larger issue is whether string-only keys would make more sense semantically, and frankly I think they do. PHP's arrays are dual-purpose. For an array entirely of integer keys, is it really such a benefit?
&gt; As the huge performance delta for this RFC's uncommon cases shows, heap-allocating a ton of new strings in a loop is not fast. You don't have to deallocate at the end of the request, so you don't need to allocate at the beginning of the next one. &gt; PHP's arrays are dual-purpose. For an array entirely of integer keys, is it really such a benefit? It's a benefit in terms of design: it's more predictable, and it's easier to explain, learn and use. As I already said, the internal implementation can be optimized for lists when it's a list. As PHP 7 does (and JavaScript does). 
This product involve the complete management of front end , you can generate invoice and send multiple email like Mail chimp . For More view the video ...
Instead of reserving `object` as a keyword from 7.2 and above wouldn't it make more sense to simply use `stdClass` - which all objects inherit from (as I understand it?), and is already a reserved keyword so there is no chance of a backwards compat issue.
More importantly, what happened to the one that recommended NodeJS?
The decision is "don't cast it, I don't want to lose information before I can process it more intelligently". For example, the field values in a result set coming from SQL are scalars, but may be any type of scalar. Including booleans, why not. Or for numeric strings, if it's already an integer/float, I don't want to cast it to a string and back. But if it's a numeric string, I want to convert it myself, and treat it completely differently if it's out of range (i.e. gmp/bcmath) or cast to int/float if it's in range. PHP can't do that differentiation automatically. Its options are too limited out of the box, and I'm fine with that, as long as it'd allow me to describe my intent ("give me a scalar") and nothing more ("cast it blindly to some type of scalar"). Additionally, there's a special property to the PHP7 scalar typehints, compared to the typehints before. Imagine your program has been extensively tested, and nothing trips TypeError conditions. Then you can strip out class and array typehints, and nothing would change at all. But if you strip away the PHP7 scalar typehints, data that was cast is no longer cast. So the program changes. A "scalar" typehint that covers all scalars would have this property of being removable, as it doesn't change the data, it only runs its assertion and either emits a TypeError, or not. As it should, anyway. I like my assertions to be assertions, and typehints are nothing more than this. Assertions shouldn't change the outcome of a correct program. 
As /u/nyamsprod already noted, there's an (at this point somewhat vague) plan to replace resources with objects where possible. The big precedent for this is GMP, which changed from a resource to an object in PHP 5.6. Having a `resource` type hint could be very problematic for such a migration, because it would turn a relatively transparent change into one that breaks any code using such a typehint. The second reason is that generally you are interested in specific resource types. Your function `read_file(resource $file)` pretty certainly does not accept just any resource, it requires a specific resource type. (Note that this is very different from the argument that a number of people raise against `object` -- the difference being that the vast majority of `resource` hints would actually require a specific resource and could not handle a generic one. This is not the case for `object`, which would only make sense if you really can accept any object.)
Nice to see others working on it. :-)
instead of reserving yet another keyword, why not introduce a common base class of all objects? Then you could type-hint to that and it would have other advantages too.
But we can already typehint interfaces and classes?
If people are lazy they'll just not use type hints at all (or do anything else stupid) with or without the `object` hint. It's like forbidding kitchen knifes because some people can get hurt.
You can, but like most cryptography, writing your own implementation will [probably blow up in your face](https://framework.zend.com/security/advisory/ZF2015-10). [Use one of these libraries](https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide).
You should give [Flarum](http://flarum.org) a shot. It's open-source forum software build using Laravel (organization of project is different than default). It's got a good feel to it and it seems the authors have paid special attention to keeping UX very simple / minimal yet functional for end-users.
Ah - I've just realised that in all of the cases where I have exploited this it has been from data that has come from a `json_decode` which of course returns a `stdClass`. Probably for the best that I now tend to wrap this stuff in a POPO :P
Interesting. Didn't know this. Thanks.
Replacing `resource` with an object makes sense. Hopefully something comes of it. Thanks for the input.
&gt; I would be interested in hearing the design decisions that were made when thinking about what that function should do. [Mapper](https://github.com/ScriptFUSION/Mapper#expressions) allows this. It also permits several other types, including `array` and `null`. Scalars are unmodified during mapping whilst other expression types may be augmented. `scalar` might also be useful in storage contexts where such values can be passed straight to the storage driver and stored verbatim without modification. In such cases, it might also accept additional values, but writing `scalar|Foo` is easier to read than `int|float|string|bool|Foo`. Nevertheless, I do not think adding `scalar` to PHP, when it has union types, is nearly as useful as allowing users to create their own typedefs. For example, it would be very useful in Mapper to be able to define a `MappingExpression` type as `scalar|array|Strategy|Mapping|null`. Users that need a `scalar` type can define it themselves.
I'm aware of what it will accomplish, but what's the *use case* for accepting any object but only an object?
They are real people. They are my email list.
Then maybe, its time to add a common base class to PHP? Most modern OO languages have base Object class. Sure PHP's base/root class doesnt need to be named 'Object', maybe making 'StdClass' a common base class will be very helpful. 
It is quite remarkable a fact that many PHP users confuse "best" with "fastest". But of course laymen will be impressed with your revelations. Keep going. The "echo vs. print", a bleeding edge question, is waiting your tests.
Well, if you read the article, the author was specifically challenged over what methods of concatenation he used "for performance reasons," and he proved that it literally doesn't matter. The only thing that makes a difference is PHP5 vs PHP7, and if you used sprintf instead of just concatenating it was slower.
https://mybb.com/
Well, strictly speaking there is no such thing but yeah.
Sorry, you can't comprehend even a paragraph of text, not to mention a context of the whole conversation. You are limited to a single sentence. It means I am wasting my time.
I'm using sprintf all the time, in my post I was checking which way was the fastest, that's it. I wanted to check if it's important to use single quotes or double, and now I know. As u/tinylittleumbrellas said, PHP 7 is doing the difference and this is also something that I didn't know.
In real world I'm using e.g. Blackfire.io to profile my app ;) This test was created to finally get the information if it matters if I use single or double quotes. I mean, if I didn't know I was wandering from time to time which one should I use. Now I know, so I have a little less to think about when writing code and I can focus on what really matters :) Thanks for the tips!
&gt; echo 'The quick brown ' . $animal1 . ' jumped over the lazy ' . $animal2 . '.'; Yeah, but I think I like `echo "The quick brown {$animal1} jumped over the lazy {$animal2}";` even more, in my opinion there is no more readable way. But sprintf is cool and for more complex concatenations it's the best option. 
It's not weird that sprintf is slower as it also performs a type check on the injected parameters. and ofc, here's the obligatory "something, something, premature optimisation" that other comments liked to stipulate as well. 
So, what matters is variable interpolation vs not, without any interpolation, the resulting opcodes are identical for single and double quotes, so no performance difference. Check out the video at around the 31m mark for concatenation. Earlier bits cover interpolation. Suffice to say that your tests are not very useful, nor surprising. You would find that `+=`is more efficient, and though you are surprised by it, sprintf is a function call which comes with some overhead to pass in, parse, and utilize arguments. In fact, calling a function is a multi-step process: 1. The function call is initialized 2. The arguments are passed in (one opcode per argument) 3. The function is actually called 4. The arguments are recieved (one opcode per argument, userland functions only) 5. The work is done 6. The result is returned What sprintf gives us is complex, formatted interpolation, not concatenation.
&gt; data that was cast is no longer cast. I don't use weak types, I only use strict so I don't have that happen in my programs. And I think what you said is a really good argument against using weak types.
That was pure academic test ;) but I think it's important to check even that simple things. Next time I'll check performance of arrays and this will be much more helpful test.
You didn't test implosion. $sb = []; for($i=0; $i&lt;10000; ++$i) { $sb[] = "$i"; } return implode('',$sb); vs $sb = ''; for($i=0; $i&lt;10000; ++$i) { $sb .= "$i"; } return $sb; Using an array like this is faster in many languages because you're not creating a new string on every iteration; you're appending to an "array", which if implemented properly, will allocate more space than it needs so appends will be fast. Also, be sure to append random/different vars for all your tests, otherwise JIT compilation might compile away the concat (not sure if PHP is clever enough to do this or not, but you might as well rule that out).
works for echos but not string building.
And sprintf or `.` concatenation will prevent XSS how?
This needs clear reproduction steps. Especially since OP initially forgot to disable xdebug…
You're absolutely the right. Everything in life without empirical value should be purged with fire. Entertainment is for the weak. /s 
It doesn't have to be eternal to be entertaining. 
Ok, that's pretty clever. Well done :)
Thank you for providing us with a schoolbook example of a premature optimization. An useless optimization out of nowhere that ends up with doing the same job twice is what all this topic about. 
I've heard a lot about Flarum, and while it's certainly gorgeous, I really dislike its server settings and general structure. [This, for example, bothers me way more than I think it should](https://github.com/flarum/flarum/blob/master/.htaccess) Personally, I'll keep an eye out on this one. I would love for it to allow me to set whether or not I want everything installed to webroot (which is currently its default, and something I personally think is a bad practice), as well as allow me to define which route groups are mapped to which of the primary server types (ie: maybe I want my api and admin servers attached to subdomains rather than /api or /admin routes) I may contribute to the project to see if this is something I can tackle.
The problem with videos is that if they contain errors, they are time-consuming to re-shoot, and even if the advice is terrible, my experience is that authors will ignore any requests to correct their mistakes (I have tried). This part 1 does not actually cover any PHP, and I guess part 2 is not available yet, so we will see... [This tutorial](https://codek.tv/v/e4eFBQmWs8Q/how-to-connect-android-with-php-mysql-best-android-studio-tutorial/) from the same site has a whacking great SQL injection added in, and using MySQLi too - which can do parameter binding just fine `:-(`. There does not seem to be an easy way to comment under videos, but in any case - **beginner beware!** 
Whilst I really don't like that either, it feels miles ahead of the horrible PHP forums that seem to be very popular.
Except right on the [download page of the project](http://flarum.org/docs/installation/) it says not to use it in production.
That's only good for variables, not functions or expressions. For that reason I do most things with sprintf just for consistency. 
If I had to guess that's going to be much less memory efficient.
Seems more like an academic test to me. He proved that one way is objectively faster than another. Neat, but in the real world the difference is negligible and doesn't matter - which is the point of the post, I think.
1. you should be using [prepared statements](https://secure.php.net/manual/en/pdo.prepared-statements.php) 2. the reason is duplicates is because you're iterating your list_name,list_price combined array for each list_row_id. You have 2 list_row_id and so the list_name,list_price array will get looped over twice. 
I don't see what the fuss is about personally. If your site is simple enough, just use jquery. But if it's going to be complex and featureful, a lot of these tools will help you build more robust, maintainable projects. I remember the days of maintaining complex front ends that used jquery and they were often an unmaintainable mess over time.
Why is that a problem? It makes sense to check facts you don't know, regardless of subject.
Yeah, it's a nice feature indeed! I'm glad you found it. Almost all IDE's have this ability. That is also a good reason for using an IDE and not a text editor for programming. Most of them have built-in revision control.
I recently had an issue with upgrading a CodeIgniter codebase to PHP7, where I kept getting 500 errors with no error messages. Turns out I needed to change the DB driver from 'mysql' to 'mysqli', because obviously the mysql_* functions were removed in PHP7, but every DB function in CI begins with @, so it never told me!
Sadly for a modern option, Flarum is about the only option. Not a fan of its style personally, I much prefer the traditional type of forum structure used by XenForo/vBulletin/IPB/phpBB/SMF/etc
You have problems.
Could ob_start, echo and ob_get_clean or fopen('php://memory') resolved your RAM issue?
&gt; Your password can contain only letters/numbers/spaces. :'(
Yeah, kind of. I keep forgetting that I should explain every silly issue in the most simple terms, instead or assuming that most readers have at least basic experience. Well I am wrong. Here, for example, the guy have no idea of the implicit loop performed by implode. Looks like he's not alone in that.
Hmm I've checked a few projects and Local History is showing as empty. Odd. I'll have to investigate.
Yes, exactly. That's what I am talking about. I do not devise so-called "facts" out of nowhere. I assume my code being perfect *unless there is a* ***reason*** *to think otherwise.* So when I have a real **fact** to check - I am doing so. This is called "profiling". While you are calling facts just wild guesses out of nowhere.
As you are posting this here I assume you want a critique. A few points which will make your router IMO much better. 1. The code is quite hard to follow because you have taken the path of lowest possible line count which can be seen as a negative when looking for reviews/help/etc. This would be solved by writing it to the standards of PSR1/PSR2(http://www.php-fig.org/psr/). 2. You are also missing docblocks which really do help. Add them along with type hinting where possible. (https://www.phpdoc.org/docs/latest/references/phpdoc/basic-syntax.html) 3. Tests allow a dev to see examples of implementation but more importantly that your code does what it says it does given the appropriate input and even further what occurs if it does not receive the appropriate input. (https://phpunit.de/) 4. Add .idea to your .gitignore
Then you still have a lot to learn, but that will come in time \^.^
add .idea to your global git ignore (not your project one) ;) 
It depends on your definition of Modern. phpBB may have been around for a long time, but the current version is built on Symfony components and follows modern coding practices.
I've never thought of that. I'll have to check it out. Thanks!
Duh..Vim gundo. 
Wonder why more editors don't us [Vim-style undo trees](http://vim.wikia.com/wiki/Using_undo_branches) rather than just a straight stack. In general use it's identical to (and just as simple as) an undo/redo stack, but when necessary (like the case you mentioned) you can go to ANY point in the file's editing history.
Hehe, it's in there now 🙈
Good catch. Admittedly I added that on as an edit after the fact as a quick addition :)
Local history is a killer feature for me. One thing to keep in mind though is that local history will not be preserved when upgrading phpstorm major versions, so it might be good to keep old versions installed for a while.
If I'm understanding this correctly: leave the composer.json of your phpcpd library as it was in the original version. Then in your application's composer.json add your git repo to the "repositories" list then change the "require" section to point at your branch: { "repositories": [ { "type": "vcs", "url": "https://github.com/g4z/phpcpd" } ], "require": { "sebastianbergmann/phpcpd": "dev-ignore-violations-on-exit as 2.0.4.1" } } [Relevant composer guide](https://getcomposer.org/doc/02-libraries.md#publishing-to-a-vcs) I hope that helps. \[edit\] Apparently [you shouldn't rename your version of the package](https://getcomposer.org/doc/05-repositories.md#loading-a-package-from-a-vcs-repository) as I thought.
It's not pointless; you get to figure out how something works. You can say "hmm I wonder which is faster, a, b, or c?" Then test them and figure it out. If he kept going down the rabbit hole he could have learned a whole lot more. And no, can't say I've ever come across people arguing which concatenation is better.
[removed]
&gt; Yeah, kind of. I keep forgetting that I should explain every silly issue in the most simple terms, instead or assuming that most readers have at least basic experience. Well I am wrong. &gt; Here, for example, the guy have no idea of the implicit loop performed by implode. Looks like he's not alone in that. Sigh. Here's the implode() implementation: http://lxr.php.net/xref/PHP-7.0/ext/standard/string.c#1192 The loop itself isn't the bottleneck in the first example (for large strings). The bottleneck is that every time you issue a concatenation, the entire (ever growing) string is copied to a newly allocated Zend string. And guess what, implode() doesn't work this way. It instead goes through the array, finds out what the length of the resulting string would be, allocates *a single time* and copies the segments there at the correct offsets. - So the concatenation loop will do **10,000 heap allocations** and move and allocate approximately N \* 10,000 \* (10,000 + 1) / 2 = **N \* 50,005,000** bytes in memory in total, where N is the average length of the strings in that array. - Implode will do **one heap allocation** and move and allocate **N \* 10,000** bytes in memory in total. If we include the allocations and memory taken up by the array given to implode, then both approaches even out in terms of *number of allocations*, but implode() is still ridiculously more efficient in terms of the amount of memory allocated and moved, i.e. roughly **N \* 20,000 for the "array + implode" example** and **N \* 50,005,000 for the "concat in loop" example**. Of course for small strings, it's simpler and faster to concatenate than to deal with pushing to an array. At larger sizes, however, the sheer amount of memory moved, as the math above shows... changes things. And it shows you're in fact wrong about the implode example doing "the same job twice". --- It's not a sin not to know. But to not know, and pretend as if you do, give wrong advice and be arrogant as hell, that's something, /u/colshrapnel/ 
Indeed, variable interpolation is mostly syntactic sugar for concatenation.
Can you explain what the game is?
And you are wasting a lot of time. I just hope you don't get paid for checking the performance of single vs double quotes. Otherwise I feel sorry for your employer.
You're the second person that seriously lacks the ability to read! &gt; regardless of subject
Thank you, I didn't know about opcache_reset(). I'll give it a try. 
Are you not running backups? Now's the time to set them up.
Well, I work on that kind of projects myself but... when advertising a library I assume the main target is people that might want to use it in the future, not in the past. Technically the project that you mentioned is "a real world project" but the context I was using the term is a little bit more restrictive.
yeaahhh i gotta change that. 
With what generic type could you represent all objects? Do you mean wildcards?
If php storm was open at the time you can just ctl/cmd + z and it will 'undo' any file changes. This has also saved me from my own git reset stupidity.
that is one legendary bot
Notepad++ has this feature too, if you enable. It can also back them up to the internet.
Not only that but one of the core developers of phpBB, per https://www.phpbb.com/about/team/, is Nils Adermann. The same Nils Adermann that cowrote Composer: https://getcomposer.org/ (look at the bottom of the page). And the first secretary of PHP-FIG - Michael Cullum (per http://www.php-fig.org/members/) - is, you guessed it, a member of the phpBB management team. phpBB knows what it's about and their team members would be notable PHP developers even if it weren't for their involvement with phpBB.
Very interesting article!
Untested, straight to master, with no message. Ummm...
Yeah, he's not here anymore.
A complete guide on Building RESTful APIs with Lumen and OAuth2 https://medium.com/omarelgabrys-blog/building-restful-apis-with-lumen-and-oauth2-8ba279c6a31
TIL. Nice.
Admitting is the first step.
Yup, I got to meet and chat with Michael for a bit at PHPNW last year. He was very passionate about the project, and said that one of it's biggest drawbacks is getting past the reputation it earned back in the mid 2000's even though it's been mostly re-written by now. He also did a talk on the topic near the end of the conf: https://www.youtube.com/watch?v=J4F16PLFUoc
Do you know about Laravel Passport? https://laravel.com/docs/5.3/passport
I just updated the README.
Thank god, someone who isn't complaining straight ahead... Yes, indeed, I need to secure the passwords. However, it's a platform for my very own, personal use, so there is no need to hash it (so far). Also, I will update it in the future so it allows multiple users, but not focusing on that now as I'm the only one using it. Thanks for your well-estructured feedback :D
&gt; My first concern is that the password is stored as plain text with no hashing. And in $_SESSION, too, no less.
This is my very first project in PHP. I came here looking for opinion and also help. If you only complain about everything that is wrong instead of contributing like everybody else is doing, you could simply say "fuck you" and leave, same effect.
Then stick with "Hello world". Even when you know what you're doing, you don't roll your own crypto. Access controls aren't far behind that. 
This is the way to go if you wanna learn, doing exactly the opposite as "sticking with Hello World", which will take you nowhere. God, so much negativity, there is no need for that. Just help me improve it, if not, leave.
You're wrong. You have to crawl before you can walk, and you can't even crawl yet. Doing what you're doing is how you're going to hardwire yourself with a pile of shitty habits that you'll have to force yourself to break later. 
some feedback: - Did you know? $_REQUEST = $_GET + $_POST - Your strtolower could be applied to path before exploding it. But maybe you do not want to lowercase variable path-parts and/or their values... ("/hello/:Username" with "/hello/Hans" world become $username="hans" ?) - your usage of for() can sometimes be replaced by foreach() - unnecessary complex: if (empty($routePattern[0])) unset($routePattern[0]); // $pattern = ltrim($pattern,"/"); - I'd rename dynParams to urlparameters (or inputvalues) and params to urlparts. The naming is misleading and confusing. ;) I hope to see a second version. :)
&gt; You have to crawl before you can walk, and you can't even crawl yet. Oh look, a big bad keyboard warrior. Look it's easy to say something is crap without offering any solutions. to fix the issue. Rather than point out that he has "shitty habits" why don't you do something constructive like point him toward a tutorial that can help him code a secure login application. Maybe [PHP the Right Way](http://www.phptherightway.com/) would be a good link to point him to. We get it, you're a better programmer than him. Probably me too. That's fine, but it serves no one commenting in this manner. Do you think that all coaches do is tell people what "shitty habits" people have without offering any points to build on?
Thanks! I wrote it :D
Thank you one more time, specially for helping me out on GitHub reporting the issue. I will look into it really soon.
Oh, I guess we'd better just ignore all projects that are in Beta and never use them, then. Hey, anybody remember that thing called "Composer"? Didn't we just get version 1? How's that working out? Seems pretty new, I'm thinking of giving it a whirl.
Why don't you refactor that crap? 
&gt; That is also a good reason for using an IDE and not a text editor for programming. That's not really a sensible comparison given that an IDE, among many other things, *includes* a text editor but it also includes a ton of other stuff --- in this case local versioning. However, people --- like myself --- who prefer a specific text editor usually build our own development environment around it, so I don't just use VIM for PHP, I use VIM + a ton of plugins + Git + Bash + Ruby + Go + PHP (e.g. for linting). And for local versioning you could possibly use something like: http://www.vim.org/scripts/script.php?script_id=2442 (based on a quick google search; there may be better solutions available). Edit: I'm genuinely confused about the downvotes... I don't feel like I said anything even remotely controversial nor were I being rude or disrespectful... But of course, with no comments to accompany the downvotes, it's impossible to know. Is it just because I didn't just chime in with praise for PhpStorm? I mean, I also didn't say anything negative about PhpStorm or IDEs in general...
Awesome! Thank you. I'm planning on writing a deploy bot, your package looks perfect for this. 
Nope. I'm looking at a project that has no version control(A Symfony app I just created to test something) and it still has local history. 
WordPress?
Congrats guys :) You are the first in history who ship PHP app to their clients with the following comment (instead of unzipping one file): - please download php - install it then enable that stupid IIS or install nginx or apache or learn to run php built-in web server - place php files here and there and edit little bit php.ini - start services and navigate to localhost:8080 
Is joke?
I don't see the OP's responses like that, but I can understand your reaction if you view it that way.
it is not fully portable because you must install MSVC runtime on client machine and that's not my case 
Have not browsed WordPress internals in last years?
Symfony2
[removed]
off the arguments? :)
Yep. As they say, you can play a game of chess against a pigeon, but it will still knock over a bunch of pieces and shit all over the table while strutting around acting like it won the game. ;)
/u/smitty I'm a working as a web developer. If you need some help about coding or improving UI, my team and me can help you about them. Just let me know :)
I'm a bit late to the party, but I've recently launched [Assertible](https://assertible) - a continuous API testing solution. The goal with Assertible is to continuously test your web services -- for example, every time you push to a PR or deploy a new version of your app. Assertible tests will run then, and let you know of any failures. Check it out and let me know what you that; I'm happy to help get you set up or just chat about how it works!
Hehe, after actually reading that portion of the docs (which are basic assumptions I have for any open project) I think it's quite obvious what they mean: if you don't / can't get your hands dirty, don't use in production because we aren't at a place to support you. Also see their contribution guidelines at http://flarum.org/docs/contributing/. Basically, if you use this, plan on being a decent human being and helping out? lol... I guess if you don't have time for that in your "production environment" (completely legit for cases where a client isn't paying for that) the. Do NOT risk use of it. Cool. 
Thanks if the time comes where I need some help I'll let you know
Out of curiosity, why did you decide to go with: $slackbot = new SlackBot(); $slackbot-&gt;initialize(&lt;my_slack_bot_token&gt;); instead of: $slackbot = new SlackBot(&lt;my_slack_bot_token&gt;); The extra method call seems like it could be avoided by simply having the constructor accept the token required to initialize the class properly.
Nope, what's interesting in it?
Hashicorp's Vault project is a good start: https://www.vaultproject.io/
 ^ this is literally the comment I scanned the comments for. git reset doesn't delete those commits, it just unlinks them from the current branch. Further reading for anyone else who is perusing these comments: http://gitready.com/advanced/2009/01/17/restoring-lost-commits.html 
They forgot an even worse mistake: Violating the [cryptographic doom principle](https://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/). 1. Understand [cryptography terminology](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded); clearly specified requirements, use-cases, and thread models will prevent you from making a huge mistake (e.g. encrypting passwords instead of hashing them, like Adobe did). 2. Don't roll your own; [use a library](https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide). 3. If you insist on rolling your own, at the very least [learn the difference between encryption and authentication](https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly). 4. If the attacker gets root on your webserver, it's game over, so don't obsess too much about how you store keys as long as: 1. They're not remotely accessible. In a file outside the webroot with strict ACLs is fine. In the same database that stores ciphertext is not fine. 2. They're not hard-coded (i.e. won't leak if you have a publicly accessible `.git` directory). 
&gt; huge files of spaghetti code tamed into various very well documented classes [HAHAHAHAHAHAHAHAHAHAHAHAHAHA](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L779)
Do you consider it production ready? I ask because you don't have any releases.
I will tag a pre-release today. I would love to see a Symfony2 bundle (but will probably need a PR for that) and I want to improve the documentation / getting started guide.
Well, that's what I am pointing to: It modifies `$str .=` and `$str[$i] =` in place, if the refcount is 1. And the 4 KB boundary means that there's each 4 KB a new copy _at most_. (usually much more rarely.)
Thank you, Taylor :)
Because our production server is only accessible via FTP(dont ask me why...), we use [phploy](https://github.com/banago/PHPloy) to upload changes in our repository.
You'll probably have to edit your own font https://fontforge.github.io/
Going to fun pair programming with you.
No wonder there are so many bugs and security leaks in wordpress, not even a developer can read this. Might as well read opcodes -.-
Great! maybe a middle dot it's too minimalist for me, but a small dollar symbol with limits inside the minimum lowercase box could be very interesting. 
They'd been working on it for 3 days, I hope to god they were committing along the way...
Yes, I agree! I used middle dot because I did not found any muted dollar to copy/paste
Have you tried `nikic/FastRoute` or `timetoogo/rapid-route` ?
I thought that was also part of the rainbow-table definition, just that that's a rainbow-table that's generated on the fly rather than being statically available.
While I welcome the efforts and changes, Wordpress won't be able to get rid of all its legacy before quite some time. It's good to know they are willing to work on it rather than just give up on it and bet on their JavaScript/nodejs version. Also note that the worst in Wordpress is not necessarily the code, but the absence of security at its core (check https://paragonie.com/blog/2016/08/on-insecurity-popular-open-source-php-cms-platforms; to be taken with a grain of salt as they have their own CMS to sell, but they are a reliable source still).
Wait, I got this one covered: https://paragonie.com/blog/2016/10/guide-automatic-security-updates-for-php-developers#reproducible-builds
I hope you've given yourself a chance to get used to it first. It's great we can modify our IDE, but you'll have to tweak that constantly wherever you go. But one thing that's even more configurable and is always with you: your brain.
&gt; Oops, maybe I have no brain: I did not understand what you mean. Could you help me? First couple of months when I started using PHP, everything about its syntax bothered me. Then it stopped bothering me. That's my brain at work ;)
Shit, I have no brain: I started PHP ten years ago and asked this question to myself today. Sorry about that, can we swap our brains?
Eclipse does have PHP dev tools ( http://www.eclipse.org/pdt/ ) Other good options are PHPStorm, Netbeans and Sublime Text
It doesnt matter. It is only not pretty. The request will be the same if you do use pretty urls :) 
Rainbow tables are only special in it that they exploit the space/time trade-off compared to more simple "lookup tables" (they consume more computing power but a lot less space). Rainbow tables or lookup tables are defeated by salting, but indeed salting also defeats the attackers ability to test multiple candidate passwords with price of one, and they defeat the ability to see if multiple accounts share a password, and even they defeat timing attacks from password verification (as long as the salts are not leaked separately from the hashes and they are unguassable to the attacker). The last point about defeating timing attacks is probably just a coincidence, at least I'm not aware such outcome was never a planned feature of salting. Salting achieves quite a bit ;) (Sorry for the off-topic.)
Hmm, ok but why 32-bit?
I use PHPStorm from jetbrains (intellaJ) I would also recommend looking at PHP 7 as it pulls a lot from java, or if it's an option look at Hacklang from Facebook. If you're looking to learn a framework I'd suggest Symfony or Laravel https://knpuniversity.com https://laracasts.com 
It'd only be useful insofar as providing a type declaration for it.
Your problem isn't that you're missing an `object` typehint; it's that you've made a mistake in your design by necessitating the acceptance of any and all objects through this method. This is the kind of problem you won't get far discussing in foo/bar abstractions. Real use cases are pretty critical in understanding why this feature is totally unnecessary.
Here is another one(monaco), monospaced the variations of I, l, i, are all distinct. here is $ replaced: http://i.imgur.com/7zpJoYU.png dl: https://a.uguu.se/4pWUFGfaawOT_monacox.ttf.tar.gz and muted with dot: http://i.imgur.com/iaNt41e.png dl: https://a.uguu.se/R3mULlLL3rqR_monacomuted.ttf.tar.gz **monaco is subject to copyright and I claim no ownership over this.** &gt; (c) 1990-97 Apple Computer Inc. (c) 1990-97 Type Solutions Inc. (c) 1990-97 The Font Bureau Inc. I also made a few variations like having the dollar at top left instead, but due to anti-aliasing, anything smaller than normal was a bit blurry or just plain bad. I have to redraw the glyph and I am not going to. This gives me another idea, if anyone is going to work for it, do it like [fira code](https://github.com/tonsky/FiraCode) and make 2 symbols become another glyph. This can be extended to other languages by making "var abc" into "$abc" where $ is the variable symbol. But sublime doesn't support this, so its useless for me \^_^ anyways, font names are "monacox" and "monacosmall", in this order. dl links are only valid for ~24 hrs. I actually like the first version, its distinct enough I wouldn't confuse it when I am using $ in a normal place. 
you might also consider using the header() function to alter the http headers.
Uses cases in question: - serializers - generic factories - hydrators - data-mappers - property accessors - reflectors You can have another example here: https://github.com/nelmio/alice/blob/b6985b4d9cd8a29fb4b8b52f3c50d3a12f4616b7/src/Definition/Object/SimpleObject.php#L35. In Alice objects should have an ID, but those objects in question are a user/domain objects, and this ID is for alice only, so a viable solution is to have a simple wrapper like that. As it has been said elsewhere, there is little valid use cases in a domain, but in a library or some parts of the infrastructure it makes sense.
Let me also recommend PHPStorm if PHP is something you'll definitely be working in consistently. I held off of using a non-free IDE for years. Now I kick myself every time I think of how much easier my life would have been if I'd gotten it earlier.
PHPStorm is the best thing since sliced bread. It's made by the same people that make IntelliJ.
I also want to stress that PHPStorm currently is WAY ahead of any competition. If you want a serious IDE there is almost no way around it.
Kindergarten fears. 
&gt; Correct. That's what compiled languages like Java and C# are good for. So let's say I have 500k lines of PHP code, and I need to make this available on a desktop machine, for a specific workflow. Your answer would be one of: 1. Screw you, keep it on the server, -or- 2. Give me 2 years and a small team, I'll rewrite it in Java. You're fired. By the way, of all possible languages for GUI, *Java*, honestly? That wouldn't be my first choice by far, unless it's an Android app. &gt; If your organization is tied down to a specific language, then that's a problem with the organization and it will not be sustainable for much longer as a business. Can you substantiate this with anything other than bold statements? As I said, there's only one factor to judge an outcome by: does it fulfill its purpose well enough? If yes, then the goal was achieved. Not every app is written for casual users at home. Some are written to be used by trained specialists in an enterprise, and they don't require nearly the level of polish and hand-holding you'd need for a "general" end-user. They, and their bosses only care that the apps works properly when used as instructed. Nothing else. &gt; Writing an application for a client in this way is bad, but I'll touch on that in a moment. You're making a big assumption: that the application is being written from scratch, and the company has a dedicated team for this one-off desktop app. Surely if that's the case, you'll pick the best language for the project, in *general terms*. Those are called "greenfield projects". And also they're very rare in a corporate setting. Surely you'd know about this, if you knew what you're talking about. &gt; PHP is for writing Web Applications. We've established that already, but let's explore what that means as an end-user: &gt; 1. The user opens their browser &gt; 2. The user types in the address on which the application lives &gt; 3. The user sees their application Incorrect, you didn't even bother to check what this project does, did you? You open a single file, and it launches the server, and browser at the correct app URL automatically. So you wrote a lot of bullshit above for nothing.
Just because my clients are runing both 32/64 bit Windows and 32-bit PHP version runs on both :) It is enough for testing application mockup.
security through obscurity does not speak against the practice of hiding stuff, it only tries to discourage you from using that as your security-layer. Having a more obscure layout will make it more difficult to breach your system, but it will not make it more secure. "perfect" code should be secure, even if you open source all of your code. The only thing obscuring your own code does is to make it more difficult for attackers to find the mistakes you made. If you don't make any, it doesn't matter at all. 
You didn't touch shit. You're dead set on always having PHP run on a server, because it's most often used on a server. This is not a reasonable thought process, especially if you don't know OP's circumstances, instead you're just being obtuse so you can shout at somebody. That's your problem. For the record, *of course* that in the "general case" I'd write a GUI app in C#/Swift and so on. But one never writes software for a "general case". There are always specific circumstances that can make another solution a better choice. And you'd know that with some more real-world experience.
Oh my! :) I won't torture you so many hours, if you are so simple and can't understand it from description, this solution is only for testing web application mockup without installing anything on client's computer or servers or make it publicly available OR to run command line application without installing anything on client's computer. Imagine that there are companies which wants PHP and only PHP command line application to analyze or process some data. Dude :)
If you happen to be using vim you can use `conceal` to achieve this. Personally I only have `$` visible on variables for the current line I'm on. Update the `php.vim` syntax file to have syn match phpVarSelector "\$" contained display conceal with `conceallevel=2` it will only show the `$` for the current line Pretty much on your own with other editors though, probably have to have a custom font as suggested
And I’ll have you know I graduated top of my class in the Navy Seals, and I’ve been involved in numerous secret raids on Al-Quaeda, and I have over 300 confirmed kills.
So, check your plugins before going live? Hardly a Wordpress-specific problem, but a broader question of webmaster competence. 
Why would you store it twice? That just doubles the risk of it getting compromised. 
One of the few bandwagons I not only happily jump on, but also replace the driver put the pedal to the metal and crank up the megaphone on the roof. If I had to choose between slicing my own bread or using eclipse for php, I'd spent some money on an automatic bread slicer. 
Ok, I'mma be real with you..... That was fucking funny.
In my experience, loops can be problematic because of variable scope oddities. Where possible, lately I try to use array_map, array_filter, array_sum, and array_reduce w/an anonymous function if I have to work with an array. I wouldn't *yet* go as far as saying all loops are bad.
1. Your link is to a yet-to-be-refactored collection of helper functions, not an already refactored class. 2. Funny you linked to the function's body and not its 22+ lines of comments detailing its purpose, usage, params, returned value and security-related advice. Given the function is about 60 lines long, that's about a comment every 3 lines of code on average... not bad eh? I guess you proved my point :)
I guess the following is a possible reason: $names = ['a', 'b', 'c', 'd']; $name = 'nessuno'; foreach($names as $name) { echo $name; } echo $name; assert($name === 'nessuno'); Outputs: &gt; abcdd &gt; &gt; Warning: assert(): assert($name === 'nessuno') failed in &lt;path&gt; Edit: formatting 
i am sorry i'm kinda confused but doesn't reddit use jquery like i mentioned? do they do something to prevent csrf?
The isolated scope within the `each` can be handy - you don't have to worry about polluting variable scope or stuff left over from the last iteration. Collections also come with a bunch of useful functionality that your simple example doesn't need but can be useful if you're doing something more complex. Nothing wrong with loops, though. In your example, both are effectively loops.
The font is controlled by the IDE (editor) and most allow you to change it. 
Nobody is saying it's the "next silver bullet"... who said that? Where? What does that even mean? Adam Wathan gives a presentation and has a book on collections in which he expresses the opinion that he hates loops and conditionals. Great... fine. Also the original example in this post is not at all representative of the code Adam re-factors in his presentation. Watch the video from Laracon. He re-factors a huge loop with conditionals into collections to show you how to use them. It makes for a really good demonstration of the things you can do with them. It's not like people are crawling through Laravel replacing every instance of a loop with collections.
It is important for things like RESTful resource URLs–e.g. *http://unviersity.edu/library/authors/tolstoi_lev_nikolaevich*. That URI for Tolstoy should live for a long time. Redirecting each *tolstoi_lev_nikolaevich.php* to *tolstoi_lev_nikolaevich.py* when you change the backend from PHP to Python would be a drag. ["Cool URIs Don't Change"](https://www.w3.org/Provider/Style/URI.html) is Tim Berners-Lee's take on it. Not everyone looks at Web addresses as resources, so YMMV. 
You can use csrf tokens. The jquery sends a request to your api. And the api will then delete the record if the user is authorized. 
&gt; Nobody is saying it's the "next silver bullet"... who said that? Where? What does that even mean? Well, here you go: &gt; some members of the Laravel community are preaching the fact that conditional statements and loops are bad. If someone wants to *limit* certain unreliable or complicated uses of loops and conditionals, that's one thing. If someone want to call them "bad" and claim they should be completely replaced by collection functions and the like, this is "silver bullet" mentality. &gt; It's not like people are crawling through Laravel replacing every instance of a loop with collections. Well, it's apparently the kind of impression some people in the community have. And I've seen this in the JavaScript community as well. Some people "get it" and use multiple techniques, each at its best strengths, other people only see in black and white and demonize everything that came before the latest shiny. So I don't think bringing a bit of balance is uncalled for.
&gt; Going "monadic" all over your code won't improve your code, it's just another cargo cult. Yeah, there are times when converting an array to a Collection is super useful and lets you much more easily perform complex operations on it. But whether you really need to do that to *all* your arrays is a matter of opinion. Some people just like the consistency of using Collections for everything. But there's absolutely nothing wrong with using a foreach loop and standard arrays if you prefer (and it's likely going to be faster since there is some overhead in using a Collection). Personally, even with a Collection, I prefer using a foreach loop because I prefer the simpler syntax. But I'll use each() if I'm chaining together multiple functions that I'm applying to the Collection.
They have the wrong impression.
The `each` example here is really not a good example to demonstrate the benefit of taking a more functional approach to array transformations. My only point with any of the functional array stuff is that 99.99999% of the stuff you want to do with a foreach loop already exists as a function with a name somewhere. Every time you use a loop and a `$result` variable instead of `array_map`, you are missing an opportunity to use a higher level abstraction and creating duplication in your code. If you would write this: $newString = str_replace(' ', '_', $oldString); ...instead of this: $newString = ''; for ($i = 0; $i &lt; strlen($oldString); $i++) { if ($oldString[$i] == ' ') { $newString .= '_'; } else { $newString .= $oldString[$i]; } } ...then you should write this: $newArray = array_filter($oldArray, function ($item) { return $item &gt; 0; }); ...instead of this: $newArray = []; foreach ($oldArray as $item) { if ($item &gt; 0) { $newArray[] = $item; } }
I'll start. $names = array_column($registrants, 'name'); While this is definitely cleaner and more concise, to me it is much harder to just understand at a glance what is happening than the foreach() loop. It could be that array_column is a fairly new function in PHP and I don't have a lot of experience with it, but the syntax of the foreach() loop is pretty universally understandable, even to a programmer unfamiliar with PHP. 
I think a better thing to worry about is conditionals inside nested loops. They can easily bog down performance. Also see: https://www.reddit.com/r/programming/comments/59cq8r/applying_the_linus_tarvolds_good_taste_coding/
Like event sourcing. :) _I'll be here all week_ 
/u/iltar, /u/Juris_LV: would you please give a try to this build: https://github.com/kalessil/phpinspectionsea/blob/master/PhpInspectionsEA.jar In the inspections' settings uncheck "Follow PHPUnit standards" to get original behavior back.
&gt; Again, you're inferring a whole load from my comment. Almost like you're deluding yourself there, amiright? You don't really know what delusion is, do you? Or maybe you do, it's pretty clear you have first-hand experience. I won't bore you with the details about the meaning - that's what dictionaries are for - but your attempt to try and "turn the tables" on me again with your grade-school fallacies is just hilarious. That aside, you and I weren't "inferring" anything. You were *very clearly* defending bad code by saying "OMG, DA COMMENTS ARE GREAT" (paraphrasing), and I *very clearly* stated - again, not inferred - that code like that should die in a barn fire and shouldn't be defended (more paraphrasing). I think it's great that you take Wordpress so seriously that you would consider contributing to the base, but that's not something anybody new to Open Source projects should be attempting to do. Automattic has a track record of squashing very real attempts at modernizing that project, so new and eager devs would very well find themselves walking into a minefield of both terrible code, and political toxicity. The Wordpress Core is almost exclusively the reason why non PHP devs think PHP sucks at everything forever. Call me bitter, but I don't have high hopes for that CMS.
Sure buddy.
Care to write up your process? Would be helpful
If you imagine the array of registrants set into a table then `array_column` is pretty explicit about what it's doing. In that way I find it more readable than the more generic loop because the loop doesn't tell me what's going on as explicitly.