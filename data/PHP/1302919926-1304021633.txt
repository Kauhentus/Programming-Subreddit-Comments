I'm in this phase right now. I would just change that to: "Can see where he's weak but not so clearly how to fix his problem and is too pressed for time/deadlines to go back and do it 'right'".
See [EBNF](http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form). A lot of computing manuals and help texts borrow from this convention. 
Thanks mate, will read it through.
I hadn't heard of Behat. It looks pretty good.
 self::$regex = '#' .'( &lt;!-- TOC([1-6])) --&gt;' // &lt;!-- TOCN --&gt;, $1 is &lt;!-- TOCN -- $2 is N .'( [^&lt;&gt;]+ )' // content $3, may not be empty or contain more tags .'( &lt;!-- /TOC\\2 --&gt; )' // matching &lt;!-- /TOCN --&gt; $4 .'|' // OR: looser match below .'( &lt;!-- TOC([1-6]) ) --&gt;' // idem, $5, $6 .'( .*? (?: \\n .*? )? )' // content $7, anything on 2 lines max .'( &lt;!-- /TOC\\6 --&gt; )' // idem, $8 .'#ix'; Try this. Have not tested it though.
Ouch - I'll reply, even though i'm fearful of the karma bullets I've already taken. Framework programmers generally suck. There are a few really great ones, but there are way to many that don't understand core php, and that's a problem for our language right now. Frameworks also induce fractionalization of the PHP community, diluting what could otherwise be a very powerful community.
Not that it's a helpful reply, but using heading tags for styling is not the correct thing to do with heading tags.
The default === PHP behavior without a php.ini. And in this case, that's "" which means it's ignored, and GPC lives within $_REQUEST (as per the default variables_order).
That's probably more helpful than the expected reply and OP should really heed this warning.
1984 by George Orwell. But then, I have never read a book on data access patterns.
Why would I make another account? UMADSON.
Basic reading comprehension is very difficult for you, isn't it? I'm not talking about you when I mention someone making accounts. Notice that it says "KravenC and," suggesting that that's a different person. It is, however, hilarious that you've now outed yourself as looking for fights.
You should read, from the PHP Manual, the section titled [How to read a function definition (prototype)](http://php.net/manual/en/about.prototypes.php)
&gt; Basic reading comprehension is very difficult for you, isn't it? Not really worth reading what you post. I like that I make an impression. &gt; It is, however, hilarious that you've now outed yourself as looking for fights. Yes, hilarious is what springs to mind when you say "looking for a fight" on the internet. UMADSON.
Thanks mate. I'm following a Web Development: PHP &amp; SQL book at the moment, but I guess they must assume I have learnt another language or know about prototypes. PHP is actually my first language so this will be handy, thanks!
As usual, you are unable to admit your errors.
&gt; As usual, you are unable to admit your errors. What qualifies as admitting it? You have some strange thoughts on human interaction. It's like you celebrate other people's mistakes as an achievement when errors are something people make all the time. I guess you need a letter or something. You make errors all the time too, but I guess pointing out others' is where you get your self esteem. No wait, it's how you get that attention you crave. Maybe a combination. That's a rough life.
The first answer to the question on http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags applies to your question as well. Users _will_ break your HTML in strange and horrible ways, so using a regex is not really going to be reliable.
Go away please.
People will tell you to use prepared statements, but what you are doing is fine. Other things you can/should do that also help protect you: * sanity check known constraints, e.g. pageid probably needs to be an int &gt; 0 * have a list of known good values, e.g. if sorting using GET, sort direction must be either DESC or ASC * make sure the page fails gracefully if the query fails
You should read up on PDO, its perfectly crafted for handling issues such as injections with prepared/binded statements. [PDO Intorduction](http://www.phpro.org/tutorials/Introduction-to-PHP-PDO.html) [PDO Prepared Statements](http://www.phpro.org/tutorials/Introduction-to-PHP-PDO.html#10)
Yes, it'll be enough. As an extra precaution, I tend to "untaint" a variable if at all possible. This means, I make sure it fits the data type that I'm searching for. Ex: the field you are going to search is an integer, either convert it to an integer first, or make sure it's an integer before running the query. You do need to escape your value. If you don't a hacker has 1 character less to type in when he is trying to grab your data.
You could still get into trouble if you use weird characters sets on client or server. [Example](http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string). If you use utf-8 (and normally you should), this isn't an issue.
Remember that PHP may have a limited numeric type, so if you're going to have very large values a &gt; 0 check may fail due to signed interpretation of a larger number.
Use PDO and it will be easier. I find passing arguments to prepared statements to be much easier.
Another for using prepared statements and PDO, or at least MySQLi. IMO there is no reason to be using the old mysql_* extension at this point. PDO is the standard for PHP5+. Also, if it's an integer just type cast it as an integer.
remember that MRES should only be used on a variable RIGHT BEFORE the mysql query. Don't use MRES on all of your GET/POST variables at the top of your script. You don't want to be modifiyng or checking the values / sanitation on escaped variables.
&gt; but what you are doing is fine. No, no it is not. Relying on functions and interacting with libraries in this way is not only a serious contributor to security issues in so many PHP scripts but also very inefficient anymore. MySQL server query caching is just one of the reasons why prepared statements offer performance benefits. Why teach anyone to work with queries in such a dangerous fashion? Because it "works" and the consequences will only be obvious later on once you slip up and forget to escape something? Advice like this does not help web security one bit.
What does that even mean? There is no AWAY. If you can't deal with a little red envelope, you probably don't want to login to reddit. Grow a spine or some balls.
Like the name implies, mysql_real_escape_string only handles string expressions. That means that anything that is not wrapped in quotes will not be protected against injection attacks using this method. If you're really concerned about your security, then instead of protecting against SQL injections, you should use something which is actually immune against it... namely prepared statements. Prepared statements works by compiling the SQL statement, then using bind variables to inject the data. Because the SQL statement has been compiled, there's no SQL to break out of. No SQL = No SQL injections. 
No, it is not enough. mysql\_real\_escape\_string() relies on the character set of the current MySQL connection to escape dangerous characters. In addition, it only detects the character set specified using the mysql\_set\_charset() function, and not the character set specified using the commonly used `SET NAMES` or `SET CHARACTER SET` query. (Things may have changed since I last checked, but this is what I remember. Also read [this](http://ilia.ws/archives/103-mysql_real_escape_string-versus-Prepared-Statements.html).) So if there's ever a mismatch between the character set that mysql\_real\_escape\_string() thinks you're using and the character set that you're actually using, your string will not be escaped properly and [Bobby Tables](http://xkcd.com/327/) will pwn your site. Remember, there are lots of obscure character sets out there. Also, validation != sanitization. For example, if you know that $page should only contain alphanumeric characters, you should pass it through ctype\_alnum() to make sure it doesn't contain illegal characters. This should provide an additional line of defense. But you should always perform both validation (only accepting valid data) and sanitization (escaping, or using prepared statements). Edit: formatting
mysql_ doesn't use MySQL query caching? Can you find the source for this since it will help me make arguments to get people to move off the former without just having to resort to rhetoric.
Consider this: you are setting $page to a value that is not "page"; it is some version of page encoded into a format required for some downstream process (and SQL query). That alone should start giving you an uneasy feeling that something is wrong. This gives me nightmare flashes of work many years ago on oscommerce. *shudder* First answer: use PDO, as everyone else here is saying. Second thing to add is *if* you need to do this kind of encoding, do it right up close to the point at which it is used, not at the point at which it is first fetched. This is a general rule that is worth keeping in mind through your development. Lastly, there are two different encoding methods that you should choose between, depending on whether the MySQL column is a TEXT type or a BINARY TEXT type. Been bitten by that myself in the past. But again, it points to a different method, e.g. PDO.
Please stop wasting my time soon.
I am not sure what exactly you're asking when you say this: &gt;In your controller you receive an $id as a param and you want to create a person object ($person = new person($id);) Is it better to have inside the person __construct a call to the DB that populates name, address etc? Your MVC framework should handle this without the need for you to actual insert each individual values or parsing the id. (the id should be auto-incremental) However, if you want to create a person with specific id of 2222. In controller you set up the values: $data['person_id'] = 2222; $data['address'] = "reddit ave."; $data['phone']=888; If you are for example getting values from the form, then all you have to do is save the form data. Again depending of framework these are handled differently but again generally are the same Now I don't know which framework you are using, but again, parsing the values as an array to new/save/construct model will automatically save these values. e.g: $controller-&gt;Person-&gt;save ($data); The difference between frameworks will be how array is constructed (i.e. $data['Person']['person_id'] ) If you, however want to manipulate this data in any way (e.g. don't save persons that live in certain areas) . then do it in model by overwriting the save model or using in before save methods or/and similar. Again depending on framework. EDIT: Just realized that you are maybe not using a framework but doing your own MVC exercise. In that case, i woudl 'simulate' the frameworks by having construct that takes array as parameters and saves (does DB insertions) those that exist in array. If id exist in an array, then does an update But again, depending what you do and which 'design' approach you take. Do you want your person object to save all the data? then yes, do in construct (i,e, $person = new Person($data); //you __construct does the db saves, etc/. Do you want your person object just to return a skeleton? Then do it in controller and call update function.(eg. $person = new Person($id); //your construct sets the id ; $person-&gt;updateAddress('reddit ave.'); //your setters 
Thanks, everyone. I'll be checking up on PDO. Looks like I'll have to recode most of what I've done...but pain is gain, I guess. 
Yeah it does. Edit: Don't know why I got downvoted.. mysql_ *does* use MySQL query caching.. From a machine that only uses mysql\_ via PHP: * Qcache_hits 5,156.81 M The number of cache hits. * Qcache_not_cached 361 M The number of non-cached queries (not cachable, or not cached due to the query_cache_type setting). 
Well ...the model should not be tightly coupled to a database. It shouldn't even matter to the model, if data-source is database, json file or external web service. Thus, the class which does the actual DB-related work should be a separated layer. And as for you model "Person", imho . it shouldn't be the primary model you use. I would go with something like HR( human resources ), and have methods like add_employee , get_employee, etc. Which then would return you an object hat is instance of Person. P.S. In controller you should just "change the sate" of your Models, and link/bind them to the View. An then let the view handle the presentation logic ( choose the templates , make the pagination , ect. )
tl;dr - simpler __construct() methods should be favored and heavy lifting should be put into static factory methods. Consider how you would unit test your model. If you have DB calls in the constuctor, then you need to mock out an entire database in order to write a unit test. However, if you have a simple constructor (maybe taking an optional array of data to populate) then you can unit test much easier. So if you have a simple constructor, how do you get the data from the DB to your model? Either with a factory method public static function dbFetchById($id) { ... } or having a separate class that interfaces with your database and instantiates the model for you. "Well, that's fine but even though I know I should I don't really write unit tests, so how does that help me?" a strawman asks. The thing about unit tests is that the less coupled your design, the easier they are to write. So they inform good OO design. In this case, the design that I came up with makes it easy to change the way your model is stored. What happens when down the road your models start getting persisted in the session in addition to the db? Or on a web service? That __construct() would make it much harder to reuse your code without significant changes.
You should always be thinking of more secure methods, as you should never trust user input. I'd go with PDO (like the majority of other's have said) and also typecast your queries.
If it's encapsulated in quotes as per his example, then it is impossible to "inject C++ style comments".
I would advise having a "dumb" constructor function, which takes the attributes for the person as parameters. The constructor then simply sets the internal variables to what was passed into the parameters of the function. Then, you have a static function called "get_person_by_id" or something similar, and it takes the ID of the person as its parameter. This function then queries the database and constructs a new Person object, and returns it to you.
&gt; Please stop wasting my time soon. I'm not the one wasting your time. It's your time.
Still?
Still is. It's almost like you like it? Smile for me.
I agree, prepared statements are the way to go for sure. Also, read this, http://www.parseerror.com/sql/select*isevil.html
The MySQL server caches queries, and when you send it queries that is has to parse each time, like: SELECT * FROM apps WHERE id=238472981 SELECT * FROM apps WHERE id=238718711 With prepared statements you cache one query... SELECT * FROM apps WHERE id=? ...leading to increased MySQL query performance. Prepared statements also make batch query handling so much faster. Also, instead of seeing ' . mysql_real_escape_string($derp) . ' a dozen times on a single line, we have something much more maintainable and organized.
This is done by the MySQL server. Query caching is much more efficient with prepared statements because instead of just caching common (compiled) queries, it's caching easily-parsable generic queries. More cache hits with many website features.
True, I must have misunderstood the intention of the statement in your original post. My response was to this: lhnz &gt; mysql_ doesn't use MySQL query caching?
have a separate method eg ` $person = new Person(); $person-&gt;load($id); ` where load() calls fetchRow() and sets the class members
I do not like it. Please stop pretending otherwise.
upvoted for good work ethics
The purpose of a constructor is to put the object in a default state or a state defined by the arguments passed to the constructor. Doing anything beyond that is arguably bad. So, if setting that state involves database calls then you can do it in the constructor; there's no rule against it. However if you see an emerging pattern and think that you might reuse that code, then you would obviously benefit from pushing that code to another method.
I doubt caching the actual query text is significant enough to really bother with unless you're doing a large number of inserts or updates. 
I don't see that borne out, so I have no reason to believe it. You almost always want more. Wasting time, bad behavior, whatever you want to call it. Somehow it's exciting for you.
I do not want more. What is your goal here?
It's not something you have to "bother with" in any case. The db engine handles it automatically. Prepared statements implicitly invoke it. Whereas converting all your arguments to strings, escaping them, and sending a full textual query do not invoke statement caching. Only result caching. When you send a prepared statement to the server, it's not the same as sending a text query to the server. Most db engines represent, optimize, handle and execute them both almost completely differently. 
You seem to enjoy it enough to continue. So I think you do. My goal is the same as yours, to enjoy myself. It's been good so far!
Just load the html of the comment form into a DIV in your comments_show.php page via an AJAX request with jQuery. The div should be hidden until after the form has been loaded, at which point you can expand it with your jQuery plugin using an AJAX callback. Just a tip - don't embed HTML in your PHP pages. You should instead make templates. This has the added benefit of making what you want to accomplish easier. Check out Smarty, Twig, and PHP Savant (to name a few).
This cunt just won't give up. Huh, KravenC? :) He must have no life!
PHP already is a templating language. And it is [simple](http://codeangel.org/articles/simple-php-template-engine.html) to use it. As for hidden fragment of you page : just use css with a hidden overflow and height: 0; Then use whatever js library you like to animate the expansion. 
Well .. there we few good things about data access patterns in Addison Wesley's - "Patterns Of Enterprise Application Architecture". But it's not only about data access. I'm not even sure id such book exists. P.S. quick tip - stay away from anything that uses Active Record pattern .. its tightly coupled and contains way too much 'voodoo' for it to be testable .
Please stop. :(
Well in MVC the model-layer is responsible for data access. The layer as a whole is still responsible for querying etc.. Many (PHP-) framework users see 'Models' as value objects, but in MVC terminology the term is broader.
Stop what? Stop responding to your responses? I think we have a way to go.
+1 for Twig
You have no real need for the client to talk to the server. You just want to conditionally display a comment form based on a button click if I understand you right. That can all be handled client-side. If you absolutely must do this server-side, then you're going to have to pass state information back to the server in some way shape or form. The server will use that information to determine how/if it's going to display the form. Really really basic example here just to give you the basic idea: &lt;?php if(isset($_GET['showform']) &amp;&amp; $_GET['showform'] == '1'): ?&gt; &lt;a href="/myscript.php?showform=0"&gt;HIDE Form&lt;/a&gt; &lt;form method="post"&gt;&lt;input type="text"/&gt;... ... ... blah blah form stuff&lt;/form&gt; &lt;?php else: ?&gt; &lt;a href="/myscript.php?showform=1"&gt;SHOW Form&lt;/a&gt; &lt;?php endif; ?&gt; You can of course pass state however you want. Cookies, session, whatever. You could even call a whole other page. But I don't know the particulars of your situation, so I still want to stress doing this kind of thing client-side as a general case.
* use php to output the form HTML as you would do usually * use css to hide the form HTML * use javascript to change the css properties to show/hide the form simple example: http://jsbin.com/ihepe3/2
That's not really true; MySQL does byte-for-byte comparisons for both compiled and text queries for the query cache. MySQL didn't even support query caching for prepared queries until 5.1.17 -- before that you'd get better performance not using prepared statements for selects. 
I really think this is what he wants. He's a feedback junky of some sort. Which isn't special, but something he is loathe to admit to himself. I would like to add that I approve of your service to the community. It's actually interesting to see who you point out.
Thank you :) Most of the time I end up pointing out StoneCypher, because he trolls 95% of the time. 5% of the time he actually has a useful response. Even in the 95% of his trolling, there are valid responses. But because he's an obnoxious douchebag without social skills, it looks like he doesn't know how to put his viewpoints forward. There's a difference between saying: "I think your points are wrong, and here's why..." and "I think your points are wrong, moron. It would be a waste of my time to tell you..." He *may* have valid counterpoints. But most of the time I think he's bluffing, and he tries to rely on the *appearance* of being an authority on a subject, and hopes that no one calls him out on it. Of course, when someone calls him out on it, he goes through his standard motions of obfuscating, deflecting, and bitching.
&gt; Like the name implies, mysql_real_escape_string only handles string expressions. That means that anything that is not wrapped in quotes will not be protected against injection attacks using this method. Can you explain what you mean by that?
It was a lot easier than I expected. Took about half an hour to convert everything over. Not bad for a noobcake :P
I'm with you. I'd rather learn how to do it securely from the get-go than find myself 5 years down the road effing up peoples websites.
mysql_real_escape_string is designed to prevent escaping out of a string expression. If you aren't working with string expressions, then clearly this method is the wrong tool for the job. An example of a string expression (in bold): SELECT * FROM users WHERE username = **"richardjohn"**
Model is not a value object , nor is it an ORM. Fact, that php/ruby frameworks act like it is, doesn't make it so. Model contains domain business logic. The way how you handle an invoice does not depend on the source of the data ( is it an nosql database, xml , or sql database ). As for php frameworks: most of them does not use a "broader" definition of MVC. They just call it MVC , because it is good for PR.
Why not just dispay: none; and then change the display property with JS? 
Here's some code that does a toggle client-side. Requires the [jQuery](http://jquery.com) library. &lt;a href="javascript:$('#comments').toggle();"&gt;toggle comments&lt;/a&gt; &lt;div id="comments" style="display:none";&gt; &lt;div class="comment_list"&gt; &lt;/div&gt; &lt;form&gt; &lt;textarea&gt;Comment&lt;/textarea&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/div&gt; 
Well .. in the first place you wouldn't change the css property but change/add/remove the class. As for display or overflow, it kinda depends on the layout that he has. Both have some issues. Actually there there is a third way - move it out of the view-port. Usually done with positioning , and setting a negative left ( something along the lines of left: -32000em; ). It actually is preferred cause of screen-readers and search engines.
This is undefined, so no; that one person found it works under one shell isn't compelling. However, you can do something like this: array_exec($cmds) { foreach ($cmds as $cmd) { shell_exec($cmd); }}
I've seen questions similar to yours quite a lot before. You question prompted me to start writing up a brief intro to PDO and prepared statements. It's [here](http://foo.tl/guide/dealing-with-database-inputs/). It's very much a work in progress. If you could let me know what mistakes you find, what it's missing or anything like that I would be very grateful. 
No offense, but this problem has nothing to do with PHP's role in rendering the HTML from the server.
Sure. I'll look at it tomorrow and see what I can learn from it.
Thank you very much, kind sir :-)
It's better to both hide &amp; show the form with js so the page is still functional with js disabled...
This worked perfectly! Thank you! Is there any way to change the text of the hyperlink with this simple method when it's expanded or collapsed? For example, "Show Comment Form" vs. "Hide Comment Form"
I signed in just to upvote this post and I don't even do PHP! Brilliant example of MVC.
Welcome to the wonderful world of libraries!
Go to WCU, walk into one of the labs in 25 UNA, ask around.
I think I get what you are saying in terms of keeping the Model separate from the Data Access. The thing that confuses me is lets use the person as an example. Person_Model contains all the functions and data for a person. Person_DAL contains the instructions for getting and setting the data DAL_connection sets and gets the database connection, xml file ect now assuming I am using a database I would need an SQL statement somewhere. So to would I for a XML document. Where would these go? Person_Model should not be concerned with the data source. Person_DAL should be. Is this correct? so you would therefore need a separate Data Access Layer for XML, NoSQL and SQL. Correct? 
Ok ... where to begin. First of all, the Person itself in not the Domain model. It is just a class that your domain model uses. And that same Model knows about DAL (data access layer). And when your model needs to store the Person *somewhere* , it executes something like: $DAL-&gt;save( $person ); And from the standpoint of Model, it does not matter what exactly DAL does with the Person and where does it put the Person. And your SQL goes in that method. Now, if you want to save Person in XML, you just swap the DALs , to another on implementing the same interface. --update-- Domain model should receive an object, which implements DAL interface, in the constructor ( via a factory or directly ). This way you can do the swapping without actually changing the Domain model itself. Might be useful : http://martinfowler.com/eaaCatalog/dataMapper.html 
If you were to add an id to the anchor tag you could do something like the following: &lt;a href="#" id="toggle_lnk" onclick="$('#comments').toggle();$('#toggle_lnk').text(($('#toggle_lnk').text() == 'Show Comment Form') ? 'Hide Comment Form' : 'Show Comment Form');return false;"&gt;Show Comment Form&lt;/a&gt; &lt;div id="comments" style="display:none";&gt; &lt;div class="comment_list"&gt;&lt;/div&gt; &lt;form&gt; &lt;textarea&gt;Comment&lt;/textarea&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/div&gt; At that point though I would probably make the decision to not put the code inline. From a maintainability standpoint, once the inline code gets more than one function call in depth, i find it to be much easier to read and maintain when the code is formatted on more than one line.
There are a number of ways to do this with a little bit more code. Here's just one way: &lt;a href="#" id="showComments" onClick="$('#comments, #showComments').toggle();"&gt;show comments&lt;/a&gt; &lt;div id="comments" style="display:none"&gt; &lt;a href="#" onClick="$('#comments, #showComments').toggle();"&gt;hide comments&lt;/a&gt; &lt;div class="comment_list"&gt; &lt;/div&gt; &lt;form&gt; &lt;textarea&gt;Comment&lt;/textarea&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/div&gt; For reference, [the toggle function](http://api.jquery.com/toggle/) from the jquery doc. If you pass a number like `toggle(150)`, you'll get animation with that number representing the anim length in millis. Obviously not required. There are certain reasons for why you may want to toggle comments client side vs server side. Toggle comments without a page refresh is a benefit in most cases.
It's just that Foo doesn't fully capture the intent: the return value is the same exact object as the call is made on. I've used @return self a few times, but IDE support will be a problem.
I know what a string expression is, I'm just curious as to when you wouldn't be working with one in this case. SELECT * FROM users WHERE user = $userObject; Would never happen.
Yea this was what I was hinting at as well, thanks for the better explanation =)
&gt;Would never happen. It would happen if the data being passed on is an ID, not a string expression. In this case, mysql_real_escape_string won't help. I've seen too many snippets written by people thinking that mysql_real_escape_string is a catch-all function when it in fact is not. 
I recommend you take a look into Domain Driven Design. http://domaindrivendesign.org and http://en.wikipedia.org/wiki/Domain-driven_design Are two great places to start. In DDD without going into the long winded explanation, your models are really broken up into abstract concepts such as entities, mappers, services, and repositories. The goal is to create a consistent API for domain access while encapsulating the data layer and providing a high level of testability and utilizing dependency injection heavily. Entites are generally plain old PHP objects without any dependencies that are representations of the domain. A Person object for example may contain all of the attributes and necessary mutators for the Person domain. In a lot of the implementations I have seen, including my own, the Repository is what handles most of the heavy lifting of data retrieval and object instantiation by providing a consistent API as well as orchestrating retrieval using a data access object (DAO, usually created from a DAL factory metod) and finally taking the results from the DAO, a newly instantiated entity and passing them both to a Mapper object that is responsible for hydrating the entity using the results from DAO. Some implementations inject the DAL/DAO directly into the Mapper and the Mapper handles the retrieval, and some even inject both the Repository and the DAO directly into the entity itself, but I prefer to keep all of the work in the Repository. This allows me to simply and easily switch out any of the component from a single location, and in my controllers of plugins I can create a new instance of a repository for whatever domain I need to access, and use the API it exposes to retrieve whatever I need. DDD can really help understand how to break down the Model layer of MVC into something manageable and removes a lot of the confusion around who should be responsible for what. 
Thanks, I will try it in a bit. 
finally, someone who understands how this stuff is supposed to work - this is my frustration with php frameworks - even the ones claiming to be pure MVC + OOP still don't get this right
&gt; As for php frameworks: most of them does not use a "broader" definition of MVC. They just call it MVC , because it is good for PR. What else would you call them though?
There are a litany of other attacks that you should be aware of. One of your best resources is OWASP and they have a good overview of some of the most important attacks to look out for: https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project Here is another good resource for making sure you've got things covered: http://www.sk89q.com/content/2010/04/phpsec_cheatsheet.pdf Keep in mind, it probably won't be perfect right off the bat and there are new attacks coming out all the time. Make sure you don't do anything silly with passwords or anything and follow those guides. Heck, it's fun to try them so you can see through the attackers eyes, which helps me better understand attack vectors.
Don't forget to account for XSS attacks!
Ah, how could I forget? Thanks.
Look at the OWASP Top 10 web security vulnerabilities. Your app should at least protect against all of those.
Thanks for the awesome reply. I never planned to store passwords at all... rather just a hash of them. Is that secure enough? Would there be a way to encrypt *all* of the users' personal information (like email address, etc.) in such a way that they're stored encrypted, but can be decrypted only by someone who knows the appropriate password/sypher **and** that sypher is not stored in any of the .php files themselves? Basically so nobody except the admins would be able to decrypt it, even if that person had access to the source code and database? Sorry if that's an obvious question... never really thought of it before. Thanks.
Maybe you should have looked at this way of doing things instead: [simple php templates](http://codeangel.org/articles/simple-php-template-engine.html) As for me, i completely changed my style when i learned about (H)MVC ( like year ago or so ). Then i learned about dependency injection and SOLID principles, and right now i am reading Uncle Bob's "Clean Code" .. so i suspect that my style will soon change again.
Codeigniter. Anybody else with me on this?
What exactly does it mean by &gt;Input from $_GET, $_POST, $_COOKIE, and $_REQUEST is considered tainted.
Anything held in $GET, $POST, $COOKIE, and $REQUEST can be modified by the end user, and as such can be considered unsafe (or "tainted") until proper checks are done on the input data :)
As a general rule, mysql_real_escape_string() on the way in and htmlentities() on the way out. If the output is going in a tag's attribute, be sure to use ENT_QUOTES with htmlentities.
Do your users a favor and use a salt when hashing your user's passwords :) This way, if anybody DOES gain access to your database, the hashes are virtually uncrackable even with rainbow tables and other cracking methods. http://www.netarhia.com/hashing.html
Building a framework that allows me to deploy whatever kind of program i want, with clean urls, an error handling system, template system, input handling, db connection and admin. Step 1: Try working with some existing framework. Step 2: fuck all that noise. Step 3: write your own. 
Any chance you are willing to share? Github it? ;)
Oh god fuck everything about Smarty and Twig. Here's a better solution: Keep all but the most basic PHP out of your template files. Templates (views) should only contain `&lt;?php echo $variable; ?&gt;` and `foreach ($users as $user) {}` calls. Everything else should be passed down to it from a controller. *Everything*.
You're getting downvoted, but here's an up for you. Truth of the matter is that CI opened my eyes to how to separate all my code neatly. The documentation is top of the line, it has plenty of examples, a huge and active userbase, and the syntax, while a little dated, is a great introduction to frameworks in general. Thanks to CI I now am comfortable enough to start dipping my toes into Kohana and Fuel, which from my 1 week of serious coding in both, are superior to CI in almost every way. I tried Yii, I honestly did. I tried to go through it's blog tutorial, but its' heavy reliance on AR was a huge turn off for me. Also, it's far too "magical". A framework should not be magical, imho. CI had a little bit of magic, but Kohana/Fuel quickly got rid of that. No more *global*ish functions like `redirect()`. Instead, it's a very clear `$this-&gt;request-&gt;redirect()` for Kohana and `Response::redirect()` for Fuel.
Yeah but your integers would be worth twice as much even if they're displayed value is halved.
No, as a general rule, you should be using `mysql_real_escape_string()` or any `mysql_*` functions at all. Use PDO. It's more long-winded that `mysql_*` (actually it really isn't), but it's built from the ground up to prevent injections.
Also, [CSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks.
Point taken, I'm gonna go investigate Fuel :)
&gt; How do I ensure it is totally secure? You don't. If this was possible, everyone would, and there would be no security problems anywhere. Your plan must expect for you to get attacked, and be ready to cope; that's why we talk about things like hashing instead of encryption, and so on. &gt; Is injection protection enough? God no. Besides, there are quite a few kinds of injection: database, cookie, XSS, XSLT, XDomain XR, script masquerading, prototypal injection and so on. Look, if you have to ask a question like this, you can't release this code until you've read some security books. One little mistake is all it takes, and you aren't even sure what ground to cover. I'm not trying to be rude. I'm just saying, security isn't for people who don't know security.
PDO is a mess and has various well known defects; it is radically slower than native interfaces despite its documentation claims, and prevents you from using various speed focussed strategies like bulk insert. They *should* be using mysqli_ .
&gt; As a general rule, mysql_real_escape_string() No, use parameter binding.
read up on sessions. I wrote a simple password script in PHP a while ago. The code's very basic, but it might help you see how sessions can help with exactly this kind of problem: http://www.puremango.co.uk/2004/12/php_pass_81/ In essence; you generate a random unique string on the server, and create a temporary file (on the server, not accessible across the web) with that name. Then you save sensitive data in that temporary file. Then you send the name of that file to the user as a cookie value, this is known as the Session ID. Then, on repeat requests, the user sends you their session id, you open the file and read the data. The user never knows what's in their session, and no other users can access that data either. The only security concern is if someone can guess the session id, or steal an existing user's session id via some XSS attack. PHP has a dead simple API for doing all of the above: &lt;?php // tell PHP we want to send the session headers session_start(); // put some data in the session - this is a magic $_SESSION['foo'] = 'bar'; // get some data out of the session echo $_SESSION['foo2']; ?&gt; So, in your example, you wouldn't store anything at all in the cookie, apart from the session id. Eg, instead of: &lt;?php // remember that this is user 12 $_COOKIE['userID'] = 12; ?&gt; you'd do this: &lt;?php // tell PHP we want to send the session headers session_start(); // remember that this is user 12 $_SESSION['userID'] =12; ?&gt; edit: misread the title; didn't catch on that this was about a 'remember me' feature, wasn't thinking straight :/
I've removed PHP from my view completely by modifying the controllers to output XML and transforming the XML to HTML via XSLT. 
I know my way around sessions. I know that they're stored on the server, and thus can't really be messed with by the user, or at least can be trusted more than user cookies. The problem is that sessions expire fairly quickly. That's why so far I'm storing session information in a database that's set to expire every 3 days. The thing is, I'm having to "trust" information provided to me by the user's cookie, and then I can set up sessions from that. It just doesn't sound secure enough to my mind, but I could be way off base here. I'll take a look at your script. edit: Just tried your script. It's not what I'm looking for - it looks to be exclusively session based. If you close your browser, session is lost and thus have to log in again. I can already for a user to log in every single time they visit, and I know this is the most secure way, but my problem is automatically verifying their information across browser sessions so they're not asked to log in again.
That sounds hideous.
agreed. But I use the &lt;?php foreach($things as $thing): ?&gt; to get rid of the { }
Wow... I would absolutely love the chance to see your code. Would you be so generous as to open source it? 
1. xDebug + Netbeans 2. Learning to use a framework and CMS (I use Kohana and Silverstripe) 3. Knowing why I'm using a framework or CMS (and when not to) 4. Learning when to refactor and when to move on with my life 5. DVCS (hg or git)
wait what the fuck
Noted, thanks. What about secure encryption with the possibility to decrypt when required, as I discussed above? Also - presumably the salt is hard-coded? Won't this mean if an attacker can view your source, they'll know the salt, and can then use rainbow tables again?
I'm still loving CodeIgniter but am aware that it's not as OOP as it could be
Codeigniter, Zencoding, Komodo IDE and jQuery, all helped massively. 
&gt; The problem is that sessions expire fairly quickly only as quickly as your `session.gc_maxlifetime` config variable is set to. &gt; If you close your browser, session is lost You must have your browser set to clear cookies on shutdown. You can set up PHP sessions to last forever, between browser restarts and reboots. It's just a normal cookie as far as the client is concerned, it can last as long as cookies can.
&gt; How, then, to keep a user logged in when they check a "remember me" box? Generate a large random number, store it in their user record, send that as the cookie. Hashing it against their password isn't a bad idea either so that changing their password invalidates the cookie. &gt; What's the proper method of making sure they've not simply modified their cookie to try to login as a different user? By making the cookie value random or a hash, you make it much more difficult for this to happen. If you're imagining that a malicious user will try and brute force this cookie what's to stop them from simply brute forcing the username/password login? You can generally make this cookie much more complex than any username/password combination. &gt; making sure useragent and IP address are the same? With users behind proxies, IP address is not a reliable way of doing anything. I personally also like that my remember-me cookies don't disappear when I upgrade my browser. &gt; Storing a password, even a hash, in the user's cookie seems like a Really Bad Idea to me. A hash is pretty safe, just make sure you salt it. &gt; and when they attempt to access anything important, require them to revalidate their password. Is this the accepted method? Usually, you should require the old password whenever the user attempts to set a new password. Other than that, you're overthinking the problem. 
Or you use [bcrypt](http://codahale.com/how-to-safely-store-a-password/). To quote [Wikipedia](http://en.wikipedia.org/wiki/Bcrypt): &gt;Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive hash: over time it can be made slower and slower so it remains resistant to specific brute-force search attacks against the hash and the salt. To create a bcrypt password hash in PHP: &gt; /* $2a$ = CRYPT_BLOWFISH &gt; 07$ = two digit cost parameter &gt; usesomesillystringforsalt = salt &gt; */ &gt; $hashed_password = crypt('yourpassword', '$2a$07$usesomesillystringforsalt$') And to validate against the stored hash: &gt; if (crypt($input, $stored_hash) == $stored_hash) /* crypt() uses the salt directly from the hash */ &gt; { &gt; //Logged in! &gt; }
&gt; Generate a large random number, store it in their user record, send that as the cookie. Hashing it against their password isn't a bad idea either so that changing their password invalidates the cookie. Ah, such a simple solution. No wonder I didn't think of this at all.
Yeah templating, MVC and OOP. to me, templating is part of MVC; it allows you to separate design from logic. And then it's a natural progression to separate concerns by coding in an OO style.
Ah, but the rainbow tables would have to be rebuilt (which takes a very long time) with the salt included. You could generate a short (~4 chars) random salt for each user that registers and store it with their details in the database - that way an attacker could only attack a single user in the database at a time. As for encryption, I am no cryptography expert - but you could use PHP Mcrypt to enrypt user data before it is submitted into the database, however realistically this shouldn't really be necessary as long as you aren't storing information that is overly secretive. Definitely hash and salt your passwords, and I suggest you rely on other security measures (such as good coding) to prevent access to the other sensitive data rather than encrypting everything in the database! Any security expert willing to step in here with more advice?
Well, you're currently going through what I went through, a few years ago, and let me talk you back from that cliff you're looking to jump off. Sessions, PHP's home built system, really work just fine. However, it relies off of cookies to remember what the user's session variable is (you might be able to switch it to URL mode, I just never did). You could put the session in the URL directly, but that's not really any safer. I presume CI's prolly lays right on top of PHP's (I have no idea, I've wrote my own framework 5 years ago and do most programming in that). The major issue becomes how far do you expect someone malicious to be willing to go. In the session data I set up, I use a combination of mCrypt in cookies, a hash that points back to a session (just like PHP's), and then a control cookie (it's format changes on my mood, admittedly). The control cookie has the basic data about the user's session, but namely the IP address (hashed for the love of god). The session is for storing big sets of data that I might want to keep around, and the other mycrypt cookies are for anything else. Now I know you say you don't like CI's cookies being encrypted, but you have to realize how hard that is to actually pull apart. Can you do it? Do you know anyone that easily can? Then odds are you're pretty safe implementing the feature. So what I propose is, just piggy back off of CI's, since you're used to that anyway, but just put an extra cookie out there with the IP (encoded of course, also prolly one way hashed). Of course, if you can't lock onto an IP then you're just going to need to accept that the best you can do is CI's method, but make sure that the cookies are secure. By that, I mean you're running your site with https and not just http. TL;DR : CI's system is actually pretty safe. If you can just verify off an IP address so someone isn't stealing the cookie info, if you're that worried.
I sort of see CI as a stepping stone. It quickly and easily turns the MVC light on for people who haven't used a framework before. After a while you start to notice its flaws and desire a more well organized, cleanly written, object oriented approach. That, for me, is Kohana.
I agree that using an MVC framework completely changed the way I code for the better. Our in-house framework is very nice. I like it better than CI- so much so that we imported our "Baserow" class (the generic model all other models inherit from) into CI because it is much better at handling objects and database interaction. I dont know if CI is still like this, but I remember having to unset anything in $\_POST['object'] that wasnt in objects_table when trying to save a new "Object" or it would freak out. With our in house one, We just do $object = new Object($\_POST['object']); $object-&gt;save(); and it automatically maps what it can, and ignores the rest.
More user-friendly link to Panic's board: http://www.panic.com/blog/2010/03/the-panic-status-board/
You better read these first: http://shiflett.org/articles/the-truth-about-sessions http://shiflett.org/articles/session-fixation http://shiflett.org/articles/session-hijacking
As long as you have bcrypt installed, that is.
So you thin that classes which contain only static methods are somehow different from namespaced global functions .. hmmm .. interesting.
Do you have any links to these well known defects and bottlenecks?
What the heck are you talking about? It's [built in](http://www.php.net/manual/en/function.crypt.php).
You didn't read that link, did you? &gt;**crypt()** will return a hashed string using the standard Unix DES-based algorithm or alternative algorithms that may be available on the system. Some systems (like the Red Hat box at my office) don't have bcrypt installed.
The example I used of a redirect fits the bill for a static method, doesn't it? Why would you need or want to instantiate a class to be able to access page redirect functionality? Also: My IDEs seem to think the two are different, as I've got auto-complete for both Kohana and Fuel, but not for CI.
&gt; This is more an intellectual exercise (for fun), which is why I'm not just using phpBB or anything.
*YOU* didn't read that link, did you? &gt;As of PHP 5.3.0, PHP contains its own implementation and will use that if the system lacks of support for one or more of the algorithms. --- &gt;PHP now contains its own implementation for the MD5 crypt, Standard DES, Extended DES and the Blowfish algorithms and will use that if the system lacks of support for one or more of the algorithms. 
If you only permit one such random number per user record, your app will break as soon a user tries to log in from two places at the same time, or using two different browsers on the same computer. Maybe you could call it a security feature. As soon as you log in, you're automatically logged out from all other computers and browsers! But usually this will just cause unnecessary trouble to innocent users. Stick with sessions. There's nothing insecure about sessions if you use them correctly. After all, it's all done with cookies and random numbers under the hood. There is very little additional security to be gained by baking up your own cookie recipe.
&gt;**will use that if the system lacks of support for one or more of the algorithms.** If you have MD5 but no Blowfish, **it will default to MD5**. Should I write a haiku? Would that help you understand? PHP support for encryption algorithms is a travesty edit: missed the part about 5.3. A lot of systems are still on 5.2.
&gt;If you have MD5 but no Blowfish, it will default to MD5. **No.** It has blowfish built-in and will use its native implementation if it is not available on the system.
Only in 5.3. My haiku still stands.
*facepalm* [PHP &lt;5.3 is deprecated](http://en.wikipedia.org/wiki/PHP#Release_history). Your haiku does not stand.
Sessions aren't good for a remember-me feature, because they're temporary. You really do want something that isn't a session. 
5.2 is too prevalent to start assuming 5.3.
Git.
Don't forget to harden your Linux install and keep your kernel updated, don't have _any_ unnecessary open ports, use public key + password authentication, harden your apache config against various DOS attacks and other vulns, only use SSL HTTP connections, use HTTPS only cookies, don't allow JS access to any important cookies - especially session cookies, make sure your php.ini doesn't allow anything stupid like magic quotes, register globals or unlimited file uploads, never use the $_REQUEST variable, etc. The list is endless. There are lots of ways to own servers and/or users that have nothing to do with PHP code.
&gt; You must have your browser set to clear cookies on shutdown. No [session cookies](http://www.allaboutcookies.org/cookies/cookies-the-same.html) automatically disappear when the browser is closed. Whatever time you set for the gc_maxlifetime of the session won't matter if the user closes their browser. 
You want a unique salt stored with each person's hash. It's not a problem that anybody can read the salt; they don't gain anything from learning it. I.E. knowing it doesn't reduce the computational complexity at all. Also don't use md5. 
Smarty is great. But I honestly believe the thing that changed/improved the way I develop, more than anything else, was getting my first big contract job. It gave me far more confidence in my own abilities, I learned a lot (because I had a drive to deliver a quality product), and I was given free reign to do things the way I felt they should be done (and therefor I learned from my mistakes and my successes much better).
I agree. Which is why I mentioned PHP Savant. I'm personally a fan of Smarty, but that's just my opinion.
[Zend_Db_Statement](http://framework.zend.com/manual/en/zend.db.statement.html) (or similar) and standard SQL.
TextMate and CakePHP
Relying on an IP address for anything is a bad idea. Some people have dynamic IPs that change frequently, and others have to use proxies to browse the web. It's not nearly consistent enough to base anything on, least of all a session system.
I just read some of the OWASP documents on this topic. In a sidenote they mentioned that you can salt the password with something like the userID or the createDate of the Account. This would add a unique salt to every password and i think this is a sweet idea :)
The Zend Framework. Completely changed my coding structure. Also, the use of phodoc, phpunit, and phpcs have completely changed my coding habits for the better. Outside of that, I've written a php suite for emacs, with special emphasis on (but not requiring) Zend framework. My productivity has increased ever since.
CI may not be as OOP as possible, there may be some improvements to be made, but I'll be damned if there isn't something charming about it. Love it.
Is there a reason that you replied to what I said with a case of what I said? Zend DB statement is parameter binding, and parameter binding goes just fine with standard SQL. I really hope you didn't perform that downvote.
Not at -2, I don't. (I mean I already mentioned two that you can test very easily from a console.)
That's why I said, if you can, but don't count on it. If you're doing something for an intranet and you want to be sure, and you know IPs are static, then go ahead. Really, he just needs to trust HTTPS works and that your encryption method works as well.
Are you sure about that? I would have thought mysql_real_escape_string would evaluate everything passed to it as a string, and then escape all of that. I might be wrong though... I haven't used it for years!
Not true. You can use: session.cookie_lifetime to set the life of the cookie that controls the session. As long as your server isn't cleaning up session files at a different rate than that, you can control it. Sessions are as temporary as you make them be. Now if you want your different data sets to time out at different rates, well you gotta home brew that yourself, but even that can be wrapped in in the session system supplied by PHP
No, stop that! That syntax sucks! Really, the primary reason I replace that syntax every time is that IDE's can never find the end of that loop. When you've got a simple template, yeah, sure, that's easier to read and clear, but when you've got a few nested loops/if tags trying to find the right endif; or endfor; is aggravating. 
Virtual Machines, by far. Having a machine that (nearly) perfectly emulates my production environment, especially one that I can just copy/paste to my fellow developers, has simplified our works flows enormously. No more, "oh, well, Mr. Macintosh, here's how to fix your weird file system issue. Oh, you too mr. apache/php under windows? Oh wait, you can't install memcached? No gearmand support? Dang, gonna be hard for you to work on that feature, eh?" etc etc.
It treats everything as string data, yes, however if you are using it for something other than string expressions, you're fucked. 
Most of my points are covered by others (mvc framework), but one thing that made form building a LOT easier was when I built my own TextMate bundle full of frequently used code snippets.
a similar article written in 2003 http://www.massassi.com/php/articles/template_engines/
100% agreed. PHP is already a templating engine, it doesn't need another one on top of it.
Great framework.
Writing code which assumes a language version which is at 20% deployment on actual hosting is naive in the extreme. Assuming your users have done it right is you doing it wrong.
 Haiku are written In the five seven five form With reference to spring When you have found that PHP is not your mom Your job is to code Every language is Subject to programmer flaw Do not make Java Expect a language to Fix a mistake from your own hands Your script fails again Programmer seaside Screams to all "It's language fault" Tumbleweeds roll by
Why would you **ever** in OOP need to use something outside an object? And why would you redirect a "response" ? As i stated before, IMO, if a class has only static methods and static variables , then it is just collection of global function and global variables, all wrapped in a namespace. 
now that i review my reply, it doesn't make a lot of sense, i apologize. i was implying the first link ripped the content from the link i posted. compare the code. sure the code is public domain, but a sauce link would have been cool. s'all i'm saying. 
Actually, making your your own framework is almost like a rite of passage for php developers. If you have written your own, then, even if you fail miserably, you gain knowledge about, how frameworks are made and what are the challenges. And if you succeed, you have nice piece of code, that does exactly what you need. P.S. i second the "share the code" notion.
Emacs, let my IDE do all the heavy lifting for me. Drupal, let my framework do all the heavy lifting for me. Although I prefer functional programming learning MVC and OOP was a good idea.
I need to do this. One person in my department ignored installing one component and bitched my commits didn't work. Several of our wasted hours later I'm not allowed to call my boss an idiot.
This. Once I got over my fear of running VMs, I've actually got a workflow that I love to use. I can mount my vms in windows, so I can do all my code natively in windows, tail error logs in real time and code deploys so much smoother it's saved me probably days of my life. I can't even count how many apache/server issues I've been able to spot and debug before commits. 
Namespaces.
I believe that when Smarty was written that wasn't the case.
For me it was SVN. I cringe when I think about the days where me and fellow developers used to manually merge all of our tweaks and changes every couple of days because we'd never heard of version control.
Even if you're not working on a team, version control is a lifesaver. I can't count the number of times I had to redo something I deleted because I thought I wouldn't need it. Now I can just revert that commit (or look at the log). Branches are my best friend too. Want to try changing something? Make a branch. Like it? Merge it back in. Hate it? Delete the branch.
The server config differences was one of the key reasons moving to this system helped our team. Being able to simplify our apache configs was nice, but what was even better was not having to spend 30 minutes every week explaining what new httpd.conf change needed to be done and how it would apply to their specific installation. For each person. Ugh. Now we have the apache configs under subversion, and linked nicely inside the VM. Go in, do an `svn up` and restart apache -- tada! You're good to go.
Can you elaborate on how you use VM's for development? I use VM's for testing/staging, (and sometimes for virtual db servers) but I see a lot of people suggesting they use them as a dev environment? Is that right? Do you take much of a performance hit? (Prob not applicable for PHP dev, but I do .net stuff also..) Do you just keep a "development box" image that you can clone across to new team members etc?
It's immensely helpful from the standpoint of being able to send out instructions and knowing that others have a reasonably high chance of success because you're running the same setup. *(This isn't perfectly true because each VM will slowly deviate from one another as local changes occur. Still much better, overall, however.)*
No, I upvoted and gave an example of what you were talking about for the Op. Replied to you to be in context.
PHP has always been a templating engine. The point of Smarty is to provide a way to separate templates from code. Primarily, so that you can allow lower-level, or less skilled, users to edit templates without fear of them injecting PHP code that could seriously compromise the system, cause syntax errors, or otherwise generally screw up execution.
I personally cringe when I see session details added to the main user ID table. Users and sessions are two separate things that should be kept separate IMO. Put the sessions into a separate table, and reference the user ID from each session row in that table. That way you can also allow as many or as few simultaneous user sessions as you like. Even having a live RSS feed in your browser toolbar can mess things up if the application does not allow multiple logins.
Get a better IDE?
 I check my inbox 2 hour old messages here I sleep for too long Expecting downvotes Comments are at zero I am a lion PHP needs work Luckily we have some time Unless twenty twelve A language should help but PHP hurts too much I need an adult
Same with me. I played around with a few, but eventually I knew what I wanted. Still tinkering with it, but each new project I gets gives me an excuse to polish it a little more. It's funny to think what I used to look like 3 or 4 years ago and what it's like now.
&gt;Relying on functions and interacting with libraries in this way is not only a serious contributor to security issues in so many PHP scripts but also very inefficient anymore. Could you elaborate on how using mysqlnd/mysqli_real_escape_string directly is less secure or less efficient than PDO?
Indentation helps :) Nest and indent your html and do the same with the php, but independently. Works a treat. It's a shame IDEs don't pattern match the end tag.
 if($_USER['illepic'] == $_USER['TranslatedToPHP']){ echo "Nice Try TranslatedToPHP"; } else { upvote(); }
It's just different ways to develop. Some people use static methods, and some people instantiate objects. I'm not sure what you mean by "use something outside an object", though. To answer your second question: jtreminio probably meant something like `Request::redirect()` or `Request::instance()-&gt;redirect()`.
I absolutely love Kohana and I miss it developing in Python (although [Pyramid](http://docs.pylonsproject.org/projects/pyramid/1.0/) attempts to fill the void in my heart). HMVC, routes, and a good ORM? I would pay for that.
&gt;an error handling system What do you mean by this?
I've tried Netbeans, phpStorm, and Eclipse, none of which did that. I'm all ears if you've seen one that does. That said, an IDE's ability to highlight that syntax correctly is pretty low on the list of things I need my IDE to do well, so it's more sane to fix the code then to use a less able IDE just for that.
Yeah, if the whole world agreed that code should be nested sanely, I'd be a happy camper. Alas, reality kicks in...
&gt; new Object($_POST['object']); $object-&gt;save(); and it automatically maps what it can, and ignores the rest. And you don't see a problem with this? I'd love it if you told me the name of some of the sites you have with this functionality. It's not too hard to guess at the name of some of the fields you don't want me having access to and include them in the form on my end.
Kohana looks like this now: Request::current()-&gt;redirect()
I remember reading something about it a long time ago, but can't seem to remember it. Honest question, why not md5? 
Right, because that one sentence completely details the extent of how that feature is programmed. It's not like I would simplify it to fit it into one sentence so as to not post an entire technical document into one comment.
It's too easy to crack these days.
When i run code, at any point, if a function may/might fail to produce results, invalid input, no results, etc, and i want to render an error, i load the desired error message into a variable and can break out of whatever loop im in and present it. 
IDEs with color freaking coding!
So like an [Exception](http://php.net/manual/en/language.exceptions.php)?
CI is a good starter framework. Then go and check out Syfmony2 or wait a bit for the new ZendFramework2.
That one sentence could easily have included the fact that you filter for expected fields. By all means though, downvote me for pointing out an incredibly common security flaw.
Create a lookup table with the user id, the large random number (LRN), a primary key (or make the primary key a composite of the two). Replace the part about storing the LRN in the user record with storing the LRN in the look up table. Sessions are secure but they are destroyed when you leave the page and that's annoying for users.
&gt; then, even if you fail miserably, you gain knowledge about, how frameworks are made and what are the challenges. This. Or +1. Or up-whatever, but the point is I completely agree with you. Trying to come up with solutions for the framework problem helps "getting OOP". But it's important not to forget that your home-grown framework is probably sucks a bit more than one polished by dozens of contributors since years; also OOP is not the silver bullet.
I'm not sure if you're serious. So I don't know wheter should I up or downvote your comment :o
The new Twig is pretty smart. Much, much better than the &lt;?php .. and endforeach; ?&gt;es.
Working with Magento, which is written in MVC using Zend Framework. Figuring out MVC was huge for me.
it only maps to a table in the db. So I'm not sure what you would be expecting to include in some modified headers. If my people_table has name, address, city, state, zip fields, the form can include any number of meta fields in $\_POST['person'], but $person = new Person($\_POST['person']) is only going to save $_POST['person']['name'], $_POST['person']['address'], etc when $person-&gt;save() is called. The framework sanitizes everything as well. save() also calls the Person Model's validate() method first.
I did it because he was being a douche. 
I haven't seen directory traversal mentioned yet. Watch out for that one.
&gt; For me, it was discovering Smarty Looks like your next big discovery will be when you discover that Smarty is not really that useful.
The mistake in reasoning you're making here is to assume that all fields in your table necessarily map to user editable form fields. Let's assume for argument's sake that your person table has an 'is_admin' field. Obviously this wouldn't be one of the fields you'd present to a user in the form but I could add it myself using firebug or any number of tools if I speculated that there was a field called 'is_admin' and presto... I'm an admin.
Thank God for that.
Nothing is better than PHP at templating. Nothing, end of story.
Vim, i was using NuSphere PhpEd (company policy), then 2years ago a colleague introduced me to Vim (and gVim of course), it's a whole new world, much more efficient coding, plugins, customization, no more hair pulling when working on a server, i'm trying to convert every dev i know to Vim, it's like the Graal of editors. Also digging into writting PHP extension (and actually writting 2 of them) helped me a LOT in understanding the way PHP works, i would definitely recommend to any PHP dev to at least one time read up on PHP internals. And finally, working on one of the biggest site in the world definitely helped me on understanding how to write proper and efficient PHP.
Wrong. Sessions can be kept alive for as long as you like. Use [session\_set\_cookie\_params()](http://www.php.net/manual/en/function.session-set-cookie-params.php) to set a long lifetime. You just need to remember to call [session\_regenerate\_id()](http://www.php.net/manual/en/function.session-regenerate-id.php) from time to time so that the expiry date keeps moving forward. It's a good idea to call that function from time to time anyway, to prevent various attacks. If you really need to store some session-related information in a database, you should implement a custom session save handler instead of trying to bake your own cookie-based solution. Why reinvent the wheel when PHP gives you a ready-made tool that is secure by default?
 {% for item in navigation %} &lt;li&gt;&lt;a href="{{ item.href }}"&gt;{{ item.caption }}&lt;/a&gt;&lt;/li&gt; {% endfor %} Yes, that looks *so* much better.
&gt; Pornhub_dev Really?
Take a look at [these](http://www.twig-project.org/doc/templates.html). Better than the PHP alternative, right? I like Twig because it has SMART things, that'd result in ugly PHP spaghetti code. PHP is obviously the best for simple things. 
PHP is awesome if you need echo and foreach only. But for [these](http://www.twig-project.org/doc/templates.html), I wouldn't use PHP as it'd result in ugly Italian code.
 $_REQUEST = preg_replace('/[^a-z0-9]/i', '', $_REQUEST); it's the only way to be sure.
Exceptions in PHP are sorely useless. Trigger_error is more effective IMHO. Just set one error handler and be done with it.
I've never had a problem with them, but I've grown accustom to using exceptions. They're very nice once you get used to them.
I never said you needed to use PDO. You can just use mysqli. Using mysql_real_escape_string properly is not "less secure" than prepared statements, but the practice itself invites way too many problems. If you forget to escape something, you're screwed. With prepared statements, its not your responsibility to call mysql_real_escape_string thirty times in long queries. I wrote a wrapper around mysqli prepared statements because they required explicit type casting and some other silly things, so really my queries look something like: $links = Database\query("SELECT * FROM links WHERE appid=? AND version=?", array($appid, $version));
&gt;Generate a large random number, store it in their user record, send that as the cookie. Hashing it against their password isn't a bad idea either so that changing their password invalidates the cookie. If you generate a random number at login, the hash will be unique to that login.. I'm not sure why you'd want to log the user out when he changes his password. If you're concerned about the session being compromised, then just have the session die when the user logs out. IMO, a session hash should contain absolutely no information that can be reversed; it should be entirely random.
print("I wish") **Parse error: parse error in C:\xampp171\htdocs\reddit-comments\template.php on line 1**
This is for a long-term remember-me feature rather than their session; I keep those two things completely separate. The remember-me cookie basically takes the place of the login username/password step and everything else remains the same. Changing the password invalidates the remember-me cookie but doesn't do anything to session. Hashing a random number with the users password won't give any information that can be reserved or otherwise discovered. 
Thanks for sharing - looks very nice.
awww thats naaaaasty....
if you like smarty try mustache instead. completely logic less templating.
What's wrong with storing the end users username/password in a cookie? If there is no session, call your login script with the user/pass from the cookie to recreate the session. It's data the user already knows/will privide. If you're worried about people sniffing the cookie data, it's the same security as an actual login form. Just make sure it goes over ssl. And if you're worried about another person sitting at the computer and manually reading the cookie.. I personally think that if someone has full access to your account (via any auto login method) then there are more bigger things to worry about. 
This is the definitive guide for carrying out this login procedure, and has a process for detecting side-jacking, while allowing multiple cookies across multiple computers: http://jaspan.com/improved_persistent_login_cookie_best_practice
I did not know this, thanks for teaching me!
Use bcrypt or PHPass for password storage. Use PDO prepared statements for any database interaction. Use filter_var to sanitise strings.
I was under the impression Zend is horrible and bloated? Symfony on the other hand looks very nice :)
$comment++
Thanks. I thought about that before and looks like I will have to go that way. 
cookies are very helpful to keep user login because the main purpose of cookie is to store the important data like user etc internet don't know who is using it its cookies that help.
Zend, just works. It's very modular, so you can just rewrite performance-sensitive parts. Though not as streamlined as Symfony. And it's still stuck in PHP5.3-- land, whereas Symfony2 uses namespaces and various bits and spells of 5.3 magic :]
 Want to respond with Haiku of mirth and some shame Laughing hurts my gut 2012 line makes Any sin tolerable Yes, even COBOL
No, I wasn't, and that isn't [what the downvote button is for](http://www.reddit.com/help/reddiquette).
Oh I agree, but it's more noticeable when you work in a team. I use it for all my independent projects as well though for reasons you just mentioned.
Oh, thats what youre talking about? We usually abstract that out into a Roles relationship through one of our authorization plugins. $person-&gt;is_admin() doesnt map to an is_admin field in the people table, but rather through a people_roles table that map people to roles. $person-&gt;is_admin() basically would check $person-&gt;role-&gt;name == 'admin', but its not modifiable through a form like that. And again, this is very simplified code for Reddit-posting purposes.
&gt; ^ Why on earth is the default crypt MD5 when blowfish is available?? **If I remember correctly** there is an option for PHPass. If it is not set, PHPass will use "portable" hashes. They are based on md5 in case you want to port the Database to a System where Blowfish is not available. If you want Blowfish, you need to tell PHPass explicitly. 
PHP Ass?
dat ass
actually you have to set portable hashes to TRUE. It defaults to FALSE.
5.3 just makes sure PHPass does not fall back on crappier encryption such as md5. Regardless of whether you are on PHP3, PHP4, PHP5.2, or PHP5.3, PHPass still adds password stretching as well as a good salting mechanism. Plus, it's comparePassword method is simply really convenient (which doesn't impact security at all, obviously).
Oh well, I guess I did not remember correctly. ;-)
I believe the way that works is PHPass will _always_ fallback on the portable hashes if the crypt methods are not available. If you set the "portable hashes" flag to true (defaults to false), then it will not even attempt to use the crypt methods and instead will always use portable hashing (md5).
Yup: public static function HashPassword($password) { $random = ''; if (CRYPT_BLOWFISH == 1 &amp;&amp; !self::$portable_hashes) { $random = self::get_random_bytes(16); $hash = crypt($password, self::gensalt_blowfish($random)); if (strlen($hash) == 60) return $hash; } if (CRYPT_EXT_DES == 1 &amp;&amp; !self::$portable_hashes) { if (strlen($random) &lt; 3) $random = self::get_random_bytes(3); $hash = crypt($password, self::gensalt_extended($random)); if (strlen($hash) == 20) return $hash; } if (strlen($random) &lt; 6) $random = self::get_random_bytes(6); $hash = self::crypt_private($password, self::gensalt_private($random)); if (strlen($hash) == 34) return $hash; # Returning '*' on error is safe here, but would _not_ be safe # in a crypt(3)-like function used _both_ for generating new # hashes and for validating passwords against existing hashes. return '*'; }
Yes really
Zend Framework uses a convention to address that: @return Foo *Provides fluent interface* I've been shortening that to simply *Fluent interface* in my own projects. That addresses the IDE issue and appends the description as a comment to the value.
I can achieve the same level of clarity with straight PHP. Never had an integrator complain about it, just gotta set some rules.
Yeah, that's cool. So phpass+suhosin = deliciously easy to use blowfish passwords.
That was just an example! I don't care how your auth system works that's completely missing the point. The premise holds true and that is that as long as you automatically map POST to a db table without supplying a list of **expected fields** then you're inviting your users to guess at and modify data they shouldn't be able to modify.
it bothers me that people bracket echo like it is a function. Sure, it will work that way, but it is a language construct. In my opinion... echo $variable; ...looks way nicer, is more legible, and takes one less keystroke (!!). Maybe I am just being OCD.
No , it really is **Response**::redirect(); ... which makes no sense. Why would anyone try to redirect the response, which is meant for me.
Is that in Fuel? Maybe they mean you're changing the `Response` to be a `redirect`.
I see. Thank you :)
Every single time I say the project's name out loud, without fail, I call it php ass. It is an awful name for a project, but it just works so damn well.
Let me illustrate. Let's say Bar extends Foo and Foo provides a fluent interface with methods a() and b(), while Bar provides c(). You have a Bar instance, and want to say the following: $bar-&gt;a()-&gt;b()-&gt;c(). Entirely valid, but after a() your IDE will think it's a Foo instance and will not be able to provide the method hint for c(). Neither "@return self" or "@return Foo provides fluent interface" have IDE support that could remedy this problem, but if support somehow manifested itself I see the first variant as the more likely option and the second one just a crutch to deal with the lack of suport.
Ah, I understand what you mean (and I confirmed it with PHPStorm 2.0.1). I don't necessarily support implementing an adhoc solution that breaks the support that IDEs already have in place, but that's really a different issue -- and largely just a personal preference.
The linked article is misleading. There aren't two types of cookies. I hear this shit so often, it's not even funny. A cookie is a cookie is a cookie. The only difference between a "session cookie" and a "persistent cookie" is that the former has its expiry timeout set to zero. That's what makes it disappear it as soon as the browser is closed. If you take a "session cookie" and change its expiry timeout to something like 1 year, it'll start behaving exactly like a "persistent cookie", and vice versa. In PHP, you can use `session_set_cookie_params()` to specify the expiry timeout to anything you want. Combined with `session.gc_maxlifetime`, the result will be exactly the same as if you manually set a "persistent cookie".
That's right. Too many people are hooked on template engines. IMO, its not portable (I've seen it happen). Simple and basic PHP is fine in template files. If you have a proper code structure and flow. All the features of Twig can be easily done with just PHP.
I don't think so. You've got to have `__set()` and `__get()` declared; there's now way of avoiding or simplifying that. Edit: well, with a mod, perhaps, one that you would write yourself and compile in :)
It's just semantics. A "session cookie" is a cookie set with a past expiration date; that's part of it's definition. The other part of the definition is that setting a past expiration date gives the cookie session behavior. The terms "session cookie" and "persistent cookie" are both perfectly valid ways of distinguishing that behavior. Browsers also have configuration options so you can deal with session cookies and persistent cookies differently (for example, allowing session cookies but disallowing persistent cookies). 
Yes, you can use the \_\_get and \_\_set magic methods to treat getter and setter methods as properties. A few frameworks do that. In the magic methods you can use the method_exists() function to test for a function with the prefix of "get" or "set", call that method dynamically, and return the result. 
Semantics is OK when it's just semantics, but it can still be misleading when posted in a comment where you imply that "session cookies" can never outlast browser sessions. &gt; A "session cookie" is a cookie set with a past expiration date A "session cookie" usually refers to a cookie with **no** expiration date, or max-age=0 in the case of [RFC2965](http://tools.ietf.org/html/rfc2965). A cookie with a **past** expiration date would be deleted/invalidated immediately. It won't even wait for the user to close the browser.
Neither PHPass nor Suhosin do anything for you which you actually want. Stretching is a simple recursive loop and can be done much more successfully than PHPass' mechanism. Do a little reading on salting and peppering. There is much better out there. Incidentally, Blowfish is way, way out of date. Even if you want to stick with a Schneier design, you should be using twofish by now, and there's much better than either of those available.
I wonder what your criterion for a "good" salting mechanism is. That seems to me like saying something is "good" at string appending.
Security should not be structured around ease.
Yes, that's what __get and __set and __callStatic are for. They can also be used for much more complex things. http://us3.php.net/__get Sorry about the formatting: if I did it otherwise, you'd be seeing broken bolding right now.
OOP and MVC
Are any of these implemented in PHP? Do you have a link to any resources that cover using these superior methods in an application for password hashing? What exactly is wrong with bcrypt? I thought mcrypt was for encryption not hashing :S
Any of these one things? One, yes, there is a large stack of native implementations which can be easily googled up. Two, it doesn't matter: mcrypt is a generic algorithm interface. You can snap just about anything into it, and then said anything is available to PHP. Three, nine chances in ten it's already on your server in mcrypt. Four, like I said, there's much better available. Try looking at your options, instead of just using the Redditor defacto pretending to be security expert choice. Blowfish hasn't been a good idea since 1996. It's almost 20 years old.
Umm, NetBeans works just fine with it. Also, if you indent your code properly it should be easy to read even without syntax highlighting. 
&gt; Semantics is OK when it's just semantics, but it can still be misleading when posted in a comment where you imply that "session cookies" can never outlast browser sessions. That's the definition of "session cookies". Once you change the cookie expiration date, it's no longer a session cookie it's a permanent one. This is, of course, not to be confused with sessions in PHP. There's nothing misleading about using the term correctly. 
The problem with md5 in terms of secret hashing is basically its sheer speed. A fast algorithm means you can build a rainbow table (or simply try various combinations) at a much higher rate. [Popular Hashing Algorithms - An Analysis of Practicality and Security Applications](http://projects.z-dev.org/hashing/) 
Fair enough. I suppose I should have said "easy to use" salting method. In orderwords, you don't have to worry about retrieving salt values and manually salting inputted passwords for the sake of comparison.
That doesn't even make any sense. The ease if _implementing_ a security mechanism has nothing to do with how secure the mechanism actually is. I'm beginning to think you're just purposefully trolling r/php now.
Hey StoneCypher, reading through the docs for mcrypt, it looks like mcrypt is for encrypting strings/files/etc, and also having the ability to decrypt. Shouldn't a password be hashed in such a way that it's impossible to get the original value of the hash? So far I've been hashing user's passwords, and when they log in, I'm hashing the provided password and comparing to the hash I've stored, not unencrypting the stored password (although I know you're not saying anything about unencrypting). So, to be clear, you'd recommend bcrypt?
 class PropertyClass { public function __get($name) { $getter='get'.ucfirst($name); if (method_exists($this,$getter)) return $this-&gt;$getter(); return null; } public function __set($name,$value) { $setter='set'.ucfirst($name); if (method_exists($this,$setter)) $this-&gt;$setter($value); } } class ExampleClass extends PropertyClass { private $_radius=0; public function getRadius() { return $this-&gt;_radius; } public function setRadius($value) { if (($value&lt;10) || ($value&gt;500)) { throw new Exception("Wheee"); } $this-&gt;_radius=$value; } }
Via reflection you could do something like this. If you have a parent class with __get and __set functions and have your class inherit from it. It may not work as you want it to, but if you inspect your class for private member variables you could just have something like this: public function __get($name) { if (is_in_list_of_private_variables($name)) return $this-&gt;name; else throw new Exception('No accessor for ' . $name); } I havnt played around much with reflection before but in my head at least this should work. I would read up some here: http://www.php.net/manual/en/class.reflectionproperty.php#reflectionproperty.constants
Same goes for **require** and **include**, it bothers me to no end.
But who was cookies??
&gt; &gt; Security should not be structured around ease. &gt; The ease if implementing a security mechanism has nothing to do with how secure the mechanism actually is. Nobody said it did. Try understanding what was said *before* arguing with it. I will rephrase to make this easier for you. "You should not be choosing your security mechanism on grounds of how easy it is to use. You should be choosing it on grounds of how secure it is." &gt; I'm beginning to think you're just purposefully trolling r/php now. Yes, novices often think that when someone disagrees with them, said someone is trolling. It's sad that they can't cope with the idea that other people might just have a legitimate reason to disagree that the novice doesn't understand, and that therefore they must be picking fights for fun. Funny thing: you're actually clearly picking a fight here, and I had a technical matter I wanted to discuss. I bet you'd flip your lid if I said you were trolling there, though, since you're obviously just trying to straighten out what you see as inappropriate behavior. Maybe you should consider what it means that people are making technical commentary on topic that you don't understand, and you're calling them trolls, yet you're doing nothing but picking fights with no apparent goal other than your own entertainment.
&gt; Shouldn't a password be hashed in such a way that it's impossible to get the original value of the hash? For passwords, yes, one-way hashes should be used. Mcrypt wraps hashes. &gt; So, to be clear, you'd recommend bcrypt? Dear god, no. Was I unclear when I pointed out that blowfish was 20 years old and had been replaced not only by its own author but by two decades of other work? I'm a little confused here. First you talk about one-way hashes, then you hold up a library that does something I've already panned and isn't what I had recommended, which uses an out of date algorithm. I mean if we're actually talking about my recommendations, I wouldn't use encryption at all; I just don't feel like having that fight right now. Bcrypt isn't one-way hashing, and it *also* isn't good encryption. It's just a standard-issue redditor-pretending-to-be-smart topic. Bcrypt is just slowed-down blowfish. For my stuff, I use indirected rounds of SHA32048, Radio Gatun, Whirlpool and GOST, on a strong peppered stretching, both pre-emptively at client-side and then on the residue delivered at the server side. God, no, I wouldn't recommend bcrypt. I can't imagine how you took advice to stay away from blowfish in a generic hashing and crypto api, and converted it into I'd recommend something that's blowfish only. C'mon.
&gt; Fair enough. I suppose I should have said "easy to use" salting method. I do not use ease-of-use as a choice of security methodology. My opinion is that nobody else should either. Sadly, because you're off flipping out on me in another thread, I don't think I can actually have the legitimate version of this conversation with you.
My bad, I meant to type: So, to be clear, you'd recommend mcrypt?
Exactly! BTW, the ucfirst() is unnecessary because functions/methods in PHP are not case sensitive. 
I guess if you really wanted it in one place you could do something like the following public function radius($radius = null) { if(null !== $radius) { if($radius &lt; 10 || $radius &gt; 500) { throw new Exception("Radius must be within the range of 10 - 500"); } $this-&gt;_radius = $radius } return $this-&gt;_radius; } Not to sure how much I like this though.
This is what I've never understood about prepared-statement proponents. There are two major arguments, performance (which in a larger-than-not number of cases in PHP apps does not exist), and security, which follows the line of thinking that by using an external library to just dump anything in your database, it's somehow secure. I personally feel like the reliance on prepared statements for "security" is worse than *_real_escape_string. Your code **should** be vulnerable if you "forget" to escape a variable, you **should** be checking, type casting, stripping, escaping and value checking all external data that comes into your code. As for the performance increase of prepared statements, it hardly exists and there are massive misconceptions about it. Prepared statements are cached per connection, so unless you're doing the same query a few thousand times on the same page load (which generally means you are doing something wrong to begin with) you'll see no real performance increase. I wish people would stop acting like security is about what libraries you use, or what method you use to escape/validate date; it's about keeping security in mind at all times and coding defensively, you can't really avoid that.
From what I've seen of your posts, it's more the tone of them than the actual content of them that gets you downvotes.
Wrap them in backticks, like `$this`. Easiest way to avoid unintended bolding and italicking.
&gt; I personally feel like the reliance on prepared statements for "security" is worse than *_real_escape_string. Your code should be vulnerable if you "forget" to escape a variable, you should be checking, type casting, stripping, escaping and value checking all external data that comes into your code. No matter how much of a hard-ass someone thinks they are at coding securely, it is extremely critical to limit the amount of mistakes you *can* make. Granted people shouldn't be stupid enough to forget to escape something, but preventing that risk entirely (through abstraction) is clearly much more secure. I cannot comprehend the argument against this. In security there's something called "better safe than sorry." &gt; As for the performance increase of prepared statements, it hardly exists and there are massive misconceptions about it. Actually, I will concede that it probably is a slight overstatement to claim it is significantly better in most use cases.
Being that you say you are doing this using the CodeIgniter session object then many of these are not a concern. Review the docs on CodeIgniter sessions and make sure you instruct CodeIgniter to use a database to store sessions. If this is turned on and setup right then when you set something using the session library it is never actually transmitted to the user, all the user gets is a GUID that is a reference id for an object in the session database. With this setup if I set $this-&gt;session-&gt;set_userdata('password', 'mysecret'); the 'mysecret' is never actually transmitted to the user, it is stored in a json style array in the database with both the index and cookie being something like 'H24JGH74565HTHGGHETJ7567YT'. Yes cookies can be exploited however if you look at the CI session setting you can have it lock the cookie to both an IP and user agent, this is no 100% but will help prevent most cases of cookie hijacking. For most of what you suggest you are just attempting to recreate a wheel that is well functioning and mostly secure (more secure then your own attempts will be). Review the CI docs for sessions, read the wiki and forums. You might also want to check out some of the existing CI Auth plugins like ionauth. EDIT: Another great choice is running the site in SSL mode so traffic is encrypted, with ssl certs being under $15 now (on godaddy) you should use one if you are that concerned about user data and cookie hijacking.
[WAMP](http://www.wampserver.com/en/) or [XAMPP](http://www.apachefriends.org/en/xampp.html)
You just need to set up a server on your computer. I've always used [xampp](http://www.apachefriends.org/en/xampp.html) when developing locally. It's easy to install and shouldn't take more than 5 mins of your time to set up.
Best bet to get the syntax close enough to that would be to write a syntax transformer of some kind, that would take an input PHP file and rewrite your getters/setters (C# style into \_\_get and \_\_set) before writing the real PHP file out. You could probably even achieve this syntax by transforming with regex, but you could also use Tokenize and other ways of doing it in a more robust way. If it ends up being simple enough you can even embed the transformer into the PHP file itself, so it modifies itself before eval'ing itself. If you want an example of that, you can see one in my [PHP Hacks repository](https://github.com/ZaneA/Misc-Hacks/blob/master/phphacks/preprocess.php) (regex and all).
Cool. How about an AMA in r/webdev?
If you're interested in running linux, a LAMP is very easy to set up. sudo tasksel install lamp-server
or [Z:WAMP](http://zwamp.sourceforge.net/)
Phpass will use [bcrypt](http://en.wikipedia.org/wiki/Bcrypt) (it is based on Blowfish, but it is not Blowfish) in PHP versions since 5.3, or those patched with Suhosin. This is because it requires support for those algorithms in PHP's [crypt](http://php.net/manual/en/function.crypt.php) function. Bcrypt is most certainly not "way, way out of date" and is in fact the default password hash for OpenBSD, an operating system often used in places where security is paramount. In addition, there is nothing wrong with phpass's MD5-based "portable hashes" - although bcrypt or Triple DES is preferred - despite the fact that it uses MD5. Although interestingly, Drupal chose to modify the portable hashing algorithm [to use SHA-512](http://drupal.org/node/29706) instead. I **highly** recommend learning about cryptographic hashing from people who actually know what they're talking about (i.e. not me, and not StoneCypher): * [What You Need To Know About Secure Password Schemes - matasano.com](http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html) * [How To Safely Store A Password - codahale.com](http://codahale.com/how-to-safely-store-a-password/)
And if you are on a Mac, unless your reddit username is silverfishhandcatch, you will prefer [MAMP.](http://www.mamp.info/en/index.html)
You should have described your current setup. Anyway. I would suggest for you to install some virtualization software ( like VirtualBox, or some other ). Install on it some server OS, with which you are familiar. And manually set up your php development stack: - webserver ( apache or lighttpd or nginx ) - latest php - database server (postgresql or oracle or some inferior database system ) - other stuff And configure it in such way that you have forwarded the VM's ports back to the host-system. This would let you have a *canned* server on any operating system you want. You just run the VM, and in few seconds there is a webserver on your http://localhost with all features you need. Or you can make it exactly like your online development sever. Your choice. P.S. I would caution against use of pre-made server solutions ( wamp, xampp ), because they have only basic features, and kinda 'pollute' your everyday OS. 
Good thought, but it's doubtful you will actually get anything done with your wife driving down the highway.
You will also want to download the manual: http://php.net/download-docs.php
It is not possible to do what you are requesting syntactically without heavily modifying the PHP core. However, it is possible using vanilla PHP to do something like the following using magic methods.. class MyClass { function getName() { /* return name */ } function setName( $name ) { /* mutate name */ } } $myObj = new MyClass(); $myObj-&gt;Name = 'test'; echo $myObj-&gt;Name; Doing this adds significant overhead to the accessor/mutator processes, and unfortunately cannot be accomplished without internal magic methods, essentially imposing a custom method routing mechanism on your problem domain. It conceivably might have been possible to do it elegantly without implementing or inheriting magic methods were Closures implemented properly with [dynamic binding](http://en.wikipedia.org/wiki/Dynamic_dispatch). Unfortunately Closures are terribly limited(read: broken) and dynamic binding isn't even on the table AFAIK.
It should be mentioned that this approach does not consider private and protected scope, therein invalidating scope definitions for methods used in this way.
What happened to `__isset`, `__call`, and `__unset`. And how is `__callStatic` (or `__call`) even relevant to his question? Did we forget about [magic methods](http://php.net/manual/en/language.oop5.magic.php)? Aren't you a core developer or something?
The biggest tools are the programmers. *preemptive edit: downvotes imminent*
How exactly would one get the original password from a hash made by bcrypt with a decent amount of passes in a decent amount of time? If it's so insecure, how long would it take for you to give me the unhashed version of this? $2a$16$zbOM9ry.43LAYwER1fTIkOWhA76Lt8.a2uADoLc63TWrBbQh01PUm
I've been reading into mcrypt. It seems to be an encryption rather than a hash, and requires a passphrase. Doesn't this mean that if your server is compromised, you can use the passphrase to decrypt or at least brute force the passwords in the same way that you can with bcrypt?
The thing is, you haven't really said why bcrypt is bad for hashing other than "it's old". I haven't downvoted but I've been googling around about mcrypt for a while and it seems to just be for encryption, not password hashing, which seems like a bad idea if the key was compromised.
I prefer XAMPP over MAMP solely for the reason that it is much more related to a LAMP stack.
&gt; the drive is 8 hours so thats about 20 hours or so I could work on my project 8 * 2 = 20.... I didn't realize that PHP's math was so messy!
my initial 8 hours is an estimate, it sometimes takes longer. duh..
sadly the rest of us use macports, and compile them by hand.
Oh. So (8 + $traffic) * 2 = 20 ?
Run linux and install Nginx and PHP FastCGI.
make sure you download the php docs and related docs (mysql say) too
I'm pretty sure xampp is enough of a solution for what op needs and the best answer to his question.
As for downloading a website, wget is a good tool for that. It also exists for Windows: http://gnuwin32.sourceforge.net/packages/wget.htm
Haters gonna hate.
Interesting article... but I had to stop reading when the author said that CodeIgniter was one of the most well-written bits of code out there!
PHP has a low barrier to entry compared to most other languages (in my opinion, I'm sure someone will correct me) so it's probably the best tool for your job while you're learning. Chances are you have some web hosting with a shared provider, and they'll support MySQL databases at the very least, which will be perfect for what you want to do. However, it's important to be clear on exactly what it is you want to do. Do you just want to make your own forum software? Is it for the sake of learning how to program, or do you want to make a real site that actual people will visit and register for? If you just need a forum, your best bet is to install a pre-made forum like [PunBB](http://punbb.informer.com/), which is small and extensible and easy to make mods for. If you're doing this for fun and just to learn how to program, you have a few more choices to make. Do you want to use a framework, or will you be coding everything from scratch? A framework is a set of functions and libraries that are ready for you to plug your code into without having to reinvent the wheel. Some frameworks give you pre-built functions to handle user registration and login etc, so a framework might be your best option to begin with. [CodeIgniter](http://codeigniter.com/) is pretty nifty, [CakePHP](http://www.cakephp.org) is nice, and there are dozens of other frameworks out there that might suit you depending on your requirements. Just google "PHP framework" and compare features. If you're doing this for real and you've never worked with databases before and don't know any PHP code, you have a long, long way to go before you're going to be ready to release code that the public can use. There are a lot of security considerations to cover, especially when you're dealing with complex and multi-faceted software like a forum, and you're likely to shoot yourself in the foot hundreds of times before you start to get a grip on things (we all do, even once we've learnt a thing or two.) So if this is a real project for a real website, and you don't want to spend a few months working on some smaller learning projects, hire someone to do the work or find some pre-built software that you can adapt to suit your purpose. Anyway, let us know what you want to do in much greater depth and I'm sure we can offer some more specific advice. Good luck!
PHP has always been about cheap throw away code. Small businesses that need a website with a simple CMS, a gallery, some sort of form to email feedback/contact us system. That's where tons of money is, that's where tons of contractors get their first job. That's what drives the internet forward. Sure, the sites get upgraded, rewritten in Rails, whatever. Crappy PHP scripts have a place in the ecosystem and always will.
Windows user here. All of this is based on the assumption that you already know a good deal about HTML and how a website works. I've found that one of the best ways to learn is by example. To do this, you'll need to run code. To run code, you'll need a webserver, MySQL and PHP. For this, [EasyPHP](http://www.easyphp.org/) is the easiest setup I've ever used. It's a simple install and you get a webserver (Apache), which is the software which will serve HTML documents as web pages; MySQL, which is the database server to handle database queries; and PHP, which is the scripting language itself. The *other* way to do this is to jump in at the deep and deal with hosting and domains. While you can find any number of reasonable hosting companies who will take care of setting up hosting space and domain names for you, it will cost you but depending on the deal probably not much more than £30-50, $50-80 or thereabouts. Just check their feature list for MySQL and PHP. Don't worry too much about anything else. You'll naturally become aware of anything else you might need from your host and they're typically flexible if you need to change anything. Now that you have the environment to run code and serve pages, you need to write code. For this, anything from a simple text editor (Notepad or Notepad++) to more advanced packages like Dreamweaver. Try a few things and see which you're the most comfortable with. For PHP documentation there really isn't a better site than [php.net (language reference)](http://www.php.net/manual/en/langref.php). MySQL can be a little more complicated. I'd suggest looking for beginner tutorials. The MySQL website and its documentation is aimed at those who already have a good amount of programming knowledge. Start with *just* PHP. Get the hang of how it works, how to use it in a document, its control structures, maybe dabble with classes/objects. Once you have that under your belt, move on to simple MySQL examples such as storing and retrieving a single value in a table. If you make it that far and you want to know more you'll take it from there under your own steam. It *is* going to be a long and winding road, especially given your goals, and, while reddit will usually help with the occasional specifics here and there you will be a better programmer if you find your own solutions to any problems you come across. Hope this helps and good luck!
We practically invented hip hop.
[Reddit Enhancement Suite](http://reddit.honestbleeps.com) has a save comment 
Agreed with you, up to: &gt;Sure, the sites get upgraded, rewritten in Rails,
I'm literally leading a team of 6 developers to replace PHP with rails code. The massive organization agrees that Rails is better, and I do too. I wrote PHP for 10 years straight since its inception and still converted to Rails due to it. I'm still unsure as to why people are holding on to an inferior language. EDIT: I understand how it sounds, but why would you hang on to the language? What actual reasons are there?
These kinds of thoughts waste valuable human memory that could otherwise go to learning more programming languages and memorizing dirty limericks. 
Well, I'm glad you've seen half a dozen posts and therefore think yourself in a position to argue with someone's self opinion of four years of data that doesn't match what you just said. Clearly if I was being haunted - take a look at TrollPointerOuter, one of the sock puppet accounts, which has only ever been used to hassle me - then you wouldn't get that impression as a result of having been tricked, now would you?
I was unaware of that! Thank you: you just saved me `tons` of formatting hassle. I'd double upboat if I could.
What the f*ck are you talking about? Even Ulrich Drepper says he would have picked up bcrypt, if only it was on NIST's list: http://www.akkadia.org/drepper/sha-crypt.html I have never seen anyone dismissing bcrypt. More here: http://stackoverflow.com/questions/1561174/sha512-vs-blowfish-and-bcrypt
Er. Are you really bringing up isset, call and unset, which are of no relevance to c# style getters and setters, then asking me how callStatic, which is not the same thing as call, is relevant to his question? It's relevant for the obvious reason: sometimes a getter/setter applies to a static member variable, derp. One such example is when you're implementing things in the mindset of drivers, and one of them is a singleton, and you're trying to implement the countOf-ish method. No, "we" didn't forget about magic methods; the reason I didn't recommend __get and __set is that the OP was asking for *C#* *style* getters and setters explicitly, which are not what those magic methods are. It's right there in the post title. No, I am not a core developer. I did very old work - not a whole lot of it, but I dust that off when people using my work (even in a small way) call me young - and I occasionally submit patches. Most of my PHP work is distributed as libraries, because of personal beliefs.
&gt; How exactly would one get the original password from a hash made by bcrypt with a decent amount of passes in a decent amount of time? What am I, your college professor? There are lots of ways; rainbow tables are the most common &gt; If it's so insecure, how long would it take for you to give me the unhashed version of this? I'm not who e-commerce sites have to worry about. They have to worry about well financed criminal organizations who break into systems looking for credit card data, identity fraud stuff and so on. You know, like the recent Gawker and Epsilon attacks. You can do a lot with a thousand commodity PCs running several GPUs and a set of rainbow table scanners. Also, I don't waste my time preening for Redditors who make ridiculous demands of me. Of course I'm not going to spend time opening an encrypted string by someone who thinks it's a hash and that hashes are unhashable. Read a book, or at least learn to be nice when you're asking someone for information. Getting stuck in challenge mode like this really turns people off, and makes them not want to help you. I mean, maybe you just want to win an argument and feel right. And if so, you're doing it the right way, because right or wrong, you've set it up so that someone's just going to turn and walk away, and you can feel smug because they never knew anything in the first place, and yyyyyyyyeeeeeeaaaaaaaaaaaaaah. But if you actually want to learn why your design is bad? Be less of a dick. Ain't many people here who can actually give you that answer, and I'm not going to, now. You're encouraged to think of that as me puffing my chest up and acting important, because I totally haven't written security libraries that are in common use, or anything, and you're much better off swinging your big ol' internet dick around. For your ostensible customers' sake, I hope the next time someone says "but guy, every single crypto book out there says never ever reversibly store passwords, only residues," just say "how exactly would you perform an attack, give me a numbered list and a flowchart, and here's your challenge string to prove yourself, RUN MY GAUNTLET MERE INTERNET FOOL, FOR I AM THE DOMINEER AND YOU MUST CERTAINLY GIVE A FUCK WHAT I THINK." Turns out I don't.
"procedural crap" Orthodox developers can say all the names they want, but they forget that out there are all kind of project sizes and budgets where putting a framework, oop, mvc don`t make a difference and is that where php flexibility wins. And personally i think is because of the nOObs and spaghetti code that we've learned more about usability and bridges between programming and graphic design. if web development were in the hands of the classic square mind programmer, we would still have projects impossible to afford , ugly interfaces, and ugly asp shit Rasmus was right then. Is nice to see now the language evolved into something usable in big strong projects, but if we change everything to oop and complex frameworks php will lose what it had in the beginning Its just my opinion dude
Looks impressive Can't wait for the CMS :D
&gt; The thing is, you haven't really said why bcrypt is bad for hashing other than "it's old". I gave more than enough information. I'll repeat it. 1) BCrypt is Blowfish. 2) Blowfish has been replaced several times by its own author. Is that really that hard? Did you think he'd replace it if there wasn't a reason? Maybe, I dunno, you could go see if he explained why he replaced it? There's a 400 page PDF on counterpane that I don't feel like writing for you as a reddit comment. You really don't seem to understand that posting a comment on reddit is not a legitimate reason to think that the entire internet is your personal research staff if you just challenge them in public. Here's my Caesar Cipher. See if you can figure it out. (Hint: it's got a distance of 52.) "Eat a dick."
This is what PHPass does, if PHP 5.3 is used: http://pastie.org/1815357 And it doesn't do anything else, when PHP 5.3 is used.
&gt; What the f*ck are you talking about? Even Ulrich Drepper says he would have picked up bcrypt One, without an actual reference to where he says this, I have no context. I don't know what he'd pick it up for (nobody just picks tools up, except zealots, and Drepper is no zealot; he'd be using it for something specific, and I don't know what.) Two, Drepper is a great programmer, but he's no security researcher, and he certainly isn't the author of the tool. It's not clear to me why you would take Ulrich Drepper's word over that of the person who actually wrote the algorithm in discussion. That seems ... silly. &gt; I have never seen anyone dismissing bcrypt. I didn't dismiss bcrypt. It's great. It's just that there are newer replacements for it, made by the same people. You seem to be trying to make this into a religious thing. I'm not sure why. Is there a reason you're holding blowfish up over twofish? (It's legit to not point to threefish - it's flawed - but why are you holding it up over twofish?) I sure hope you're less aggressive in your next reply. It's hard to stomach talking to you when you act that way, especially when you're ignoring that blowfish has a successor.
Realizing that OOP is about creating metaphors and writing stories.
Perhaps the better question to ask is, why do you believe PHP inferior?
http://sixrevisions.com/tools/20-invoicing-tools-web-designers/ let us know, if you find anything from this list. I haven't tried a single one.
The comma just denotes that it is another argument to the function. The brackets (not parentheses!) indicate that it is optional. 
Agreed. CI and and some non-frameworks (Wordpress, Drupal) are absolute abortions to look at under the hood. They are using some of the most dreadful 'features' of the language (error supression operator, anyone?). Anyone serious about server-side 'frameworks' who also consider PHP should have their heads examined. Sure PHP can be made to perform well, but it doesnt out of the box. It needs help from things like APC, Memcached, or even uberhelp in the form of something like HipHop, which makes it become non-php. I was once a proponent of Zend Framework, mainly because it wasnt necessarily a full-stack framework, and I could pick and choose which components I could use. The problem with ZF is that it is so bloated with environment-sniffing code that it is unbearably slow as a result. I have to stick with Rasmus on this one. PHP is a great language for output rendering and lightweight server-side utility. That's about it. To use it as your full middleware layer or god forbid your data layer is an invitation to trouble. Ruby and Python arent much better either IMHO. Unfortunately, J2EE and .NET are the best things we have at the moment that can fill this void. This is why I am very passionate about Go. Can Go save us all?
Absolutely. Especially its ActiveRecord class.
Thanks for the list. I will give it a look.
Not very pretty IMHO.
Honestly, once you get going with CI things usually go smoothly that you simply can not be fucked to slow down again just for the purpose of becoming more OO compliant, esp. if the docs of the new framework aren't as good as CI's (and they are all worse than CI's). I'm embarrassed to say that after 4 years of PHP development I know little about true OOP, but then my clients don't give a shit either way. Lack of true OOP pays my bills just as well.
&gt; you can just rewrite performance-sensitive parts You shouldn't have to!
Do you really need PHP highlighting in your view, if it just contains simple foreaches and variables?
I don't think the fuck-fest you described is exclusive to PHP, I mean I've seen some pretty gnarly stuff written in many different languages.
agreed :)
It's because you're a troll, and the easiest one to pick out. You're also a dick to everyone.
Call me when Python or Rails get as large a representation of open source projects that fill needs that you'd otherwise have to reinvent the wheel to accomplish. Hate all you want on PHP it still has a faster zero to complete project timeframe than the other options available and less people circle jerking in forums about how pretty their less approachable language is instead of putting those projects out there. I don't care if you've designed the best language in the universe if I have to rewrite the wheel every time I use it I don't want it. 
Yes he is. Ignore the StoneCypher troll. The problem is that he's a douche. He (sometimes) has valid points, but he feels the need to put someone down when he makes it.
I wouldn't aim a newbie at a framework like CI or Cake just for the sake of gaining more framework zombies. If you put someone in that environment then they don't learn php they learn php from a CI or Cake perspective which may be great but then becomes incompatible when outside those environments. I would suggest he learn the language first. Be able to make an informed decision about which framework he wants to use before jumping in and gaining a skill set that's confined to one framework on the internet that may or may not eventually die.
&gt;rewritten in Rails Repeat after me, "Rails is not a language"...
&gt; The massive organization agrees that Rails is better More likely that, Rails is what they were told was best. Also, I find it rather odd that instead of saying the name of a language you opted to use the name of a framework. Which raises questions about competency and the legitimacy of your claims (as a result), but feel free to ignore this part of my comment, I just needed to point that out. A more layman's term example of what you did would be: I write in dictionary.
Wow. My team was hired to undo the damage caused by Rails. Sure it looks pretty, performs well in dev but make sure you load test it to the gills. It was awesome for us until it went into production. We've been in production for months with Zend Framework. Smooth sailing.
What I'd recommend depends on who I'm talking to. For people like OP, who I interpret to be novices, yes. For people with more experience, no. It's a little like asking which gun to recommend. Depends. Are they new to shooting?
That example is pretty amazing. I'm guessing it would add quite a bit of overhead, but this is what I was looking for. Thank you
What are your thoughts on Symfony? What about Python/Django?
Javascript will save us
&gt; I've been reading into mcrypt. It seems to be an encryption Keep reading. Notice that where I actually explained my recommendation, it was the use of four specific one-way hash algorithms.
&gt;The massive organization agrees that Rails is better, The UK Government, a larger organisation than yours chose ASP.net for a lot of their sites. Therefore ASP.net is beter than Rails.
xampp FTW
[Uniform Server](http://www.uniformserver.com): PHP 5.3, MySQL, PHPAdmin, Apache and many extras [HHTrack](http://www.httrack.com): download entire websites easily They've both served me well over the years to achieve what you are asking for.
i use harvest
exactly, it's possible to write shitty code in any language. php's problem versus other languages is that there's not much to discourage novice coders from doing so in the first place.
I was going to add "however in most other languages, at least it's a neatly formatted fuck-fest," but (ironically?) at the time I wasn't sure how to format it.
I prefer to always cast my input as well.
No problem, it most certainly is a hack though and should probably be treated as such, but that being said it does work and so if it does what you want then great :D
Yeah, not something I'll be putting in any production code, but, something fun to mess around with =) thanks again!
I can't agree with several things the article has said: &gt;Check out the Zend or CodeIgniter frameworks and tell me it’s not some of the best documented, most well-written code you’ve seen. It's not. Having dug extensively through both CI and Zend, I feel more than qualified in saying that neither are particularly well-written under the hood and both leave a ton to be desired with regards to documentation, at least if you compare them against their competition in other languages, like Rails, DJango, or Spring, all of which have much, much better documentation. &gt; Speed &amp; Scalability (maybe the best among script-based languages) Absolutely, definitely not. The PHP runtime is slower than any other popular runtime, requires a lot more fiddling, etc. The only thing PHP has going for it over other languages is its execution model, which isn't an issue with any of the aforementioned web frameworks and being able to break out of that execution model for things like a full text search index is absolutely essential for performance in computationally expensive websites - which do exist! &gt; A great unit testing framework The author has never run up against any of the PHPUnit walls and it's severely deficient with advanced testing, when compared to something like JUnit. &gt; Arguably the best documentation for any language No, no, no. A thousand times no! The documentation is, in various places: incomplete, vague, poorly organized, and in some cases, downright incorrect! This reads like a PHP fanboy wrote it, I would not call this language agnostic, unless his exposure to non-PHP languages was completely based on surface knowledge. If he'd worked with the tools that exist in other languages, read their documentation, etc. I don't think he'd be singing the same song. Developers that leave PHP rarely come back **because the tools and ecosystem around PHP are the worst in the business** and claiming they're not is just ignoring the problem and burying your head in the sand. Now bring on the downvotes!
What do you mean? It accepts a string to hash and a salt. Seems like proper params to me.
At the database :)
At this point in website development, 99% of people are picking a language because of their experience with or opinion of it; not because it's slow or fast. If you're in a situation where using something like Kohana or Fuel hinders your development, you shouldn't be using PHP in the first place. Plus every other language has an API for memcached and it's used quite often for optimization. The only reason PHP is considered slow compared to something like Python or Perl is because most of the time, people will use mod_php instead of Fast-CGI.
It would be interesting (although perhaps a nuisance in some situations) if the salt parameter was not optional. Edit: Looks like in some cases the method salts the hash by itself if you didn't provide one.
Python has a ton of [web frameworks](http://wiki.python.org/moin/WebFrameworks) (you can't really compare Rails to Python because one is just a framework while the other is an entire language) and a lot of documentation if you're beginning programming or coming from another language. I'm not sure what you mean by "rewrite the wheel every time I use it" because there are many solutions for Python projects ranging from [microframeworks](http://webpy.org/) to [full-fledged web servers](https://launchpad.net/rocket).
I'm more speaking to drop in solutions. PHP's got a corner on that market. We're talking full featured forum software, blogging platforms, content management systems etc. All with active development teams and proven track records. Yes Python's got some of that but it's just not as big or popular as their php counterparts. Don't get me wrong I'm not saying anything about the language, Python is outstanding. It's place in that market just isn't nearly as strong yet. PHP is available on every $2 host on the internet by default, when newbies go to start up a site about X they don't know to ask for Python or RoR they just get what they get and go from there. That means PHP's literally a petri dish for all sorts of nasty crap. But at the end of the day I go to work and get paid to implement solutions in PHP, not Python, not RoR. And frankly if I had to use Python or RoR for those situations where an actively developed drop in solution done in PHP would do, I'd pull my fucking hair out.
Perhaps I'm being ignorant. if (CRYPT_BLOWFISH == 1) { echo 'Blowfish: ' . crypt('rasmuslerdorf', '$2a$07$usesomesillystringforsalt$') . "\n"; } if (CRYPT_SHA256 == 1) { echo 'SHA-256: ' . crypt('rasmuslerdorf', '$5$rounds=5000$usesomesillystringforsalt$') . "\n"; } if (CRYPT_SHA512 == 1) { echo 'SHA-512: ' . crypt('rasmuslerdorf', '$6$rounds=5000$usesomesillystringforsalt$') . "\n"; } You tell it which algorithm to use and how many rounds to run by prepending the salt with the constant-defined integer corresponding to the algorithm you want, plus 'rounds=n' for n rounds, all separated by dollar signs. Is that information normally considered part of a salt? Why can't you give it a salt as one parameter, the algorithm as another, and the number of rounds as another?
On top of what LOOK_MA_NO_TYPOS has said, consider this: Assuming it available at all, if you wanted to encrypt something with blowfish, your salt would have to be something goofy like crypt($hashme, "$2a$07$z0m6tH1sIsn0tC00laT41l"); Where `2a` specifies blowfish, `07` specifies the cost paramater (which *must* be a two digit number from `04` to `31`), and the last part is a 22 character string from `[0-9A-Za-z]` *or else the function will return an empty string.* On top of that, for each hash type you have to check a global constant to see if it's even available. Horribly enough, if the string isn't just right for bcrypt, it just returns "". If you rely on it for hashing passwords, a single typo could potentially make every password hash "", allowing anyone to login with any password.
You don't honestly expect a post that's critical of PHP, in r/php, to get upvotes, do you? :P
I completely agree there: it's stupid easy to find a PHP project if you don't want to develop/tweak something yourself. There are hundreds of forums, twitter/facebook clones, etc. And I'd say that PHP's biggest strength is that it's on pretty much every shared hosting situation. That being said, if you want to develop something, *throw PHP away and head to Python*. There's a library for just about anything you could want and it's soooo easy to develop for. A lot of people praise Python like it's the savior of programming, and I wouldn't consider it *that* awesome, but I'd say it's the best language I've ever had the experience of coding in.
My guess is that it's a direct reflection of how the underlying c library works. 
Are you familiar with the problem of creating a framework that's a good-for-all-scenarios yet has the performance of a custom made highly specialized solution? The best way it can be done involves metaprogramming, runtime modification of the loaded code, just-in-time translation to machine code and other "simple things". With PHP you basically lose almost all possibilites for doing it, because a PHP process is short lived, so it has to load things quickly, and can't stop to JIT-compile something. Without an opcode cache you can't do fancy multi-step compilation of metaprograms. (And APC isn't included by default.) And PHP as a language doesn't [really](http://hu2.php.net/runkit) support monkey-patching classes or running code, and a framework has to be general, so it shouldn't depend on some fringe extension. Oh, and someone has to write the specialized code, put it into the framework and maintain it and its coupling to the framework too. It's not impossible, but a pretty tough nut to crack.
Is it not proper that a crypt function be cryptic?
Well let's talk about the problems with PHP documentation, then! Why do you disagree?
I am actually serious. I learned it in a previous job under an enterprise PHP environment and liked it so much that I brought it with me to subsequent positions. PHP does XML/XSLT very very quickly and it's a great way of further abstracting the view from business logic in MVC. It's also standards compliant and natively supported in PHP. Our implementation of it under Zend Framework is also l16n and i18n compatible. It's not for everyone or every project but where appropriate it definitely rocks socks. You can also use the same technique to output XSL:FO which can be turned into a PDF or RTF. It's a little more complicated but I prefer building PDFs this way versus using non-standard third party libraries. Using templating libraries like Smarty really don't do anything but add overhead and you can pretty much do everything you can do in PHP under Smarty, which totally voids the point of using a templating system in the first place. I think the fact that Zend Framework uses ".phtml" as its default templating system is sad. 
You rang?
Sounds impressive! Way over my head.
It's a feature of the underlying C library: since the salt and parameters are encoded in the crypted string, you can always just pass the entire crypted string as the salt argument, and crypt() knows to discard the part that isn't arguments and salt. So if you've got bob:$5$rounds=5000$usesomesillystringforsalt$hlaghlghalglghlg in your password file, and Bob logs in, you just shove that whole second field into crypt() and it does the right thing. If that didn't work, you'd have to store all that out-of-band somewhere (or not at all). But! The first purpose of crypt() is for handling the passwd (and shadow) files, where password gets one field. Originally passwords were only hashed with DES, so one field was fine; crypt() knew that the first two characters of the hashed password were the salt. But when it came time to implement new algorithms they had to be backwards-compatible, which meant one field, which meant encoding the algorithm in the hashed password. 
8~ * 2 =~ 20.
Just think about how you achieve generality. You try to be ready for as many conditions and formats of input (and outputs) as possible. So you have if/switch statements everywhere. You use general algorithms, you decouple as many modules as you can to be able to insert the right one to process the input or produce the output. That's why Java is full of abstract boilerplate code. But every time you test for something, every time you use an abstraction you lose performance. It's that simple. To gain some of it back you have to reach a fixed point (that is the process reaches a relatively stable state where it knows its environment, the conditions so it can just eliminate those tests with the stable value, and eliminate the abstractions too). Eliminating means on-the-fly (runtime) program modification, and the system (the program). So the program spends a lot of time testing, then it practically compiles itself into a low-level specialized variant that's optimized for its current environment. I particularly like Scala, because it looks as it might be able to handle this enormous complexity and be able to do the runtime transition. But there are things that you simply can't abstract away without input from the developer. Okay, that's not entirely true, but there are things that look fucking impossible on first, second, and almost all following sights. Just think about making a DBAL - Database Abstraction Layer, that can work with every database engine/server out there. From Oracle, through mySQL and PostgreSQL to SQLite and Firebird. Each has different SQL syntax, each has different implementations of indexes, locks, tables, cursors, joins, blablabla. Each has different performance pros-and-cons, each has different features! So your DBAL has to address the common denominator. (That frankly ends around Insert, Select, Update, Delete and Create/Alter table. SQLite has no Access control for example, Oracle has VARCHAR and VARCHAR2 and mySQL has no Series type [so the DBAL has to make a __series table to hold counters/sequences].) Yet the [Doctrine](http://www.doctrine-project.org/) team does something like this, with not totally horrible performance. And they even have an ORM - object relational mapping - library, that tries to abstract away the whole Database thing.
The examples are often just as much examples of poor practice as they are API calls, though, which means that people will just copy and paste them. Remembering, of course, that PHP is *designed* to be low-barrier-of-entry, the documentation maintainers should be on top of this. (Sidenote: I'm aware of the adage "don't bitch, fix it!" and to be very honest, I tried but to say that the documentation system is built to encourage contributors would be the exact opposite of the truth. The only way it could have gotten as damn confusing and messy as it is is intentionally). The discussion is all but completely unmoderated and often completely wrong, factually incorrect, bad advice, bad practice, etc. The first thing I tell people who I support (##php on freenode, usually) is to ignore user-contributed content to the documentation because there's no reliability to it at all. On top of all of this, there wouldn't **need** to be any commentary on documentation at all if it was inclusive enough. There's also no documentation standards that exist that I know about and if they do exist, they're certainly not enforced. There's no justifiable reason why it's allowed for PEAR/PECL extensions to be distributed by php.net without full documentation, let alone core modules (I'm looking at you SPL)! The fact that there's a discrepancy between core and non-core modules is a big issue to me. I would think that "incomplete documentation" would be a show stopper and it is for a lot of open source projects and I'm not aware of any other languages that allow completely undocumented language features to be added willy-nilly. At the end of the day, this sentence sums up everything that's wrong with PHP's documentation: &gt;I guess it's a matter of what documentation you need. 
The problem with Python is that it's a great language with a horrible runtime and both IronPython and Jython have been woefully abandoned. It's the exact opposite of Java in that Java is a kludge of a language with the best runtime in the business. I wouldn't use Python for web development strictly because of this, when something like JRuby (or even Rubinous, which will someday lose its GIL) exists.
You left out of your non-frameworks list: * MediaWiki * PHPbb * Joomla! * Magento * OSCommerce I'm actually unaware of any large, popular PHP projects that aren't abhorrently written.
Memcached only helps in situations where there's data that needs to be shared between servers and is cachable. There are plenty of cases (full text search, anything at all relating to computing graphs, aggregating data, etc.) of things that web applications need to do that are computationally expensive and not very cachable and it's in those cases that PHP really comes up the weakest.
I haven't seen any issue with Python's run-time, but I'm not running any hugely-popular websites. I like to think that in this day-and-age, the language's run time is one of the least important things to look at unless you wrote your own or something; all of the popular languages have very competitive runtimes.
Well I've always cached search results since some people search for the same thing and that was a major bottleneck... I've also cached data grabbed for WordPress posts/pages. It's mostly where the biggest bottlenecks are, and I've never had a problem caching stuff that's available to users without accounts (the biggest percentage of users).
The big issues are: 1. Global interpreter lock means you have no real threading. This means, for web applications, you have to run X runtime instances where X is the number of requests you'd like to be able to process in parallel. Since the runtimes don't/can't share memory, this means there's a significantly larger memory footprint for a Python web stack than actually necessary. 2. Extensions to the runtime are written in C and many of them only exist on particular operating system(s). They're also written against a non-threadsafe interface, so the GIL can't ever go away. 3. There's poor cross-platform support, both as a result of #2, but also a general disinterest in running Python in anything but GNU/Linux.
Use Solr for your searches and enjoy it not being a bottleneck any more as well as giving you much, much better results* :) * Full disclosure: I'm a lucene ninja by trade, so I'm a little bit biased.
Magento is pure madness. I have no idea who thought coding that way would somehow be a 'good' idea... the code is absolutely incomprehensible due to its insane use of abstraction... Absolutely everything is done through various magical methods that operate behind the scenes, so whenever something goes wrong it's completely impossible to understand why, or how to fix it.
Most of the cross-platform issues I've run into were alleviated by installing Win32all or another extension. I don't have any experience with threading, so I'm not sure if I'm reading what you correctly: if I set my web app to use 10 threads, it can only process 10 requests at the same time? Last I checked, PHP doesn't support threads, so the same problem (actually a worse one) exists for it. Does Ruby or Perl support threads properly?
I've looked at [Sphinx](http://sphinxsearch.com/)— what are your thoughts on it?
Thanks very much. Are you able to tell me what this example would mean? [; parameter] as opposed to [, parameter]
wouldn't you use ' ' (single quotes)? that could be mistaken by strings… even for the parser
Sadly no, it's a larger organization who bases their entire business in the entire world on the internet. Billions of pageviews. I know PHP fanboys will continue to downvote but come on, what's the purpose of holding on to this language?
Because the language is hideous in comparison. Needle haystack? Haystack needle? Dollar signs thousands of times? What's the point? Ruby also by default allows for DSLs to be created, allowing for even more legible code. PHP has none of this.
Not very interested since I have to sign up with a service that I can't even read about on their site before giving them some info.
I've been using Freshbooks for a good while now. It has time tracking, invoicing and late reminders. Clients can also pay over the internet if they like (and your invoice will be marked "paid"). You can also set up recurring invoices for monthly services like hosting. For me, it's been totally worth the monthly fee.
Being that I'm more familiar with Zend Framework, I'll say I prefer it over Symfony but it's well known that Symfony has excellent documentation and some people like it because of its more-rigid structure. Personally, I like that ZF is set up to be loosely structured so that you can tailor it to your needs. I've yet to give Symfony any serious amount of time though. I'm not much of a Python guy but I've heard good things about Django. But usually from Python developers.
I don't know if I fully understand your question so this answer may be way off the mark, but could SSH tunneling (or even reverse) help you?
I have a question about this actually. The hashes returned by crypt() contain all the details of of how they were salted, what algorithm was used for hashing, and how many rounds were run. Is there anything wrong with stripping out all that extra info and storing only the actual hash? Say an attacker gets hold of a dump of my entire database, but not my application source code. If the entire output of crypt() is stored in the database then they know exactly what type of rainbow table to build to work towards finding out plaintext passwords. If the details of the hash generation process are a secret that only the application source code knows, then it's much more secure, right? On the other hand, fuck this noise, I should probably have been using PHPass from the start.
That has nothing to do with frameworks. Just run a local webserver.
Reverse SSH tunnel
It's a standalone search server, so it's more comparable to Solr instead of Lucene (Lucene is just a library, Solr is a search application). So, with that in mind: * Solr has tested faster in the past * Solr is Java, Sphinx is C++, so it's much more difficult to deploy Sphinx. * Sphinx requires an esoteric client library to be in use, rather than a REST API, which severely limits its usefulness in a ton of languages. * Sphinx is designed to work against a RDBMS, so it's much less flexible than Solr is. * Solr supports a lot more features than Sphinx does, in terms of text transformation, search highlighting, queryability, etc. I'm completely unaware of any situation that I would recommend Sphinx over Solr.
If you run n threads in Python, only 1 thread can be actively computing at once (although the rest can be waiting). So, to process 10 requests in parallel, you have to run 10 instances of Python although they should each have several threads, because threads in a waiting state (waiting for I/O, usually) don't hold the GIL. So you can have 1 thread executing at once, but you can have n threads that are waiting at once.
Figuring out the algorithm from characteristics of the hash isn't *that* hard. If you have "fnrO06.601/yE" then it's probably not SHA1! But the point of storing the salt with the hashed password is that you use a different salt on each password, and therefore you'd have to have a lot of rainbow tables to crack a whole password file. If you didn't store it with the hashed password you've have to either use a constant salt, or you'd have to store them somewhere else, at which point you're not gaining anything over storing them together.
'the wild'?
Grab yourself a VPS! They are pretty darn cheap these days, some going for less than $30 a year - which is pretty similar to shared hosting! When you say that the hosts "block" the ports, how have you tested this? How were you trying to do it? Maybe it just needs another few pairs of eyes...
PHP's filter extension isn't really new, it's been there since 5.2 which is about 4 years old. It should give you about everything you need for input validation and sanitization. It's quite simple to use and it's not limited to just input as you can use it on any variable.
Yeah, you're right. Another reason the thing shouldn't take those kinds of arguments.
What's $sql set to after it's built the insert string?
if (!mysqli_query($DBConnect,$sql)) { die('Error: ' . mysqli_error($DBConnect)); } echo "1 record added"; echo '&lt;meta http-equiv="refresh" content="2;url=http://localhost/Project/members.php"&gt;'; I think the sql is right, because it does connect and add the data to the db fine, just that platformsAvailable field is getting wrong data. edit: is there a code tag for reddit? I'm kinda new here :D
$_POST['platform'] is a string because you're missing the square brackets at the end of the name attribute for &lt;input&gt;. This means that you're asking PHP to iterate through characters in a string in your for loop.
Well the SQL isn't doing what you intend so why would you think it's right? :) I meant do: echo $sql; after it's built it, and tell me what it outputs on the screen.
Not related to your question, but I hope you are not inserting post variables directly into your query without sanitizing them first.
output is this "INSERT INTO games (title, platformsAvailable, genre, players, info, picture) VALUES ('Portal 3','X','FPS Puzzle','1 and co-op','physics puzzle game','url')"...pretty much what I thought it would be, I've been checking its entering into the db with myphpadmin. It's just that one field and can't work out why =/
See [fieryscribe](http://www.reddit.com/r/PHP/comments/gvguf/cant_figure_out_why_its_only_sending_1_character/c1qkgcn) response. That's the answer. $_POST['platform'] is a string "Xbox 360", so the count is 1, so that loop runs once, and you get the 1st character which is X. Change: echo '&lt;input type="checkbox" name="platform" value="'.$platform.'" /&gt;'.$platform; To: echo '&lt;input type="checkbox" name="platform[]" value="'.$platform.'" /&gt;'.$platform;
I'm not sure what you mean? The for loop loops round and adds the value of each checked checkbox to a string var seperated by a ", ". All the checkboxes are named platform.
No I'm not, I'm aware I should though. This is just a noob project, dev locally. IF I ever put this online I will be making it more secure lol. Thanks for the heads up though.
Okay let me explain a little further. Let's take the GameQ library for example. It queries game servers with a socket connection and gets information about the server. Stuff like the current map, server cvar's, current players etc. This doesn't work on my shared hosting (hostgator) and from what I can tell, it won't work on most shared hosts either. Most shared hosts block outgoing ports that are required to communicate with the server. I am not familiar with how SSH tunneling works so, if this seems like a viable solution I am all ears. However I don't want to do anything that gets people's host mad at them, that would be bad representation for my project. Maybe I should just go the VPS route and set up an API.
See my response to escsco.
Yep just tried this and it works. Thank you, and of course thanks fieryscribe. Up votes for all.
is it possible that the column in the database is a char(1) ? Also, you seem to be treating $_POST['platform'] as an array in the second segment of code.. this variable should not be an array (unless you changed it in the code, which is bad practice)., whenever you use indices on strings i beleive it grabs the character at that index. (in that case whatever $i is) Also,you seem to be using two similarly named variables ($platform and $platforms), this looks like a mistake, but I can't be sure. have you tried echoing $sql instead of executing it in mysql_query() ?
That's a bad habit to get into.
You need to make the platform an array: `name="platform[]"` Otherwise you're just iterating through each character in the selected platform. `$string = 'PS3';` `$string[0]` is "P", `$string[1]` is S and so on. Which is why when they select Xbox you are just seeing an X because your code is only adding the first character of the string.
Heh, believe me, I'm well aware lol. 
It seems my problem was that I was treating it as an array ( I wanted that) but forgot the [] so it was being treated as string. :) edit: and yeah, someone suggested echoing the sql earlier, the output is above :)
Yeah I have, the output is above :)
PHP will interperet `$_POST['platform']` as a string if the input doesn't have square brackets (`[]`) at the end of the `name` attribute. &lt;input type="checkbox" name="platform" value="foo" /&gt; &lt;input type="checkbox" name="platform" value="bar" /&gt; To get PHP to interpret the `$_POST['platform']` as an array, you need to add square brackets to the end of the `name`: &lt;input type="checkbox" name="platform[]" value="foo" /&gt; &lt;input type="checkbox" name="platform[]" value="bar" /&gt;
So is [this](http://php.net/manual/en/book.filter.php) where I need to be looking?
Thanks :) 
Correct.
http://framework.zend.com/manual/en/zend.validate.html I'm not sure how standalone it is, but you don't have to use the other parts of the framework. Just put it in your include path. You also might look at Zend_Form as well. I use it all of the time on the backend without using the rendering on the frontend. 
Here's one that I wrote: http://pastebin.com/vbMy3qQ5 It requires one additional file: http://pastebin.com/sVvW7srY It's similar in style to CI...
No problem. I understand the confusion. I am not entirely comfortable with the way PHP generates the `$_REQUEST`/`$_POST`/`$_GET` variables in situations like this. If you sent this using a `GET` `method`, the browser will send a query string like `platform=foo&amp;platform=bar`. PHP writes *foo* to `$_GET['platform']` then overwrites it with *bar*. If you add the square brackets, it interprets it as an array, which is probably what the user intended. I have two problems with this: * I can't imagine any case in which completely disregarding user input is the desired behavior. * Requiring the square brackets in the `name` couples the HTML front-end to the implementation of the processing of the script. Lets say I have: &lt;form method="get" action="http://somesite.net/processform"&gt; &lt;input type="checkbox" name="platform" value="foo" /&gt; &lt;input type="checkbox" name="platform" value="bar" /&gt; &lt;input type="submit"&gt; &lt;/form&gt; If I implement the program at `http://somesite.net/processform` in PHP and want to use the normal PHP idiom for accessing the input (`$_GET` or `$_REQUEST`) I have to change the `name` of the variable to `platform[]`. But the HTML `&lt;form&gt;` is essentially a view--why should I change the view to change the processing implementation? This has actually bit me once. I needed to process a form that used multiple query string values with the same key name. They were from a standardized protocol, so I couldn't change the key names. In the end I had to write a special `$_SERVER['QUERY_STRING']` handler to build a pseudo-`$_GET` array. My proposal: if PHP encounter multiple user-input keys with the same name, it should automagically fill the appropriate `$_REQUEST`/`$_POST`/`$_GET` with an array.
This project does a good job of using Symfony components: https://github.com/fabpot/Silex Also, THIS: http://groups.google.com/group/php-standards/web/psr-0-final-proposal?pli=1
Modules - by extending classes or implementing interfaces. Pluygins - I'm thinking about using Events in the new version of my CMS. Right now I'm using the term plugin to describe an piece of script that is included on every page load (as oposed to modules that are loaded per-need basis). All the plugins are stored in a single directory, named iXXplugin-name.php and sXXplugin-name.php (XX is a number from 00 to 99). i-ones are loaded at init phase, s-ones at shutdown. With Events I could put them all in one place and use Events to run them when needed.
There are several ways you could do it that would be successful. I'd personally automatically scan particular directories (that could be specified via configuration) for plugin descriptor files, parse the files, and load the plugins they describe. A less dynamic and magic way might be the have a single plugin manifest file or a single directory where plugins can drop in their configuration. So, your project structure might look like src/ main/ foo.php bar.php baz.php plugins/ my_plugin/ plugin.xml foo.php bar.php your_plugin/ plugin.xml ... ... At runtime, all you would have to do is scan plugins/*/plugin.xml, load their plugins and wham bam thank you ma'am. If this performance gets to be a problem, it's entirely possible to parse all of them and cache an intermediary parsing step - like an array of plugins to load - on your production site. I've seen several PHP projects do this, most notably Magento. You can make the plugin system much nicer for the developer by offering standard classes, example plugins, etc. The only restrictions I would enforce this way are what conform to a particular defined extension point: an extension point for a page rendering element might only need to return a string to be rendered in the page, whereas another plugin (that enforced logins) might need an extension to return a boolean. I'm sure you can see how this would be helpful for everyone and can imagine ten thousand better examples. In some way(s), you'll have to create a way for plugins to be referenced dynamically. A common, relatively easy to implement method is to allow plugins to define their own "extension points" and have plugins registered to be called at those point. A good example of this might be the plugin that actually renders the page: it would have extension points at "header start" "header end" "body start" and "body end." One plugin that uses it, say one that automatically minifies javascript, would want to hook into the "header end" point but another one, say the layout renderer, would want to hook elsewhere, at body start and body end. If you do it this way, you only have to specify a very small selection of core extension points (that correspond to major events in the request's lifetime - like "request made" or "response ready to be sent to the client"). If you properly structure your plugins around this system, you wind up with a very semantic representation of your site that's very easy to understand and self documenting. You'd wind up with nice extension points like: request retrieved &gt; page generation &gt; body start &gt; layout manager &gt; column 1 rendering &gt; add display box request retrieved &gt; page generation &gt; authentication &gt; authenticate request retrieved &gt; page generation &gt; header ready &gt; page optimizer &gt; concat javascript &gt; minifiy javascript response ready &gt; html tidy &gt; tidy body response ready &gt; google analaytics &gt; inject javascript As you can see, if you name things properly, it's very easy at a glance to recognize what a plugin does, assuming that it's represented properly in XML (and this is why I choose XML): &lt;register_extension&gt; &lt;request_retriever&gt; &lt;page_generation&gt; &lt;body_start&gt; &lt;layout_manager&gt; &lt;column_1&gt; this\is\a\class\that\implements\some\Extension\interface &lt;/column_1&gt; &lt;/layout_manager&gt; &lt;/body_start&gt; &lt;/page_generation&gt; &lt;/request_retrieved&gt; &lt;/register_extension&gt; It looks kind of horrible for a human to read (it doesn't help that this is also an extremely pedantic example that exists solely in my imagination) but XML makes for extremely easy interfaces to be written, so when your product gets mature enough to be able to deploy plugins via uploading a zip file and allows for customization and configuration via a management console, you'll never have to actually read the markup. At the end of the day, I gauge the success of a plugin system by how much of the core functionality can be expressed as plugins. You might wind up with a bunch of tightly coupled, dependent plugins but that still means your plugin system and its dependency resolution is powerful enough to handle the totality of your platform.
I just posted a link where he said that. He said "why not use bcrypt then" and the only reason he gave was that it wasn't on NIST's list. Then he implemented Linux passwd with SHA-265 and SHA-512 with about 1000 iterations to make it slow enough. OpenBSD (known for its security) uses bcrypt for passwords: http://www.openbsd.org/papers/bcrypt-paper.pdf Of course there are newer replacements (there always will). That also mean newer bugs. Still to date, bcrypt is good as it was 10 years ago, no problems detected so far. Yes, that applies to twofish too. But just saying that twofish is more up to date, doesn't make bcrypt any less effective. If only reason is to use twofish is that it'a newer, its hardly an argument against bcrypt, and its use of blowfish. Do you have anything else to say than that? Yet I have not read any valid arguments against bcrypt.
I would strongly advise against XML part. It's mostly people not protocols or tools reading the code, thus source code readability should be the prime focus. You can either achieve that with JSON, YAML or even skip this step completely. I have created a PHP5 plugin system in sub 50 lines that is closure powered. //PostsController.php function showPosts_Action($category){ ... $results = Posts::Find(array('category'=&gt;$category)); hook('blog.posts.showposts', $results); ... } //SomePlugin.php (jQuery Style) on('blog.posts.showposts', function($data){ $data['content'] = markdown($data['content']); return $data; }); //Or you can also send it as delegate $markDownFilter = function($data){ ... }; //And then externalize the interface to e.g. "plugin-name.init.php" on('blog.posts.showposts', $markDownFilter); on('blog.posts.sendcomment', ...); Given an interest, I can put it on github 
Your directory layout like what I have going on right now. My current layout looks like: ./app/ &lt;- Everything here is what comes with the Standard install, makes upgrading almost worry free ./config/ ./helpers/ ./libs/ ./modules/ ./content/ &lt;- Templates and temporary directory ./templates/ ./tmp/ ./local/ &lt;- Everything here is unique to the local install &amp; takes precedence over the app directory, easy upgrading, like what magento does ./config/ ./helpers/ ./libs/ ./modules/ &lt;- Custom modules, using MVC ./SomeModule/ &lt;- Main module directory ./Controller/ &lt;- All controllers here ./Model/ &lt;- All models here ./View/ &lt;- All views (layout) files here ./SomeModule.xml (or ini) &lt;- Config file ./plugins/ &lt;- "Hook" style plugins similar to Wordpress/Drupal ./DoSomthingPlugin/ ./DoSomthingPlugin.php &lt;- Main Plugin file ./DoSomthingPlugin.xml (or ini) &lt;- Config file Caching plugin info is a great idea, I'll definitely do that. When I originally started I wanted to allow developers to write modules using extends to build upon any standard class. Now when it came time for implementing modules, I realized that this would work great with only 1 module overriding 1 method, but as soon as we have 2 modules overriding the same method things break. So my first idea was having 2 systems, 1st for modules the 2nd for plugins (hooks). Modules which either add new classes or modify current classes (by extending) with the 1 module per extended method limitation. Modules would usually be new major features (i.e. Comments modules). Plugins (hooks) would be the system that allows developers access to certain points in the code, which can be tied into by the custom plugins. Plugins would usually be changes to current modules or the types of changes which can work with other plugins (i.e. Social like buttons). Modules will follow a standard MVC style. Plugins are a little more complicated (due to controlling hooks locations/access), I was thinking about doing this for the plugins (hooks) system: class Something{ public function getDoSomething($args){ $plugins-&gt;executeHooks('Something_getDoSomething_pre', $args); $results = doSomething($args); $plugins-&gt;executeHooks('Something_getDoSomething_post', $results); return $results; } }
I was thinking about going the same route as you, separating modules and plugins.
If you know that you'll only need to run a single (or two) queries then I'd say that you should connect/disconnect just before/after the query. If you have a lot of queries (most scripts and application will have that) then open the connection in the beginning and close it in the end.
Allright thank you, this is the answer I needed. What happens if the script dies somewhere, does that close the mysql connection? Edit: nevermind i've found an answer on google for this one.
In case someone else wonders: PHP will close the connection when the script closes/die.
You know, I've been thinking about things like autoload() and include/require for the past few days. It seems to me a lot of issues/problems would be made moot if PHP simply adopted something like the PSR-0 (http://groups.google.com/group/php-standards/web/psr-0-final-proposal?pli=1) into the language framework. Take Python, for example. A lot of people overlook just how powerful the import search path is. I love the hierarchy of packages -&gt; modules -&gt; classes. It just makes sense. It's the whole convention over configuration thing that RoR dorks scream about. I don't have to do any fancy introspection or guessing of the class name. I just tell it where the packages are, and bam. Instant autoloading. But PHP has nothing like it, no intelligent searching for modules, no standard hierarchy of them, in fact no concept of them whatsoever. I realize that PHP started out as a fancy templating language, but this is 2011 and it has made a lot of strides to become a full-featured interpreted language, with things like namespaces and closures. It just needs to take that extra step. As it is, it feels like an ad-hoc, slapped-together mess. Which saddens me, because I love PHP.
You, sir, have made me look like a fool, and I appreciate it.
But then, you don't have to crack a whole password file, you can just crack one, an admin password, and you'd be in the system. I think that's what LOOK_MA_NO_TYPOS was talking about.
&gt; Caching plugin info is a great idea Vanilla forums does this too. It generates ini files pointing to the locations of all the controllers and locale files in the core and in plugins. If a plugin is installed, updated or disabled, then the ini files get rebuilt.
Putting it another way: opening a new database connection has an overhead, so do it as seldom as you can within each page load.
&gt; Still to date, bcrypt is good as it was 10 years ago Blowfish also wasn't the right choice ten years ago. &gt; If only reason is to use twofish is that it'a newer That is not the only reason I gave. I get really bored of repeating myself. &gt; Yet I have not read any valid arguments against bcrypt. Okay. Have fun then. I already mentioned where you could get a 400 page document by the algorithm's author full of reasons, but I guess you'd rather stick to 20 year old technology that its own author replaced than find out why the new one is better. Notably, this isn't about it being newer. You'd know that if you were reading: I panned threefish, which is blowfish's grandchild. It's unfortunate that people spend so much time defending their existing expectations that they don't even really read what they saw.
I'd seriously recommend looking in to symfony 2's way of doing things. Very, very nicely done and a large factor in why phpbb4 will be built on sf2
On a related note : stop using the old mysql_* functions and learn how to use [PDO](http://php.net/pdo).
Out of the two options, the former is the better one. Opening connections has an overhead, so it is better to reuse the existing connection than closing and opening new ones. However, a better approach would be lazy-initialising the connection, i.e. not opening the connection until you actually need it. Example: [...] function query($sql) { if (!$this-&gt;isConnected()) $this-&gt;connect(); $this-&gt;db-&gt;query($sql); } [...]
Personally, I do it using a combination of the first two. Plugins are a directory within the plugins base directory. The main file is the file with the same name as the directory (but with `.php` of course). The main file specifies all the relevant information (name, description, ID tag, author, etc) through the file's PHPDoc header (via a custom [ReflectionFile class](https://github.com/rmccue/ReflectionFile/blob/master/ReflectionFile.php), which kinda sucks) Plugins can reimplement classes (the plugins can hook into the autoloader to override class loading), although this isn't the recommended way, as it means that plugins may conflict. Instead, they mostly operate through hooks (actions and filters, ala WordPress), e.g: Plugins::register_filter('feeds.update.insert', function ($feed) { $feed['id'] = sha1($feed['title']); }); // Then running this: Plugins::apply_filter('feeds.update.insert', $feed); As awesome as autoloading and extending classes is, it's very easy to get conflicts between plugins. Overriding the built-in classes is still possible if a plugin needs to do so (say, if they're completely replacing the authentication system, in which case, you'll only want one of these). If the plugin system detects conflicting overrides, it will skip both and use the built-in, and report that the plugins are incompatible to the user.
I like to think of it as port forwarding (but don't quote me on that), where a port on your local machine is pointing to a port on a remote machine. So if your host provided an SSH connection, you can log in and tell it to tunnel some remote port to a local port (e.g. I can tunnel the MySQL port on the server to my localhost port 7890, so when I connect I just use localhost:7890). Reverse tunneling just means you'll initiate the SSH connection from the remote machine to your local machine. This will require your local machine to need an SSH server. If you're going to automate this you'll probably need to setup passwordless logins. The other way is to use the [PHP Expect Module](http://www.php.net/manual/en/intro.expect.php). It's not pretty, but it works. With that out of the way, you might be better off with VPS.
Are these pdo functions faster then the old mysql_ prefixed functions?
Beginners often go to insane lengths to optimize - at the expense of code readability and flexibility. MySQL connections will close automatically at the end of each script run (unless you use persistent connections), so in normal circumstances there's no need to add extra code just to close the connection - in particular if trying to determine where SQL calls are made means you have to add a lot of extra code. It's not worth it. Keep in mind that 1) MySQL is able to establish connections really fast, and 2) the majority of sites are not Facebook and don't need to go to great lengths to optimize. Many forms of optimization come with a price (more code, more time spent figuring out how to optimize, etc.). Mind you, I'm not saying you should never think about processing time. I'm saying that, if you have what I'd call a "normal page" where you have a few SQL calls and PHP generally processes that page quickly, you shouldn't worry about closing the connection.
A [CRM](http://en.wikipedia.org/wiki/Customer_relationship_management) might be a good solution.
The difference between the two are negligible. PDO used to be significantly slower in the past, but that is no longer the case. There is no noticable difference in speed. The benefit of using PDO over mysql_* is that it gives you a common easy-to-use API to multiple databases, as well as giving you access to [prepared statements](http://php.net/manual/en/pdo.prepared-statements.php) (a feature which is also available in mysqli (which supersedes the mysql extension)).
The location - top or bottom - isn't very important, and should be chosen more in terms of what'll lead to simpler code. The important bit is that connecting to a database is expensive in terms of CPU, RAM and DB resources. You should make as few connections to the database as possible, and one complex query is nearly always better than a herd of simple queries.
Looks great! I'm going to use this, thanks!
Hopefully it makes more sense in context... hopefully.
take a look at how fuelphp implemented packages and modules. it would be a great solution for what you want to do.
mysqli_ functions are faster than either. PDO really only makes sense if you value portability over performance. Outside of trivial cases, it's not possible to write SQL that will perform equally well across various database engines. So you're going to have to have database-specific logic anyway. Might as well get as much performance out of it as possible by using native drivers rather than a murky abstraction layer.
This (lazy opening) is usually the right answer. That way, pages that can be read from non-database cache never need to open a connection, and pages that need the database connect to it just fine, and you don't have to think about it when you're writing your code.
&gt; I like to think of it as port forwarding (but don't quote me on that), where a port on your local machine is pointing to a port on a remote machine. So if your host provided an SSH connection, you can log in and tell it to tunnel some remote port to a local port (e.g. I can tunnel the MySQL port on the server to my localhost port 7890, so when I connect I just use localhost:7890). Reverse tunneling just means you'll initiate the SSH connection from the remote machine to your local machine. This will require your local machine to need an SSH server. If he can't connect to arbitrary ports, then he can't connect to arbitrary ports. None of this matters.
&gt; If the entire output of crypt() is stored in the database then they know exactly what type of rainbow table to build to work towards finding out plaintext passwords. That doesn't really make any sense. Rainbow tables are used when you have a known salt (or null salt) which is being reused for a lot of hashes. If the salts are different for each hash, then you just brute force until you get it. No point first making a table which will require you to cover the entire search space. &gt; If the details of the hash generation process are a secret that only the application source code knows, then it's much more secure, right? It's usually pretty easy to narrow down which hash algorithm is being used. They have different field sizes and encodings. Using an invented, non-standard hash is almost always a horrible idea. The common ones have been examined by many sets of eyes behind which sit extremely gifted brains.
What does that mean? Whether or not the salt is constant, you still only have to crack one password to get "in the system", if you attack an account with sufficient privileges.
And for those curious as to the output: http://codepad.org/M2827Jnd
&gt; It's mostly people not protocols or tools reading the code, If users have to read or modify source code to deploy a plugin, you've failed at creating a robust plugin system. In the case I described, unless you're a developer hacking at a plugin, you would never need to read anything at all. Your plugin system requires configuration details to be done in actual source code - and XML is not source code - and that's a major failing in my opinion. It also requires a lot more documentation because it's not immediately self-documenting what each hook will pass or expect as a return value (something handled by my idea in that each extension point can use an interface to decide). Your system makes a bunch of sense, but I don't think it's as robust or user friendly as one that I described. Whether it makes sense to build a massive system like I described or a smaller, less robust one like you've described would depend entirely on the scope of the project. For a CMS, I don't think what you've detailed is anywhere near as powerful or useful or easy to use.
In the case of MySQL, it will cast parameters as necessary, so if you always quote everything, you're actually not fucked. Just running more slowly.
&gt; I have used simple JQuery plugins for expanding and collapsing before, but to my knowledge they don't work with PHP because of the client-side and server-side relationships. Your PHP can send the content and the javascript to the browser, which then does what you want on the client side. Wrapping your head around this is kind of the central eureka of developing modern web applications.
&gt; BCrypt is Blowfish. It's not blowfish. It's some parts of blowfish (which itself is not a hashing algorithm), adapted to produce a hashing algorithm. One which, to my knowledge, has not shown any significant signs of wear.
You can do strange things with closures + you could make the result as an image.
I don't think that will be so easy to integrate, so it sounds like my best option is to get a VPS and make an API.
At the end make a [phar](http://www.php.net/manual/en/book.phar.php) archive out of it.
Just use a public variable in a standard class.
I use it to keep my controllers tidy. After writing my models, I treat them as a kind of "black box" of functionality that I can use multiple times in any controller I wish, without having multiple copies of the same code. I'm no professional, and there are more reasons I am sure - but it is reason enough for me to use them!
Models handle fetching data and returning it to the controller. It could be from a database, it could be from an XML file, it could be from a CSV file or a directory or whatever. For most frameworks the models implement some sort of ORM, which means a basic model really needs no code, you can just use it as such: $order = Order::find( 1 ); You can probably see how this is better than dealing with the database in the controller. Beyond that the reasons for a model are to seperate functionality to facilitate code sharing and an easier to read codebase. For example, by having a split out model (presumably inheriting from some base class that handles talking to the database), you can easily switch which database you are using (or even switch to using something other than a database) by updating code in just one place. Beyond that, the business logic idea is correct. For simple cases there may not be much business logic. But the idea is that when your controller asks a model for data, the model then can do whatever is necessary when returning that data. That means, rather than returning raw data from a DB, it may modify that data. A common simple case of this would be if you have a person table with first and last names, and you want to format a full_name field from that which will always have the same format no matter where it is used. More complicated models go well beyond that and may deal with things like access control to data, formatting currencies, phone numbers, etc, providing validation on their data attributes, manipulating data from multiple sources, etc etc. By isolating these things in the model, you ensure that no matter where that data is used it is always in the proper format. In contrast, if you do that work in the controller or view, then you end up with a lot of duplicate code or the potential to have to update things in many different locations, which quickly becomes unmaintainable. 
In MVC, the controller is the main arbiter of all the actions in the request. If you're using MVC, it could be assumed that your business objects know how to handle their own persistence. For example, if you had a class User, it would be much easier from the controller to call $userInstance-&gt;save() rather than make the CRUD directly in the controller. Such code can become impossible to maintain after a few updates. Simply put, the controller's only job is to coordinate the interactions of business objects and render output to the views. The controller should never decide business rules within the program. For instance, if you need to determine if a User has registered for something, you wouldn't do that in the controller. You do that in the model and return a response. All the controller should do is call $user-&gt;isRegistered(). The split between model and controller can become very vague if not properly used, but keeping things in order will allow for more modular and portable code.
Do a print_r($chkOwnSql) and then put the output into something like phpmyadmin or on the mysql command line. If there is an error you will see it. You seem to be using $_POST as $POST in some places. Also, I really hope you are cleaning these vars. The code you posted is a major hack waiting to happen. Should look more something like this. I use oop, so you'll have to change the function names to the procedural way. Prepared statements are the preferred way to prevent sql injection. $sql="INSERT INTO reviews (title, platform, author, text, rating, datePosted) VALUES (?,?,?,?,?,?)"; if($stmt = $mysqli-&gt;prepare($sql) { $stmt-&gt;bind_param("ssssss", $_POST['gameTitle'], $_POST['platName'], $curUser, $_POST['revText'], $gameRating, $curDate); $stmt-&gt;execute(); $insert_id = $stmt-&gt;insert_id; $stmt-&gt;close(); if($insert_id &gt; 0) { return $insert_id; }else{ return false; } }else{ return false; } 
[Please see here](http://www.reddit.com/r/PHP/comments/gk7le/i_just_dont_get_mvc_or_oop/c1o8457)
&gt; If users have to read or modify source code to deploy a plugin Surely enough deploying the plugin would have to work in Copy &amp; Forget manner. However.. &gt; unless you're a developer is where our views differ. If end user wants to tweak the system I expect one to know basic PHP (Yes Graphic Designer, you too) or have system implementing GUIs accordingly. &gt; Your plugin system requires configuration details to be done in actual source code Valid argument. This can be alleviated by having plugin config files for non default cases in your application directory. (that is, where all page specific information/customization resides.) &gt; and XML is not source code Often XML can be more cryptic then it's underlying purpose. The aforementioned XML would become the following line in PHP: on('page.body.layout.column_1','Plugins\Markdown'); //or even chained, if that would make it more readable on('page.body.layout.column_1')-&gt;run('Plugins\Markdown'); &gt; it's not immediately self-documenting This is indeed an issue, unless developer has written a throughout documentation. I do like however (and both hate) the idea of interfaces. I can clearly see it solving the issue, at a cost of additional dependency though (thus overhead, albeit for a small amount of interfaces - small one). 
You're going to have to be *a lot* more specific than that.
Ok well, I have 28 fields (columns) in my database. I found out how to export the data to csv, xml, excel, pdf etc. but when I do, (as you already know) this exports all the fields as shown in PHPMyAdmin, horizontally, in a table. I would like to know how to easily output that data so it would show like this: First Name : Herpina Last Name: Derpster Birth date: 19/03/1978 Instead of: First Name Last Name Birthdate Herpina Derpster 19/03/1978 Not sure if I'm clear...sorry if my explanations are not really tech-savvy... 
&gt; is where our views differ. If end user wants to tweak the system I expect one to know basic PHP (Yes Graphic Designer, you too) or have system implementing GUIs accordingly. If you look at all of the most popular and successful php projects - MediaWiki, Wordpress, Drupal, Joomla, Magento, etc. - you'll notice that they all have one thing in common: no PHP knowledge needed to deploy, use and customize. By requiring PHP knowledge, you severely limit a product's target market. And not only to non-developers! Why should a .NET developer have to learn a language he will likely never otherwise use to write a blog for his friends? &gt;Often XML can be more cryptic then it's underlying purpose. The aforementioned XML would become the following line in PHP: Sure, but let's not sell the XML short either. Some of the things you can do with the XML that you can't do with a PHP method (or without a serious investment of time that XML wouldn't require): * Web-page configuration - no need to edit any files. * Interactive plugin deployment and customization. * Easy visualization of a page request. * Better debugging (easier to catch a faulty plugin from a configuration like this than an anonymous callback) and profiling &gt; Valid argument. This can be alleviated by having plugin config files for non default cases in your application directory. (that is, where all page specific information/customization resides.) So, in your case you have behavior defined in both a source file and a configuration file. In my case, it's defined always in a configuration file. I don't think I have to explain this any further. &gt; Often XML can be more cryptic then it's underlying purpose. That's a fault of developers, not the language. Surely PHP developers can sympathize. &gt;The aforementioned XML would become the following line in PHP: No, that would accomplish roughly the same thing. To properly convey the *exact same* behavior: $extensionRegistry-&gt;getExtension("request_retriever")-&gt;getExtension("page_generation")-&gt;getExtension("body_start")-&gt;getExtension("layout_manager")-&gt;getExtension("column_1")-&gt;registerExtension(new this\is\a\class\that\implements\some\Extension\interface()); Your system relies on some kind of arbitrarily namespaced hooks. My system is a hierarchical tree of extensions that are called in sequence to render a page. &gt;This is indeed an issue, unless developer has written a throughout documentation. There's an inverse correlation between the amount of required documentation to read and the amount of people using your software. Having great documentation is an absolute must, but users shouldn't be required to read it to do the most common things - your system should have been designed to accommodate that.
Do the formatting in html and have them print the page. Iterate over every row and format the results how you wish.
In the future, google docs spreadsheets are a good way to do this. They have a form builder, and all the results go into a spreadsheet.
Is this really a direct copy-and-paste of the code that you're running? If so, you're not pulling anything from the $_POST array, you're literally writing the string $POST[gameTitle] to the database. Your query should look like this: "INSERT INTO reviews (...) VALUES '" . $_POST['gameTitle'] . "', '" . $_POST['platName'] . "', and so on. I hope this is for a school project or something, because you should never ever ever be putting data directly from get or post into a SQL statement.
Their documentation sucks balls, and quite frankly I think it pales in comparison to Zend.
Yeah, I'm realizing that regarding their documentation. However personally I like the look of Kohana so far, I've always preferred a more minimalist framework (which is why I tend to steer clear of Zend, Symfony, etc.) I only wish Kohana was better documented and had more stability, it seems like each release can knock out or re-implement any feature at random.
This code is nearly criminal. You WILL get hacked. 
Most 3.0.x tutorials will break in 3.1.x. I suggest you keep the [migration docs](http://kohanaframework.org/3.1/guide/kohana/upgrading) handy. When I learnt the framework, I first read the official docs which were pretty invaluable. They're better now than when I started and have plenty of examples. Then I used the [unofficial wiki](http://kerkness.ca/wiki/doku.php) to fill in a lot of blanks missing from the docs. After that it was just IRC, Stack Overflow and reading source. Edit: Make sure you read the [getting started](http://kohanaframework.org/3.1/guide/kohana/) at a minimum. Pay particular notice to the cascading filesystem stuff. Half the beauty of Kohana is extending the base systems which Kohana makes very easy for you.
You should probably read a little about object-oriented programming before learning the MVC pattern. You don't need to read too much into it, just the general concept. Models typically represent what an object is like in the real world. For example a "blog post" model would represent an entry in a diary/journal. **Real vs. Model** * New sheet of paper * $p = new BlogPost() * Write down date * $p-&gt;date = "24/04/11" * Write out entry * $p-&gt;entry = "Blah blah bla!" Using a model is never more work than calling the database from the controller and is a tried and tested best practice. It keeps the code cleaner and easier to maintain. You can call the database directly from a controller if you only require a simple query like SELECT 'sitename' FROM 'settings' WHERE 'siteid = 1' but even then you could have a "site" model which has a function for getting the site name. ($s = Site-&gt;find($id = 1); $s-&gt;sitename).
If you are not committed already I highly recommend trying out fuelphp. It takes the best idead of kohana, rails, and codeigniter and blends them together in php 5.3 goodness. Its in 1.0 release candidate right now but its really stable and they have good docs (soon to be even better). Seriously take a look. http://fuelphp.com
I have a pretty decent understanding of CSS and HTML and am attempting to learn PHP to make my sites more dynamic.
The first framework since CI that actually looks documented half decently, not bad.
I'll be honest, I'm a little weary of such a new framework. It seems like we see a new framework every other month, and most die pretty quickly. While fuel looks pretty promising at first glance, I'm a little worried about the long run and how much I'll get out of the time I spend learning it. I'll be giving it a try though I suppose.
This is pretty much the path I took. I was hoping for one consolidated view of what I would need, but there doesn't really seem to be any. Maybe I'll write one if I end up liking Kohana
Yeah but this one has some of the core contributors from the CI community behind it (dan horrigan &amp; phil sturgeon). I cant see this fizzling out anytime soon.
Yeah and there is a big push in the next couple of weeks to make the docs even better.
Alot of non Kohana users say "Kohana's docs suck". Not because they have taken the time to look themselves, they just repeat what other non Kohana users say. This is a pity because IMO it scares people away from Kohana. Read: http://kohanaframework.org/3.1/guide/kohana/install http://kohanaframework.org/3.1/guide/kohana/conventions http://kohanaframework.org/3.1/guide/kohana/bootstrap http://kohanaframework.org/3.1/guide/kohana/routing http://kohanaframework.org/3.1/guide/kohana/mvc/controllers http://kohanaframework.org/3.1/guide/kohana/tutorials Once you learn the basics of how Kohana operates (HMVC, routing, config, autoloading etc), its simply a matter of looking at modules and seeing how they work. Please ask if you have any specific questions : ) .
I'd be willing to pitch in. I'm not in your area, not by a long shot, but judging from the link I don't think you need instruction on anything that complicated.
Continue with any arguments is a bug, in my opinion. There are other mechanisms for achieving the desired effect without confusion.
Where is the loop you speak of? Also, SQL injection is one of the easiest exploits to prevent. Please consider using bing parameters.
http://www.agavi.org
&gt;mysqli_ functions are faster than either. The difference between PDO and mysqli are [negligible](http://jonathanrobson.me/2010/06/mysqli-vs-pdo-benchmarks). I even did some benchmarks of my own a couple of weeks ago and neither has an edge over the other. 
fyi, i'm building something similar to this over at http://getfoundation.com in PHP. Site sucks right now but I'm about to do a big push in a couple weeks. If you need help with anything, I've probably already tackled the problem, so you can hit me up for advice or help.
That's ORM/Crud not model.
Well, you've been pushing FuelPHP very hard on /r/PHP so your intentions might not best fit those of the author. I can't imagine the fuelPHP community would be as large as that of Kohana's. You can readily get help from #kohana on Freenode and questions asked on StackOverflow get answered within hours (most of the time).
Kohana used to be messy with API changes in the 2.* era, but that's changed with the 3.* series. All you need to know is 3.0 and 3.1 are API breaks (the 2nd number is a major version), but if you went from 3.1.0 to 3.1.9 you'd be fine. Do feel free to pop into the #kohana chatroom on Freenode or even ask questions on stackoverflow. 
I have only because I believe it has the most promise out of them all. 
thanks heaps, I'll pm you if I get stuck on something. ".co.cc" is just a free domain that I'm using so I don't have to pay for anything while I'm testing if that's what you mean by not being in my area.
Site looks awesome, your help would be appreciated, I'll pm if I get stuck, thanks heaps again.
&gt; For selects, MySQLi was about 2.5% faster for non-prepared statements and about 6.7% faster for prepared statements. 6.7% is worth it to me. Especially when PDO provides no additional value that I can see.
&gt;6.7% is worth it to me. Like said, I ran a few benchmarks a couple of weeks ago, and neither had an edge over the other. They were almost exactly the same. Sometimes mysqli was faster by a slight, and sometimes PDO was faster by a slight. I ran 1000 iterations of different methods (INSERT, SELECT, prepared statements etc.) something like 10 times. It doesn't make any real difference which one you choose to go with (because 10ms really doesn't matter), as long as your comfortable working with that tool. &gt;Especially when PDO provides no additional value that I can see. * PDO is an abstraction layer which provides a common easy-to-use API to multiple databases. * PDO uses the same native code as mysqli does for its mysql driver. Quoting Ulf Wendel, the lead developer behind the mysqlnd driver: &gt;"Any of the PHP APIs are just tiny wrappers on top of the underlying C libraries. Mapping from the C call to a PHP call is always about about equally fast no matter how you do the mapping - in ext/mysql, ext/mysqli or PDO_MYSQL. If you compare equivalent PHP API calls with each other they should be very, very close together in performance. &gt;[...] Moral is, forget about API performance. There's not much to squeeze out of how you map the very same underlying C library calls into PHP API calls. But it can help a lot to use proper API calls for the task. "
Just make the jump and get a VPS. You'll never look back. Shared hosting is awful.
I am a huge fan of Kohana. And the docs are improving. However, they still suck. I almost always find it faster to read the source then look in the userguide. I actually dread having to go to the userguide, I rarely find what I am looking for and there is rarely example code. The lack of any established model/validation pattern drives me insane. 
Send certification is surely worth it. Buy the send certification book and study that well.
&gt;Send certification is surely worth it. Buy the send certification book and study that well. -Powloki
Would it be helpful? Yes. Is it essential? No I got a Senior PHP job without one, but things are most likely more fierce in Silicon Valley than in Kent.
It's utterly negligible. The speed differences are minute, and it's far better to write portable, maintainable code with PDO than fuck around with mysql and mysqli.
You could mess around with the following idea. It's totally awesome that you are trying to write your own framework. Personally, I've written several over the years, but I've never used one in a production environment. Write a framework to learn...not to re-invent the wheel. public function controllerAction() { $view = new StdClass(); //create a view object. $view-&gt;title = 'User List'; $view-&gt;description = 'A list of users.'; $view-&gt;users = Model_User::list(); $this-&gt;renderView('user-list.phtml', $view); } public function renderView($template, StdClass $viewables = null) { extract((array)$view); require_once($view); } // view.phtml &lt;title&gt;&lt;?= $title ?&gt;&lt;/title&gt; &lt;?php print_r($users) ?&gt; 
Just to check, you are using parametized prepared statements with PDO?
I like to use a layout for each controller (usually a default one for every controller) and a view for each action. The view should only deal with data specific to it's action. If you write HTML from the controller there is not much point in using MVC.
Yes I realise this, hence my enquiry on the subject ;-)
You could do the app free then be payed for support, on the basis that you are using them as a guinea pig.
This is a pretty nifty idea, very similar to method I was using before. However I'm guessing this does require a separate view file for every state of the web application, so you would create a copy of this one and tweak it for, say, a list of news items, and again a tweaked copy for a list of something else. Then a tweaked copy is made for the detail view of a particular user, and another is made for the edit view of a user, and the add view, and the same for the news section etc. So, how would you go about getting rid of the duplicated elements, or what you might consider the standard aspects of each View file (like the header and footer) and replacing them with some sort of reference or call to a "view-part" file that contains this standard code?
Here's my approach for that... the key is the output buffering. You need to capture the output from your template (which only has content pertaining to your specific controller action) into a variable. That variable can then be used in a global "layout" file. Below is a sample "View" class: public function render($withLayout = true) { $templateContent = $this-&gt;getOutputFromTemplate($this-&gt;template) ; if ($withLayout) { print $this-&gt;buildLayout($templateContent) ; } else { print $templateContent ; } } private function getOutputFromTemplate($template) { if (is_file(APPLICATION_DIR.'/views/'.$template)) { extract($this-&gt;vars) ; ob_start() ; ob_implicit_flush(0) ; require(APPLICATION_DIR.'/views/'.$template) ; return ob_get_clean() ; } else { throw new Exception('Could not find template '.APPLICATION_DIR.'/views/'.$template) ; } } private function buildLayout($templateContent) { $layout = $this-&gt;layout ? $this-&gt;layout : 'layout.phtml' ; if (is_file(APPLICATION_DIR.'/views/layout/'.$layout)) { ob_start() ; ob_implicit_flush(0) ; require(APPLICATION_DIR.'/views/layout/'.$layout) ; return ob_get_clean() ; } else { throw new Exception('Could not find layout file '.APPLICATION_DIR.'/views/layout/'.$layout) ; } }
You wrap everything in a topmost View. This CAN be done manually every time: $top_view = View::factory('layout'); $top_view-&gt;content = View::factory('content'); So the actual layout simply echo's the $content variable. But ideally you want to streamline this whole process. FuelPHP for example offers a Controller_Template class, that you extend, that has an instance of the layout view already set as a property, and you simply do this from within the controller. $this-&gt;template-&gt;content = View::factory('content'); You can have a look at template controller class for FuelPHP here: https://github.com/fuel/core/blob/master/classes/controller/template.php And for the Slim micro-framework: https://github.com/codeguy/Slim/blob/master/Slim/View.php
The certification can help get past HR in some companies. I wouldn't hire someone based on them having (or not having) a certification, though. Give me a GitHub account instead: I'll decide if you're cut out for the job from that much better.
So, if someone uses borland c++ from 1994 to compile the code they get from Gambit Scheme, and you say "but there's a better compiler these days which gives stricter, faster, smaller binaries and catches more errors, this toolchain is bcc but it should be clang/llvm," do you say "this isn't bcc, it's something that's adapted bcc to produce scheme binaries, one which to my knowledge has not shown any significant signs of wear?" When someone tells you where to find a 400 page PDF by the algorithm's author full of signs of wear, why do you just not read it, then point to your ignorance of the contents as evidence that there's nothing wrong? I don't want to play semantic games with you. Fine, it's not blowfish, it's built on blowfish. Mince around the phrasing however you want; you know perfectly well what I meant. When you haven't even attempted to read the documentation that's available to you, what your knowledge lacks is not useful in terms of discussion. There have been more than 20 years of signs of wear from techniques which apply to all cryptosystems. If you knew what you were talking about, the signs of wear would be apparent even if you didn't know how blowfish worked, just from in what year it was invented. Please let this one go. I'm not interested in someone putting in effort to not know things, then to hold up their not knowledge as supportive. Lack of knowledge doesn't actually impress.
If you're not familiar with mvc, this reddit [comment](http://www.reddit.com/r/PHP/comments/gk7le/i_just_dont_get_mvc_or_oop/c1o5lja) sums it up.
My opinion: As an entry-level applicant, any additional qualification to give you a leg up on the competition is good, but factor the cost of certification into your decision given that it will only be important to some employers. Worth $195 for an entry-level applicant, plausible. Context: I had been writing PHP profesionally for about 3 years when Zend offered the certification test at no cost to attendees of conference in which I was participating. I took it without any preparation, and have had the certificate sitting in a frame on my shelf since a couple weeks afterwards. I have never met an employer that has asked about it, and I can't say that it has really done anything for my career other than perhaps providing some self-confidence.
Current PDO is 5 or so percent slower than raw queries. That's not the issue. PDO is a portability library. If you aren't already very good at SQL, portability in SQL is a bastard of a thing - it makes the generation 4 javascript war look positively civil, and it's decades entrenched. If you need to be portable between databases, with the special exception of oracle and postgres, which use the same set of extensions by design (postgres was originally meant to be an escape hatch for oracle,) then a library like PDO is a good way for you to go, and PDO is a very good choice. However. If you don't care about portability, there's this other issue - PDO locks you down to most of portable SQL. What it's really doing are little well tested parse transformations, and there are some things it can't cope with. Furthermore, it locks you out of all the vendor proprietary stuff, and sometimes vendor proprietary stuff is important - like if you're using geolocation, like a dating site would to find nearby matches, or so on. You seem performance focussed. Most people shouldn't be - they should be more focussed on learning to do SQL in non-retarded ways, rather than merely correct ways, because there they're going to find orders of magntitude of improvement in getting their index elements in reasonable order, in eliminating unnecessary branch searches, in patch exclusion, in knowing about how these things actually work. But. *If* you already have all that nailed down - and going by the questions you're asking, you don't, just saying for completeness' sake - then using a native interface can give you tools which can have a moderately large, but usually linear, impact on speed. Bulk insert is a good example. Every database has a bulk insert notation, and the performance impact can be huge even on a table without indices; with indices, especially complex indices, potentially enormous. But the way they each work isn't just a notation change; they're conceptually incompatible in some cases. So PDO doesn't try to model that. And that's a big loss. It's not alone. I mean, look, if you're *really* speed sensitive, you aren't writing PHP at all, but rather some compiled language with a focus on efficiency, and you're using the binary interface with compiled procedures and parameter binding.
Wait... being from Texas I didn't know there were actual *homes* in Silicon Valley
I'd like to see those benchmarks. I'd like to see how they address the performance-related behaviors available in mysqli_ but not available in PDO, such as bulk insert. Benchmarks for maximum speed shouldn't compare equivalent behavior, but rather best available behavior.
Github? I didn't know this was Ruby discussion. 
I will share this... It is using CodeIgniter, but i think it makes the point... This is the main_template.php file: &lt;?php $this-&gt;load-&gt;view('includes/header'); ?&gt; &lt;div id="cpanelwrapper" class="cpanel"&gt; &lt;div class="cpanel-left"&gt; &lt;?php if (is_array($lefts)) { foreach($lefts as $title =&gt; $content) { ?&gt; &lt;div class="cpanel-left-box"&gt; &lt;div class="cpanel-left-box-header"&gt; &lt;span class="header-text mycollection"&gt;&lt;?=$title?&gt;&lt;/span&gt; &lt;/div&gt; &lt;?=$content?&gt; &lt;div class="cpanel-left-box-footer"&gt;&lt;/div&gt; &lt;/div&gt; &lt;?php } } ?&gt; &lt;/div&gt; &lt;div class="cpanel-right"&gt; &lt;?php if (is_array($rights)) { foreach($rights as $title =&gt; $content) { ?&gt; &lt;div class="cpanel-right-box-header"&gt;&lt;span&gt;&lt;?=$title?&gt;&lt;/span&gt;&lt;/div&gt; &lt;?=$content?&gt; &lt;div class="cpanel-right-box-footer"&gt;&lt;/div&gt; &lt;?php } } ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php $this-&gt;load-&gt;view('includes/footer'); ?&gt; With that, in my controller I setup these various areas: $data['rights']['Filter Sales'] = $this-&gt;load-&gt;view('modules/filter', $data, true); $data['lefts']['Items For Sale'] = $this-&gt;load-&gt;view('modules/items_forsale', $sales , true); and then at the end... $this-&gt;load-&gt;view('main_template', $data); $data['rights'] could in theory be a big array of different "modules". The key part is the third parameter passed to $this-&gt;load-&gt;view. It is 'true' and that will return the rendered HTML as a string instead of adding it to the output buffer. This promotes code reuse. Meaning that anywhere I want "modules/filter" I just "include" that piece. Writing good flexible HTML is just as important as having a good templating engine. If you write HTML that cannot be easily stretched and extended then you will be painting yourself into a very tight box. And my 2cents on writing your own framework... If you are doing it as an exercise in learning the ins and outs of a framework and what pieces are needed, then you are doing it right. I believe that if you are writing the framework as the first step to starting a project then you are putting yourself at a disadvantage. Writing a framework is no simple task. Lets say it takes you two weeks to write a framework, that is two weeks you could have spent writing your application. You will be just reinventing the wheel. And if there is any additional logic you need, any good framework should allow you to easily extend it.
I won't get hacked because its not going online. It's purely local dev for a school project.
Thanks, and yes its for a school project. I don't think the problem is with the sql tbh, otherwise I'd have put it in the sql subreddit.
I have written a small PHP5 MVC framework ([Belokan](http://gitorious.org/belokan)) for my own usage, it's open source so you can read the source code. I think it's pretty easy to understand how it works :-).
I would check out how other frameworks handle this. FuelPHP is a modern, light PHP framework which would be a good example. But as a high level overview... Typically most frameworks implement a master layout template (which can be overridden per controller or action when needed) that holds the common stucture and layout of the application. Typically it also gives a means for individual views to add common things such as css/js files, error/status messages, etc. And it contains blocks to output lower level content, such as individual page content, navigation links generated elsewhere, etc. Then, you have a view for each action in each controller, organized in a logical directory structure. These handle the output of each action, and yes you end up creating a lot of them, but the alternative method is one view to rule them all with a bunch of if and switch statements, and that gets ugly FAST. To handle the fact that many individual content views may share a lot of the same things, most frameworks provide helpers and partials. Helpers are essentially functions/methods which can be called in a view to do common things. Most frameworks ship with a set of stock helpers, which handle things like pagination, html helpers, form helpers, etc. Partials are essentially view fragments you can include in any view, and handle displaying things that may be needed in more than one view (for example, your main navigation, or the output for formatting a user profile, etc). 
CakePHP offers three levels of View to work with. The topmost level is the layout. This contains most of your page structure minus the content area. Then you have your view for your action specifically. The results of this are rendered into the content area of the layout file. Finally you have "elements". These are self-contained chunks of HTML/viewlogic that you can call from any view. Most MVC frameworks seem to follow this general structure.
It's enclosed in " and not ' so those post vars (except where he used $POST and not $_POST) should be getting parsed
You're inserting $POST[gameTitle] (which doesn't exist) but selecting where title= $_POST[gameTitle] Fix all $POST to $_POST and I guess it would work.
I just woke up so I'm probably still dumb, but it sounds like you need to implement a layout system. That way each view is only the most relevant content in `#content` (or whatever) and gets passed back into a layout file (the specific layout used being determined by the controller).
It looks like you have messed it up a bit. Lemme explain what i mean by that. . The business logic **must** be in the Model. That is reason for this part in the MVC triad. As it is, right now you Model actually sounds more like an DB abstraction layer ( something along the lines of [data mapper pattern](http://martinfowler.com/eaaCatalog/dataMapper.html) ). As for View - it contains the presentation/display logic of the page. For each Controller class there is only one View class ( 1:1 relationship ). And the View can use multiple Templates ( how to make a simple php templating thing - read [here](http://codeangel.org/articles/simple-php-template-engine.html) ).
I've created my own little mvc framework which I frequently use for lightweight projects. This is how I handle the view: On controller initialisation, a view object is created and associated to the controller. The dispatcher calls controller-&gt;display() after the controller is done. The controller's display() method then calls the view's output() method which includes the view's phtml file. This way I can specify different views for ajax requests. Just like the Zend framework, I can add .ajax.phtml view files to respond to ajax requests: if(Controller::get_instance()-&gt;isAjax()) { include($this-&gt;viewfile . '.ajax.phtml'); } else { include($this-&gt;viewfile . '.phtml'); } The view gets data from the controller and has magical get and set functions storing data into an array. Within the controller I do: $this-&gt;view-&gt;setTitle('Page Title'); $this-&gt;view-&gt;dataname = 'somedata'; And within the view's phtml file I do: &lt;head&gt;&lt;title&gt;&lt;?php echo $this-&gt;_title; ?&gt;&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;p&gt;&lt;?php echo $this-&gt;dataname; ?&gt;&lt;/p&gt;&lt;/body&gt; I've also splitted header and footer into seperate include files. I don't know if this way is best practice, but it works for me.
I dunno -- it seems pretty relevant, if I were looking for PHP programmers I'd look for people who don't use PHP as their primary programming language.
Thanks, but this is just a local dev project, I don't plan to put it online. I want to keep the method I'm using, not change it to code I don't really understand thanks. 
Alright, not a loop, an if statement to check if the user is reviewing a game they don't own. Yes I'm aware of the dangers of SQL injection thanks, but not aware of how to prevent yet. This is just a local dev project.
Yeah, thanks but that's not the answer :( I've added the missing _'s but it still doesn't seem to work =/ The alert still pops up even when adding a game that the user owns.
Why would I be looking for a framework if I wasn't familiar with mvc? It's just Kohana specifically I need to learn. Still, thanks for the link. That's a great summary of the basics of the mvc structure
Thank you very much for the comment, however as someone who is currently reading through the documentation I have to say there is a fair amount of truth to all the bashing of Kohanas docs. I've seen a lot worse, but there is definitely room for improvement. I think I'm actually learning more just by experimenting around with it.
Here are the printed results for $sql and $chkOwnSql in that order. INSERT INTO reviews (title, platform, author, text, rating, datePosted) VALUES ('Half-Life 2','PC','Jeklah','great','1','2011-04-24') SELECT * FROM userownedgames WHERE username = 'Jeklah' AND title = 'Half-Life 2' exactly what I thought/wanted, so the sql isn't the problem here. 
Yeah, the flip side of the documentation issue is that I find I learn a LOT from reading the source, and delving into the tracker/forum discussions explaining why stuff is the way it is. A thing I really like about Kohana is that, while I may not like a change or the way something is done, I can be certain that smart people have thought hard about it, and done it better than I would have. 99% of the time I was wrong, the Kohana was right. Just because I think I want it to do X, doesn't mean it should do X, or that I would even want that if I understood the issue. Vs, oh, say, wordpress, or CI in which the reason why a thing in the way it is will have exactly nothing to do with what is right. :)
We're currently working on releasing the framework we made for TwitPic, and the general way we handle views is to make all class variables in the controller available to the view. Since we're highly geared towards efficiency, we don't use normally use templating engines. So in the controller you would do: public function show() { $this-&gt;var = "data"; // one way of loading a view $view = new View("user/show.html"); $view-&gt;render(); // another way of loading a view View::respond_to("html", "show.html"); } Then in the view you can simply do: &lt;? echo $var; // outputs "data" ?&gt; The way we do that is by storing all class variables in an array in the Controller class, then we call the PHP extract() function on that array to move the data into the scope of the view. Hope that helps!
Ok, I think your problem is the if(!mysqli_query(..)) stuff. You should first of all remove the ! as it's asking the wrong question. The "else" will ALWAYS be executed if the query is *successful* (it becomes if(not true) {} else {}) Second, you're only checking the success or failure of the query. AFAIK, returning zero results doesn't mean a query failed, so you need to check mysqli_num_rows($result) to make sure more than one result was returned.
Heh. Yeah, you're right about me geting the ! in there when it shouldn't be...dunno how I thought that. Cheers. Also yeah, I guess I didn't think that a query that returns zero results would still be a successful query. Cheers. I will make these changes, see if I can get it working.
Ok there are a number of things wrong with your code, you need to do something similar to this, $res = mysqli_query($dbconnection,$sql); if(!$res){ echo mysqli_error()); } if( mysqli_num_rows($res) !=0){ echo "this game is in your list"; }else{ echo "this game is not in your list"; } 
Most MVC frameworks such as Rails and Express.js have what is known as a partial, these usually represent something like a blog post in list format so it can be used on the site of blog posts in lis and other places, but partials can also be used for headers and footers. In frameworks without partial support as CodeIgniter you would call extra views from within the template itself. EG Controller: &lt;?php blog_controller { function view() { $data=array(); $data['blog_post']=$this-&gt;Blog_model-&gt;get_from_id(123323); $data['title']='Hello $this-&gt;load-&gt;view('blog/view',$data); } } ?&gt; Then in the view &lt;?php $this-&gt;load-&gt;view('header');// load header echo $title; $this-&gt;load-&gt;view('footer'); //load footer 
&gt; So, if someone uses borland c++ from 1994 to compile the code they get from Gambit Scheme, and you say "but there's a better compiler these days which gives stricter, faster, smaller binaries and catches more errors, this toolchain is bcc but it should be clang/llvm," do you say "this isn't bcc, it's something that's adapted bcc to produce scheme binaries, one which to my knowledge has not shown any significant signs of wear?" Not analogous. Weaknesses that affect blowfish's suitability for its intended purpose may or may not affect bcrypt's suitability for its, different, intended purpose. &gt; When someone tells you where to find a 400 page PDF by the algorithm's author full of signs of wear, why do you just not read it, then point to your ignorance of the contents as evidence that there's nothing wrong? Are you serious? You are asking me why I didn't go read a 400-page PDF on a related-but-not-identical topic so that I could play Reddit-penis with you? Serious security consultants who stand behind their own names recommend using bcrypt. If you can articulate a specific argument as to why using bcrypt for password hashes is not a good idea (not hand-waving or telling me to shut up until I have a PhD in mathematics, but specifics) — or point to a known, respected authority who says it — then we're getting somewhere. Otherwise, you may or may not have a point, however your approach is anything but persuasive.
&gt; PDO is an abstraction layer which provides a common easy-to-use API to multiple databases. It's an API that can't provide any of the specific API improvements that individual databases have, and which doesn't solve the more fundamental problem that SQL which doesn't a specific database is going to perform a lot worse in many cases. &gt; PDO uses the same native code as mysqli does for its mysql driver. Why would that provide any additional value to me?
&gt; Are you serious? You are asking me why I didn't go read a 400-page PDF on a related-but-not-identical topic It's not on a related but not identical topic. And no, I'm asking you why you think your not knowing something matters when you aren't trying to fix your not knowing. If you don't want to read the material, that's fine; just don't try to hold yourself up as having valid anti-knowledge which should support your explicitly driven from ignorance claim. "I don't see why I should switch." "This paper tells you why." "I'm not reading it, and I still don't see why I should switch." (sigh) And then? &gt; so that I could play Reddit-penis with you? Oh, right, I forgot, when you charge in and argue on a conversation between two other people that because you don't know any better someone else should be ignored on a topic you admit to having not studied, it's because *they're* playing pompous. &gt; Serious security consultants who stand behind their own names recommend using bcrypt. Name one. &gt; If you can articulate a specific argument as to why using bcrypt for password hashes is not a good idea This isn't what I said. Please work on your reading comprehension. I already went into great detail the last time someone falsely claimed that this was what I said to explain the difference between "this is good but there is better" and "this is not good." &gt; (not hand-waving or telling me to shut up until I have a PhD in mathematics, but specifics) A four hundred page PDF by the algorithm's author is sufficient. I have no reason to explain it to you as would a paid tutor, especially while you're behaving this way. &gt; Otherwise, you may or may not have a point Yes, one of the problems with refusing to read foundational material is that your conclusions are always "I don't know whether you're right." It's sort of amazing to me that you think that is a criticism, rather than something you're expected to say. I am not wrong, or failing, merely because you refuse to read the reference. &gt; your approach is anything but persuasive. My goal was not, and will never be, to persuade people who cannot be bothered to learn about the material they're trying to discuss. If you attempt to criticize me on the basis that I have not sufficiently spoon fed you, all you will earn is derisive laughter. Please stop insisting that I am required to tutor you. Have a nice day. 
Thanks, but I've figured out a solution now :) Heres what I got, it seems to work. if (mysqli_num_rows(mysqli_query($DBConnect,$chkOwnSql)) &gt; 0) { if (!mysqli_query($DBConnect,$sql)) { die('Error: ' . mysqli_error($DBConnect)); } else { echo "1 record added"; echo '&lt;meta http-equiv="refresh" content="2;url=http://localhost/Project/members.php"&gt;'; } } else { echo "&lt;script&gt;alert(\"It appears you are trying to add a review for a game you don't own. Please can you add the game to your owned list, or not review games you don't own.\");&lt;/script&gt;"; echo '&lt;meta http-equiv="refresh" content="2;url=http://localhost/Project/addUserGame.php"&gt;'; }
Yep you were 100% right. Here's my solution, and thanks again :) if (mysqli_num_rows(mysqli_query($DBConnect,$chkOwnSql)) &gt; 0) { if (!mysqli_query($DBConnect,$sql)) { die('Error: ' . mysqli_error($DBConnect)); } else { echo "1 record added"; echo '&lt;meta http-equiv="refresh" content="2;url=http://localhost/Project/members.php"&gt;'; } } else { echo "&lt;script&gt;alert(\"It appears you are trying to add a review for a game you don't own. Please can you add the game to your owned list, or not review games you don't own.\");&lt;/script&gt;"; echo '&lt;meta http-equiv="refresh" content="2;url=http://localhost/Project/addUserGame.php"&gt;'; }
that works by you are doing the query twice, once to check the number of results and another the check if it failed or not. change your first bit to $res = mysqli_query($DBConnect,$sql); if (!$res) { die(mysqli_error()); } if (mysqli_num_rows($res) &gt; 0) { 
&gt; However I'm guessing this does require a separate view file for every state of the web application Well, there can be a difference between the view and websites template--I gather you figured out a contemplating solution already. Assuming you're not repeating your site layout in each view, the answer is "yes" each controller action will most often have it's own view. That's EXACTLY what you want to happen--otherwise you're application will end up being a confusing mess. To make like easier you can setup a convention to have your framework automatically look for the existence and load a specific view--the convention could be .views/controller-name/controller-action.phtml. This way you wouldn't have to manually specify the view in each controller action. Note however, you always want to be able to specify a different view file manually. Often I'll have an add() and edit() controller methods but only one add-edit.phtml view file. Remember, there is no point speeding up your coding time, if the end result is less-maintainable/messy. 
&gt; It's not on a related but not identical topic. From what you said, it was a paper about why Blowfish may have weaknesses. That's related to bcrypt, but it's not about bcrypt, because Blowfish has a different purpose from its derivative bcrypt. I know you like analogies, so here's one: People have been using Compound X to treat bacterial infections. Someone comes up with a way to modify Compound X to treat viral infections. It is later discovered that the bacteria have evolved a resistance to Compound X. You point me to a 400-page paper about this, as evidence that the Compound X derivative should not be used to treat viral infections. &gt; Oh, right, I forgot, when you charge in and argue on a conversation between two other people that because you don't know any better someone else should be ignored on a topic you admit to having not studied, it's because they're playing pompous. I joined the conversation because what you were claiming didn't add up. After several more paragraphs of bombast, it still doesn't, because you haven't added a single shred of relevant evidence. You haven't considered to summarize how this 400-page paper supports the conclusion that using crypt for password hashes is a bad idea, leaving the strong implication that you are not able to. All you've said is "there is a long paper out there, and nobody who has not read it is fit to sit around the same table as I." I might as well say I've got a 1600-page paper that says you're wrong. &gt; Name one. At least a couple have already been cited above. &gt; Yes, one of the problems with refusing to read foundational material is that your conclusions are always "I don't know whether you're right." &gt; It's sort of amazing to me that you think that is a criticism, rather than something you're expected to say. I'm not sure what makes you think it's a criticism. It means exactly what I wrote: I don't know whether or not you're right, and after some iterations through the discussion, I don't feel any closer to knowing.
SHOW ME THE CODES
* **Modularity** - Break your problem into smaller piecce and re-use them better * **Version Control** - Don't lose what you made, and don't be afraid to make mistakes because you can always go back * **Unit Testing** - Don't lose 3 hours for a typo
It's not uncommon to find that someone looking for a framework is actually making the jump to mvc at the same time, this felt relevant (and I wanted really bad to share this awesome comment).
Look into using XSLT
Rather than make a View Only view, and an Edit Only View, and/or an Add View etc I usually create a single View[ObjectName], sometimes I do Manage[ObjectName]View separetely if its better to have a different presentation than a simple edit view for an editor or the object is complex enough such as having one or more subObjects to also edit. From there I create some partial views like a Add[ObjectName]View, the List[ObjectName]View. After that is a reliance on ajax and security checks for add and editing. The Manage view will often have title at the top, then a dropdown box under that to select item to edit or display a list, with an add button under that. Selecting something will either reload the page with a new parameter (which requires the mvc framework can handle overloading or default values like Manage[ObjectName]( int objectID = 0 ). This will add a new call at the bottom to View[ObjectName] or Add[ObjectName]View depending on what button was used. Editing is usually handled inline with switching pure text with an edit box for the element using javascript or at render time with if statements. Some of these can be auto generated to save you time, like the list view or the add view if you're ok with it being generic and obvious that's what you're doing.
Which is obsolete, especially considering they didn't enclose the PHP in `&lt;![CDATA[`
I never knew of this until today yet it's always available and perfectly valid: &lt;script language="php"&gt; echo 'even Netbeans processes this correctly'; &lt;/script&gt; I wouldn't use it personally as it's so "long-hand" and impractical, but it exists and many of us who weren't really using PHP before PHP 5.2 may not know that this is in fact perfectly valid.
Ask them to show you previous projects they've done. Hiring developers is... difficult.
"Web-based application developer with a primary focus on PHP backend scripting presented with an HTML/CSS frontend." Got me hired.
Look for: * Database skills * Good programming style * Object-oriented code * Thorough server-side validation * Cookie/session management skills * Security skills (can prevent XSS attacks, SQL injections, etc) * Organization of code into multiple files Other things that might be nice (and indicative of skill): * Understanding of .htaccess/mod_rewrite (Unix-developers only) * Knowledge of regular expressions * Years of experience &gt; Zend certified? or CakePHP? What CMS? Joomla or Drupal? None of these can be used to gauge skill (unless of course you are specifically looking for a Joomla programmer, for example).
New info for me but I'm struggling to figure out why they would write this into php at all. The compiler searching for this string in code must take a small but non-zero amount of system resources that could be used elsewhere. All just to support the .0000001% of php code that uses it.
And that's how it should be because... being developers is difficult. 
ah, MVC. This trend towards positional (i.e. unnamed) parameters... how is that an advance? It strikes me as being non-future proof and non-human friendly. 
In frameworks such as Zend you do not need positional/unnamed parameters. You could do... http://mysite.com/controller/action/username/drhugs/ But I think the general idea is, more often than not, users are not really meant to think of them as parameters or the position is more meant to rename the naming. For example, http://mysite.com/news/archive/2011/06/ 
You could fetch up a small sample of tests to give to your most eager candidates/ Such as: [Exam_1_-_Programming_PHP_Practice_Questions](http://www.wepapers.com/Papers/19639/Exam_1_-_Programming_PHP_Practice_Questions) Even if you don't or can't mark the test, it will winnow the candidates who are too lazy/uninspired about your opportunity to take the test. Possibly request that all applications take the form of a blog posting on a forum that they set up (either from their own source codes or open-source.) 
Mostly 404s since it's all chance, but I did find one [WTF](http://imgur.com/gbA9W)
I like it. Focus, and presented are good words here.
cool. haven't found anything disturbing yet. you should tack on a "s" to your img links so that you generate small thumbnails. $out .= "&lt;td&gt;".$imglnk."&lt;br&gt;&lt;img src='http://i.imgur.com/".$stri."s.png' width='200' height='150'&gt;&lt;/td&gt;\n";
I've found it very frustrating when looking for people to hire how people who have very limited PHP skills will list it as one of their skills. The worst part is during the interview they will then cop to not really being interested in learning it.
I have a friend who does this. One day its "im a programmer, gosh this is epic" next day hes asking me how to solve simple ass problems, when i try to explain, he doesnt want to hear it, cause "i dont need to know that"
Wouldn't it be 1000 times better if you used the imgur API to pull random images from the gallery?
Source: http://www.eegra.com/show/sub/do/browse/cat/comics/id/82
First of all i would suggest to stay away from FuelPHP. At least for now, till the stable release. I would recommend to take a look at Kohana, Yii and Lithium. Though before making a choice, you should try to make something for yourself and in process learning stuff about loose coupling , SOLID principles , testable code and how (H)MVC should be made.
&gt; From what you said, it was a paper about why Blowfish may have weaknesses. Yeah, except I didn't actually say this. You're now arguing with what I'm saying, based on shaky and as of yet unsubstantiated interpretations of things you imagine I said earlier. Notice the complete lack of quotes defending this bizarre interpretation, which is basically the exact opposite of what I keep actually saying. &gt; I joined the conversation because what you were claiming didn't add up. Frankly, given that each time you present something it's a bizarre interpretation which can't be found of defended with quotes from the actual source text, this isn't entirely surprising. Occam's razor suggests you just don't understand what you're seeing. &gt; because you haven't added a single shred of relevant evidence. Keep pretending that if you won't read it, it hasn't been presented. Really adds credibility to your argument by dint of cluelessness. &gt; &gt; &gt; Four out of five leading dentists agree that some bullshit about bcrypt. &gt; &gt; Name one. &gt; At least a couple have already been cited above. No, they haven't been. Pretending a quote has been given doesn't make it real. You can happily prove me wrong by giving any name that has been given in this conversation, but so far I'm the only person who's named an actual cryptographer, and it's Bruce Schneier, the actual inventor in question, and he says otherwise. And I said where. Going "yeah people say I'm right" and when asked whom saying "er uh some were named above" is really not making your case for credibility. You could of course prove me wrong, by quoting where they were cited above, but since they weren't, we both know that you're going to claim it isn't your responsibility to, when you claim that Top Scientists In London Proved Your Case (tm), mention who a few of them are. The bullshit card has been declared, sir, and short of showing yourself to be correct or apology, my end of this conversation stops here, no matter how ridiculously over the top you go in face saving acrobatics afterwards. &gt; what you were claiming didn't add up. &gt; I don't know whether or not you're right &gt; I don't feel any closer to knowing. &gt; All you've said is "there is a long paper out there, and nobody who has not read it is fit to [argue about the topic it discusses] %% edited for non-melodramatic correctness Starting to catch on? Go look down at someone else, champ. If you had shown a little humility, maybe. One of these days you'll realize that the tone in which you ask for information is why you so often end up saying "oh yeah? Well I bet you didn't have anything to teach me anyway."
FuelPHP is very nice. They're actively working on it, and of course there'll be some bugs here and there. I was looking for a new framework and was trying to decide whether I should go with Kohana or Fuel. In the end I chose Kohana. It's simply got more years behind it and a much larger community. I do believe Fuel will evolve into a very good framework, though! I tried learning Yii. I really did. I stopped and started the blog tutorial several times, but the whole "magic" feel of it simply got in the way of my learning. I'm sure Gii is a great tool to have, but maybe it shouldn't be introduced so early in the learning process. Also, its' AR is very tightly woven into its' DNA, and I prefer to write my own queries by hand. There's no one in the world who won't admit that the documentation is top-notch, both in code comments and in their reference online. It's absolutely great how detailed everything is. Maybe if you like more magic in your framework, you'll like Yii. Kohana seems to be the direct opposite of that. You simply have to look at their routing system to understand how much work you actually have to put into it to make it work exactly as you want it to - and I love it for that. Just one thing: Don't go into Kohana (if you choose to use it) thinking it's similar to CodeIgniter - it's not.
Don't think I would say "scripting", though.
I really, really like short-short tags, `&lt;?=$string?&gt;` and I wish I could reliably use it in my programming :(
ask them how quickly in the past they've been able to make hiring managers squirt.
I really hate that for readability but it does save keystrokes and code space in html layout code. However I would love to be able to always just put &lt;? [...] ?&gt; instead of &lt;?php [...] ?&gt;
I'm a pretty huge Yii proponent. The learning curve is steep, but it is really well-written, the community is really active and supportive, and the framework is architected in a really consistent fashion. It is a full MVC framework, but it also has a pretty cool way of handling component style stuff (similar to .NET), database migrations (so you can commit your database structure to your versioning system and verify current database version so you know your app is updated), command line execution, super-flexible caching and logging, and several other things that are really nice once you learn that they exist. Is there anything in particular you want out of your next framework or are you just getting the pulse?
Here's an option that I haven't seen anyone mention yet: Hire someone you know is good to interview the developer. If you know for certain that someone is a great developer, that person is well qualified to verify other developers' knowledge. Hard to bullshit a technical interview with someone who walks the walk.
You should first decide if you're going to use a pre-built CMS or framework or roll the whole site from scratch and then look for someone with the skills needed to do that. Also, if you're expecting a lot of traffic, say 4K or more page impressions per hour, make sure they have some experience with that. There's special stuff you need to know for that and it's hard to learn it unless you have a busy site to get practical experience with.
I was also bored, so I tried this in javascript: [http://jsfiddle.net/synewaves/AtkJb/5/embedded/result/](http://jsfiddle.net/synewaves/AtkJb/5/embedded/result/)
I usually just go with "web application developer". 
"Web Applications Developer" is a more appropriate title. It's what I use when people ask me what I do.
You wouldn't need GD, just use curl to determine if page returns a 404 error or not before displaying the link.
This looks like another "Hey, I've got this great idea for a facebook-like website but with a twist! I have no money to pay you right now but once we make it rich you'll be rolling in the dough!"
Exactly. Just another person with another idea which is basically "Lets make a poor copy of something else!" This guy needs to state a budget, which I'm going to guess is not much and in that case the answer to his question is "Whoever is willing to take such pathetic pay, just don't expect much."
I'm a php guy, feel free to ask me anything 
Especially people that think creating a WordPress theme qualifies them as a PHP developer...
Just compare the length, then MD5 of the returned file to the known 404 image. Probably cheaper than using GD.
Right, but it's still a 404, and curl can tell you that.
Thanks
What advantages does Fuel offer over Kohana besides the oil utility and possibly namespaces? I had a look at the docs and API and they look very similar, though I imagine Kohana has a ton more modules at the moment.
Yes but the HTTP status of that image is still 404.
tweaked to remove the 404 images, and adds useless stats: http://jsfiddle.net/KzfKf/embedded/result/
Look for someone who has coded in a language other than PHP, too - ideally a compiled language with stronger typing and enforced separation of presentation and logic. I am not hating on PHP by any stretch. It's just because PHP is one of those languages that gives you so much freedom, it takes a lot of discipline to code it cleanly, and the "clean" PHP movement is much younger than PHP, so you can't take for granted that you're dealing with a clean PHP coder. 
I never said I was going to hire them for free. I am actually willing to pay up 200$ per hour for a competent developer. That is why I am asking and not going blindly. I don't want to end up with someone who pretends they know something when they know jackshit. I am not sure where you are driving this conclusion from but thanks for your input!
What is the best way to go about it with regard to getting someone proficient in a popular CMS and Zend certified (easy to hire?) or just go with our own (harder to hire)? I am thinking it would be better if we need to get someone to fix something in the future because these technologies are quite popular. 
If he does well, he will quality for a prize! 
sudo admin
Sorry for the double post. 
If you end your MySQL query with \G instead of ; it will give you a 'vertical' dump That's assuming you're using the MySQL command-line interface, not something like phpMyAdmin 
to me it kind of depends on what type of things they do with the theme. If it's very basic things, then not so much and they should list "novice php" at best, but if they're doing some higher end things with the theme or are also developing their own plugins, then it's a bit different. I know I list "intermediate" for my php level but it's probably more higher end novice. I need to work on that part.
I couldn't agree with this more. I actually clicked this link specifically to make this point and was very pleased to see someone had already made it. PHP has such a low barrier to entry that there are a huge number of people who call themselves "PHP programmers" who you shouldn't touch with a million-foot pole. I wouldn't be averse to hiring somebody who had no PHP experience whatsoever if they showed a high degree of proficiency in a similar language and weren't outspokenly anti-PHP (closed-mindedness and ignorance are also good reasons not to hire somebody). Read http://codefury.net/2011/04/why-php-was-a-ghetto/ for an excellent analysis of the problem. Oh, also, don't hire anybody ever without reading this: http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html
Almost every post like this turns out like a craiglist joke, nothing personal. Mentioning your salary range gives an entirely different context to things.
Could you hand pick the points in that 400 page document where it says bcrypt is defective? I have read all your reasoning in this thread, but I have not found anything that makes justice to say that bcrypt defective. Why do you act so frustrated? Please help us understand, and don't just think we are idiots. I still think there is no practical reason for not to use bcrypt. Prove me wrong!
And once again, no actual information defending your position.
If you do this those who maintain your code will hunt you down and skin you alive. I've seen it happen...
"programming"
echo "cocks"; all up in this
I swear under my breath and say what I type. Does that count?
Yes and it can get awkward if you forget to remove something before committing it to the repository.
Once, I taught PHP as part of a computer science program in high school and I observed that boys tend to use obscenities and girls tend to use greetings while debugging. Moreover, the boys that were not able to program (due to lack of motivation, study or capabilities), were often happy to spend a lot of time to output stupid nonsense and obscenities and joyfully crying out about it to their friends. These morons failed my courses, obviously, but man, did they have fun (until the test, he he he). Girls in the same category, however, just did nothing (useful) at all. Luckily half of my classes were good programmers and another third could get a reasonable grade with hard work and study. I find that girls were a bit more successful than the boys, but the best of the class were boys. I think this is because girls of that age behave a bit more adult than the boys and do study somewhat more seriously, but I often wondered if girls' better language skills were part of it. 
echo "lol"; all the way
Another favourite in OO code: class LOLWAT extends Exception {} and in the code: if(false !== $this-&gt;getWhatever()) { throw new LOLWAT('wat...'); } 
"hi", "hi there", "wtf", "the fuck?", "test" etc. 
After subscribing to F7U12 I found myself using console.log('le click'); quite a lot.
"BOOM"
"Software Engineer with a specialisation in web based application development". Of course it does help to actually have a recognised engineering degree. I normally simplify it to just "Software Engineering" when people ask what I do.
echo "blarg"; here =\
I use WTF and lol a lot. I usually say fuck yeah after I get it working.
I do it from time to time, but one time I forgot about one part where when a very rare specific condition occurred in a data set I was pulling, it would just say "You Magnificent Bastard". One of our consultants was using the output of a website for his presentation on our company's sales and experience with current customers, and randomly in the middle of the presentation he read this out loud from the slide without thinking. They literally took it as a compliment towards the company, although unorthodox I suppose it didn't hurt things. When asked why it showed up in the website I blamed the intern from the past summer, and removed the comment immediately. 
I use behat and love it. Symfony 1.4 project, it has a good plugin for symfony. Author is very quick to respond to fixes (hasn't needed many) and it's integration with Mink is pretty good.
I don't know. There are advantages and disadvantages to every approach. I think it may come down to staffing. If you expect to maintain two or more programmers at all times then creating a well-documented application from scratch or based on a framework could be good. Two or more programmers is important for this strategy because if something happens to one, the remaining programmer can train up a new one. If you only plan on one programmer or only hiring a programmer on a project to project basis, then leveraging the power of communal knowledge and building on Drupal or Joomla will save you a lot of money and aggravation in the long run.
echo "bla"; echo "bla2"; $bla = .... and my all time favourite echo "fuckin work!";
eh, I used to. I still do sometimes, but it's a habit I'm quickly getting away from. After all, you might accidentally forget something in the code, commit it to your repo, and it might its way into production on a client side. Not something you want happening.
Yes, that's what you keep pretending: that if you won't read the PDF, it doesn't exist. Meanwhile you haven't presented one lick of evidence - not even a PDF the other person refuses to read - and are arguing from ignorance. Again. Go away, please. 
&gt; Could you hand pick the points in that 400 page document where it says bcrypt is defective? Nope. Since this is reddit, soon you are likely to say "because you won't do my research for me, you are wrong." And then I will laugh sadly. &gt; but I have not found anything that makes justice to say that bcrypt defective. I never said bcrypt was defective, and I don't know why you can't cope with that idea. It's not like it's the first time I've pointed this out to you. Stop asking me to prove things I haven't said, and stop asking me to be your research assistant. &gt; Prove me wrong! I already did. That you're too lazy to look into it isn't my problem. If you want your research done for you, I know some grad students whose rates are very reasonable.
I know some frameworks have compilers built in that will transform `&lt;?=` into `&lt;?php echo` before running the code (Lithium, for example). Personally, I don't like the syntax. I prefer being verbose.
Downvoted by PDO fans again. :(
Not since one of my old coworkers Rusty forgot to remove those words before shipping product to a client.
You're the one presenting a claim. Rather than defending your claim, you point at a 400-page document. It's as if I make a surprising claim, and when challenged, tell my interlocutors to go to the library and research for themselves. Either you can substantiate your claim by coherently summarizing the relevant factual arguments, or you cannot. Telling people to do their own research is not substantiating your claim, it's a cheap avoidance tactic.
&gt; You're the one presenting a claim It just isn't my problem that you're too lazy to read the legitimate defense given. No amount of hollering or whining will change this. Go hire a research assistant, or find your reading glasses. Stop bothering me.
Whenever I know something isn't going to work echo 'And BOOM goes the dynamite'; // For the love of god and everything holy please don't run! I have it linked to a hot key.
Absolutely! Usually nonsensical fragments of whatever song I'm listening to, or `lol`/`horse`/`boot`/`bee`/`cocks`/[a silly description of the state]. Abusive language gets saved for debugging variables - probably because it's a pretty annoying debug if I have to use debug variables, and also I like to think I'm forcing the compiler/parser to read the abuse I'm directing at it.
"poo" and "pee"
i tend to use check point 1, check point 2... only when I'm pissed do I start to swear. I tend to recommend against it, I've known too many times where someone accidentally let that code get out into the wild.
&gt; my end of this conversation stops here This is why StoneCypher is here. To troll hard for attention. Keep playing with him. It's what he likes. Then he claims ppl are bothering him. The little red envelope literally causes him some emotional feedback. It's a very interesting fetish that he will continue with for a very long time. We have to believe one of 3 things. 1. He thinks that being unable to simply explain [what has been learned from blowfish in implementing twofish is so much better] is not worth stating to someone 2. He simply doesn't understand it well enough to explain it himself and he thinks this encouragement to RTFM is good enough to hide his shame. 3. He just wants your attention, whereby he gets a warm fuzzy feeling, so he continues to taunt and avoid substantiating. I have decided he's not a complete moron, just a sad little man who gets in these EXACT exchanges on a daily basis. See his comment history. He gives some over the top truth sermon, when questioned states he didn't say that or you're dumb or this is read the pdf and derive the wisdom. His cheap avoidance tactics are many. It's this over and over (with small breaks for the well adjusted side of his personality)
Mine get progressively worse as I hunt down a bug. It could start with echoing 'At Point X with Variables $a $b $c $d' As it takes longer to hunt down it could devolve into 'FUCK FUCK FUCK FUCK'
Depends how code is coding. The ratio of anger to profanity rises with how much my code is pissing me off. Usually starts with echo 'poop';, but can quickly escalate to echo 'cunt';.
You didn't give a legitimate defense. You just said it's almost 20 years old and twofish is better. 15ish is close to 20 ya? Twofish is better how? You should really know it. Right now you can't quite explain it. It's cool. You know I'm here for you. &gt; Yeah, except I didn't actually say this. no you said something to the effect of... &gt; Is that really that hard? Did you think he'd replace it if there wasn't a reason? Maybe, I dunno, you could go see if he explained why he replaced it? Why would you change an encryption other than to strengthen it? Perhaps to make it faster! Use less memory in performing. I guess those are the only reasons that matter. Maybe you should just act like a normal human and give him a link explaining the differences or claim one. Then you don't have to pretend you know what you do or dont.
My favourite is Aaaargh.
There are some big differences between Kohana and Fuel, most notably the routing. In Fuel it's automatic (or the default is pretty easy to use - can't remember). Using base controllers is very easy to do: APP/users.php (base) APP/users/view.php (extends base controller) I believe the routing system picks this up immediately. With Kohana, the default router isn't very in-depth or very powerful... but that's where it shines. Once you wrap your head around how to create your own routing rules, it's very nice to use. Fuel's routing feels more CodeIgniter to me. Fuel uses Kohana's DB class (or it's very similar). Really, Fuel is a hybrid of CI and Kohana, and possibly other frameworks as well. The advantage they have is that the framework is in its' infancy, and the developers have the choice of picking and choosing what they feel are the best ways, either by writing from scratch or adopting another frameworks' methods, to go about defining how their framework will function. This could turn out to be a magnificent advantage if done right, or it could create a mess of the code (although with the talent behind the keyboards, I doubt this'll happen). Why not use both right now? Honestly, Fuel even as young as it is right now, will be easier to learn that Kohana if you're not patient. Kohana is NOT hard to learn - you simply have to erase the mentality that there'll be a ton of examples in its' docs - read the code when you're not sure how something works. The code is very well documented and should explain what all's going on. Saying that, Kohana is def. not for beginners... they should use CodeIgniter. edit: Yes, Kohana has quite a bit of modules. I've only used one so far, the Pagination module. Reading through it, it doesn't seem to so Kohana-specific that it can't be converted to use another Framework. I'm sure other modules can be expected to be the same.
I'm much worse. I name all of my variables, methods, objects, and classes after genitalia.
Years ago code of mine was being demo'd at a WWDC (not PHP, but still...), and it crashed with some expletives up in huge letters on the screen. For the most part I avoid doing that now, just in case someone gets a peek at a part of the app before I've been able to go clean it all out for some reason.
I am hoping to find the best framework that offers the fastest application development for me and is easily maintained in the future. My expectation is that once I learn a more advanced framework those goals will be met. I have read the Yii book is outdated but would you recommend purchasing it for learning Yii or just trying to grasp everything from the examples?
Thanks! I will look into Lithium. I read that Kohana doesn't have the best documentation so I ruled it out earlier. Has this changed or is it still hard to grasp from the documentation provided?
I often bash myself or tell myself what the code is doing. 'Oh shit! The retarded programmer found me! Isn\'t he special.'; 'I guess every fag has his day'; 'I\'m going to hunt my boss on an island, eat his dog, and shit all over his sister\'s lips.'; Sometimes I leave these in my code and my boss is all like, "Wtf?!", so I tell him I got a virus and he's like, "That's weird." It's been a long year at the plant. A lot of layoffs...
&gt; It just isn't my problem that you're too lazy to read the legitimate defense given. At this point, it's not a legitimate defense, it's somewhere between a bluff and a busywork exercise. Furthermore, I just skimmed back through your comments on this page, thinking, you know what, I'll read his damn paper, maybe I'll learn something... and guess what? You didn't post a link or even a title.
It's not hard to grasp. Just start small, as always, and as you come across things you wish to do, look at the docs. Also, #kohana on Freenode. The guys in there are absolutely helpful.
I usually use "YEAT". But you folks probably have no idea what that means. Then again, clients don't know what it means either, which is probably a good thing. In fact I'm not even exactly sure what it means, but people around here say it an awful lot. Yeat!
I think it's safe to say we've all done this at one point. There's only so many times you can chase down a bug before you think "fuck it" and just start chucking in *echo "bollocks";* in a vain attempt to narrow it down.
I usually echo my name in ALL CAPS.
"If you see this, you're fucked" 
Reminds me of a story somewhere where the debug message "work, bitch!" was used for some application at a company. Some of the female employees were less-than-pleased when it popped up on their screen.
Commenting to save this for later - just about to move my project from procedural mysql to mysqli. Thanks!
At some point when I'm really red up I always end up using print_r($GLOBALS); and inspecting every single last damn variable. This starts to fail miserably however once you realize that you have classes with private data. Then it's time to duplicate your code somewhere, get it running, replace every instance of "private" or "protected" with "public" and try once more. Debugging in php can be hard sometimes.
Getting rows out of mysqli is kind of sucky, more so when using prepared statements. If possible, if you are on php 5.3 and know what you are doing, compile with mysqlnd (mysql native driver). If you can do this it gives you access to new functions : $stmt-&gt;get_result(), which returns the results as a results object, so that you don't have to use $stmt-&gt;bind_result(), which is a pain. $result-&gt;get_all(), which returns all rows of a result set. This just simplifies things, as without you you have to do something like this. $rows = array(); while($row = $result-&gt;fetch_assoc()) { $rows[] = $row; } if(empty($rows)) { return false; }else{ return $rows; } Now, this isn't hard, of course, but it is a pain to have to do that over and over again. Outside of that, the main thing you may have to deal with is are escaped inputs in your database. When you use prepared statements, it does not add slashes to the text input like when you use real_escape_string(). Instead it marks the entire entry as text, so none of it will be executed. This is a very good thing, but you will probably have to update some display code and database values to get it all running well.
I always default to echo 'crapzone'; Fun times. A quick grep 'crapzone' . -lr to clean up.
I had a buddy alert 'nigger' on a dev site at one of his jobs. He got fired, his boss was black. Dumbass. 
die("horribly");
Thanks for being so helpful! My host is running PHP 5.2 and even then I don't think I would be able to compile such a thing myself. I guess the format you showed above I am already familiar with anyway. As far as prepared statements go, does that mean I don't need to bother escaping my inputs, or should I still be doing that for safety purposes?
always
If you're echo()ing, you're doing it wrong. Install [Xdebug](http://www.xdebug.org/) and you'll be a *lot* more happy with the debugging process.
The best way to avoid any problems is to use #1. You have to be careful with #3 because it's not always enabled on every server. I have known about #2 and #4 for years but have never seen a real-world implementation in any open or closed source projects. Also, if your entire page is surrounded in php tags, ommit the closing ?&gt; tag. It will eliminate any trailing whitespace issues and will still be valid.
Fuck everything about that.
When I'm debugging JS, I like to use if(confirm('U JELLY?')){ ... stuff I'm testing ... }
Yeah I'm really bad for this. I'm always using code templates in my IDE to spout such offensive terms as *\_\_FILE\_\_ . ': ' . \_\_FUNCTION\_\_. ': ' . \_\_LINE\_\_*
I like to use "awefweufihwef" or "afjowihf23" or sometimes if I'm really feeling crazy "afoiuwhfuoh" 
blargh &lt;--- (Or hi2u)
I used to use NPC phrases from Ultima Online, but got out of the habit when one snuck into production.
&gt; does that mean I don't need to bother escaping my inputs, or should I still be doing that for safety purposes? That is what the prepared statements do for you. They are just able to do it without having to use slashes. Much better way. The only problem is you already have "slashed" entries in your db, and you probably have code to strip those slashes on output. Personally, I don't have mysqlnd enabled either, but when I'm writing code I wish I did.
I use XDebug, so I am not usually echoing things out. However, I usually rename the variable something nasty to find it quickly. I do the same thing with comments. My commit messages can be legendary with their profanity, though. 
I'm just going to go ahead and say that you're doing it wrong.
Cruel things happened to Joe that day...
Figure of speech, meaning live public facing application servers.
 &lt;? echo 'tacos'; ?&gt;
Always very sad when someone confuses "bug" with "thing I don't like" in the effort to make their preferences sound like a matter of correctness.
I'll often do a &lt;?php echo "Why?!"; ?&gt; when something is broken.
if($worked) { echo "big bucks"; } else { echo "whammy"; }
I usually use "blech" because I learned to program from the book series [C for Dummies](http://www.c-for-dummies.com/) and I think he used the word blech a bunch in those books.
I'm all about foo, bar, baz, quux, in that order.
mostly "test1&lt;br /&gt;" , "test2&lt;br /&gt;". The XHTML compliance is very important. I'm not very fun :(
The documentation is very good for the core. A bit less for the official modules, like ORM. But you'll have no trouble getting started.
Kohana will not offer the fastest application development, because there are no "auto"-features, like creating a basic CRUD-interface. This is more simple to do with Yii. Kohana just gives you a beautiful written base, but no *magic* at all... Also note that with Kohana, every major release (every year) will have major API-changes. This makes for a framework that moves forward &amp; improves very quickly, but not really backwards compatible on long term. Every 2 years they stop supporting the previous major release.
I have no idea why, but I often use something like `echo "jjj";` ..
I'd probably fire you if I saw that. If those debuggers got into the wild and suddenly one of my clients, let's say a medical professionals group, had a HIPAA compliant web form for taking patient's personal information and it suddenly started calling all their patients, "You Cocksucker", I'm getting sued because you're a jackass. We can't have that, so let's try to pretend we're professionals who take pride in our work. Keep it nice and boring and maybe even helpful to other developers: "Debug : line # returns integer", "Debug: line # expected 234 got 567", "Debug: line # is NaN", and so on.
i take this approach. most developers will read this as y_uno, and think 'oh its spanish, the 'and one' function, of course.' // somewhere in boilerplate code function yuno($work) { echo 'no ' . $work . ' - ' . __FILE__ . ' - ' . __LINE__ . "\n"; } // some biew file &lt;?php if ($broken) { yuno('save'); } 
In my defence, it's easy to type. Ends up being the first "word" I think of.
"here", "here1", "here2", "here3" ...
Aw, I thought it would make people laugh. I've never actually done what I wrote above. I take care of every notice php throws and I never have any bugs I can't figure out as I go along now. Very occasionally I need to use a back trace.
IRC Captain Guy, looks good printed and gets all the ladies (think football captain). Although WebAppDev also works.
Look into xdebug and kcachegrind, both relevant. I usually don't use them unless I'm working with an unfamiliar framework, and need to understand the app flow or debug some pesky bug. Stackoverflow has great threads on this topic.
The book is helpful, but there are many typos and examples that don't quite work (Yii released a minor version while the guy was writing the book, so some examples are partially changed. I can see where this would be frustrating to a new Yii user). I think the best way to explore it is to try using it, starting out with small projects or side projects that aren't that complicated. Be prepared for a little confusion up front. The forum is very helpful, but some info is for pre-1.1.7 versions. The "Definitive Guide To Yii" is very helpful to read, and I recommend reading it before your first sample project, and then skimming it in between each project attempt as a refresher and to notice features you missed the first time that will make life easier.
I was hoping someone would say this. There are way too many PHP developers who have never heard of a breakpoint.
And especially bad considering they can DOS your website with Noscript and steal your passwords by simply viewing source... I don't mean to sound alarmist or anything, but the security of the entire internets are in jeopardy!
i worked with a guy who would echo things like BAM and BOOM. sometimes with varying degrees of exclamation points attached. 
that was a horrible joke. also, ever heard of using an actual debugger?
I always echo "Hello" and other variants because I wouldn't want to release my code and forget about the echo "Cock" that I mistakenly left in my script. I've released code before with a couple echos left over and from what many people are saying here, it would have been very unprofessional and embarrassing if they said something bad.
It doesn't show up in the source like javascript, it gets parsed just as if you used &lt;?php ?&gt;
This is endlessly annoying in versions &lt;= 5.2 because of the parser they use. If you use token_get_all on a string containing "&lt;script something something&gt;" it gets parsed into 2 tokens instead of 1 of TOKEN_TEXT e.g., array( 0 =&gt; "&lt;s", 1 =&gt; "cript stuffs here&gt; ..." ) Because the parse reads to &lt;s, looks ahead to see if it has "language='PHP'", if it doesn't it scans back to &lt;s but doesn't join the two strings. EXTREMELY annoying when writing stuff that depends on those tokens being joined.
Ah cool, with xampp, you need to enable the module and either either enable profiling through php.ini or per-script (much less resource intensive obviously). IMO kcachegrind is the best to start out with to get a full understanding of xdebug (w/o confusing ide/integration specific features).
True debugging lets you halt PHP execution at runtime and observe the call stack and currently-set variables. I'm not lucky enough to have this kind of setup at work, so I usually fall back on `var_dump()`. I've used [Xdebug](http://www.xdebug.org/) and [MacGDBp](http://www.bluestatic.org/software/macgdbp/) with great success in the past.
It looks like they've implemented some rough form of rate limiting, probably based on the amount of invalid image URL requested over time. It's definitely a healthy thing for them to do. I think the script still works if you're patient. On my end, it's basically 4 times slower now. 
Either you missed my sarcasm, or I missed that drspliff was actually being sincere.
Needs a /s. The internet is serious business and text es no bueno for displaying sarcasm.
It'd be a lot nicer for everyone involved if it was using an API that returns a valid but otherwise random image. Alas I can't find anything like it in imgur's api list. Remembering requests is probably not that critical. Each time we try for one, we pick one URL from a bit under a billion. Even if a full load pulls a few thousand requests, we're unlikely to get a duplicate. ( wolfram alpha can't compute the [probability of not getting any duplicate](http://www.wolframalpha.com/input/?i=x%21%2F%28x^n+*+%28x-n%29%21%29+for+x+%3D+916132832%2C+n+%3D+3000) with 5 random characters, but with 4, it's around [73%](http://www.wolframalpha.com/input/?i=x%21%2F%28x^n+*+%28x-n%29%21%29+for+x+%3D+14776336%2C+n+%3D+3000) )
when I get frustrated, it's always die("WTF");
alert('wibble!'); and to make this subredit-relevant.. echo "wibble!"; 
a buddy of mine was debugging some emails being sent out to his user base. To keep entertained, he wrote some pretty depraved shit in the email bodies while testing. I trust you can see where this is going.. email config set incorrectly, thousands of users receive repeated emails from this perpetrator of awesome, goes unnoticed until a shell shocked user writes to customer service asking why they're being sent emails about cleveland steamers.
echo 'O HAI';
Am I the only one who just bashes the keyboard to get some random letters - its quick. For some reason d and g seem to appear frequently.
i used to do that, until one time i had to get a project ready for actual production and there were a few of these debugging messages I forgot to find that said all sorts of hurtful and awful things, a bunch of investors and stuff saw this when they were showing off the website early. It was incredibly embarrassing, fortunately everyone who saw it took it lightly and/or found it funny. I still avoid profanity in my debugging though because that could have gone worse.
or wincachegrind if you are using windows.
[Agavi](http://www.agavi.org). If it likes you.
yes. All the time" favorite phrase: "fuck" "dicks" "dongs" "lolwut" "tongue-punch my fart-box" 
I would suggest looking into Linux if you have windows. Just playing- no holy wars please. I use *nix, Mac, and windows all regularly for various purposes.
I've heard that eclipse can do step through debugging but to be honest, I've never really had the need. I've found that as time has gone on I produce less and less bugs. I can't actually remember the last time I was trying to chase down a bug that I couldn't find or understand. I haven't recently been maintaining code I didn't write though. When I go back to doing that then I may well want to scream.
`assert False`
The absurdity of my output statements is directly related to my level of frustration
I used to use Xdebug a lot, but now I work on a very memory and CPU intensive product, and the overhead of Xdebug is unbearable on my lowly VM.
echo "echo"; reporting in.
The same thing happens to me. I had a bunch of if statements for a donation system that could have a message attached to it. Somehow none of the new donations were showing up. As soon as I figured out the problem (index was displaying wrong) I noticed my steady decline into insanity. Donation 15: Hey work now Donation 16: WORK NOW Donation 17: AAAAAAAAAAAAAAAAAAAAAA
This is a great question, was wondering this myself. Thanks for asking!
Web application developer. It's even harder from the other perspective. I spent 10 months working at a company who were full of (and probably wanted) the first type of 'web developer'. Never been so bored in my life.
Xdebug.. eek... I kick it old school... var_dump($myvarible); exit; Of course I also code in vim and I'm sure many IDE fans would downvote me for that alone.
xdebug's var_dump replacement is a life-saver. 
Sleeping, dont wake the trolls.
"By the time you read this, you're already dead."
Having so many API changes pollutes Google and SO and is possibly a reason not many docs are written for it. While the API seems a bit more stable, who would want to put much effort into documenting a moving target like that? Those who use it heavily are beyond needing docs anyway, which is both a blessing and a curse for the project as a whole.
I find that as I keep debugging a script that I echo out progressively more obnoxious debugging messages so I can see them above the din of the previous debugging messages.
...or version control...
 echo "asd" ; echo "dsa" ; echo "asddsa" ; echo "dsaasd" ; echo "asddsaasd" ; And it goes like that all the way down.
not anymore
Hardcore rap Lyrics
In school my variables would sometimes have questionable names... Especially if there was a bug and I was having troubles finding it. $work_now_bitch = 1; As for echos they're a lot more tame with things like: if($something): Debug::dump('Finally!'); else: Debug::dump('Fiddlestick...'); endif; Depending on what's needed my echos are along the lines of: 'Fiddlesticks', 'Seriously?', 'Finally!', 'ARGH', 'wtf', 'omg', 'here'.
Take a look at webgrind and XDebug. There really isn't anything that reads your code, but XDebug lets you control the execution and see into what is going on. 
"Bang!" for me. I visualize little code landmines.
xdebug is fantastic- better var_dump output, stack traces for errors, and profiling for speed. You'd be amazed the stupid little things that slip through your code but totally screw up performance.
Gave a whole new meaning to *Sloppy Joe*
Also, grab netbeans, it works nice with xdebug
Have a read through this [Eclipse debugging guide](http://docs.google.com/viewer?a=v&amp;q=cache:lxFSJwbhub8J:www.eclipse.org/pdt/articles/debugger/os-php-eclipse-pdt-debug-pdf.pdf+eclipse+pdt+debug&amp;hl=en&amp;gl=uk&amp;pid=bl&amp;srcid=ADGEESiSLli2cfQXOn2eT5FemzeyeMBSgPqLKzN3QOzfMSvc6oQLqQEvp4hgxphs9ubbEjVno8vhL0pnc4XQCVFDYqugu4Ucetz4YIgPIMH0PEsANv_LeRLjnuvbt9cm2GWDnG5uzCde&amp;sig=AHIEtbRV372ybbJpLap-7xPA8XXqOCHOog&amp;pli=1). Debugging by putting lots of var_dump()s in your PHP code works ok but it's a bit like putting alert()s in JS code. Eclipse will let you set breakpoints in your code and explore what the PHP interpreter is doing *while* it's running. E.g. you can watch the value of variables changing and see the call stack (which functions/files have included others). You can also incrementally step through your code and see what line number is causing your bug. As for "learning" Eclipse, using it as a text editor doesn't take much learning at all. If you're just working on small PHP projects then a full-blown IDE may not be worth it but if you have a large, OO PHP project then give Eclipse a go.
Why stay away from FuelPHP just because it is in RC? RC stands for Release Candidate, which means its ready to use but may have a few bugs. You should try out as many frameworks as you can before picking one, but doing avoid FuelPHP just because its in RC. Stable is just around the corner anyway.
I've compared CI, Kohana and Fuel several times as they are all something I have great experience with. I work on/with CI and Fuel and have worked with Kohana several times. My favourite comparison is up on StackOverflow which is what I believe to be a truth-ful honest answer. Sadly shadowhand on the Kohana team had a bit of a rant in return, but he is often less open-minded and very defensive of his project. http://stackoverflow.com/questions/5559549/kohana-vs-codeigniter-year-2011/5567161#5567161 Kohana is brilliant, I've used it several times before but there are a few bits I just didn't like so much. Their ORM felt a bit funky, their Migration solutions (third party) were rather lacking and the lack of documentation at the time drove me mad. Since then they have really stepped up their game with docs but there is lots of room left. There are lots of things t he development team would like to change or do entirely differently but if they do tht they'll break things for current users. Fuel does not have that problem for v1.0 at all, giving us a great start against others. As for Yii, personally I have got on with it. It feels like is a slightly less clean CodeIgniter with a few extra libraries in it. All the extra features were just something you could easily install into CodeIgniter from a third-party like Templating or Asset management. If you want something, install it, dont expect it to do everything because you cant please everyone and trying is stupid. Try them all, make a 15 minute blog, whatever. Just don't write Fuel off for being a "youngun" and don't turn your back on CodeIgniter just yet, it's speeding up in development these days.
The thing that bothers me most about this is that it devalues everyone in the pool.
Netbeans is straightforwad to configure for debugging. Here is their wiki on setting it up properly: [http://wiki.netbeans.org/HowToConfigureXDebug](http://wiki.netbeans.org/HowToConfigureXDebug)
Add some business logic to the BlogPost object and its a model.
Why is this being downvoted? StoneCypher makes a good point. 
You could convert it to use PDO and prepared statements. 
I normally echo 'Helloooo'; Sometimes though, if I'm feeling extra pissy, it'll be swearwords, sometimes even racist, which really wouldn't go down well if left in the code. 
Make something. I taught myself relational databases by making a persistent browser RPG. It's garbage and nobody is ever going to play it, but it taught me many things about coding and databases.
Are you just looking for things to do to your reddit clone, or with mySQL/RMDBS in general? There are tons of interesting things you can do with DBS.
Create a webapp to track the number of steps you take in a day. Add all kinds of interesting metrics such as total number walked, avg walked, steps left to reach the moon, etc... Open it up to friends/others and include social aspects such as commenting on others' progress, posting to twitter/facebook, etc...
I always like doing stuff to get cool statistics / reporting data out of stuff. Maybe some sort of graphing interface to show user activity levels / up vote percentage over time or something? Maybe trending words / phrases in comments and links?
If you want to learn another technology, MongoDB is fun. I'm not big on jumping head-first onto the NoSQL bandwagon, but for some applications, it really is quite useful.... and MongoDB is fun. For fun with MySQL, data analysis and metrics can be cool, especially if you tie it in with a nice charting API. Learn complex queries. They can be a bit tricky to get the hang of, but I actually kind of enjoy them and they're very useful. Even if you use an ORM that simplifies querying the database, there are still times when you'll need to write some SQL by hand to do something really custom, so it's good to know.
I always wanted to do something like this that would let you track distance walked, biked, etc. then you could pick a starting point anywhere in the world and it would pick a random route from there and show you photos of all of the cool things you would have seen had you been walking there instead of around your house.
Lead Web Developer is what I normally use, but I'm moving to just Lead Developer nowadays. I feel like there may still be a little stigma tied to just being a "web" developer from back in the days where animated gifs ruled the tubes. I personally have been overlooked for a batch processing type of project because I was just a "web" developer, but it is what it is. I know I'm preaching to the choir here, but cross over between web development and almost any other type of work is so extensive anymore that leaving it out and being more generic makes a lot of sense to me. I mean really, when was the last time you heard of a major project without some sort of web based interaction to it?
I thought ORM handled the CRUD stuff? That's how I always do it in Kohana. Seems very easy to get up and running.
But notice how he hasn't denied that it's a facebook clone. 
Make a categorization system using a [modified preorder traversal tree](/http://dev.mysql.com/tech-resources/articles/hierarchical-data.html) Simple, fun, and powerful!
You could write a program that creates movie titles out of existing movies and strings them together to make ridiculously long titles - IMDB has a copy of their movie database for download, parse the movie titles out, throw them into a database and do a random walk to create a long title. Here's one I came up with after my program ran 167 sec: "Jennifer's Body Double Team America: World Police Academy 3: Back In Training Day Of The Dead End Of Days Of Heaven Can Wait Until Dark Star Trek: Deep Space Nine Months" Jennifer's Body -&gt; Body Double -&gt; Double Team -&gt; Team America: World Police -&gt; Police Academy 3: Back In Training -&gt; Training Day -&gt; Day Of The Dead -&gt; Dead End -&gt; End Of Days -&gt; Days Of Heaven -&gt; Heaven Can Wait -&gt; Wait Until Dark -&gt; Dark Star -&gt; Star Trek: Deep Space Nine -&gt; Nine Months 
Its a royal PITA. Half the clients I talk to want Facebook basically. Just had a client that wanted a site that did instant messaging, profiles, status, bulk email distribution lists managed through the site, full cataloging / search of all content by multiple specific criteria, and quite a few other features specialized to the site. Sure, I could throw something at them like Drupal Commons, but frankly that shit is a monstrosity which an end user could never manage IMO. Not to say that is bad, but frankly I'm not up to that task and their budget is typically VERY low for most projects (mentioning a $60 a month hosting bill for another client gave them pause), which frankly is laughable.
I get my frontend designs from a designer in PSD format. I then do the slicing/chopping into cross-platform XHTML by myself because I'm faster than outsourcing this. So, since I already have the XHTML, I just rename to PHP, use PHP Alternative Syntax, and then insert it with variables, uppercased so that they stand out from the lowercased XHTML. There are times when I need to generate several similar rows of something, so I compose that in the model and keep it very minimal on XHTML output there. This model-created XHTML, used only for special cases, is then dropped into a $VAR and inserted into the XHTML view file where it receives further styling or perhaps jQuery stuff to take it further. Whether this is a good or bad practice, I just don't care. 
You'd be the guy I'd hire, versus the people who responded against you here.
Big Kohana fan here. Sorry to counter you here, but the docs still suck. They were better with 2.x and 3.0, but the 3.1 docs make huge assumptions, have several TODOs, and explain things without going into enough detail. Let me give you an example. Go looking in the 3.1 docs on routes. Now make a lambda-based route. After you do that, go back and make a callback-based route. Not so easy, is it? The docs didn't help you much, did they? Thank gawd for the Kohana forums. 
Some good points. I'd reason to bet that the Kohana base is as big or bigger than CodeIgniter, CakePHP, Zend Framework, and Symfony. So, these are like the top 5 frameworks. Everything else is a wanna-be without a large enough fan base. 
that makes a lot of sense actually, youre right. I mean if it doesn't involve web in some form or another, you wouldn't be angling for the position to begin with
&gt; Not so easy, is it? The docs didn't help you much, did they? The docs clearly specify how to write both. What is the problem?
Yes, it does. But it will not "magically" create a HTML-interface, like I believe Symfony can.
When I'm hiring, I pay attention to four things: 1) The person's code portfolio. Show me some of your hobby code. 2) The person's attitude. Difficult during an interview, but with a little digging, do-able. 3) The person's ability to solve a problem on their own time, in their own environment. (Fuck on-site code tests: white boards, no internet and no compiler are just not how we work.) 4) The person's ability and/or willingness to grow into new technology. In my opinion, the best thing you could do to reach out to an employer like me (and maybe other people are different) would be to write something interesting and non-easy in your spare time, and when you hand it over, for it to be well documented, well tested and not wastefully built.
I just thought of something fun to do today that i probably wont do, but i sure as hell thought about it. Add an expiring cache layer between your DB and your live site. Run all your mysql queries, and save the results in another table, or better yet in a flat text file. Set a timer to check when loading pages. If its past the timer time, reload the flat file results. This is fun, practical, useful, and some other crap buzzwords.
Databases, in my eyes, are rarely cool. Most of the time they are a necessary evil.
Gotcha. If you've got a lot of forms, I can see how that would be very helpful.
Let me ask you, since this is kind of up my alley; &gt;Hobby Code I assume we are talking about php. What would you consider a "sufficent" or "complex enough" amount of code to show off in a portfolio? The reason I ask, is a lot of my work is niche stuff for clients and while i do my own projects, they are typically fun or light apps that serve a specific purpose. &gt;Attitude In my experience, this is a huge factor. Almost to the point of overshadowing others. Id like to hear your take on how important a good attitude and what specifically you look for when hiring. &gt;Ability to solve problems How best would this be demonstrated to you? Perhaps through going into detail with some case studies of previous projects and work? &gt;Ability/Willingness to grow into new technology Whats the cut off point of (not to sound crass) hand holding when it comes to bringing someone into something new? Say for instance, i demonstrate an attractive attitude, and my problem solving skills are what you are looking for, but I only have a brief experience with the technology you are working with; however i have a strong desire to learn. Would you consider bringing that person into the environment, or is it too much work to get them up to speed? 
&gt; I assume we are talking about php. Depends on the interviewer and the job. Someone like me, I'd like to see code in pretty much any language; I believe that language diversity is a major asset to a programmer. That said, I know a lot of people who would only be interested in the language(s) that are germane to the job, too. I mean, no one size fits all. Interviewers are people, and they differ. I just check out my public projects repo for the interviewer. There's code in there for around 30 languages, and ostensibly whatever the job is will be covered down there somewhere. &gt; What would you consider a "sufficent" or "complex enough" amount of code to show off in a portfolio? Depends on the job. If I'm looking for someone to build a stock exchange, I'm looking for realtime experience, datastructures, complex network behavior, security, large data, etc. If I'm looking for someone to build web forms for my blog, a little PHP and a little experience with WordPress. &gt; The reason I ask, is a lot of my work is niche stuff for clients and while i do my own projects, they are typically fun or light apps that serve a specific purpose. Make them available, mention them in brief as sideshows, and let the interviewer decide whether he/she is interested. &gt; In my experience, this is a huge factor. Almost to the point of overshadowing others. Be wary of that "almost." I can name a number of people who I'd love to work with if I didn't know how garbage their code was, because they're awesome people. &gt; Id like to hear your take on how important a good attitude and what specifically you look for when hiring. Ability to fit into the group, ability to enjoy themselves at the common level of humor (light, serious; polite, crass; tame, mean; et cetera,) willingness to share unpleasant work, lack of likelihood to place blame, willingness to be honest when they don't know a thing, blah blah. Standard set. I'm looking to exclude people who would be a detriment to the team. That isn't something that one can be glib about: if your team is a bunch of jerks (Hi, Ryan and Drew - I miss brunch) that enjoy being jerks to one another, that's actually a healthy system, and you want another jerk who can fit in, has enough of a thick skin to not feel embattled, can keep up, won't ostracize or carry grudges, etc. These are questions that need to be asked in the context of a specific team and a specific job. General answers, in my opinion, must by needs be vague to the point of near-uselessness. For my last three professional jobs, even to do the same batch of work, I'd hire three completely different kinds of person, just on terms of getting them to fit in well with and to work well with the locals. Which sucks. It's not the meritocracy one wants. But the real world is a dick. &gt; &gt; Ability to solve problems &gt; How best would this be demonstrated to you? I'd give them a problem, and wait for them to solve it. The problem would be in the general alley of the work, and slightly harder than the work expected, so that I'd know there was room to rise to a challenge. That's an offsite interview thing. You ask them to do that before you fly them in. If you don't trust them enough to do it themselves, you shouldn't be considering hiring them. You'll ask them about it when they're onsite, of course, but onsite interviews destroy good workers' ability to work - I've seen really good programmers fail simple shit just because the whiteboard isn't a good way to work and they don't have their reference, and they're scared in the interview. &gt; &gt; Ability/Willingness to grow into new technology &gt; Whats the cut off point of (not to sound crass) hand holding when it comes to bringing someone into something new? Depends how much time you have, whether you can spare someone to do the support work, and whether you believe you've hired someone senior enough to jump in with both feet. I haven't had a single day of training in my last four professional jobs; I've walked on and had to just get myself up to speed and get to work. And that's not something you do to a novice. So I mean, the easiest thing to do is to set a training price. "I make $x per year, and I'd expect to need N weeks to spin up with help. I need Dave to do the spin-up, and Dave makes $y. Therefore I need (x+y/12) to pay myself to spin up into this job. The new hire makes Z. Adjust the sum to match z+y, which means if they make less money than you they get extra time. Remember, we tend to underestimate how hard it is for an outsider who also doesn't know anyone's name yet. &gt; Say for instance, i demonstrate an attractive attitude, and my problem solving skills are what you are looking for, but I only have a brief experience with the technology you are working with; however i have a strong desire to learn. Would you consider bringing that person into the environment If it's a video game? Fuck yes. If it's the security team at my new credit card company? Hell no. That has a lot to do with risk and liability. I want a worker like that, but that's predicated on their not being an untenable risk. That's usually a thumbs-up, in my book, but a lot of other people see that differently. Remember, if you get four hiring managers in a room, and ask them how to hire well, you'll get at least five answers.
A statement suggesting to use PDO/an IDE/debugger/7000mb framework in /r/php? Wow, how immensely original!
Have you got $X = array(); somewhere?
the function sqrt returns "The square root of arg or the special value NAN for negative numbers."
"It's garbage and nobody is ever going to play it" - Kyle, don't think that way. One look at the absolute crap that millions of people on FB play every day might give you some new perspective.
Software Engineer, Web Applications is what my business card said when I was in that role. I thought it was a flattering title. Got the Engineer side as well as the application development side.
Time for the normal PHP debugging process: break it down into pieces - in this case, a lot of intermediate mathematical steps - and var_dump the variables. Just use a small freq_range during testing :-) 
$X is a complex number (does php do complex numbers?), also your values of pi and e are a bit small, eulers number especially, add loads more decimal places on, it doesn't affect cpu time taken to calculate, but you'd get a much more accurate answer.
Your variable for i will be NAN and there's a proper function for pi. Setting e as a constant like that won't work at all, even if php knew how to handle complex exponents. e is transcendental and has very special properties which approximating it will destroy. You can't really do complex numbers in the way you want to there- natural exponent of complex numbers are complex sinusoidals which I'm reasonably confident PHP is incapable of handling like this. If you want to Discrete Fourier Transform then I suggest using a [Fast Fourier Transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform) algorithm, [Cooley-Tukey](http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm) should be appropriate. There's some pseudo-code there which shows how to implement it. That equation for the DFT you linked doesn't show you directly how to create a DFT, its part of the definition for the DFT. I can't remember the specifics (its been a few years), but the gist of it is that in signal processing you can extract the frequencies and relative strengths of the input frequencies making up an input sound wave using it. Its also got more general mathematical uses which I never touched on, but it sounds like you're looking to use it for signal processing. The wikipedia article on DFT is pretty confusing to read (as are most wiki Maths articles) so I'd suggest getting an undergraduate level textbook on signal processing and finding the chapter which deals with this- that's where I picked it up at the time. Or you can post in /r/physics :) PHP isn't really the most appropriate language for this kind of work to be honest... if you don't know C,C++ or Java then you can always try Fortran which is procedural so pretty easy to do mathematical stuff like this without learning OOP. Good luck ;)
So.. any suggestions?
OK, this could be fun: The Hunt for Red October Sky Captain and the World of Tomorrow Never Dies!
As for the appropriateness of PHP to perform a FFT, that depends on the OP's need. If the OP plans on running in production then bare minimum a custom C extension for PHP, or more likely a daemon in C, Python, LISP, etc that your PHP frontend interacts with. If this is a one-off script, intellectual experiment, or something of the like there's nothing wrong with using PHP if you're most familiar with it.
True, but IDEs and frameworks and debuggers are down to preference, there's little excuse not to use PDO now.
Although excluding this is poor form, PHP will automatically set the variable $X as an array since the code is operating on $X as if it was an array.
"Debugging for hours! Better drink my own piss."
PHP guy for almost 4 years now. Also know a bit of Javascript, as well as SQL, HTML, CSS. PM me if you need help with something.
I didn't see it mentioned, but in addition to everything else, ^ in PHP is the bitwise xor operator, pow() is for exponential expressions.
http://twitterfeed.com/ - It also works with Facebook.
you can use f.... oh snap they changed their api. ok nevermind you can also use fbh.. oh snap they changed their api. 
Thanks, I never thought of using RSS. I'll probably make my own application (search for ways to import rss to Facebook). Much appreciated. :)
You can instruct users to forward their domains to **mydomain.com/customername/**
Having the customer type in anything "sensitive" each time its needed. Edit: Impractical with a controller, I know. Consoles need to come with keyboards.
Nice try, Sony engineer.
I'm the same, with the exception of W, there's always a w in there somewhere. My FPS palm will never go away.
The news I read says the hackers took over a system adminstrator's PC so it wasn't so much about securing website as securing the PC's that had administration access.
http://httpd.apache.org/docs/1.3/mod/mod_rewrite.html
Yes.
The thing I'm missing is a good-looking product. I know the games and apps on facebook are crap - but they're _shiny_ crap. I could never make something shiny enough. i'm a programmer, I can make it _work_, and work _awesome_. But look good? Farmville's got me beat by a mile.
Username is ironic, but doesn't seem like a [novelty account](http://www.reddit.com/user/NoSalt/submitted/).
The DNS settings can't point to a path on your domain, but you can still do this. It depends a little on your Apache configuration, but assuming you have your web app in the web root and not in a vhost, you can have the clients point a CNAME at your domain. (When the unmatched domain hits your server it will just fall through to the default). In your app, you'd then have to check the host value found in the server global, perform a lookup (ie; you'll have to know what domain each client intends to use) to get the appropriate client details, and the rest should be easy.
I'm sure someone with more experience will come along to give a better answer, but I don't see why this data couldn't just be kept encrypted locally and sent along when needed, decrypted, used and discarded. Worst case scenario, an attacker would have to get a hold of the decryption keys and method, and then either physically access the victims' machines or implement some sort of man-in-the-middle attack for all transactions involving the secure data - which I dont' see being possible in any remotely reasonable manner.
Need to know more about the attack, but you hash, you salt, you use post rather than get, you DON'T TRUST THE CLIENT, you isolate testnet from realnet, you encrypt.
AFAIK users get redirected after they have made the payment, so putting Google Analytics on the "thank you" page would be the most appropriate place for it. You can then do all sorts in the admin area to track how many conversion you have. As for running Javascript with PHP, it's not going to happen.
Why use mod_rewrite when a simple 404 document can do it. in apache, do: ErrorDocument 404 /404.php Also, if it's your apache server, why not disable vhosting (or make your site the default host). You can then inspect the server requested as well, so customer domains can be handled without a restart.
This is more of a question for /r/sysadmin and /r/netsec . You'll probably get a better response from those sub-reddits.
Basic computer protection: * Have better passwords. We know Sony is horrible with this already. * Password protect your PCs because hacking is much easier when you don't have to use the internet. * Encrypt hard drives (or user folders) to prevent access to the data if the computer's stolen. * Use a firewall, antivirus, and/or network attack reporting. Website protection * Don't store entire credit card numbers in one database online. Store the first 4 and last 4, but keep the rest elsewhere. The billing system can use the joined result. Same with SSN. * Any other user information is lower priority than SSN and CC #. * Use strong passwords for database connections. * Use SSL encryption for payment processing and user information updates. * Connect to FTP using SFTP or SSH. * Use irreversible encryption for password storage (SHA256 with salting for instance). Besides a username or a person's real name (maybe email address), user information should be read under a secure connection. If you are displaying someone's address or phone numbers, then it's best to use a secure tunnel.
 Codeigniter is quite a bad framework, as you probably found out. It's a very small, beginners framework. Having worked with a few CI just frustrates me how limited it is. No command line, no ORM, no unit tests for controllers, no form generators, no decent template system, not modular. It's *very* bare bones. I think a framework should be opinionated and guide people, especially beginners towards good software patterns. This concept seems to be missed on codeigniter. Look for the following in whatever you may choose. * Object Relational Mapping, it's so much faster and cleaner to define your models, as *objects* and have a script sync up the database, create the required tables and so on. * Testing from a controller level. Codeigniter has basically nothing for this. * Command line interface. * A healthy amount of community modules and activity on forums like stackoverflow. * Modules. You should be able to split your models, controllers and tests into separate folders. I suggest you take a look at some of the patterns Django uses. Have a short read though their tutorial. (http://docs.djangoproject.com/en/dev/intro/tutorial01/) Take note of how little code you need to write. It's important to choose the right framework and knowing what patterns the good web frameworks use (.NET MVC, Rails, Django, Symfony) is an important factor. You should really narrow it down to around 3 candidates which suit your requirements and then spend a couple of hours working with each to get the general feel of it. I wouldn't consider Yii or Fuel because there is no community, and no modules that can be had easily. Choose one of the popular ones and you'll find it much easier to get help on stackoverflow or irc. If you're not limited to PHP Django is a great option. It gives you an admin backend ready to go, which cuts a heap of time off projects. The community is also rather large (4000 subscribers to r/django If you must stick with PHP then Symfony is a good choice I think. I've been using Silverstripe (A cms and framework) lately and it has been working out very well. Most of the aspects I hate in CI are solved in silverstripe (and django too). I don't need to spend countless hours hand coding forms or trying to solve patterns that should be solved, because those problems have been solved already. The testing works well, it's modular, highly object oriented and has a simple template and ORM system. The only thing lacking is the community because silverstripe is a lot younger than some other projects. I got fed up with codeigniter a while ago and made this post on stackoverflow asking for advice on alternatives, as OP is doing now. I hope it's helpful. http://stackoverflow.com/questions/4094260/choosing-a-new-php-framework. 
you can setup multiple virtual host with apache and bind on multiple subdomains: http://myclient.mysite.com/
mod_rewrite is triggered regardless. Even in your example you've set a condition to prevent the rule from being triggered if the file exists on disk but mod_rewrite was still processed. Also, you would probably want to exclude your PHP files as well. You wouldn't want a user hitting a PHP file directly.
Anyone who cares about there logs would see the page as a 404 even though it was a valid request.
You're doing it wrong, Google Analytics is meant to provide information regarding page views (ie: all client-side information). The tracking of ecommerce transactions should be done entirely server-side (eg: written to a log file, stored in a database). Putting the Google Analytics tracking script on your "thank you" page is perfectly acceptable but it shouldn't be your sole metric for tracking purchases.
When I've needed to do this before, I just issue a CURL request to the 1px gif image google analytics embeds in the page as a javascript disabled fallback. [Example of doing this](http://there4development.com/2010/08/php-class-for-posting-to-google-analytics-event-tracking/)
If you need it fire regardless of the transaction completing or not (which it sounds like you are trying to accomplish). You will need to make the JS appear on the page to the user one way or anouther, weather this is on a "unsuccessful" thank you page. Or by polling the server on the "processing" page to find for the completion of the transaction (good or not) and then displaying the pixel to the user that way. As everyone is saying, running JS within php isnt going to happen unless you want to do some sort of crazy solution where you have firefox or some other browser running as a backend process or something on the server. But even in that event its not how google analytics is supposed to work.
Agreed, although it would be of infinite value for more PHP developers to have a firm handle on web application security. Most of them seem to think their sites are secure just by protecting against basic SQL injection attacks.
How would it affect the log? In my logs, I see the original request URL, and since you have to change the result back to "200" in PHP, that's also represented.
Write a static function like Debug::output and setup a pre-commit hook that will reject any commit that uses that function.
This is my favorite PHP function: function debug( $var ) { echo '&lt;pre&gt;'; print_r( $var ); echo '&lt;/pre&gt;'; } I solve most of my problems it. Also, google for the magic constants LINE, FILE, and the function debug_backtrace()
Upvoted for "started off with a small project" advice.
Upvoted for "start off with a small project" advice.
Google Analytics has a conversion tracking feature, which is likely what OP is dealing with.
Pretty sure you can plug a keyboard into a PS3, or they just put all the information in on a PC.
I have built a system over a couple years that does exactly this. You will need to be aware of relative vs absolute paths. Form actions may have to be changed and base href's may need to be used depending on how you structure your file system. Setup some constants with these paths so your script can best determine where it is.
I can see where this is a tough spot to be in. I work with Magento , and the checkout is all javascript, so I'm familiar with the surrounding issues. There must be some way to put logic around the javascript that sends the page view to analytics. Otherwise, a customized confirmation page could work. You could have the confirmation page/script redirect if it doesnt find a session variable, which would block any javascript from running. It seems whether you use javascript or curl here, both methods have some gotcha's.
I've done this before. Basically, you will need a method that parses the url, and initializes the application for a single user/site. The code should work whether you go to www.client123.com or www.mycompany.com/client123 . Whether both url's are exposed or not is up to you. Quick hint: I recommend parsing the url from right to left. Also, you will need DNS pointing at your web server and you will have a virtual host for each domain, that all use the same code path.
mcrypt, and pray they don't find the files that have your keys to decrypt it. Well, really... just make sure either the directories aren't explorable by the user that web server (or whatever) is running as.
your best bet would be via analytics api, if that's even possible
Even people with experience would tell you that. However, in large companies like Sony, you don't have the people with experience doing the 'trivial' coding, which is what inputting / getting the data layer would be. All too often in said companies, the people with experience are too busy to then look over the code for a decent code review.
Ideally, only my console would contain the keys to decrypt the information. Should that console break, I just need to input the data again myself. For how often that scenario happens, it seems like a good solution to me. That way, I feel I have more control over my own data.
Just have the customer send the tracking request. They're going to eventually load another page on your site, right? If they send the request, I think it links better with Google Analytics' traffic sources -&gt; conversion tracking.
Tokenization. Then you insanely lock down that basket and insulate it with layers of access services.
I'd be very surprised if that tracking feature didn't rely on cookies or at the very least IP addresses to figure what's what. By sending a tracking request from his server, OP will match neither, effectively turning Google Analytics into a dumb incremental counter for that particular request. 
You can make that into an easy one liner with echo '&lt;pre&gt;'.print_r($var, true).'&lt;/pre&gt;';
Handy tip to be sure, but it's unlikely he's using the MySQL command-line.
for htaccess I usually have RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . index.php [L] The first 2 lines specify to only route non existing files or directories to your index.php Then at the beginning of your php script you can have something like $url = $_SERVER["DOCUMENT_ROOT"] . $_SERVER["REQUEST_URI"]; $url = str_replace("\\", "/", $url); $url = substr($url, strlen(WEBSITE_DIR)); $url = explode("/", $url); $url = array_remove_empty($url); // Custom function to remove empty string values from array $client = $url[0]
As well as www.myclient.com (if they point DNS at you) .. and this is among the best solutions imho . upvoted.
This seems the most sensible way to go if it must be done with cURL rather than a pageview by the client.
This is true... I've seen iPHone pedometers, so it's definitely possible using the accelerometer. I agree you would need some easy way to input data. 
I don't know about the US, but in South Africa I think there is such a law in the process of being created.
I haven't found one like that for Yii. Yii is a nice framework but the tutorials are definitely lacking, it actually seems to almost assume you know another framework like rails before learning it. I actually started my last project in Yii, and found Rails For Zombies and ended up switching from php/yii to RoR. To be honest I haven't looked back, writing in RoR has really been a dream, it just is so well organized and uses convention to make a lot less work on me. However this is just an opinion, I still work on many php projects so hopefully I don't get flamed too bad. 
Cool thing about stdClasses (or other classes you may build that act as arrays) is that you essentially have array dereferencing. Thing you cannot do in PHP5.3, and have to wait for trunk for. returnsAnArray()[0]; Thing you can do in PHP5.3. returnsAnObject()-&gt;{0}; Aw yea. Also I would recommend using :bar :foo instead of ? ? as it's much clearer. 
See if they have a Github account or contribute to any open source projects in their free time. It's not an indication of skill, but at least it gives you an indication of enthusiasm.
phpToPDF works on an API based solution. We are running a webservice to provide you perfect solution for generating PDF files from PHP Code. We have simplified our API so that you just need to download phpToPDF.php file from your account, include it in your code and you are ready to start generating pdf files. Nothing is installed on your server. PDF Generation will take place on our server and a generated pdf file will be returned and stored on your server at specified directory with your specified file name.
You can, I mean a console should come with a cheap kb out of the box.
There are plenty of projects using FuelPHP already, myself included. We've got a huge amount of support with people like PHPDeveloper.org and HappyCog behind the framework. Documentation is up to 90%, the final 10% will be there before 1.0 is released. If there is anything left unclear then just ask us on IRC, there is always somebody who can answer in there.
The documentation has taken a massive jump since this reply so I suggest you have another look. For us documentation before 1.0 was the most important thing. The 50-70% docs for RC1 was just so those using it can have a headstart. Actually, those interested in the framework - and its community approach - have been incredibly happy to help by providing not just bug fixes but by documenting who libraries and sections. This is the community driven aspect in full swing. If something is not there people just add it, no complaining and no unfair expectancy (generally speaking, not saying you did either).
Some of the best work I've seen regarding Yii is the series by Larry Ullman. He covers all the main parts of developing with Yii, so it's worth a read. http://www.larryullman.com/series/learning-the-yii-framework/
Iterators are awesome. I've done some great stuff with chained [FilterIterators](http://us3.php.net/manual/en/class.filteriterator.php) in recent projects. Do yourself a favor and [check them out](http://us3.php.net/manual/en/spl.iterators.php).
I'd never heard of IteratorAggregate or FilterIterator. I've been using plain old Iterator for everything and there have been times when either IteratorAggregate would have been simpler or FilterIterator would have been more appropriate. Also, FTA: &gt; Iterators is a subject which strikes fear into the heart of many developers. Surely not?
&gt;I read that Kohana doesn't have the best documentation so I ruled it out earlier. Lithium isn't finished yet and it's documentation is incomplete. But it really is super awesome from what I've seen of it so there is always that.
Very good points. I recommend named params as well for larger queries. for queries with 1 value to escape it really doesn't matter because you don't have to count and track where they are going. In the next post we will probably cover FETCH_INTO and FETCH_CLASS.
I usually use a mapper to create_object from an array, so I have total control over exactly how the data is going into an object, but this is a bit beyond the scope. I usually use \PDO::FETCH_ASSOC too :)
No worries. In my case its not so much a complaint as a general observation. I can drive the car, but I can't build it myself. I'm not an experienced enough developer to pick apart code that has too many dependencies etc, because it just takes me too long. Granted, that's a good way of learning, so as purely an educational exercise that's fine, but when you "just want to get things done", needing to spend 4 hours to try to figure out how to replace a select box with a set of check boxes with a form builder is madness :) I'll have to keep an eye on this. Its bittersweet. The worry with a new framework is that it wont stick around. The problem with older frameworks is that several are in the process of a major rewrite and in a state of disarray.
this kid does a great job teaching CakePHP http://www.youtube.com/watch?v=nO9oSQhRa9s He uses the 1.2 code i think so just be aware that instead of $Form-&gt;input() or $Html-&gt;link() you would use: $this-&gt;Form-&gt;input or $this-&gt;Html-&gt;link() etc..
One time I complained on Reddit about not making a lot of money as a PHP developer and some one told me to stop referring to myself as being just a PHP developer, even though that's the only server side language I really know. It makes sense though; In theory I'm also a html, xhtml, html5, xml, javascript, jquery, ajax, css3, mysql, active record, codeigniter, doctrine, etc. developer. 
I learned CodeIgniter from http://net.tutsplus.com/sessions/codeigniter-from-scratch/ 