does anybody still use this ?
So better programming techniques then haha. Thanks man. I've always tried to figure out my approach in terms of how well an application performs. One of the problems with picking up programming around 2009 was that you can "afford" some clumsy code, lots of room for errors. But it always bugged me.
[removed]
Problem is, many of those tools have been violating the [Oracle JRE license](http://www.oracle.com/technetwork/java/javase/terms/license/index.html), which says you can only omit a few selected files, and of course cannot change any of the JRE files when redistributing. Looks like this will no longer be the case once those tools take advantage of the Java 9 modular features (and was never the case with OpenJDK of course).
A few I think, but most people who use Java web frameworks use either JSF or Spring MVC.
Yeah, I've heard that memory is cheaper than devs statement before. Just a horrifying idea...
&gt; Java Ranch come to mind That's titled "A friendly place to learn Java programming". That's the problem with most of these types of online communities: they get swamped with people asking what the difference between java.util.LinkedList and java.util.ArrayList is. That drives off 'experts' very fast. This same thing is true in this place as well; beginners questions tend to get a TON more answers (even though the mods are really explicit about those questions not being on-topic here) than architectural questions. 
Throwing memory is a short-term band aid, but it definitely doesn't scale well. At some point you can't simply double the size of datacenter.
IIRC you can add instances of deployment.javaws.jre.0.args for each JRE (by changing the 0 to the correct index, if there is more than one). Might need to ser 'java', instead of 'javaws' depending ... I can't remember, and I'm on my phone, so I can't verify. Depending upon your needs, you could instead set the JAVA_TOOL_OPTIONS environment variable.
[Relevant xkcd](https://xkcd.com/1737/) I'm a little sad with my basis of programming. There are so few people I've worked with who've genuinely understood that problem. I try hard to think about how my program is going to cause allocations and context switches to happen, but there are so few people who really understand the exchange between the code you write and the code that the machine actually runs. I hear assembly is a pretty good way to try and understand those impacts, thoughts?
You aren't the only one. However, sadly, we refuse to move to later versions of JSF and don't get to enjoy the new features.
I thought soft deleting was akin to moving a file to the recycle bin, as in you can get it back if need be
Indeed, he's certainly not the only one. In fact, a diverse range of polls places JSF at the first or second position of most used web framework in java. If that holds for this sub is an open question, but in general jsf is often used.
It would horrify me more if it would be the other way round nowadays... I would not be happy to earn so less money for my work 😎
Your criticism is entirely appreciated! The time factor might be true for you, and that is why this subreddit is a thing :) ! And people can assign themselves the titles, as it is more of a *be honest to yourself* system. People wouldn't gain much from lying to themselves and would be found out quickly either way. It is very hard to put people into skill categories, so this seems to be the most appropriate way. In my opinion, we have a lot of very skilled individuals in our community and i see people helping and being helped everyday, the goal is not to form an elite community. I have thought about creating a subreddit for the discord, but this would just split people away from the /r/javahelp and /r/learnjava subreddits which wouldn't be good. 
I would assume that the size of 50000 good oop crafted star entities is nothing crucial for Java in 2017 with modern machines. The rendering is the crucial aspect: which needed stuff you have to render? Depending probably on the zoom. Things 3d shooter are fighting since Wolfenstein 3D with its BST 😉 It is a question of personal taste and goal: Am I am interested in pure fps crunching without *tricks* (omitting not visible stuff) and have fun with cumbersome and none idiomatic code, or should I strive for an idiomatic solution with probably less performance? Personally I would **always** follow the idiomatic path, but of course other people (like the op) think differently, which is totally ok.
This is usually because you have the wrong version of eclipse for the JVM you have installed. For example if you have a 64 bit JVM you need to download the 64 bit eclipse. You can check the version of your JVM by running java -version on your command prompt or command line if running linux.
OK, I have tried both 32 bit and 64 bit eclipses 
Whar operating system are you using?
You are not alone, I do full stack Java and .NET consulting, and our Java web projects are mainly JEE based. Some of them still on the lovely Websphere.
Just get the lates JDK and update Java if possible
Too long; didn't read. What follows should be a concise summary of the article or whatever the TL;DR refers to. The summary should be short and sweet and is usually tailored towards people not interested in reading the entire written piece.
-vm C:\\Program Files(86)\\...\\java.exe versus the non (86) programs file version which would specify whether the javavm is in 86(32) or 64 bit mode 
http://vertx.io
&gt; On 2017-03-06 IBM voted Yes with the following comment: IBM's vote is based on the technical merits of this JSR and is not a vote on the licensing terms. IBM supports licensing models that create an open and level playing field by allowing third parties to create independent implementations of Java Specifications and that do not allow individuals or companies to exercise unnecessary control for proprietary advantage. We support open source as a licensing model for contributions in the JCP, and would hope others will support this direction. This comment is not necessarily directed at the current business or license terms for this JSR, however, it is a statement of IBM's preferred licensing model.
This video should not be called "Amazing Features of Java", but "Features of Other Languages that Java does not have" Example: "Operator Overloading is bad and is prone to programmer error" followed by "Java can do operator overloading in another way, so there's no point in adding it"
Try r/javahelp
When in doubt consult the collections docs https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html
Excited for this release, but also really not looking forward to migrating everything..
Our release on Wednesday is a rewrite of a JSF application that became a JSF/Angular/Spring hybrid, to now finally just Angular/Spring. I'm so happy to finally be dropping JSF completely. I haven't written much JSF so if there's an advantage to using it, I'm missing it.
[ArrayDeque](https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html)
That is true. It makes sense to migrate to V8 at some point in the future to stay "future proof". V7 is however supported even on the free opensource side until the release of V9.
there is no vm on here, what should I do in this situation? 
Well you could try adding the -vm argument. Make sure you have java installed (turn it off and on again style debug). Dependent on your attempted eclipse install (x64 vs x86) find the file path to your compatible JRE binary directory. The binary directory is the folder 'bin' within the jre/jdk/whatever_java_directory_is_called. So specify that in the eclipse.ini file and try again. I really can't help further because no windows virtual machine to test on.
"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%" -- Donald Khuth, in *Structured Programming With Go To Statements* I totally agree. My own approach to writing programs has long been three-step: 1. Make it map valid inputs to correct outputs 2. Make it not crash on invalid inputs 3. (optional) Make it fast, *if it is not fast enough already* So, idiomatic OOP can be okay for 50 000 stars, but what if you want to scale up to 500 000? What if you need to port to less powerful devices - phones or TVs? What if you have a server handling several multiplayer games with 50 000 live entities in each? I am observing this right now at work - colleagues wrote a piece of idiomatic Scala that passed all tests with flying colors but is a bit too slow to be put in production...
Looks like the path you specified was not correct. Possibly needs quotes. Again, I'm running out of hypothetical/testing space so I can't help much more than what I am.
No I appreciate it very much. Thank you for all the effort
&gt; Knuth's quote is often used as a bludgeon to derail any attempts at tuning. A frequent misuse of a quote in practice does not reduce its theoretical correctness, right?
To be interpreted properly, quotes must always been understood within the context they were given. At a time when goto statements made code hard to follow, Knuth was suggesting to minimize and defer code optimizations that would make code even less readable. With the advent of OO programming, one could argue that his primary concern can be addressed with encapsulation. Optimizing early may be perfectly ok if it doesn't make the code less readable. This is not an theoretical argument. For example, the Apache FastMath class has a lot of performance enhancements over the base Java Math class. You could easily "optimize early" by using the Apache Commons jar and substitute your Math references with FastMath. This absolutely violates the spirit of Knuth's quote as it is interpreted today, but absolutely does not violate its intent. Honestly no one would suggest that using Apache libraries is the root of all programming evil.
Now I'm waiting for the addons to be updated
Reminds me of my childhood, except I was 10 and the language was C, not Java. 
homework. do it so i dont have to help you on the job.
[removed]
JGrasp is a 'teaching editor', not a real IDE. So yo might as well go and use a real one at home to get the hang of it. Also: -&gt; /r/javahelp is more suitable for questions like these.
Your statement is again full of unprecise and unprovable thesis. Why is the duration of the generation of a galaxy crucial? You do that once for a run of several hours or probably even days! How do you know something takes up to 4 seconds on my machine? Or even on a cloud computed algorithm? And how is this worse than your current approach that takes 30 seconds (probably with lots of odds because of optimization)? 😎
What would be the most important add-ons that would need an upgrade?
&gt;taught himself &gt;£1295 coding camp ok
Got hooked on BASIC, age 9, against the *discouragement* of parents who thought I was just wasting time. It was magic, though. Forth a little later, C later still (I just didn't know they existed).
Thanks man, much appreciated :)
We use JSF too and its great! ;)
This post is nothing but shitty advertising for some overpriced camps.
Congrats! Can I use Vaadin outside a Servlet Container? Would be great if for example we can run Vaadin in Undertow, Netty, etc..
I also use JSF and love it. We are just starting a new JSF application. I do not see anything out there that can created a rich front end without a lot of additional work.
Thanks! Was actually going to add a section but the post felt pretty long as is. I'm writing a follow-up that's all about private/remote repositories. Stay tuned :)
Why don't we make one big 'programming' sub where we discuss everything then? Because that's what you're reasoning in favor of. The reason there are separate learning subs is because otherwise the "discussion" and "news" posts would be drowned out in beginner questions. This would basically lead to a collapse of the community since 'experienced' people coming for the news and discussions would move elsewhere. 
If used with Spring Boot you should bei able to use Undertow instead of Tomcat.
What's really neat about peformance expectations is that they are completely subjective. If I think that over 3-4 seconds is too long to generate a galaxy on the latest Intel i5 with 32G of ram, then it's too long. 
Since this is concerning **Java Programming** it should, as the *plenty* hints on the page indicate, posted in **/r/javahelp**. **Post removed:** programming help.
Dwarf Fortress needs iirc lots more time to generate a map - completly d'accord imho, because you spent lots of hours, days, weeks or even years with that instance. Within the game this would be too long, if that repeats regulary during player actions...
It's really much simpler than that. If players think it's too long and complain, then it's too long. If every game takes 30 seconds to generate a galaxy, then players assume that 30 seconds is the norm and accept that. But as soon as a game starts doing the same thing in 2 seconds, then player expectations change and 30 seconds is now too long.
ConcurrentHashMap is really nice, and you can actually use it for a concurrent set with ConcurrentHashMap#newKeySet. One thing to note however is that concurrent != synchronized. CHM guarantees thread visibility but it does *not* guarantee that writes to the CHM will block other reads in other threads. If you need an exclusive lock on the map, you need another map.
Depends on what you need. Charts are nice IMHO, Spreadsheet as well if you have a use case for it. I personally don't use designer much, I write the declarative thingy by hand (and use [vdecl](https://github.com/christoph-frick/vdecl) to quickly visualize it).
JGrasp is a neat little editor that is best used for teaching. It makes nice control structure diagrams (CSD) for some popular languages. I used JGrasp while at Auburn a long time ago and only used it once since I graduated. I use IntelliJ as my main editor but have no hesitation in recommending Netbeans or Eclipse. The one time I use JGrasp outside of the university was when I inherited some badly written code. The CSD made it a little easier to follow what the original developer was trying to do. Now that some time has passed, I use code formatting programs and a debugger (which most IDEs have now) to reverse engineer anything I come across. This is where IntelliJ pulls ahead of the pack.
JGrasp has a couple of neat features for students like the Viewer which displays various objects in graphical form as a program runs. https://www.youtube.com/watch?v=D-zrayZQj6w There's nothing wrong with using it but in "real life" you'll probably be using intellij, netbeans or eclipse. Doesn't hurt to try all of them. 
You pulled the old slippery slope. I said this sub is barely active and the other one less so, so why pester someone who will probably only ever come here once to take his question elsewhere. You took that and made it into "combine all the programming subs". You took the small, tenable thing I said and turned it into this huge, opposable force in order for it to sound ridiculous.
You'll want something to demonstrate you can code, such as a legit open source project with real users, a mobile app that makes money, or a portfolio of freelance projects... something along those lines. Alternatively, apply for internships (but hiring managers for internships will want some evidence you can code too before they'll ever call you back). Startups will be most open minded about you having no college degree. Also community colleges tend to be very affordable and might be useful if you need some structure to help get started in your career.
Try all of them! But if you find yourself in dependency hell tweaking settings all day long and never having a chance to code then fall back to jgrasp. 
If you work with a large team then please don't discard microservices. They're actually helpful.
Thank you for the info, this is just my personal list as a single developer doing stupid CRUD apps.
patch released monday with a GA announcement on Wednesday for 2.5.x and today for 2.3.x. We got the memo last night and have been rolling out updates to customers today. The information was not widely available Monday. PS - this really is a crazy serious exploit. It turns a struts application into an open command line for a script kiddie attacker. It's as easy as: exploit.py 'https://server' 'ls -ltra'
Here is a kafka logback appender that I like a lot: https://github.com/danielwegener/logback-kafka-appender
yes
Jokes on them, we're using Struts &lt; 1.3... Makes sense for a legacy application, doesn't make sense for a "v2" that is only a couple years old and was supposed to be a rewrite.
Right now you'll have a little bit of a hard time in the Java realm for a few reasons: 1. The major shortage is in the senior levels 2. Java can often be a graybeard culture - meaning it's not always super welcoming (depending on the area). Though maybe this is changing, and probably depends on your area. 3. Enterprises are some of the bigger Java users and often have really arbitrary HR requirements. But that's not to say it isn't possible, there are a few paths: 1. Network and make some friends, hopefully one of those can help you get in the door. But I wouldn't make that the primary reason for making additional connections - people don't want to feel used. 2. Get some good consistent open source stuff going, even if it's just a Facebook clone or whatever service(s) you enjoy. 3. Consider getting your foot in the door a round-about way. You could maybe start in QA or even a different technical role. I've helped transition a number of people from non-dev roles in (they are really valuable because they can often bring in really excellent business domain experience)
People still run legacy code?
Read the title. 
Thank you, I had never considered this. Is the returned KeySetView concurrent as well? I assume so given it is backed by the concurrent ConcurrentHashMap but the doc says it more indirectly than explicitly. Wonder why they haven't introduced ConcurrentHashSet as a top level class. I will read the source later, but if you are already confident I would love to know!
Thank you so much! I am on PluralSight right now! Do you recommend any other learning tools?
I'd look for a good Java bootcamp. Nano degrees from some of these moocs aren't too bad. Something to bridge the gap.
That moment when using an outdated library is a good thing. 
I feel that. But most I have found are highly expensive. And that's... why I'm avoiding University.
My thoughts as well when Heartbleed came out, the company's servers were so out of date that the attack was not feasible.
Open source aside, a library is essentially a black box. As long as it (a) has a proper API, OO, functional, or whatever is the paradigm of your project, and (b) works, using it IMHO does not violate the quote in question, whether you have insight into how it is implemented internally or not.
&gt; Then there were obviously no stress / load tests for the program of your colleagues? What makes you think so? There were plenty of tests, but the end goal is to replace a component with a bunch of known issues, so again (1) and (2) from my list above took (temporal) precedence. Now it works but is three times slower, which I think is better than "same speed or faster, but breaks just as often". I hope you would agree that profiling and optimizing a piece of working code that is well-written is more pleasant than tracking down the root causes of weird bugs in a ~~piece of s~~ piece of not so well-written code?
Yeah, "algorithms are for people who don't know how to buy RAM." -- [Jeff Atwood on Twitter](https://twitter.com/codinghorror/status/337060074717605888)
All sets can be made from a map. It's a common way of implementing a set.
Good info if you need to learn enough to support an old app. But, at this point, nobody should be starting new projects with Angular 1.x.
The tests are real world data, and the production release is circa three months away, so I am not sure why are you seeing a problem here.
Here is the CVE: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0114 And here is how you check if you are vuln. http://stackoverflow.com/a/23467193/131697
Because some Java applications use Angular in the frontend.
Nice. "So, zero has been faster than sized for at least 5 years now."
I have a sample code from a coworker who used java config and learning it line by line, what is the purpose of each object etc. Regarding the XML what are the repercussions of not learning it aside from not being able to read codes of people who used it, and would it be sufficient for me to just learn to read it or do i need to learn to write in that way too?
Dislike checked exceptions, having to write lots of boilerplate(though IntelliJ helps a lot). Also how long it takes for new language features to arrive and deprecated functionality never being removed. Like the ecosystem around Java, libraries, frameworks, build tools etc. The verbosity and type safety also means I can often quickly understand what even big Java programs do quickly(bit harder if too enterprisey). Hard to make mistakes in Java in my opinion, so good for large teams of varying skill. The JVM also spawned a ton of cool languages.
Dislikes are all likes for me :)
I rarely write Java, but when I do, I always forget that the '==' operator doesn't work with Strings, which generally creates an hour or so of me pulling my hair out. There are a lot of little quirks like that that I dislike about Java, but I definitely understand its popularity. For my money though, I'll take C# any day. 
It's almost as if anyone reading /r/java already knows all of this. 😂
pays the bills
That's incorrect. Type erasure was chosen in Java so that bytecode compiled with generics wouldn't break in 1.4 JREs. The language fundamentally didn't support it, and so they sort of "bolted it on" to support it. In the .NET world, on the other hand, they decided to make generics a breaking change in older CLR versions, and this is why they were able to use reified types. In this sense it was not "bolted on top."
I love Java, but, along with the == problem with Strings, the one that trips me up is BigDecimal.equals does not behave like I think it should. To me, 3 and 3.00000 are equal, but, you better remember to use compareTo instead of equals with BigDecimals. 
Out of the languages I've used Java is the most straightforward to debug so I like using it if I expect to write a lot of complicated code. I'm not smart enough to do that in other languages without wasting a huge amount of time fumbling around not knowing what's going on. What I don't like is things like reading and writing files have syntax that is kind of wordy so I end up wasting a few seconds here and there looking things up.
IIRC, a few deprecated and very little-used APIs are going to be removed in Java 9.
`{{ ... }}` isn't a particular syntax (unless the parent is talking about something I'm forgetting). I think it's the combination of the anonymous subclass scope syntax, which is `new Class() { ... }` and the syntax for an initialiser block, which is just `{ ... }`. Put one inside the other, and leave off the `new Class...` bit to make your example look more dramatic, and you have `{{ ... }}`.
Like: Runs everywhere easily, good libraries and tooling, the fact that I get paid to write it. Dislike: Unchecked exceptions (it's funny, someone else complained about checked exceptions), how fucking verbose it is, the bad support for sum types (is there a good way to do sum types?).
Yes, this. I didn't mean to be dramatic, just not as verbose. It can cause memory leaks that are hard to track down, and it's not very clear for a java beginner that a new class have been created. This answer on stack overflow explains it a bit better: http://stackoverflow.com/a/924536/131697 Re
XML config makes more sense if you have a lot of "knobs" to turn IMHO, some projects will actually be configured faster using XML
You have to deal with it how? If you don't like seeing this pattern in your codebase, you can not use it. If other developers in your team use it, you can ask the company/team standards recommend against it. And if it's third party code, then you don't have to deal it as it's third party implementation code you never see. You can write horrible code in any language. The `{{ ... }}` pattern was never endorsed Java, and it's borderline "code golf" and doesn't belong in professional code, as not only it's somewhat obscure, but also has suboptimal performance (anonymous classes wasted, bindings wasted, additional RAM taken etc.).
What problems are you trying to solve? One doesn't "use imports" for the sake of using imports; one imports classes because those classes help do specific things one needs to do.
Oh come on, at least the generics and enums are good.
String interning is optional, so overloading == would change the behavior of programs. String is a reference type and no where else in the language is == redefined for a reference type. I agree there should be a separate operator, but that's pretty much what I said above in terms of non-paranthetic operators or function overloading. "is" could be one such method / operator. I also agree that "==" would have been better reserved as an overloadable operator, and "is" would be a better identity checking operator. Basically, identity comparison should not be overloadable, but it would be fine if many other operators could be overloaded (including named operators, and == if it were the value comparison operator instead of the identity comparison operator).
The fact that BaseStream doesn't extend Iterable despite having the same exact methods is kind of fucked up. Otherwise, you should've been able to do `for (int i : IntStream.range(0, n))`. I guess if you added a wrapper around it. I'm sure there are plenty of third party libraries that offer the equivalent function for doing that sort of thing.
There's long discussions about streams extending Iterable on StackOverflow and the main points were that there are already cases where it does (I think), and that it ought to. Hopefully it will in the future. I believe you can cast an `IntStream` to an `Iterable` or something similar and it will work, but it looks very funky and lengthy.
Recently tried to do a little rest API with the MEAN stack and wound up going back to Jersey. Though I did stick with Mongo. Used to be Java was almost useless outside of the enterprise because nobody wanted to host it. So I'd have to use something else for personal projects hosted on Dreamhost or the like. But now cloud services like Digital Ocean will host a jvm for me for pennies, so I'm actually using it more than I used to.
&gt; It can cause memory leaks that are hard to track down, and it's not very clear for a java beginner that a new class have been created. A beginner doing things that aren't clear to him. More at 11.
&gt; Java can often be a graybeard culture - meaning it's not always super welcoming (depending on the area). Though maybe this is changing, and probably depends on your area. I have honestly never heard this sentiment before when it comes to Java. It's one of the most, if not the most, popular languages in the world. That statement seems more applicable to a language like perl or something.
I may very well be alone in this, but I like checked exceptions.
It being popular doesn't really imply anything about whether or not we as a group are really welcoming or not. It's hard to introspect, but it's something I have heard quite a number of times from people around. Like I said, it may depend on the area. But other ecosystems really embrace newbies and what they can contribute. Perl is different, it's a more antiquated language and ecosystem that's been, by a few measures, steadily decreasing.
I understand what you mean, but I don't agree with you :) Let me take another example of something that I think is bad language design: That c++ templates are turing complete. It's something that isn't by itself a "construct of the language", as it's composed of many smaller features with templates that come together and produce the turing completeness. But my personal opinion is that c++ became a worse language because of it. With that said, I don't have any proposed solutions to the {{ ... }} situation, it would be dumb to remove anonymous classes or initializer blocks. But then again, I don't create programming languages, I just use them.
(:
I think it is something left over from the days of yore when most programming was very low level. I can remember being a programming student and reading the perennial question on Usenet "what sort of programming projects can I do to learn a language?". One of the answer was to write a file reader in hex. 
Maybe the best option would be to run with it and make the Java compiler/runtime recognize some use cases that don't require binding `this`, and don't require creating an anon class, and optimize for it. So code stays the same, but performance and memory issues go away. That's probably the opposite of what we've been talking about, but... anything else would be uglier.
Agreed, Java was adopted at the right time when the Internet boom and lead by Sun who developed server and CPU. On the same note can be said about Apple Swift.
Reading ARINC data and decoding it requires all of these to line up with the specs for various messages about fuel quantity, fuel flow, SSM bits, and a dozen other fields. The manuals that describe these systems use a mix of binary, hex, and octal. Being able to use constants and bit manipulation directly with those values makes the code very readable by our engineers. 
For one instance, parsing a standardized datastream. As an example the first two bytes of a jpeg image are 0xffd8. Code that checks that using hex is easier to read and write than converting that to decimal. 
I think it's great having both. I myself use unchecked most of the time just so it doesn't pollute my code too much (especially when I'd have to add *throws MyException* to a dozen methods) but in other cases I do use checked ones, especially when they're only throw once or twice across the call stack.
Ok, octal and binary values, but no unsigned integers ? I mean if you're doing low-level stuff, then please give my unsigned ints before you give me octal and binary. 
[Javaslang Iterator](http://static.javadoc.io/io.javaslang/javaslang/2.0.5/javaslang/collection/Iterator.html#range-int-int-). Use static imports and it would look exactly like your example.
So then you yourself are saying that this shouldn't be here? this article is about about java. 
Generic syntax is awful, that's why they had to try to fix it with the diamond syntax.
Octal values are mostly used by accident: LocalDate x = LocalDate.of(2017, 07, 02); // OK LocalDate y = LocalDate.of(2017, 08, 02); // unexpected compilation error ;)
when talking/dealing with data from older systems. i deal with a lot of ebcdic and cobol data from copy books. some of the tricks to packed decimal involve moving bits (using binary) or reading data directly as hex and converting it to decimal.
Lots of things are "valid" but in poor taste. That's true of any language. Just because you can, doesn't mean you should.
Octals are useful for specifying file permissions on unix system. 
Yeah, sorry. I didn't mean to sound condescending or anything. Just tried to explain it in a way to make it easier to accept.
I do a lot of protocol work, different protocols document in different ways and it's easier to visually match the specification.
I like to use hex when expressing 24 bit color values because the rgb values fall cleanly in digit places, so 0xFF00FF has a red value of 255, a green value of 0, and a b value of 255. It wouldn't be immediately obvious if I wrote that number in decimal, which is 16711935.
While we're at it, can we get some byte and short literals? Anyways, adding octal and hex is just a javac compiler addition, whereas unsigned values are much more complicated to support cleanly (It seems like).
like: Simple. I find Java to be a very straightforward language. No weird parts. Everything just works the way you expect it to work. (with the exception of generics which are a bit weird) dislike: verboseness &amp; boilerplate. Checked exceptions 
There would have been no negative numbers if they weren't signed. 
Negative bytes? Why not just 0..255. At least they aren't negative Booleans. 
When dealing with bit manipulation, these can be handy. For example building a good hash code, or for stereographic encoding. For specific bit strings I use the underscore as well: 0b0100_1100. Hex is useful to shorten the binary, but if I'm doing specific bit stuff, binary is handier. Haven't used octal yet. 
you wouldn't. It'd be unsigned just like char. The point of bytes isn't arithmetic usually, it's io and bit fiddling, where unsigned values are much more useful 
We already have char though. The problem isn't unsigned values, it's adding primitives. Hopefully valhalla will fix that :) 
Yeah once you spend a little time getting used to something funky like file apis you either put together a quick abstraction or a new library comes out that makes it all easier.
I don't know if this is still true, but some libs like cxf, camel, etc haven't done a lot of work in documenting their usage with Java config. 2 years ago, i gave up and used xml config for those parts.
&gt; JAR hell How long ago were you working with Java? With Maven and a plugin this is a non issue.
You made some excellent points as to why Python is in some ways newer than Java, at its roots.
A big difference is between the two is that with microservices the endpoints are smart and the pipes are dumb. In SOA, it was just the reverse. The difference is huge--if you ever had to program an ESB, you'll remember how unpleasant that was. 
There's no need to let everyone change your program.
I am everyone.
lol well, no one's perfect. the no lambdas was a negative. i don't know how well it's been implemented.
Is that a joke? What projects are you working with? A Fucking pom is your solution? Of course I'm using Maven, but fucking Java picks just what ever version of library is linked first, faulty by design. 
You can, but it's easier to just manipulate the hex values then use a wrapper, especially if you want a color that isn't predefined and edit that color on the fly. (My opinion, of course)
Bullshit. It looks like have not even tried using them. Besides lambdas are a small quality of life improvements. They are not a language defining feature. I prefer discreet testable methods to using lambdas except when it's just a menial task.
Still having a screwed one is better than not having anything. Building libraries without it would be really difficult.
Of course, you are absolutely right. I just wanted to add that this is a technique also employed by the Java standard libraries, meaning that this is also somewhat intended and endorsed.
Additionally to what /u/redditsoaddicting said, there's also [javacpp-presets](https://github.com/bytedeco/javacpp-presets) for some popular C++ libraries. JNI and JNA are not transpilers (translating one to another) but bridges to call functions of another language in Java. They are working on [Project Panama](http://openjdk.java.net/projects/panama/) to improve this mechanism.
&gt; (Java 9 modules seem inane Why? 
&gt; may have had some good reasons. That's what I was pointing out. Java was originally designed for the set-top boxes that were being developed in the early 90s. &gt; I remember 8-bit assembly and even then they had 16 bit integers. Yes, but if you could get away with using 8, you would. In that context, there was also a consistency issue: all numeric types were signed by default. 
Agree they're annoying when the exception will never actually happen. Would still rather have them though.
Interesting, I hadn't heard of Project Panama. Then again, the only real interfacing I've done was fooling around in a high school Java (more like Swing) class. JNA was great for that. Super easy and nothing special needed in the DLLs.
I like checked exceptions, but I think the standard library overuses them in places where unchecked exceptions should be used
Started my day with /r/gunners and arrived here to read a nice blog, but the meme continues....
&gt; Dislike: lack of an "opinionated" way to do CRUD apps. I think Rails got this right. You mean ActiveRecord? In Java many people don't touch ORMs. At my first real job every team was using myBatis. Nowadays jOOQ is very popular, and I would probably pick that if I had the need.
&gt;it's a simplistic and purely contrived example, That's the point. It's not a real API at all! Of course, if we were writing the API, we could create it as we wish, but suppose that upon "foo" failing, we have to call "bar" and so on (like, say, calling "close" on a SQL connection) which is enforced by a 3rd-party library. In that case, we are screwed!
It's been researched but not considered for OpenJDK. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.2.7362&amp;rep=rep1&amp;type=pdf OpenJDK is getting Shenandoah which is designed to be very low pause, even compared to G1, whilst still being compacting. Pause times are meant to be independent of heap size.
\*scratch\* buffers? I know I've heard of them before... http://pragmaticemacs.com/emacs/instant-scratch-buffer-for-current-mode/ They are even called the same thing.
&gt; I think the standard library overuses them in places where unchecked exceptions should be used Absolutely. People say that the IDE can take care of handling them - sure, but that still adds visual noise!
Like: - Static typing. Dynamic typing is a nightmare on any team sized project. I consider it a nightmare in my own code written 3 years ago, but it's definitely terrible on large projects. Static typing's biggest advantage is forcing everyone to document the type's they are using for vars. After that you might as well g - That it doesn't try to be overly compact and less readable. I'm happy you cannot overload operators, or come up with super compact but indecipherable commands. - Garbage collection of course. Huge reductions in headaches from memory management, or security issues from pointer arithmetic. Dislike: - How is it that it's been over a decade, and we still have to write/autogenerate getters/setters??? - And get/set naming can be very awkward. booleans are isHasMoreItems(), or isMoreItems(), or getHasMoreItems() or getMoreItems() (is that a boolean about if it has more items, or a list of the remaining items?). Then in jsp's you don't use the get, but in java you do. You should never have to write get/set in front of a method name anywhere really. You should be able to write .hasMoreItems or .nextItem and it should be consistent everywhere. - They keep bolting on other language paradigms in small chunks and I think they're doing a poor job with it. I don't mind generics, but foreach I is good in theory but I never use it because it doesn't let you access the current index. Same deal with some of the new iterator foreach stuff. Lamdas feel extremely bolted on. - My biggest fear is they will keep adding hodgepodge other language features until java is complicated mess. It may be verbose but it is/was consistent and not complicated to figure out what was going on. - Some annoying things from when it was first created. == compares value with primitives but compares references with objects. I think .equals() should be part of an interface declaring that "yes, I did write an equals method for this object". That you can easily create small hardcoded arrays but not collections, very annoying for quick test code. Arrays.asList() no longer works as you'd expect after generics were introduced. - Other languages have nicer syntax now, that avoids the crunchy looking semicolons and braces. 
Seeing my [other comment on this thread](https://www.reddit.com/r/java/comments/5ytz0b/what_do_you_like_about_java_and_what_not/det94h7/) getting downvoted to oblivion, I now understand why Java sucks. It's because the Java ecosystem is mostly filled with pea-brained programmers who cannot take critique, even when asked for.
`forEach`?
You can't change values bound to the lambda that way. Mutation is still sometimes needed.
True, but in those cases I don't think you're supposed to use Streams or the functional paradigm they represent. Or just use `map`, depending.
Lisp has a way better IMO notation for non-base 10 stuff. #x10 == #16r10 == 16 #o12 == #8r12 == 10 #b11 == #2r11 == 3 The old C way (which Java uses) always kinda annoyed me
Whatever
&gt; Yes, we could say that main throws MyException, but that defeats the whole purpose of having checked exceptions in the first place! I disagree. Checked exceptions are meant to not be ignored, but if you can't or won't handle them within a function, there's nothing at all wrong with adding a throws clause and passing the buck.
I personally would go with LWJGL, is your keyboard broken?
Yes, java can be your first language.
Java is an excellent starting point because of its readability and the concepts can be applied just about everywhere. I started with PHP a long time ago and I was using Intellij Ultimate and decided to try out a Java web framework. Launched it from my IDE and realized I had been missing out, that I could understand Java code better than PHP with out ever using it before. 
I'm in my first year of uni learning Java. All I can say is it doesn't matter the language, focus on logic, then algorithms.
Well, practiceit is a good website to learn on, I have just started learning this school year, and am taking the AP test soon. Practice it lets you practice many of the concepts pretty well.
Checkout Adobe XD or Sketch
Good point. I'm sure bit packing is going to be really effective in relieving your GC pressure. I look forward to whatever contrived example you can come up with that demonstrates that being an effective technique. Your second reason is exactly the reason I said you might use it, so thanks for that.
JMonkeyEngine for retained, libGDX for 3d with less hand holding, lwjgl for you're almost at the bare metal (ie GL with a bunch of simple low level utils) JMonkeyEngine is easer probably but I didn't find it the best performance, libGDX probably has the best balance, ie you get batching and simple culling, and a physics library (bullet with jni interface)
Java is a bit verbose compared to other languages. I would suggest you also look at Ruby and maybe Python.
Much less of a learning curve if you're already proficient with Java and highly useful and valuable, employment wise. 
Spring, Servets, JavaEE, Android, Libgdx
&gt; Can I pick Java for my first language if I'm just learning how to code? Yes, absolutely! I've been a java dev for 10 years and I understand the arguments against java as a first language, but you know, people have learned to code with C and Assembler. I think being able to build something you're excited about with your first language is much more important than choosing a first language that has less annoying boilerplate (that boring stuff that you have to write just to get your code to compile, like "public static void main(String[] args) {") than java does. &gt; in the past, I wanted to give up at the sight of difficulty. I just don't have the ability to move on with it. Yes you do. You learned to walk and speak English and use a computer enough to come here and ask that question. Just because all those things are simple for you now doesn't mean it didn't suck a lot when you were learning. The thing with programming is that you've got to be stubborn enough to keep grinding away at it when nothing works and you feel like a complete idiot. Only you can say whether you want to build your mobile app badly enough to keep going. It'll suck sometimes but there are lots of people here and all over the internet who will help you if you keep trying.
Generics.
I know C++ and java and some mc68k assembly and now im learning Android development though this play list. Its 85 videos but they are all extremely short and easy to follow and understand so I highly recommend it. Android App Development Tutorials: http://www.youtube.com/playlist?list=PLFhfnOjjZFcSKaZ72gyy7KyWpP5idY1Tq
I've been thinking of doing this as well. After find out there is good job market for Java I've been thinking of focusing on expanding my knowledge with Java instead of pursuing web development, especially since I've already put a lot of work into Java so far
You need a tutor, not a language. Java is complex and verbose, Pascal is a language for beginner. You should look Scratch
Wouldn't something like react native be a better choice if you want to go down that path? Two mobile platforms with a single framework?
What did you use to program it? And why not LibGDX?
Can I work als a team with the free version? I know they are similar, but why should I choose C# over Java? And I don't know anything about C# :c
But LWJGL hast no Model loading etc., I would have to do that on my own and I don't rate my skills that high. And why should my Keyboard be broken?
Okay, thank you. That leads to my second question which I forgot: ist it possible to make low poly water with libGDX or jme3? Like just some vertecies, slowly moving Up and down?
you could also check https://lwjglgamedev.gitbooks.io/3d-game-development-with-lwjgl/ (https://lwjglgamedev.gitbooks.io/3d-game-development-with-lwjgl/content/chapter9/chapter9.html). there are some cool chapters about loading models in lwjgl
that is a pretty good idea!
Have Java Minecraft be able to connect to C++ Windows 10 Minecraft aswell as join the windows servers. I wanted a Mod for Java Mc to be able to work with the windows 10 platform.
Java is an awesome language to learn first! Java is the first and only language I've been working on. I would recommend trying udemy.com it has courses for anything you are interested in learning and a bunch for Java and application/game development :) also if you do decide to go for courses there, they retail for $200 each but you can wait about a week or so and a lot of course go on sale for $15-20. 
You are going to have a lot of fun! I learned to program in C. 
Okay, so that wouldn't be aß hard as I thought... What about Shaders? I mean just simple lightning, so I have to do that on my own? Or reflections?
Looks interesting but i can't see wide adoption of its usage as imo there doesn't seem to be an everyday use case
maybe. java has certain specific features not available in other languages, maybe even more than any other language one might want to start with.
My take: it's not really about debuggers vs this toString. it's more like if you have a class which has a bad toString and you were printing with System.out. And now you have a chance to see more 
It isn't bad, however when working with 3D, libgdx has no editor or viewport, both things which make working in 3d very easy. You could use something like blender mixed with libgdx I think its called bGdx or something, but jmonkeyengine is far easier to work with in 3d. In addition jmonkeyengine has nice 3d features and tools like simple water, terrain sculpting and painting with mipmapping and other various 3d engine things. Note to remember that jmonkeyengine is an engine, libgdx is a framework. 
I would strongly suggest you to avoid xml configuration and go for java config. If you work with Spring Boot (but also Spring) you will be able to do anything via Java Config. If you prefer you can still use both of them in your project, but really, there is no need to do this. IMO keeping all configurations in java code via Java Config helps you focusing on the project and is less distracting and is the way that is currently suggested to adopt for new Spring projects. I'm creating a spring boot template project where everything is configured via java config. I'm still making it but check it out here at [springboottemplate.com](http://www.springboottemplate.com)
True: You can do it in java too. But nobody (to my knowledge) has written thin toString.jar library. The closest you get is commons lang. Also, by doing it as a script you get it to work straight away for nashorn, java and nudge4j. 
&gt; Have Java Minecraft be able to connect to C++ Windows 10 Minecraft I'm not sure any suggestions here will help you (feel free to correct me if you've tried and succeeded). As far as I know, they all act like wrappers to invoke specific function calls in libraries. 
Okay, thank you, I'll take a look at it ^^
All the "ist" in the post 
But why are you printing your object with Sysout in the first place? If it's for the user, you should probably not just call toString anyway, whereas if it is for debugging purposes, why can't you use a debugger?
&gt; The code comes with a good trick to load it on demand The trick is good indeed, but it does not work with Java 9 (getSystemClassLoader() != URLClassLoader, setAccessible is also blocked)
Wow. That is very interesting, I guess we should update this too http://stackoverflow.com/questions/60764/how-should-i-load-jars-dynamically-at-runtime
Ohh, I just saw it, sorry. My auto-correction changed it :c "Ist" ist the german for "is"
You can get some inspiration here: https://www.reddit.com/r/java/comments/5fvacy/what_features_of_java_8_are_you_using/
This is a link to a presentation video/slideshow
Yah it was just to see if it is possible to have java interact with C++ which seems it is possible but not easy in any way.
Java 9 adds a search field to javadocs generated by 'javadoc' as well.
That post is really helpful. Thanks.
It is for Android. And also, it is clone of terraria. By rewriting Terraria, I mean rewriting it in Java, but with old content. 
Yeah, thanks to java 9's modules.
Well React is a JavaScript library for rendering HTML UIs and Java is a backend runtime for creating (in this case) web APIs. They're entirely separate things which span quite a few components and concepts. Your best bet would be to pick one or the other and start there, only coming full circle when you are comfortable with your level of understanding. There are a gazillion tutorials on both 
?
Reminds me so much of what i did a year ago. I'll join in if I find some time :) 
Although an improvement over no search, I expect every search function to have subsequence matching. I tolerate nothing else.
Commons Exec, ZT Process, and NuProcess are popular libraries. I suspect there will be many people happy to have this API.
I think Java is too complex for a complete beginner. Better to start with python, and the most important is to learn the theory behind, not only the lenguage.
Good work.
Sorry :( Guess this is what happens when MS buys Minecraft?
Need to use some lambdas bro... public void onLoad() { ModAPI.addKeyBinding(Input.KEY_G, () -&gt; ModAPI.getPlayer().setGhostMode(!ModAPI.getPlayer().getGhostMode())); }
Honestly, Java-LibGDX is pretty nice and has great cross-platform support. And Java is fast-enough. After all, the heavy lifting is all done by OpenGL. 
Yeah, honestly Java and C# are pretty darned close in terms of performance. This isn't surprising considering how similar their runtime environments are. They both compile to byte code which is interpreted by a virtual machine. They both use garbage collection and they both are object oriented languages with elements of functional programming and imperative programming. So... pretty darned similar... https://benchmarksgame.alioth.debian.org/u64q/csharp.html
It _should_ run on desktop but it is [designed](https://cloud.githubusercontent.com/assets/7306503/17391892/7f93f3f2-59ce-11e6-8e88-9a50d4074c0c.png) for mobile.
&gt;hence my statement Ah, right. &gt; Not sure OP is interested in the existing clone Well, that's a clone but this seems like OP wants a faithful rewrite.
ugh, now *I'm* feeling queasy.
As I understand it the JVM has three levels of code cache and the CLR has one. Anecdotally, we had a huge enterprise server app in C# (it performed sequential, long running computations so run time for tests is easily comparable) that I transliterated into Java 8 two years ago and with that change alone and no real structural ones, it got about 20% faster.
I made a mistake looking at this on my lunch break. Gross
.Net support is faaar expanded from what it was on Linux even a year ago. It has a lot of nice super-high-level features inbuilt, but neither Java/C# gives a clear advantage imo. I far prefer Java since Java8
Try out the exercises from a Lambda Hands-on Lab that we ran at JavaOne 2016. (It also covers the streams API.) https://github.com/stuart-marks/LambdaHOLv2 The instructions are for a pre-loaded VirtualBox image, but basically all you have to do is install NetBeans and use it to open this project.
[Optional Arguments](https://msdn.microsoft.com/en-us/library/dd264739.aspx)
First: *wrong subreddit* Anything learning Java related should go in /r/learnjava, programming help should go in /r/javahelp Second: &gt; but I want to know which Class In swing / Awt are good for making simple games (I say, graphics and simple moves) Programming doesn't work that way. Programming requires **you** to come up with the cool stuff. There are no classes that are inherently *good* for making X - classes are just Lego bricks. You need to be creative with them. For games, neither AWT, nor Swing are the solutions, BTW. There are proper libraries, like *libGDX*, *lwJGL*, *jMonkey*, etc. Still, you should first get *really proficient* in standard Java. With only one month in, you'll have a serious lot more to learn, no matter of previous Python experience or not. OOP in Java works completely different to OOP in Python and you need to be quite firm in OOP before moving on to games.
Software developers? Nitpicking? Why I never! 
&gt; How does anyone even think that's a good idea? Deadlines most likely.
What are your thoughts on Mono?
Oh whoops, I was thinking about OP's project. Still seems like it can't be that complicated.
Isn't Terraria written in C#? Although I'm sure .Net has an equivalent of Java's i18n options.
you can get a very effective and cheap sea effect (in terms of speed) just by using a fragment shader on a flat plane (its better than you'd think - https://www.shadertoy.com/view/Ms2SD1)
No, I'm on Windows myself and I like Visual Studio so I'm using VS Community 2015 and 2017 for C++ and C# stuff. I'm eager to give it a try though now... https://www.youtube.com/watch?v=TZF46oPBHPc There's some video of developing .NET core app on Ubuntu with VS Code. The video's a bit old already though, things may have changed since then. It's definitely not perfect by any means it seems. But I guess it's a viable option now. Not the best option, Java with Eclipse IDE and Maven or Gradle as dependency manager for example might be a lot more user friendly and quicker to develop in.
Your enthusiasm makes me want to hop in and futz with it! I've been steeped in C# at my day job so long that Java's verboseness is an immediate turnoff (I'm heavily invested in the var keyword, properties, and LINQ), but I'll have to give Java 8 a shot
Lambda is love, lambda is life ♥
Still faster, at least for web stuff: https://www.techempower.com/benchmarks/#section=data-r13&amp;hw=ph&amp;test=plaintext
Mono is slow and have really old and slow GC
I'll look into it. Maybe I can make my presentation partially interactive
I'm just saying large switch statement etc... it looks like it was written in C first and then ported. 
Same I'd love to help out if you need any
Sorry for use the wrong subreddit, but thanks for the answer ;) 
It's not about choosing C# over Java (despite the fact that C# is quite modern). The point is Unity offers you a far better toolset, and an IDE for all stuff gamedev related which is sort of a pain if you want to do beyond drawing polygons/sprites on screen. Take a look at the unity demos/tutorials. I myself started learning libGDX through a MOOC but I gave up in between and started learning Unity instead. It's akin to writing your large enterprise maven java project in Notepad vs using IntelliJ. 
Java is as verbose as you want to make it. But, yes, in Java you define what you want then you create and return that object with what you want in it. So method "A" creates object "B" with values X, C and Z. Python does have its advantages in this. You can return values X, C and Z ~ or ~ B, Y and Z without having to define an entire object to contain all of these values as you would with Java. In the end, your coding apples to oranges. Each language has its strengths and weakness. After being a Java guy for 10+ years I'm really digging Python. Is it a complete replacement for what I do and what I want to do? No. But I'm finding that Python is a good replacement for bits and pieces of things that are legacy and could be simplified. You cannot go wrong with either choice. 
There is a ton of stuff to learn about Java. What about Spring or JavaEE? Then there are application architecture patterns in Java...
I haven't; it wasn't really on my radar to do so at the time, and it's been a while now. The code's all proprietary, though, and relative performance between platforms on this kind of thing is really pretty dependent on specifics. Actually, we've since ported it to Kotlin, and I'd be curious to run the experiments again to see how it stacks up. (Edit: of note, the test comparison was run on Windows, as you might have imagined if it was a CLR app two years ago.)
Generally, I do my bean configuration in Java using Spring's annotations. It's just easier. Pretty much everything you need to do with beans is in the Java annotations now. I remember when there was no other option but to use mountains of XML config. Thank goodness those days are gone. As for other config, like properties and environment settings, YAML has made life much easier for Spring developers.
I would not have all of your static content in a JAR or a WAR. You want to deploy those things separately from your application logic. This is basic separation of concerns - you want to sever that tight dependency between the layers (UI &amp; domain/bus). There are technical reasons too. If you have no Web server and clients are connecting directly to the app server, then you have a larger attack surface for your application. Not to mention, something like NGINX is going to have more features related to being a web server and it's going to be better (faster, more efficient) at serving static content and routing web requests. Now, that doesn't mean you can't have all of those artifacts in the same IDE at the same time. They just don't all wrap up into the same artifact that requires a redeploy every time you want to change a color on a web page. Bottom line: use a web server to serve client-side web/static content; use a Java servlet container/app server to run Java app/bus functionality
This looks interesting, would you mind saying what compelled you to make a new game engine or what you hope will separate it from others? Looking at your Read Me it seems like your engine is very straightforward and gets you going pretty fast. It looks like you have a bunch of built in methods and classes to streamline development, at least more so than a framework like libgdx (the java engine I personally know best). 
I first created it because I thought it was a fun little project. I also wanted somebody with basic java knowledge to be able to use it and create something with it. 
Im pretty sure they released a big update that rewrote most of their code. Last time I decompiled it I'm pretty sure it looked better. 
This order ?
 If(name == "Green Slime") { return new GreenSlime(); Ummmmmmmmmm what? I kinda also felt a bit sick looking at your rewrite m8. Also your enemy class seems to have a bug where you don't ever se the maxAi. 
Maybe this will be replaced with HashMap.
This is their most recent release. Freshly decompiled out of my steam library folder.
Okay, I'll maybe take a look at it but I'm more likely to stick with Java as I'm also using ist for other stuff and also want to improve my Java skills by programming the game - it wouldn't help if I'd use C# ;)
No he's talking about the source code for the original Terraria
As somebody that has to deal with significant portion of the domain data being string values, this thingy is freaking awesome: https://github.com/tguzik/valueclasses The basic idea is the same as in TFA, but the library provides a decent blueprint that doesn't require screwing around with compiler plugins or annotations.
I don't think that this is a good programming style.. To add one arrow, you need to put it in many places...
Yeah! I love the swarm intelligence 😎
[removed]
[removed]
[removed]
What if developpers had made a game tool a la gamemaker that generate that code ? Generated code should follow coding standard? That's a real question. We used to use a generator in my company and it generated ugly code but noone had to read it, we even deactivated sonar analysis on that generated code. I imagine that's a bad practice but that code still runs in production on major websites even if the generator was written 10 years ago. And that's the most reliable part of every application using it.... We can't compare developpers' skills analyzing decompiled code that was generated. The thing that let me tell that is that the game had a lot of updates when it was actively developped. And that level of technical debt would not have allowed to support the rythm imho
They could make a tool like this. But again, this is not the way, that game programming patterns recommend. Read this article: http://gameprogrammingpatterns.com/prototype.html
This looks very interesting. I will mess around with it when I get a little spare time.
You should probably get rid of the original Terraria assets in your project.
If you would use your brain, you would realize that there is no human beeing that is so stupid, that he will create something like that. Those switches &amp; cases are compiler generated. And also, the class is decompilable, which decompiler do you use? In fact it is well written, you see it in other classes, so from that, I assume that the coder does not create shitty code when it's rainy outside and he does not create good code when the sun shines... Let's assume that it's really not compiler generated (which it is, but yeah), who says he did not create a tool which creates the code from him? A switch can actually be faster than a KeyValue Store, as long as you dont hit the cases to often.
It's very popular in Rust dev. At least you can see that many devs focus is here (for example it's dev/test platform for Rust Language Server). I'm using it personally for Rust and I'm happy. There are many things missing but compiler is your friend.
Ah ok. Thing needs some docs and major fixing. Might I suggest using some sort of factory pattern for the enemies instead of having the if statement there. 
Static methods are Java's equivalent to functions, so you're actually going backwards here. I.e. it would be cleaner if you reverted to the static method approach, and replace your parseDocument, findElementsWithPropertyTag etc objects with static methods, e.g.: private static Try&lt;List&lt;Element&gt;&gt; findElementsWithPropertyTag(Document document { return List.ofAll(document.head().getElementsByTag("meta")); } then your Try.of block just becomes: url = Try.of(parseDocument) .mapTry(FacebookImage::findElementsWithPropertyTag) You can also inline these and it then simplifies even further: @Slf4j public abstract class FacebookImage { private final static String FACEBOOK_IMAGE_TAG = "og:image"; private final static int TEN_SECONDS = 10_000; public static String version3BetterJavaslang(String pageUrl) { return Try.of(() -&gt; new URL(pageUrl)) .mapTry(url -&gt; Jsoup.parse(url, TEN_SECONDS)) .map(Document::head) .map(el -&gt; el.getElementsByTag("meta")) .map(List::ofAll) .map(els -&gt; els.filter(el -&gt; FACEBOOK_IMAGE_TAG.equals(el.attr("property")))) .mapTry(els -&gt; els.get(0)) .map(el -&gt; el.attr("content")) .onFailure(ex -&gt; log.warning("No " + FACEBOOK_IMAGE_TAG + " found for blog post " + pageUrl, ex)) .getOrElse(DEFAULT_IMAGE); } } (disclaimer: haven't actually compiled or tested it) Note, your final version has a typo - the class name and constructor don't match.
Cool tutorials. I'm just in a process of writing spring boot guides on my own blog, but I somehow felt that I should start with web services and then move to database. Good job.
Ant, baby. 
That is cool. I've used Natty a lot but am always disappointed development basically stopped on it (although it works very well for what it does and is stable so not complaining). This looks like the next evolution of something in the same vein and with far more functionality.
I hate Maven. Absolutely fucking despise it. But I still end up using it for every Java project I create. Why? Because it works. Because a lot of thought, effort, and development time went into it, and because if I need to do something as part of my build process, Maven almost certainly allows me to do so. Yeah, I'm going to have to write a hundred lines of programming-via-xml, but at the end of the day it'll work. I can't' say that about any of the other Java build tools.
....the nastyness of maven builds is directly proportional to how unstandard your project is. Why are you writing 100 lines of nastyness? - 
can Doug Lea learn a bit about CSS ? or is he exempted because of his threading knowledge ? 
[sbt](http://www.scala-sbt.org/)
It's always scary how smart dl is. This is outside of java a great resource on concurrency.
Spark, the web framework, as opposed to Apache Shark...
thank you
yep good point! http://sparkjava.com/ micro web framework, not http://spark.apache.org/ for stream processing
If you do not like maven, gradle or sbt, write yourself one. It will be the Nth build sytem, the best build system ever. I hope the sarcasm is obvious. I sometimes miss makefiles and ant....
Oh that is what "issues" are for. You can add problem or to-dos.
Finally! /sorry, couldn't resist 
Maven. Even though Gradle is hip (mostly because of Android where it's default build tool), for non-Android development most people use Maven. See last chart: https://javalibs.com/charts/github
If the most complicated thing you're doing is making a war file I think Maven is fine. Any more and i will get a headache. We wanted to make an RPM but have the version be the Jenkins build number. That was a pain.
oh sorry forgot to press "save". there is another cool tutorial just for shaders in lwjgl -&gt; https://github.com/mattdesl/lwjgl-basics/wiki/Shaders hope it helps
while looking on your pipline at https://github.com/6thsolution/ApexNLP/wiki/Multiple-Languages-Support - what about markov chains with your tokenizer and entity detection? could be useful for generting good answers or am i wrong?
Thank you, I'll take a look at it :)
Share your thoughts! I went with libgdx ~2-3months ago, away from lwjgl. 
In this video I am showing how to get command line argument to your java program(get varies datatypes) and how to do manipulation with those datatypes.
Wellllll yes and also no, Actually it's a little bit different from traditional nlp approaches. In NER we use a rule-based approach using [dfalex](https://github.com/6thsolution/ApexNLP/tree/master/dfalex) to find our entities. In future we will use Hidden Markov Model **just** for some other languages that have more challenging problems like Indian, but currently we don't use 
I wonder if that's just for repositories that GitHub considers are Java (which is my guess based on the build tool numbers compared to the specifically Java numbers) or all repositories using one of those build tools. I was surprised to see one of the repos I contribute to is considered a Groovy repo because there are more lines of code in Groovy than Java (because of the tests). Also, this is the second thread that makes me think I've been living in a Gradle bubble. My last three jobs have been all about how Gradle is the better tool. I didn't know that opinion was far from common consensus.
Absolutely. 
http://motherfuckingwebsite.com/
What don't you like about Gradle? Maybe we can help with those issues.
Very cool!
I'm relatively experienced, use concurrency in Java all the time, but, uhm... ELI5?
Bazel and Pants have been around for a few years (Bazel had existed in the depths of Google for a while before that too)
Gradle Script Kotlin is very new and doesn't yet have all of the features from Gradle proper. It doesn't yet have documentation. I use it and love it but I wouldn't *recommend* it yet.
I've used it for years. It's by far my favorite web framework. 
For reference: [Game.java, line 148, from tag 1.2.4](https://github.com/Vrekt/Lunar/blob/1.2.4/src/me/vrekt/lunar/Game.java#L148) [java.awt.Window#getBufferStrategy javadoc][1]: &gt; ... This method will return null if a BufferStrategy has not yet been created or has been disposed. Looking at Game.java's source, bufferStrategy is created here: public synchronized void start() { // snip frame.createBufferStrategy(3); // snip } You sure you're starting the game? game.start(); Disclaimer: Haven't yet used Lunar, I might be completely offtrack :) [1]: https://docs.oracle.com/javase/7/docs/api/java/awt/Window.html#getBufferStrategy()
I've found the issue and it is now fixed.
easier done with 6? (off the top of my head) lines of code... at this rate you'd have to watch 1,000 hrs of video just to execute an sql query via jdbc
https://github.com/takari/polyglot-maven
Profiles are the most underrated, underexplained and underdeveloped feature of Maven. I use them all the time for multi-modules build, and try to put as much Maven config as I can into specific profiles which get enabled or not depending on each submodule's purpose. Like facets.
Maybe it could be like assertions? Instead of `finalise` we could have `assertFinalised`, which is only run if you have `-ea` for that class, and in which you just check that the resources are already cleaned up and raise an error if they haven't.
[removed]
I've heard of swagger. We put example requests for our api in Postman(a chrome rest app) and have used it for live api documentation/testing. It's certainly not the best documentation solution, but it works for our small team. 
Thanks for the details! I am an experienced user of Thread, Callable, Executors, Atomic*, Managed stuff in EE, volatile etc. I just hadn't heard of the new Java 9 stuff. 
How do you stop the threads? Thread.stop is deprecated https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Thread.html
I hate maven. My previous company forced me to work on maven and I hated every moment of my life and every line of that damned XML code. Even today I have nightmares of working with infinite line long XMLs with no end in sight. I wake up sweating and realize that I have changed jobs and now I work on Scala + SBT and I don't need to be afraid anymore.
Currently I'm using thread.interrupt
Never mind, I got it
One vote for [Make](https://www.gnu.org/software/make/)!
This. IntelliJ makes maven usage a lot less painful.
You can still have desired behavior with Cleaner. 
&gt; Scala + SBT and I don't need to be afraid anymore. lol
This sub can use all the help it can get. And twilio is a great service. People who don't know about it will be pleasantly surprised to see how powerful it is. 
Sure, but it seems disingenuous to title something "... Dial and Answer phone calls with Spark and Java 8" when it reality it's not "... Dial and Answer phone calls with Spark and Java 8 using Twilio". I have no quips with twilio, but the fact of the matter is that this post does not describe a vendor agnostic API for services like twilio, or something to that effect - it literally describes twilio integration with your application.
Good to hear. I wonder how much of it is personal preference and how much of it is bad experience. I've seen good and bad Gradle builds, and I've seen bad Maven POMs. Maybe seeing a good Maven POM would change my tune. Bad Gradle practices can be handled (for the rare times they come up) during a code review. I don't know about Maven, though. The verbosity just kills me. I converted one of my old projects from Maven to Gradle almost concept-for-concept last week. The pom was 125 lines, whereas the build.gradle was 44 lines and much easier and understand. It would have been 35 lines if I used Groovy instead of Kotlin in the build.gradle. Also, since I'm already not in the right part of town... vim &gt; emacs 
Glad Java 9 has support for containers with respect to sizing the heap. For Java 8 explicitly setting the heap size is perfectly reasonable. It would also be nice if Java gave us the ability to specify heap as % of memory, although I'm fairly proud of my bash scripting to accomplish this, but it's still useless in Docker because as the article points out, the reported system memory is not the container's memory.
The format in which the keys are stored has a header in the beginning that is the same for all keys in that same format. Same with public certificates. If you search for those base64-encoded starting bytes, you'll find thousands of matches. So everything is fine, except that it's probably the wrong subreddit for this question.
It is good it is here because of how he created the keys, but his question would probably be useful information in more pertinent subreddits as well.
It's repositories which use appropriate build tool.
that's kind of what I'm thinking. I don't remember having ever written a finalize() method outside of an odd code interview question or when playing with a debugger/profiler. 
&gt;Yes there is no way to convey the pressure of the remote connections to the garbage collector so it knows to collect. That's really the core problem, and has me wondering: could an API be introduced to do just that? So that you can programmatically taech the GC to handle other limited resources in just the same way as memory?
IntelliJ's Maven support unfortunatelly sucks :-( Many times I'm forced to call mvn clean package in command line and restart Idea because it's unable to download artifacts correctly and/or discover them in my local repository. Maybe it's because of company's Nexus and/or proxy server, but with Eclipse everything works just fine. Also POM files which have parent which references BOM files are walk-in-a-park with Eclipse. Idea's tooling is for this use-case useless (btw. for example Spring Boot uses this setup).
Yeah, I can understand than. I'll create this game with libGDX, but in the long term I'm going to learn lwjgl. Sounds like the best solution to me. But if I use cubemaps, I can't reflect things in a dynamic way; if ther ist an enemy in the water he won't get reflected. Or did I understand something wrong?
I'd assume the reason is that it seems quite unnecessary for the users here. Most people in /r/java are Java developers, so the following seems a poor reason: &gt; Rather than convincing people to properly set up Java and the enviornment vairables for maven If you're installing Maven, then it's quite likely that you already have Java installed. Setting up the environment variables is simply adding Maven to your Path. If you want to use this image, you need to install Docker and add that to your Path - so the workload to that point is the same. For the docker image, however, you also need to set up an additional alias so that you can remember the command. It just seems like an awful lot of work to avoid adding a directory to your path.
Damn, with GL in the name I first thought this was a 3d engine... Nice project though.
&gt; Please seek help with Java programming in /r/Javahelp! Anyway, a hint: LinkedHashMap&lt;String, ArrayList&lt;String&gt;&gt; courseToStudents = new LinkedHashMap&lt;&gt;(); // add data for(String course : courseToStudents.keySet()) { for(String student : courseToStudents.get(course)) { String out = course + "&lt;&gt;" + student; // append to FileOutputStream } }
Better ask in /r/learnjava . But this question doesn't belong even there.
Since your post is about *programming help*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Before posting there, be sure to **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there. As it stands, the post would violate the *"no effort - no help"* rule because you don't demonstrate even the slightest effort to solve the problem on your own. **Post removed:** programming help
By making use of try-with-resources, higher order functions or the new Cleaner infrastructure introduced in Java 9.
In base32, each character represents 5 bits, so 15-20 characters is 75 - 100 bits, which leaves 924 - 949 bits of entropy, which should be enough. Still, if it's easy enough to switch to 2048 bits, you might want to use that instead.
Overload and override! I hate these questions, they are not similar they just sound similar. They should just ask what is final, what is finally, what is finalize?
&gt; Is my code generating insecure keys As far as I know 1024 bits isn't considered safe for RSA these days. As for the similarity between the strings, as /u/503AccessDenied suggested some of it is the header. There is also the public exponent which can be one of a few commonly reused values. See [Thomas Pornin's answer about why that's still secure](https://security.stackexchange.com/questions/2335/should-rsa-public-exponent-be-only-in-3-5-17-257-or-65537-due-to-security-c/2339#2339).
This is essentially what some of the new generation of CI tools are doing, with all tools invoked on the build pipeline. [Concourse CI](http://concourse.ci/), in particular, uses containers to great effect. This way the pipelines defines the exact tool version and environment to use for each step and is guaranteed to always work in the future because the images for the tool containers will remain the same as opposed to mutable CI tool config (fuck you, Jenkins). I assume doing the same thing at the CLI will provide you the same benefits.
Small update: we can not use original terraria resources, so we use a texture pack.
Oh, yeah, sorry, I had no idea where to post, I was thinking about /r/encryption but its kinda inactive so I just came here
Just a little piece of advice: having a popup on a webpage that covers the article one wants to read is extremely annoying. A programming blog owner should know better. On the other hand, the article could use some a bit of checking: * Is setting the hibernate.jdbc.time_zone property enough? * &gt; allows you to pass the Timezone in the SQL descriptors of TimestampType and TimeType * That is not reflected in the posted code. It is in the pull request though * This seems to be an unreleased feature (git pull accepted 8 days ago), but i didn't see a mention of that in the article. Really, I expected better from Vlad.
I haven't had that much trouble with it. Occasionally I have to do a full project rebuild when IntelliJ has an aneurysm (and then discover my colleagues' code isn't as squeaky clean as I hoped it was), but I just haven't really run into this issue. I too use a spring BOM in my parent, and this gets handled pretty ok about...80% of the time.
JFXGL is very alpha though https://bitbucket.org/cuchaz/jfxgl 
I think the feature (try-with-resources) was introduced to specifically address the issue people were using finalize for. Finalize is pretty unreliable (there is no guarantee it will even be called when you expect) and can have deviously tricky side effects (hard to trace). http://howtodoinjava.com/core-java/related-concepts/why-not-to-use-finalize-method-in-java/
Could you explain why Gradle sucks?
Yes. It'd be quite nice to see some *GLNode* or mobile support out of the box by JavaFX. It will take some major changes to move to 3D / mobile, but I'm still keeping an open mind about it. At the moment [JavaFXPorts](http://gluonhq.com/products/mobile/javafxports/) looks promising.
&gt; I'd assume the reason is that it seems quite unnecessary for the users here. Most people in /r/java are Java developers, so the following seems a poor reason: &gt; Rather than convincing people to properly set up Java and the enviornment vairables for maven &gt; If you're installing Maven, then it's quite likely that you already have Java installed. Setting up the environment variables is simply adding Maven to your Path. If you want to use this image, you need to install Docker and add that to your Path - so the workload to that point is the same. For the docker image, however, you also need to set up an additional alias so that you can remember the command. &gt; It just seems like an awful lot of work to avoid adding a directory to your path. Thanks for that background, I really appreciate it. I'm planning on adding the following to the readme. As a Java engineer, I see several advantages to this strategy: * I can have multiple versions of maven all driven off of one command line. 3.3.9, higher, lower. I tagged two versions to that repo that you could access with a tag * I wanted to try to mess with Maven 3.5.0-alpha-1 but there are no packages in any of the major linux distributions and dockerhub solves that nicely * as /u/deep_fried_eyeballs eloquently points out in another thread in this post, our CI system can use exactly the same version that the developers use without confusion * If you're on a large team, and they are using this strategy, then you could update the version of the tool without having to have everybody install it, just by loading a different version in dockerhub * if you want to add some logic before calling maven or after calling maven, the docker container is a nice medium to abstract that away * You don't need to have different installation/onboarding instructions per platform, it's the same on Windows, *nix, Mac * the docker image could be a git submodule to our project so we know exactly the tooling that was used to build and deploy the package.
* The [stacktrace says](https://github.com/vmlens/stress-test/blob/master/src/main/java/com/vmlens/stressTest/examples/dataRace/DataRaceTest.java#L78) the first NPE happens at `instance[0].getTypeName()`. Does this happen because `ts[0]` hasn't been filled in yet, the reference hasn't been copied to `instance`, or both? Why would the JVM ever optimize the if clause out if `instance` should be always be null in a newly created DataRaceTest object? Does the Thread implementation "recycle" Runnables? * Why does the JVM or the native code behind Array.clone() not check for a null pointer first? Why doesn't the JVM catch the segmentation fault signal and pass that to Java as a NPE?
Unfortunately, the scripting language is not Java, nor can I control whether the users in question will actually *use* use try-with-resources.
Yep, I can understand that there are some advantages, but they seem to be solutions to issues that I (personally) have never encountered. That's not to say that some people won't find it useful, but it may be a reason that it didn't become popular when posted. &gt; I can have multiple versions of maven all driven off of one command line. 3.3.9, higher, lower. I tagged two versions to that repo that you could access with a tag I've never needed multiple versions of maven, and if I did, IntelliJ lets me switch between versions easily. It's possible that I'll need to switch to investigate a bug - but so far that has never happened, and the tooling I have covers the rare case. &gt; if you want to add some logic before calling maven or after calling maven, the docker container is a nice medium to abstract that away To me, that'd seem like there's an issue in my build process. I like to avoid extra, unknown steps. If my project can't be checked out and built simply, then something is wrong. &gt; You don't need to have different installation/onboarding instructions per platform, it's the same on Windows, *nix, Mac Installing maven is the exact same on these platforms already. Grab the correct binary, set your path, and you're done. Again - I'd like to stress that this is probably because I'm a Java developer already. I have maven set up, and my environment configured. This use case probably just wasn't for me.
Ahh right. Sounds like you're processing this scripting language with Java. If this is the case then surely you control the point that the objects go out of scope and can handle the de-allocation then? 
Thanks for the reply, that does clear things up! Some follow up questions, if you have the time: &gt;This is fairly common to this kind of parallel runtime system. It leaves the GC and kernel space to run on the final core. If you tried to use all cores you would likely end up with context thrashing as the (kernel) scheduler tried to fairly balance the impact of the GC thread and its own work across the other cores. * If the ideal number of threads is NUM_CORES - 1, then why do so many people seem to recommend NUM_CORES instead? This includes JCP, IIRC, though I don't have the exact quote at hand. * Can't you still get thrashing with NUM_CORES - 1, since you're not guaranteed on which CPU the GC thread is going to run? It could still mess with your cache if the scheduler decides to run it on a core that one of the ForkJoin threads was just running on, right? * Wouldn't a parallel garbage collector have this problem no matter what, since it uses NUM_CORE threads (IIRC)? &gt;I'm not as sure about this one, but LIFO means tasks that the task you just created will be the first one run, which makes sense as that is the one with its data in the cache. This is how I think most other fork-join systems I've seen (such as Cilk) are configured. If the ForkJoinPool.commonPool() was meant for ForkJoinTasks (which create other subtasks and stick them on the queue) then LIFO would make sense, but AFAICT it's by default used by parallel streams and CompletableFutures. Those use a more traditional method of scheduling the execution of each new operation as a new task submitted externally to the thread pool - in fact, that kind of externally submitted, never blocking task is called out as something asyncMode is specifically designed for! So it's confusing that it's not being used.
Nice one! This is exactly the sort of info I was after. All I'm looking for now is some sort of starting point. Many thanks. 
What you are looking for is a log management tool like Splunk.
Back from (near death) - we recorded our first podcast of 2017 last week. Hopefully we can get back into some more regular recording/publishing cycles.
Postgresql driver uses it to make sure, the database connection was closed.
Not that I am defending the author, but &gt; Java depending on Intel's memory guarantees wrt caching as opposed to ARM and RPi processors That's very likely an actual problem. The architectures have very different cache coherence models. The VM was originally developed for x86 and amd64 architectures. There are very likely to be issues that only crop up on architectures with a weaker/different cache coherence model, such as ARM.
Yes, it's a standard race on mutable shared state. 
?
How about not catching exception (unless rethrowing as RuntimeException) and using [Thread.UncaughtExceptionHandler](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html)?
?
Might be guesses, but they make sense to me. Thanks.
What about: graylog, GELF, biz.paluch.logging:logstash-gelf
Using the debugger mechanism (agent) is the only way I can think of to capture all caught exceptions.
&gt;The starting point for IncreMaven is your uncommitted changes in SVN:
there's also http://rollbar.com
Try to ask a specific question and possibly provide some code.
Ths original JVM didn't just target Intel. It was on SPARC, as well. 
Wow this site is terrible. That's not even a completely functioning program in Python. 
Several reasons: 1. (why not pom plugin) I wanted tool to be external, because in my case I cannot modify pom. 2. (why not pom plugin) In the external tool, I have better control over maven (cycle, parameters, logging) 3. (why a script) I wanted the tool to be changeable easily 4. (why python) Python is one of tbe most popular scripting languages. Also most linux developers have it installed by default 
Since this is a *programming related* question it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Be sure to read the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed:** programming help
I shared the original post from the programcreek.com. Isn't it? 
I like to use Sentry for stuff like this: https://docs.sentry.io/server/installation/ And then your Java app logs to it using log4j (or log4j2) or logback or whatever your logging framework is. https://docs.sentry.io/clients/java/modules/logback/ You can pay for hosted sentry, or you can run it yourself for free.
This script isn't at all useful to me since it uses SVN. If it used git, it could be helpful. 
Code complete has very little to do with MS languages. But it's probably one of the most solid books on software development in general that there is. Very very highly recommended for every developer working on anything bigger than a hobby project.
Java programming language skills decode so well into skills for other languages. Here are some supplementary languages, &amp; a concise look at what your Java programming skills will give you in the way of a head start, &amp; what differences to look out for.
I'll adopt it for git over weekends then :)
Having java as my first language really worked well with my computer science degree since both the basic concepts and implementation carried over to other languages in an understandable format
This series is gold.
It's not a new problem no, but it suggests the JVM team are giving up on solving the issues rather than doubling down and improving them. I'm facing an issue in my current project where we have a resource that needs to be closed, and it'd be nice if we could rely on the GC to do that because it'd be a much more natural programming model (the resources in question have to be allocated up front without knowing if the caller will really need them or not, and it's easy for callers to forget to close the resources). But there doesn't seem to be much interest in doing anything beyond scaling to ever larger heaps. I guess that's where the commercial support is driving the team right now but it'd be nice if they could find a way to upgrade G1 so that some allocations are aggressively collected ASAP, or could be weighted somehow.
Please, 5k lines in single class is nothing, also, depending on coding style, the actual amount of code might be a few times lower, so. Not everyone writes "library.DoEverythingForMe();" type of code, sometimes you just have to implement everything yourself, and not everyone wants to have thousands of one-line classes and useless abstractions...
In my experience, any employer (who knows what they are doing) should understand that Java and C# are about as close as any two languages commonly used today. I've done interviews with whiteboard coding for C# jobs where I responded in Java, with the understanding that the minor syntactic differences can be learned on the job, particularly with the aid of a modern IDE. The reverse should be equally true. The differences between the two languages are quite small. Java separates the declaration for class inheritance and interface implementation. Java doesn't have var or dynamic declarations. Java doesn't have out parameters. Those are the first things that come to mind. 
1337 number of posts :)
Hi Nikosssgr. Although a bit of topic, I really like the library. Thanks for introducing it to me. Maybe I will right something about it in the future. So stay tuned. :)
And IBM had Java 1.0.x on PowerPC RS/6000 systems.
Ah well that makes sense (even though my opinion still stands haha). You should be fine, the two languages are pretty similar syntactically. I would advise you to learn how to use the hash map and make sure you know why it's useful (it has O(1) lookup), how and why you want to use a string builder rather than using + to concatenate a string, how and why to use interfaces. Questions I see reoccur are the simple monopoly game question (to test your OO design abilities and test if you know when to use an interface), some form of string reversal or string parsing (to show you know how to use a hash map and/or the string builder and can analyze run time), and fizzbuzz (if you're really unlucky). If you or anyone that reads this wants more interview/salary negotiation help shoot me a message I would love to help
Sorry to shit on your parade but Collectors.partitionBy exists.
C# converts switch statements that are really long into a different type of call instead of falling back to ifs that's actually faster.
Oh yeah ... forgot about Big Blue! They had JVMs on a variety of their systems from early on.
TL;DR: [Koboloke](https://github.com/leventov/Koloboke) is nice.
But `Collectors.partitioningBy(...)` only gives you a `Map&lt;Boolean, List&lt;T&gt;&gt;` meaning it would be more code to do further actions on the results.
Yep. Writing specific classes for a fringe case of a general functionality that is already implemented makes zero sense. Now someone who read that code also needs to dig qhat that splitter is, how to use it for 3 cases (they can't) and what was the reason for not just using a map. 
In multiple cases you use Collectors.groupingBy. They thought of everything, this guy just doesn't know about it yet.
I would like it too. Currently trying to figure out how to use Javaslang in my project. 
Not sure I understand. Even if the state is shared, in any given thread, by the time it reaches the last line, wouldn't it have already executed the if block? the if block looks like it would always set the instance. Is the problem here that some processors execute instructions in a completely different order than what was written in the program? 
Why not take advantage of Polyglot Maven and use a pom.yml? [Example](https://github.com/takari/polyglot-maven-examples/tree/master/yaml)
Neat. Thanks!
Exactly.
I still wonder why people use JPA. They end writing lots of more lines of code. 
This brings me back memories of JSF days conference in Austria back in the day, when Groovy was being discussed to be also part of the official standard.... We even had some sessions demoing how cool it was to write JEE beans in Groovy.
And they end up writing lots and lots of blog posts about features and gotchas in JPA and Hibernate. Maybe that is Hibernate's secret: it's co-dependent with the blog industry. 
Try implementing this [Phantom Read optimistic locking mechanisms that works even on Read Committed isolation levels](https://vladmihalcea.com/2016/08/30/how-to-increment-the-parent-entity-version-whenever-a-child-entity-gets-modified-with-jpa-and-hibernate/) without JDBC. I bet it's not going to be a lot of fun, right? Now, there are tons of reasons to use JPA, like: * transparent prepared statement batching * second-level cache to offload Master nodes while maintaining strong consistency * versionless optimistic locking (e.g. OptimisticLockType.ALL, OptimisticLockType.DIRTY) * support for multitenancy * Full-text search integration and [even more](https://leanpub.com/high-performance-java-persistence/read_sample).
When this inevitably starts alerting, the maintainers will realize the problem with the name.
Thanks for telling me, but please read the updated blog post again.
&gt; I'm not sure what you're talking about. Hibernate 5.x User Guide is state-of-the art. Let's take one of the features you're bragging about above, repeatable read emulation. Here's the comprehensive algorithm description of this feature in the "state-of-the-art" manual: &gt; It maintains a generally "repeatable read" persistence context (first level cache) of the application domain model. I see. A "generally repeatable read". Generally. Whatever that means. That makes everything clear, not. &gt; that's the only type of multi-tenancy (discriminator based) that Hibernate does not support. So... that feature is even more humble, huh. If the "multi-tenancy" support requires distinct tables or databases for every tenant... that makes the feature even less something to brag about, because it represents the kind of "feature" which Hibernate implements to go around limitations in its own abstractions. Say if I'm accessing such a "separate DB multi-tenant structure" in any other layer, would I need dedicated support for multi-tenancy? No, I just open the relevant database and I use it... it just works. &gt; But from a DB performance perspective, it's not like the discriminator-based approach would yield the best performance, right? From a DB performance perspective, it depends on your schema and indexes. One of the core reasons to go "multi-tenant" is so you can do efficient aggregate queries over all tenants, and ease maintenance (one schema to update atomically etc.). If you have to keep separate tables or DBs, that's multi-tenant only in Hibernate-speak. Otherwise it's basically separate single-tenant schemas/dbs.
Whats so bad language class ? Its plain simple, fool proof, fast. It doesnt use any hipster libraries or quadratic lambdas inside templates, but it doesnt mean its anything wrong. Its not like straight bull**** in nvidia physx source - uses "if" and "for" without block {}, so one naturally would think that only one line should be executed/looped then, but no, it has some bull**** compile flags like "--use-alignment-as-block"... And grats on porting from one **** language to another **** language :) Its always nice to see something fun.
And, can you point me to a different data access framework whose documentation passes your exigencies? Related to multitenancy, a discriminator approach is not very useful. If you need something like that, you need native support for multitenancy to provide better performance than using a one billion rows table that covers 10 tenants.
&gt; And, can you point me to a different data access framework whose documentation passes your exigencies? https://www.postgresql.org/docs/9.1/static/transaction-iso.html &gt; Related to multitenancy, a discriminator approach is not very useful. If you need something like that, you need native support for multitenancy to provide better performance than using a one billion rows table that covers 10 tenants. Some databases have no problem having 10 billion rows. I wouldn't go multi-tenant on SQLite, after all.
You're still assuming that the code that is being decompiled is the result of compiling what the developers wrote. And I am 99% certain that is not the case. The code as shown is not just unmaintainable, it is not even realistically the result of a deteriorating code base. If it's not the decompiler failing to reproduce the code that was originally compiled, then there's either a code obfuscator involved, or the code was generated.
Spoken like a true millenial!
Agreed, I've seen production incidents on a few occasions because of infinite timeouts. It's almost never the right answer.
I'm not saying that you just cant do stuff in java, i'm saying that its the wrong tool and you proved nothing. Yes, for very simple games its ok, but if you want to go big, you gonna have to do everything c/c++ way, and then there is no point in using java at all. Game development is not an easy task, and its more off a premium market - so you better go with c++ from the start if you want to achieve something, because it will not get any easier. Just look at minecraft - you need top end pc for something that must run great even on mobile phone, and even then the whole user experience is basically trash.
&gt; But from a DB performance perspective, it's not like the discriminator-based approach would yield the best performance, right? What would you prefer? Schema-based? Task: Add 100 tenants and watch your cursor cache (Oracle speak. Plan cache in other DBs) explode ;)
&gt; It means that Hibernate is the best documented data access framework, since I asked you to provide a data-access framework that's better documented, and you mentioned a RDBMS. If that's the consolation price you want, you can take it. Reminds me of the joke that Zune was the "best sold brown MP3 player". The distinction is arbitrary. SQL is a data access interface with specific semantics, and those are covered in excruciating detail for every database (there are papers which go in greater detail). Hibernate also provides a data access interface, on top of SQL, but by comparison it's like throwing shit on a wall and seeing what sticks: millions of under-documented options, whose semantics often hide surprises that can lead to performance issues and data loss in the right circumstances. &gt; That's exactly why Hibernate does not support discriminator-based approach. If it offers a solution, it must work properly on all supported databases. I'm not sure why you're trying so hard to be Hibernate's apologist. They don't support options which people use every day on Oracle, SQL Server and Postgres, because it might underperform with a very large dataset on SQLite? **Really?** No, actually they've been planning the discriminator support since version 4.x, and the plan was to add it in 5.x, but they still haven't, apparently. I thought it's in by now. The prosaic reason is probably more like... they still can't find a way to reliably patch it into the spaghetti they have. &gt; If you like JDBC better, then check out this Twitter conversation. It summarizes the joy of working with plain-old JDBC. Hibernate uses JDBC, and not using Hibernate doesn't imply you have to drop down to naked JDBC, so I don't understand your point. Hibernate could've been a much simpler system, but it isn't entirely by the choice of its authors, who can't stop adding poorly conceived features to it. This is not because of JDBC or Java.
That's a different kind of multitenancy, than what we're (probably?) discussing here. The Oracle feature you're looking for is called [Virtual Private Database](https://docs.oracle.com/database/121/DBSEG/vpd.htm)
Yeah, the bad old days before people figured out the deal with the emperor's clothes. 
Man, I'm starting to realize, for all the people that say C# ripped off Java, it has way more features. 
How about a builder pattern for better readability: MyInterface.of( () -&gt; { ... }, () -&gt; "hello", v -&gt; { ... }, v -&gt; "world" ); vs MyInterface.builder() .myMethod1(() -&gt; { ... }) .myMethod2(() -&gt; "hello") .myMethod3(v -&gt; { ... }) .myMethod4(v -&gt; "world") .build();
I've already solved this problem for myself. The absolute certainty with which you're talking about Hibernate's inevitability is part of the reason why so many people take it for a given. It's a political victory, not technical. And in political fights, the best option rarely wins. It's more a game of smoke and mirrors. 
I'm sorry, but AAA game has a name - does that considered a super duper hard functionality to implement ? If AAA has something, it doesnt mean its hard to do that, and if your game has the same, it doesnt mean that your game is any good. By going big i meant going big and start making good games for money - good graphics, good physics, good everything. This java slideshow with 70's graphics is in no way big. By doing what you do, you are not only not learning anything, you are also wasting time on doing useless things with wrong tool. At this point you would be much better off with a text based game.
Thank you
&gt; But you can find an even larger number of articles online of people cursing Hibernate and removing it from their systems, so again, not sure that's meaningful. In the [Hibernate newsletter](http://in.relation.to/2017/03/06/hibernate-community-newsletter-2017-5/) which is issued every two weeks, you can find at least 4-5 articles that are pro-Hibernate. There might be rants from time to time, but way lower, and it's worth checking the rant author credibility as well.
Tesseract can usually get decent results but you have to tune it like a mother. Try detecting text and cutting out regions to send along beyond just sending entire images.
Wow, stop right there, doing business and making good games doesnt have anything in common, you could put shit in a bag, put ea logo on it, and people still would buy it. I was talking about making good games from the professional side. Try to think for once.
You can query ORM without JPQL. Have you ever used a criteriaquery? It sounds like ORM is not the issue here
"fast" in "fastutil" doesn't do what you think it does. Like the worst of all.
At first, circuit breakers are confusing, because "open" means that there is no connection and "closed" means everything is working fine.
Check out [this tweet](https://twitter.com/Coffee402/status/842723375042633728). Lots of people love Hibernate. I see tweets like these every week.
ORMs are trash and you're much better off defining an API infront of your data backend and only calling through that. If you ever need to migrate, updating the API isn't that bad. ORMs give you constant overhead in performance and maintenance while only guarding against a small risk of having to migrate backends which a concise API mitigates anyway.
Say what you want, but people love it. Here's [a new one](https://twitter.com/fnharms/status/842799828983840769).
Sure, but it's a visible limit. I'm saying a hidden default of 5 seconds is just as bad as a hidden default of infinite. That's very different to a very visible finite limit.
If you need a crash-course in echo chambers, [please visit this subreddit](https://www.reddit.com/r/The_Donald/).
Interesting.
BTW, lookie, we have a new thread :-) https://www.reddit.com/r/java/comments/5zyf5n/orm_have_there_placebut_its_not_a_silver_bullet/
Entity queries (JPQL or Criteria API) are only useful when you need to modify the entities being fetched. Otherwise, just use DTOs for projections. And you should not restrict yourself to JPQL queries only. Why do you think JPA and Hibernate allow you to create native SQL queries? Native queries are a [Magic Wand](https://vladmihalcea.com/2017/01/18/the-jpa-entitymanager-createnativequery-is-a-magic-wand/). You can run Recursive CTE, Window Functions, PIVOT, Derived Tables, LATERAL joins, JSON queries and more.
This is what Gaving King, creator of Hibernate, has to say: &gt; Just because you're using Hibernate, doesn't mean you have to use it for everything. Point your colleague [here](https://plus.google.com/+GavinKing/posts/LGJU1NorAvY) Now, while this is an argument from authority, but if the man himself says don't over use it, just don't. Between &gt; everything should be consistent and the same and &gt; choosing the right tool for the job it is clear you are right. That said, I had a phase when I tried to do everything via hibernate... it is possible, but painful.
The consistency should come at the interfaces between your components: interfaces should be simple and consistent. Implementations should be allowed to vary, and be refactored, even piece by piece. This is why if you avoid implementation-specific interfaces, you're golden. Because as you say, there are no silver bullets, and "consistency" in implementation has another name: monolithic code. Monolithic code never survives in the long term, when flexibility and change become more important than how pretty v.1.0 looks in the repository. That's what I'd tell your colleague. ---- Now there may be another thing he means by consistency and that is state consistency. Because if Hibernate serves from cache, and another library serves from the DB, the data incoming may be inconsistent. The same can however happen also with Hibernate alone if you run your server backend in more than one process. This type of consistency is necessary (unless you specifically know you don't need it and can therefore relax it), but that's a different, and very long topic, and as I'm hinting, just using Hibernate is not necessarily a guarantee for data consistency. 
Very interesting surveys! Well, I don't see any problem with adding the TRIGGER to a grand children table. Of course, if a database had many tables, it will be a lot of work. 
And zero is a terrible synonym for infinity. It is not infrequent that I see failed arithmetic which accidentally results in a zero value that causes an infinite timeout. I refer to it as a "Maxwell Smart Error", ie. "Missed it by that much" Use Long.MAX_VALUE or Integer.MAX_VALUE if you mean infinity or provide a method overload which doesn't take a timeout value that uses the default timeout.
The story of the 0 timeout: https://www.ibiblio.org/harris/500milemail.html
Hmm, perhaps it could be a bug in code that's utilizing off-heap memory (such direct byte buffers) or some low-level resource that isn't being cleaned up? Too many things to guess at from your description.
ORMs aren't a silver bullet but they serve a purpose. I usually ignore anyone that is on either extreme. I often find that developers are generally terrible at writing queries and ORMs often do a better job.
&gt; I'm forced to call mvn clean package in command line and restart Idea because it's unable to download artifacts correctly and/or discover them in my local repository This is one of my biggest annoyances with IntelliJ
Unsurprisingly, I really love this. Nice way to share snippets, too.
If you want to use cloud service, I recommend Azure : https://azure.microsoft.com/en-us/services/cognitive-services/computer-vision/ Google: https://cloud.google.com/vision/ Watson: https://www.ibm.com/watson/developercloud/visual-recognition.html They are similar, but have different options. If yo want to roll your own, use tesseract (real ocr), or opencv (more computer vision style).
My team uses HQL, criteria queries, and native queries depending on what works best for the particular use case. We try to implement in that order generally. The problem I'm sure he is trying to avoid is having a new developer come in and just go right to native queries because he is more comfortable.
To criticize a little bit, I think you have a broken view of the industry and how our skill set is utilized. "What will be left to code?" Everything. That will be the answer to that question forever. You don't just stop developing something because it's been written already. That's like asking construction workers what buildings there are left to build. We build, improve, replace. You're right, there are a lot of people going into the field but it's still crazy in-demand and most of them don't last more than a few years. If you're a good engineer you'll go pretty far.
I do see what you mean, and yeah, you're right, those types of things that can be automated WILL be. That's sorta a catch 22, but something I severely am looking forward to. Why? Because once those easy tasks get automated that means the more complex stuff gets put on my plate. I've been professionally writing software for almost 10 years now. I hate doing stuff I've already done. That's not exciting anymore. The repetition sucks. People and businesses will always come up with more complex custom problems for us to tackle. That's what drives innovation and builds progress. I want those assignments. 
Usually people not comfortable enough with SQL use JPA in my experience. 
Are you using JavaFX with web view? That's been known to leak memory outside the heap.
I will join you in the downvotes... I have yet to meet an ORM that makes my life easier, and most of the time they make it harder.
Just like you can have a logical transaction spanning over multiple HTTP requests, which can cause [lost updates](https://vladmihalcea.com/2014/09/22/preventing-lost-updates-in-long-conversations/) on a row level, you can have it on a predicate level as well. So, application-level transactions require application-level concurrency control. Makes sense?
I was a bit skeptic about picking .NET as my first working experience, but, honestly, I didn't miss Java in these years. I would say I would not look into going back to Java, if it wasn't more popular in most of the industries.
their*
[removed]
Thank you so much, I'll try to have all of those fixed soon
Yeah, I was really hoping for a summation of the best (probably highest) level APIs and some quick code samples. I used Shiro recently which forces you to do a bunch of stuff which felt too low level.
I know that I am a picky non-native speaker, but the title sounds a bit odd to me.
What do you think is wrong with it? Maybe hyphenate 'sought-after'?
Maybe. When I look at the title I am wondering what is "after programming".
Been there, done that. At my last company my boss was a big fan of hibernate and we had to do everything with it. Even in simple tools you usually have this one entity to which everything else is related. And which hibernate and its lazy loading is just unable to load efficiently for a simple table view with search results. In my professional career I found that a lot of engineers tend to religious debates with only absolutes. Those people are morons. Good architecture is always balancing multiple factors, like in your scenario consistency, complexity and performance. The best way to deal with them, is to define good non-functional requirements for the software (like response times), and thus enforcing this way to balance out factors. Sadly this can also lead to horrible over-engineering (in hibernate this is usually starting with caching).
Yes, that's a really nice feature
&gt; e.printStackTrace(); 
Thanks for your contribution to the open source ecosystem :) Quick question though: I think I read on your site that there can still be a several-second delay before a file modification is detected. I'm working on a library called [Shoebox](https://github.com/sanity/shoebox), it's actually for [Kotlin](http://kotlinlang.org/) rather than Java, although Kotlin has bi-directional compatibility with Java and a shallow learning curve for Java coders). Shoebox is a simple key-value store, currently backed by the filesystem, using Gson to serialize objects to JSON. It's main benefit is that it has powerful support for the observer pattern, so you can listen for additions, deletions, and modifications in a flexible way. Currently this only works if there is a since Shoebox Store instance listening to a directory, but it would be great if a Shoebox directory could be shared between several Store instances, perhaps running in different VMs or even different servers through a shared filesystem of some kind (see [this issue](https://github.com/sanity/shoebox/issues/2) for more info). Based on your experience with Barbary, do you think this is a viable idea? I'm starting to worry that the various options for listening for filesystem changes may not be reliable enough for this :/
I don't recall much detail about the inner workings I'm afraid. I probably only spent a week or two on BarbaryWatchService a long time ago. Someone took over ownership and maintenance from me some years ago; the GitHub project you linked is his. You could ask him. What I do recall is that attempts to listen to file system changes have unexpected limitations. More than that, I just don't remember. 
Can't see The post right now but when I'm back home, I can help with Brazilian Portuguese if the project is short.
This is spam focused to sell certificate training. 
Powering spacecraft everywhere. 
&gt; Did you try with HIGH modifier, right? While I haven't yet found a reference to confirm it, my suspicion was this was for polling this simply made the polling more frequent - but unfortunately polling is too inefficient for my use-case. &gt; As I see it a prod server won't? ever run in OSX. So probably only OSX developers might be affected (small price to pay?). You're right that most servers won't be running OSX, but the problem is that I'm building a library, and I don't know what OS my library's users might want to use. It would be unfortunate to say that my library won't work for you if you want to use it on a Mac, and it would violate the expectation that people have about Java libraries which is that they're cross-platform.
I would greatly appreciate it. It's not too much text. Probably ~80 lines total.
I appreciate the PR! I'll merge it asap.
unlikely in the short term. Right now Web Assembly does not support garbage collection, so it is not really possible to target it with Java. Once GC support is added, its conceivable that there will be some UI frameworks that could be compiled to work in the browser, but it seems unlikely that JavaFX or Swing would be supported.
Have you considered using memory mapped files instead? Check out Chronicle-Map (https://github.com/OpenHFT/Chronicle-Map) for an example of how you could do this. That library might also cover some of your underlying requirements as well. 
http://open-dolphin.org/dolphin_website/Home.html
I'm sure you'll be able to write Java that targets Web Assembly eventually, but I don't think the JavaFX or Swing will be supported. Browser code generally manipulates the document object model that is made up of tags. I don't think there is likely to be a clear cut way to turn JavaFX or Swing code into DOM components. 
Considering there is a jvm implemented in JavaScript, seems likely http://plasma-umass.github.io/doppio-demo/
What? 
I think block programming is a good tool to use in the early stages of programming education. It allows the student to focus on algorithms and structures rather than syntax, compiling, semicolons, etc. Provided the block program is generic enough, there does not seem to be much that separates typed languages from built languages at the algorithmic level.
Have you had a look at the Apache commons.io FileAlterationMonitor API ? I've used it with great success and is IMO slightly faster. In worse case you could end up using a timer and file API to check for changes. I would imagine that you could get upwards of 15ms response time and pretty low CPU usage
For java application or in general for the jvm application it's extremely hard to determine how much memory will be allocated. Heap is only a part of the total memory. https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html
It kind of works, with less OS integration that what Java actually supports, so I would leave the "extreemly well" out.
I make my living in graphical programming of large scale industrial control systems. Sure, it is a niche, but a very well paying and highly specialized niche. I am not saying that it can ever completely replace traditional programming languages. Graphical programming can't even do that in my line of work. Our internal library is written in *Structured Text*, a textual IEC language, simply because it is way easier and shorter to write library internal, non customer facing code in that way.
I don't think we've seen, yet, the most elegant form of 'block programming' possible yet, because all such languages haven't been built for elegance, they've been built *for kids*, or for very small niches. I wonder what a team of truly great UI / Language designers could come up with together if they really focused on making a visual language.
Still one of my favorite languages. Only wish IDE support for static typing would be better.
Quick example on how to use it: ` var list = new java.util.ArrayList(); list.add("apple"); list.add("pear"); $c(list,'elementData')[0]` will print `apple`
Looking at the current state of web development - especially with JavaScript - everyone in there is a sick perverted bastard, if you ask me.
Yup. I agree. The hipster crowd that thinks that browser is a perfect place to implement and execute multi-modal unconstrained UI's should be sent to burn in sun. Somehow when Microsoft tried to do that with ActiveX 15 years ago it wasn't quite cool. NOTHING HAS CHANGED.
A quick look at the javadocs suggests that FileAlterationMonitor relies on polling - is that not the case?
Ну ок. Вечером гляну :)
You are correct about the database design. On a lot of the projects I have seen the SQL is a mess because the design is also a mess. The developers writing the crappy SQL were the same developers that designed the database. The company either didn't have the budget to hire a DB person or assumed all developers also understand good db design. You are also correct about queries not being that hard which I why I prefer to design the database correctly and let an ORM write the queries instead of me wasting time writing code to do simple queries. That is what ORMs are good at. If I have complicated queries I can always write those instead of the ORM. What ORMs aren't good at is being used with a legacy system that has poor design. 
I get a message saying code is expired 
I'll check it out
I've created a new post with a new invite. Let me know if it works
I'd think it is rather easy in eclipse s it controls the files and the compiler. But without this, you could track the class files or let the filesystem inform you on changes. Not sure what you are trying to accomplish though. 
Yes, there's no reason it's not possible, despite some of the misleading answers here. There are already JVM implementations in JS, and canvas allows a swing renderer to paint to the browser. It is likely to need the newer shared memory array stuff to allow generalised multi threading, which will take a year or two to become ubiquitous.
There is a system that listen for class changes and automatically restart the application. It works OK, but it is ALL or nothing. For example changing a local variable or method body restart the whole application. I would like to make it more efficient and do a restart only when the class file is no longer binary compatible, either bc a method signature changed, add/remove some field.
Behave yourself or there will be consequences.
Interesting. If you don't mind sharing, what are you building?
This can easily be achieved via Java's class loaders. Essentially they take binary blobs (files, input streams) with Bytecode and turn them into classes you can use. Read the Javadocs on class leader, it's very interesting.
Isn't anything new :) it's about to make it more efficient. I built a micro-framework with a command line tool that run/restart the application. The reload/restart uses [JBoss modules](https://github.com/jboss-modules/jboss-modules) to reload the application.
ty, putting it to use as we speak.
It's been a while since I dealt with Java, so my memory is a bit hazy on the details. Your right, you need to unload the class, _if_ you're reusing the class loader. But you can just create a new one. If you have lots of classes that you don't want to reload, load them in the parent class loader. 
My main problem with HTML5 is that every web browser supports a different subset of the features. So we either program to the least common denominator or use a bunch of polyfills to fill in the gaps. Not all of the browsers even support the same features of Javascript so we need to use tools like Babel in order for us to use the latest features of the language. 
https://github.com/JigarJoshi/otr/blob/master/otr-common/src/main/java/com/jigar/otr/crypto/AES.java#L59
Those same problems apply to web assembly at the moment and will apply in the future. Browsers will implement features ahead of standarization. For javascript these are mostly solved problems. For web assembly you'd have to start all over again. Web assembly would make sense for apps that need and use the feature set it offers. But if you target web assembly from javafx you are not doing that. Not to mention that web developers are easier to find then java developers. :)
I like watching videos. Sometimes you pick up things you wouldn't otherwise, like how other devs work, which can make you more efficient or teach you something you didn't know. Josh Long's videos come to mind. I think it's cool to see him work. Or just casually watching the Coding Train to see something cool come to life in a short period of time. Sometimes I see places I could do better, sometimes I learn something. Maybe CS videos don't work for you, but they work for a lot of people. Things like treehouse or Lynda or coursera or the vast number of YouTube channels wouldn't still be going if they didn't work for some people. 
Thank you for the explanation! I'm very new to github and license related things. I might change the license now that I know more but I mainly choose it because I wanted everything free and open to the public. I suppose if some big company wanted to use it and maybe needed a different license then I would. Again thank you!
The big question not in this thread is: are you asking for a way to do it in Production or not? If you want to increase dev speed then it is not too complicated. You control the class loader (and have to break java class loader's contract by not doing parent-first search) and you throw away the old one to reload the code. If you are writing a stateless REST application that'll work just fine. Otherwise you'll need to have a way to shutdown and start the application again while passing the state. Not too complicated as well, just extra boilerplate code. If you want to do the same in production, then none of the other answers apply. Do not do this in prod. You would be opening a door to major bugs, starting from a memory leak (all it takes is one reference in an alive thread's threadlocal to keep the entire class loader in memory with most of its loaded classes) and going all the way to inability to use other advanced java tools. Most of java agents would not like the code hot-swapped on them. To do this in prod you would need to control your execution environment to the last finest detail. It is a lot of work for a small gain.
&gt; I often find that developers are generally terrible at writing queries and ORMs often do a better job. But that would mean the same developer would not be able to check if the ORM you're using is creating efficient SQL queries. Using an ORM removes a lot of the boilerplate of querying and mapping but doesn't remove the need to check the queries and look at what the DB optimiser does with it. 
Could you elaborate why they should not be good for CS teaching?
This: var url = new URL("..."); Makes me sad. Javascript was introduced to the world 21 years ago.... Something that was like java in its syntax, but not like java in that it had this kind of stuff. I really do not want java to turn into javascript. Please, the gun is pointed at your foot. Dont pull the trigger. 
It's nothing like JavaScript except for the letters. Everything is still strongly typed. If you worry about readability (which is a valid concern), I am sure that IDEs will allow to overlay the type.
Why wait for some uncertain future? Start writing in Scala now :)
This subreddit is about Java, the **programming language**, not about the island. Your post is completely off-topic here. **Removed**
What exactly is the second warning for? You rightly pointed out that I'm new to reddit posting and replying, yet you criticise me for not replying inline. It's a simple mistake and not worthy of direct criticism. 
I've now deleted the discord post (i think/ hope). I hope this clears up some disagreement. I'm just here for Java.
Your argument will be shot down and downvoted right away with "Take an IDE and hover with the mouse over the variable" or "Just write the type in the variable name". I've started a similar discussion a while ago: https://www.reddit.com/r/java/comments/5o4cj4/jep_286_local_variable_type_inference_readability/ I'm starting to believe that the only people that want this are those that try to write code like `final Function&lt;Integer, Function&lt;String, Integer&gt;&gt; axs = Functions.axs();`
Well as I said, I am not an expert but I hope just to let you understand that these things are important. It doesn't just matter for big companies, but for everyone including small companies and individual hobbiests as well. Maybe GPL is what you want. To put it succinctly, GPL says you can do anything you want, except deny these same freedoms with anything you create. In other words, you can only use it to create open source software. At any rate, it looks like an interesting project, I will certainly be trying it out. 
I see that! If we do it that way we will have to set the max and Min hp and all that somehow huh. What if we used the prototype design pattern: https://en.m.wikipedia.org/wiki/Prototype_pattern That might help if there's tons of enemy types. We can just clone for an existing one and we get all their base stats. 
Just development and what you commented is already solved (see my previous answers). Today, application restarts in development are ALL or nothing... doesn't matter if you change a local variable or not.. always restarts. Want to make it more efficient. Need a way to check if a class is binary compatible, detects method signature changes, new field, etc...
In practice I almost never need to know the exact type of a variable, and when I do, I can just mouse-over. It's just noise to me, which makes "var" so much easier on the eyes. Just have good variable names and you hardly ever need to mouse-over. It works in C#, it works in Kotlin, it works in Scala.
Other languages use this var style without problem so i don't see either of these being a problem in practise. If we could get rid of the new keyword as well that'd be even better. var URL = URL("xxx")
I wish they would use 'auto' from D instead of 'var'. 'auto' means very clearly "infer the variable type". 'var' has too many overlaps with other languages (Javascript, Pascal, Go, C#). 
I feel like you have a fundamental misunderstanding of what this feature provides. 
I imagine you can refactor at will to go from var to types and vice versa. 
I would argue that other languages do have a problem. In my view they've traded code readability for a very minor increase in developer convenience. Especially considering the strength of IDEs in the Java world, it's basically automatic to get the type filled in for you, but reading the code, diffs, bug reports becomes effortless in the future. 
Operator overloading 🙌🙌
I suppose those who downvote will have to learn for themselves =\ 
Sure, almost any feature can be abused, but that doesn't mean that it shouldn't be available. The "auto" keyword is also similarly abused in C++ by a lot of people, but that doesn't mean that it should be removed from C++. When you are familiar with an API, it's so much easier to just type var complicatedMap = myAPI.getMyMap(); instead of always typing in (sometimes dozens of times) Map&lt;Map&lt;List&lt;String&gt;, List&lt;Integer&gt;&gt;, List&lt;Boolean&gt;&gt; complicatedMap = myAPI.getMyMap(); And forget about hovering over in the IDE to find the type, when you press `.` on the object, you will get the options relevant to that object's type in any case. In other words, the onus is on teams to introduce strict code guidelines that are enforced by the team itself. Type inference is overall a great feature that has been long missing from Java. I do agree that maybe `var` is a bad choice of terms (emulating the C# world, perhaps?). I second the other guy's suggestion to use `auto` instead. Overall, I would argue that judicious use of `var` would increase readability and remove unnecessary verbosity.
[Fluent API Designer Crash Course](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/) to the rescue. You'll need: interface MyInterface { static MyInterfaceBuilder1 builder() { ... } interface MyInterceBuilder1 { MyInterfaceBuilder2 myMethod1(...); } interface MyInterceBuilder2 { MyInterfaceBuilder3 myMethod2(...); } interface MyInterceBuilder3 { MyInterfaceBuilder4 myMethod3(...); } interface MyInterceBuilder1 { MyInterface myMethod4(...); } } With this technique, you can even save yourself from the trouble of requiring a `build()` method at the end, because the final argument (`myMethod4()`) will automatically "build" the object. Might be slightly overengineered, though...
You appear to have missed the point. I deliberately named the variables `myApi` and `getMyMap` to deliberately push the idea that we are *familiar* with the API being used. Even with library APIs, I'm pretty sure almost every one has a set of APIs that they know in and out. In those cases, it helps remove a tremendous amount of verbosity! Also, I find code that is less cluttered much easier to read quickly. The second argument is that even in languages that hardly have halfway-decent IDE support (like Haskell or Rust), type inference works beautifully and most people (even if they are not used to it at the beginning), quickly get used to it and find it actually enhances readability. And we know that Java has arguably the best IDE support out there. Also remember that the linked article mentions local references (not method parameters AFAIK), so knowing the specific type on the fly (for the programmer/reviewer) is, I would argue, not that big a deal. Instead, intellisense would easily provide us with the possible operations on the object instantly. 
I really *really* like those enhanced enums. [I had wished for them since Java 5](http://stackoverflow.com/q/4290878/521799). Also, the underscore for lambdas is nice, since lambda arguments cannot hide outer scope and `i` is always in-scope already in my code. Yeah, it's the little things... :) Now: multi-line strings and named parameters. Please? Early Christmas?
I really hope this doesn't become commonplace. "Features" that weaken typing of a strongly typed language aren't okay imo. Might not seem like a big deal, but in C# when this was added it pervaded the entire ecosystem. That one little 'var' keyword is exactly why I'm not a .net developer anymore. 
I was really confused at first since I thought it was talking about the smalltalk dialect. But I am excited for this project. Var will be a great addition, since we currently double declare types.
It's not an additional check, it's almost the opposite: one less check. Instead of comparing left and right types for compatibility, inference blindly copies the right type over to left. 
I think people have a tendency to selectively read parts of comments. I mentioned in my very first comment that almost every feature has two sides to it - in this case, the result can be abuse of type inference, sure. That does not detract from its merits. I feel this is more of a difference in the mentality of the camps - some folks don't want any form of dynamism in the language, some others are exactly the opposite, and yet others choose a form of compromise. That's all well and good. If type inference weren't useful at all, you wouldn't see even stronger forms of type inference in even more strongly (and statically) typed languages like Haskell, Scala, or Rust. Fanaticism of any sort is always dangerous.
Why do you say that they do not follow basic design principles? The classes are package private, they can test them internally. Mocking is not the only strategy for testing, they can test the functions of the class or the class as a whole. Although I'm sure you meant something else but when you say: "a final class means you can't mock it which means you can't test it" is very very wrong, I think you meant you can't mock it while testing other classes which may accept it as a dependency or as a function call parameter, because mocking a class that you're testing is an obvious anti-pattern, that is a lot of times referenced in tautology driven testing which means nothing is really being tested.
The article doesn't seem to disagree with you...
Found the D guy! ;-)
The same story for 1000th time.
The simple solution here is to maybe hide the java docs or make a method hiding annotation.
ivy genuinely is great. community missed an opportunity to rally around an awesome barebones dm tool.
Open closed has little to do with class extending....though many people took it to be this, and it has caused a real mess.. Total mess. Classes should not be extended, in general. Extending a class couples its child with its parent. Coupling is bad. Open closed is nothing to do with this. Open for extension, closed for modification means that if you are creating a system, and this system has many different modes of working, then instead of modifying the same chunk of code, adding in new functionality with each new mode (a huge big if statement), it is better to encapsulate each mode in its own class. So, for example, If you have a photoshop type of app, instead of each filter been part of a super big FILTER factory class which knows all the filters, you have a plug in mechanism which loads independent filters in to some manager class which can call them when needed. OR, if you have a Web application, instead of having one big servlet which handles every type of request, you have lots of individual servlets, or MVC controllers, each handling its own specific path. OR, if you have a Unit testing framework, you dont go modifying that framework to add a new test. You just add a test, and the framework will dynamically search and load your new test at runtime without any modification. It doesn't just relate to object orientated systems...it relates to all systems.... one of the first programs I did when a kid was a text adventure game...this game (written in BASIC of all languages), started off as a huge massive mess of if's and thens, and it became so big and complex, my mate and mine couldn't get our heads around how it worked. So, we came up with a plan. Instead of modifying the one piece of code, adding new rooms as you go.... each room became a plugin, and loaded when needed into the main line code. It was much easier to maintain this way. To add new parts of the adventure (to extend) , we just added a new room plugin, and this was dynamically loaded in at runtime. 
Just to add Bertrand Meyer started pretty early with the ISA requirement on inheritance. It's not a neat shortcut. But yes "the industry" went full retard for a while.
I have some concerns about readability. It makes perfect sense to use `var` in the `var foo = new Foo()` case, because why repeat yourself and it's unambiguous that type foo is. But I worry about assigning from return values. Because it's not obvious what the return type is without knowing the function. It might be predictable, as the `url.openConnection()` example, but I'm sure there's plenty more examples where you don't know the exact return type. It makes it harder for the reader to know what a variable is. Like you say, an IDE can go a long way to resolving that issue, but only if you open the code in the IDE. If you're reading a pull request or something, it's not going to help. I foresee coding standards specifying when and when not to use `var`. 
Ok, silly question. Why do those exist. What benefit is provided by creating of(E e1), of(E e1, E e2), etc rather than simply of(E..e) or of(E e1) and of(E e1, E..n)?
Why would it?
This is a pretty common pattern for vararg methods in Java. The reason is mentioned in the article: &gt;In each method list, the first method creates an empty unmodifiable collection. The next 10 methods create unmodifiable collections with up to 10 elements. Despite their API clutter, these methods avoid the array allocation, initialization, and garbage collection overhead incurred by the final varargs method, which supports arbitrary-sized collections. Every time you call a vararg method in Java, an array is created to hold the arguments. Since arrays are objects in Java, this requires an allocation on the heap, and subsequent garbage collection. Calling a traditional non-vararg method is relatively cheap, because the arguments are passed on the stack so no additional allocations are required.
I wish they would do "let" and add the restriction that type inferred variables are final.
I assume List.of creates an ArrayList.
List.of is static. The implementation is in the interface. So how does it return a list?
One, look at the main entry points to the application. For example if it's a web app this will be in `web.xml`. Two, look at the interfaces to external systems. This will be your Hibernate DAO's, and REST/SOAP client bindings. Three, map out a few typical flows through the application and which classes are involved. This will give you a "big picture" view which you can then refine with further details. 
Thanks! I'll do this. Fortunately as an intern they give me work but they don't press hard on deadlines. So I can take my time and do this.
There's no guarantee that all the methods use the same implementation. It's possible that the fixed-size lists bake the elements right into the list object, rather than use a backing array. 
Oh dear, I thought that plague was limited to C++. I love the *idea* of operator overloading (great for vector arithmetic), but I've seen it abused in so many ways that I have a hard time trusting its inclusion in a language, now. 
My guess is they delegate to an internal list factory so List doesn't import ArrayList.
This is what I came here to say. The author doesn't understand the O/C principle. The O/C Principle is not about inheritance, it's about writing software that clicks together like legos: you don't modify bricks to complete your project.
It's a nice feature to have but to me the first example for unmodifiable list seems more readable than the second. For normal mutable collections it looks bether but maps it's plain ugly. I would rather use 4 lines than Map.ofEntries.
A couple of those creates specialized versions of a List. Size zero is a immutable singleton, size one is a class with one field and hardcoded size etc. Size two is the same but with two fields. The rest are actually arrays. The same applies to Sets and Maps. Set with two elements has two fields with randomized order. Map with a single key-value pairs is an instance with the key and value as fields. So yeah, an optimization with the cost of a complicated interface, with no effect on the call site.
One issue with `var` is that if type inference is added to, say, return types, it kinda doesn't make sense, you'll need a new keyword: var foo() { return "hello"; } But I guess that'll never happen.
I forgot to save this post and haven't read it at home. I'm glad i suddenly remembered about it. I've already read your github files and it looks like i'll able to translate it tomorrow (Actually, it's today. I'm going to sleep 5.00 am so my tomorrow means when i wake up again.).
Oh I wouldn't bet on it. The time it took for javac and IDEs to efficiently implement Java 8's [JEP 101](http://openjdk.java.net/jeps/101) (generalized target type inference) hints at the topic being non trivial. This won't be an issue in average enterprise code, but do combine some heavy generics, overloading, intersection types and perhaps lambdas in a single assignment... we'll see :)
Yes, your version is more concise. LSP was mentioned because many people do mention the two principles combined, especially using the strong historic link to object orientation and subtype polymorphism, which is overrated. The "distilled" principles say something else, more general. Anyway, you're saying the same thing with different words.
Sure, I agree. The assignment itself might not cause issues, but anytime you dereference something from that local variable, I would imagine the applicability / specificity / etc checks will become much more complicated, as you can construct a variety of types that are not denotable (i.e. that simply didn't exist in the current Java language). For instance, pass that local variable, itself being of a rather complex type, to a generic method that does some fancy `extends` and `super` magic on a generic intersection type... And it *will* be abused
Some of those look like they were taken from Kotlin (and Scala, and .....). Which, to my mind, is great. It means they're taking the bits of alternative JVM languages and pulling them in to the core Java language - which is a much better use of time and resources than some of the proposals that have been getting a lot more traction. (Like pulling JSON parsing into core, when there are perfectly good libraries that are trivial to depend on for the same job)
Variadic functions can also take pre-constructed arrays, so these ones will have to do an array copy to preserve immutability, or else... Integer[] ns = ...; List&lt;Integer&gt; list = List.of(ns); // better hope this copied ns[0] = 42; // or else we've just mutated our "immutable" List! Creating and copying an array for every `List.of` call is quite inefficient compared to the specialized solution.
I have actually never used it in my 7 years od programming. But hey, it exists
We have just solved that problem, thanks for suggestion!
No other structure guarantees reflection resistance. The only downfall is that you won't get lazy initialization.
&gt; No other structure guarantees reflection resistance. Mind elaborating?
&gt; awkward and hacky What's so hacky about it? Everything you'd want from a singleton, (except lazy initialization, if you need that) enum already provides. &gt; extremely lazy developers As if being lazy wasn't the greatest virtue a developer could have.
I'm not the author of this idea so is it enough if I'll point you here: http://stackoverflow.com/questions/5735797/is-this-singleton-resistant-to-both-serialization-and-reflection-attacks/5735894#5735894 ? Edit: Sorry, I see that source in SO comment is broken… This one works: http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=3 .
You can create instances of classes with only private constructors using reflections, but can not "inject" enum values.
To me it seems a *little* bit hacky but as far as hacks go I've seen much much worse. Inclined to say it's okay. I mean an enum is a class where there are *n* possible instances, and *n* can just be 1.
Myobject x = new myobject () is declaring twice. Var x = new myobject () has the same information with the same checks but without writing the class twice.
The factory methods are neither part of the languages nor the compiler. They're part of the standard library. So yes, modifying the Javadoc generator is less simple than changing a library function.
&gt; even in the face of sophisticated serialization attacks. Oh, interesting. I hadn't thought of this. Thanks for sharing!
[https://www.javacodegeeks.com/](https://www.javacodegeeks.com/) [Java Youtube Tutorial](https://www.youtube.com/playlist?list=PLFE2CE09D83EE3E28) Visit [SimplyLearn](http://www.simplilearn.com/) These 3 are good platforms to learn java from beginning. 
Sorry, for I have sinned... import java.lang.reflect.Field; import sun.misc.Unsafe; public class X { public static void main(String[] args) throws Exception { for (Cannot ok : Cannot.values()) { System.out.println(ok); } Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe"); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); Cannot yesICan = (Cannot) unsafe.allocateInstance(Cannot.class); System.out.println( yesICan instanceof Cannot ); // and then: Field ENUM$VALUES = Cannot.class.getDeclaredField("ENUM$VALUES"); ENUM$VALUES.setAccessible(true); Cannot[] soSorry = (Cannot[]) ENUM$VALUES.get(Cannot.class); soSorry[0] = yesICan; for (Cannot oops : Cannot.values()) { System.out.println(oops); } } } enum Cannot { CANNOT; } Output: CANNOT true null 
The only thing wrong with this is that you're using Singleton at all. Why do you want magic global static state in your program? You're going to think this is fine or clever or whatever, but literally 100% of the time this will burn you once your program gets to a sufficient size. You'll have hidden dependencies all over the place and the whole thing will be impossible to modify without breaking it.
https://github.com/chewiebug/GCViewer
I think one important reason is to be able to optimise low arity specialisations (empty, single-value lists) without paying the price of megamorphism at the use-site of such lists.
I like learning things at the fireplace with a nice glass of Malbec (Ballmer Peak!) but I've heard that Shiraz works, too...
Well this works, but I find that a hacky way to make singleton. Enums as their name indicate are for lists of values. Here you are going to get only one value in your enum and adding a new one will break everything. Btw, I often use enums for Open-Closed principle. This usage is a little conter intuitive. So, in the semantic point of view, it's really bad, imho.
Singleton doesn’t always mean state. And moreover, it doesn’t always mean mutable state.
Yes it works. No, please don't do that. The only thing I can say to something like this is "WTF?". 
All I've seen was this: &gt; but can not "inject" enum values. And I thought: Challenge accepted.
Whats the performance impact of using this? Or is it something only for dev use?
Well, *in this case*, it's true that you cannot do it with "reflection" (as in: the reflection API): http://i.imgur.com/iUXaznK.png
&gt; It does always mean state, otherwise it would be a static utility class. Unless it implements an interface. In general, I agree with you, mutable singleton is a thing you should avoid in your program (the exception is probably only if it holds some thread-local variable). But that's not what the initial question was about.
&gt; but the rest of your team must get it. You can use this to make a case against new Java 8 features like "Lambda's" because the team "doesn't get it". It's too often used against 'new' things because people don't like to change.
&gt; No, please don't do that. Why?
It's a hack, it isn't the Java way. However Java requires a good way to write singletons.
Enums are just classes with some specific rules; at run time only the instances that were defined at compile time can exist (unless you employ devilish trickery like /u/lukaseder demonstrated). So if you have the idea in your head that an enum is just a list of predefined values I can imagine this looks weird. So the most important bit here is to understand that in Java an enum is a special type of class, not a typical C-like enum. As such it can do a lot more than a C-like enum can. Since a enum is just a class with a limited amount of possible instances and a singleton is just a class with a limited amount of possible (1) instances; it's actually a natural fit. The main reason you don't see it that often is twofold. First of all a lot of people are used to doing it the 'old' way and enums are relatively new (1.5 IIRC). Secondly people are starting to recognise that singletons are in fact a bit of an anti-pattern (often are used to create global state and are hard to mock) so singletons themselves are avoided more. 
* Well, first and foremost, there is nothing to be gained by doing that. You can achieve the same thing by making a normal class with "private static final MyClass instance = new MyClass()". * Second of all you will confuse the hell out of the next developer who reads your code. Remember, we write code for other humans, not for the computer. K.I.S.S. * There is no point in using the "enum" since you're never going to have INSTANCE2 enum member (it would defeat the purpose). * Plus not to mention: singletons? WTF is this, 1999? Yes they have their place and their purpose, no, you're very unlikely to need one in your application. Don't make one, unless you know what you're doing. * This approach (as well as any other manual creation of singletons) is not suitable for DI. If you're not using DI, you're probably either making a "Hello World" application (in which case, go crazy, it doesn't matter) or you're doing it wrong. 
&gt; It's a hack, it isn't the Java way. Who decided that this isn't "the Java way"? An enum is basically just a class with a limited (at compile time) number of instances. A singleton is basically just a class with a limited (1) number of instances. So it's a natural fit. 
I wasn't asking you about why you should avoid singletons, that's not what this is about (and something I agree on; can't remember the last time I created one). But the only real argument is that you don't gain anything from it because you can't do private static final MyClass instance = new MyClass(), but that's not all you need to make it accessible from the outside. An enum would do both at the same time and also resist tampering with reflection. Also confusing newbies is not an argument against anything. Newbies will always be confused about stuff. 
Great work. Hope someone at Oracle gets some inspiration from your work
I covered this a bit in https://github.com/cretz/stackparam#production-usage. It's quite fast and all native at exception creation time, but I do call a bunch of toString's at trace print time but that's usually less common. It does add a bit of mem use and might disable a hotspot optimization or two, I am unsure. In general though, I've found it quite high performing with low overhead. Micro benchmarks gladly accepted.
 Thank you. I will give it a try.
Frankly I think that is the real reason. Basic points-to and escape analysis after inlining should be able to detect and eliminate the array allocation on the heap when the JIT compiler is in effect. Now, before that...
Thank you. I will move to that. 
Not quite as easy as that - https://jcp.org/en/resources/speclead_life And, I know before even starting I would be total crap as a spec lead!...
No. That's not a preference for intuitiveness. That's a complacent, ego-driven reaction. You encountered something you and your team didn't understand. You could have acknowledged the shortcoming in your understanding. Instead you dismissed it as Horrible Code™️️ and cut yourself off from a learning opportunity. `enum` singletons are not obscure or complex. They are a straightforward application of a basic Java language feature. Next time, say "oh, I guess I haven't learned about this" or "I don't understand this yet" rather than deciding that everything outside your current knowledge is weird or unreadable.
Yeah, I don't have strong feeling about this particular trick. Though, I do consider the singleton design pattern a borderline antipattern, so I'm not sure there's *any* approach to it that I'll be enthusiastic about.
This is not about "change", but about something undocumented no one knew why was there. If a team decides to move on Java 8, using lambdas is something that is taken for granted. If someone uses an enum to implement a pattern because a book recommends that way and does not documments it, is a problem for the rest of the team who actually cares about the whys.
Enums are actually the safest way to make a singleton when you consider cross-classloader behavior. It's a chapter in Effective Java.
You know what's called a chunk of code no one on the team understands and not even Stack Overflow can provide a bit of light on the whys and hows? Tech debt. This is not about egos (wth), understanding, experience or shortcomings, but about the fact that I asked everyone on the team, several friends that also work as programmers and I could and find nothing. I'm sorry, but if even Stack Overflow can't answer me a question about something on an architecture I file it behind "weird stuff". In fact, I saw this thread as a "shit, finally I understand this!" rather than "shit, what the fuck is this." And I've even ended the post wondering about the actual advantages of doing this. But hey, if you want to see that I just filed into the "what the fuck" folder, go ahead. P.S.: Now nitpick and tell me that technically that is not "tech debt". 
Spring JDBC template already does what you need.
It's not a waste of my time, or yours. Next time you dismiss some code as "unintuitive" you will think twice - even if it's just for a moment. This directly helps you become a better programmer. Take care.
So much hate.... People downvoting does not even take time to explain their point of view... reading comments I can see I'm not the only finding that code shitty :)
I honestly would like to see something like JOOQ added as a standard. It complements JPA really well.
Why to standardise if you can just grab the library.
&gt; The author doesn't understand the O/C principle. The O/C Principle is not about inheritance Why don't you just read the article *first* and then make your bold claims about the author...
&gt; JPA, and ORM in general, has proven to be a bane to many developers once complexity starts to increase. Not if you read [High-Performance Java Persistence](https://leanpub.com/high-performance-java-persistence/). You don't need a new JSR, you just need to learn how to run JPA at warp speed, and beyond.
Singleton doesn't have "valueOf" method, doesn't have ordinal and cannot be enumerated. Singleton is a design pattern, enumeration is a type. Enumerate singleton is a hack for me, and I respect your opinion: is equally valid ;)
Singletons have an ugly side effect, global access, that hurts testability. DI frameworks help in preventing this side effect.
DI helps in preventing this effect, but DI *frameworks* have features that are doing their hardest to emulate globals, through misguided features like **autowiring** and environment-specific **qualifier annotations**, which brings back many of the issues, which DI was created to solve. Some people manage to have architecture that truly has no global state. But most simply run to containers which let them avoid the well-known symptoms relying on global state (statics, singletons), while preserving the disease (coupling to environment configuration, uncontrollable shared mutable state etc.).
Mutable singletons are just asking for trouble. Might as well throw in some mutable global variables too.
Probably a stupid question but what's un-modern about a "getter"? 
People on SO know about it for sure, but how could you search for it effectively without already knowing it was meant to be a singleton?
what JOOQ is for SQL is Criteria API for JPQL, though I must admit, that the JOOQ API is much more refined, but that is also partially due to SQL being a bit different than JPQL
redundancy
Stackoverflow... your caught in a stupidity loop.
This is not a double declaration because you can have MyObject x=new SubclassMyOfObject() An IDE should provide you with the type. It does not help to read and is confusing for people learning the language Have a look at C++ template with auto and come back. The compiler can deduce everything but not the programmer! SO very difficult to read and to debug 
&gt; Just have good variable names and you hardly ever need to mouse-over. do you mean that you suggest to reintroduce type in the name?
No. Only enough to make it clear. You don't name it `nameString`, or `sName`, but maybe use `names` to mean List&lt;String&gt; instead of `ns`, or `nameArray` if for some strange reason you're unexpectedly using arrays. `personByName` for Map&lt;String, Person&gt;, etc.
why you get thread safety, security, and serialization all taken care for you? 
I second this! In my experience, the people who complain about JPA/ORMs A) Don't know how to use them, and/or 2) Don't know SQL well enough
Holy shit you're right. Somehow it got some upvotes ¯\_(ツ)_/¯
Not to defend his work, but he lists a bunch of requirements for object inheritance in the first edition of Object Oriented Software Construction. If your mental model doesn't fit in an ISA model and about 6 or 7 other principles, then you shouldn't use object inheritance, you should use something else like duck typing. (In your phrasing, if your type implementation doesn't fit into a taxonomy tree, don't use inheritance.) I read his ideas as very strict. ISA and contextual taxonomies are inherently at odds with each other. I'm not saying people didn't think this way, but I am saying I didn't read his work that way. I think other people fucked it up.
I guess when a java dev sees a question like this Effective Java is the first thing that comes to their mind... (don't know but you but this enum singleton really stick with me because of its "hacky" nature) And we just can't wait to share our knowledge and get some karma from our fellow programmers, don't we, hahah. We all have done something like this! 
Duck typing is basically no typing. But there's an alternative: separate interfaces from implementations. The interfaces can use multiple inheritance where applicable, and implementations can instead use composition. The trouble with inheritance are the implementation conflicts, coming from the imperative stateful nature of an object implementation. Interfaces don't have these issues, ergo there inheritance is largely harmless, even multiple inheritance (which Java supports for interfaces, naturally).
The integers have been broken!
In Java, `static` fields (including enum members) [aren't initialized until you actually do something with the class](https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4). So you get lazy initialization of singletons for free as long as you don't put unrelated stuff in the class.
But does var result = someMethodCall(); have the same info? 
&gt; The most counterintuitive part here is mutability. Actually, the most counter-intuitive part is enums being a class.
Oh I read it
[removed]
Using your basic problem solving and search skills. Searching for "enum instance" on Google gets you there right away, for instance. Alternatively - just learn the language features and idioms. If you understand how `enum` works and you understand what singletons are then the intent of an `enum` singleton is very clear. The instance is even called INSTANCE. If you frequently encounter "horrible", "unreadable" or "unintuitive" code written by other people then it is a *strong* sign that you need to brush up on your understanding of the tools, languages and domains that you're working with.
Holy *crap* was I bored. --- I was about to say "gotcha", then I realized I used `sun.reflect.ConstructorAccessor` and the entire point of this debate is to stay within "the spec" of the reflection API. However, there is one entry point remaining. @CallerSensitive public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { /* access checking code omitted */ // (1) if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException("Cannot reflectively create enum objects"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { // (2) ca = acquireConstructorAccessor(); } @SuppressWarnings("unchecked") T inst = (T) ca.newInstance(initargs); return inst; } If you argue that setting a field on a constructor instance is "within the spec", you could race the clazz field: set it to an non-enum class for (1) and change it back to the original enum class before (2). However, this approach has a slight problem: since both constructorAccessor and actual Constructor instances are cached, you have one shot per JVM at getting this race. Having one shot at something doesn't stop people though. I used Kotlin, but that shouldn't matter. import java.lang.reflect.AccessibleObject import java.lang.reflect.Constructor import java.util.concurrent.CountDownLatch import kotlin.concurrent.thread enum class MyEnum { INSTANCE } private fun &lt;T : AccessibleObject&gt; T.makeAccessible() = apply { isAccessible = true } fun main(args: Array&lt;String&gt;) { val myEnumClass = MyEnum::class.java val constructor = myEnumClass.declaredConstructors.first().makeAccessible() val internalClassField = Constructor::class.java.getDeclaredField("clazz").makeAccessible() val goLatch = CountDownLatch(1) internalClassField.set(constructor, Runnable::class.java) thread { goLatch.await() var i = 10000 while (--i &gt; 0) {} internalClassField.set(constructor, myEnumClass) } thread { goLatch.await() try { val newEnumInstance = constructor.newInstance(*arrayOf(":D", 1)) println(newEnumInstance) println(newEnumInstance.javaClass) } catch (e: Throwable) { println(e) } } Thread.sleep(50) goLatch.countDown() } Batch script: @echo off :while1 java -jar sandbox-1.0-SNAPSHOT-jar-with-dependencies.jar.jar goto :while1 Output: C:\Users\***\Documents\IdeaProjects\Sandbox\target&gt;k.bat java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.InstantiationException java.lang.InstantiationException java.lang.InstantiationException java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.InstantiationException java.lang.InstantiationException java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects java.lang.InstantiationException java.lang.IllegalArgumentException: Cannot reflectively create enum objects :D class MyEnum There you go. Almost 40 JVMs died for this.
I can use PL/SQL to get named params
&gt; Singleton doesn't have "valueOf" method, doesn't have ordinal and cannot be enumerated &gt; Singleton is a design pattern, enumeration is a type. Then why does it matter how you implement it? Just because the GoF book described it a certain way (which was written before 1.5) doesn't mean that is "the" way it should be done. A singleton is simply a class you can only ever create one instance off. Nothing more, nothing less. How you actually go and do that doesn't make something more or less of a singleton. &gt; Enumerate singleton is a hack **for me** That's fine. We're all entitled to our own opinion. My problem was with you claiming it's not "the Java way". 
Fun fact: this is also a way to hard crash your JVM. If you set the clazz field to null and don't override access checks, it calls `sun.reflect.Reflection.quickCheckMemberAccess(Class&lt;?&gt; var0, int var1)` with a null class, which then in turn calls `sun.reflect.Reflection.getClassAccessFlags(Class&lt;?&gt; var0)` with a null - crashing in native code. I certainly didn't know you could trigger such a crash just by reflection, always thought you needed Unsafe/JNI for that.
Primitives don't fit well in object oriented paradigm, the reason they exist is performance and memory usage. Primitives are themselves counterintuitive from OO perspective. Making enum a class is quite natural for an object oriented language.
Obligatory XKCD... https://xkcd.com/927/ But seriously most persistence frameworks seem to be designed around abstracting from the database, for the sake of avoiding SQL. My recommendation is just to learn SQL, and write your own persistence layer that suits your particular project. SQL isn't that hard, and you can reduce complexity of your application plus avoid many of the associated performance issues.
I've thought of that as well, but pure GC logs don't really reveal anything of use to third parties. Also, do you think that GCViewer is better than gceasy.io? The latter provides suggestions as well.
Standardization might also hinder innovation because of more rigorous testing and "don't break compatibility" requirements.
From what I saw, the suggestions weren't really that insightful, usually you know what you're looking for, and mostly it just provided pretty graphs, but gcviewer gives you the raw information in a "higher resolution" graph to really drill into things.
If I shit next to the toilet, do I blame the engineer designing the bathroom? ;) The moment you do `setAccessible(true)` you're on your own.
That was a mistake in my opinion. Hibernate would be much more advanced today, if it didn't have to do all that JPA politics. Conversely, Hibernate users would get much more out of Hibernate if they didn't feel the unrealistic urge to comply with JPA, having bad conscience from merely *looking* at Hibernate specific features.
While I don't agree with you on improving on JPA/ORMs (that will just fail again as history has proven: the topic is too opinionated to be standardised), I'm most certainly in favour of improving JDBC. Here are some features to steal from APIs like jOOQ, JDBI, Spring JDBC, Apache DbUtils, etc: - Named parameters (damnit, how hard can this be?? Implementations like ojdbc already support it. Now: Pull up to the specs) - Varargs binding on `prepareStatement` calls where all bind values are passed in one single `Object...` argument - Better fetching tools, such as fetching into a `Consumer&lt;Row&gt;` or just a simple `Stream&lt;Row&gt;` (I'd also happily take an `Iterator&lt;Row&gt;` over the arcane `ResultSet`) - A functional transaction API, like jOOQ's: `transaction((Connection c) -&gt; { ... transactional code ... }` which allows for easy nesting of transaction and abstraction of `Savepoint` - Optionally: A simple templating mini-language, but that might be out of scope because too opinionated for a standard - Optionally: Look into what the JDK 9 `Flow` API can do for "reactive JDBC". - Optionally: Add a flag to the javac that turns off certain checked exceptions. - Mandatory: ~~Urge~~ Beg on knees for Brian Goetz to implement multiline strings (gah, how can JDBC work with all that string concatenation for *static* SQL??) I keep trying, but he keeps hitting me on my head: https://twitter.com/BrianGoetz/status/844185201622302720 These would be no-brainer JDBC modernisations, in my opinion. Too bad JDBC 4.2 didn't include `Stream` support. A `Stream` and a `ResultSet` are so obviously the same type, semantically... There can only be two reasons: No time to get the resource management details right, no priority for either team. Heck, I'd even be happy to be on that spec team (if they let me and if they're willing to ignore my occasional rants, which they probably aren't).
But you don't necessarily disagree with improving the JDBC API, right?
&gt; And, I know before even starting I would be total crap as a spec lead!... Why? :)
I absolutely agree with improving JDBC. It's an incredibly ancient API that hasn't changed much (if at all) in 20 years; but most persistence frameworks go way beyond that goal.
Well, there are two things that can be done: - Improve JDBC with "obvious" new convenience features that don't go against JDBC's philosophy. - Rewrite the whole persistence world from scratch (yeah right) I'm usually in favour of doing realistic things :)
If you believe so, go ahead and file a bug report. I think doing this is the definition of shooting yourself in the foot.
Probably the most practical solution, without delaying JDK 9 even more.
*They would have to rewrite all of Open JDK from scratch to make it non-GPL* I don't think they would. As far as I know they own copyright to most of the Open JDK code. They can do with it whatever they please.
&gt; Oracle announces that some future Java version will change license to non-GPL and closed source. But how are they going to do that? If they even attempt that we'd just end up with "LibreJava". 
Right but you can't really write methods in your java code that use names parameters. Yeah you'd have name parameters in SQL but are you really going to use SQL to write the logic of your methods / constructors??
No. As copyright holder for the OpenJDK code, Oracle can distribute it and its derivatives under any license they choose​. And, in fact, they do. The Oracle JRE and JDK are both distributed u der their own non-GPL licenses, and they are both based upon OpenJDK.
Of course! Don't you know that average enterprise business logic looks like this? String unformattedDepotNo = depotNo; String query1 = "select replace('" + depotNo + "%','- ','-') from dual"; rs1 = stmt.executeQuery(query1); if (rs1.next()) { depotNoFormated = rs1.getString(1); } 
The modules concept, while being necessary, always did come across as being partially done. Hopefully they will give it more priority, and fix it (hopefully adding versioning support) well before Java 10's schedule!
&gt; OpenJDK cannot legally be changed to a non-GPL license. That's the entire point of the GPL. Wrong. They cannot *remove* the GPL license from currently released code, but as the copyright holder, they can most definitely say "all further releases will be under license X". 
While I trusted Sun (rip) I'm amazed that Oracle haven't done something like this to varying degrees already, maybe they do grok how keeping it open earns them money - who knows! It might be an excuse to learn mono &gt;:)
I would have loved to seen the discussions around this. I'm sure there are some pretty pissed off developers out there who feel like they just wasted a ton of their time doing something that is now just going to get switched off and ignored.
Hey, just wanted to let you know those exercises proved to be super helpful for my talk. I appreciate you sharing them with me.
Java is probably the most used programming language in the world. Yes, it's very relevant outside of Android. There are far fewer work opportunities in Python and Swift.
&gt; If you use Sublime for Java you deserve what's coming to you. Likewise if you write code like the above line. It's just to illustrate the point. Usually it's not that bad, but the proposal shows as an example a method or two deep. Take a look at the Builder pattern. &gt; So either you have pre-existing knowledge of that interface, which also applies to API return results, or you have to go inspect another file. And when you need to go examine another file, by copying the variable's *type*, and recursively grepping from the working directory - while using sublime - having to go inspect another class and dig through a chain of methods is a determent to me reading your code. If I could do '$ eclipse .' or '$ netbeans .' , I would. Using sublime is just for speed while reading through tons of examples. Edit: grammar &amp; *I use an IDE most of the time. But for quickly pouring through an example in someone's repo (while just reading), I choose to use vim or sublime as I spend a lot of time on the command line.* 
Great! Glad to hear it.
More FUD? Really? 
&gt; Take a look at the Builder pattern. With the Builder pattern it's rarely a shock what the type you end up with is: var foo = CarBuilder .blah() .blah() .blah() .blah() .build(); // Surprise! It's a Car! &gt; And when you need to go examine another file, by copying the variables type, and recursively grepping from the working directory - while using sublime If you use Sublime for Java you deserve what's coming to you. &gt; If I could do '$ eclipse .' or '$ netbeans .' , I would. Unfortunately you were born with a rare disease that prevents you from using the right editor, when it hurts your argument. I understand. &gt; recursively grepping from the working directory [...] using sublime [...] **for speed** Nice one. I also walk by foot 100 miles to my work every day. For speed.
Thanks for your nice words. Well, I don't disagree with you at all, but I don't think we need much on top of JDBC. Just some modernisation as I've mentioned [here](https://www.reddit.com/r/java/comments/60nz65/javaee_persistence_layer/df95uqz/). Check out how lean it is to write SQL in Groovy with multiline strings and closing over results etc.
The fact that you dont understand what type inference is at all, it makes me sad.
I had many questions just like yours when I was starting out as an intern. You should not be afraid to ask questions to your fellow team members. As others have said, large codebases can be hard for anyone new to grasp, not just interns. Only the people that wrote and work in the codebase can truly understand it. Ask questions, and ask more questions about why they did something that way when they give you an answer. A willingness​ to learn is more valuable. Good luck!
I would agree on versioning. However in regards to reflection support, the whole idea is to encapsulate private framework code so it can be improved. Because folks directly access (through reflection) the Java internals it makes it hard for the Java team to refactor and improve the Java JDK. It's a hard transition and I wish they had gone with OSGi, but I respect the decision.
[Reminds me of a recent video I had seen](https://www.youtube.com/watch?v=daF6tNnsw5c)
C'mon, even MS had to opensource parts of .NET stuff to avoid total community collapse. Unlikely Oracle will make the same error.
Article would be infinitely better without the incessant references to Buzzword-Bandwagon-Bob's book.
&gt; big kill switch FTFY
The collect method iterates every item, assigning the default variable "it" to each item. I'm just reproducing the DZone example by partitioning the array by whether or not the list element is greater than 50. 
Ah, exactly. Just trying to be explicit for those new to Groovy. 
Cool feature. Is there any way to do this with pure Java?
As I know, Java has event listeners to handle GUI components such as Swing, AWT. But it uses for a different kind of work. I think we have to use 3rd party framework. 
Just logic much. 
`Unsafe` and a few other classes will remain accessible, even with strong encapsulation. http://openjdk.java.net/jeps/260
So do you write things like this as well? if ((it &gt; 50) == true) ... How about this, to be entirely sure: if (((it &gt; 50) == true) == true) ... (ok, seeing myself out, sorry couldn't resist)
That's how copyright and dual licensing works. It is not related to the GPL
Don't be a cunt.
I sometimes cannot resist.
Yeah. It's called: Enterprise software development.
Your patches won't be accepted into OpenJDK unless you sign the Contributor Agreement: http://openjdk.java.net/legal/ which basically gives Oracle all rights to your contributions as if they were their own.
Did someone use Spring's application events or some other framework that adds events to implement any complex business logic in a real-world application? I would like to hear about your experience.
Yes, we do. Our portal pushes some messages to no of devices such as android, iOS, POS system. Let say, someone updates or delete the existing message. Then, the event listener is listening message changes and notify to devices.
I love the friendly and constructive answers I'm getting with this. I **knew** what that code was doing. I wanted to know **why** the original programmer did this instead of, say, just a static function, a classic singleton or whatever other option.
We're using some Xtext-based DSLs in production. I think it is worth trying. As someone mentioned, Xtend is an example of a Xtext-base language - also used by our project in production. 
I'm using Xtext for multiple projects at work (DSLs) and it is really nice to work with. As already pointed out you can derive your grammar from Xbase and enable your language to use all building JVM packages, classes, etc 
&gt; Unsafe and a few other classes will remain accessible, even with strong encapsulation. http://openjdk.java.net/jeps/260 * They print noisy useless warnings to console, each time program starts, and AFAIU these warnings cannot be turned off. I will have to read them over and over again. * The promise to kill it in Java 10 * The flag name (with the word "illegal") sounds like I'm doing something bad, but I'm not
&gt; Say, Unsafe.allocateMemory and Unsafe.putByte can be replaced with just about anything, say ByteBuffer No, they can't. * `ByteBuffer` is garbage collected, and I need raw memory which is not GCed. * it is not possible (easily and fast, without JNI) to extract memory pointer from `ByteBuffer` for example, to use it with JNA
Java EE6 was really the successor to Seam which was where a lot of the ideas for CDI were fleshed out. DeltaSpike is not a competitor to Spring. DeltaSpike is only meant to fill in the missing gaps in the EE platform. Its goal is to have those solutions eventually standardized the EE platform and then removed from DeltaSpike For me DeltaSpike was very helpful after Seam ended and my projects moved to EE6. For example EE6 lacks Transaction support for CDI Beans. DeltaSpike provided this. Once I moved to EE7 I removed that DeltaSpike module form my App. 
But the philosophy auf Java EE is still to use an app server, wheras CDI + DeltaSpike can be used as an alternative to an app server. &gt; For me DeltaSpike was very helpful after Seam ended and my projects moved to EE6. For example EE6 lacks Transaction support for CDI Beans. DeltaSpike provided this. Once I moved to EE7 I removed that DeltaSpike module form my App. Does Java EE7 provide transactions for CDI beans?
&gt; EE7 does support @Transactional on CDI Beans But that is nothing new, isn't it? As far as I understood, the DeltaSpike module for JPA provides transaction support for beans without requiring an app server.
It wasn't supported for CDI beans in EE6 so it is new for EE7 My end goal is to have everything in my app using standardized features providing by the EE platform. So once EE7 supported transactions on CDI beans I stopped using DeltaSpike for it and used the standardized EE7 way.
It has SceneBuilder embedded, but it's slow and a bit buggy. Better to just use it standalone 
Few questions about configuration frameworks used to read a software properties and parameters
interesting find and nice catch. It would seem like making bounds volatile would solve the issue. 
public class Task04 { public static void main(String[]args) { int[]a={10, 30, 20, 50, 40}; int largest=a[0]; int backup=a[0]; int location=0; for(int i=0; i&lt;=4; i++) { if (a[i]&gt;largest) { largest=a[i]; location=i; } } // this is as far as i could come//
Why do you need it not to be GCed? Just... keep a reference to it...?
And that is related to *Java* in what way?
Circular reasoning.
DeltaSpike is just a set of CDI **extensions** supposed be used on the top of JavaEE, in addition to what JavaEE provides or fills JEE gaps, not as a modular replacement for JavaEE features. What you are looking for is JavaEE/microprofile or Wildfly Swarm (I think it can be called an early microprofile implementation)
Yeah, but since question was equally absurd it seemed like a fitting answer.
ewwww
A HashMap lets you get the key and value together by calling `entrySet()` on it. That will give you a `Map.Entry&lt;K, V&gt;`. Then you can call `getKey()` or `getValue()` on each one.
Ah! I did not know this! Is it new in 7 or 8? :) This would've solved so many problems back in the day too... TYVM for this!
There are libraries that implement tuples for Java... but why not create an actual class for this? Something like - class QandA { public final String question; public final String answer; public QandA(String question, String answer) { this.question = question; this.answer = answer; } // boilerplate equals, getHashcode, etc... } // .... Map&lt;String, QandA&gt; map = new HashMap&lt;&gt;(); QandA qna = new QandA("What is a tuple?", "A finite ordered list of elements."); map.put(qna.question, qna);
I'm doing that, as it's a very convenient implementation. Unlike the article is stating, you don't have to extend your events from ApplicationEvent which leaves your domain model framework agnostic. Adding Spring integration those events can even leave the JVM. Here it gets interesting when you think about your transactional boundaries. What particular question do you have?
You are confusing Xtext and Xtend. Xtend (xtend-lang.org) is a JVM language (similar to Kotlin), Xtext (xtext.org) is a language framework to build programming languages (Xtend is built with Xtext).
That would certainly be better OOP :) good idea!
:| well my face is red.
Nah, it will just be Hudson - Jenkins
They are going to kill Visual Studio once they get their C# IDE out there.
Better to just hand code. The editor is great in IntelliJ and works well for direct javafx or fxml coding.
it seems like there is a large group of C++ programmers that would be lost without VS.
I've read linked e-mail twice, and I'm not convinced that what are you saying is true. And if it is true, those guys are very bad in explaining their intentions.
Does the font look different for anyone else? Specifically string literals [Images](http://imgur.com/a/4VaTq). Using Source Code Pro 14pt for both.
Looks bold
Apache is a graveyard? Kotlin is young, and syntactically very close to Groovy. I'll give you Scala, but Groovy has it's place, especially since Grails is one of the best frameworks around. I'm all for dynamic programming. It's what makes creating custom DSLs possible. Edit: you're free to statically type anything and everything in Groovy too. 
This is really low hanging fruit, and it aggravates me to no end why it hasn't been done yet. Tco was solved 50 years ago. Come on Java, we finally got lambdas, and you couldn't give us tco? Smh
* We cannot use fixed size `ByteBuffer` objects, because my small objects are not of fixed size. So I need proper pool do cache objects of different sizes * This pattern is implemented in netty, as `io.netty.buffer.PooledByteBufAllocator` * We use it in some places, but it is not universal solution, sometimes we need to be more efficient than `PooledByteBufAllocator`, because * ByteBuffer objects have large memory overhead (~ 70 bytes per object: just count fields of `java.nio.DirectByteBuffer`) and CPU overhead (because of indirection and GC overhead). &gt; It's just allocating and working with a region of bytes. It's not brain surgery. Implementing a good memory allocator is much more hard problem than you probably think. Just have a look at source of jemalloc or `PooledByteBufAllocator`. And it sill will be less efficient than working directly with addresses.
&gt; I'd recommend you read how memory management works in your OS, things like what a memory "page" is, or at least maybe what a "sector" on your HDD/SDD is, and research similar topics, because this betrays very poor understanding of the topic. &gt; research the way MemCache uses a Binary Space Partitioning for allocating memory blocks efficiently &gt; Have you worked with C/C++ BTW? Because I'd be really shocked if you have &gt; betrays very poor understanding of how you should implement this &gt; You also don't understand how modern GC algorithms work &gt; You seem quite lost in the topic. You seem to know a lot about me. I think you totally misunderstood me. I never talked about pages and disks. Probably because you are convinced that I don't know anything. That's fine, I'll still try to explain you smth. Suppose, you have pooled allocator (proper, super efficient etc etc). In that allocator you at some point call: ```myAllocator.allocate(10) // returns ByteBuffer``` At that point you've got a `ByteBuffer` object which size is 70 bytes. Problems are: * if such objects live long enough they are promoted to old gen eventually causing painfull full GC * if you have lots and lots of these objects (e. g. millions), and if you allocate and release these objects frequently you will start noticing GC overhead, in particular, pauses * memory overhead is huge: for 10 bytes of pooled memory you've just got 70 bytes of `ByteBuffer` object. Memory overhead for small allocations is huge. As I said, this is how `PooledByteBufAllocator` works. It works well for large allocations, but not for small. &gt; Yeah and netty is known for being among the slowest frameworks on the market, right? /s I don't see, how it is relevant to memory allocations.
 myAllocator.allocate(10) // returns ByteBuffer I never suggested that your API should *return* a ByteBuffer, I suggested that you write a ByteBuffer backed shim for the Unsafe API, which returns `long` addresses, not buffers. If you have a lot of code which uses `Unsafe.allocateMemory`, you want to change the least amount of code, have the least number of objects, that's the first trivial thing to do. Then all you have to do is replace all instances of `Unsafe` with `MyUnsafe` and you're golden. Your entire argument about how "memory overhead is huge" for a 10 byte ByteBuffer means you didn't research anything of what I said, and skipped the parts where I said your smallest ByteBuffers will be 4kb, even when you're allocating 10 bytes. Too bad I guess, I won't repeat myself, if you're willing to know what I actually proposed you can go read the comments I already wrote.
&gt; I said your smallest ByteBuffers will be 4kb. No, it won't if you are using either: * heap byte buffer * pooled allocator, e. g. `PooledByteBufAllocator` which does `slice` on large allocated native `ByteBuffer` &gt; Then all you have to do is replace all instances of Unsafe with MyUnsafe and you're golden. You didn't explain, who is going to allocate memory in `MyUnsafe` when `allocateMemory` is gone, and `ByteBuffer` has huge overhead for small allocations.
&gt; You didn't explain, who is going to allocate memory in MyUnsafe when allocateMemory is gone, and ByteBuffer has huge overhead for small allocations. You have to be kidding me. Did you read the comments I posted until now very carefully? Did you research the terms I pointed you to, like how memory pages and disk sectors work? You can allocate one 4kb ByteBuffer and reserve 409 unique 10 byte slices out of it, and return addresses pointing within that block. At offsets 0, 10, 20, 30, 40, 50, 60... Do you understand this concept?
Doing it at compile time would eliminate the need entirely.
they already sell the resharper plugin which i've heard is mandatory for VS
Definitely don't mention Double.MIN_VALUE (if you don't know, it's not what you think)
Working on Windows, they changed the font size from 12 to 11pt
Actually, I'm a bit tired of your rudeness and arrogance, so I wish you the best and good luck. 
I use it for the data module. It has its niche, but if you use spring, you will use spring data for that. Generally, if you use JavaEE, you try to stick to the standards. I see no main stream usecase for CDI in a desktop application. I think, that Google Guice is the dominant dependency injection framework for that area. There is also Dagger for Android. 
I am a big Spring and Spring boot fan, however for a project that I was not the architect we decided to go fully Java EE stack without any Spring and because as explained in the other comments the JavaEE stack is not so user friendly and has a lot of missing bits compared to Spring so we decided to use Delta Spike and YES it is a success, basically the project was released and actually have a lower memory usage if we had went full spring and spring boot. It was a retail store with basically TomEE + Delta Spike + Hibernate with a very high load during some peak hours and days. 
I tried going without it for months after a fresh install because i didn't want to renew my subscription. About 3 months in i decided the subscription was worth it
I think that the reason is the same why Google's Closure Compiler was superseded by NodeJS-based tools. JavaScript-community want's to write their tooling in their beloved JavaScript language for their favorite platform. This is also the same reason why development and build tools for Java (e.g. Eclipse, IDEA, Maven, Gradle) are JVM-based.
despite not being a particular jscript fan, I've implemented scripting in a few projects and Nashorn is basically trivial to shoe horn into a project even if it was never particularly intended for scripting, I'd encourage anyone who needs a scripting engine in their project to just do it, cause its a whole heap easier than you'd expect!
If you're a fan of Nashorn you may be interested in a new implementation of JavaScript on the JVM, Graal.js. https://www.youtube.com/watch?v=OUo3BFMwQFo It has performance comparable to V8 (the JS JIT in Node.js), which is a lot faster than Nashorn.
Honestly, I just haven't heard people talking about serious and compelling use cases for JavaScript in a JVM. * You want to add script-ablity to extend a Java application? Groovy seems to have that niche locked up. * You want to run Node.js apps in the JVM, because you think that will give you better performance than V8? I guess you can try it, but I don't have time to deal with all of the inevitable compatibility issues. Even native Node is barely compatible *with itself* from release to minor release! * You want a Java REPL? Okay, but there are better third-party alternatives today, and a better built-in option is coming with Java 9 in a matter of months. I'm not trying to be mean, I'm just turning the question back around. People who care about JavaScript interpreters in the JVM, what is it you're doing with them or wanting to do with them? 
&gt;So ironically people wait for Java 9 and its REPL when, for instance, JJS is already here This makes no sense at all. You would expect people working in Java to like using a REPL with Java, not JavaScript. 
Spot on. The question appears to be quite trollish to be honest.
A Java REPL does not make sense at all, instead. They have got to invent a whole new syntax because Java Statements where meant to be in classes so if in Java REPL if I write i = 10; // is that correct ? or should I have written int i = 10; 
They also recommend the use of vRaptor instead of spring mvc. Don't worry about looking it up, you don't want to use it. Take their views with a grain/ton of salt. 
I've used it frequently quite successfully. &gt; You want to add script-ablity to extend a Java application? Groovy seems to have that niche locked up. Does it? I've always used JavaScript since it's well known. No need for extra training on yet another language. &gt;you want to run Node.js apps in the JVM, Who would actually want to do that? &gt;You want a Java REPL? Okay, but there are better third-party alternatives True. Like BeanShell which has been around forever. &gt; what is it you're doing with them or wanting to do with them? I used it for a script api for a game I was building. But commercially we used it to script our HL7 engine - again JavaScript was the way to go since it's well understood out there. 
I am surprised to see a notion that JavaScript = Node.js. There are tons of other frameworks in JavaScript world and Node.js is far from being the best. Any decent JS code works in Nashorn just fine.
&gt;Or can I just treated as basically the same without manual memory management No. Being a C++ programmer I think you will have an easier time learning Java, and it is bonus that the sytax is similar, but the languages are not the same. Your quoted view would have been less wrong in the 1990s, but a LOT has been added to modern Java. I've seen a bazillion books on Amazon over the years with titles like "Java for experienced programmers" or "Java for C++ programmers". Get the most recently published 5 or 4 star book off of Amazon and read the most critical reviews ( somethings they actually sell me on the book, one man's meat is another man's poison ).
I have users (process designers) build simple functions with [blockly](https://developers.google.com/blockly/) and need to run them. Too bad the Blockly compiler doesn't really work in Nashorn due to the missing DOM, so I have to compile them once with an external nodeJS service. But I don't need any nodeJS during the runtime of the process, thereby reducing complexity.
I guess server side rendering for certain UI frameworks could be a sensible use case.
Ahhh ok thanks. I'm guessing writing 1990s Java in 2017 is frowned upon :)
I agree completely. I've only seen usage of Nashorn proposed as part of a meta-programming initiative. My personal experience leads me to think that meta-programming is deceptively complex and difficult to test. It may be a nice tool, but there's a bit of a solution in search of a problem, at least from the problems I deal with. Admittedly, this is anecdotal.
No, I dislike Groovy. Also I don't see additional information provided as verbosity and even then verbosity is still better than too much syntactic sugar, meta.template^TM programming, anonymous blocks or otherwise magic happening in the background.
I 've enjoyed this but I believe we will end up to agree to disagree. Java is class centric no matter what. Your minimal REPL code needs to be wrapped into a Java class, which makes REPL code a variant of the language. because int i=0; is not valid java but public class Wrapper { public static doSomething() { int i=0; } } is In JavaScript, what you write through the dev console is what you can copy paste into a solution. That's also why Javascript has the famous function "eval" and Java has not. 
Im not that familiar with google cloud yet but have a project in the coming months that should be deployed there. Are there any advantages to deploy on GAE instead of Google Container Engine?
If you use Vector, you will get laughed out the office. (Unless you know the exact situation to use Vector, which is very rare)
Do you think this is good for a first time learning to code or i should go with a more basic kind of thing? A few people told me to start learning java first because its a good base to learn other languages
I have seen JVM JavaScript engines used to evaluate scripts that run on websites, parse JavaScript (return the AST for example), and other tasks you might want to do with JavaScript outside of a browser. There are lots of use cases.
The APIs will be the biggest differences and that really depends what you plan on doing with java. For basic command line type app that might have data structures and system IO you can probably write a bad app that gets the task done simply by googling each specific code part you get stuck on but other java developers wouldn't approve if they had to use it.
Yeah I'm worried it's probably gonna be like that for a little
Yeah, basically, Java 1.2 introduced the Collections framework and Vector was shoehorned into that. New unsynchronised data structures were introduced, while the old ones were left as synchonised. In Java, ArrayList is preferred over Vector because it's quicker in the majority of use cases. I remember being taught Vector when I was taught it in uni. 
Too long, didn't read: if you're already doing good, clean object-oriented design in C++ then there isn't really anything major for you to know and you can simply Google for syntax differences if you ever find any. ***** Java is aggressively object-oriented, while most C++ programmers I know do a ton of purely-procedural coding. Java will let you do some stuff like that (for example: writing a ton of static methods everywhere, using classes as global variable holders, struct-like classes that only hold some arbitrary data, etc). The difference is that while C++ will let you work like that year in and year out, Java will eventually bite you in the ass and you'll have to rewrite everything into actual OOP style. So, if you're that kind of C++ developer who gets a hard-on by writing macros, abusing pointers and doing/using stuff like I mentioned above instead of just doing good OOP design (which you always should anyway IMO), then I'd definitely take the time to study OOP in itself (not necessarily a Java tutorial even) and design around 10 OOP projects before you begin actual Java coding - and I don't mean programming 10 of them, just doing a ton of design exercises so you know what OOP really is before you jump into Java coding itself. Other than that, the syntax is nearly identical and you won't have problems with that at all and Google can help with minor stuff. But trust me: if you go into Java with the same mindset of C++ where "everything goes as long as it compiles" you will, definitely, come to regret it at some point. Sure, it may take you 1 year to get there but eventually you'll realize that the VM cannot optimize the style you're coding in (and it needs to, to get near C++ performance); that you should have created a class hierarchy instead of using different static methods to do stuff that is related; that the libraries you want to start using in your project are expecting objects to operate on and not those primitive-data arrays C++ guys love to use so much to hold data; etc etc etc. When you finally realize it, then maybe you'll have 1 year of code written that now you need to refactor entirely just so you can move on with life. Yay! My point is: the entire Java stack, from libraries to the syntax itself to the JIT compiler, debugger, profiler, IDEs and everything are all written targeting clean, well-designed object-oriented code. *They will let you write weird stuff* but that's a very dangerous illusion because you will more likely than not reach the point in your project where you'll decide it's better to spend a month refactoring code into a good design than try to hack everything else to force it to work with a C++ coding style that isn't really welcome at all (but definitely doable) in Java. Good luck!
My advice for a first time coder: https://www.codecademy.com/learn/python As the site says, "it's great for a first language" but don't let that make you think it's not gonna let you do "big boy" stuff. Python is one of the most used languages in the world and a first choice for many of the world's best programmers. This very site we're using right now is written in Python and it is also the third most-used language for GitHub projects worldwide http://githut.info/
No. Java is very different from C++, although the syntax is similar. The platform is entirely different. You're writing code to compile to a VM byte code format instead of native code. You should know approximately how the Java memory model works, not to mention best practices are different across languages. You'll have to unlearn some habits from C++ that won't translate well to Java. I imagine a seasoned C++ programmer will be particularly prone to pre-optimizing code in a way that conflicts with the JVM's runtime optimizations. I mean, how would you respond to someone saying "I'm a Java programmer who has to use C++, can I just do the same stuff but manually manage the memory"? It's not so simple that we could cover it in a short reddit post.
Java didn't even have generics until the mid-2000s. If your last experience with Java is pre-2004, you're in for a big surprise. The biggest changes in recent years (since 2014) is the inclusion of streams (basically, collections that can be used lazily for functional-esque programming).
I'd say going from C++ to java using the core language and libraries is much easier than going from Java to Java UI or Android.
GAE has the advantage over GCE that is takes care of auto-scaling, auto-healing, integrated diagnostics, and simple deployment or your application. You don't event have to think in terms of containers. On the other hand it has limitations on what you can do. All that said, there's a trade-off. I've just found this article which compares those options Google provides. https://medium.com/google-cloud/containers-four-ways-457f4b7dd898
On the string topic: that's mostly a good thing I imagine? 
cool. nice way to end this friday. I agree with you man on this: "I do consider that Java made a mistake of not allowing free functions" That's exactly it. thanks for the interesting note on 'eval' 
Well... yes and no, as you may not be familiar with some of the concepts. However, it *does* help you avoid some of Java's gotchas.
Or better yet `Collection` or `Iterable` :) **Edit:** I should clarify that I mean for parameters. Accept the lowest interface you need and return `List`
Nashhorn has been at the core of our system since it came out. The problems: is some don't know js, complete lack of compiletime (...write time since no compiling?) error checking, complete removal of pre runtime type safety, and a whole lot of other stuff. Transpiling from ES6 to js helps problem 2 by finding syntax issues at least. It also adds lambda support.In my opinion it's crucial to the process. EDIT: a big part of it's unpopularity is it's barely documented. I didn't even know exports existed for like a month. 
Right back at you! Have a good weekend! :-)
There are a lot of frameworks in Java. Jersey is pretty popular for REST. Tomcat or Jetty for HTTP. I'd also look at the Play framework, which is available in Java and Scala. I also think you would like Dropwizard if you like the way Express is designed. Learn ORM with something like Hibernate. Or at least understand what an ORM does, since I don't think there is an equivalent in Node.js. It is very common. JDBC is also your friend. Most importantly, learn how threads work and how to do concurrency the right way in Java. You don't have the event loop callback chain like you do in Node. You'll also need to learn how to use Futures for async programming to take full advantage of the JVM's power.
Or you could just use Java libraries since you're targeting a JVM. Java.type and imports work after all. var classRef = Java.type() var s = new classRef(args) You can also include this all in your ScriptContext, or other boilerplate-removing-import-script. Edit: Several mature projects exist which allow loading node modules into Nashhorn. So now you have 2 of the largest OSS ecosystems out there instead of one. 
* Spring Data ReST * Spring Security * Thymeleaf or JSP * JUnit * Spring Data 
That's a strange way to even begin with metaprogramming, no? I've never heard that term outside of perverting CPP's templating system
No, just no. If someone is returning an ArrayList, 99% of the time I want to work with the List interface on that returned data. If you pass back a Collection or even worse Iterable then I have to cast to List most of the time. Returning it as a List is preferable.
 &gt;you want to run Node.js apps in the JVM Who would actually want to do that? You don't seem to grasp just how much of a boner/girlboner people have for node.js. Offtopicish: I must say I thought node was just gonna be some flash-in-the-pan hipster shot...but it's clearly here to stay.
Try CommonJS it sounds like a perfect fit for you
Thanks
Sorry, I should have said they should be used for parameters, not return values. 
Spring has already been said, but I want to second how universally marketable it is for Java web dev. Go through a couple of the guides on https://spring.io/guides. They generally take around a half hour to do and convey the important bits of knowledge. Plus you can put the completed code somewhere to reference in an interview and prove you're serious about making the switch.
Literal strings are objects, so it's not only common, but preferred to use SOME_CONSTANT.equals(someVar) vs someVar.equals(SOME_CONSTANT) due to alleviation of the null check and risk of throwing an NPE. There is no operator overloading, no multiple inheritance (although the addition of interface default methods blurs that line a bit) and you'll want to learn about class loading in lieu of linking. Check out the effective Java book series. Generics will make you want to kick a baby in the face. Have fun. 
Oh hey also all methods are by default virtual in Java, so that's a thing.
Interesting thing about the '==' for Strings in Java is that it compares the addresses of the strings in question, not their values. Kinda like using an `&amp;` in C++ to grab the address and compare it.
That is as fine a resource as any.
Threading and higher modes of concurrency. Java has a built-in thread/memory model (I know that C++11 does too, but that is hardly perfect or standard across compilers) which is quite okay. Despite most uses today being of higher-level concurrency constructs (Executors et al), I would say that a solid understanding of the `Thread` class and the memory model will serve you quite well indeed! Also, the standard library is huge compared to C++. Most of the functionality you need will probably be in the standard library. Exploring it is highly advised! :-) Generics in Java do type-erasure (for now), so you will want to be careful when you use them! That being said, they are simpler to use than templates. And, oh, also interfaces. A bit like abstract classes in C++, but not quite the same! In fact, interfaces in Java are quite powerful and useful, and quite underrated in my opinion. Finally, once you get to Java 8 and above, Lambdas and Streams. Lambdas in Java aren't as powerful as in C++, but they work quite well, and Streams are an absolute pleasure to work with. Good luck!
And this is due to there being no operator overloading to change this behavior. 
You need to `new` everything. In C++: vector&lt;int&gt; v; v.push_back(25); // This is fine because v is on the stack In Java: ArrayList&lt;Integer&gt; a; a.add(25); // Will crash because you have not created a 
eh more or less, some differences, java takes the oop thing super siris and not as many quality of life tricks.
/r/javahelp 
&gt;Karate You know you can split up the README into multiple documents, right? That's like a mile long.
I've been in the opposite situation a few years ago and I'd say it depends on what you're planning to do. If it's a private getting-started project or some excersice e.g. for university I'd say yes. You will hit some walls quickly, but also learn as quickly. If it's for some enterprise application (e.g. using JEE), then definitely no. You should at least cover the fundamentals of the language. It should be easy coming from C++ (I bet there are tons of guides for switching from C++ to Java, which make the transition even faster), but you still need to be aware of it. And then learn JEE :) ...oh, one thing I frequently forgot at the beginning when I switched was the call-by-reference/value thing.
For the love of god please read Sun's style guide, it's old, but probably 99% still applies http://www.oracle.com/technetwork/java/codeconvtoc-136057.html This Seriously Triggers me: public class SomeClass { private String _prefixing private String how_about_snake_case;
Nah, it won't compile since `a` isn't initialized.
don't get this, the few questions are so trivial I couldn't even think how to describe something so simple... 
Thanks for the info!
Don't trust the python people, it's a meme language that lets you get away with anything so you learn nothing.
Vector is basically a thread-safe ArrayList, so when ever you need to read and write to a list from multiple threads and you don't use your own locking.
It's called "open session in view" and it's an anti-pattern: https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern/
Never dir a Second think generics are "Kind of templates". They are just as much templates as s C ist C++. Read the Java tutorial in generics, and try not to cry. Sarcasm aside. Java hast other (arguably more OO) ways of solving problems. But at least I have to Make a concious effort to not design templates classes using generics. It Looks like it should Work, but type erasure spoils the Fun every time...
Use ArrayList not Vector. 😀
I don't think that's very accurate.
I did the same things few years ago. Java is much easier than C++ What are the main differences: * there is only reference, that is pointer. There is no automatic variables (i.e. variables defined on the stack like Myclass x; in C++), so data members (except primitive type ones) are always pointers and you need to allocate them. You do not need to deallocate them. This is the job of the dtor * There is no destructor, so no RAII and this is not simple at the beginning to avoid it. Honestly this is somethign that is missing. You have to think differently * There is no template with primitive type. Try to use as much as possible primitives types. Be careful with Integer and String they are immutable. * Friend, compilation control (#ifdef) and typedef are missing. Friend is really missing. You have no choice that avoidind the use of these 3 things * there is no copy ctor, operator=,so that's really nice and faster to code. iterators are normalized. data structrue are well designed Good luck 
Not that every app needs every library, but I almost always bring Apache Commons Lang3 into my projects. It has several Tuple-style classes: https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/tuple/package-summary.html 
I prefer TestNG it to each their own, but Testing: - Spock - Mockito - Powermock (Great for Mocking Static methods) - Geb - AssertJ General Utility: - Jodd - Apache Commons - Guava Messaging (Listing Just Java Centric Stuff): - JMS - Kafka DI/IoC: - Spring - CDI Search: - Elasticsearch Coordination/Discovery (Java Based): - Zookeeper/Curator - Atomix Cache/Data Fabric: - JSR107 API - Ignite - Some Still rely on ConcurrentHashMapLRU - Caffeine - Hazelcast - Ehcache Templating: - Thymeleaf - Pebble Build/Dependency: - Gradle - Maven DB: - HikariCP - DBI - Jooq Misc: - Dropwizard Metrics -Java Mail 
One thing you might need to get used to as you switch from C++ to Java is that micromanaging performance probably won't work. As difficult (infeasible?) as it is to predict how exactly a C++ program will run on even known hardware, Java's JIT system has more going on. It's not just the initial just-in-time compilation to native instructions, but also dynamic performance-driven recompilation that includes branch prediction and other crazy optimizations. I ran a batch operation a bunch of times in the same process and gathered CPU time for each. Each batch is executing the same Java code on the same data, so they should be equivalent other than those JVM/JIT tweaks: batch time (seconds) 1 3.72387 2 0.727355 3 0.619783 4 0.579416 5 0.495118 6 0.546002 7 0.517789 8 0.533981 9 0.51089 10 0.452555 11 0.454784 12 0.467984 13 0.4954 14 0.399778 15 0.404552 16 0.400644 17 0.400224 18 0.400941 19 0.391058 20 0.385732 The first one did the initial JIT, and this is not a small application, so it took a few seconds. However, the second batch was still almost 90% slower than the speed it settled down to after a number of passes through that code. This does make benchmarking and performance tests harder (or at least slower, as you have to let it burn in first), but it does mean that it can make heavily-repeated code run faster automatically. When I say it does crazy optimizations, I mean things like eliding your null checks. Suppose a parameter to a routine is non-null for the first N times the method is called. The JIT may decide to just stop checking for nulls … and then if a null occurs it catches the SIGSEGV, recompiles the code with the null check restored, and then runs it again. This puts the code you write very far from the metal … but does make it run faster.
Jeez! Thanks for the list.
&gt; So ironically people wait for Java 9 and its REPL when, for instance, JJS is already here I have not heard of anyone excited about the REPL. 
Why?
Where would you recommend spring over dropwizard? I've been using dropwizard for a number of years now (all backend json in json out services) and really like it, but I wonder if I should use spring for a new project...
We found that reading JSON in Java and passing it to Nashorn scripts for processing was ungainly and slow. Using JS as part of an ETL pipeline was the design goal, and it failed us. 
Wow, "server side development in Java" is a rather broad category! Since no one else has mentioned them, if you're in a data-heavy environment you should consider Spark. I would say Hadoop, which is still a very big thing, but Spark is looking like it'll be taking over more. YMMV. 
Spring is king.
Think of it as C++ with nicer build tools If you are a programmer of any skill you will find that Java is pretty much the same - slightly different syntax, more robust and standard built in SDK functions/algos library You probably want to start by playing around with a few template projects in gradle and maven - they will cover build needs for 99% of code out there After that install IntelliJ and enjoy the good times
Sure, but I'm referring to simple use cases with String.
because you're then forced into knowing the details of the implementation. it breaks encapsulation, because I now have to figure out what they mean by "equals." Some would make it equivalent to .equals(), others would do identity comparison, others would do "sameness"-type checks You can also imagine a world where they overload '==' for floating point, to compare equality based on some threshold of error. I like that the ONE way you do it is .equals(). I know BigDecimal/BigInteger would benefit from this, but everywhere else I see it more like a leaky abstraction. 
It's not just strings. Learn the difference between == and .equals(). It'll come in handy a lot. 
And the thing is, strings are pooled and using `==` might work sometimes, leading to confusing debugging sessions :)
H
I think a lot of programmers have decided to ignore most of the stream API and various functional features. The cleaner notation for anonymous inner classes is nice but the rest is fairly controversial from my perspective.
Start calling everything AbstractSomethingSomethingFactory.
&gt; Also, destructors are useless in java Yet so many C programmers who now have to do Java keep doing this shit: public void destructor(Object o) { o = null; return; }
&gt; And Javadoc is beautiful, of you ever need to know what a method does the documentation is right there in the IDE for you Unless your IDE sucks and all the code you need the doc for is in a goddamn .jar and the Javadoc won't pull up. And unless the Indian consultants who wrote the codebase before you got there, under the guise that Javadoc was required for all methods, just simply copy-pasted this for every method's doc: /** * @todo description of the method * */ 
Even worse, they use finalize method as a destructor. And they misuse generics, treating them like templates. 
I believe somebody built a GUI using visual basic to track the killer's IP
Dropwizard is only for the REST+HTTP layer. Spring covers that and almost everything else. You really have to subscribe to the whole framework to get the most out of it. This is great for some projects, but I'd rather use Dropwizard and pull in other libraries when I need them. Plus you have the option to switch out libraries if you need to.
You think anyone is going to read this massive blob of code with not even an explanation of what the supposed problem is? 
I need help with the input scanners. How do I start?
I went from c# to java dev in no time. Just learn what a jar, war, servlet, descriptor, Pom file, basic libraries, etc are and you will be off to the races. 
It's no JavaScript, but still 
If we avoided things because they *can* be abused, we'd never have left C99 (C11 has function overloading). It can be useful as well as abusive. Depends on the quality of worker and documentation.
https://i.imgur.com/Thg517x.jpg
System.in.read()
You're just conditioned to Java's limitations. There is no one way to do equality comparison in Java, because [`equals`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-) (sensibly) defaults to identity comparison for any type that does not provide equality semantics. This requires just as much trust as when somebody overrides the `==` operator in a language where that operator represents equality (e.g. [C#](https://msdn.microsoft.com/da-dk/library/53k8ybth.aspx), [C++](http://en.cppreference.com/w/cpp/language/operator_comparison)). What Java and C# get right is a very clear distinction between equality and identity comparison: there are well-established conventions for communicating whether you're doing one or the other. C# merely chose to make equality the first-class citizen rather than identity. Whether operator overloading is a desirable feature or which language's approach is better are their own discussions.
But the same applies to overriding equals. You don't know how it was implemented, if you don't learn it. Most of the time you are interested in comparing a state, so imho the shorter == is a better choice for state comparison than equals.
Only compile-time literals, so only `a != b &amp;&amp; a.equals(b)` can cause false positives. Unless you call `intern`, which you have no business doing, and I don't think that's even guaranteed to work.
It has actually aged really well (I suppose in part because Java moves so slowly). In any case, rumour has it he's in the process of updating it.
Scanner in = new Scanner(System.in); make that a field (outside a method at the top) String input = scanner.nextLine(); will halt for user input. Then parse the string to float/double/etc and you're done Scanner can wrap any input stream by the way. Files, networking, all kinds of shit. This is very googleable though, and belongs in /r/javahelp
Don't worry too much about reusability. Just write simple code that does the job with the least amount of indirection while still remaining testable and understandable. Avoid writing your own annotations. Even the mature frameworks overuse them; chances are you'll overuse them even more. Biggest tip is probably this: have a look at building some simple service in nodejs + express, or perhaps ruby with sinatra (but *not* ruby on rails). Notice that you can get a *lot* done without metaprogramming and frameworks. Now take that lesson back to Java.
Except all the "utility" and "helper" classes like java.lang.Math ;-) Better don't think about them, to not feel encouraged designing classes like this, if you are coming from a procedural language.
[Bingo](https://blog.jooq.org/2014/04/01/spring-api-bingo/)
1. Since this is help with **Java Programming**, it should be, as the **plenty** hints on the page indicate, posted in **/r/javahelp**. 2. Before posting there, **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) because as you have presented your post here would be against most guidelines. + Endlessly long code without code formatting (should be on a code hoster) - the code is **not even complete**. + Code only post without description. Posting the description in a comment is not sufficient **Post removed:** Programming help.
Since you haven't mentioned this, C# has an explicit method for checking if references are equal: [`Object.ReferenceEquals`](https://msdn.microsoft.com/en-us/library/system.object.referenceequals.aspx)
Reddit is **not a self promotion platform**. The reddit rules **explicitly** allow **one** self promotion (i.e. link to your blog) in every **ten** contributions. That means that **nine** contributions must bear no reference to your blog/content. You have **massively** exaggerated that limit. The reddit **spam** rules also clearly state that: + Content that is generally not well received by the community (i.e. has 0 or less karma) is to be considered **spam** and thus **forbidden**. Your content generally receives 0 or less karma, so you are a **spammer** which is forbidden according to reddit rules. Please, refrain from constantly, blatantly violating all reddit rules or otherwise you will be banned and reported to the **reddit admins**. Your conduct on reddit is **unacceptable**. Either, you become an active participant who respects the self promotion and spam rules, or you will have to leave reddit.
CompletableFuture.supplyAsync(()-&gt;syncMethodWithResult(args), executor).thenAccept((result)-&gt;doStuff(result)); is a quick example that shows off how baller it is. It has some composition/merge features I never use and CompletionStages I also never use. I'm told they are quite powerful features though. 
Where can I find info on the java memory model?
Here an advice, forget about the pointers.
Yeah, I didn't mean to say you _don't_ care about it at all, but more along the lines that it's not really a priority. I'm sure you still have wars about tabs vs spaces in the team. And props on mentioning toolchain. :) BTW keep up the good work. Maybe you could do a /r/programming AmAA about the practices and approaches? I'd be most curious although I suspect it's more of the same old boring stuff, just with more sign-offs?
Very important to remember byRef and byVal for parameters. Java passes primitives as byVal and complex objects as byRef. 
Aptech Computer Education trains you for showing up for global confirmation exams held by real IT companies like Oracle, Java, Microsoft and Red Hat. When you pass these exams, your name shows up in the database of the affirming company, along these lines building up you as a specialist in that innovation. IT businesses lean toward procuring experts with such affirmations. Additionally, ensured experts appreciate better compensations and profession prospects. 
Just watch this presentation and decide yourself :)
&gt;language uses I work on the embedded platforms, so I'm stuck on C99 and the higher level stuff there is on C++03. Nobody gets to move, like, ever. I'm hoping I can use the bug I'm chasing in a network driver as an incentive to look at Rust lol, but yeah language questions are all in the ground-software department because there's really nothing besides C/C++ that can pass ratings to fly (yes we know Ada was built specifically for this purpose, no we're still not going to use it). &gt; tabs v spaces Division standards say 2 space indent and other aesthetic standards and our tools all have format files available to enforce that. I'm a tabby myself so I just suffer silently like the good worker drone I am. &gt;toolchain This is a much bigger element of our work than many people assume at first blush lol. Especially in the embedded space we have to be *very* aware of how the entire stack -- compiler, optimizer, linker -- are going to misinterpret our intentions. It doesn't help that we target architectures that occasionally mandate proprietary compilers, plural, so there's a lot of infrastructure in place to ensure that all object files have a common ABI and that they behave mostly as expected. We use GCC as the base case, but while it has an impressive target base, we still go beyond it... &gt; practices/AMA We are audited yearly for ISO 9001 quality management practices, we have a fairly terrifying CI test and fuzz suite and chambers of hostile-environment tests, and special cases may have to be mathematically solved as well as survive the code review, test, and audit process. I'm not sure how much more I can actually say, here or in an AMA, both because (a) I'm still a relatively new hire and (b) while I'm unclassified, I'm not sure where the line between public and Sensitive But Unclassified is for a *lot* of our work. I know I'm currently tasked to NASA so legally I can't put classified info anywhere near my work, but trade secrets probably abound? Infosec is weird.
Java is way less idiosyncratic than C++. There are rules and they are consistently followed. Things are well defined. It's not that easy to completely mess up low-level stuff. Learn the standard libraries and you'll be fine.
Operator overloading itself isn't the problem. The problem is overloading operators that are already well defined for objects like == (identity equality operator). If you could overload +, or custom named operators, that would allow clearer and more elegant code in many circumstances. For example, I have a Vector class, and +, +=, etc would be nice. In the case of Java's == operator, I think there should be another overloadable operator for value equality.
I'm in favor of operator overloading but the C# example actually highlights the dangers of not placing limitations on it. Many C# programmers don't even know how to force reference equality (heck, I'd have to look it up right now but it's something like SomeSystemLibrary.ReferenceEquals).
AFAIK there's no guarantee about the behavior of `==` and strings except that if the string aren't equal it won't be equal. You are right about `intern`. If you're doing a lot of Java though, you rarely use == for objects. I would go so far as to say its use is often a sign of design problems.
You mention that these queries are type safe but they are not as I see it, they are plain strings which will be parsed during runtime, correct? I think it would be nicer if you design it as a DSL, to build these queries in type-safe but a readable way. Right now, I think most developers would prefer java.time over plain error prone strings.
Show your developers about developing services using either spring framework or better with spring boot. Boot does much automatically without your devs having to focus on wiring up the application components. It's flexible enough for overriding it's configurations and there are a lot of annotations available for use that improve code readability.
I agree, it is redundant for most use-cases. It is very niche and overkill in most scenarios. Target users are applications with dozens of date specific expressions either hard-coded or present in configuration via chains of date operations. Think about it this way, some of the expressions shown in the video, if you had to implement in code, how many lines would the more complex ones take? And if a support engineer had to figure out what was going on, how long would that take? Reading DQL is a quick operation. Date related support issues can often take hours just to spot the initial bad calculation. If you can't imagine a use case for how this would benefit you, then it would likely not benefit you. 
Xtext projects are now standard gradle projects producing standard jars as output. The Eclipse plugin provides a wizard that makes it a bit easier to start a new project, but you can do development entirely without Eclipse. The resulting parser/interpreter would be vanilla Java, without any deps to Eclipse, OSGi or so.
This is like asking why JRuby and Jython, etc aren't as popular as they deserve to be. I once had a dream that everyone would converge on the JVM as the runtime of choice and we would no longer have node.js, CPython, MRI Ruby, etc. Or that the "official" runtimes would be the JVM versions. I would love to have a universal runtime which let me switch between all of the popular modern programming languages. That would actually be awesome IMO. BUT there's a lot of Java/JVM hate out there. tl;dr a lot of folks hate Java and the JVM and actively avoid the whole ecosystem around them.
I'd do exactly as dpash suggests, it's pretty much the way we do it with the only addition of using an environment variable to indicate we want to use local profile: SPRING_PROFILES_ACTIVE=local in the service's run configuration. This way we can have an application-local.yml file pointing to localhost instead of some-service-name plus whatever other settings that may change in our local environment (e.g., not setting up SSL for kafka which we do have in PROD). It's the quickest way so far for us to do local development and testing and because you're running the current service from Intellij (or whichever IDE you use) you can set breakpoints and debug/troubleshoot with ease.
You can't really blame Java for time. Every time api/library is a horrible disgusting piece of shit. It is just the nature of what it has to do, since there are so many thousands of edge cases and annoyances. Yeah it could be better, but Time sucks. Any changes will be given in a JEP, so there is nothing we can tell you that you can't find out by reading JEPs.
Very incomplete list of choices: * _Webframeworks_: Spring Boot, JSF / Java EE / Jax-RS, Dropwizard, Vaadin, Spark, Jooby, Rapidoid, ... * _Template_: Thymeleaf, JSP, Pebble, FreeMarker, Velocity, ... * _ORM_: JPA (standard), Hibernate, Eclipse Link. I'd also check out JOOQ, not actually an ORM * _Security / Authentication_: Apache Shiro, many framework have their own like Spring Security * _Infrastructure / Others_: Maven / Gradle build, Netty, Jetty, Tomcat, IntelliJ, Eclipse, OSGi, GWT, ... 
Congratulations! Your comment used every letter in the English alphabet! To celebrate the occasion, [here's some free reddit silver!](http://i.imgur.com/l7LP33z.jpg)
[java.time was heavily influenced by Joda-Time](http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html), a open source date/time API. That's probably why it feels out of place.
We use spark, hadoop, etc. extensively for back-end services that are critical for feedback loops that drive web-served ad tech, though. There's a large overlap. 
Because having a large standard library reduces the cognitive load for developers. You have one way to do things. You don't need to learn the five different way that the different third party libraries do it. Look at logging for example. JUL was not good enough, so you had commons logging, and log4j and slf4j/logback and now log4j2. Also having a large standard library means that people will try out this crazy new language you've just released, because there's less work for you to do to implement things you need.
Hopefully in Java 10 (and sort of in Java 9) [java.net.http](http://download.java.net/java/jdk9/docs/api/java/net/http/HttpRequest.html) will replace the ancient HttpURLConnection (URLConnection in Java 7 still supports Gopher!)
They have. Look at the javax.mail stuff, or imageio.
Here is a great video from the lead a architect of Java on the potential future https://youtu.be/oGll155-vuQ Some really interesting things like value types, pattern matching switch statements and improved generics
My code is always a beautiful work of art until I start adding shims for edge cases. It might be common sense to you guys but passing a response object back up the stack reaaally helps. A consumer passed via method param of the responses run after completion has reeeally helped this though. So if anyone newish to java is reading this...always have at least an overload that can do that.
It depends. Some of javax is in the jdk, some of it is not.
The point is that jdbctemplate might use a transaction, while your JDBC will almost certainly not.
That looks super useful! I would love some associative capabilities, maybe to generate an SQL init script where it supports relations. For example generate a bunch of `User`s that are all in a `Group` but so that no user refers to a group that doesn't exist. Maybe something like: List&lt;Group&gt; groups = ... User u = mock.reflect(User.class) .field("groupId", m.from(groups).map(Group::groupId).distinct()); However generating SQL with all the dialects out there is not easy unfortunately.
In a main method, Create two houses and one school and add them all to the same array. They must have different heights. Create your own selection sort and sort the buildings by height. If you use any of Java's sorting you fail. After they are sorted, print them all out.
gave it my best
What strategy do you use to debug that?
What
If your run configuration is called "MyGoodApp", you can also do Shift Shift My Return. Fast, easy to remember, and no customization required. I use this one all the time. 
I didn't know about Podam, looks cool. But MockNeat is not about "auto-filling", rather it's about filling the gaps with data that can pass as real. For example, you can generate valid [`creditCards()`](https://github.com/nomemory/mockneat/wiki/MockNeat#creditcards) and not only numbers, or you can generate [`names()`](https://github.com/nomemory/mockneat/wiki/MockNeat#names) and not only fixed-sized strings. The other aspect is that Podam looks very declarative, making use of annotations, but not everybody is comfortable with annotating their model classes. In the end both libraries mock data, but their ways are different. 
There is already a short cut for Scala console, though I use Netbeans keybindings, so I don't know what the default is. 
I've been following your library for a while, happy it's now in a public repository :) I'd like to see it generating object graphs, so if your Employee class has references to a list of (say) Absence objects then it would randomly create a number of entries in the list etc. A bit like benas Random-Beans. 
Should be named MockNeato.
Thanks for following the library. I know what you are saying. To be honest this is a feature i am thinking to implement very soon. Basically i will add some "defaults" so the developer don't need to specify everytime what it really wants there. Sometimes it doesn't matter what string you have there as long as it is a string. It will be more tricky to that for collections of objects for examole, but it's doable. Another step forward is to create the possibility to do snapshots on the generated objects and persist them on the disk. Those snapshots can then be re-used for unit-testing, having the advantage that you always use the same data. This again will be tricky.
Useless. There are Oracle's [Official Code Guidelines for the Java Programming Language](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) and [Google Java Style](https://google.github.io/styleguide/javaguide.html) which both are far more in depth and precise.
If you have only one configuration - no need in this at all. This plugin for projects with many Run/Debug configurations.
If you're using Eclipse these compiler lint bits are also available inside the IDE. You can configure them to produce warning, errors or nothing on a case-by-case basis, the results being shown right in the text editor. They're really powerful and helpful - from noticing a typo of = when you wanted to use == to analyzing branching code flows automatically and predicting null pointers. http://help.eclipse.org/kepler/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fcompiler%2Fref-preferences-errors-warnings.htm
Yes absolutely!
Please read Reddit's rules for spam - at the moment you've done nothing but link to one site, so you're a long way off what's considered an acceptable level of self-promotion. Given the comments on your other posts too maybe you should actually write decent content before attempting to link to it...
If you can write modules, so they can be transparently converted to microservices without API B.C. breaks, then by all means go for modules. This, however requires: - You should keep the API surface extremely narrow. No willy-nilly instantiating module classes, but have a single entry "module class" which provides a small set of "API endpoint" objects. All interaction happens through those endpoints. - Everything that goes into and out of an endpoint should be simple DTOs that can be serialized on the wire, and result in a small payload (so you can't pass around large indirect state). - Every call into an endpoint should have a standard way to bail out on transport errors (network failure, timeouts, remote service is down etc.), so when a module is converted into a service and one of those failures occurs, the clients using the module are expecting this kind of errors. - Ideally the endpoints are entirely async, i.e. the result is delivered via promises or via callbacks. Synchronous endpoints means you'll have poorly performing applications once the underlying logic becomes network bound. If you can follow strictly the above, go modules. The reason why some people prefer to bite the bullet and go microservices is because in real teams following those conventions is very hard. People will take all kinds of shortcuts that will make modules coupled together, or impossible to rewrite as services, which means you're stuck with a good old spaghetti monolith.
Did any of the posts that you read mention why it was better to use a 3rd party? In any case, if you have code that works, just use it -- but, be sure to store the token securely. https://developer.android.com/training/articles/keystore.html
Second this approach, specifically using native Android functions. If you need to target less than API 18, consider Authenticator. There's a lot of boilerplate, and it's a hassle to interact with, but it also covers most of the bases for you. https://developer.android.com/reference/java/net/Authenticator.html
&gt; What I do in my work is doing "microservice-ready" modules, and then I decouple some of the modules to services over time, when they need to scale, or be rewritten in another better language for the problem etc. I 100% agree with this approach especially with smaller teams. It lets you skip some of the network error handling, distributed logging and monitoring. It still lets you add it easily in the future though when you do need larger scale or have a larger team. I often think going microservice first is a bad approach unless you have a good reason to. &gt; This is why microservices is easier, because it forces everyone to understand. I might disagree with this a little. There are always people who refuse to learn how things are working behind the scenes. A good example would be a module that fetched N users from the database with SQL vs a HTTP client calling a micro service to fetch N users. Even if both offer a bulk fetch by ids some developers just default to a for loop fetching them one by one adding tons of network overhead. Ideally this is where code review comes in. I do think I agree that the networking overhead of microservices can point out issues faster but I don't know if I would consider that a benefit.
I think you should learn spring hibernate jsf ( primeraces ).then you should know most used design patterns 
I am quite used to design patterns with php, even though for every java developer it is like a joke of a language I have been working with some great developers, using really nice and neat codebases. 
Something that I found weird is that there are 3 build tools maven, gradle and ant, but the three of them use maven repo as package repository? Is that correct? What is the difference between them and which one is "the one" to use. I am using maven on my small projects and I can't see a reason to move to something else 
/r/learnjava /r/learnprogramming 
Are you doing your own flavor of OAuth?
There are competing frameworks and all are working good. There is spring and there is javaEE. The two are very similar but in some kind different. If you want full stack options look at spring and javaEE. JavaEE also is implemented in different frameworks. JBoss is one of them. So spring gives you a real framework that you can use. JavaEE is just a standard that can be implemented and oracle will verify it. That said there are a handful of javaEE servers and frameworks. Just use one of them. And yes you need a applet server. But for microservices you can use an embedded one. 
https://www.reddit.com/r/java/comments/61a2af/looking_for_an_overview_of_all_the_java/ post still on the front page of the subreddit..this might help you.
You fucked up, yo. You don't have enough time to retain and implement these practices into a functional program. That being said, I would use TeamTreehouse and Oracle's Java: A Beginners Guide.
I'm using Xtext in Eclipse and, apparently, it's a Maven-only project.
&gt; For example, I have a Vector class, and +, +=, etc would be nice. How? Does it add it to the end? Does it add it to each element in the list? Does it add each element to the other element at the same index? == is the one I'd like to see overloaded, anything else and I definitely think it turns into a mess. Operator overloading doesn't let you do anything new - you can do the exact same thing right now with a function, which has a name that tells you what the op is doing.
It works as + normally does in numeric types, with the same precedence. This doesn't need to be complicated. == is already well defined for object types. You're overloading the identity equality operator. That's not good. Introduce a value equality operator like :== or something, whatever, as long as it's distinct. "Doesn't do anything new", yes it does. It lets you express things without repeated function composition which can lead to ugly, verbose code.
Author here. Thought it might be nice for this r/java sub-reddit to expand a bit on the upcoming Java module system. Java 9 adds a new module system where module descriptors are introduced to explicitly demarcate the public API of a module, and to express its dependencies on other modules. Example of a module descriptor: module mymodule { exports mymodule.pkga; exports mymodule.pkgb; requires someothermodule; } What happens is that every package except the ones exported are inaccessible to other modules. Non-exported packages are encapsulated, not even reflection can break through that barrier. The requires statements are used by the Java compiler and runtime to verify whether the current configuration of modules resolves correctly. Obviously there's lots of more detail to go into. Of course I recommend you check out my upcoming book (early release available) for that: http://shop.oreilly.com/product/0636920049494.do In short, Java makes a great step forward wrt. modularity. When regular JARs transition to modular JARs (by adding a module descriptor), many more checks and balances are in place than are currently possible with the classpath.
Spring is the de facto web (plus a LOT of other stuff) framework. To be able to use it you should also make sure you understand either Maven or Gradle well enough. Start by creating a simple [web application using Spring Boot](https://spring.io/guides/gs/serving-web-content/). In most Java projects I've been in (I work as a consultant so tend to switch every year or so) the most common components encountered are: * Build tool (Maven/Gradle) * Dependency Injection Framework (Spring, Guice, CDI) * Test runner (JUnit) * Mocking library (Mockito) * Logging library (Slf4j, Log4j) * MVC Framework (Spring) When interfacing with relational databases (not something relevant to every project but common enough to mention) I'd suggest going for Spring Data JPA. All the other frameworks / libraries tend to differ quite a bit more from project to project. The ones above I encounter in almost all of them. 
http://mooc.fi/courses/2013/programming-part-1/ Also read the sidebar. Questions like these should go into /r/javahelp or /r/learnjava. 
It is nice to see that I made a good choice by myself, every tool you just listed is something I have been looking into lately. 
I am as well looking into desktop applications development, just for fun and I found Javafx amazingly easy to use. Is there any other framework I should have a look at, if I want to see something else apart from server side applications development? 
Speaking of tools, I am using jetbrain phpstorm and so my natural choice of ide was intellij, which I found myself familiar with and really fast to work with. A lot of people out there use eclipse, which I find really slow and convoluted to use. Is there a particular reason that makes eclipse better than intellij or is just a matter of personal preference related to being used to the ide? 
Can you explain exactly why you want to do all this inside docker containers? What exactly do you gain from this? For local development I run database (and similar) services inside docker (much move convenient to use a single docker run command over system-wide installations) but I personally would not run the application inside docker. It's much faster to just run it from the IDE and most 'running' is done through JUNit anyway. 
If you want feedback: I don't want to write test scenario's in JSON, sorry. I am not ever going to hand-write (or even edit autogenerated) JSON. Also if you want people to use your library it needs to have strong benefits over other ways to do stuff. For example can you explain why your approach is better than Spring MockMvc (which we use for controller unit tests and integration tests)?
Reddit is **not a self promotion platform**. The reddit rules **explicitly** allow **one** self promotion (i.e. link to your blog) in every **ten** contributions. That means that **nine** contributions must bear no reference to your blog/content. You have **massively** exaggerated that limit. The reddit **spam** rules also clearly state that: + Content that is generally not well received by the community (i.e. has 0 or less karma) is to be considered **spam** and thus **forbidden**. Please, refrain from constantly, blatantly violating all reddit rules or otherwise you will be banned and reported to the **reddit admins**. Your conduct on reddit is **unacceptable**. Either, you become an active participant who respects the self promotion and spam rules, or you will have to leave reddit.
&gt; There is no need to "edit" the JSON, it´s optional. Then how do you know what values I need to expect in an integration test? &gt; With MockMvc, seems like it only "tests" that the endpoint returns 200 code (I already check that for each call to the endpoint, here) and returns data. But where do you check that the provided data and the persisted one matches ? I really don't get where you get that impression. You can use (for example) use JSONPath to see if the JSON matches. You can also use hamcrest matchers there: .andExpect(status().isOk()) .andExpect(jsonPath("$", hasSize(1))) .andExpect(jsonPath("$[0].type", is(CURRENT_FOO))) .andExpect(jsonPath("$[0].foo", hasSize(2))) .andExpect(jsonPath("$[0].foo[?(@.id=='" + FOO_ID_1 + "')]", hasSize(1))) .andExpect(jsonPath("$[0].foo[?(@.id=='" + FOO_ID_2 + "')]", hasSize(1))) .andExpect(jsonPath("$[0].totals", hasSize(1))) .andExpect(jsonPath("$[0].totals[0].total", is(2 * BAR.doubleValue())));
I wonder if IntelliJ IDEA supports such reordering.
I understand. However I wouldn't use this approach, at the end I'm trying to get rid of writing the comparison, still you have to provide the data somehow, either you fetch it from your DB or having a mocked class.
Also, the visibility gets more complicated when you start nesting classes (which is something you can do in Java). For example the compiler will let an outer class access private members of an inner class. Whether you define the nested class to be `static` also affects things, for example a static nested class can't access instance-specific values or generic type parameters of the outer class because it only has access to static things. This may sound like esoterica, but this stuff comes up all the time if/when you start making little struct-like classes that are used entirely within a larger class. Where it can get messy is that I think the runtime doesn't actually support the concept of nested classes, so what the compiler does is turn the nested classes into regular classes and then since they wouldn't normally be able to access each others' private content at that point it generates accessor methods to expose them. For example if an outer class Foo directly references a private field baz in an instance of an inner class Bar, the compiler adds package-scope setter/getter methods to Bar for baz and then turns the accesses into method calls. If this is in a hot path, you can start getting these weird method names showing up in profiling. The "pmd" analyzer has a couple rules that can detect cases where the compiler will insert accessor methods.
&gt; So how do you test something that changes every test; like for example the current date? You can't hard-code those. Hmm, for Dates is not implemented yet but knowing that the field created_at is a Date I would just initialize it every time via reflection. &gt; Exactly. So I am comparing the output in the JSON to whatever I mocked or inserted into the DB. How do you do that with these 'fixed' JSON scenario's? Based on the JSON file initializes the POJO (checks which are the declared keys and initializes the matched field's names). Using the initialized POJO I first persist it, then checks if matches with the one fetched throw the enpoint. Since each test is independent and I need an ID for fetching it, I do persist the entity for each test. For instance: @Test public void create() { UserDTO entity = (UserDTO) getData(PUT); Assert.assertNotNull(entity); UserDTO fetchedEntity = (UserDTO) getClient().put(entity); Assert.assertNotNull(fetchedEntity); Assert.assertEquals(entity, fetchedEntity); } Where: * getData(PUT); maps from JSON to the DTO * getClient().put(entity); checks that the status was 200 
Ctrl+shift+up/down while the cursor is at a method will shift the whole method up or down.
But it is all very simple, you create your own objects -&gt; you create functions how to compare them (if you need that at all). All standard data types already have it impemented. You also can do comparison via function instead of operator overloading in c++, too. All in all, there is nothing to hate, only yourself for creating useless objects and then needing to compare them.
Hm, I do the exact opposite. I order direct helper methods directly above their associated method. It's almost as if the method is a part of the "header" of that second method.
i use google all the time i rely on my IDE for syntax correction worry about the logic and optimizations and not something as trivial as syntax 
10 years professional experience here, I have zero problems with syntax except for the Java 8 stuff. That said, I'm googling constantly for solutions on how to do things, it's necessary to my job that I don't spin my wheels, though that still happens. The beautiful thing about Java is that when it comes to line-by-line development, everything has been done before. It's either in the standard libraries, Apache commons, or someone has coded up an optimal solution on Stack Overflow. The hard part is pulling it all together into a readable, maintainable solution that if my coworkers need to dig into, they won't yell at me later for coming up with something convoluted (or I won't hate myself if I see it a few months later).
\m/ Thank you so much! This is EXACTLY what I needed. 
Just wondering. Why wouldn't I want to use it? 
/r/Javahelp ? 
Direct links to documentation and sample project: - http://jooby.org/doc/lang-kotlin - https://github.com/jooby-project/kotlin-starter
Can we get a mod in here to delete this whole thread; it's clearly irrelevant as some random bloke on the internet is already aware of these blogs.
Awesome! Does Jooby's swagger documentation work with Kotlin?
"new"
he never said it was a bad article, just that he reads those blogs :(
https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf
I'm not sure the the article is talking about the same thing, or that I agree with it. For example the article says things are autocommited, but that's not inherently the case. I've seen a similar pattern used on the job with spring, and it worked well to make sure every developer wrote code inside a transaction that was opened and closed correctly. 
There are a couple reasons. The most important to me (and my main goal) would be to have a uniform setup. I explain: if all your dependencies are inside Docker and your app container is there as well, and you are using something like Docker Compose or Kubernetes (minikube) to orchestrate containers, then you are going to use the same 'configuration' (as in, locations of the other services) as you're using in production. So, no need to even install anything, just run 'docker-compose up' and you're good to go, no matter if you need one or ten additional dependencies. This may not sound like much if your only external dependency is a database, but it starts getting complicated if you also depend on, say, NoSQL, Redis and Kafka. If you have external services of your own, or if you are on a full-blown microservice architecture, it can become a real problem. If you decide to manually spin up dependencies, though, you will need a separate app configuration to point at the local ports of different services, and you also _may_ run into port forwarding issues depending on where you are running Docker on. For example, Docker for Mac is limited in the kinds of port forwarding it can do. Docker Machine (using VirtualBox provider) works better, but there's the additional step of getting the machine IP and hope it does not change, etc.
I don't get it, why those downvotes?
The only thing I memorize is which libraries are good for what, and in which project I solved a particular problem already. Everything else is google, stack overflow and auto-complete in the IDE. That being said, you should know java *syntax* well enough to operate without having to look it up, but that mostly comes through practice / experience.
Netbeans or IntelliJ Community, depending on which project I'm working on. If the project produces a fat jar (dropwizard etc) I'll restart the container. If the project is going to be deployed into an app server, it's normally enough to just build as usual and the app server (running in the container) automatically picks it up and deploys it. I always use maven for builds. 
&gt; This may not sound like much if your only external dependency is a database, but it starts getting complicated if you also depend on, say, NoSQL, Redis and Kafka. If you have external services of your own, or if you are on a full-blown microservice architecture, it can become a real problem. As someone working on a full blown Java microservice architecture: I really don't see it as that much of a problem. If a single service has that many dependencies you might have architectural problems. 
Fair enough, I may be overthinking this. I guess I'll try the 'app ouside Docker' approach. I may have been 'traumatized' by connectivity issues between things in/out of Docker in the past, that's why I may be reluctant to just map the services manually. Do you use anything to orchestrate your dependencies in dev (Docker Compose or minikube)? Or just manually 'docker run' each dependency individually?
That's a good question. I use this as a rule of thumb and I'm generally leaning towards accepting sites. The other rules are relatively hard to follow so if they are followed, then the site is worth having a look. Cheers, Eugen
For core Java classes I code from memory maybe around 75%~80%. Frameworks &amp; open source library maybe 50% of the time I google. 
I used to sort my method like that. I've got to say these days I tend to navigate through the hierarchy view in IntelliJ, keyboard short cuts to jump to an implementation etc. rather than scrolling up and down the source file. May be that's because I'm working on a fat legacy app that has huge unwieldy classes.
10 years experience here. I don't Google for anything commonly used in Java like any reserved keywords or stuff in the standard libraries like the various collections or other java.util.* classes. If anything I will first peek at the actual API for something I haven't seen in awhile. (I think I reviewed the Deque interface this way somewhat recently.) I will Google for other random stuff throughout the day though, related to Spring, Apache, and various other libraries and frameworks used throughout the codebases I touch.
Is your application a game? If you are using `Node` and its subclasses in the scene graph, then there isn't much you _can_ do. If you don't rely on JavaFX controls as much, you could use `GraphicsContext` along with `Canvas` to reduce the effect on memory, as well as gain performance. Depending on what your use case is you might want to go lower level and use C++ to have more control over your memory usage.
Looks like it does and since v12 https://blog.jetbrains.com/idea/2012/10/arrange-your-code-automatically-with-intellij-idea-12/
The language and syntax will be very similar, possibly exactly the same. What you will be doing will probably be radically different. You could try a beginner to java guide but you might feel like its useless. I would suggest making a web app. make something simple and keep adding to it