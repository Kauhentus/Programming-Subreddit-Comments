How can it all be in main()? Goto statements? That's horrifying. 
These days when we look to hire someone, we don't ask them to explain a technology on their resume. That leads too often to a recitation of a book they read or even a wikipedia article. Not very instructive. So, now we ask them to tell us what they DON'T like about a particular technology. That knowledge only comes from extensive experience. Be ready for that question.
I've been coding professionally for 18 years. Probably almost 30 if you include non-professionally. The length of time it takes me to cringe at my code is getting longer, but it's still only up to about 18 months.
x++; // increment x Yes, I really saw this in someone's code. Also, a lack of meaningful variable names. All in-line code in main. Try/catch? What's that? 
And.. let me guess. That Object had a .value member that could have a null, right? lol...
What part of nullability is handled at compile time? I really have no idea what you mean by that.
But... my bike is SPECIAL I tell you! That stupid nuclear power plant can just wait!
Is this a good thing? 
Well, it's unidiomatic for starters. It's also not really a good example - there's no null traversal through chained higher order functions. As discussed, `get()` switches off null safety, so this is a little like saying that static-typing-with-casts is just like dynamic typing. True, but missing the point.
Are you a programmer familiar with other languages or is Java your first? If you don't know others maybe you want to start with a language with more immediate feedback and more forgiving of mistakes. JavaScript and Python come to mind. The general concepts are going to transfer once you have the hang of any of them.
LOL! That made me laugh. The reality is worse, actually. It actually couldn't return `null` because of that static analysis tool. So the `set()` method had a check to avoid being passed a `null`. It threw some kind of exception. Instead, the `value` just defaulted to an instance of an object called `NullObject`. :P They literally made their own object to represent `null`, and the `hasValue` method did a type check. Insanity. Pure insanity. :P Paid well though...
Haha I understand that there is no such thing as perfect code. When I cringe it's usually because I wrote alot of code when there was a simple method that could do the job better and faster. Or because I did something like using an array where an arraylist would have made life much easier. 
I bought a copy of the Java textbook "Java: How To Program" and I went to work on Saturdays and used my work computer to type in every line of code I read and then I did every single program assignment at the end of the chapters. After a year, I was pretty expert. Go on Amazon and you will see that a not-current-edition version of this book can be bought for cheap. 
that's impressive, I'm still working my way up to 5 mins
You give them documentation that describes 10 steps to set something up. Steps 1-3 don't contain copy/paste-able commands, so they don't even read steps 1-3. They start with step 4 and wonder why nothing is working.
Would you mind sharing some insight on that balance?
&gt; That's horrifying. You're telling me! :D Yes. Goto is used and abused in that thing. It's similar to how they program in RPG. They have a concept of subroutines, which are defined in the same file with the rest of the code that looks and works exactly like goto. So, she naturally replicated this same structure. I tried to explain to her the idea of a method, and how that would also mimic the way they define subroutines in RPG, but this is also a person who needed to ask for help on how to delete a "record" from a .csv file with Notepad++. Suffice it to say, she has a very, very specialized skillset. :)
Elvis for elvis sake: "K".equals(foo) ? true : false; He's been programming for 7 years.
If Oracle will stop contributing to NetBeans, there will be the risk that no other company or independent developer will move it forward. Oracle already has an IDE called [JDeveloper](http://www.oracle.com/technetwork/developer-tools/jdev/overview/index.html), but NetBeans is way better. So this could be a bad thing, but there are other great IDEs out there, like IntelliJ and Eclipse. (And, of course, Emacs)
Annnd you just described my manager.
I totally forgot the `null` test for my interview today. Dangit. 
My professor encourages a lot of abstraction. He wants the main as clean as possible (usually just init and run methods), with everything else taking place in methods. I agree with this to a point, I think he overdoes it with the abstraction. If the code isn't reusable I don't like to put it in a method, it seems inefficient and unnecessarily complicated.
I'll remember that, thanks!
It is the observer pattern loaded with utility so... pretty much one in the same. 
I get what you mean about that comment, it's very unnecessary. However I can't really complain, I tend to create my classes and methods first, then fill them with comments outlining what needs to be done, which is how I get comments like that. I think meaningful variable names is my weakest area. I hate long name, so I tend to acronym everything
I mean, there is only eclipse really, if you're looking for RCP, aside from netbeans. Or bake your own... Isnt' JDeveloper really bad?
Ohhhh I need to work on the comment one. I usually describe rather than explain.
Some my tips to avoid null pointers, which complements tips given in this article: http://javarevisited.blogspot.sg/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html
I'm guilty of this one and it's a habit I'm trying to break. Any tips to get past it?
Null is part of the semantics of the language. You aren't forced to handle the null any more than you are forced to handle the optional. They provide equal protections.
I tend to lean towards your professor here, though perhaps not to the same extent. I haven't quite found a way to explain why to someone who doesn't already get it though. To try anyway: it makes things easy to understand. If one large procedural block of code gets too long, it's hard to understand. You have to know that this 30 lines is doing operation x, that fifteen is storing the information to disk, and that last 40 or so are doing some other operation. It's a lot easier to understand the flow of your application when it's broken up by operation like that and you don't have to read more than the method name to understand what it's doing. Have you ever written a comment at the start of a section of code to explain what that bit is doing? Why not break it out into a well named method or function so that comment is no longer necessary? 
Lots of good answers. Here's one I didn't see yet: poor understanding of logging. - logging too much useless info - logging at the wrong level - not logging something critical (e.g. silently eating error) - not wanting to log at all (someone tried to argue to me that it was a useless waste of resources recently) - not looking at the log when something fails and instead flipping out and randomly changing things
That's what I try to do. I don't think I was clear enough in my earlier comment. I break down each program into its component parts, essentially delegating each operation to a method. Then, I look through all of them and try to minimize repeated code by making reusable methods.
It's all about finding the right balance between code complexity, robustness, performance, and time. (though I agree with your professor regarding logic being in methods as there are a lot of benefits regarding testing and future flexibility) For example, you could spend a day or two writing the optimal data structure for a certain part of the code but is it an action the user will execute often? When the user executes the action, is the improvement even noticeable? How much time did it take to code the data structure? Could you have spent that time adding a feature or a bug fix that would have had a greater effect or noticeable reward? How much time will be spent maintaining this additional code? Is all this worth the cost rather than just using one of the implementations already in the JVM? The answer varies depending on a lot of factors but a lot of devs strive for perfect when good is good enough.
The most honest (and not at all helpful) answer is experience. But outside of that, stopping every couple of hours and asking yourself if the time you're spending on something is ultimately worth it. Regular conversation with your teammates is a great way to facilitate this. Code reviews, pair programming, or just a "hey, can you take a second and look at this and tell me what you think?" **Edit:** Another good way to break this habit is writing unit tests. Unit testing is rarely fun but if you make a habit of writing good, functional unit tests, you will very quickly learn how to write simple yet extensible code.
The point is, you are forced to code to the possibility that there may be no value there. And your example and comparison of styles is somewhat contrived: any competent Java 8 programmer will be able to forgo the use of `get()` almost entirely, with things like `map()`, `orElseThrow()`, `ifPresent()`, etc.
Lol yesterday i found this in my code... If (sql==true){ return true; } else { return false; } facepalm 
Bingo. Brian Goetz (one of the main designers of the Java 8 functional APIs) has admitted that even including `get()` in the API was a mistake.
Wow, I fit way too many of those, need to up my game
my favorite: catch(Throwable th) { }
&gt;You aren't forced to handle the null any more than you are forced to handle the optional. You are forced to handle the Optional, excluding the backdoor afforded by `get()`. This is identical to how static typing in Java works in general, except there casting provides the back door. If you don't handle the Optional, your code will literally not compile. But there's nothing you can do that will catch issues with null values at compile time, since the type system enforces nothing around null values. I think this is pretty straightforward. At least, I can't think of any objections that don't amount to "static typing is exactly the same as dynamic typing because casting exists" - which was my original point.
Put yourself in the position that you need to maintain the code you wrote. After a while, simple and plain will seem sexy.
You miss the point. When you use Optional (and you are consistent/disciplined) everything that's not Optional is not null. If I call a method that returns a Foo, I've got a Foo, and I don't need to check that I got null. Of course, you need to be aware of what you are calling. There's plenty of 3rd party libraries that returns null. You should probably be wrapping those to reduce your dependence anyway, but definitely wrap them to return Optional so you only need to deal with Null on the boundaries of your code.
&gt;Gets offended during code review. The rest of these are forgivable. This one is what sinks you.
Reminds me of AppleSoft BASIC GoSub
Nothing is wrong with being an inexperienced programmer, signs of that are not bad. Traits I am concerned with in new programmers include overconfidence (along with resistance to constructive criticism) and inability to problem solve without direction.
Comments that explain what something does. You code should be easy enough to read that descriptive comments are not needed. Comments are nice if you had ton do a work around, bend something to your will, or hard coding a value is for some reason necessary. But saying "# begin loop" before a loop makes me want to unplug your computer.
you know sometimes after a long coding session your brain just crashes and goes into auto pilot and you just forget about condense-able options.
Well your first comment says you don't like putting code that isn't repeated into a method, and your second comment says you do. I would perhaps give your prof more credit. 
i will still sometimes write code that way because I'm planning (or just removed) debug/logging info in the code blocks.
That's exactly the thing that is great to see in your projects. You used arrays coz those were the tools you learnt and no doubt learnt some things to stretch their usefulness beyond comfort. If you were using the better (and much bigger) collections early on, you wouldn't appreciate or understand their importance and how they work under the covers. This is why you got a formal education in engineering, to learn how everything works as opposed to just how to get the job done in it's most basic form. Anyway, great anecdote and kudos on your accomplishments thus far. 
About a week ago, I had to migrate/review/patch some code I wrote from 2002. I actually had some pride in areas of it which were still understandable, and relatively clean, from 15 years earlier, and yet I also had cringey flashbacks to specific corner-cutting I'd done come back to bite me. It was weird - I was remembering the room I was in, the time of day, smell of the room, etc, when some of the specific code blocks were being written - almost like stepping back in - way back - in time. (15 years!) :)
&gt; Forgetting to test for null Defensive programming is also not great idea.
&gt; Forgetting to test for null. You should be using optionals in this day and age.
1. Starts writing code before understanding the problem 2. Thinks every problem should be solved with whatever language he prefers using 3. Treats general programming guidelines as cardinal laws
That's amazing! I was once asked to make a small change to some code. I looked into it and told the customer, "this is great code, whoever wrote this for you knew what they were doing!" ... it was my code. I'd written it less than a year earlier. I had no memory of writing it at all. So I'm a little jealous! But I mean, at least it was good code?
* Wanting to rewrite everything as a *default* to every problem. * Massive methods. (ie: 2000+ LOC). Not refactoring out to smaller methods. * Avoiding SME's, not utilising BA's * Premature optimization. * Understand that problem-solving does not equate to downloading a new framework/lib. * Thinking that completing various java certifications means you can craft software well. * Teamwork. Fixating on who did what rather than understanding why. * And my personal favourite.. using 20 pairs of opens &amp; closes in the one method. O_o 
Not sure if I understand Liquibase (or Flyway) correctly: Do I have to create the initial DDL and changes manually? How would a workflow using an Entitiy-First approach look like, where Hibernate creates the DDL? Couldn't the changes in my Entites not be discovered automatically? Or are they? Or do you guys use the Entity-First approach strictly in dev and Liquibase kicks in for production?
I bought a Dummies book, worked through it, and then made a few simple programs myself.
there's nothing upfront about NPE, cause if you're not careful the null can leak. If the lack of data to persist is a problem, the user should be using orElseThrow, as I mentioned before. That allows you to fail loudly. 
More likely just `if (sql)` though, no?
I put that in about once in every project (that's intended for production and doesn't have inversion of control, as in Jetty) for last-ditch logging before letting the process die.
No, wrong.
Assuming they've gotta do it alone.
isPresent()/get() is wholly replaceable by orElse(default). Or any other number of methods on optional. isPresent() and get() are like training wheels for people not used to optional yet, and get() itself is particularly dangerous and really should be avoided as there are safer ways to do it in every occasion.
You just provided the best practice list from my company. FML. 
God damn, another one. Our super senior tech dude who flies continent to continent to train people on best practices wrote his own rest and testing APIs (tried and failed to re-write spring contracts as well) and insists we copy-paste. There's literally a library that he provided which the documentation says: Copy the following class to your project in order to use this library. The class is a static single method utility class which could've just been in the fucking library. In our company, we've somehow banned writing internal libraries unless he writes them. 
I haven't had a ton of trouble finding memory pressure issues using visualvm you realize it's got a memory sampler/profiler right?
I know what you mean about writing the story in comments and then fleshing out with code between the comments, but in this case "increment x" was one of very, very few comments throughout several classes written by the programmer in question. Acronyms are fine, as in DataInputStream dis or BufferedImage bi. But variables called a, b, c, etc. has noob written all over it.
It seems like the sign of an experienced programmer is zero comments.
* Not using Google to find answers. However unique you think your project/issue is, someone else has done it and solved it already.
You may be best off searching this subreddit to see the previous answers, I don't think much has changed in the landscape. Basically: it comes down to preference. Anecdotally most of my Java friends prefer Intellij (all of us used eclipse at one point and love what it has done for the ecosystem). In many cases, it's best to use what many around you at work use too mitigate differences in how they can help (otherwise it's often up to you to translate over).
When I review code, I don't care how people write their code. I only care about 4 things. If there is a problem with any of these 4 things, then you need to refactor. * 1. Did you solve the problem? Critical thinking and using the right algorithm. See point 4 * 2. Did you add unnecessary technical debt? This is an entire college course if you ask me. * 3. Can I read it without documentation? a healthy dose of abstraction and separation of concerns * 4. Is it cpu/memory efficient? See point 1 If you can solve for these 4 things then I cannot care less if you have have a mile long Constructor that does all the work. But we all know that if you follow these 4 things, then you won't have a mile long constructor. :) 
If you already use and like Eclipse, you should stick with it. It's that simple. Java IDE choice is kind of a religious war for a lot of people. I've used all 3 (Eclipse, IntelliJ and NetBeans) and prefer to use NetBeans for my work at home. The other two are very capable but seem more suited for team projects.
Jesus christ 1.6? I weep for you.
This one annoys me. Sometimes i feel like dick when i literally read (or type) what the error message says. Just the other day something about array length mismatch in a method i wrote. I said 'ok you have one array with 10 slots and you are trying to assign 11 values in there. Did you look at these two arrays to diagnose the length mismatch and read the source? Person: no Me: facepalm
IntelliJ is a fucking catastrophe. Eclipse is working towards that goal, but is not there yet.
A big one I've seen a lot is not really code related, but process oriented. The more skilled you are, the better able you are to chunk out your work into meaningful and logical sections. An inexperienced person is more likely to want to write an entire slice of a feature, for instance, while the more experienced person can say, "first I'll do this part, test it, and commit. Then I'll do this part..." And so on. It's really hard at first to know where the seams are. I've also noticed a tendency to make larger commits with more time between them, but this might be a symptom of the same problem.
Class variable access modifiers are optional...
It's not quite the IDE solution you're looking for, but the `@HotSpotIntrinsicCandidate` annotation helps with maintainability. It used to be quite confusing to be developing Java code and have certain methods silently replaced with intrinsics. Modifying the Java code would have no effect! This annotation was introduced in JDK 9. When placed on a Java method, it serves as a warning to developers that the code might be replaced with intrinsic code. Also, it enables error checking; an intrinsic won't replace Java code unless that code has the annotation. http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/65464a307408/src/java.base/share/classes/jdk/internal/HotSpotIntrinsicCandidate.java
I'd just bite the bullet on names over acronyms and force yourself to get used to it. As for comments, I find it helpful to outline a complicated process via creating empty methods that are well named. So I get the high level process including parameters and output types at the same time as I'm working something out. It doesn't always stay that way, but it helps me organize my thoughts until I have my path forward.
Yeah, this is the fast track to losing the respect of your peers.
An experienced programmer does not have zero comments. An experienced programmer only puts comments where it is necessary: When the code needs a "why." Good code should be clean, easy to read, and easy to follow. Just because you can follow WHAT, however, doesn't mean you can follow WHY.
I still do spaghetti code at times but in Android sometimes it just makes things easier. Not the right thing to do but sure is faster.
True. I've got nearly 25 years in the field plus more than 10 years of programming beyond that, so I'm "experienced" I'd say, and I for one am less concerned with whether a method is too long/not abstracted enough and more about how well-organized what's there is. Sure, a 1k line method is PROBABLY not good by any measure, but if you give me, say, 500 lines, and it's well written (pretty much everything else in that list AND commented well AND broken up into logical steps demarcated by said comments and spacing) then in my experience that's not at all bad. In fact, in some ways I argue it's better because now I don't need to jump out to other methods to understand what's going on, I can just follow the bouncing ball through the single method. There's absolutely a balance that has to be struck, but it's not an either-or thing in my opinion, whatever current "best practices" want to claim.
Eclipse ist pain in the ass compared to intelliJ. It feels much more mature of offered Feature, smooth Integration of many plugins and usability. 
Just buy the book; don't rob the authors!
Your thesis is almost *unprovable* as it says Give me a function of 500 well written lines... Very unlikely that this is going to happen ever in this universe 😂 Imho the guidelines of line count maximums are just a shortcut that can be derived implicitly from other, more substantial advices. For example separation of concern, single responsibility, not to mix up levels of abstractions and so on. Those are imho very reasonable and reflect methodologies that are used all around in other professions or domains as well (contracts, scientific articles, complex machines like cars, cookbooks, ...) If you follow these guidelines you will hardly arrive at situations where 500 LoC are the best solution you can come up with 😉
'Not Invented Here' syndrome. As a consultant, I see this a lot. It's a very dangerous habit to allow an organisation to get into. * Who supports the custom library for other users? Is it documented, or are the FAQs passed down in an ancient tome covered in dust, and almost entirely unreadable? * What is the cost (in terms of time and money) of managing, maintaining, releasing, documenting, testing and QA-ing the custom code? If the answer is 'nothing' then I find the respondent to either be lying, ignorant, or 100% useless for tasks that provide actual business value. * The custom library probably has dependencies on well understood, and widely used components (Apache Commons are a classic). I usually try and hammer the point home by asking how far down the rabbit hole are people going to go. I mean, if you're a NIH purest, you probably want to go and rewrite that whole Tomcat container, right...?
Generics came in 5.
Reminds me of a developer we had once. She got mad at on of our testers, because he found bugs in her implementation and gave her back the task because it didn't work properly. A few days later she complained to our boss that it is impossible to work with him because he is such an "unpleasant person". 
Care to explain in what ways its a catastrophe? 
As someone coming from other languages, what's wrong with static methods? Seems like they would tend to make code more likely to be pure, and thus easily testable, since you can't rely on instance state.
I have to disagree. It used to be, but these days you rarely find anyone preferring Eclipse over IntelliJ.
I was making my own implementation of an optional type in C# and was trying to make the method name for the equivalent of get be the shit emoji so that a) it would be more difficult to use and b) it would be the best expression of what the method is. Couldn't get it to work, though.
Having my co-workers review my code.
I agree with this 100%. I teach all the new hires at my company using my company's IDE( Eclipse with some custom plugins) and almost all of them end up switching to IntelliJ .
I've been offended by code reviews but only because I saw dumb shit like hardcoded jks passwords in the reviewer's code. He would always have to find something to say about it.
&gt; I'm graduating next semester and I'm going back through past code projects and cringing. I started thinking about my current code and I was wondering if I'm still coding like a novice. You are. And whenever you look back a year or so at your code you see things that you now would do 'better'. Learning is a constant process that never stops. Or it does and you're a Java developer with 10x1 years of experience in a decade. 
A mid dev can solve a complex problem in a complex way. An experienced developer solves a complex problem in a simple way.
Static typing is significantly less useful than it ought to be, because casting exists. 
I am in both worlds. At work i have a Xeon workstation, SSD drive, and use IntelliJ ultimate all the time. But it seems that my home laptop with Core i5 and 8 gigs of RAM is not enough for that monster hog of intellij, so at home i have a lean install of Eclipse for Java EE. Pretty satisfied with it. 
The point is that with null, you have to consciously choose to do the right thing (checking for null). With optional, you have to consciously choose to do the *wrong* thing (using .get()). If you just try to use your Optional&lt;SomeObject&gt; without doing anything, the compiler will yell at you. 
Not using libraries - writing so much code that was already written for them and handed to them on a silver platter..
One of the main problems is that inexperienced people tend tend to focus too much on the code instead of the business logic. What experience teaches us is also thinking about structure and the big picture.
why would i? and why would you care about my reasons? would any of them convince you to not try it or to abandon it?
Documentation? 
&gt; you probably want to go and rewrite that whole Tomcat container, right They did rewrite the shutdown hooks :D Oddly this guy's largest claim to fame is him being a successful IBM consultant... I don't know about elsewhere but where I'm located working for IBM is close to a blackmark without project history.
I like to depend as little as possible on other people having their shit together. But yeah, it is a lot harder to screw up. 
You must mean "anyone preferring intellij over Eclipse" surely. Just a typo im sure.
&gt; Eclipse is industry-standard. Last year at Devoxx belgium a presenter asked for a show of hands of who was using what and IntelliJ got by far the most 'hands', followed by Eclipse. Netbeans were just a few dozen people and "vim and the rest" were like two. So no, Eclipse most certainly isn't "industry standard".
Then why teach them Eclipse?
no, I mean it's rare event to see anyone preferring Eclipse over IntelliJ.
&gt; why would i? and why would you care about my reasons? Then why even post?
actually its the opposite. what you do see, however, are the loud hipsters who love to love inferior technologies for the sake of being ... different i guess. Most people use eclipse and love to use eclipse and get disgusted (as they should be) by intellij.
it is my opinion and it is my right to post it. it is not your obligation to read it.
Communication used to be a two way street. If you have an opinion that differs from mine I can learn from you if you explain why. It's too bad that nowadays people get defensive instantly. I mean; in the time that it took you to reply and downvote me you could've just told me why. I might even figured you had a point.
Few signs I can remember that others haven't mentioned. 1. Finish a story or task fast (speed over quality). It does take experience to distinguish between code that works vs production ready code vs maintainable code. For example, with modern frameworks you can get a working piece of code really fast, however that may not be the best one. Requirements are almost guaranteed to change. 2. Undervalue the need for comments. I have noticed many do not comment a weird or complicated piece of code. When you ask them to add comments, it is strange to them as they understand what they wrote! But with experience you know that 3 months down the line if you have to work on that code, you won't remember and would spend a lot of time understanding it. 3. Undervalue analysis. Be it picking a library or picking a pattern. Many jump the gun here. Opinionated software is great, but you must take your time to understand them before you pick them up. 4. Perhaps too focussed on tech and not the business of what they are building. Product owners, even if with technical background, will have assumptions on code design or potentially even false expectations, an experienced developer helps POs with features, cost and priority. You cannot suggest good alternatives if you do not understand business needs. Apologies for formatting hell, am using the app. 
Buys easily into new technologies on the basis of sales pitch only. Let's use nodejs, AWS IoT, Emberjs. 
I use flyway and I always write SQL by hand, even in dev. In my IDE, next to my class files, I keep the last SQL file opened and I modify it whenever needed. For example, when I write a new JPQL query, if an index is needed, I add it in the SQL file. And because at that moment I'm fully aware of the DB usage context, I'm able to choose the right index type (btree instead of hash for example) Threat SQL as code!
&gt;broken up into logical steps demarcated by said comments and spacing Those are called methods. 
Great tip. Thanks!
I was going to say. Rather have a clean structure that doesn't allow for null. 
1. Focusing on things that a linter or static analysis can fix for determining experience level of a programmer. It's a waste of time and effort to deal with stuff I can automate away. 2. Not using source control. Pet peeve of mine. 3. Being clever. Keep it simple. Cleverness never helps a design. 4. Unwavering belief in ivory tower shit over business needs. 5. Worrying about documentation before automation. Hell, even meaningful documentation can be automated. 6. Switching jobs every year or two. This is big, as it tells me you have little long term experience in understanding the ramifications of the work you've done on any significant job. 7. Spending time worried about documentation over automating things you are still doing manually. Code &gt; Documentation every day of the week.
Optionals don't really solve the problem unless in your business logic "null" is an actual state worth considering. If whatever you want to wrap in Optional isn't actually optional in your business logic (like that second address a user might have), don't do it. 
They work on a small sample project, find it easy, and think large projects have the same problematics and complexity. Will think that some operations are trivial (merge operations, Q&amp;A campaigns) in a large project. Will think that some languages or frameworks that are best suited for small projects are the best to use on large projects.
IMO this describes bad programmers, I have worked with programmers with 10+ experience and they check all the boxes.
&gt; The other side of this is over-engineering or optimizing for a use case that is extremely unlikely to ever be needed. (which I've seen a lot from talented junior devs) I used to do this a lot when I was younger. Finding the sweet spot between complexity introduced/abstraction comes with experience and maturity.
I don't think many small classes are over engineering tbh. You are not writing more code than if everything was packaged in a single big class file.
I'd rather have your professor than one who does not. Of course, over-engineering is bad, but judging from the common practices in industry, the average programmer does not abstract enough things.
I have written code for more than 10 years. I still have this feeling when looking at 6 months old code: if you want to learn, you will always improve :)
I used to let new hires configure eclipse for 2-3 days. _Then_ I would beg them to use IntelliJ for a day. I've stopped being a jerk now. I tell them to use IntelliJ from day 1 or never come to me with their ide problems.
Sorry, nope, everyone at my company switched to IntelliJ on their own, and I tell all my interns about the free student licensing Jetbrains has. If anything you're the oldschool hipster still using stone axes long after we invented bronze. I've used Eclipse for six years for various languages. I know my shit. Oh, and you won't believe this. We've started using Kotlin(!) to write our unit tests. 
We absolutely do not allow advocating piracy nor links to pirated material. **Post removed**
&gt; Gets offended during code review. Or consistently failing to address or answer half of the comments.
We absolutely do not allow advocating piracy nor links to pirated material. **Post removed**
It is however my duty to downvote crap like this that comes out of people's mouths.
I should ask around at JFall...
Failing to see when they add an object creation (especially in loops). Failing to understand when they are merely copying a reference to another object (and therefore, changing properties will also change them in the other ref). Failing to know when they should do the former or the latter. Also, failing to evaluate the complexity of their algorithm (this is especially true in fluent api dealing with collections, you can end up pretty quickly with a O(n^2) or O(n^3) algorithm without realizing it).
6 -&gt; makes no sense average software engineer lifespan in a job is 18 months - 2 year
Sorry, but this is the commonly known useless bad quality of "Awesometak" (banned here) who is the author of this article. Take a look at [Java Design Patterns](http://www.java-design-patterns.com) to see how it is done in the right way.
Or something as silly as smartcards. /s
Ehhh, some people would say 100 lines is pushing it let alone 500.
For Android and older code bases: @NotNull/@NonNull and @Nullable to the rescue.
&gt; It's true that programmers get lazy and forget to do the null checks. Language support for operators like ?. are helpful, but ultimately this boils down to the programmer taking the necessary steps to ensure he type checks nullable values. Javac should just make `@NonNull` and `@Nullable`, and the appropriate checks, required for every method. So, much like checked exceptions, we can "ensure" that there are no problems.
Devoxx is much bigger than JFall though. JFall is pretty much Dutch Java devs only. 
I think it's more like personal preference. I'm using Intellij on my current workplace for over a year for a Java and Scala project. I dislike it compared to Eclipse. Just some examples: * The vim plugin in Intellij is unusable. Then the one Eclipse has is much better. * When the little yellow tooltip thingy appears, you can't copy it's content, you select one word, then it disappears, so if you want to search for the error/warning, you have to type it. * The displaying the documentation in Eclipse, when using autocomplete feels more natural, and better. I don't get it all the love Intellij gets. I've found very few things it does better then Eclipse. Maybe the things Intellij shines at are't occuring that much during our project, or maybe I've been using Eclipse too long before...
Yes but I don't go to Devoxx and I'm curious :).
* Saying "it's stupid", while not understanding what "it" does under the hood. * Jumping to the conclusions about the functionality or a bug without doing the proper research * Not being able to work out the problems outside of coding * Copy/pasting the code without understanding what it does first 
I remember the similar thing in Devoxx belgium 2014. Same results, IntelliJ was the most popular by far, when they finally said "JDeveloper" there was just laugh and no hands.
it is personal preference. No one can deny that, but it seems that lately most people prefer IntelliJ over Eclipse. I've personally developed plugins for all big 3, but stayed with IntelliJ, and originally I came from Eclipse as that was the IDE used in my school.
100 lines in a file is a very comfortable number. The class does one or two things and you can fit it's entire code on the screen without scrolling.
Shit I've never thought of this, this is great. 
You should ask this question in the node.js camp as well
+1 for unit testing. I've gone through years of my programming life without it and now I cannot live without it. 
Thanks so much for sharing your elaborate opinion. Cheers ;-)
* Long methods * No barriers in code (all dependencies are hard-coded) or seams everywhere (enterprise madness) * Objections to imperfect / not "cutting edge" tech * Using or avoiding libraries at the wrong times * Playing hockey with API's 
Stop writing more articles about "stop returning null values". Please? Null has a meaning, it's useful. Of course, if you misuse it you'll have a bad time just like anything else in life. The solution for misuse is NOT stop using it. It's to learn how to use it properly. Thanks.
IDEAVim is amazing. What problems do you have with it?
"It doesn't work."
You need an elaborate opinion on why autocompletion, error checking, refactoring, code generation, semantic search etc. have a high return value in IDEs? Well *cheers* right back at cha!
If I call get() on an optional that doesn't have a value, it throws an exception. I have to use ifPresent() which is just not as good as checking for null. If my concern is documentation then @Nullable will do just fine. I don't see why I should add the overhead of Optional.
In my last year of (high) school, I found out what textbook the university I had just been accepted in to (to study CS) is using for teaching Java in the first year. Over that summer vacation I taught myself Java from that book to get a head start on university. It was easy as I already learned OOP a few years prior, and had been coding generally since I was 12.
Actually, if you know a technology stack very well, you get quite good at 'guessing' and it's often faster to try a quick workaround instead of step-by-step debugging. Some problems are very hard to debug with a debugger (e.g. time-critical code, race conditions) and an educated guess can save a lot of time. In other words: Think before starting the debugger. 
There is nothing inherently wrong with imparative code, its a tool like any other.
&gt; Trying to be fancy/overly terse/unique. Jeez what a buzz-kill. /s While for most APIs it'd be a big detriment to be overly terse and "unique", I've seen some quite excellent DSL-like APIs go this route with excellent effects. Take jOOQ for example. Is this coming from an inexperienced programmer? Context matters, is what I'm saying.
This has a flip side. - When I initially experience a technology, I experience all the superficial problems of style, rather than substance, and learning pains of educating myself in how this new technology differs from what I've used before. - Next stage is deeper understanding, the superficial issues disappear, replaced with some insurmountable obstacles in using the technology to its full potential due to fundamental architectural weaknesses in its design (some intentional, as any technology is a balance of "dos" and "don'ts"). - The final stage is transcendence. After endless exploration of the problem space, every of the fundamental issues has been resolved through non-obvious workarounds, advanced deep magic, or subtle and sometimes invisible to myself changes to my workflow, as I adapt to the technology. I have merged with the technology. We have become one. So you see, if I'm at the last stage, and you ask me "tell me what you don't like in Java", and I'd just give back the most empty, and confused look. After a brief moment my eyes would show a hint melancholy, I'd smile slightly, and I'd say "I don't know, sir. I like everything about it."
If they have two competing or similar technologies, I like to ask them what their thoughts are on when they might favor one over the other. The exact answer isn't even important just that they express some thoughtful answer that shows they had some basic understanding of the tech they were using.
Well, yeah, but I'm talking about a different thing that I probably didn't explain very well. It's when you see someone get an error, and they don't really even look at what the error is saying -- they just think, "it must be this or that, so they throw in an extra bit of verification or a debug print, then when it doesn't fix the error, they guess at something else... Meanwhile the code gets cluttered up with all this unnecessary crap. So I wasn't talking about timing issues or the like -- more just when you see someone who looks at the information that accompanies a relatively straightforward error and only sees a blur that reads "ERROR".
Unit Testing, TDD and Refactoring Unit Testing will help you to actually build units that are testable, so when you add a feature, you prefer to add a new class, rather than hacking through all the other code to get it to work. TDD will solve most of the problems you encountered in step 1. And if you haven't already got heavily into refactoring, do so, and that should solve many of the remaining problems you have with structuring code. I recommend IntelliJ Idea for its awesome refactoring features, these will help you immensely. 
Yes, go on, please elaborate!
I was thinking 100 lines max for a method. 100 lines for a whole file--now that's austere. I commend your commitment to brevity
I just *did*! (╯°□°)╯︵ ┻━┻
Which is why it's hard to find experienced programmers. But if you don't scrape the bottom of the barrel, you don't run into this problem. Also, just because the average is 18-24 doesn't mean you don't have jobs that last longer than that. That's how averages work. Maybe I should add something about understanding how averages work, and why percentiles are a thing.
Where? ┬──┬◡ﾉ(° -°ﾉ)
Oh interesting. In fact, I think I had seen that annotation before. Yes, that's already useful enough for what I had in mind.
Let's make a deal. I'll use IDEs as they are right now, and you can wait for one that shows intrinsic code as assembly.
I think the keywords in that last stage were "workarounds" and "magic". Some folks think that design patterns are really language smells. (I'm not sure I fully agree, but they have some interesting points.) An easy example is the Iterator pattern. It can be considered a workaround in early versions of Java for not having an enhanced for loop yet. There's also the Builder pattern. Dart doesn't need it. Of course, the common design patterns aren't even needed in functional programming languages, but they have their own set of design patterns that object oriented programming languages don't need. I suppose I would ask, "What don't you like about Java? When has Java not been the best tool to use?"
In our team, most people use IntelliJ instead of one person who tried it and went back to Eclipse. It doesn't matter, use whatever makes you happy.
Creating the need for manual work. If you dont know how to make the computer do something, but do know how a person can click to do it, look it up.
A few things I've seen that I haven't seen mentioned yet: * Comments that explain a line of code that is fairly standard, e.g. `if (foo != null &amp;&amp; foo.bar() != null) { // short-circuit - no exception if foo == null` I seen juniors do this presumably because (1) commenting is good, and (2) they learned something new - the code did something unexpected from their point of view (and therefore unexpected to everyone), so it should be explained. Obviously, mids and seniors don't need comments like this and such comments detract from readability. * A lack of parallelism in code - often because a junior went in and added something new in 1 place and didn't added it everywhere it needs to go or didn't add the parallel action needed in other places, e.g. a contrived example: if (action.isSelection()) { foo.sendSelection(x); foo.sendSelection(y); foo.sendSelection(z); } else if (action.isDeselection()) { foo.sendDeselection(x); foo.sendDeselection(y); // BUGBUG: why no sendDeselection(z) - did someone miss something? } I catch a non-trivial amount of bugs looking at places where 2 or more pieces of code should be parallel but aren't. Sometimes they aren't supposed to be completely parallel, but that just means the code is missing a comment explaining why. A similar idea applies to fixing a bug at a specific point in code - the next step is to look for where the same bug may be occurring in other (similar or parallel) parts of the code or where near variations or parallels of the same bug occur in the code. * `if`-checks / `null`-checks without diagnostics - juniors will sometimes put in checks to fix a problem (really its just fixing a symptom and just kicking the can down the road and even further away from the actual source of the problem) without diagnosing the real issue or at least logging the bad state: Result result = null; if (x != null) { // junior added this to "fix" a bug result = x.query(); } return result; If `x` being null at that point is *unexpected* per the design, then at a minimum, there should be `else` with a `log.error()` to indicate a problem. The real fix is to track down why `x` was null. BTW, when I flag this in a code review, this is what I get next: Result result = null; if (x != null) { // junior added this to "fix" a bug result = x.query(); } else { log.error("x was null"); } return result; This is a useless log message. What am I going to do when I see `x was null` in the log. The log message needs to provide context - what was going that may have lead to `x` being null. What information will I need when I go to diagnose the problem when I see that `x was null` 
Any particular reason(s) you're against longer and more descriptive names? With almost all editors and IDEs natively supporting auto-complete lists when you start typing, I really only find myself typing out the "long" name only when declaring it the first time. After that it's never more than three to four keystrokes and the name shows up. Even if there isn't native support for auto-completion, there's a really good chance a plugin exists. More descriptive names can almost always only help, while acronyms or abbreviations tend to have a high potential of causing confusion. The acronymed/abbreviated name may be extremely obvious to you (which makes sense since​ you made it), but there's no guarantee it will be obvious to anyone else inheriting your code. Go the safe route and be as clear as possible.
"Some people" have never written a VT100 parser that can pass vttest. You either have a 1000+ line main switchboard function, or you have a 1000+ line state table (or if you are xterm, about 8000 lines of state table). 
* Abundance of Utils classes * Inheriting just to share code * Using checked exceptions in high level business code * Implementing toString and/or Cloneable * Trying to do too much with too little. **Premature Optimization** * In line with the above: Trying to do the compiler's job before compiling. ;) * RTTI (if instanceof) Just to name a few. Edit: ok adding a few, because it's special: * Using switch on enums, instead of just encapsulating the functionality inside of it. * Using Strings or Integers instead of enums. lol 
Yeah, good point, there will always be exceptions. I've seen something similar in emulator code, where there's a method with a very long switch statement covering all the op codes for the processor. Makes perfect sense.
It has been many months that I tried it, and I'm on vacation right now. Some issues I recall with it: You can't switch on/off quickly. You have to go in Tools/Vim emulator menu. In Vrapper (Eclipse vim emulator) there is a toolbar icon. The shortcut (ctrl+alt+v) does not work, it's clashes with the extract variable. There are other clashes with shortcuts (maybe with ctrl+c and ctrl+v), and some other issues, I don't remember them now. Maybe I gave up too early. But with Vrapper I did not recall to have any issues.
No. Lots of projects use Java and more will in the future.
i see so clojure and scala are different from java ?
don't know what your goals are, but I'd keep an eye on kotlin too. That theoretical stuff isn't always so great in a production environment, so it kind of depends on what you plan on building. To get scala to be performant you have to use it like its java.
Clojure and Scala are languages that run on the JVM, the same virtual machine that Java runs on. All three languages compile down into bytecode, which is what the JVM actually runs. It's a huge mistake to say that you should learn Clojure or Scala instead of Java. Clojure and Scala are what are known as functional programming languages. Java, in contrast, is mostly an imperative programming language with some functional programming bits. If you're just starting programming Java will, in my opinion, be easier to learn. This isn't to say you shouldn't learn functional programming, only that I find imperative programming better at teaching the basics of programming. As a practical matter, Java jobs are more plentiful than let's say Scala jobs. There is a lot of legacy Java code out there that needs to be maintained so if you know Java you can always find a job. If you know Scala but don't know Java then your opportunities are going to be more limited. Scala, and other functional languages, are becoming more important as big data processing takes on a larger role in applications, but it's never going to reach the level of Java. There's just too much grunt work to be done that can be done quick and dirty with existing Java tech.
You are right to be as restricted as possible. Also, look into dividing your application into packages. Even a tiny application almost certainly has a logical division between data model and data manipulation/presentation. 
Having one big package is usually a mistake. You shouldn't be super-granular with your packages, but breaking up logical components will make maintainability much easier. Of course more packages does expose the weakness of package-private: it can't be used if you want to have a cross-package API. You'll have to default to public in that case. Of course now you have to be aware that anything that is public is considered part of your public API; if you're writing a library people will try to use anything that is public, even if you don't intend for them to. Document public classes and methods that shouldn't be considered part of the public API and hope that developers will read the Javadoc. That's about the best you can do for now. Come Java 9, though, you'll be able to take advantage of modules. Modules allow you to specify exactly which parts of your library are exposed to external use. Just because something is marked public doesn't mean code outside of the module will be able to access it. This will let libraries hide the "public internal" bits.
Keep an eye on Ceylon too. And Scala. And Haskell. And Idris. And Prolog. And Category theory.
&gt; They work on a small sample project, find it easy, and think large projects have the same problematics and complexity. Like the people who brag about making a web page in nothing but notepad, and who pronounce IDEs as being ridiculous.
TLDR: Program like a grown-up programmer :D
I'd add * difficult to communicate with * not open minded to constructive criticism
Theoretically, *public* is what you would want to publish as a public API (that others outside of your module depend on), and *package private* for an internal module API (that you are free to change). Keeping this distinction is useful because you don't end up with situations where users are dependent on internal APIs, which means you either break users or are forced to publicly maintain internal APIs (see [sun.misc.Unsafe](http://blog.dripstat.com/removal-of-sun-misc-unsafe-a-disaster-in-the-making/)). However, *package private* only allows access to classes with the *exact same package name*. If you don't want to lump all of the code in your module in the same namespace, you can't use *package private* anymore, and have to fall back to *public*. This is a *huge* limitation, and is pretty much why I don't use *package private* and just stick to *public*. You can use interfaces to achieve the same effect. JavaEE does this by defining a public API using interfaces (which users depend on) and which are implemented separately (internal APIs not visible to the user). For example, [JPA](http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html) and [Hibernate](https://docs.jboss.org/hibernate/orm/5.1/javadocs/org/hibernate/jpa/internal/EntityManagerImpl.html) (a common implementation of JPA). If you're not building an industrial strength platform API, I would suggest a more modest use of interfaces along the [dependency inversion route](https://lostechies.com/derickbailey/2011/09/22/dependency-injection-is-not-the-same-as-the-dependency-inversion-principle/). Java 9 is offering a different approach with [modules](http://openjdk.java.net/projects/jigsaw/spec/sotms/#defining-modules), where you can specifically enumerate which packages constitute the public API, and the JVM will ensure users can only use the public API.
And then ideally [your IDE reminds you](http://i.imgur.com/0vEBW7e.png) :\^)
thankyou, this makes some sense ! 
Maye you had a more complex conditional in there before, but when you simplified it, you didn't realize that you could simplify the whole chunk.
Why is implementing toString a bad thing? It's very useful for debugging!
&gt; don't know what your goals are i had a very bad start with programming, the following things in C language * double pointers * filing * structures * pointers with filing * double pointers with filing * pointers with structures * double pointers * pointers (or double pointers) in function arguments VERY BADLY befuddled and bewildered me and my concepts on programming i STILL have problems with these concepts since i didn't bother to rectify them and the degree program chose to close down programming courses after teaching C++ to focus on other computing stuff (DBs, ICs etc) i am scared to go back to learn C ... so i want to know what to do, how to break my jinx in programming ... i want to have good concepts of programming so i was hoping on learning something on how to go about resolving my issues with programming 
Category theory is the type of performance hit I'm talking about though, and very heavy handed/dogmatic. It seems like they don't care how much energy/time the actual computing takes, only how the source code appearance makes them feel, even if it results in a million times more machine instructions being executed and additional resources being consumed. It is ivory tower philosophy masquerading as computer science IMHO. Like so many people still hoping to prove that P=NP, largely a waste of time. ooh, memoization! like we haven't been caching for decades, that is the ONLY nod to performance I've seen. The lack of such dogma is what I like about kotlin, it is just a "better" java as they say, you know, for getting stuff done without making the users wait half an hour at runtime, or jacking up the electric bill and leasing costs for less throughput. I mean if you have a fixed set of data, that doesn't change, and your output is fixed, i.e. just a report, then it starts to make a little sense, but how situational is that? Otherwise it is a bad fit for anything that would be considered a modern system. Just my opinion of course.
Our company's official IDE is built on it.
Apart from what the others said, inexperienced programmers tend to not know the JDK and apache.commons / guava / etc. in and out. So they may write: HashMap&lt;X, ArrayList&lt;Y&gt;&gt; map = getMap(); if (map.get(key) == null) { map.put(key, new ArrayList&lt;Y&gt;()); } map.get(key).add(value); instead of Map&lt;X, List&lt;Y&gt;&gt; map = getMap(); map.putIfAbsent(key, new ArrayList&lt;&gt;()); m.get(key).add(value); Or `StringUtils` 
C is rough, it helps if you have done some assembly so you have some idea why it does what it does at the machine level. But C is also a lot more portable. What sort of applications do you want to build I guess is a better question? What is drawing you to programming in the first place? 
javac support for a @NonNull would be amazing, but may be harder to implement than you think.
&gt; You can't switch on/off quickly. Why did you want to turn it on/off frequently? &gt; The shortcut (ctrl+alt+v) does not work, it's clashes with the extract variable. There is an interface to resolve conflicts (tell IDE or IdeaVIM to handle them): https://i.imgur.com/Wmp5UaJ.png Isn't the VIM plugin for Eclipse a paid plugin? At one time many years ago the VIM plugin for eclipse was $99, haven't paid attention to eclipse since 2005 so maybe that has changed. 
I like this description. Because this is kinda how it is with many things we use. Once we really get into things we don't think so much about the things we adjust. Then we might see a beginner and we wonder why he did an unwise thing. Things that might even work but we just know in the end he will bump into problems by going that path. 
It is a personal preference, you should try eclipse and intellij and stick with the one you like best. Years ago when I tried Eclipse I couldn't get past Eclipse forcing me to have all my projects in a single workspace. I abandoned it quickly because of that, that is a horrible setup for me as I prefer project per window. On occasion I will check out new versions of Eclipse and I see that Eclipse has stuck with its dogmatic insistence for a single workspace. I close it immediately.
I often do: if (blarg == true) { // We can do foo because ... foo(); } else { // We can't do foo because getting here means that A // happened and B is likely. Ideally we would do baz() // but that violates the spec at ... So we will do nothing // here and rely on the UI to retry after such-and-such. } Because I am pedantic and consider comments as important a deliverable as the code itself. 
Since you say automate before documentation twice in your list, can you expand on what you mean? Are you talking about external documentation like requirements documents, or internal like commenting and javadocs? 
Agreed. This is better than storing `null` in `post.comment`. In addition to helping with proper usage of the value, it documents without comments^[1] that this field can legitimately contain `null`. As for using `get()`, you could have to ide detect that as suspicious. That is no guarantee, but it would help. What I think would be a mistake is to replace all references with `optional`. This would add undue complexity to the code and encourage the use of `get()` as coders would not want to deal `orElse()` if they know the value cannot be null. ^[1] ^because ^comments ^can ^be ^outdated ^or ^missing ^while ^executing ^code ^cannot. p.s. I still dislike null objects as a proposed replacement of `null`. They are very useful in certain contexts, but it cannot replace the actual `null`.
You need to learn Java to understand some basics of what's going under the hood of JVM. W/o this knowledge you'd end up scratching your head over bizarre stacktraces / memory dumps when your lazy stream will appear not so lazy for no obvious reason. Nor you will understand memory constraints, internals of collections and the toolkit (a lot of Scala developers have no clue what `javap` is used for). Just don't get into the EE domain (EJB and related stuff), core java + multithreading are still very valuable to have in your assets.
&gt; What is drawing you to programming in the first place? I am a Computer Engineer ... well, i will be when i graduate in a few months I am situated in Karachi,Pakistan. there's not much scope for designing and developing hardware, especially hardare which is related to gaming there is also NOT much scope for game development here so there goes my two BIGGEST passions in computers. i love computers because of games and High Performance gaming hardware ( AMD Ryzen/Thread Ripper, Intel i9/i7, Radeon Rx480/Vega56,64, Nvidia 1080Ti ... you get my drift) soo .. what else am i supposed to do but know which languages are in high demand in the Job Market and then train myself accordingly? &gt; it helps if you have done some assembly yep , there was this course named " Microprocessor based System Design " where we took a close look at assembly language, especially jumps and stuff as well as loops and other practices that are normally done in higher lever languages. i know the basics that everything basically translates on 1s and 0s and then makes the circuit boards pass on signals in accordance with the binary to get whatever works the user desires, done. our programming teacher was a piece of work ... she spoke so fast and mostly wrote ENORMOUS amounts of code on the white board rather than explaining concepts to us in a calm, relaxed and tactile manner. she single-handedly ruined programming for alot of the batch
ah .. thankyou THIS &gt; core java + multithreading are still very valuable to have in your assets. and this &gt; (a lot of Scala developers have no clue what javap is used for have made me have a greater resolve to start with Java :)
Yeah, usually just if(foo), not if(foo==true), but occasionally I may do === in php or js if I'm feeling moody. :)
Just ask them about dependency injection. Probably a good way to probe their knowledge about abstraction. 
:) one of the big things I've taken away from coding over the years is the value in cleaner code. Spaces/tabs, syntax/braces/etc - doesn't interest me. decent structure, decent variable names, decent method names, some useful comments - all of those make maintenance so much easier for me or whoever else might have to deal with it. Until you've had to deal with your own code 5-10 years on, it's hard to understand how much of an impact this can have (both on yourself but also on others who might have to deal with it years after the hype around lib X has faded) 
Every retard at my company did the same thing. The smart people didn't.
That's an anecdote
I just stick try/catch clauses at the top level function calls and everything below using "throws Exception" in their methods. 
have you researched the jobs available in your area? Are you willing to relocate? looked at any trends in your area vs where you might relocate? These would seem to be the important variables if marketability is your goal. There isn't super reliable data on it, but it is better than nothing IMHO. re: pointers to pointers (to pointers), these are just levels of indirection. I.e. instead of having an address to a value, you have an address to an address of a value, or an address to an address to an address of a value, etc. You are really gonna have to bring out your inner nerd if you want to go full-on gaming programmer, might be best to make that a hobby while finding a more pragmatic day job (java isn't a bad choice in that regard). Sorry you didn't get the education you hoped for. FWIW I am largely self-taught, then learned relevant technologies on the job, for a long period of time now. I did go back to school, but just for the piece of paper, and it was a cakewalk by that time. 
You can start by listing why you think IntelliJ sucks instead of attacking people. What can be asserted without evidence can be dismissed without evidence.
On/off switching because sometimes, I need features, that are easier without the plugin on (multi line editing for. eg.), or I hand the keyboard to my college, to show some code, and I don't want him/her to freak out from vim :) Maybe I will give another try, but the thing is, with Eclipse, you did not have to do this. (Ok, for Emmet plugin, you have to change the key mapping settings for some minor shortcuts (but that is because I use a hungarian keyboard, not an english one).) It's very discouraging. Why did the plugin developers defaulted to a shortcut that they know will clash with the default shortcuts, and out of the box won't work? It's not very user friendly. I have used the Vrapper plugin for many years, it was always free, who knows, maybe it started as a paid plugin.
There isn't enough time in the universe for that. You can start by listing why do you love that shit so much. The smart people at my company (including me) used it for a couple of months, to see what the fuss was all about. We have made a list of pros and cons and eclipse/netbeans (with minor variations) always came out on top. I did my homework. You, obviously, haven't. If you need me to do your homework for you, you can fuck off.
You'd fit right in on /r/iamverysmart.
If you can't use Optional, name API methods with "OrNull" if they can return null. If not overused, this can be a helpful way to signal, directly in the API that the function may return null. public EyeglassPrescription getKittenGlassesOrNull(); Now when calling that function, it is fairly obvious, even without JavaDoc that this may return null if a particular kitten does not wear eyeglasses. Also name the variable with "OrNull". EyeglassPrescription epOrNull = getKittenGlassesOrNull(); Again, useful IF NOT OVERUSED. But better would be to return a list. It is unlikely that a kitten would have more than one EyeglassPrescription. But an example would be: public List&lt;ValuableExpensiveItem&gt; getFavoriteChewables(); Now if a particular kitten doesn't like to chew on anything, then return an empty list, rather than null. 
Sure, a terse API is actually a good thing. I was more referring to people that try to write very compact code, do lots of things on one line, abuse ternary expressions, etc.
Hahaha, so you do want me to do your homework for you. Well, as i said earlier, you can fuck off. 
&gt; Sorry you didn't get the education you hoped for it wasn't THAT bad .. just the C and C++ course. some teachers were wonderful, the graceful ladies who taught me Operating Systems, Microprocessor Based Systems Design .. they are some of the BEST teachers its just i feel like programming is my Achilles Heel, but i will leave no stone unturned in trying to make sure i resolve this issue as well thanks for the pointer to pointer description :) , feels easier now &gt; . FWIW I am largely self-taught, then learned relevant technologies on the job, for a long period of time now. this is encouraging, i was unsure if one could be a self-taught programmer ! but now, i think one could be BETTER being self-taught rather than being directed to do so ! I always thought university was my one and only chance to learn programming, but i guess that's not true. and you went through uni like a walk in the park :p and you're right about the day job, anything to pay the bills and make some steady income. i mean, how bad can it be? i would like to know though ... why would i need to be a nerd for gaming programming :D ? 
* Mountains of ifs. You know what I'm talking about. * Not documenting code * Long, long functions doing everything in one place * Doing loops and jumping through hoops because they don't know THAT ONE api function which would do exactly what they want * Excessive null checks and redundant validations, "just in case". This happens when they haven't got experience with the API and don't know exactly what that call does * Or not doing null checks AT ALL. * In Java: Not using generics, instead using &lt;?&gt;s and unsafe casts all over the place. This one makes my blood boil. 
Be proud of your code. Able to explain it, and defend the choices selected.
&gt; &gt;* Gets offended during code review. &gt; Wait, what?
I call it: shotgun debugging. Bang! Ok, that didn't work. Bang! Ok, that didn't work either. Now, something that should not be mistaken for guesswork, is debugging tests to gather more information about the problem. This is more like doing science. Hypothesis. Test. That's not the problem. So repeat. Eventually you get the Ah Ha! experience.
Don't plan for the future. At least in coding. Only refactor what you need to refactor. "But what if in the future I need to add another parameter to this function?" THE CLIENT IS UNPREDICTABLE. Don't pre optimize code into something that you'll probably never use. It's wasted effort. Only put your effort into already solicited or necessary changes. But when you do, do it right and don't take shortcuts.
One way to cure them of this, or to shame them into learning more, is to take the exception, explain that it contains a LOT of valuable information, and start pointing out things you can see directly in the exception. It looks like you were entering a purchase order, and there was a problem parsing an integer value in an order line, probably the quantity.
Number one sign for me: code that isn't necessary. I find this a lot, that newbs tend to build abstractions and constructions that I personally would just strip out because they only add complexity and no value. Hard to show examples without posting thousands of lines of code, though.
&gt; They ask about a problem and say something like "I'm getting an error" instead of saying exactly what the error is. This is one of the most effective ways to make me angry. You're coming to me and spending my time, but you're not going to make it possible for me to actually help you? And you had this information right in front of your eyes, but couldn't be bothered to copy and paste it? I try not to rip people's heads off in this kind of situation, but the temptation is always there.
&gt; silently eating error Pros do this, too, and IMHO it's one of the worst things you can do. This *always* leads to grief later, and quite often a lot of it.
&gt; Traits I am concerned with in new programmers include overconfidence Had some guys turn in assignment code in university that looked really, really weird. So I asked them why they were doing it that way, and it turned out they had these errors and they thought it might be a compiler bug, so they were trying to work around the compiler bug, and eventually got it to work. Honestly, seriously thinking the bug is in the compiler and not in your code, and then acting on it. Now that's overconfidence.
Nah. This reflects not having realized that booleans are values just like all other values.
What will you give me ? Visibroker 4.0, Name service only runs on 1.2. Original developers stored global security keys in thead storage so Java 5 is right out.
Here is a quick handy glossary that might help in general, and while not directly answer your question, will help you to reason about the answer to your question. Java -- a programming language. Also a virtual machine with an ecosystem of languages and tools. Java Bytecode -- platform neutral executable code emitted by a compiler, such as the Java or other language compiler. (Scala, Clojure, other languages, etc.) JVM -- Java Virtual Machine. An interpreter that executes Java Bytecode. The interpreter might actually be implemented as a compiler that seems like an interpreter. JRE -- Java Runtime Environment. Packaging of a JVM to run your compiled Java Bytecode programs. JDK -- Java Development Kit. A JRE plus tools useful for developing Java programs. Compiler. JAR tool. Etc. JIT -- Just In Time compiler. A JVM can use this technique. For example, a JVM may start out by interpreting your Java Bytecode. All functions are dynamically profiled. Once a function is discovered to be using a larger fraction of the CPU than other code, that function is compiled by a C1 compiler that quickly produces un-optimized Native machine code. The function is also scheduled to be compiled in the near future by the C2 compiler which is a slower compilation process, but produces highly optimized native machine code. 
I mean nerd in the sense that the bulk of programmers, and people in general, will give you strange looks when you get excited about some bit of technology :) re: indirection, the most common use I've had for multiple pointers is in multidimensional arrays. I.e. say you have to map, based on testing, the pulse width for a fuel injector in a car, and it isn't nice and linear or anything. So you have inputs like mass flow, throttle position, current rpm, well these empirical values can be represented in a 3d array, where these are x/y/z coordinates, and it will be very performant. OR say you don't have a nice mass flow sensor in your production vehicle, but through testing you have values for mass flow from manifold pressure, rpm, and air temperature, same deal, or you use all the inputs because your mass flow sensor is kinda slow.
I'll add one to the list: Does not make at least reasonable attempts to leverage the strengths of their IDE. They will almost certainly create more bugs and be less productive than colleagues who do. In Java, you have extremely powerful IDEs available to you. People who ignore the IDEs warnings concern me. Further, you don't even have to learn the newest syntactical sugar by heart, your IDE will help you be expressive! IntelliJ in particular allows me to be extremely expressive with far less superfluous code, and also protects me from myself. It's good to know what to do and what not to do, but to pretend you're infallible is a mistake.
Highly opinionated, like most of these comments.
thanks :)
&gt; Why did the plugin developers defaulted to a shortcut that they know will clash with the default shortcuts, and out of the box won't work? It's not very user friendly. I think it is because those are standard VIM shortcuts, so they let VIM users decide whether to use them as VIM shortcuts or IDE shortcuts. Default setting is VIM (I have changed all of mine to IDE). Hardcore VIM users would probably complain if those shortcuts didn't work by default. 
i use Eclipse. Why? Because I have 5 monitors and displays View on those 5 monitors Problem Views are great. Incremental compilation over all projects is awesome. I would not be able to use IntelliJ with my workflow.
[deal](https://twitter.com/chriswhocodes/status/903636761913561089)
Maybe this was more "implementing toString() on everything?" We implement it, ahh, "selectively."
In fact, I've learned [this already exists](https://twitter.com/chriswhocodes/status/903636761913561089) :)
&gt; An easy example is the Iterator pattern. It can be considered a workaround in early versions of Java for not having an enhanced for loop yet. It's still a design pattern for iteration, just a nicer one. One of the things I try to hammer into novices heads is that patterns are things you see, recognize, and reuse. They aren't just a finite list from a dusty old book. 
That's perfectly fine even for a senior developer if they don't know the library. What's not ok is when they don't go back and clean up the mess afterwards. Or if they don't document why the fix worked was after unwinding the stuff that didn't work.
Would slightly modify it to - if you were in charge of rewriting the language what would you add/edit? For java - Multi class inheritance for instance.
So bottom line - we are both back to using IntelliJ and nothing has changed. 
&gt; I mean nerd in the sense that the bulk of programmers, and people in general, will give you strange looks when you get excited about some bit of technology :) lol i have had that already, since i got awareness of tech/hardware tech . i get excited about every good new game or tech that's coming out and promises some goodness :D
I'm not sure why you think the aim of Optional is "code prettiness" and this is a bit of a strawman. Null (mis)-handling obviously has an impact on customers: * service degradation, due to bugs, due to not handling null. * increased costs, due to slower development, due to having to consider whether a value is nullable at every call site If you disagree that Optional improves null handling then your performance argument is irrelevant. You could instead just say "don't use Optional because it is pointless". If you agree that Optional improves null handling, and you agree that null mis-handling has an impact on customers, then whilst performance is important, it might not always be more important.
Multi-class inheritance? NOT!
I would not ask the question about Java. I would ask it about ancillary technologies such as Spring.
Yeah, this guy nails it. I use both since I work with two different development groups. Both are excellent IDEs. Go ahead and use whichever one you like best and don't worry about people hating on one or the other. My personal experience: * I think IntelliJ integrates with GIT and branch management a bit nicer * I think Eclipse's out-of-the box tomcat/web support is awesome (I only used the community edition of IntelliJ) * I prefer Eclipe's .jsp/.html editor 
"It'll take us less time if you ask me what I like about it." :-)
Well, I wouldn't put it this way. I got a feature I wanted but didn't know existed already, and you... well... hope you'll have a great weekend!
Good to know! :-)
&gt; Wanting to rewrite everything as a default to every problem. In Java this is somewhat true but in more expressive languages, especially for smaller projects, it can be argued that the rewrite might be delivered faster, perform better, and be more easily maintained in the future Edit: formatting
This could easily get into splitting hairs territory, but... It might be a pattern, but I wouldn't call using an enhanced for loop a design pattern. There's a difference between copy/pasting a for loop and actually coding out the Iterator pattern correctly. If you're interested in reading more on the idea: http://wiki.c2.com/?AreDesignPatternsMissingLanguageFeatures
I guess it's possible that sql could have had a non-Boolean value, depending on which language you're using. But that still doesn't fix the if(sql==true) line.
Call me a cynic, but I'm always a bit wary of benchmarks that just so happen to show the author's library is the best (and it could definitely be stated more explicitly that cache2k is made by whoever runs cruftex.net). Has anyone else heard of or tried Cache2k?
So you can rely on the wikipedia article you just memorized.
Well said. Love #2, which is a great point and something I think we all should strive to understand better.
[Disclaimer: Java SE Product Manager, work for Oracle] Looks like you have run into the disabling of SHA-1 for TLS. See details here: http://java.com/cryptoroadmap Bad idea to re-enable this...
There are two common ways to abuse statics: * Creating methods `static Bar m(Foo f, ...)` inside the `Foo ` class. Usually, they should be normal instance methods. This also includes cases when they're defined in the `FooUtils` class in the same package. Such methods make sense only if they are defined in some other package and depend on other components than `Foo` does. * Static state, excluding necessary singletons and correctly implemented cache, but *definitely* including incorrectly implemented cache (I've seen big opensource projects with constantly growing private static HashMaps, you can guess how that ended).
 [DEBUG] com.company.project.ToplevelLogger [40]: Fatal error
Not all inexperienced programmers are like this (in fact, few probably are), but some try to hide their insecurity behind "strong" opinions. Example: https://toomuchawful.com/2014/12/22/new-intern-knows-best-goto I once met a guy who would constantly educate the team that Oracle Database sucked and MySQL was much better. It was a bit tiring after a while. He moved on and became "CTO" of a small company :)
Or the opposite: "It works for me."
&gt; I find this a lot, that newbs tend to build abstractions and constructions that I personally would just strip out because they only add complexity and no value. I've met experienced architects who did that
I meant that from the perspective of the junior developer having their code reviewed and criticized by others as a part of that review process. And instead of keeping an open mind, and engaging in polite discussion, become offended and refuse to listen. Of course, it behooves the reviewers to be professional and considerate as well. However, I have witnessed this happen enough times for it to pop up in my head when I was writing this response to the OP.
&gt; It might be a pattern, but I wouldn't call using an enhanced for loop a design pattern. You say that now, but if your junior devs started writing a bunch of weird code that didn't use for loops then you wouldn't hesitate to accuse them of violating Java's standard patterns. *** The way I classify design patterns are: * Idiomatic patterns: the patterns that 'everyone' using a given programming language are expected to know and use. * Framework patterns: the patterns that are specific to a given framework (e.g. JEE, Spring Boot, Hibernate) * Application patterns: the patterns that are specific your application Idiomatic patterns are so common that experienced developers don't even see them as patterns any more, but they are useful for training new developers.
 System.gc(); System.gc();
Documentation in the general sense. So that would include things like javadoc (to a lesser degree), customer-facing api docs, support docs, external developer docs, etc. 
I wasn't aware of the crypto-roadmap, thanks. Is this likely a file on the server that will need to be re-signed?
Neither Scala nor Clojure will replace Java. It's never too late to learn all three, but I would recommend starting with Java as it's widely used. Scala and Clojure are niche languages, you might struggle to get a job if you only know one of them.
Well, IMO, getting offended at code review is not a sign of being a rookie, it's rather a red flag, i.e. dealing with "superstar" coders who think they're the seventh heaven. They're often the worst. I mean, sure, one can argue about programming approaches and the need to do something this or that way (I've been in such a discussion when I just got in a certain job), but getting offended? That's WAY taking things too personal.
Looks like I am not going to get the offer! Haha. Nevertheless it's more of an implementation and acceptance than anything else. We only needed to start it with 1.1 and we would have come to accept it... How about not having 'null'. Edit: That sounded needy.
Did you sort-out what you need for this?
Ah, Abstraction! We are developing microservices and the amount of abstraction the architecture team is forcing us.. We are ending up creating a lot more micro components than we planned. Will not be surprised when they start cribbing about performance and ask us to dial a couple off them back!
Treating programming code as a countable noun.
Yes, I was using Cache2k before Caffeine came about, I used it for Hibernate but, I dropped it only because I ran into a weird issue when I was using it as a backing for Spring as a JSR107 Cache
Oh, this is very true. I don't think anyone really likes working with those "superstar" style personalities that can do no wrong, regardless of profession. :)
&gt;overconfidence Reminds me of my freshman year CS class. 
&gt; Eclipse forcing me to have all my projects in a single workspace That is literally the point of the workspace. You can have multiple workspaces. A workspace can house dozens of projects, the JS ones for the UI, the Java ones for the middle to back-end, the data ones, the C++ ones for legacy projects being integrated. IntelliJ _still_ can't do this. Worse, you have to actually pay to get anything enterprise related that Eclipse, Netbeans and others give you for free; even Visual Studio gives you a free IDE that lets you do enterprise grade work. 
My *personal* preference is IntelliJ IDEA, but I use all three major IDE's depending on the project/team. My reasons for my preference: * It supports all of the tooling (application servers and build systems) that I end up working with the most out of the box. * I think the auto-completion is better. * I think the refactoring tools are superior. * I also really like how IDEA handles project setup and artifact creation; it's way more flexible. Of course, this is just the opinion of some random stranger on the internet. Everyone will have their own preferences and opinions, and I would say that if you wanted to explore IDEA a bit -- go for it. You might like it. You might hate it. But you won't know until you try. :)
I tend to do the same thing when appropriate. Explaining *why* something is happening in code, especially when that something is unusual, can be really important; not just for others, but as a reminder to your future self as well. 
Wish reddit had a lol option instead of just upvote.
Technically that's called "read only". It sits between immutable and mutable in the safety scale.
Maybe cache2k is the fastest, and maybe it's not. As /u/Vile2539 stated - I too am skeptical of any benchmark published by the library maker.... but a better title for this would have been: Guava, Caffeine, and cache2k are all within 15% of eachother and all **way** faster than EHCache. The reality is, for *most* people Guava is "fast enough". It's distributed by a big reliable name, and has an excellent supporting library and APIs. 
Because it's a pit viper, e.g. a publicly available method on Object by every single 3rd party lib you might use. Think about it and also consider this: I really doubt your customers pay you to do code for debugging purposes. If you're implementing this just for debugging, find better tools.
&gt; keep an eye on kotlin too Just don't assume that it is language worth learning _NOW_. Unless you are into Android. Keeping an eye on is totally okay though. 
&gt; IntelliJ still can't do this. You say this like it is a bad thing. (although pretty sure you can setup each project as a module if you are insane and like multiple projects in the same window). &gt; Worse, you have to actually pay to get anything enterprise related that Eclipse, Netbeans and others give you for free; I have no problem paying for my preferred tool. If IntelliJ is your favorite IDE then you have to live with the fact that it costs money. 
Well, if you struggle to wrap your head around pointers and what memory is - sorry, maybe programming is not for you. C is a _very_ good start in learning programming. Getting exposed to some of primitives (and they are not hard at all - "go to this shelf, read the book there. Follow what the pages say. One of them will say "go to this shelf, read the book there. Follow what the pages say. One of them will say "Go ...) from early on is a good thing that will help and speed up any subsequent learning 10 fold.
And like so many Indians you are unable to use punctuation properly. Can you explain ..fasci.nation . your kind of people have - with absurd punctuation?
I would agree that some of the less verbose arguments are somewhat limited. However the big selling point for me is the functional style programming, unchecked exceptions, extensions, and the everything-is-an-expression. It just makes the coding experience better. To use fancy terms, Kotlin is more declarative vs javas heavier imperative bent, and I personally like that more.
FWIW, I get the same result as you.
Not necessarily. I made a small web app. My data objects, representing the JSON payloads passed back and forth via the API, we're all in a single kotlin file. I have like a dozen of them, and the file is less than 100 lines of code. All because if how compact kotlin is.
Kotlin doesn't have any special JDBC logic. You use JDBC the same way you would with Java. Only really difference is no try-with-resources, kotlin has a use() function that does the same thing. I wrote some cool extension functions for JDBC for fun. Basically doing quick queries and updates, with a single function directly on the connection object that wraps around all the boilerplate with statements and resultsets. I like it, it can make JDBC code one-lineable.
If the problem is fixed by removing `SHA1 jdkCA &amp; usage TLSServer`, the thing that is failing is certificate chain verification when negotiating an SSL/TLS connection to a remote server. Either the end-entity server certificate, or one of the intermediates, has a SHA-1 signature, which is no longer considered secure. Browsers stopped trusting SHA-1 signatures by default around the beginning of this year. It looks like this is manifesting when your application is loading some libraries dynamically over the network, probably using an `URLClassLoader` or similar. The issue should not be related to code signing (that's a different constraint in `java.security`), but in a complex environment it's hard to rule anything out without seeing it. You will need to work out where your application is retrieving its JARs from, and identify which of those is presenting a SHA-1 certificate. Then, you have three options: - Replace the server certificate with a newer one, with a secure signature algorithm (such as SHA-256). - Explicitly trust the end-entity certificate of the server on every client. - Re-enable SHA-1 signatures for certificate path verification on every client. Replacing the server certificate is by far the best option, and will ultimately have to happen anyway. However, there are still plenty of legacy systems hanging around which are unable to handle anything newer than SHA-1, so you may have to manage those compatibility issues. Explicitly trusting the end-entity certificate is fragile and doesn't scale well, but may be an acceptable compromise. Re-enabling SHA-1 signatures is problematic from a security perspective, and still doesn't scale well. If you are in a large(ish) enterprise context, this absolutely will not be the last you will hear of issues caused by SHA-1 deprecation, and someone in your organisation has probably already had to deal with some similar pain. Hopefully, you have some security people who will be able to help you investigate, and also put pressure on whoever is in control of the server certificate. Hope that helps.
Thanks for the verification, that means I'm not going crazy, what version of Java and what OS (if I may ask)? 
java version "1.8.0_144" Java(TM) SE Runtime Environment (build 1.8.0_144-b01) Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode) Windows 10, v1703
Yeah, security on applets is understandably difficult. I know its easier said than done, but start moving things to a webapp and deprecate your applets. Its a dying technology.
JSR 305 was an attempt to get that stuff into the stdlib (though javac wouldn't analyse it), but if failed to get accepted :(
Figuring out which jar should be possible from the full stack trace.
Many people, including Bob Martin in Clean Code, advocate for methods 20 lines or shorter. The idea is to decompose complexity. A 500 line method isn't a method, it's a script wrapped in braces.
cache me outside how bout dat
I'm not sure what you mean by your first statement. I'd totally question why they weren't writing standard Java. It depends on what they were doing. I assume by "weird code" you mean not using Java 8's streams in a standard way and instead doing something funky that should totally use a for loop or could use a Java 8 stream. I've seen developers use while loops and manually handle the variables, and I've seen them try to do some reflection voodoo (prior to Java 8) to get a for-each type of functionality out of Java. For your latter statement, it could just be our different terminologies maybe. I think of design patterns as more high level than the decision to use a for loop over another option. If I was at a design review, whether or not a for loop was going to be used over a while loop or a .each wouldn't come up. It would at a code review. So maybe it's a code pattern, sure. 
They should have included Infinispan.
&gt; I'm not sure what you mean by your first statement. I'd totally question why they weren't writing standard Java. Typo, I meant "then you wouldn't hesitate" &gt; So maybe it's a code pattern, sure. Something to keep in mind is that "design pattern" is a loan word from physical architecture, the designing of buildings. In that context you have patterns from how city streets are organized down to how individual bathrooms are laid out. But if you want to distinguish between "design patterns" and "code patterns" that's fine by me. The important thing isn't the terminology, but rather thinking about repeatable patterns instead of making every piece of code it's own snowflake.
I also watch for non-static methods that don't rely on any member data. 
Does that mention Spring is easy to spell? 
If you *know* only that package needs it then default is fine, but in practice I rarely use it. Generally only when exposing a would-be private method to unit tests. 
&gt; The MDC manages contextual information on a *per thread basis*. Source: https://logback.qos.ch/manual/mdc.html Yeah. Pretty much stated in the documentation. ;) This is why you'll usually see people calling `MDC#put` on the main thread of execution. So for web services, you'll have something like: @WebMethod(operationName = "CreateReceipt") @WebResult(name = "CreateReceiptResponse") public CreateReceiptResponse createReceipt() { final UUID requestId = UUID.randomUUID(); MDC.put("request-id", requestId.toString()); ... bunch of stuff here ... MDC.remove("request-id"); return response; } Doing it anywhere else is just asking for trouble!
Always remember the phrase: _"It's easier to write than to read code"_. Don't ever acronym things unless you're absolutely sure anyone that sees that code later will understand it. Writing code that is understandable for others is a skill that needs practice, so do it even if it's a personal one guy project.
Then, when you find it, don't simply copy-paste it (even if it solves your problem after trying it). If you don't understand it, it's an opportunity to go search about those methods to know why/when they are the best approach etc.
I'm more inclined to believe his anecdote than the "Eclipse is industry-standard" statement which is not supported by any evidence whatsoever.
How do you know it was written in Java? (It's very pretty though. JavaFX?) 
Some audio stuff in java.. https://github.com/philburk/jsyn
&gt; The important thing isn't the terminology, but rather thinking about repeatable patterns instead of making every piece of code it's own snowflake. Absolutely. 
I forget where I saw the data, but last I saw, IntelliJ was edging out Eclipse. It was something like 45 Intellij, 40 Eclipse, and 15 other. Eclipse was industry standard once upon a time, but yeah, it's just not anymore.
Cool! Do you have it somewhere on github?
You are correct. You should choose the most restrictive one. &gt;But from my research, I have discovered that package-private is not used very much and can be confusing since people may assume you made a mistake in not specifying an access modifier. See common pitfall number 4 here https://zeroturnaround.com/rebellabs/watch-out-for-these-10-common-pitfalls-of-experienced-java-developers-architects/
Learn Scala, learn clojure, but do learn java as well. 
Ughh ... no. Lol, wtf are you smoking? optionals are great, but not all-encompasing, not all-applicable. null has its place, live with it.
definitely not true. higher level languages don't have as much as Java does and focuses on solving an entirely different problem. Just stick with learning Java.
Scala and clojure are great languages and you should learn them! However, I recommend not learning them as a first language. Learn another, more mainstream language first (doesn't have to be java although that's a good option). The main reason for this is popularity, you will find many more resources and tutorials for Java, as well as many more Jobs (although some people say that although there are fewer scala jobs, there are also fewer qualified applicants to compete with which balances it out, can't say how true that is) The other reason is, Scala is a complicated language. There are more things for a beginner to get tripped up on than Java. I think it is probably more difficult to learn programming with Scala than with Java. There are also no real books or tutorials I know of for beginners to programming in Scala. Most scala resources assume you already know Java or another language.
I disagree that Java is needed to understand JVM internals. Scala doesn't help or hurt any more than Java in understnading the JVM, bytecode, collections internals or any of those. &gt; (a lot of Scala developers have no clue what javap is used for). The same can be said about Java developers. Some people are going to care about this and some aren't, the choice of language doesn't affect that.
Lack of familiarity with APIs and libraries (overuse of the few methods and data structures he/she knows) Lack of familiarity with tools (constant surprise that the IDE can do that) Tests the wrong things often overlooking important edge cases.
&gt; Well, if you struggle to wrap your head around pointers and what memory is - sorry, maybe programming is not for you. now that's just harsh and condescending .. almost damaging to one's morale also, i think you didn't interpret it too well ... i didn't exactly say what you think i did when i was referring to having conceptual issues do you know i am doing my final year project all alone (its usually done in groups of 3/4) ? I have had no interest in programming, no motivation ... but after the fateful events that led me to be a lone member of my FYP, i chose to give it my all and i got a pretty good idea of what memory is and even pointers and i know how memory works, how pointers work ... it's just that our first exposure to programming was an absolute disaster and the few peculiar cases, like double pointers in function arguments and other similar stuff, didn't sit well with me i am just scared to go back to C, because there's this resident fear inside my head, that i will have to face those double pointers and structures with pointers and so on... thats all
&gt; your kind of people I am not Indian the prejudice in your mind is just ... either disgraceful or ridiculously comical. can't put my finger on it since you chose to be a nitpick, point out the punctuation error please 
AH ... a descriptive answer finally i understand, Java is king over the 2 i mentioned. it's like getting a solid base/framework with Java first and then going on to these more sophisticated, yet abstracted languages. &gt; Learn another, more mainstream language first (doesn't have to be java although that's a good option). what would be your top recommendation(s) ?
paki, indian, what's the difference?
&gt; i am just scared to go back to C, because there's this resident fear inside my head, that i will have to face those double pointers and structures with pointers and so on... So, yeah, stop. All you will do is write shitty copy-paste code. If you don't appreciate the beauty and elegance of it - stop.
If you are using package by feature instead of package by layer approach, package private is a great tool which helps you modularize your packages. It also eases refactoring because it's immediately evident who uses package private class/member.
Borders and Geographical location, for starters and then comes Culture, but that's a discussion for another time you still didn't point our the error
ok that's it, you're not helpful gotta stop listening to a troll like you hell, you're being borderline bigoted !
&gt; All you will do is write shitty copy-paste code every beginner refers to some code first you didn't begin programming while feeding on baby milk ! you're a dick ... disdainful prick this arrogance of yours will trip you up eventually and make you fall face down egotistic jackhole 
There is no space before . there is no .. such thing. (as for you believing there's a difference - how cute. Both are same shithole just some imaginary border drawn in between)
Fair enough. I hope your course included instructions on spamming expert mailing lists with stupid questions and "please do the needful". 
All righty then. Listing what I don't like in Spring would take us by rough estimation 3 months, so I want a full-time salary plus benefits.
* Python: very easy to learn, dynamically typed though * Java: Solid, easy, lots of materials, JVM platform * C#: Like Java but from Microsoft, Windows centric, has some more language features, .NET platform * Go: Very compact language, imperative, no OO, new'ish I also heard that Smalltalk is a nice beginners language.
thanks :) what is the difference b/w dynamically typed and static? also, what is imperative ? (you mentioned it in Go)
I wouldn't necessarily say that. The others you mentioned are seperate languages, but they run on the JVM. Java being the primary JVM language and most people who are leaning a JVM language already know Java, so often people think of constructs in those languages in terms of how they work in Java but this is not necessary. You can work with Scala, Clojure and other JVM languages perfectly fine without considering what the Java equivalent is. As far as recommendations I would say go for Java. I'm a Java dev primarily so I'm obviously biased, but there you go. I think Java is a good choice because it is the most popular language in the world. If you are already learning some Java, stick with it, trying to jump around all the time will slow your learning. Just stick to one language. Other good languages to learn could be Python, Javascript, C, C++, or C#. The important thing to note though, is that the actual language Doesn't really matter. Don't worry about learning the "wrong" language, there no such thing. Just focus on learning programming, those skills will carry across languages. If you need a language you don't already know, but you have strong programming skills you will be able to pick up the minor differences between languages.
thanks this makes sense especially the 'wrong' language part ... ever since my first experience with programming, there was this bias in my head nagging me on learning older languages was a waste of time i guess you just need to have good logic skills and an intuition to think up the rough sketch of what you want to make/program, the language syntax and the complimenting tools required, come together on their own once you have a good idea on what to do.
* Dynamically Typed: Type checking at compile-time as opposed to run-time. *E.g. Python, JavaScript, Clojure* * Statically Typed: Type checking at compile-time as opposed to run-time. *E.g. Java, Scala, C, C#, C++, Go* &amp;nbsp; * Weakly Typed: Types are implicitely coerced into another. Type is on the value, not the variable. (5 + "2" = "52"; 5 - "2" = 3). *E.g. JavaScript* * Strongly Typed: Explicit conversion is required *E.g. Thanksfully pretty much every other language* &amp;nbsp; * Imperative (Procedural, Object Oriented): Statements are executed one after another, in explicit steps specifying what happens. Imagine a recipe. * Declarative (Functional, Logic): Defining how the result should look like and what's needed to get there, but the steps are left to the compiler. I didn't give any examples for the last categories, because many programming languages mix features from both. (Go aswell).
 MDC.put(...); try { ... } finally { MDC.remove(...); } This is what I usually go for. It's a _lot_ of code and better way would probably be a small helper method that returns an `AutoClosable`: try (MdcHelper.put(...)) { ... } Actually, a _nice_ way to handle this would be through decorators. JAX-RS example: @Path("/users/{username}") public UserData getUser(@MDC("user") @PathParam("username") String username) { ... } (Doesn't work ofc)
I downloaded it and there's a jre inside it. 
1. Go for the most restrictive visibility and scope possible in all declarations and usages. `private` &lt; `package` &lt; `protected` &lt; `public`. And don't forget about inner classes. 1. Keep your public API completely separate from your implementation. Provide API documentation for your public API. 1. Don't expose your implementation any more than necessary. But do allow for pluggable behavior via composition. 1. Related to the previous, don't use inheritance as a means of code reuse. Extract the code into a separate class and reuse via composition. 1. When inheritance is appropriate, consider carefully whether to make methods overridable (`protected`). Template method pattern is a good way to 'lock in' behavior that defines the "is-a" quality of a type while allowing subclasses to customize that behavior. (Declare the template method itself as `final`.) 
What I see usually done is that the class itself is package-private, and all the methods in it are public. Having package-private (`default`) methods is rare (and should raise questions, but should not be forbidden). And when I see a `protected` method, that usually means the method is designed for overriding in extending classes.
&gt; Replace the server certificate with a newer one, with a secure signature algorithm (such as SHA-256). Is there an easy way to do this or am I going to have to do it one by one?
You could switch to Kotlin. /s
Java is the most-used programming language in the world. Anyone claiming that it is irrelevant has an agenda unconnected to reality.
Hmmm 
no. return sql
Oh dear, the not-fun I had trying to get an mdc-using logging framework to work with RxJava and Retrofit...
&gt; i will still sometimes write code that way because I'm planning (or just removed) debug/logging info in the code blocks. Reading is a lost art.
Its been a while since I've used Eclipse regularly, but I think this is all possible in IntelliJ if you tweak the module settings.
I think optionals are ok but I'd prefer approach that is planned for c# 8 where you can annotate type as nullable simply by appending question mark.
&gt; There is simply no reason to use optional in a method that is called find something. in java null is a quasi-valid reference value. semantically this means that a lot of java code ends up equivocating on two states: something extant simply has a null value, or something doesn't exist and nullness is a signifier. the idea of optional ('maybe' in haskell, 'option' in scala/ocaml, etc) is to articulate an absence of value in a way that avoids the equivocation. it's also nice that you can use things like map, filter, etc on optionals. this can often make for cleaner declarative code that doesn't need a bunch of if/then/else noise.
*Laughs in obfuscationish*
If /u/qlkzy is right and a network classloader is established over an insecure SHA-1 connection, **you have an arbitrary code execution vulnerability waiting for you** when preimage attacks for SHA-1 are found. I repeat, *when*, not if. If you don't want your company to be the first one in the (bad) news once this happens, now is the time to pressure everybody in charge.
&gt; null values are easily the most performant solution to represent the concept of a missing value. this is a red herring for two reasons. first, optionals are a tool for software correctness. you're contrasting the pursuit of correctness with some unsubstantiated performance notion. second, i'd wager that the number of java projects where using some optionals will have a non-trivial impact on performance is vanishingly small. (i'd also argue for most of *those* projects java is the wrong tool for the job, but that's another issue.) &gt; If you use nulls, you have to check before assuming it has a value. nope. &gt; It's true that programmers get lazy and forget to do the null checks. yes - programmers are human. half of engineering as a profession is about mitigating the 'human factor' in projects. &gt; ultimately this boils down to the programmer taking the necessary steps to ensure he type checks nullable values. this is just a variation of "don't make mistakes and mistakes won't happen" or perhaps "write perfect code and you won't have these issues", etc. it's just ego, and it's largely meaningless. it doesn't contribute to developing reliable software. &gt; ultimately you have to choose who your end customer is... the user (where performance is important) or other developers (where code prettiness is important). aside from being another red herring, the two are frequently the same.
imho it seems like java/the jvm is the wrong tech for a use case where you're legit fighting a garbage collector or suffering because of pointer/reference chasing.
i'm not convinced you've said something that wasn't a strawman.
There are good benefits to java on these situations: only about half your code do you care enough about these issues and it is extremely easy to debug as long as you are careful with your misc.unsafe usage. Hotspot can be incredibly good at optimizing code paths. So i In cases where development time is very important but so it performance, Java has a use.
&gt; I have to use ifPresent() not really. you could use orElse, map, flatMap...
I'm not OP, so I don't have to be polite. Fuck off, troll.
Image you have a method `static String printCent(int cent) { return "$" + cent / 100 + "." + cent % 100; }`. It's simple and fine, until it needs to be internationalised. Now the method needs a `Messages` object: `static String printCent(int cent, Messages msg) { return msg.get("currency.symbol") + cent / 100 + "." + cent % 100; }`. It sucks having to pass the global `msg` object everywhere though, and making it a `static` global is clumsy. So you decide to make it available via dependency injection. And that's when you have to remove that `static` keyword.
ah, fair enough. given that people have achieved success with the jvm in these areas, i can see how it's not necessarily a 'wrong' thing as i had supposed.
java is fine, it'll be around for a long time. the ecosystem is massive and there are zillions of jobs. scala and clojure are cool, but are much smaller languages in terms of community and jobs. they're also jvm languages, and even if you were learning either, you're going to encounter a lot of java in the ecosystem... so you'll want a grounding in java anyways.
*dynamically typed*: if you declare a variable x, the 'type' of x can change. a 'type' is just a way of describing what kind of thing we're talking about; ie, is it a number, or some text, is it an animal, or a car, etc. in python, you can say: x = 'hi' # x has type 'str' (a bit of text) print(x) x = 123 # x now has type 'int' (an integer) print(x) here, x can be a different type whenever you want to change it. *statically typed*: when a variable is declared (or when it is first assigned), it has a type and it (in principle) cannot be changed. this is generally less flexible but can help us prevent certain kinds of bugs. in java you will get an error trying something similar: String x = "hi"; System.out.println(x); x = 123; // &lt;-- the java compiler will stop when it sees this and issue an error message. System.out.println(x); // &lt;-- because the compiler stops at the error above, this line will never be executed.
&gt; I mean, there is only eclipse really, if you're looking for RCP, aside from netbeans. Pardon my ignorance, but why not IntelliJ as well?
Welp, this might really suck. Working on multi-year-old software which uses the Netbeans RCP. If Apache can't keep Netbeans going, that will be fun to fix.
This is of course possible, but it is *really* easy to hop threads in modern Java, by design. You can change a single function name and hop execution over to a different thread in Java 8, and non-blocking webservers make this even more likely.
Spring Sleuth just solves this by wrapping your thread pool execution logic so that every time something is executed, the MDC is passed to the new thread context. I found this trivially easy to do myself with Monix's Scheduler (basically a thread pool, AKA ExecutorService). A solution that involves abandoning MDC and correlated logs altogether seems...extreme. Not sure why the writer of this blog decided to go that route, instead of just customizing his thread pools to be MDC aware.
i tried IntelliJ... the project management and not being able to see my 50+ projects/modules errors all in the same convenient view in a separate monitor is just so prehistoric.
JetBrains hasn't released the platform it makes its products on as a RCP. So you get two choices, Eclipse or Netbeans. Heard Netbeans was the better of the two. Edit: RCP means rich client platform, they make building complex modular GUI's much easier.
I've used Groovy on the job. I don't know a ton about the language, I'm very much not a fan of how I saw it actually being used. - I greatly prefer a statically typed language for work - Mixing both Java and Groovy I found unpleasant, my opinion might be different if the entire project was in Groovy but - - When I was job hunting it looked like most places had done the same as the place I used it, they tried to sneak Groovy in beside existing java code, you ended up with some Java and some Groovy which I didn't like at all. Also, the more likely they did this, the more likely their glassdoor reviews would basically be like "chaotic burnout place to work" - I get the feeling Groovy was trying to replace Java, failed, and now is fading out If I wanted to do a new language it would be Kotlin. - Most of the advantages of groovy but statically typed - Officially endorsed by google for android development, google seems to be trying to make it happen as well I'm not sure if Kotlin will take off, but it did not seem like Groovy was going to lead to a good career path unless you got lucky - a lot of the projects that had wedged Groovy into the project looked terrible. So I couldn't see myself going that way.
The package/file structure of java is very helpful and easy to navigate. I think this and many classes per file are deal breakers for me. This seems like a language trying to solve problems no one is having.
I agree. Plus features like local variable type inference and data classes are in the works for future versions of Java.
At the very least, Kotlin has data classes and works seamlessly with existing java code.
Didn't we just have Kotlin? How many more "better" Java languages need to be shitted out before clowns take the hint?
I see, thanks for the explanation. 
I personally prefer IntelliJ IDEA but in the end use what you are comfortable with. Try both, test your needs against each one and stick with the one you feel best with. I'd also advise trying the one you opt not to go with every major release to see how it's changed. Never know, you may switch.
Besides, you can already have more than one class in a source file, and having multiple source files in that structure often means smoother merges when working in a team. And I do love working in the IDE. Disclaimer: I'm a plug-in developer.
I just moved an API ASP.NET (Windows) to ASP.NET Core to Node and finally to Spring. We needed to get rid of Windows Server, so I naturally gave ASP.NET Core a try. But it wasn't up to the job then. I needed to meet a deadline and hacked a NodeJS / Express API. The "fun" starts when it gets complex und you find yourself spending a lot of time on standard functionality - especially data access and security. Now I'm with Spring and was also hesitant on wether to choose Java or Kotlin. With my C# / Typescript background I think Kotlin is truly fantastic. But I chose Java, because it's hard enough to learn a new Framework. I also use Lombok and IntelliJ. Java as a language never got in my way in any way. So I'd say: Just start with Java. Also keep in mind who is on Reddit, Hackernews, etc. Only a small fraction of the IT world is represented and we're enthusiats, so we love new things (languages, frameworks, ...). I know some fantastic devs who are using plain "boring" Java with Eclipse and get the jobs easily better done than me.
+1 (Btw, how do you know you're the 8th?)
In 2011 Scala already had lambdas, and many comments during that year said: just use Scala. Now, did we all do that?
I'm not advocating Kotlin, just saying there exists a better alternative with reasonable syntax and easy integration with existing java... unlike scala.
&gt; The rest of these are forgivable. This one is what sinks you. Sounds like an ego trip in my experience. "I'm reviewing your code, so I'm critical of you but you can't say anything back". Thing about code reviews is that the reviewer doesn't look through the requirements to make sure you actually met them. They're not evaluating whether your code worked, they're ignoring what your code actually does. I've seen a ton of time wasted on arbitrary formatting arguments, styling arguments, or feature abc that's new that the reviewer read on a blog entry last week. And the classic "I go light on my friends but am hard on everyone else" bit. Or the "super critical of new devs while nicer to devs of my same experience". I've been coding for a decade, and maybe 1 item in a code review was actually an actual bug, whereas a ton of time is wasted in "changing" things that don't matter. Did you use a for loop, while loop, iterator, or lambda expression? I just stressed for 4 days and was excited to finally get the db to do what I need it to do - who cares which loop I used. I'll tell you who, someone who's reviewing without any of the responsibility of actually meeting the requirements.
Hello, Just for the background, I am making living from programming. 1. No I don't remember everything. There are still situations when I am asking Mr. Google. 2. Whenever I am creating something, it always starting from defining the goal. Example of the goal is in this article https://enterprisemath.com/anomaly-detection-bag-of-words . There are 6 sentences and program is supposed to find the one which is weird. This is something small and realistic to achieve, which is what I would recommend you to do. Then just figure out the first little step to move towards it (e.g. it might be typing the main function). Once you are done with the first step, then do another. And keep going. Write a lot. P.S. Think about buying some book. These books for beginners ususally can give you a good start. 
' "out" and "by-reference" parameters ' And I'm 'out'. This is a language level anti-pattern. 
kotlin - you can't even do incremental builds with their command line tools.... no real love (or support) for their (possibly deprecated?) ant target... pass....
Intel Core / 2gb RAM / HDD and latest IDEA CE. Works pretty well. As former Eclipse user i see no performance difference.
Seems like all they wanted was C# on the JVM.
Did you find a nice solution to this?
Looks interesting, what are people's experiences with this?
&gt; Let's face it: Nobody loves working in Android Studio, Eclipse, or NetBeans – the IDEs are bloated, clunky and unintuitive. I absolutely love working with them, in contrast to the advertised "text editors". &gt; On Windows, fully integrates with Visual Studio, Microsoft's flag-ship IDE. If the IDE's mentioned above are bloated then VS certainly is aswell.
If you keep throwing something might stick... ?
Yep; decorate the executor so that job submissions are decorated with the current MDC; when they start they apply the MDC, delegate to the inner runnable then unapply the MDC. It's relatively clean, and the same solution applies on a Scheduler (for RxJava).
Yeah, the "enhancement" of multiple classes per file was a weird one. I (and I think most people) find the correspondence of a filename Foo.java with a top-level public class `Foo` to be quite helpful. The actual restriction is against multiple *public, top-level* classes in the same file. It's possible to have multiple top-level classes in the same file, with at most one being public and the rest being package-private ("auxiliary") classes. But it's rather frowned upon to have auxiliary classes be used from other classes in the same package. Indeed, `javac` warns about it. So you might as well use a nested class instead.
Who the hell uses ant in this day and age?
Basically.
I wish this was more popular. Spring is so slow, especially in unit tests.
&gt; (Also, whoever started this new language trend of putting type declarations after the variable name belongs in an asylum.) I mostly agree with you, but to play devil's advocate, I think it's fitting for two reasons: first, it means the left side is free for var/val. Second, if you leave off the type it's inferred, so it's pretty seamless to do: ``` val foo:MyObject = MyObject() val bar = MyObject() ```
I have equal distaste for languages allowing you to leave out the type in a language with strong typing. It hides valuable information from the reader. It also doesn't read well. Anyone who's taken high school algebra knows "let x equal ten." So instead of "let the integer x equal ten" (int x = 10) we have something that just doesn't paste into English as readily...and uses more extraneous punctuation. It's strange that a language that seems to want to "fix" Java's historical penchant for verbosity has made long-form variable assignment much more so. And the "val" keyword is just a complete waste. Java's use of the type in its place makes more sense, as does Python's altogether lack of a prefix during assignment. The only reason I see for it is to make people who basically only know JavaScript more at home...
How this is done depends on how your environment manages certificates in general. However, I (perhaps naively) wouldn't expect you to have a very large number of individual certificates, unless your environment is truly byzantine---if nothing else, certificates anchored on public CAs cost money. To be clear, we aren't talking about certificates client machines or signatures on application JARs: these certificates establish the authenticity of the server hosting `https://internal.yourcompany.com` etc.
Spring 5 GA is released Sep 21 2017. That's also the same date as Java 9 SE GA.
&gt; it seems that my home laptop with Core i5 and 8 gigs of RAM is not enough for that monster hog of intellij disable auto indexing and problem solved
hey the last time i looked at some "modern" fashionable build system it was like cracking a nut with an a-bomb - I was in danger of spending longer trying to write its config than the project itself, in contast I have a simple ant template that I copy into a new project and just start coding... no drama, no upstream polution... just works.... 
Apparently being organized and having a structure is a limitation. Filename: Candies.class Inside the file: public class GetInTheVan{...}
&gt;I have equal distaste for languages allowing you to leave out the type in a language with strong typing. It hides valuable information from the reader. With respect, if the type is obvious I don't think there's a need to restate it. I see what you're getting at, though, and I agree. C++'s auto and D's auto make things far more frustrating than they need to be, especially in tutorials. I do think that when you're just replicating the name of the constructor though, it adds verbosity without adding readability. I think Kotlin got this compromise right: optional type when it can be inferred. That way you can add readability when it's needed and omit it when you favor brevity. &gt;It also doesn't read well. Anyone who's taken high school algebra knows "let x equal ten." So instead of "let the integer x equal ten" (int x = 10) we have something that just doesn't paste into English as readily...and uses more extraneous punctuation. Let x be an integer with value ten. &gt;It's strange that a language that seems to want to "fix" Java's historical penchant for verbosity has made long-form variable assignment much more so. And the "val" keyword is just a complete waste. Java's use of the type in its place makes more sense, as does Python's altogether lack of a prefix during assignment. The only reason I see for it is to make people who basically only know JavaScript more at home... I respectfully disagree. Val tells you the value is immutable. Var tells you it's mutable. Smarm aside, I think it's important to have something to designate you're declaring a variable. I rather like Python, but one of my gripes is that it's too easy to spell a variable slightly wrong and get strange, undefined behavior. Same with JS, a language I strongly dislike. If you have x0=10; and some time later inside a branch you have xO=50; that can cause hours of headache that could be solved by the compiler.
Why would you use Spring in a unit test? Why not just use `new` to create a new instance and manually wire in mocked or instantiated dependencies? Spring and DI in general are for integration, and should only be used in integration tests. Even then, Spring itself isn't slow, it's all the other beans that get created and initialized in the application context. In which case, to speed up integration tests, use limited test specific application contexts.
In my opinion ContentView = R.layout.main; is much more confusing than setContentView(R.layout.main); Mainly because: - = is used only as an assignment here it is used as a function call - uppercase first letter is used only for classes, here it is used for function call setContentView will give you a very clear idea that there might be something else going on, it's not just a simple assignment. 
While it's true that 99% of Java developers don't really have any idea what they are doing I personally believe learning Java is the first step to becoming an expert within the ecosystem. I understand people use Clojure and Scala for particular purposes and that in almost all cases learning Java first is pointless in those cases. However I personally believe to be a well rounded "JVM" expert you need to learn Java. Over the last 5 years I've gotten really deep into the JVM ecosystem because my company has at least 30 applications built on different JVM technologies (Java, Groovy, Bean Shell, Scala, etc) as well as many platforms (Grails, Liferay, Hybris, ColdFusion, etc). I personally found Java to be a good foundation to build a solid knowledge of the JVM off.
I disagree with your assertion that C is a bad start. I learned to program in C / Basic / MIPS and I do NOT regret it. You absolutely need to work at that level before working at a higher level if you want to be a well rounded engineer / scientist. If you just want to be a code monkey (which is not really anything to look down on) then start wherever you want. If your goal is to be a legitimate computer scientist or software engineer I strongly suggest a background in CSEE and beginning with C / Assembly / Embedded. Just my opinion.
Unrelated question but can you post your curriculum? I am interested in seeing what a Pakistan CpE degree is like
The point where unchecked exceptions fall down is in handling mapping of collections: you will have to catch any exception in the mapping function go back to the described functional approach, then filter for errors and handle them. Edit: autouncorrect
Interesting topic, i have the same problem with spring and @Async methods
they should skip EE '8' and call it '9' to sync with SE
I know. But that's what people do.
They could catch up. Under the Apache Foundation, Java EE could have a shorter development cycle.
How is the exception management a *great improvement* compared to C++? The OP talks about the mid 90ys - when did exception management arrive to C++? Really later than that? It has definitely been into C++98 - so the compiler support should be there at least from this date. Of course the mechanisms differs a bit, but the overall concepts are pretty close!
&gt; I disagree with your assertion that C is a bad start. I NEVER said that C is a bad start, i just said that the teacher was not ideal, at least not for students who had no exposure to programming before ! she jumped into complex questions WAYYY too quickly and THAT is what caused me and alot of others in the class to get off on a bad start in coding, im NOT putting the blame on C. that's all. now that i delved fairly deep into some programming, i see it's not something out of the world. it's just logic entwined very closely with other logic and it takes time, poise and tact to understand that, along with alot of patience. Hope that clears it up. now, as to what i want to be/do ... i don't want to be a scientist, nor a code monkey (lol wth is that) i just wanted to design AAA video games or design the hardware that runs them ... high perf. hardware optimized for top class games ! i love games and anything related to them would be a DREAM to work upon i'm still very confused as to what to do, where to go regarding my vigor for games ! any advice in that regard would indeed be appreciated !
sure this was the curriculum applicable to my batch; [see here](http://www.neduet.edu.pk/cise/docs/courses%20for%20batch%202013-2014.pdf) and this is a revised version for subsequent batches; [here] (http://www.neduet.edu.pk/cise/docs/courses%20for%20batch%202014-15.pdf) and there's probably another revision coming up in the near future but not yet officially ratified by the university
disabling indexing means invoherent dependencies, slower refactorying... Why would i even bother when Eclipse uses 50% less RAM, 66% less disk space on base installation and CPU is not hitting 100% usage when i refactor a simple variabile name? IntelliJ creators are simply not interested in making the IDE more resource efficient. Fair enough, but stay away of my laptop then.
Now you're just sparking the whole package by feature vs package by layer discussion
I'll most likely after current job look for programming job. What would you suggest I focus as a Java (off Android ) programmer? Sql+spring in Java? 
Oh, well, my company is using JEE 5 specification. Might as well take a look at the specification to see how things are going to be in 15 years here.
&gt; (I only used the community edition of IntelliJ) Well that's a bit unfair for a comparison then.
I used to work with eclipse for many years and always thought it was kinda bloated. Getting slower over time. I used to have 3 independent installation for eclipse for the "domain" of it, because I thought every plugin made is a lot slower. A few year back I stumbled over intellij and it didn't felt so cumbersome, so cluttered and was in my opinion a lot faster than eclipse. Though I miss a few features of eclipse. But teaching yourself a new ide can be painful at times. Best feature. the terminal that just works without me doing anything. it is there. working :D Personally ... money well spend on intellij
The thing is, Java EE 8 is aligned with SE 8, not SE 9 (how could it, SE 9 is not released).
&gt;It makes your code a lot more clean and easier to follow. Easier for who, the developer? Because it definitely isn't easier on the poor operations team trying to debug a production issue. The issue I have with DI is that you can't tell by looking at the source code what class will be providing the implementation of the interface, you can only know at runtime when there is a stack trace that shows you the class names. So when it comes time to track down a runtime problem and debug an issue and you see you have an interface Foo but nowhere in the code is a private Foo foo = new FooImpl(); but instead is a @Inject private Foo foo; then you have to figure out what is providing Foo. Is it FooImpl, is it Bar, what? Which means support becomes more costly, and the largest cost of any software project is not the initial development, it is the long term running and support of it.
For those not in the know: https://blogs.oracle.com/theaquarium/opening-up-java-ee It hasn't been decided which foundation will pick up Java EE. Likely candidates are Apache and the Eclipse Foundation.
Since they have donated NetBeans to Apache few days ago, my guess is that Java EE will be Apache too. But, as you wrote, we still don't know yet.
Why are you so extreme about it?
Are you sure? I had some problems trying to run Mojarra inside Tomcat, because Tomcat still doesn't support Java 9
Is this is a recurring and expensive production issue? I usually only ever have two implementations: the actual implementation and the test mock. I'm interested in knowing more about the code that would make this a problem, how many implementations does your DI system usually have to choose between?
If you only ever have 1 implementation and 1 mock, then what is the value of DI? Constructing and passing in a **new** instance of the implementation in a set or constructor method will make it work fine for both production and testing, so why worry about DI?
Interesting, I haven't thought of this from the devops perspective. From my experience, I don't often such a situation where you have more than two implementers of a given interface. Perhaps this can be solved by injecting implementations directly instead of interfaces, where possible? During development, IntelliJ is often smart enough to find any possible implementers of an interface easily, not sure how it works on devops side and what tools are used.
If someone new to Spring googles "spring testing" they will immediately find the Sprung docs for integration testing, and without more experience think this is *the* way to test with Spring. What you suggest is actually the way to go, and is a matter of education.
The Eclipse Foundation has Microprofile, which already includes most Java EE vendors. It could go either way. https://projects.eclipse.org/projects/technology.microprofile
For me the value is in the testability. I've had systems that were (unit) untestable because of hard links to static initializers, network calls inaccessible from dev, etc. So being able to pass in dependencies via constructor like you said for me personally is very useful. DI containers offer other things like scoped instantiation (objects which are injected over specific scopes like per thread, per session, etc) which I haven't used but which I imagine some people find useful and which I also imagine complicates things. So you don't like DI and I do, that's fine, this isn't /r/changemyview :) The question for you that I do want to hear more about is the nature of your DI problems in production? How are you using DI that is problematic and what (if anything) can be done to mitigate it?
That's absolutely the case. Mojarra required Java SE 8, absolutely not Java SE 9.
The problem is with this optional Maven dependency of Java API for JSON Processing: &lt;dependency&gt; &lt;groupId&gt;javax.json&lt;/groupId&gt; &lt;artifactId&gt;javax.json-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; It requires Java 9 for some reason. You can see it here: https://github.com/javaee/jsonp/blob/master/pom.xml More discussion here: https://bz.apache.org/bugzilla/show_bug.cgi?id=60688
The one by Jeanne Boyarsky and Scott Selikoff
First make sure you know well plain java. Do some sipmle programs, read web tutorials or beginners book. After that, read Effective Java from Joshua Bloch. https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683 You don't need to read every line of this book, but at least you should know roughly what is going on there. Regarding the framewors. There are zillions of them so you have to be selective. It really depends on what you want to do. Spring + sql is good for web applications. These are for example used as a administrative portals. It's kind of job safety since there are many of them and won't disappear soon. Go for that. Now just a little advice for the job. The salary of the programmers goes down since it's becoming still easier to create generic things. To me it turned out to be really good deal to combine it with mathematics. Don't look to yourself only as a programmer, bring something more to the table. Let me know if you need any help. P.S. I am thinking about flushing out some posts and examples related to computer vision in the next couple of months. Is this something you would be interested in to see? 
That is not true because it still indexes but not automatically (same as eclipse). When you disable it you have to start saving changes the same as eclipse (ctrl s) and it start indexing at that moment. You can also decrease max ram limit editing the vm options and set the same as eclipse. Use the IDE you want, I just wanted to advise anyone with the same problem.
Thanks ! 
Dependency injection is not about using interfaces everywhere. With mocking tools like Mockito, a non-final concrete class is flexible enough for unit testing. 
Now Java EE projects look like Spring projects: dependency injection everywhere. But configuration files are separate and you have just one Maven dependency.
I'm positive. Java EE 8 requires Java SE 8, not SE 9. 
I found the part in the Java EE spec: &gt; **EE.2.4.1 Container Requirements** &gt; This specification requires that containers provide a Java CompatibleTM runtime environment, as defined by the Java Platform, Standard Edition, **v8** specification (Java SE).
mala gupta
&gt; Followers of a purely functional approach would probably discard the previous snippet in favor of something like that: &gt; &gt; public Either&lt;String, Failure&gt; readFile(String path) { &gt; if (!file.exists) { &gt; return Either.right(new FileNotFoundFailure(path)); &gt; } else if (!file.canRead()) { &gt; return Either.right(new FileNotReadableFailure(path)); &gt; } else { &gt; // Finally read the file &gt; // Depending on the language &gt; // This could span seveal lines &gt; return Either.left(content); &gt; } &gt; } You would only use the Either monad with an API that supported idiomatic use of Either, e.g. (ignoring the method implementations): class FilePath { static Either&lt;Failure, FilePath&gt; open(String s) { return Either.right(new FilePath("/path")); } FilePath(String s) {} Either&lt;Failure, File&gt; exists() { return Either.right(new File()); } } class File { Either&lt;Failure, FileHandle&gt; canRead() { return Either.right(new FileHandle()); } } class FileHandle { Either&lt;Failure, String&gt; contents() { return Either.right("DATA"); } } and your client code would then look more like this: Either&lt;Failure, String&gt; contents = FilePath.open(path) .flatMap(FilePath::exists) .flatMap(File::canRead) .flatMap(FileHandle::contents); (as /u/jbgi points out, in practice you would use an IO monad)
The NetBeans case was different. It made sense that they did not donate NetBeans to the **Eclipse** foundation. :)
If you are looking for good study matieral, I would suggest one with practice tests. http://enthuware.com/ is a desktop program that contains several examples and can even pick tests that center around your weaknesses. EDIT: Another nice feature is after the tests you can review why the answers you choose was right or wrong. 
I've got another -- leaving compilation warnings scattered through the code. It takes a while to understand what different warnings in different contexts actually mean, and why they represent something potentially dangerous. So learners tend to get numb to them quickly and often go years before they start paying any attention to them at all.
sadly this version incoherence will mislead prospective users.
_Sadly this version_ _Incoherence will mislead_ _Prospective users._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^whistlin3 ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
But if you have an exception, you should already see in the stacktrace which exact class is creating it (i.e. the Foo implementation). No? If what you are searching is not an exception, then your classes should have efficient logging. I feel that looking at the DI system for **runtime** errors is not something that should happen in **production** anyway. You should have caught these problems during development.
not quite, because for IO, the purely functional approach is to use `IO` actions for interacting with the outside world. And in `IO` it is perfectly fine to throw (and catch) IO related exceptions. Also it does not make sense to preemptively try to test for exception cases (exists/canRead) because those cases can still happen anyway.
Cool, if that's the case i will give it another shot. Thanks!
And you can build an A-bomb scale nut cracker in Ant if you want.. the important question is *do you need it*? You can write KISS build files in Maven and/or Gradle just as well as in Ant, just because you're familiar with one system doesn't mean everything else is overkill. And after writing that Gradle template just copy it into a new project and start coding.. just works....
man, does the C# community have to deal with this constant drivel? How many "better than Java" languages have appeared in the last 10 years and where are they now?
I think you should learn Java b/c it sounds like you still need to grasp many prgramming concepts and why not Java! As someone who is going back through the language step by step since college b/c I went IT and not developer it is good for concept acquisition. It's syntax is born out of C which many languages do, java is in widespread use so worst case find a job dev in java and will teach you high level logic design of data structures, programming structures and thinking in OOP. There are Universal concepts that can be translated to any language, regardless of implementation, which will behoove you to know, op. You will bang your hand many times when learning any language who be left bewildered b/c of lack of underlying knowledge or support available. Lot's of resources in java community that has your back. Don't hesitate.
Using a loop to lookup a value in a hashmap. I've seen this from a couple of developers now and I think I'm going to make it my tell-tale sign for spotting someone who's inexperienced.
&gt; The issue I have with DI is that you can't tell by looking at the source code what class will be providing the implementation of the interface, you can only know at runtime when there is a stack trace that shows you the class names. This is not an issue with DI. You can `@Inject` concrete implementations instead of interfaces, and you can accept interfaces in methods or constructors instead of concrete inplementations. So, without DI you'd have the exact same problem: No idea about the actual implementing class. But that is actually a good thing and the reason interfaces exist in the first place. Complaining about the very basics of abstraction sounds kind of odd to me.
Fair point. I was addressing the API design point with using Either consistently and not IO generally.
I personally never let Hibernate generate anything as it has been proven to be less than ideal. I design the database tables and corresponding entities together to make as much sense programmatically and logically yet also take advantage of DB design best practices and normalization. In that case Liquibase is fantastic because every change gets applied automatically, invalid states and collisions of different versions of the database are flagged, every developer is always on an up-to-date database if they're running their own (optional, of course, if he/she is working on a feature that also requires database changes), etc.
yeah, that was nitpicking on my part. your api is very nice!
Some of the features are nice. Some are not. Unfortunately I don't see this project taking steam, which is sad, because I know how disappointing it is to do something with all your heart, without understanding the market you are addressing. I guess I've been there, I've done that. The programming languages world is saturated, nobody needs another Java killer. Or Java++ ...
NetBeans &lt;3 On any PC &lt; 5 years, it's sleek enought for me. But above all, it's smart enought to let Maven do the builds and it does not try to mess with it.
Hi.
SQL doesn't sound to exciting and creative hehe. But it seems like a basic thing every programmer should know. I am actually an accountant, with finished collage of 5,0 average. Hopefully that will help me in my future path as a programmer. Money is not what I am currently looking as a programmer, I would be happy with less as long as I gain expirience. I like to build things (I've been doing music for last 10 years or so www.soundcloud.com/gottolovehouse). Freedom of being a programmer is also a thing that excites me. Do I want to work for company? Shall I free lance, shall I open family software company with my kids one day ? Who knows... But I like the freedom it gives, you can do anything.... I want to backup my java files whenever I want? np, i programmed it the other day, so on .jar click my files go on my E drive, do I want to have a diary? np, i created a diary. So much stuff...its amazing, what ever your mind can think of on pc you can do it. Computer vision? Could be an interesting read, but wouldnt excite me that much.
Good point
Bought Herbert Schildt's Java: A Beginner's Guide and read through most of it. Also went through University of Helsinki's Object Oriented Programming with Java course (Part 1). Best way to learn is to write programs in Java, period.
There's no argument with manipulating an object via an interface definition, but having an external system decide on what the implementation value of an interface is at runtime versus having code instantiate the implementation with a simple **new** command puts a layer of abstraction that isn't necessarily discernible by a simple review of the source code. In order to determine what the implementation class is, you have to know what is performing the DI and where/how the DI layer is configured to be able to review the setup.
Perhaps I'm jaded, but I'm inclined to look at this statement vis-a-vis historical performance... and decide to not hold my breath.
You will never catch all possible error conditions in development unless you can cover every possible data edge case your code could possibly see. So you capture the errors and log them then research the situation. Hopefully you have sufficient logging details to identify what class is injected so you know what source to look at.
Meanwhile, our hadoop cluster at work is still running Java 7. If this happens, Java 15 will probably be out by the time we get to 9.
They want to catch up to JavaScript which has a yearly release.
You just described DI. Perhaps you're confusing libraries which provide a framework for automatic DI resolution with the pattern?
Spring for REST does not require a Java EE server - just a Servlet runner, allowing for REST service creation with just Spring Boot and Tomcat. Perhaps these Java EE features do require a Java EE container, thus most likely a commercial Java EE server?
Really? This is the yardstick of improvement now, new version numbers at regular timed intervals?
Once it's not at current my work place through a receptionist. Yes, people do this.
YEET
What makes yours different from all the others?
Well one of our admins has coded a very interactive bot, and we make challenges for people to make things for rewards.
It's empty.
I pity you. Hadoop was a blip of tech excitement due to misguided google publication (widely misunderstood) that has milked big data line for a while. Repeat after me - "my big data is a 10MB flat csv file. I don't need a 100 node cluster to process it"
8u131 introduced a killswitch though.
What is? The server is brand new. 
Doesn't look like it's requiring Java 9. Just an optional profile for 9 that's not enabled by default. 
&gt; 8u131 Wat. Really? I honestly haven't heard anything about this. Is there a source?
the server was made like 40 min ago lol
JAX-RS does not require Spring boot - just a Java EE environment, allowing for REST service creation with just Java EE. Also, which commercial Java EE server? TomEE? WildFly? Payara? Please, enlighten me...
Agreed - JAX-RS does not require Spring or Spring Boot. I was just trying to answer your question of why ones might use Spring. In brief: not everyone has or wants to use a Java EE server to run their Java web applications/services.
I prefer a LinkedIn message.
There's a talk whose title relates to this, among the lines of my Python script is better that your hadoop cluster
Can you explain me why do companies run such "outdated" JDK's and etc when the code "should" be backwards compatible? 
Java 20 Release notes - Apart from correcting more bugs in threading due to our self imposed tight deadlines, we have no new features
Play WS is Java, and is based on AsyncHttpClient: https://github.com/playframework/play-ws#java
Because they directly use or use libraries that use anything outside the java/javax package hierarchy (com.sun.* or other JVM internal classes) which is not guaranteed to be backwards compatible.
I get that, but the stuff I'm using it for is actually a decent use case for it. Quite a few jobs that handle hundreds of millions or a few billion items daily adding up to a few hundred gigs. Cluster is pretty small too, but there's no way this stuff could run in a reasonable amount of time without either hadoop or some outrageously expensive multi socket server and the much more complicated programming required for that.
In my case, lots of things are sharing that cluster and a few can't run under 8 for various reasons. Old versions of Spring seem to be a common cause of problems.
Mark Reinhold mused on this I believe back in May. I'm curious how library vendors will view this? With more iterations of Java out there, might lead to a bigger testing requirement. Overall I think this is probably a good thing. It feels like Java, when compared to other languages, has been somewhat stayed. Faster release cadence means we don't have to wait until every feature is ready full vetted and complete before we see a new iteration of Java. There were several features pushed out of JDK 9, it's nice to know that we won't have to wait three years to use at least some of them. 
Not to be contacted at all.
Yes. http://www.oracle.com/technetwork/java/javase/8u131-relnotes-3565278.html "JRE Expiration Date"
&gt; adding up to a few hundred gigs Love a fun challenge. I can bet you 5 days of consultancy fees at $1000 p/d that I can fit that into a 1h job (max) on m4.xlarge. If the dataset is incremental - probably a near-real-time job on m4.large.
Email or linked in. GitHub issues are better. No work place contact. 
&gt; One toolchain, four languages, four major platforms: Elements is a modern development tool stack for creating applications for all of today's platforms, using either our very own Oxygene Language, C#, Swift or (current available as preview) the Java Language. Wow, these people love making languages. 
Java that runs on any platform. Like .NET or cocoa. 
Probably that the amount of JDBC implementations was relatively small.
If you want to build a community you should not splinter an existing one but add to an existing one. There already is at least one Java Discord chat, see [here](https://www.reddit.com/r/javahelp/comments/5yaq8w/active_community_for_all_of_your_questions/).
LinkedIn; it's what it's for. I have no issues whatsoever with recruiters contacting me via LinkedIn if they keep it professional and matter-of-factly. Just send me an in-mail with details about the vacancy. There's at least a 90% chance I won't reply (because most experienced devs already have a job) but you improve the chances of at least getting a "thank you but I'm happy where I am" message if you give me details about the job (what tech stack, java version, responsibilities) and the pay. If you ever contact me at my place of work (which is at a client in my case) you might piss me off enough to go and contact your manager. Don't do that. It's pretty embarrassing. 
Floating point arithmetic in banking system sound quite bad. Runtime access error sound like reflexive api... I'm not sure if it is the JVM that is buggy or the way you used it. I don't blame at all, you should have right reasons to do this. My point is even if you wait others to upgrade their JVM and finding bugs, you will have problems if you do weird stuff cause others don't do that :) Btw having a nice test coverage make migrations like that painless
Ok, I'm sorry but this is how I am. Whether it is successful or not is a risk I'm willing to take. Peace.
dont worry mate, we are all still on 5 and 6 with a little 4, at my work (banking)
in reality most real large enterprise apps arent. Spring, mule, tomcat, all are funny about which versions they work with. Plus they change the JVM aguments a lot, so you need to tweak your tuning configuration.
There are often changes that "should" not affect applications if they use the api properly but in the large applications in enterprise you're bound to have some code that does break from the tiny changes (such as hashmap iteration order).
This is oracle jdk only isn't it?
So you don't care about community, all you care about being the 'boss' of people joining your server. Check. 
Does this mean major (numbered) versions, or updates with mostly (only?) bug fixes? 
My opinion - your subject should be informative. Next time please specify what you are looking for opinions of in the subject. Same goes for any email. "Are you interested in this" is a bad email subject. "Are you interested in a programming job" is slightly better. "Are you interested in a programming job at ACME Inc." Is much better. If your message or email title feels like a clickbait you are already cultivating bad opinions about you and/or your firm. 
Yes, I would, but only if it has a meaning. Have you studied the SOLID principles? The first one is the Single Responsibility Principle and stats that 1 piece of code should have 1 responsibility. My rule of thumb is : try to describe the role of your class. If your description contains the word "and", try to break it in two and try to make the role of each class as obvious as it can be.
You will always see the concrete implementation name in your logs (the stack traces should print them out with class name, method and line number). What really fucks up everything is when a Proxy instance is used. Then all you can know is that some framework did some black magic and you'll have to dig into heaps of obscure and indirect code.
Sorry but "just use new" doesn't cut it if you have many autowired/injected dependencies - you'd have to create LOTS of new instances to bring up a test case. As a unit test is meant to run over a "small, self-contained" piece of code with no dependencies on external stuff, you are likely to create more mocks and when you are working with integration tests. I have created some tests to run on an in-memory database and it takes 2 seconds to run 50 tests. Database creation/population/cleanup included. I just use a configuration class that loads all beans used by the "real" app, and override the injected bean to do whatever the test needs. For example: @Configuration() @Import({AuthenticationServiceConfiguration.class, ServiceConfiguration.class, SomeOtherConfiguratio.class}) public class TestServiceConfiguration { //assuming there's a Utils class being injected one of the configuration classes of the real app. //for the sake of the example, assume the original sends email alerts when an exception occurs, among other things @Bean Utils getUtils() { //return a mock that extends from the original and does stuff differently for testing (won't send emails) //This one itself can have autowired/injected dependencies. Spring takes care of it. return new UtilsMock(); } } Then I create my base test for DAOs like this (the following uses TestNG): @ContextConfiguration(classes = {TestServiceConfiguration.class}) public class BaseDaoTest extends AbstractTestNGSpringContextTests { @Autowired public OrderDao orderDao; @Autowired public ProductDao productDao; @Override @BeforeClass protected void springTestContextPrepareTestInstance() throws Exception { super.springTestContextPrepareTestInstance(); } @BeforeClass(dependsOnMethods = "springTestContextPrepareTestInstance") public void setUp() throws Exception { //database initialization goes here. Create everything and possibly populate data } } This basic structure allows me to create lots of test cases that run on a test database, and their code just looks like this: public class CustomerDaoTest extends BaseDaoTest { @Autowired CustomerDao customerDao; @Test public void testCustomerOrderQuery() throws Exception { //executes query to return orders of a given customer //just testing that the query is sane and the code that reads from the result is OK. } @Test public void testNoDuplicateCustomersCreated() throws Exception { //run process to insert customer from a JSON twice and see if only one is in the database } } Assuming that `Utils` class that is injected has some specific code to for example send e-mails with errors in case of exceptions, and `UtilsMock` overrides that behavior to prevent this from happening, how would you setup test cases for 100 DAOs by "just" using `new`? You'd have to use `new` in your 100 test cases, just to set a single mock. Also you'd have to manually make sure that the order of initialization of all dependencies is sane. Not fun at all.
Three remarks: * There's nothing wrong with using an instance (of any class-type) just once. If you ~~use lambdas (which are inner classes technically)~~ or start threads, you do the same. * Does this inner class serve a purpose? For instance, if the two methods share some state in fields of the inner class, I would definitely go for it. * If the inner class does not serve a purpose other than grouping methods, does it make your code more readable? You're correct that then it's the same as putting them in the parent class directly, so you better make sure it actually increases understandability of your code rather than making programmers wonder why that inner class exists in the first place.
This could probably work a lot better now that multi release jars are a thing. Just gotta get everyone onto Java 9 as a baseline...
Okay... so nag messages, rather than a killswitch. 
Thanks for the advice! 1) This is helpful because every time I realize I am only using an instance of a class once, I question whether I can just make the methods static or make it an inner class. 2 &amp; 3) The (potential) inner class shares a few different fields so I wouldn't have to pass any parameters into the public methods. In that sense it does make it easier so maybe the inner class is the way to go.
I have not studied the SOLID principles in depth but will look into them more soon for sure! That sounds like a reasonable rule of thumb. Thanks!
Probably a bit off topic, but what's the benefit of getting certified? Aside from good possibility to fill gaps in your knowledge (if any). Thinking of getting certified too, but that doesn't seem like a very required thing on a job market. 
Using floating point calculation when you need precise result is a really big mistake. If I was your client I would be mad that you relly on so imprecise representation of data : loosing cents in the end make you loose millions. Instead you should use BigDecimal !!! But that's not the point of the discussion. So if your project is vital and has a lot of legacy, you should avoid jumping on every release. Method visibility is something you can detect pretty fast cause your project does not compile. For your floating point, no need to have precise tests, you can use property-based testing ! https://www.youtube.com/watch?v=5pwv3cuo3Qk
Okay, I understand now that Enum implementation is the best way to make a Singleton. But I can't say that was this subreddit community that helped me understand why...
Of course, but you also have to realise that not everyone wants to use Spring or Spring Boot to run their Java applications.
&gt;Do not post tutorials here! These should go in /r/learnjava.
Are you asking a question or trying to make a statement?
Of course - fully understood and agreed. Spring is not for everyone. Best choice really depends on the organization, team, maintenance strategy and task at hand.
Its really not that hard to use spring-boot without fat jars if you want to only transfer files that have changed, if that is really an issue for you. You can also use the spring-boot launcher without actually using the framework itself. Spring-boot hello world non-web app comes in at 6.5MB. Hello world app, no dependencies but using spring-boot loader comes in at 88k.
Lambdas are not inner classes. They are build on top of invokedynamic. https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood
Thank you, wasn't aware of that.
I think he's practicing posting on reddit.
Yeah. But nobody in their right mind uses openjdk.
Indeed. Most features in Java 9 were already complete like half a year ago and were just waiting for Jigsaw to finally finish.
There are other 'risky' industry sectors that pull through and update. There might be bugs in the new Java version, but there are definitly bugs and security holes in the old version. Additionally continued development in older Java is more tiresome and you will find less developers that will put up with it. To me it seems that especially the banking sector does like to just increase the manager bonus and in turn keep the Cobol mainframe running in the basement.
Okay, Based on what you said, I had to make assumptions. Sorry if I "hurt" you making thoses. I don't expect you to test framework : NumberFormat is from jdk, you should not have to verify that it work. One question, when did you make your migration? Was java 8 stable at that time? I was certain that java update were fully retrocompatible and I never had any problem with it.
Can confirm. I work in the banking sector and our apps were just recently upgraded to Java 6 last year. Fortunately, newer apps are being developed on Java 8.
What the fuck do you want to do with writing this sentences?
In this particular case you don't even need `AtomicReference` or `volatile`. The `toString` method fetches the value of the `stringCache` field, and then computes and caches a new string value if it got a `null`. The Java memory model (17.7) guarantees that reads and writes of reference values are *always* atomic, so even if a bunch of threads are reading and writing that ordinary field simultaneously, each reader either gets `null` or a complete reference to some initialized String. The worst-case situation is that more than one thread gets a `null` and they independently generate and cache the same string value, so it might duplicate some work but because those writes are atomic nobody ever reads a partial reference (or a reference to an incomplete string). So as others have noted, the bug here is that the JVM is not following the memory model correctly.
Major releases every six months. 
A 600 line class in java is not necessarily excessive. When you move from sample/toy applications to real life ones, some classes will be that long or larger. Most ~~will~~ should not. As /u/sampledev said, do study **SOLID** In the case of class ( or method ) getting too large, see if you cannot apply **S**. When working on smaller applications, **S** is the most critical. **O** comes in close second. **LID** are very important, but *usually* apply to larger application or libraries, and do not get applied as often regardless. **S** gets applied for every line of code you write. It is usually defined for classes, but applying it to methods makes it easier to reuse them. I even apply it single lines of code. It makes it easier for the next person who has to read your code to understand what you meant to do. Remember, though, that **SOLID** they are *principles* not *laws*. Sometimes, you have a good reason not to follow them. Sometimes.
 I prefer IntelliJ because of its indexing and great out of the box support for everything on a Java and web development stack. But that's just me, it's very subjective. There will always be people that say "I'm more productive using X", X being emacs, IntelliJ, Atom, eclipse... Or people saying "Eclipse is better because it's free".
Came here to say this. Also, don't make it an overly long message. Short and sweet.
But can't you just get community edition
It's mostly down to personal preference really. If you're already acquainted with one then just stick with it unless you have a good reason to switch.
That's a bad idea in general. You should be injecting interfaces. Usually the problem of which bean is instantiated where should be taken care of by reporting at runtime of your DI container. As an example, Spring has no problem of giving you a list of its Autowired components. To go more into detail with Spring and IntelliJ, you can even click an icon that points you to the bean definition. Once you setup Spring correctly in your project settings.
&gt; great out of the box support for everything on a Java and web development stack. Unfortunately not for OSGi.
IntelliJ has a dark theme. Eclipse has dark [eye cancer](https://i.imgur.com/EavoEXY.png).
Eclipse is a defacto industry standard. Knowing it well will help easily fit in at many jobs. Many online educational resources "teach from Eclipse" ( screen shots etc ). Eclipse is free of charge.
IMO you shouldn't be using Inner classes at all and they're a code smell to me. I generally prefer to pull them out into their own class if they really need to be a class at all.
People say you have to pay for intellij but community edition is FREE
50% of the reason I switched
IntelliJ is also fairly widely used. Just stay away from NetBeans if "wide usage" is a concern. ;)
Any sources on this? Every last development conference I attended IntelliJ always had more hands up when asked Eclipse or Intellij or whatever
IMHO (and this really is just that: opinion): Paid IntelliJ &gt; Eclipse &gt; Free IntelliJ In other words: if you're considering "community edition", I think you're better off going with Eclipse. More add-ons, more support, bigger community. However, the paid features of IntelliJ are really nice.
What are the extra features offered with paid vs free
You can't do a simple web-search? Ok, fine, take a look here: https://www.jetbrains.com/idea/features/editions_comparison_matrix.html In summary, paid gives you JavaScript support, duplicate block detection (to aid in refactoring), first-class support for major frameworks (Play, Spring, Grails, GWT, etc), DB tools, etc. Now, Eclipse already comes with the JS support and DB tools, so you start to see why I say Eclipse is better than free IntelliJ ...
Another thread like this? Why?
&gt; Eclipse is a defacto industry standard. The latest show of hands I saw at Devoxx Belgium show that a very large majority use IntelliJ, many more than Eclipse. I don't know where you're from or if that maybe is local to Europe but I would not say Eclipse is the "de facto standard". Also [this poll](https://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-2016/) supports an IntelliJ majority. 
I vastly prefer Eclipse for performance and usability reasons, but many people seem to like IDEA. Try both and find what you like.
Some minor things **I** like more in each * Eclipse: costumizable perspective and view, type lookup, search and navigation, debug inspection / expressions / display, pom.xml tag doc, polyglot / variety of plugins, OSGi support, creating runnable jars and other artifacts * IntelliJ: smart autocompletion, dark theme, framework support (got payed edition), variable values in debug editor, Streams debugger, parameter hints, search in preferences menu, key bindings menu, wizards, installing updates
You are right. I was mistaken.
People say you have to pay for HBO to watch game of thrones too. There are always ways. 
*losing loosing != losing
You are right but not for the reason you mention. The reason nothing is required here (as many others have said) is because of the character array in String being `final`. Without this (or proper synchronization) references to partially constructed objects are possible due to permitted reordering of instructions. Reads and writes of references (themselves, i.e. the addresses) are atomic, but the construction of the object that is referenced is not guaranteed to be complete, or in other terms its state might be stale to another thread thread while the reference itself is not. This is counterintuitive but is described quite well in Java Concurrency in Practice, for instance in 3.5.1 (the Java memory model spec of course describes this too, it just isn't always the easiest to digest). The VM in the blog post is in fact broken though, since the `final` modifiers guarantee safe publishing in the Java memory model. Finally, my original point was not so much the blog post issue but about the author's statement about mutability in general.
I beg to differ. We (Azul) have plenty of customers using our Zulu binaries built from the OpenJDK and passing the full TCK. There are also many people using it for free.
Indeed, this might lead to quite a bit of additional complexity. As a library vendor with Java 6 support, for instance, it's rather tricky to support the different JDK API versions. For instance, `String.join()` cannot be used, even if the development JDK (e.g. 8) might support it. But the benefit probably outweighs this rather minor annoyance (which is caught by using CI).
You didn't hurt anyone, I'm sure. Everyone who has expertise in a profession from years of work is quite accustomed to strangers with almost no expertise jumping in with their uninformed opinion on how things should be done. All you did is make his eyes roll.
That's like saying nobody in their right mind uses Linux
https://github.com/craigmiller160/KotlinCommons Not really a lot of documentation, since I mostly made it for myself. Just about everything has unit tests though, so if you look at them you'll see examples of how to use the code.
Please tell this to the guys doing QuickFIX/J.. doubles everywhere in their API. Already the BigDecimal/Double conversion really sucks. I do love rounding everywhere....
Note that in Java an *inner class* means specifically the pattern class A { class B { } } where an instance of `B` will inherit a pointer to an instance of `A`, and consequently can, for instance, access fields of `A`. Contrast a *nested class* class A { static class B { } } where an instance of `B` is completely independent of `A` and so requires an explicit reference to `A` to access its fields. This has implications for performance, and especially in embedded development inner classes are a source of accidental leaks. Lambdas, incidentally, are functionally more like nested classes than inner classes but are still technically different.
Intellij marketing?
Honestly, it's not worth bothering with. Most people who proclaim the advantages of SOLID don't actually do it, and end up just writing whatever code they were going to write anyways. The few who do actually follow the so-called principles invariable end up writing ridiculously bad code. * SRP: While you don't want "god classes" that do everything, anemic 'single responsibility' classes can be even worse. Look for a balance. * OCP: No, you don't need to make every class inheritable. Nor is there anything wrong with adding new features to an existing class. * LSP: Ok, yea this is really important. * ISP: Originally this dealt with improving compiler performance in C/C++ like languages by breaking up header files. The interface being segregated was the API, not a Java/C# style abstract `interface`. Now it generally means, "mindless use abstract interfaces everywhere even if it makes the code worse". * DI: Dependency injection is one option, but it isn't always the best option. Sometimes it is better to fully encapsulate a class in order to make it easier to use. Sometimes the class is better served by a service locator rather than dependency injection. And again, you don't necessarily need to wrap every damn thing in an abstract interface, even when using DI.
What makes them not principles is the fact that no where in the literature does it offer any suggestion as to when they should be applied. Saying, "A class should only do one thing, unless you have a good reason not to" isn't helpful to junior programmers. By adding that caveat you've rendered the whole principle meaningless. 
I default to as restrictive of a visibility as possible. If OuterClass is the only thing that ever uses InnerClass, this design is probably fine. Don't show people things they don't need to think about. Now if InnerClass needed to be public, then I would agree with you.
Well if his problem was clearly explained at the begining we would not be debating about my expertise.... Communication is a skill that everyone should work on in that profession. ;)
Could not agree more :)
Sry, grammar nazi spotted
Your code is wrong. When you type 31.9989 that is a floating-number which is only an approximation of 31.9989. You can never assume it is 31.9989. Sorry, but you might have to read up upon floating-point. Your code should go directly from a string to BigDecimal (and the same way back). Never pass through a float or double.
I love and agree with your views. You should write a book, "SOLID meets the real world".
Probably not a book, but I have toyed with the idea of a series of articles.
Most linux distros use it by default. There's very little reason to be using Oracle JDK if you don't need commercial features and you don't do swing gui.
Plain maven builds are terribly slow though.
This is all well and good but should be said that ModelMapper is quite slow - even compared to something like MapStruct let alone doing it yourself.
I don't see how j2html could possibly catch on unless CSS and JavaScript were somehow woven into the mix and I can't even imagine what that would look like. The web page lists the reasons they came up with and released j2html, short HTML pages like login pages. I'd rather use plain HTML or JSP or JSF (depending on what's already in use) than j2html to keep from having so many technologies to deal with. 
Because you mention using static as a replacement, static should only be used for methods that don't modify a state because they're not threadsafe.
Eclipse marketing?
Whether a method is static or not doesn't affect its thread-safety. Non-static methods aren't thread-safe by default, you need to do some synchronizing or locking for that to happen.
Two months ago the boss told me they had not enough developers and too many software testers, so I had to recycle myself. I grabbed the first thing I found, the Oracle Java Tutorials , a lot of doubt solving browsing on stack overflow and stuff like that, annoying friends that code and other coworkers... Then yesterday they tell me to speed up, get the OCA certification ASAP (and giving me a folder of exam preparation resources) and start as a junior developer with the seniors directing me. Last time I coded anything was with Visual Basic 10 years ago in class and I swore I would never ever code again. Life sure likes to bite you in the ass. Today I thought Generics were fun and then the type Erasure lessons made me wish I had never stopped drinking. But I need to hurry and know the minimum before they create the study group for the cert... No academy, no teacher, just internet tutorials and a lot of Methylphenidate.
&gt; OCP: No, you don't need to make every class inheritable. Nor is there anything wrong with adding new features to an existing class. OCP has nothing to do with making every class inheritable. OCP is basically about making sure to define "right" abstractions and making it easy to define different implementations for them. &gt; LSP: Ok, yea this is really important. Aaand it's broken all the time, even in jdk. &gt; ISP: Originally this dealt with improving compiler performance in C/C++ like languages by breaking up header files. The interface being segregated was the API, not a Java/C# style abstract interface. Now it generally means, "mindless use abstract interfaces everywhere even if it makes the code worse". No. ISP is about keeping interfaces small and oriented on specific use case. &gt; DI: Dependency injection is one option, but it isn't always the best option. Sometimes it is better to fully encapsulate a class in order to make it easier to use. Sometimes the class is better served by a service locator rather than dependency injection. And again, you don't necessarily need to wrap every damn thing in an abstract interface, even when using DI. The fuck? Do you even know that DI stands for *Dependency inversion principle*? I am sorry, but unless you really understand what SOLID is and where does it come from, you have no rights to critique it.
&gt; You will never catch all possible error conditions in development unless you can cover every possible data edge case your code could possibly see. Which is why we have unit tests and integration tests. I get what you are saying but I feel like what you describe is a really really really edge case. So saying that you have issues with DI for those cases only is a bit extreme. If DI is good enough for 99.999% of the possible scenarios, it makes sense to use it rather than avoid it for the 00.001% cases it makes debugging more difficult as you say...
&gt; Do you even know that DI stands for Dependency inversion principle? Toss a coin, some people say Dependency Injection others say Dependency Inversion. Now this is where it gets really stupid. A lot of people say "dependency inversion", then talk about nothing but dependency injection. Not that I blame them because there's no such thing as a "dependency inversion principal". There is a dependency inversion technique, but if you invert a dependency and then invert it again you just end up right back where you started. You can't actually look at code and say "this dependency was inverted". (Though you could say "this dependency should be inverted" in some cases.) 
Just drop the appendix and you have a principle 😆 I think a beginner can grasp a better meaning from this than from telling him to write classes with high cohesion... "just do one thing" leads to high cohesion in more cases than not to give him any advice, don't you think so? You have to face it: Lots of devs will remain mediocre for all of their lifetimes - it is a good idea to promote principles to them. Of course lots will be abused and violated - but without any rules the world of coding would be even darker imho!
&gt; OCP has nothing to do with making every class inheritable. Before it was reduced to "do whatever you want", OCP was grounded in early OOP theory. There was a time when it was believed that inheritance would solve all the problems. So you made your classes "open to extension", where extension specifically meant inheritance. Then to solve problems with backwards compatibility, classes were "close to modification", which meant you never added new features and only touched them for bug fixes. This was widely used in COM programming on Windows. And it was the guiding principle for designing abstract interfaces in Java and .NET before the introduction of default methods on interfaces. *** Of course these days it just some wishy-washy bullshit about "defining the right abstractions" without any concrete rules or guidelines. Basically a meaningless phrase. 
Yeah but static methods are a bit more dangerous because you don't need instance. It just sounded weird to me to say "I only need it once.... maybe I can make it static"
Sadly there aren't many alternative CLR languages, which is quite a shame I do love C# though
&gt; ISP is about keeping interfaces small and oriented on specific use case. Yes, but again that "interface" was not originally a Java `interface`. It was an interface from API or Application Programming Interface. When ISP was originally proposed the interface in question was a massive header file that was used all over an application. Breaking up the module behind it wasn't a possibility at the time. But build times were ridiculous because every time the header was touched everything had to be rebuilt. By segregating the interface into smaller header files, each component could reference just the header that applied to it. And thus no longer needed to be rebuilt when unrelated parts of the original interface changed. It's a powerful concept that can be applied to designing and publishing open source packages. *** Java doesn't work this way. The closest analogy might be replacing 'interface' with 'JAR file'. But that's still a useful even then, build times in Java aren't usually bad enough to justify needing this concept. So not understanding the history and context behind the principle, Java developers morphed it into parroting general advice about how to create abstract interfaces. *** They actually did the same thing with "program to the interface, not the implementation". This was originally advising people to use a libraries public API instead of screwing around with pointers (or in Java, reflection) to directly modify a data structure's internal state. But since such wankery with reflection isn't common in Java, they instead took it to mean that you have to use interfaces everywhere. 
An Oracle-funded body says they're authorized to increase their commitment to an Oracle-owned community project. And there are people somehow taking this as something other than a sign of Oracle cutting ties with that project? /popcorn /slingshot
I'm all for principles and guidelines, just not SOLID. I would love for someone to write a .NET Framework Design Guidelines equivalent for Java. Stuff with mostly programmatically verifiable guidelines that use the word "Do", "Do Not", and "Consider" rather than the hand-wavy bullshit we find in SOLID. And if there are exceptions to the rule, those exceptions are explicitly listed. Here's an example chosen at random: https://msdn.microsoft.com/en-us/library/ms182153.aspx It tells you why the rule exists, how to fix violations of the rule, and when to ignore the rule.
Unless your unit tests duplicate every data submission payload - positive and negative - every network issue - loadbalancers down, certificates expired - issues with loggers running out of disk space, etc, you aren't going to catch all possible errors that your production code is going to see. So do all of your unit tests operate in an actual production-like environment? 
We have to upgrade our environment before we can move to Java 8. The version of Solaris we use only supports 7
😱
&gt; I don't see how j2html could possibly catch on It won't, and it really shouldn't. It's apparently in demand in some strange niche part of the market, with 4k downloads in august. I don't really know what that niche is, but as long as there is a demand for the library it I will maintain it. It's actually pretty fun to work on. &gt; I'd rather use plain HTML or JSP or JSF (depending on what's already in use) than j2html to keep from having so many technologies to deal with. The idea was that if you know Java and you know HTML, you pretty much know j2html. It should be a lot easier to pick up than JSP/JSF, but if you have something in a project for generating HTML already, there is no reason to use j2html. 
Heh :) Pass my regards to Tene.
Thanks, it does look fun, but more niche as you said.
My Java files are sync'ed on Google Drive all the time. I have no problem whatsoever with this. So, it's likely something unique to your setup.
If you plan to buy groceries, it's best to make a "list", to "capture" the "requirements" of what is needed so you can optimize your time at the "store". Unless the context is data capture then it could be anything like video, audio, logs, buying habits, ISP's selling our browsing data, etc. In debugging, it can be stack traces, screenshots, logs, a saved Docker image or even a full VMware or VirtualBox VM to aid postmortem analysis. 
Weird. I have been using Google Drive to upload files for a long time and I've had no problem.
What the? Guys, DO NOT, i repeat, DO NOT use google Drive or similar services for sharing code, they are not designed for that and you will run into a lot of issues. Learn how to use a decent version control system, such as git. There is github, or gitlab, you can store your projects there, and share them in a more structured way...
&gt; Of course, migrating to microservices is much more complicated That may be because there is no consensus yet on what a microservice actually is: https://en.wikipedia.org/wiki/Microservices "There is no industry consensus yet regarding the properties of microservices, and an official definition is missing as well." 
**Microservices** Microservices is a variant of the service-oriented architecture (SOA) architectural style that structures an application as a collection of loosely coupled services. In a microservices architecture, services should be fine-grained and the protocols should be lightweight. The benefit of decomposing an application into different smaller services is that it improves modularity and makes the application easier to understand, develop and test. It also parallelizes development by enabling small autonomous teams to develop, deploy and scale their respective services independently. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
There are a lot of different means depending on the context. One meaning is to "capture a local variable" in a closure (a.k.a. lambdas or anonymous functions with state). Here is an essay on the topic: http://bruceeckel.github.io/2015/10/17/are-java-8-lambdas-closures/ P.S. All of the terms above are not Java specific.
To "capture a stacktrace" just means that you have a copy of the stack trace. That is to say the list of functions currently being called when an exception occurred. Without a copy of the stack trace in the log, it can be difficult to understand what went wrong.
&gt; So do all of your unit tests operate in an actual production-like environment? Actually some of them (not all of course) run in **the** production environment. Right after every deployment. Anyway as I said, discarding a whole principle (i.e. DI) for the 00.001% of cases where is not suited is not the way to go IMHO 
&gt; Sorry but "just use new" doesn't cut it if you have many autowired/injected dependencies - you'd have to create LOTS of new instances to bring up a test case. As a unit test is meant to run over a "small, self-contained" piece of code if you have many autowired/injected dependencies you most likely are missing some abstractions which will make your code more maintainable and testable
Or BitBucket (free private repositories) or Gogs (self-hosted and lighter weight than GitLab).
I don't understand. I'm a beginner programming student and I need to share files with fellow students for collabs. They are just files, nothing special. 
this seems like the one I am referring to. lol
Whatever really, as long as it is meant for keeping source code...
They are not just files, they are source code files that you are trying to share and work on collaboratively. Google drive, Dropbox, and similar are terrable for this. Use git and a service with free private git repos like gitlab or Bitbucket. Or even GitHub if you want the project to be public or get a premium account (they are cheap, and maybe you can get a student deal?). Git (and other source control tools like hg, SVN, etc...) Are specifically designed for collaboration on code so are much better for this.
I've been working at universities at post-doctoral level for a while now and everyone I know uses Dropbox to share code within and between universities. At my last uni I'm aware that version control repos had been requested to IT support on a few occasions over the year but had never been supplied. The university prefers people use NT network shared drives, but that doesn't work for all purposes since all external collaborators use Dropbox. Maybe it's different out there in the real world though... :)
Following on the example I gave, if every DAO in an application makes use of some feature such as e-mailing catastrophic errors (such as an invalid query that can't run), how would you disable that for testing in a clean fashion? If the DAOs are meant to be unit-tested, that emailing feature has to be disabled. Typically services contain one or more DAOs inside them as well, what would you do if you are going to unit-test services in a way that a DAO it uses won't start trying to send e-mails or run some other process that doesn't matter for the unit test? What abstraction am I missing to enable easy testing without DI?
I understand what you want to accomplish, and sharing code is very important. However, simple file storage solutions are not the way to go. The simplest scenario where you have problems is that two of you work in parallel on the same file, and you both save it, one will always automatically overwrite the other's code, or will at least present the conflict in a manner that is hard to resolve. Version control systems solve that problem. When a conflict happens, VCS reports it and offers means to fix it. I understand it can be a bit intimidating at first, we all went trough it, the time you invest in learning how to use one of the free hosted vcs systems will save you a lot of time and nerves in the future, and even more time and nerves of the people who will be mentoring you. Goerge uses a VCS system to keep his code and share it, George is smart, be like George.
Oh, I've met companies that liked dropbox, it's not exclusive for universities. But what can I say, it is bad practice, people should avoid it if they can...
Yeah I see it now. The fact that non-final field assignments in a constructor are not guaranteed to be visible to other threads after the constructor completes is...surprising, to say the least. It seems perfectly reasonable for method calls from multiple threads to have those sorts of reordering issues, but allowing the *constructor* to do it just seems like it's asking for trouble. Granted I suppose back when they were defining this they probably just assumed you'd slap a `synchronized` on everything that needed to be thread-safe and not worry about the performance hit. I already use immutability and final fields for *almost* everything in my own code anyway, but now I'm sitting here trying to think if there might be any crazy case where a mutable field supposedly-initialized by a constructor might leak to another thread in an unsafe manner, ugh.
Yes, I have to admit I had exactly the same reaction a while back. In believe the language spec (i.e. not only the memory model part) should be much more "in your face" about this.
The first thought that came to my mind was type erasure and the "capture-of" you see on generics from the compiler.
Not for sharing code, but I always use Google Drive for my coding. The immediate sync'ing avoids losses between pushes to the SCM.
There's not a meaning specific to the context of Java. You can use it pretty broadly all over the place. Like this method captures user input. Or we capture database values in this collection.
I would really like to see examples of considerable verbosity for modern Java code. At least code that is clearly inferior to C# code, since that gets all the praise.
If you want to do micro optimizations you don't understand how the JIT works. In this case I also recommend reading a good Compiler book that shows how many optimizations are already done in compile time. I dare you doing micro optimizations after that ever again.
I don't really understand what is the conclusion of this article. If the answer is "it depends, and there are tradeoffs", we knew that already. Actually this is the most usual answer to any engineering problem.
Losses?
We have a similar but entirely in-house library; it is indeed very niche, and for all but the most specialized of use cases it's more lines and more work to do it in pure Java than rely on a traditional view. IIRC, its earliest form was originally written to handle a deeply-recursive tree structure, either in full or certain branches at a time, and this wasn't particularly easy (or at least elegant) to accomplish in JSTL. 
Huh... I've always referred to this as "closing over" a variable (technically a *value* in Java). I think I've heard "capture" before too, but I think it's a bit ambiguous.
That's probably more correct so far as computer science gies, but I still see 'captured' and 'lifted' quite a bit in language agnostic discussions.
Win!
For CDI at least there's always a `Bean&lt;T&gt;` registered for every type that's injected, so you can look up these and inspect them.
It saddens me that you don't have a todo web app in the examples. /s 
&gt; The immediate sync'ing avoids losses between pushes to the SCM. Or causes losses because your desktop woke up and started syncing old files. 
Another voice that's going to tell you the same thing. Use git. There's no way around having to learn it anyway and it's much more suitable for working together on code than Google Drive is. 
Obviously without looking at code we may not both be thinking of the same situation. From the description you have given it seems like you want an error reporter injected into DAO - unit test can run and assert that mocked error reporter is called when appropriate. Error reporter is configurable per environment, sending emails in some, just logging in others, etc etc 
Awesome, then go for the music! And sound processing. I have worked a little bit with this library before: http://www.javazoom.net/mp3spi/mp3spi.html Regarding the SQL. Although you might not love it, databases are used pretty much in all industries so it's a good to know at least the basics. 
Take a look at [fsharpforfunandprofit-blog](https://fsharpforfunandprofit.com/posts/property-based-testing/)
I have my own GDrive account that is not shared (as I wrote above "NOT for sharing.") I write code, it syncs immediately with the GDrive giving me an instant backup every time I save in the IDE. If anything should happen, such as hardware failure before I push the code to the SCM, I have a ready back up. 
Focus on the principle of the example - which is disabling a certain behavior that is deeply ingrained in multiple places of a given piece of software - not the example itself; Otherwise you sidestep from the question of how to "just use new" cleanly to make unit tests run without depending on stuff that doesn't matter for testing or has to be mocked . I used e-mail as an example for simplicity. It could be anything - performance monitoring of a given query, getting some intermediate result from somewhere and replacing the process with a mock to return a fixed value, etc. It doesn't really matter as we just want to replace a dependency at the root of a class hierarchy. What is the abstraction you mentioned one could use?
Create zip archive and upload it.
I can't find the GitHub repository with the completed project but I'm on the phone. Is one attached and I'm missing it?
You're missing the point. It can easily overwrite stuff that you're currently working on. It works two ways. This is especially bad if you're working in a team on a shared directory like the OP is doing: if a teammate overwrites a file your local changes get overwritten. Drive is meant for syncing of files, not back-up and not source control at all. 
Most people don't have the time/patience to read a good Compiler book, and thus the truth therein becomes largely irrelevant to most people. Maybe I can rephrase my original answer that way...
That's what cavemen said about humans building houses to live in.
Thank you, I'll check this out
You probably mean [Wildcard Capture](https://docs.oracle.com/javase/tutorial/java/generics/capture.html), e.g. you might see an error where `List&lt;?&gt;` somewhere in your program is not the same as `List&lt;?&gt;` somewhere else in your program because they are different captures.
A pretty common approach these days is to push all logs into Elasticsearch generally with the ELK stack. You can then use a separate alerting framework (pagerduty or something) to trigger alerts based on error rates in the logs. The Alerting frameworks usually handle not sending the same errors multiple times once someone ACKs the alert.
That's what I thought. And for the sake of anyone else who comes here wondering what type capturing is, it's when the Java compiler infers the type of a wildcard generic. Docs on the topic: https://docs.oracle.com/javase/tutorial/java/generics/capture.html
This can be done with just Jackson in two different ways: 1. `return objectMapper.convertValue(myEntity, MyDto.class);` This even has the benefit of using already defined converters. 2. Use Jackson's @JsonView. Seriously. This allows you to serialize a subset of your entities and avoid exposing any internal-only properties. Spring MVC also makes it really easy: just annotate a request mapped method with @JsonView.
How about Dozer?
Can't say I've ever used it but according to this https://github.com/arey/java-object-mapper-benchmark it's even worse
BTW for the longest time you could only run hadoop on java 6, even when that was long EOL.
ELK and having the time to fix the issues causing the errors
https://issues.apache.org/jira/browse/LOG4J2-926
I'll just leave you with this particular issue I had to debug a couple of weeks ago, you can see how it would have hit your environment. We have a standard web service that is called by the UI that generates specific request records. The requirements of this are specifically that duplicate requests are supposed to be blocked. A duplicate is determined by a mostly natural key on the record but with a create timestamp within a certain window. Because of the variability of that window we can't rely on a unique index catching dupes. So the service performs a select based on the natural key part and if the count &gt; 0 it kicks back a duplicate error. We started getting calls from customers that they were getting errors making the request and when they looked at what was recorded it was showing duplicate entries in the database. We looked and there were duplicate records but no entries in the service log related to them. So first I pulled the source code for the service and went to look at what it was doing. It was using an injected instance of a class that handled the data access. There was no import of the implementation class only the interface so I had to find out where the implementation was. First thing I did was look in the pom file for dependencies and only saw a testing dependency on the mock instance of the interface. Next I looked at our components and found there were two instances of the interface, one used by legacy code, one a newer one so I looked in the generated war file for which one was used. No luck, neither implementation jar was present. So I asked DevOps to look on the server and tell me what was there. Turns out this is running on a newer app server that supports the module capability and this particular library is deployed as part of a module, not as part of the war. So now I had to pull the deployed module and see which code was in that archive. Finally I was able to figure out which class was doing the work and I looked at its source code, and didn't see an issue with how it was written. I then started trying to figure out if there was an issue in the call into the service and I spotted an issue. We run the service behind a load balancer with two instances running. The loadbalancer logs showed calls to the services but only the URL, not the content because they are POST requests. So I looked at the timestamp on the records in the database, found corresponding entries in the loadbalancer logs. Saw an initial call followed 3 minutes later by a connection timeout. Turned out that there was a disk issue under the database, the services were getting backed up and the load balancer was not getting a response from the first call so it treated service instance 1 as being off line, and sent the same call to service instance 2. Both services now have the request, neither saw an existing record in the database and both wrote it out. The customer saw an error from the initial call due to the time out. All the code passed all unit tests and QA tests and load tests, but it still worked incorrectly because of an environment issue. We're still working out the best way forward to prevent this in the future since the services did exactly what they should do. It took almost a half a day just to find the code to look through once DevOps figuring out what was deployed and then I had to look at logs not created by the application to find the problem. So anecdotal but it is the types of issues I've seen more than I'd like.
What does this mean? Was it unexpected? Did Oracle just throw the entirety of Java onto Github? Does Oracle still own Java? Does this mean Oracle doesn't care about Java anymore? I desperately need context here.
I also would like more context. This appears to be a ridiculously big deal. If they really did that...good on you Oracle about time you started working with us instead of against us.
Looks like the enterprise edition spec and reference implementation are now hosted on github instead of java.net.
We currently use log4j 1.2.6 for our app level log handling with an SMTP appender. We also have Splunk, but that currently captures info level stuff and the cost per GB per day is a little nuts, so we can't move our 100+ apps over to it. Someone was talking about setting a listener then email when an error line is added, and not sending more in the timestamps are close. I'll take a look at some of things you listed. Thanks
&gt; Was it unexpected? There have been signs showing that Oracle is not very interested in Java EE and it's all but been officially confirmed. This seemed like the next logical step. They're going to take a less active roll in Java EE development and instead put it in the hands of the community. &gt; Does Oracle still own Java? Yes. They did not open source the Java language. They open sourced Java EE, which is the 'Enterprise Edition' of Java. Java EE provides various APIs that are orientated towards enterprise development. It's built on top of the Java language. &gt; What does this mean? This shows that Oracle wants to take a more hands off approach with Java EE, and put it in the hands of the community. This means companies like IBM, Red Hat, Spring and others who are interested in Java EE can take a more active roll in its development. I think it's an overall good thing for Java EE. &gt; Does this mean Oracle doesn't care about Java anymore? No. This has to do with Java EE, not the Java Language. 
I understand now that JavaEE and Java are very different things but related. Additionally, you mentioned this move seems to signal Oracle's "hands off" feeling towards JavaEE. Does any of this signify possible future shift of Oracle's policy/feelings/stance on Java itself? 
Why do you upgrade to old releases, though? Wouldn't it be better to upgrade to the newest release that's considered stable enough (and if you're developing on Java 8 then you must consider it stable enough)?
&gt; JavaEE is now on Github. It was already there, for atleast [4 months](https://www.reddit.com/r/java/comments/65fn09/javaee_is_moving_to_github/). Also Java EE is [moving to an open source foundation](https://blogs.oracle.com/theaquarium/opening-up-java-ee) after the Java EE 8 release, mostlikely Apache, maybe Eclipse. Often that includes having a repository at the site and only have a mirror at github if at all.
Yeah, I've seen that before. I just don't want to manually map all the fields with these other mapping frameworks. Dozer is pretty simple to use as long as I keep up my naming conventions. I'll probably try out Orika or Selma though, can't ignore those benchmarks.
Isn't this a good thing because it ensures the longevity of JavaEE rather than letting it slowly fade out?
If you plan on getting into programming (particularly professionally), take the time to learn to use git, I promise it's worth your time. You will thank yourself later.
It only makes sense with unambiguous types like mathematical constructs for which those operations are well defined, currently BigDecimal and BigInteger could also benefit, watch out for unexpected Nullpointerexceptions though. You have to be cautious to use it for stuff like money, because money has currency and can you really add 5 dollars and 5 euros in a straightforward way? What do you do if someone tries this, throw an exception? String concatenate already works, maybe you can do list + list? But if you add an ArrayList and a LinkedList, what is the resulting type? So it might seem straightforward, but you have to be careful. Also, operators are poor function names. A symbol doesn't convey as much information as a method name. And can you add javadoc, would it show in the IDE, etc...
Oracle felt burdened by Java EE because they had to maintain a free open source reference implementation, GlassFish. Now that they are freeing themselves from the API (but not the trademark name Java EE), they can focus more on their paid implementation WebLogic.
In the short term you could probably keep the SMTP appender but have it send the emails to an alerting service such as PagerDuty or something similar. It would then take the alerts and alert whoever is oncall but it wouldn't send tons of emails it usually sends 1-2 before it escalates and once its ACKed no more alerts fire. Then you can later migrate to a better logging solution and tie that into the alerting framework instead.
It could be a good thing for Java itself, as Oracle will be able to allocate more resources on it. IMO it's a good move.
Yeah, there are certainly a lot of details that would need to be sorted. out. Value types are not nullable, so a NullPointerException won't necessarily be an issue if operator overloading is restricted to them. And I would certainly hope JavaDoc can be written somewhere.
The whole universe would be better off if Oracle hands over Java to Apache or some other community. It would be perfect if they'd just handed over everything they got from SUN to the community. 
Java 8 wasn't available in our production environments when our applications began migrating to Java 6. 
Thank you all for your information 
Straight from the horse's mouth yesterday: https://www.reddit.com/r/java/comments/6y28an/two_jdk_release_a_year_starting_next_year/
Here is my list of useful books and mock exams for 1Z0-808, you may find it useful. http://javarevisited.blogspot.sg/2017/04/ocajp-1z0-808-best-books-and-mock-exams-Java8-certification.html#axzz4ruFd0P7a
No. It has no bearing on Java the language and related SDK. Those are still firmly in Oracle's hands and there have been no signs of reduced interest in Java from Oracle. 
Isn't the JVM already sort of handed over with openjdk? This means that you can be free of Oracle if you use Kotlin/Scala/Groovy, openjdk and Wildfly/Tomcat/...
Considering that code generation via annotation processing breaks incremental builds with Gradle, I've option to just wire up my own dependencies by hand. Essentially, manually implementing Dagger2's code generation. This isn't as difficult as it sounds with Kotlin.
The best way would be a static set of math operators on classes extending Number and no way to define other arbitrary operators. 
Do you NEVER read what I write? I've now told you twice that the GDrive is used by me only and not for sharing, but for immediate backup until I push code to the SCM. Please stop the patronizing explanation of problems that cannot exist in the setup I've now described twice. 
Great, there's nothing worse than wanting to look at the sources to some Java project and finding that it's only browsable on a website with a UI that was outdated in 2002.
Would love to have this added, although not restricted to numerical types. The whole point of operator overloading is to define the mathematical relationships of your class instances.
Sort of, but not fully. Oracle still retains strong hold on various aspects of Java. Notoriously, license requirements for embedded systems. Also, take note about the Google-Oracle suit on Java API. 
So Glassfish is going away?
You are using it as a backup, the OP more or less asked about using it as SCM. Two vastly different things. You are just adding noise to a thread that is giving the OP great advice about using version control instead of Drive (noise that may lead OP to think it is ok to use Drive as version control since they may not understand how you are using it vs how they want to use it)
When it comes to open source, Oracle is damned if they do and damned if they don't.
This has absolutely nothing to do with Java in the slightest, maybe you will get better help on /r/GoogleDrive/. Although please heed the advice from the other posters and do not use Drive to share source files. There are quite a few free source hosting sites available: Git: * http://github.com (have to pay for private repositories) * http://gitlab.com * http://bitbucket.org Subversion: * http://riouxsvn.com (free private repositories) 
What do you mean by "They did not open source the Java language" ? what about OpenJDK? 
Oracle also just layed off a bunch of people in their hardware and Solaris operations, not sure how that could be related though.
I'm not sure they're just going to hand over something they paid 7 billion dollars for.
I seriously doubt Oracle is allocating more resources to Java EE
prediction: it's either Eclipse Foundation, or they'll create a new foundation from scratch. Apache is unlikely.
lol
apache is unlikely IMHO. It's either Eclipse Foundation or they will create their own foundation for the occasion.
I did some research and it seems like Oracle wants to phase out proprietary stuff from the JDK to the point they're both basically the same. They realized that the 3rd party licensed stuff they use in their JDK is difficult to maintain and might be better off using an open source alternative.
I could see a case for datetimes such as `Instant.now() + Duration.of(5, ChronoUnit.SECONDS)`. In this case it could return the same type as the first argument.
To be fair, it looks like OP was asking about both backup and SCM: "I want to upload my java files (xxxx.java) to Google Drive so that I always have access to them..." 
I am not sure Java was SUN's cash cow. SUN made money from h/w sales, right?
Yeah, SPARC. Interestingly enough, I just heard on the news today that Oracle is doing massive layoffs in their hardware divisions.
I wouldn't worry. The semantics of another language you learn will be similar to Java. You'll have some way to do I/O, selection, repetition, etc. Things like syntax might be different, though, and certain features might be absent. For instance, if you are learning C, you won't be able to declare classes or use Strings easily. 
So does this mark the JavaEE renaissance or the JavaEE death rattle? 
Yeah, this is what I was thinking. Although, if operator overloading was restricted to value types, it would have to be some sort of interface.
&gt; SPARC Good old SUN Solaris SPARC!
Wisely put.
It's the right choice, in last Java EE edition they decided just replicate what Spring did, they saw how powerful community is.
Don't like them, don't want them: * For non-numeric types, you get people wanting "&lt;&lt;" and "&gt;&gt;" for I/O, "~" or "+" for array concatenation, "()" and "[]" for container classes to pretend to be multidimensional arrays, and more. No one can just stop with numbers. * Even for number-like things (vector, matrix, tensor) you either get an explosion of overloads to cover all of the potential type combinations or you end up coercing everything into the most general type. Not worth it. Java codebases need to _last_, not just be convenient. 
I know the popular college in VA teaches Python but I don't have people to ask in the colleges I was thinking about. Thanks!!
No problem!
Yeah, overloaded shift operators for I/O is just terrible.
Then you get super cool custom operators like `&lt;|*|&gt;` because everyone knows what that does!
You're supposed to adapt! I recently went through the same thing. I graduated from University of Washington a couple years ago and am working as a Software Engineer in Seattle. During my time in school (2011-2015) I took 2 quarters of Java, 2 quarters of C++, 1 quarter each of Assembly, C, and Java again, then 2 quarters of Python. I got an internship doing some C++ but mostly C#, then landed a job doing C++ for a year, and now work almost exclusively in Java. Your goal should be to graduate **able to become** an expert in any language you'd be comfortable working with full time, and is desirable to employers. Make sure you have a language you're comfortable writing syntactically correct code by hand in (you will have to whiteboard during an interview; pseudo-code is not always allowed, and is less impressive). I wouldn't worry too much about trying to identify which language that might be; for me it was simply whatever language I had spent the most time with in the last few months. 
I'm coming to this thread a bit late but I had to respond due to the amount of FUD being spread. First, let me tell you about me. I started Java server side development in 2000 using basic servlets. By 2005, Spring had come onto the scene and revolutionised server side development, especially in enterprise shops. I was a big fan because they emphasised testability of classes and to enable this passing in dependencies (via constructor or setters) was critical. This allowed classes to be easily unit tested by providing mocks for dependencies. No need for Spring in unit tests. Then the question became how to manage the dependencies to these classes in a running application. Spring was the first framework to popularise DI. Initially there were no annotations (it was made into a JSR spec later because of its popularity) and instead you would write an XML file stating the class and its required dependencies. So to answer the first question about knowing what class was being supplied to a class - check the xml file. Later, IDE tools provided feedback if a class was missing and navigating to the class dependency. Even later, (well now) XML was done away with and you would have separate classes for providing the different dependencies. Now everything is in Java code. There is no way you would not know how the dependency would be satisfied (assuming you used IntelliJ/Eclipse, not sure about Netbeans). Another important point is that the object graph is instantiated at *startup*, not at some random point in the running of the application. You knew straight away if a dependency could not be satisfied because (a) no class of the right type could be found or (b) multiple classes could be found and it was ambiguous which to use. In the latter case, the annotation supported a simple naming mechanism to distinguish between multiple types (Qualifier annotations). The app *failed deployment*. Another thing to note that is typical of the dev shops I worked in is to seperate environment specific settings. So what that means is that the *same classes* are instantiated during dev, testing and prod but different environment variables would be provided depending on the server environment. &gt; Easier for who, the developer? Because it definitely isn't easier on the poor operations team trying to debug a production issue. Hopefully, now you realise this does not happen. The last 4 years, I've switched to Android development where Dagger 2 is the defacto DI solution. I'll be honest I am not a fan. Its overly complicated (compared to Spring) and I have real doubts about its stewardship with Google. For example, it went many months with no development and recent android-specific functionality is beyond simple. My advice is avoid Dagger 2 on the server side, there are better options (Spring, Guice, Picocontainer) and only if you absolutely must have maximum performance (at startup) where reflection is too slow, consder it.
Definitely!
Neat! Use those liberally anyway despite their licensing issues. 
&gt; in last Java EE edition they decided just replicate what Spring did What did Java EE 8 exactly replicate from Spring? 
renaissance ;) 
Indeed, and that hw often (but not mandatory, of course) was running Java server software.
GlassFish as name, perhaps. But Payara has forked GlassFish some time again and works hard on it.
I'm just guessing here, but Oracle is moving away from licensing on-premisse software and selling hardware and moves completely to a cloud offering vendor, with their database perhaps being an exception.
That's probably a pretty good assessment, Oracle along with everyone else is pushing cloud a lot.
Why so? 
In my case, becoming a certified asociate got me my current job. I didn't have an IT background but with the certificate I could prove my grasp of the concepts. I'm currently trying to get OCP certified to fortify my abilities. Background info: In my area there is a high demand for junior developers. Some people are switching careers because of this, and they start with a traineeship. The OCA certificate is usually part of this training. If you already have experience in Java you could try to get your OCP. However, if you apply for a job the best way to show your skill is to showcase some of your code.
Well I don't want to speak to the specific implementation but it could be done at the compiler level - just like we have with + for Strings. 
Embrace the new language: start coding it, reading the API documentation, scour stack overflow. You'll get your bearing in the new language quickly. And you'll still remember quite a bit about Java, though you'll be out of practice.
Apache is perceived as a graveyard for failed heavy-weight projects. The match would be perfect. I think Oracle may not letting it end up there for reasons of reputation. 
&gt; They did not open source the Java language. The JDK is already [open source](http://openjdk.java.net).
People complained that Oracle didn't have an open source development model for Java EE and accused them of being greedy corporate overlords. Now that Oracle is moving forward with its plans to have an open source development model for Java EE, people are complaining that Oracle may be abandoning Java EE.
&gt;Evolution of software craft came to the point, when we start thinking about SCM as ultimate source of truth about project version. Version should not be hardcoded in pom.xml or build.gradle. hmm. I don't agree with this. SCM and versions are usually mentioned together, but they are completely independent. &gt;If there were any commits after last tag, project is in SNAPSHOT version. This very simple and intuitive philosophy.... No it is not. What if I want a temporary tag for a DEMO version of my software? What if I have multiple tags for parallel versions? (think multiple customers of the same software). I can see your point, but this assumption will only work for the happy path scenario. 
That's probably because Spring developers were heavily involved in those standards. For example Java EE Batch was led by the same guy in charge of Spring Batch.
Very interesting story and thank you for sharing it. However it turns out that this was a racing condition with the load balancer and not a problem with the DI framework. Correct? I mean, even if you knew right away what is the implementation, you should still investigate the load balancer. Also I am a little bit confused with what you describe. You are saying that the lb sent the same request to two apps? This is either a very smart lb or a very buggy lb. I thought that lbs just monitor the health of instances and route traffic of other applications. They do not decide by themselves to retransmit staff. Finally if this is such a hard requirement it is obvious that you need a queue somewhere in this process (or some other mechanism of acknowledging the messages) Attempting to have independent services behind a lb to detect duplicates is a losing battle. So in summary, I don't think that the DI framework is to be blamed &gt;you can see how it would have hit your environment. I would have used a queue/gateway app that actually routes messages. This way it could have the whole history of everything and could take decisions on duplicate things in a much smarter way.
&gt; Yes. They did not open source the Java language. They didn't open source the Java language **now** because Sun already did it a decade ago... before Oracle even bought them. That's what [OpenJDK](http://openjdk.java.net/) is, although it's not on Github.
This is true, but I don't think they'd ever implement it that way for all types.
I don't get this sentiment. Apache also manages Hadoop, HBase, Storm, Flume...
Take a look at https://sentry.io/
Hooray!
https://github.com/allegro/axion-release-plugin/issues/197 ^^ open release issues on a release plugin. oh the irony!
Apache has a pretty big interest in seeing Java EE continue to evolve, Tomcat is still one of the most popular servlet containers out there. I think it’d be a good fit.
Oracle only requires commercial licenses for their build of the JDK, you can build OpenJDK for embedded systems if you want or use Azul’s pre-built package without licensing headaches - yay for OpenJDK being released under the GPL.
Recompiling on non android codebases is not a time issue in this case.
So many ifs and elses. Good for us, ain't it? On a side note, Java coders are famous for generating complex entanglements of monolithic if-else code blocks.
Do you want lawsuits? Because that's how you get lawsuits.
I would really love if threads about updates to any software would contain a short explanation what that software actually is.
You made me laugh. 
Nah, just make sure the server you're pointing it at says "dev-" in the title. http://www.oracle.com/technetwork/licenses/wls-dev-license-1703567.html I am fundamentally against developing with non-free software though so it is problematic from an ethics POV
the Builder pattern uses an inner class https://stackoverflow.com/questions/5007355/builder-pattern-in-effective-java
&gt; Nah, just make sure the server you're pointing it at says "dev-" in the title. Awesome! I'm now going to distribute torrents from a server with "dev-" in the 'title' (assume you mean hostname)! Great advice! Thanks!
&gt; Apache is unlikely. Strange. I recall a twitter poll of some Java bobo (forgot who, sorry) where a vast majority of respondents were in favour of Apache. I personally don't see Apache as a place where projects "go to die", there's a ton of great apache projects (Spark, Cassandra to name a few). 
&gt; I don't get this sentiment. I really don't see that sentiment either. Like I said in a previous comment; a twitter poll showed a strong (more than 2/3rds) preference for Apache. 
A few days ago actually. That last remnant of Sun is basically gone now; they laid off somewhere around 1500 people IIRC. 
Operator overloading is definitely something I look for in a powerful and extensible language. I like it from C++ and Scala. Guy Steele has talked about its importance for growing a language. The usual argument against it is abuse. Sure, it can be abused to unintuitive extents but so can every other feature. The fact that something can be incorrectly overused doesn't mean nobody should have it, especially if it leads to more readable code. The usual argument for it is numerics. This is true and in Java would apply to BigInteger and BigDecimal. Programs with mathematical nature in business logic would benefit but that's a minority of programs, especially in Java. I think the most notable use of operator overloading is equality checks and maybe comparisons. Unfortunately it is pretty much impossible for Java to start using `==` for actual content equality checking (`equals()`) without breaking backwards compatibility. Other languages with operator overloading have shown this to be a completely viable and intuitive way to implement equality and comparison of user-written classes.
We use ELK (or actually EFK, ElasticSearch, FileBeat and Kibana but that doesn't sound as cool) in our application. All our microservices just log to std out, this gets stuffed to a file which then gets grabbed by filebeat and uploaded to ElasticSearch. Based on some Kibana searches we have a warning system where if there's more errors than we expect some alarms go off (slack messages, emails and SMS notifications). Personally I feel the 'old' ways of having to grep through logfiles is completely outdated. 
There isn't a day that goes by where I don't have have a coupla apache libs in my dependencies..
Did you read the license?
Whoosh?
No, GlassFish was already open source and it will remain so, it's just that the burden to maintain it has been placed on the same community that wants to maintain Java EE. There's also Payara, basically a GlassFish++ version which I think will remain large contributors to the GlassFish codebase.
In what fucking way? If I begrudgingly use a tool for which I have a license to that's somehow akin to torrenting?
Dunno why people are piling on you, they do allow that in certain circumstances. I use them too.
You implied you can get away with breaking the law if you have "dev- in the hostname". How is copyright infringement with software licenses different from copyright infringement with game of thrones episodes? You either have the rights to the materials or you don't, the name of your server has exactly zero value when you're taken to court. 
&gt; either have the rights to the materials or you don't, the name of your server has exactly zero value when you're taken to court --- From the fucking license &gt; Oracle grants You a nonexclusive, nontransferable, limited license to internally use the Programs, subject to the restrictions stated in this Agreement, only for the purpose of **developing**, testing, prototyping, and demonstrating Your application and only as long as Your application has not been used for any data processing, business, commercial, or production purposes, and not for any other purpose. Kinda seems like where you use the application has a lot to do with whether or not the blanket license applies to you.
The greatest enemy of progress is not stagnation, but false progress. - Sydney J. Harris 
It's a html builder. You chain statically imported method calls to mimic the structure of html: body( -&gt; &lt;body&gt; main(attrs("#main.content"), -&gt; &lt;main id="main" class="content"&gt; h1("Heading!") -&gt; &lt;h1&gt;Heading!&lt;/h1&gt; ) -&gt; &lt;/main&gt; ) -&gt; &lt;/body&gt; 
Yes, Hadoop would be a perfect example. I never worked with it and I'm not saying it's a failed project or anything, but it appears far too heavy unless you are actually Google or Amazon doing rocket science. I mean, their logo is an elephant.
Thanks, I got that from the page. My point is that news about updates to libraries are usually only interesting for people who already use it. I didn't know j2html so the information that there's 1.2.0 isn't interesting to me. Perhaps add "Allows you to write HTML with Java fluently" or something like that.
That's not what u/gogostd said.
&gt; From the fucking license God you're angry. &gt; only for the purpose of developing Which isn't what you're doing if you are running something serving customers. 
This isn't an article, it's an advertisement for Bintay: &gt; So if you’re ready to give your package world-wide fame, go ahead and open an account on Bintray. &gt; ... &gt; To start with a free OSS account, you can sign up here. &gt; If you’re ready to go Premium (Pro or Enterprise), go here.
Hi All, I represent the London Java Community (LJC) on the Java Community Process (JCP) Executive Committee (EC), aka the Java standards body. I also help run the Adopt OpenJDK programme for OpenJDK outreach and onboarding new developers to work on Java itself. Now that the acronyms are out of the way :-). We're working at the JCP with Oracle to streamline the standardisation process in order to facilitate these faster releases and provide other Java vendors the ability to run their reference implementations against an in flight Technical Compatibility Kit (TCK), which is what you need to pass in order to call yourself Java. I'm really, really pleased that Oracle is increasing the cadence. Java 9 allows for incubation modules and so if something isn't ready, it can simply be put in there for early testing without it impacting the main release. Some folks asked about alternative platforms. In terms of providing high quality releases of OpenJDK for alternative platforms we've created a portal at https://www.adoptopenjdk.net with the build farm run via https://ci.adoptopenjdk.net (code in various repos at https://www.github.com/AdoptOpenJDK). We've only just received the Java Test Compatibility Kit J(TCK) from Oracle and once we have the binaries tested against that then folks will be able to get the latest OpenJDK binaries for all of the esoteric platforms (ARM, z360, AMD variants, AIX, Solaris and so forth). We'd love for folks with devops skills to come and join us (Docker, IaaS, Jenkins, make skills welcome). If you have any specific questions please throw them my way!
Lol sorry I meant latest Java EE, not the last one. Java EE replicated everything from Spring because their job is set the standard and Spring became the defacto industry standard (and pretty much still it is). For example Java EE CDI is Spring core, MVC is Spring MVC, Batch is Spring Batch, etc.
I could see it being fine for a limited context, e.g. for types extending `Number`, doing `x + y * -z` turns in to `x.add(y.times(z.negate()))`. BUT... then the whole thing would fall apart in to a holy war over disagreements about whether to allow `x == y` to mean `x.equals(y)` and this is why we can't have nice things.
OP restricted it to value types, so there's no `equals` problem. &gt; Identity comparison. The == operator on objects performs an identity comparison; on primitives it performs a bitwise comparison. (…With an asterisk for NaN.) Since a value type does not (necessarily) have a pointer, this operator does not apply to value types. The logical candidates for interpreting == on value types would be componentwise == comparison, or invoking an equals method. (If the former, the VM needs to provide a mechanism to perform the bitwise comparison, since some components may be private. Even if the equals method is used uniformly, the implementation of the method may benefit from a bitwise operator at the bytecode level. See vcmp below.)
Others like Apache Spark are also used by smaller companies. E.g. 9gag. Rather Eclipse Foundation seems like a graveyard.
You're unlikely to need it if you're just doing a small at-home project, but Hadoop and associated products are perfectly suited for small companies. Data ingestion, processing, persistence, and searching are all capabilities of these systems that I've seen companies much smaller than Google leverage.
know all about one of the most popular programming language JAVA. 
&gt;Java EE replicated everything from Spring Not really... &gt;Spring became the defacto industry standard Sorry, but not really... &gt;Java EE CDI is Spring core Lol, not really. CDI is inspired by JSF Managed Beans, EJB, Seam and Guice. JSF Managed Beans were a full bean model and DI solution based on XML, pretty much like in Spring 1.0. JSF 1.0 and Spring 1.0 were released at the same time. EJB pioneered the annotation approach, when Spring was still pushing you to do massive amounts of XML. CDI introduced contextual injection and portable extensions, both way ahead of what Spring core ever had. If anything, Spring reluctantly followed Java EE here by going the annotation way. &gt;MVC is Spring MVC MVC is not in Java EE 7. It was a new JSR for Java EE 8, but was dropped at some point. &gt;Batch is Spring Batch Batch is largely based on IBM's batching systems. IBM already did batching before most Spring team members were even born. Plus, Spring actually participated in the Batch JSR and Spring Batch is a fully compliant Java EE Batch implementation. &gt;etc. I wonder what that etc is...
When value types are introduced, will they be able to have any internal lazily constructed fields? That might mess with things.
Currently, all value type fields must be final, so they can not be lazily initialised.
We have log files, and using Spunk would have been our solution except they charge us per GB of logs sent, so the more apps we stick on the more it costs. I think we have a 15 GB/day limit which costs around $15,000 annually, and that's only used for some of our mission critical stuff and Apache logs. I was reading up on ELK, one thing I'm confused on is the pricing and what comes out of box for it. Is it OSS and they charge for support and cloud services?
It's OSS, you can get a support contract but you don't need it. So basically it's 'free'.
The postgres logo is an elephant, too.
Many apache projects either have svn to git mirrors on github or have asf git to github mirrors. Many projects have processes for accepting prs from github. Asf repos only being on github and not on asf infra is unlikely.
I do not know who holds that few. Apache has a number of very large and successful projects.
... k
In my experience, every company/boss has a different idea of what junior/senior means and may have different expectations about it. sorry for not being specific at all, but that's what I've seen in real life. just my 2¢. edit: now, for advice, always be working on something (take care of boundaries on this, the goal is just to demonstrate that you are capable, and when you don't know how to solve/do something, you will be the guy that doesn't stop 'till he solves-or at least contributes to solve- the issue, and not the guy who is willing to mop the floor with his tongue if asked). Just keep a positive attitude towards superiors, companions and coworkers in general, and you'll do well. Congrats for your new job! edit 2: also keep bettering yourself in every way you can!also keep in mind that attitude is like 70% of success! (I got that statistic from my ass, I know, but it really seems like attitude plays a BIG part in it!).
A realization that I recently made, as a senior developer (~15 years), is this: Gaining experience is no longer a motivating factor for me. I have experience. I've done enough things to know that I can learn whatever I need to learn and deliver for an employer or client. I don't need to prove this for myself any more. As a younger developer, this need for experience was a huge motivator. It makes me realize that to really provide value for my employer, I should be working with less experienced developers. I have a desire to coach/mentor, that's motivating for me, and see others grow. They have a desire for experience, that motivates them. The combination is a formula for success. On my own, I really need to push myself to get things done. I can do it, but it's not as easy as working with younger developers has been in the past several years.
It depends on the background of the developer but in general for someone with little/no experience developing in industry I would expect: * Basic development skills: no expectation of knowing/understanding any specific frameworks or any particular language, but you need to know how to read and write code to the point that you can contribute something at some point in the near future (if you've brushed up on java knowledge and have a CS degree, this should be no bother) - it usually takes a few months to get up to speed. * The junior dev to be keen to learn and develop their skills: in reality this means asking questions when they get stuck (leveraging resources online and their colleagues). Caveat: there's a limit to this, try to make sure you fully understand what is being explained to prevent the need to re-ask the same question multiple times. If this means you have to take more of someone's time to make sure you "get it" then you should at that point rather than going back later. Asking intelligent and thought out questions shows you're interested and will gain you respect. Other than that if you're keen to do some reading that might help prepare you, here's a couple of things you could possibly look at (wide ranging, not essential or exhaustive, just my opinion about some of the things I would look into if I were in your position): * Brush up on some design patterns (Gang of Four book is generally recommended). Having a basic understanding of software patterns now will help you in the long run and hopefully help you to design high-quality (and reusable!) solutions. * If you've never worked in an agile team, have a quick lookup of scrum/kanban/agile techniques and the sort of tools they use day-to-day. You'll get this as part of your day-to-day but understanding what a standup is for may help you to make an impact when you start your work (and possibly help you to contribute to things like retrospectives). If your team isn't agile then it will possibly give you ideas for the future on how your team could work in a more productive way. * Lookup development techniques like Test-Driven-Development (TDD), other automated testing methods, Continuous Integration/Delivery and the industry tools around these * If you're looking to brush your development skills up some more, try some coding challenges online (there are a bunch of sites like project Euler/HackerRank). Practice makes perfect! One of things I found helped when I started my first role was to list my achievements during each week (or where I'd struggled). I would then chat about them to my manager in our one-to-ones and they would be able to point me to someone who might be able to help when I did get stuck. Just try your hardest and learn as much as you can! Congratulations and best of luck with your new role! 
I would not recommend TDD for a junior dev. TDD implies a lot of things : SOLID principles, simple design, yagni, kiss... Why is it important to test your dev? Or what problem TDD is solving ? are questions that I expect a confirmed dev to be able to answer but not a junior. For me, you should be ready to learn a lot. And you should be open-minded, to question yourself. Aside from that, if you followed a graduation in computer science, you should be ready. Btw, never forget that even if you got your graduation, you know nothing :)
Well, I have to grant you that. But knowing how much optimization a compiler really does is an eye opener and shows how many micro-optimiazions are already done by the compiler. Especially with the JIT in Java, which is an incredible piece of software engineering.
I think is great, but too overuse-friendly. It is mostly a cultural problem. In c# (in my experience) it is used with moderation, and it is a great addition. In Scala (mostly a couple of years ago) everyone was overusing operator overloading and was horrible and unreadable. I have faith in java community to use it in rational levels. If not, at least I'd love some build-in operator overloading like +-*/ in BigDecimal, BigInteger, and &gt; &lt; in comparable (= is up to discussion). And [] to access lists/maps! You can try it now in java using [Java-OO](http://amelentev.github.io/java-oo/) . It is a lombok level hack, so it works in the IDE, it works in maven, but it is not trully java.
i have mixed feelings. just see scala for the psychotic onanism this stuff can devolve to.
yagni and most of solid is pretty easy to understand. I think that pure TDD is unintuitive and finding your version of TDD takes a good of time and practice, so you might as well start off with trying it and figuring out what works. I agree with the rest of what was said.
 - Don't be afraid to ask questions, but put some effort in trying to make things right. - Listen to advice and try to not repeat the same mistakes over and over again. I had to fire a guy who simply could not avoid writing duplicate code. I can't recall how many times I had to point out he was writing the same thing over and over again. - Try to improve yourself. For my first job I had to work with javascript but did not know a lot about it. I used my time out of work to learn as much as I could about the language and it made quite a difference. Don't wait to be spoon-fed and don't be content with what you learn at the job only. You will become better than your peers very quickly if you try to build up knowledge around the technologies you are using at work. - That said, don't waste time with hipster stuff. It's better to learn some legacy technology instead that is established and likely used by other big companies - it will help you land your next job - This is not your last job. Switch jobs once you realize there's not a lot else to learn (2 years is the average) 
Looks very interesting. Would be good to see this integrate with Apache Spark.
Ooooh. That's nice. It's _really good_ at profiling things, but the production license was far more than what I would have considered it worth. 
&gt; *Ask not what your junior developer can do for you. Ask what you can do for your junior developer* -- John F. Kennedy
Every Java game I have ever played had a problem with stuttering due to GC.
I make no difference between Juniors and others. In some fields even a Senior is a Junior but he often forgets it. In general I expect from developers: * Beeing curious and open minded * Willing to learn * Kean to speak about mistakes (own/others) * Good communication skills * Self organizing * Humor Knowledge of code is useful but IMHO easier to compensate than lack in any of the above categories. 
This is an employee market where I am at so my expectations are pretty low to be honest. We just try to hire bright people with any kind of general knowledge of Java. I.e. it's easier for me to list what I DO NOT expect from a junior Java developer - Build tools familiarity (maven, gradle) - Frameworks knowledge (Spring, Dropwizard, Juice, etc) - App servers (tomcat, JEE-antyhing, etc) - Source control knowledge (SVN if anyone still uses it, GIT, Mercurial) - IDEs (Eclipse or IntelliJ) As far as the actual language itself, I don't expect them to know anything except for the basics. I.e. I DO NOT expect: - Concurrency / Thread Safety / Immutability - Advanced generics - Lambdas - Writing own annotations - Intricacies of memory management / GC - Intricacies of Java spec (i.e. did you know EXACTLY how unboxing is supposed to behave with mixed argument types in say a ternary operator?) - Advanced IO - Logging - Being able to sense good coding style I do expect basic understanding of classes, collections, Strings, basic IO, and most importantly ability to google for the relevant libraries that already do shit that you are about to write. The latter I cannot stress enough: Apache Commons and Guava are your best friends people! :) 
I would look into game engines like Unreal Engine or Unity. They are all free to get started.
Agreed, TDD for Juniors is questionable at best. 
By far the easiest way to get started would be with something like Unity. 
Dont need this
So, you're probably not going to jump into work straight away. I've been a JavaEE developer for a little over 5 years and have spent my last few months onboarding a new person. In the beginning she was doing mostly reading, but she had front end experience so we've let her do quite a bit of angular work to get familiar with our stack. The java has been a little slow but she really likes it and is learning fast. If you want to help yourself get up to speed, don't spend time reading, spend time coding. It's honestly the only way to get better, practice. The more familiar you are with beans, annotations, the java standard library, etc the better. Learn how to use encapsulation, inheritance and abstraction in Java. 
Based on your writeup, nowhere. It sounds like you never learned it the first time around, and this isn't something you can just pick up in two weeks. 
https://docs.oracle.com/javase/tutorial/ would be a good start if you have forgotten everything. How much Java experience did you have before? Things like defining and using variables are things you should never forget if you've used Java for a reasonable amount of time. Realistically you aren't going to be able to learn and retain much in 2 weeks, especially starting from scratch, so just focus on the parts that relate directly to your coding assignment and don't try to learn things that aren't needed.
I expect you to know how to write java. I would also hope your school had been teaching you up to java 8... Which is streams and lambdas.. that would be nice. I do not expect you to know anything about spring, REST... I'm not even sure I'd expect you to know maven/gradle although I'd hope they'd been teaching you that. Basically I'd expect that after I show you the existing code and said "you need to do something similar to this" you could run with that and come back to me when you get confused. I'm a big fan of Jr. Dev's as long as they can do that. 
Lol, well thanks for the suggestion. I'll definitely be back on here to let you, if not anyone else, how it went.
That's the route I was considering because of the sheer volume of material. Thanks for confirmation and the resource will check out.
&gt; TDD implies a lot of things : SOLID principles Uh no. Those are completely unrelated concepts. &gt; SOLID principles, simple design, yagni, kiss And those are contradictory. Adding a bunch of interfaces and DI is the exact opposite of YAGNI.
I strongly disagree. While you can certainly over-complicate things, TDD is just a formalization of basic programming techniques that even beginners have been doing for the last 50 years. 
Testing. Can you write a function that adds X+Y and write a test that shows it works? I know it seems small, but I've met far too many so-called senior programmers who can't even do that much. And if you can't check your own work, you have no ability to learn.
I will expand on the design decisions vs design principles: Always consider the principles ( SOLID and/or others ) when designing the code. If applying them does not increase code size or complexity, just do it. If applying the principles would make the code too verbose or too complicated for your liking, go ahead and ignore them. Later, while implementing your design, or modifying or reusing the resulting code, if you run into complications, re-evaluate the design against the principles. You might realize that the complications could have been avoided by applying the principles. Estimate the pain of using the code as is against the pain of refactoring and take action to reduce the pain. You just gained valuable experience and insight. Rinse and repeat until you are a guru. 
Unity is based in c# or javascript, but almost everyone uses c#. Unreal is c++. Id recommend one of these two engines, though. C# is really similar to Java.
Potential above general knowledge 
Sidebar: &gt; Please seek help with Java programming in /r/Javahelp! 
&gt;And they did. They adopted many of DropWizard ideas – for example the concept of self-runnable jar with all dependencies or healthchecks support. This is simply not true. People were creating self-runnable jars long before DropWizard appeared, so it is certainly **NOT** their unique idea. 
Have a look at [LibGDX](https://libgdx.badlogicgames.com/)
&gt; * Build tools familiarity (maven, gradle) &gt; * Frameworks knowledge (Spring, Dropwizard, Juice, etc) &gt; * App servers (tomcat, JEE-antyhing, etc) I might be looking in the wrong place, but every time I've applied for a Java job, even entry level, I've been pretty much ruled out for not knowing these things.
As someone who's written two games in Java, my answer is a definite 'no'. This was five years ago, with Java 6. Java 8 nowadays makes things a bit easier, thanks to the introduction of functional interfaces. But Java is still purely object oriented, which isn't a good basis for writing games. You can model things out pretty neatly but when tying things together (implementing the game-loops and stages), you'd be happier with a language which allows for a more functional approach.
6 monthly sounds a little much to me, perhaps 12 months would be better... but I'm partly basing that on it sounding cooler to name them Java 2018, Java 2019, Java 2020..., rather than Java 18.3, Java 19.3, Java 19.8...
lol no
Come to Germany! All our schools are free and they all teach old-school java!
Which language do you think I should go for then? 
Being sober in work, having open mind and willing to learn and most importantly - being able to think about a problem on his own before asking for help. 
Well if you don't follow those rules you end up with creating 15 mock per test, or break everything for each change... Your comment prove that you don't know those principles and your test suite is probably very fragile. Even if experienced developers don't understand the power of TDD, I won't expect a newbie to follow it
I'd prefer a newbie that is able to do code that work without tests than someone that create a test suite that is bloated and breaks everytime you make a small change... Before running you should learn how to walk
I don't have any experience with the "big" game engines on the market but believe that you should take a close look at their communities and consider using one of these. You're going to need a lot of support if you want to produce something of decent complexity. If you want to start from scratch and don't have the requirement of producing something fancy (regarding graphics, sounds and controls), use C(++).
And how are they supposed to know if it works or not without tests? Hope and prayer? 
/u/aretebit are you going to explain yourself further?
I'm assuming you're learning java at the moment and want to work as developer soon? So please trust the guys that told you to use some kind of source code management like github (or any other). Yes, you'll have to learn how to work with that and you'll have to learn at least the most basic concepts of source code management. But if you want to work as a developer later, that's one of the base skills you'll need every day. And by the way: when you're on a job interview one day, ask them about their source code management and if they're telling you something about a shared drive, don't say anything, just stand up from the table, turn around and run, run as fast as you can. And don't look back at those monkeys claiming to do professional development without using source code management ;-)
You have a point but a bad test suite is worst than no test suite at all.
_You have a point but_ _A bad test suite is worst than_ _No test suite at all._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^Balduracuir ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
They should be testing their code regardless
"The Problem With Quotes Found On The Internet Is That They Are Often Not True" -- Karl Marx
Back in the day the majority of games were written in C++ and nobody complained that C++ is too object oriented for writing games. 
I know at least 2 very big studios that are using all kinds of Java frameworks for their backend systems. You know the things that register the players scores, their in-game purchases, saved levels, etc. For the actual game I don't think Java is the superior choice. But you can always prove everyone wrong, like the Minecraft guy did. 
No TDD != No unit tests. 
One of the early things to know is that the more predictably you behave, the easier it is for your team to support you. You are going to run into roadblocks. Of course you should try to figure them out, but please also communicate with your team that you ran into the particular problem and where you're looking for the solution. Don't be afraid to ask for help. The best way to do this is to come up with your own approach or potential solution and then ask if you're heading in the right direction. You will learn quickly, and soon become a valued member of the team! 
I would expect and appreciate honesty.
Depends. Java is not as slow as many people tend to believe, and it is entirely possible to create a game that easily outperforms Unity and Unreal - especially on mobile platforms. Modern JVMs are beasts. The real problem is the lack of tools: you'll find a ton of libraries for the math, AI, ECS and networking parts, but not so much when it comes to the actual game engines. [LibGDX](https://libgdx.badlogicgames.com/) and [jMonkeyEngine](http://jmonkeyengine.org/) provide decent abstractions for 2D and 3D rendering respectively (among other stuff), but afaik there are no huge communities or commercial backing behind them. It seems that both of them also lack proper graphical editors, making them "frameworks" rather than full-fledged "engines". More coding, less features, (generally) longer development time. My advice? Don't focus on the tools too much. Try one and stick with it, unless it completely does not work for you, or it turns out to miss a crucial feature that blocks your development. Choosing a lower level framework will help you understand internals of popular engines, but they "waste your time" in the sense that you're likely to finish your project faster with something more high level. If your goal is to _develop games_, a high level game engine with graphical editor is the way to go. If your goal is to learn and you want to improve your skills and tool set in the JVM world, try LibGDX or jME. Hell, if it's just a hobby project, give [Scala](https://github.com/ajhager/libgdx-sbt-project.g8), [Kotlin](https://github.com/libktx/ktx) or [Clojure](https://github.com/oakes/play-clj) a chance.
This is very frustrating to me. A lot of these things are not things you learn in college, they are tooling for the job. Requiring them from juniors is ridiculous. Some of them like Spring I would be hesitant to require detailed knowledge of even from senior people. I.e. there are so many flavors of Spring workshops out there in the wild it's kind of crazy. Annotation configs or XML configs? Spring MVC on Tomcat or Spring Rest on Spring Boot? Fighting the monster (EJB) Spring is slowly become the monster it saved us from. Argghhh. 
I'm in the process currently, replacing a centralized tomcat based controller that routes to several distributed tomcat nodes, so far so good. Not the top of the priority list though so it is taking a while chronologically, but very few person-hours needed so far.
Can someone point out what has changed on both frameworks, two years later? 
For a Junior Developer in ANYTHING * Don't expect to change the world until you've been in it for a while * No massive rewrites * No including the 10 latest and greatest libraries * No insisting things are done to accommodate you until you're proven (someone on /r/programming asked someone to crap out a REST API to fulfill their fantasy of using REACT / Vue the other week, it was very annoying) * Basic data structures, when they make sense (not even b-tree, just maps, arrays, linked lists, stacks &amp; queues, basic data-types) ### Java Specific * Java Project Structure for shared library or executable * Either maven, ant or gradle basic syntax * What an anonymous class &amp; or lambda is (so you don't vomit blood or start dropping them everywhere) Everything else can be learned (including hopefully TDD as it is a growth accelerator for thinking as a programmer)
What do you want me to explain further? Is my word against yours. If you lived those times when everyone left java ee for Spring (absolutely everyone, the only one job offers for java ee were for maintaining code, because of how awful it was) you couldn't deny my statements. Oracle saw that the founder of Spring was right and they had to adopt Spring's features to survive. My answer is: Yes really. If you do not believe me go and argue against wikipedia guys becuase I have better things to do that argue with dogmatic people: "Starting from Java EE 6, Java EE is trying to incorporate and standardize concepts/features from and merge with Spring framework. The SOAP with Attachments API for Java (SAAJ) is now part of Java SE 6, and is thus available to Java EE 6 applications without needing to be included in the EE specification.[1] The Java API for RESTful Web Services (JAX-RS) is now included in Java EE.[2] Java EE 6 also standardized DI, AOP and others from Spring into Contexts and Dependency Injection for Java, Dependency Injection for Java, Bean Validation, Managed Beans, and Interceptors." (from: https://en.wikipedia.org/wiki/Java_EE_version_history). Even Oracle people shows gratitude: "Thank you Spring framework for filling the interim gap and providing functionality that is now included in the mainstream Java EE 6 application servers. The Java EE platform has evolved over the years learning from frameworks like Spring and provides all the functionality to build an enterprise application. Thank you very much Spring framework!" (from: https://blogs.oracle.com/arungupta/why-is-java-ee-6-better-than-spring) My answer is yes really, in java ee they simply copied what was working with spring because it became extremely popular and java ee clearly failed. And yes really, it became de facto and still it is in some grade, if you do not believe me read the first page of "Learning Spring Application Development" by Ravi Kant Soni (2015) which says: "Spring is now a long-time de-facto standard for Java enterprise software development." CDI is a cheap copy of spring IOC. I am not talking about the invention of DI nor batch, is the way of doing it, and they just decided catch it because it became very popular in spring. Sorry I am not active user and don't know/ can't format this text nicely.
Check out OverOps. No need to manage errors and exceptions through email at all, retain the stack local data when one does occur for debugging.
What a terrible website. Regardless of content, that non-native scrolling made me want to close that site real quick.
&gt; "The Problem With Quotes Found On The Internet Is That They Are Often Not True" -- Karl Marx -- Michael Scott
libGDX or jMonkeyEngine. libGDX is more lower level but you can use the same code to target Android, iOS, PC Desktop, even the browser and I tested all but iOS for one I was starting on some time back. I even tried it on a 6 or 7 year old Android phone and it ran fast.
while libgdx is a solid recommendation, Unity is great for just getting something up and running with minimal fuss
I'm surprised you guys keep getting past the first interviews and given these coding assignments. This is a common question on this subreddit, someone lands an interview, gets an assignment and comes on here looking for help. I sincerely hope that when you turn this in and talk to the team again that it is clear that you are unqualified and they don't hire you. You would be doing this team a disservice. Even if you manage to put together some app in a few weeks that meets their requirements there is a ton of other stuff around java development you likely have no idea about. Java is much more than just a language, it's an ecosystem that takes much longer than 2 weeks to understand.
These days? A pulse. Possibly a regular breathing pattern. Being a part of my company's hiring process has greatly altered my expectations of people that consider themselves anything from a beginner to a prodigy. 
No clue what you are talking about.... what is non-native scrolling?
I would not expect, but it is a very nice to have. TDD is not some sort of magical thing only experts can do.
What will they expect from you, or what will they ask of you? These two can be miles apart, and how fast you climb the ladder will be depend on your willingness to do the latter (pun not intended). I could tell you horror stories from my first year, but in the end, I grew exponentially in ability, more so than I could have hoped to do in 3 years of picking up tickets and checking in bug fixes.
Is this a school assignment? 
Changing the color of a button.
How so? If the tests are shite then you just have to rewrite them (or have them rewrite them). Thats what code reviews are for.
All the answers around framework and tooling are generally true, but miss the most important thing in my experience as a former jr, and from working with jrs: You don't know most of what you'll know by the time you're done with your first year. You will be tempted to nod your head and conceal the fact that you don't know what your co-workers are talking about. You must fight this temptation. Ask the question. Own the fact that you don't know shit. Make a list of the stuff you wish you knew about before somebody else mentioned it in a meeting and then work that list. Trust me. A little humility in an entry-level dev goes a long long way.
I'm not sure where you're applying, but top candidates are expected to have some experience with these things. I'm not saying that you should be able to describe or bootstrap a code base with a build tool, but you should be able to say "I have experience using Maven in order to deploy WAR files...blah blah." For example, I use Ant to build, debug, deploy, etc, but I don't really know how ANT works or how to take a codebase without ANT and design a good building solution. I've peaked into our codebase's XML files and tweaked around. I get that colleges don't teach these things, but that's where internships step in. It's just another thing if companies have to teach you the basics of Maven or Ant when instead they could grab a candidate that's seen it before even just for a minor project.
Well, Minecraft is (was?) made with Java, and the dev got a $ 2 bil. payout. So, is it worth it? The question is irrelevant, the idea is what matters. Implementation comes second.
You use ENUMs. Don't tell your professor I told you.
Smells like it
No this is not. I am trying to learn on my own. I learned some Java via Bucky videos on YouTube. I know I need to organize my code correctly. The analogy was in reference to ssh sessions to dslam boxes where I only know the IP but I don't know the box I am going too. 
Build a website or app? Solve a real world business problem with tech.
Thank you.... Looking up an example right now. 
.js is deprecated, it's really just C# going forward.
I'm relatively new to industry as well (3 yrs) but we just had a new guy join so I can let you know what we expect of him. The big things: 1. Be humble, appreciative, and willing to learn. People are more willing to help if you are grateful and capable of accepting criticism (hopefully of the constructive variety). 2. Try to solve problems on your own before asking for help. This will help you grow as a developer. The expectation is that you _will_ need help, just make sure that when you're asking for help it's not with trivial compilation problems etc 3. Ask questions if you don't understand something. I always want the new guy to clarify something with me instead of assuming You will find that succeeding is less about your technical knowledge and more about your ability to work with all different kinds of engineers. Even though coding is a less social occupation you will still be relying on your colleagues. Being able to identify different temperaments and knowing how to navigate them is an invaluable skill you will pick up as you go (when in doubt: be humble). The best advice I can give is don't get defensive about your code. Go into the job understanding you're a junior developer who is going to make mistakes. What people want to see is that you _learn_ from your mistakes and that you're working hard to come up to speed. It can feel bad to always be asking questions, but realize that you have roughly 6 months to a year (this varies of course) to blow a lot of your "dumb question" capital. So use this time to really understand your product from a technical and business perspective so that when you're hacking on production code you have an idea of how the piece you're working on fits into the bigger picture. 
Read [this](http://blogs.microsoft.co.il/gilf/2009/11/22/applying-strategy-pattern-instead-of-using-switch-statements/). The [Open/Closed Principle](https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view) is fundamental to OOP - achieving code reuse by designing classes be open for extension, but closed to modification. You can design a class that can change how it works without changing any of its code. A switch statement is opposite to the Open/Closed Principle. Any time you want to change how the class works, you have to add more cases to the switch statement, which means you have to change the code of the class.
Everyone will recommmend a game engine, but here's an example of what you can do with straight Java if you so desire: https://remnantsoftheprecursors.com/ It's a Master of Orion remake.. you can download the alpha and see how well it plays: https://remnantsoftheprecursors.com/2017/09/01/alpha-4-is-available/ It's more performant than most games in the genre on the market. It runs on a Pi Zero, and can play a game with a million stars on a larger PC. 
I'm not too sure what /u/marvk meant, but the fact that the header takes up half the page (all the time) makes perusing through the details a little frustrating.
What do you want to use Tomcat for? Once you understand what you want to accomplish with Tomcat, you can then figure out how it is done. This will make it easier to make sense of Tomcat's source code, since you have something specific you want to understand. Use the use cases, Luke.
Agreed, Tomcat has so many features I don't think you'd want to try to understand *all of it*.
i looked at the maven shade plugin and it looks like at least 2007 when it had it's first repo checkins. dropwizard's first commit in 2011 looks like it was originally a scala project (!), but that's four-ish years later. that said, the charitable read of that quote is probably that they mean that dropwizard's ideas of how one ought to build/ship a server/service thing were influential, rather than saying that literally dropwizard invented uberjars...(though i admit it does seem sloppily written and could suggest that)
I am using tomcat for deploying and running my war files, I know the workings of tomcat and little bit about its architecture, I am not sure why but I decided to read the source code may be to understand tomcat in depth, and now I am stuck not knowing what to do, also want to know how to debug the source code in Intellij 
I'd expand on that and say my experience was you don't know most of what you'll know by the end of your first month. 
You could always do Project Euler. Not necessarily projects but fun problem solving. Not sure the rules on posting links but you can easily Google it :-)
I'd expect a few things. First, a basic understanding of how version control works. You don't have have to be great at it or have all the commands memorized but you should have enough understanding to be able to get by with Google for the very basics. 10-15 years ago I probably wouldn't have expected it but with the advent of Gitlab, I think it's probably fair at this point. Can you check a project out, look at the history, and then commit a change (with Google's help), then we're good. Second, if you have an issue you should be able to troubleshoot and investigate it. Maybe you can't solve it but you have the determination to try. You shouldn't *always* need to ask for help *immediately* upon running into an issue. (there are exceptions in environments that lack good documentation and leadership) Third, on a related note, you should be able to realize when you aren't making progress, when you do in fact need help. I want my junior devs to struggle enough that they gain critical experience and knowledge but not so much that they feel demoralized or waste tons of time on something that could be quickly answered with a question or two. It's a tough balance and if you can master it you'll be incredibly valuable. Does a junior dev need to know all this immediately out the gate? No. But I'm going to expect them to figure these things out in a couple of weeks to months.
Bots are always a lot of fun, and too a bit of a challenge.
I've solved over a thousand challenges on various online coding sites, and I'll rank the top 3 as: **https://codefights.com** * Amazing UX * Best testcase feedback * Best and clearest challenge descriptions * Best IO, Best language support. **https://leetcode.com** * Reasonable UX * Decent testcase feedback, some unclear questions. * Good IO **https://www.hackerrank.com** * Many unclear questions * 'locked/hidden testcase', unclear feedback. * Uses 'system.in/out for IO, very frustrating. * Well sorted categories, good for non IO stuff like SQL/Euler etc.. The winner is Codefights by a very large margin, I.. just love the design. Only negative thing I can say is that I have almost solved everything on there, but on the positive note they seem to be in constant development. 
Depends on what you want to do. Come up with an idea and build it as a personal project. Almost any large 3 tier project will require incremental steps and, in my opinion, is a really good way of learning. Honestly, build a simple REST API with anything but spring. (Spring is a great tool but there is a lot of “magic” that happens in the background.) It can be a simple repository of user info like when you consume an endpoint it will return contact info for a user. If you have never messed with REST architecture, then go ahead and look up spring boot and what it is. Build a restful api with spring just so you know what it is. (The project takes like 30 min max to create). Then scrap that and build with something else like Spark. This will teach you basic and advanced enterprise programming. Also, build a couple of different databases. (MySQL, and MongoDB are two good ones to learn). If you want to focus only on java, don’t worry too much about the UI. Or if you want to focus less on EE and more on Java alone, research algorithms. Look up big and little endian. But deep dive into advanced topics, the fundamentals will build naturally. 
While I lean towards the other commenters sentiments here's my advice to you. Read the book effective java by Joshua Bloch, look through GitHub for some example Java projects preferably something that has some REST endpoints (learn what a restful API is if you don't know) and really understand the code, the structure etc, go on lintcode and leetcode and do the problems and look through the solutions (only one of them has solutions I forgot which one). Going forward my advice to you is to be hungry . I don't want to make any assumptions but your post isn't a good indicator of passion for cs so far. In order to get past the first few weeks you're going to have to keep learning and at an extremely accelerated pace. Read some tutorials on Java projects. Google Java microservices examples tutorials or something like that and really dive deep into what they're saying. Most likely there will be a lot of terminology you won't understand in those posts. Don't just gloss over them, Google everything you don't recognize and learn. Hopefully if you put your everything into this and have a little bit of luck on your side, you'll be at a semi-reasonable level by the time your team expects you to produce some real work. It's not going to be easy but I don't want to say it's impossible. You're going to have to work your ass off just to get to the bare minimum and once you're there you're going to have to work even harder if you really want to grow as a developer. I sincerely wish you the best of luck. I haven't been working full time for that long but I've been able to be productive bc I consider myself truly passionate about learning more about cs and growing as a developer. I started my journey with cs late (not as late as you but regardless lol) but I am confident in my abilities as a developer when compared to others my age bc I know that even if I'm not as smart or as experienced as some of them, I'll work harder than any of them to learn and grow.
Sorry Mr. McHandsome for whatever is happening in your life that posses you to write an entire 2 paragraphs that are entirely irrelevant to my question. I didn't ask for someone to take a shit on my doorstep, I asked for a list of tutorial references. Material that may have helped you understand basic concepts easier or more expeditiously in your primitive days. So next time you're having some real life issues, why don't you take it the people who are causing you them, not stranger on Reddit who is trying to be optimistic about their opportunity. I hope your dick feels a whole half inch bigger, You keyboard beta. Next time stay relevant to the post and stop ruining the community. Thanks
Sorry just re-read your original post. id prioritize leetcode and lintcode first while effective java will be good foundational knowledge for you going forward. I'm not sure what kind of coding challenge your company gave you. If it's more data structures and algorithms related I would order a Java data structures and algorithms book off Amazon asap and overnight ship that thing while doing leetcode and lintcode. If it's more around building a miniature web app or something along those lines then I'd go with the github route and the google search I mentioned in my last post
Thanks for the resources. I was hoping someone would refer an author. I find learning code much easier with a narrative voice. 
100% building; I'm assuming it's going to be a web app as the mock exam I got my hands on was.
You'll probably get a much better answer from the tomcat mailing lists or irc http://tomcat.apache.org/irc.html 
I expect you to have a basic understanding of logic (how to write effective conditionals, for instance). I also expect you to have a basic understanding of some key pieces of whatever language we are primarily using (for Java, generics and collections). Also, I expect a junior developer to be willing and unafraid to ask for help, but able to do some research rather than resorting to asking every time you get stuck. If you can't figure out why you're getting the error you are, spend at least 15 minutes googling it before you interrupt someone else to ask a question. The senior devs are there to help but they have their own work to complete as well. And if a senior dev tells you to do something a certain way, I expect you to do it that way unless you genuinely think you have a better way that you can explain and get approval for. Initiative is good but sometimes things are done a certain way out of necessity (tying in with legacy systems for instance). 
Figure out *one* thing that Tomcat does that you want to understand. Then study how Tomcat does that *one* thing. Debugging the source code is easy. Use [Remote Debugging](https://www.jetbrains.com/help/idea/run-debug-configuration-remote-debug.html) to "attach" IntelliJ to Tomcat so you can set breakpoints in the source code and step through live running Tomcat. You have to start Tomcat a special way to allow IntelliJ to attach itself: catalina jpda start Tomcat's default port for debugging is 8000.
Read [this](http://paulgraham.com/startupideas.html).
Have they told you it they use a particular framework or not? If they haven't take a look at spring boot and the tutorials they have. They are more centered around web apps. Understand what MVC(model-view-controller) is, have a good understanding of what REST is and how to implement it in java - both from the client sending a request and a server settings up the endpoints and what the different actions mean. There's plenty of examples of this online but be aware different frameworks have different ways of implementing this in terms of syntax, methods etc but they're all based on the same core princples of REST.
Do you have a point or are you just talking out of your ass? Your statement is false in its entirety. C++ isn't an object oriented programming *language*, it's an extension to the C Language that offers object oriented *features*.
/u/aretebit a vague statement on Wikipedia is not necessarily right of course. It likely reflects an opinion of a Spring fan who thinks juist like you. I don't see a reference there that proves that statement. The problem is that people all too commonly parrot each other and the urban myth is strong that Java EE supposedly took so much from Spring. Now Spring has undoubtedly influenced Java EE, especially the developers first approach. But specific technologies, less than you think. JPA for instance was based on TopLink and Hibernate. It's not a Spring invention nor technology. CDI is NOT a cheap copy of Spring. You probably don't know CDI well. As explained here already; CDI was inspired by JSF Managed Beans, EJB, Seam and Guice. The scopes (request scope, session scope, application scope) came directly from JSF. The named aspect of beans and the ability to reference them from Expression Language came directly from JSF as well. The proxy concept and the interceptors came from EJB, in fact the interceptor spec is still part of EJB. The annotation approach came from EJB as well. EJB started with the very simple `@Stateless` annotation vs a ton of XML in some file. So while it's undoubtedly popular among Spring fans to give Spring credit for all those things, if you look in history it's just not true. Then take a look at other popular Java EE technologies. Expression Language... not a Spring invention either. It originates from an Apache JSP library which later became JSTL. Didn't Spring actually copied that in Spring EL? Bean Validation... not a Spring invention either. It came from Hibernate. JTA... again not Spring, this is based on quite old code from IBM from even before Java 1.0 (~1995). JAX-RS, not really Spring either. You could argue it looked at Spring MVC and Spring MVC influenced it, but JAX-RS goes way beyond Spring MVC and is overal clearly the better REST API.
Pretty much like many Spring fans claim DI is Spring's unique idea and every later and even earlier(!) DI system is copied from Spring...
I totally agree, but only giving the word TDD to a junior saying that he should learn it is the best way imho for him to take bad habits. I think no habits is better than bad habits. Btw if you have been graduated recently, you should remember that college is only teaching you the basics. For me designing a good software is not something I would expect from someone coming from college who never worked before. In my mind you can't expect from someone something he was not meant to learn. BUT he should be ready to learn cause graduation is not the end of the learning curve : it's the start of it
Yeah you imply that is someone that is mastering development process. Most of people that come out of school don't even know how git works... It's your role to teach them that, you can't expect that before the guy has effectively started to work... Some people here did not work with juniors for a very long time here. Our role as more experienced dev is to teach them how to work properly. The only thing I expect from my coworkers is that they are interested in what they are doing. The rest is built by the team with time ;)
I don't see any relevance to distinguish between the types of the cars for the use case. So I won't model it 😉 [KISS](https://en.wikipedia.org/wiki/KISS_principle) and [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) are even more important - escpecially as they are independent of programming paradigms!
**KISS principle** KISS is an acronym for "Keep it simple, stupid" as a design principle noted by the U.S. Navy in 1960. The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design and unnecessary complexity should be avoided. The phrase has been associated with aircraft engineer Kelly Johnson (1910–1990). The term "KISS principle" was in popular use by 1970. *** **You aren't gonna need it** "You aren't gonna need it" (acronym: YAGNI) is a principle of extreme programming (XP) that states a programmer should not add functionality until deemed necessary. XP co-founder Ron Jeffries has written: "Always implement things when you actually need them, never when you just foresee that you need them." Other forms of the phrase include "You aren't going to need it" and "You ain't gonna need it". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
r/dailyprogrammer 
I'd disagree. Idea matters only as much as implementation allows, implementation is what matters the most. 
I do think build tools, source control, IDEs and at least basic knowledge of web development (even if just servlets + JSP) should be expected (to a very small extent) from Junior devs. Recently, I've been doing a lot of interviews with fresh graduates, and while I never learned some the things they know fresh out of university, I see that most of them have handled these things in class and have at least rudementary knowledge. Now if someone came in showing experience with JNA/JNI, Android, some other REST framework etc, I'd like to see that just as much. However, I want young developers to at least show some interest in furthering their knowledge of the eco system, rather than keeping it at the absolute basics of the language. After all, they're applying for a Java job - not just any programming language. 
If the scrolling on a website behaves differently than in the rest of the system, i.e. for a normal website, scrolling stops when you stop turning the mouse wheel, but on the website you linked, there is momentum when you scroll like when you swipe up on your phone and it keeps scrolling. Throws the user off for no good reason.
I had to delete the browsers DOM node of that horrible title bar, before I could see the content properly, alas there wasn't a great deal there... increasingly I find more sites with silly large side bars that have to be deleted to make the skinny content viewable - obviously my 1920x1080 laptop panel is too low resolution for some people... *sigh*
myTruck.ifPresent(Vehicle::vrooooom);
Optional&lt;String&gt; address = person.getAddress(); // Someone might not have an official address, so it's optional!
You should say "available for early access", not open, as open implies something very different.
I can't tell if I'm getting trollled or not... I don't see either of those issues... Chrome on Windows 7 &amp; 10 and Android... good luck...
I second [Project Euler](https://projecteuler.net/). The challenges are need little puzzles. You need to write code to solve the puzzles. Solving these puzzles is kind of fun.
Too much time on your hands... sounds rough...
A junior developer should try to find a balance between trying to tear down conventions / suggesting shiny bleeding edge technologies and accepting that some things are done in a certain way because that's how they've been done in the past. As a senior developer, I love the fresh ideas and enthusiasm that junior devs add to the team, but it's my job to understand that we are not developing in a vacuum where we have unlimited time and resources, but have to make due with those constraints. This means that sometimes we will be able to convert legacy software to hipster cloud based microservices and other times we have to add features to the elder monolith beast. A junior dev should look to learn from his medior/senior colleagues, but not be afraid to inject his own ideas if he thinks they are worthy. Seniors should create open platforms where juniors feel comfortable enough to share those ideas. Don't shoot them down with arguments like "that's not how we do things around here", rather say something like "that's an interesting idea that we will keep in mind for when the time is right". A junior dev should not be afraid to get his hands dirty. Most software in the real world isn't pretty, often it's a surprise things work at all. Don't complain if your first ticket is fixing an obscure bug way down in the monolith, see it as a chance to learn about the current way of working and to get familiar with code conventions and such. Have a good work ethos.
It wasn't DI that caused the problem, but that made it take longer to track down the problem which was the point of my original post. DI is fine for the developer, simplifies the development testing models, but when you have to dig through multiple files and configurations to figure out what actual code is running in production when you have an issue, it just adds time to resolving those issues. No different than looking at source code that has a half dozen layers of indirection before you find the actual implementation. The load balancer did what it was configured to do, it called one machine and didn't get a response so it assumed there was a failure on that machine and called the second one and took the first one out of the pool for a short period of time. Then the healthcheck reported ok and it added it back in. You are absolutely correct on a design where you could have any number of horizontally scaled instances trying to detect duplicates. Some form of queue would be a cleaner approach, just have to balance that model with needs to give a synchronous response to the customer. That is what the development team and the architects are working on in their redesign.
Well it is also open source...
It is? Since when?
Community edition is
Right, but this isn't about the community edition in particular and also it's not like it is new that the community edition is open-source. The title is still somewhat misleading.
So what? Games were written in C++ using the so called object oriented features is what he was saying. Also OO is just fine for games. You don't need a fancy Entity Component System just to make a game. Source: my ass. 
So it is. I didn't realize they open sourced it when they released CE. Thanks for the info.
InteliJ IDEA is freemium
Haha, as a developer myself, I'd love for this to be true. Unfortunately, we both know that isn't the case. A good salesman is able to sell a shit in a bag. Technical superiority means jack shit to ordinary people when they have to choose between 2 competing products, only what the salesman is saying matters. Look around. Even with tools used by us, we don't always choose the one that is subjectively better. And is worse with normal people.
What's your point? 
Non-native scrolling is using something other than the native scrollbar provided by the web browser. In this case, the scrollbar looks like it is a pair of nested divs, and the culprit seems to be something called NiceScroll. This is the opposite of nice.
I think IntelliJ has a scene builder.
Tehehe :D
If the source version is the same as the jar version then you can set a breakpoint anywhere and then look at the stack trace. From there you can work backward. In the tomcat source you can also set break points. 
Only a small part of it. The Javascript editor, for example, is not.
Community Edition has been open source for something like 3-4 years now - there's a github mirror at https://github.com/JetBrains/intellij-community - and they accept pull requests. You don't get _all_ features as some are held back to the Ultimate edition - but over time, most of all the Ultimate only features I've used have all moved down to community. I may be crazy - but I routinely build IntelliJ from HEAD@master as my daily driver.
Freemium is crap
Technically it is - as both Community and Ultimate edition now has EAP for 2017.3 is now open ( add the word EAP to the title and you're more accurate ). It's amusing - on more than one occasion when I've tweeted out a screenshot of some awesome new feature that's now available when building HEAD@master I've had replies from JB folk saying I let the cat out of the bag of their upcoming announcement/blogs - that's the price of open source tho.. 
Wait, you are saying that IDEA Ulitmate EAP is open-source? That's awesome if so.
No, only community.
Both now have EAP ( Early Access program ) builds available tho. I should have clarified I meant both when 'open for EAP'
See, this is exactly why the word open is dangerous. :P
Why? 
Last I checked, IntelliJ requires the official Oracle one installed because all it does it runs and renders that inside an IntelliJ view. It ended up being much worse than using it directly because this integration was buggy.
That's a fair statement. However, some of the problems rely on proper data storage and ensuring optimization. 
So I have to bear with it, it seems... Really hard to get grasp of it once you used android ui designer. edit: typo
Because it restricts you from the true emancipation others enjoy because of money. The earth is filled with situations like that. I don't think open source needs that kind of products. It dumbs down people into brands; the best example of that being those people who pay for MySQL clustering when its clone MariaDB has it for free and... It's open. 
So what do you suggest the creators of software do to make a living? And if people are willing to pay to the point that the business is sustainable, why is that wrong? People could use VS Code, Eclipse, or NetBeans (amongst others) but some of them choose to pay for IntelliJ... Clearly they feel that by charging for it they can offer a superior product, and some people agree. 